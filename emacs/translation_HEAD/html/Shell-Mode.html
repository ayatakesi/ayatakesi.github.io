<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Manual,
updated for Emacs version 30.0.50.

Copyright (C) 1985-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "The GNU Manifesto," "Distribution" and "GNU GENERAL
PUBLIC LICENSE," with the Front-Cover Texts being "A GNU Manual," and
with the Back-Cover Texts as in (a) below.  A copy of the license is
included in the section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<title>Shell Mode (GNU Emacs Manual
(Japanese Translation))</title>

<meta name="description" content="Shell Mode (GNU Emacs Manual
(Japanese Translation))">
<meta name="keywords" content="Shell Mode (GNU Emacs Manual
(Japanese Translation))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="date" content="June 2, 2024">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Key-Index.html" rel="index" title="Key Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Shell.html" rel="up" title="Shell">
<link href="Shell-Prompts.html" rel="next" title="Shell Prompts">
<link href="Interactive-Shell.html" rel="prev" title="Interactive Shell">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="subsection" id="Shell-Mode">
<div class="header">
<p>
Next: <a href="Shell-Prompts.html" accesskey="n" rel="next">Shellプロンプト</a>, Previous: <a href="Interactive-Shell.html" accesskey="p" rel="prev">対話的なサブシェル</a>, Up: <a href="Shell.html" accesskey="u" rel="up">Emacsからのシェルコマンドの実行</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Key-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Shellmodo"></span><h3 class="section">40.3 Shellモード</h3>
<span id="index-Shell-mode"></span>
<span id="index-mode_002c-Shell"></span>

<p>ShellバッファーのためのメジャーモードはShellモードです。このモードの特別なコマンドは<kbd>C-c</kbd>プレフィクスにバインドされており、最初に<kbd>C-c</kbd>をタイプしなければならない点を除けば、通常のシェルでの編集やジョブ制御文字と共通点があります。以下はShellモードのコマンドのリストです:
</p>
<dl compact="compact">
<dt id='index-RET-_0028Shell-mode_0029'><span><kbd><span class="key">RET</span></kbd><a href='#index-RET-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-comint_002dsend_002dinput"></span>
<p>サブシェルの入力にカレント行を送ります(<code>comint-send-input</code>)。行頭のシェルプロンプトは省略されます(<a href="Shell-Prompts.html">Shellプロンプト</a>を参照してください)。ポイントがバッファーの最後にある場合、これは通常の対話的なシェルにおいてコマンド行をサブミットするのに似ています。しかし、シェルバッファーの他の場所でも、<tt class="key">RET</tt>を呼び出してカレント行を入力としてサブミットできます。
</p>
</dd>
<dt id='index-TAB-_0028Shell-mode_0029'><span><kbd><span class="key">TAB</span></kbd><a href='#index-TAB-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-completion_002dat_002dpoint_002c-in-Shell-Mode"></span>
<span id="index-shell-completion"></span>
<p>シェルバッファーのポイントの前のコマンド名、またはファイル名を補完します(<code>completion-at-point</code>)。これは通常のEmacs補完ルールを使用します(<a href="Completion.html">補完</a>を参照してください)。ファイル名、環境変数名、シェルコマンドヒストリー、ヒストリー参照が補完候補になります(<a href="History-References.html">Shellヒストリーの参照</a>を参照してください)。補完を制御するオプションについては、<a href="Shell-Options.html">Shellモードのオプション</a>を参照してください。
</p>
</dd>
<dt id='index-M_002d_003f-_0028Shell-mode_0029'><span><kbd>M-?</kbd><a href='#index-M_002d_003f-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-comint_002ddynamic_002dlist_002dfilename_2026"></span>
<p>ポイントの前のファイル名にたいして、可能性のある補完リストを一時的に表示します(<code>comint-dynamic-list-filename-completions</code>)。
</p>
</dd>
<dt id='index-C_002dd-_0028Shell-mode_0029'><span><kbd>C-d</kbd><a href='#index-C_002dd-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-comint_002ddelchar_002dor_002dmaybe_002deof"></span>
<p>delete文字、または<acronym>EOF</acronym>文字を送ります(<code>comint-delchar-or-maybe-eof</code>)。シェルバッファーの最後でこれをタイプすると、サブシェルに<acronym>EOF</acronym>が送られます。バッファーの他の場所でタイプすると、通常どおり文字を削除します。
</p>
</dd>
<dt id='index-C_002dc-C_002da-_0028Shell-mode_0029'><span><kbd>C-c C-a</kbd><a href='#index-C_002dc-C_002da-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-comint_002dbol_002dor_002dprocess_002dmark"></span>
<p>行の先頭に移動しますが、プロンプトがある場合はプロンプトの後に移動します(<code>comint-bol-or-process-mark</code>)。このコマンドを連続して繰り返すと、2回目はプロセスマーク(process
mark)に戻ります。これはサブシェルにまだ送信されていない入力の開始位置のことです(通常これは同じ場所 &mdash; その行のプロンプトの最後 &mdash;
ですが、<kbd>C-c <span class="key">SPC</span></kbd>の後では、プロセスマークは前の行にあるかもしれません)。
</p>
</dd>
<dt><span><kbd>C-c <span class="key">SPC</span></kbd></span></dt>
<dd><p>複数行の入力を累積して、それらを合わせて送ります(<code>comint-accumulate</code>)。このコマンドはポイントの前に改行を挿入しますが、その前のテキストをサブシェルの入力として
&mdash; 少なくともその時点では &mdash;
送りません。改行の前後の行は両方、(それらを分割する改行も含めて)<tt class="key">RET</tt>をタイプしたとき一緒に送られます。
</p>
</dd>
<dt id='index-C_002dc-C_002du-_0028Shell-mode_0029'><span><kbd>C-c C-u</kbd><a href='#index-C_002dc-C_002du-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-comint_002dkill_002dinput"></span>
<p>まだ入力として送られていない、バッファーの最後のすべてのテキストをkillします(<code>comint-kill-input</code>)。ポイントがバッファーの最後にない場合、これはポイントの前のテキストだけをkillします。
</p>
</dd>
<dt id='index-C_002dc-C_002dw-_0028Shell-mode_0029'><span><kbd>C-c C-w</kbd><a href='#index-C_002dc-C_002dw-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>ポイントの前の単語をkillします(<code>backward-kill-word</code>)。
</p>
</dd>
<dt id='index-C_002dc-C_002dc-_0028Shell-mode_0029'><span><kbd>C-c C-c</kbd><a href='#index-C_002dc-C_002dc-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-comint_002dinterrupt_002dsubjob"></span>
<p>シェルまたは(もしあれば)カレントのサブジョブに割り込み(interrupt)ます(<code>comint-interrupt-subjob</code>)。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。
</p>
</dd>
<dt id='index-C_002dc-C_002dz-_0028Shell-mode_0029'><span><kbd>C-c C-z</kbd><a href='#index-C_002dc-C_002dz-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-comint_002dstop_002dsubjob"></span>
<p>シェルまたは(もしあれば)カレントのサブジョブを停止(stop)します。(<code>comint-stop-subjob</code>)。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。
</p>
</dd>
<dt id='index-comint_002dquit_002dsubjob'><span><kbd>C-c C-\</kbd><a href='#index-comint_002dquit_002dsubjob' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-C_002dc-C_002d_005c-_0028Shell-mode_0029"></span>
<p>シェルまたは(もしあれば)カレントのサブジョブに、シグナルQUITを送ります(<code>comint-quit-subjob</code>)。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。
</p>
</dd>
<dt id='index-C_002dc-C_002do-_0028Shell-mode_0029'><span><kbd>C-c C-o</kbd><a href='#index-C_002dc-C_002do-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-comint_002ddelete_002doutput"></span>
<p>前のシェルコマンドからの出力の一群を削除します(<code>comint-delete-output</code>)。これはシェルコマンドが大量の出力を吐くときに便利です。プレフィクス引数を指定すると、このコマンドは後でどこかにyank
(<a href="Yanking.html">yank</a>を参照)できるように削除したテキストを<code>kill-ring</code> (<a href="Kill-Ring.html">killリング</a>を参照)に保存します。
</p>
</dd>
<dt id='index-C_002dc-C_002ds-_0028Shell-mode_0029'><span><kbd>C-c C-s</kbd><a href='#index-C_002dc-C_002ds-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-comint_002dwrite_002doutput"></span>
<p>前のシェルコマンドからの出力の一群をファイルに書き込みます(<code>comint-write-output</code>)。プレフィクス引数を指定した場合は、ファイルに追加で書き込みます。出力の最後のプロンプトは書き込まれません。
</p>
</dd>
<dt id='index-C_002dc-C_002dr-_0028Shell-mode_0029'><span><kbd>C-c C-r</kbd><a href='#index-C_002dc-C_002dr-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dt><span><kbd>C-M-l</kbd></span></dt>
<dd><span id="index-C_002dM_002dl-_0028Shell-mode_0029"></span>
<span id="index-comint_002dshow_002doutput"></span>
<p>前の一群の出力の最初がウィンドウの最上部になるようにスクロールし、カーソルもそこに移動します(<code>comint-show-output</code>)。
</p>
</dd>
<dt id='index-C_002dc-C_002de-_0028Shell-mode_0029'><span><kbd>C-c C-e</kbd><a href='#index-C_002dc-C_002de-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-comint_002dshow_002dmaximum_002doutput"></span>
<p>バッファーの最後の行がウィンドウの最下部になるようにスクロールします(<code>comint-show-maximum-output</code>)。
</p>
</dd>
<dt id='index-C_002dc-C_002df-_0028Shell-mode_0029'><span><kbd>C-c C-f</kbd><a href='#index-C_002dc-C_002df-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-shell_002dforward_002dcommand"></span>
<span id="index-shell_002dcommand_002dregexp"></span>
<p>シェルコマンド1つ分、前方に移動しますが、カレント行を超えては移動しません(<code>shell-forward-command</code>)。変数<code>shell-command-regexp</code>は、コマンドの最後を認識する方法を指定します。
</p>
</dd>
<dt id='index-C_002dc-C_002db-_0028Shell-mode_0029'><span><kbd>C-c C-b</kbd><a href='#index-C_002dc-C_002db-_0028Shell-mode_0029' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-shell_002dbackward_002dcommand"></span>
<p>シェルコマンド1つ分、後方に移動しますが、カレント行を超えて移動はしません(<code>shell-backward-command</code>)。
</p>
</dd>
<dt><span><kbd>M-x dirs</kbd></span></dt>
<dd><p>シェルに作業ディレクトリーを尋ね、Shellバッファーのデフォルトディレクトリーを更新します。<a href="Directory-Tracking.html">ディレクトリーの追跡</a>を参照してください。
</p>
</dd>
<dt id='index-comint_002dsend_002dinvisible'><span><kbd>M-x comint-send-invisible <span class="key">RET</span> <var>text</var> <span class="key">RET</span></kbd><a href='#index-comint_002dsend_002dinvisible' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>エコーなしで<var>text</var>を読み取った後、それをシェルの入力として送ります。これはシェルコマンドでパスワードを尋ねるプログラムを実行するとき便利です。
</p>
<p>デフォルトではEmacsはパスワードをエコーしないことに注意してください。もし本当にエコーさせたいときは、以下のLisp式を評価します(<a href="Lisp-Eval.html">Emacs Lisp式の評価</a>を参照してください):
</p>
<div class="example">
<pre class="example">(remove-hook 'comint-output-filter-functions
             'comint-watch-for-password-prompt)
</pre></div>

</dd>
<dt id='index-comint_002dcontinue_002dsubjob'><span><kbd>M-x comint-continue-subjob</kbd><a href='#index-comint_002dcontinue_002dsubjob' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>シェルプロセスを継続します。これは間違ってシェルプロセスをサスペンドしてしまったときなどに便利です。<a id="DOCF22" href="#FOOT22"><sup>22</sup></a>
</p>
</dd>
<dt id='index-comint_002dstrip_002dctrl_002dm'><span><kbd>M-x comint-strip-ctrl-m</kbd><a href='#index-comint_002dstrip_002dctrl_002dm' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>シェル出力のカレントグループから、すべてのcontrol-M文字を破棄します。このコマンドを使うもっとも便利な方法は、サブシェルからの出力を受け取ったときに自動的に実行されるようにする方法です。これを行なうには、以下のLisp式を評価します:
</p>
<div class="example">
<pre class="example">(add-hook 'comint-output-filter-functions
          'comint-strip-ctrl-m)
</pre></div>

</dd>
<dt id='index-comint_002dtruncate_002dbuffer'><span><kbd>M-x comint-truncate-buffer</kbd><a href='#index-comint_002dtruncate_002dbuffer' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>このコマンドはシェルバッファーを、変数<code>comint-buffer-maximum-size</code>により指定される、特定の最大行数に切り詰めます。以下は、サブシェルから出力を受けとるとき、毎回自動的にこれを行なう方法です:
</p>
<div class="example">
<pre class="example">(add-hook 'comint-output-filter-functions
          'comint-truncate-buffer)
</pre></div>
</dd>
</dl>

<p>デフォルトでは、Shellモードは(たとえばテキストカラーの変更等に)一般的な<acronym>ANSI</acronym>エスケープコードを使います。initファイルに以下を記述すれば、Emacsはオプションで<acronym>OSC</acronym>
(Operating System Codes： オペレーティングシステムコード)のような拡張エスケープコードもいくつかサポートします:
</p>
<div class="example lisp">
<pre class="lisp">(add-hook 'comint-output-filter-functions 'comint-osc-process-output)
</pre></div>

<p>これを有効にすれば、たとえば<code>ls --hyperlink</code>からの出力からShellモードバッファーにクリック可能ボタンが作成されるでしょう。
</p>
<span id="index-Comint-mode"></span>
<span id="index-mode_002c-Comint"></span>
<p>Shellモードは、サブプロセスと対話的に通信を行なう一般的な用途向けのComintモードから派生したモードです。上記のコマンド名からも判るとおり、Shellモードのほとんどの機能は、実際にはComintモードが由来です。Shellモードの特別な機能には、ディレクトリー追跡機能、およびいくつかのユーザーコマンドが含まれます。
</p>
<p>Comintモードの変種を使う他のEmacs機能には、GUD (<a href="Debuggers.html">Emacs下でのデバッガーの実行</a>を参照してください)や、<kbd>M-x
run-lisp</kbd> (<a href="External-Lisp.html">外部Lispの実行</a>を参照してください)が含まれます。
</p>
<span id="index-comint_002drun"></span>
<p>サブプロセスとして選択した任意のプログラムを実行するために、Shellモードに特化しない未修正のComintモードを使用するには、<kbd>M-x
comint-run</kbd>を使用することができます。プログラムに引数を渡すには<kbd>C-u M-x comint-run</kbd>を使用します。
</p>
</div>
<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5><a id="FOOT22" href="#DOCF22">(22)</a></h5>
<p>シェルプロセスをサスペンドするべきではありません。これはシェルのサブジョブのサスペンドとはまったく違います。サブジョブのサスペンドは通常行なわれますが、サブジョブを継続するためにはシェルを使用しなければなりません。このコマンドはそれを行ないません。</p>
</div>
<hr>
<div class="header">
<p>
Next: <a href="Shell-Prompts.html">Shellプロンプト</a>, Previous: <a href="Interactive-Shell.html">対話的なサブシェル</a>, Up: <a href="Shell.html">Emacsからのシェルコマンドの実行</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Key-Index.html" title="Index" rel="index">Index</a>]</p>
</div>


This page has generated for branch:work/master_4078d0fd3ee9e55c3da219aa6e7788ac6130697b, commit:a5efff48b20fab86e768679e7b1dc92ec94f238d to check Japanese translation.
</body>
</html>
