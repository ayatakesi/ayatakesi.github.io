This is emacs-ja.info, produced by makeinfo version 6.5 from
emacs-ja.texi.

This is the ‘GNU Emacs Manual’, updated for Emacs version 26.1.

   Copyright © 2016–2018 ayatakesi <ayanokoji.takesi@gmail.com>
Copyright © 1985–1987, 1993–2018 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “The GNU Manifesto,”
     “Distribution” and “GNU GENERAL PUBLIC LICENSE,” with the
     Front-Cover Texts being “A GNU Manual,” and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).            拡張可能なセルフドキュメント形式のテキストエディター。
END-INFO-DIR-ENTRY


File: emacs-ja.info,  Node: Top,  Next: Distrib,  Up: (dir)

The Emacs Editor
****************

Emacsは、拡張可能で、カスタマイズ可能な、セルフドキュメント方式のリアル
タイム画面エディターです。このinfoファイルでは、Emacsでの編集方法や
Emacsのカスタマイズ方法について説明します。GNU Emacs 26.1に対応します。

   これをEmacsで読んでいる場合、Infoドキュメントシステムの基本的な手引き
を読むには、‘h’とタイプします。

   Emacsの拡張に関しては、*note Emacs Lisp: (elisp)Top.を参照してくださ
い。

   This is the ‘GNU Emacs Manual’, updated for Emacs version 26.1.

   Copyright © 2016–2018 ayatakesi <ayanokoji.takesi@gmail.com>
Copyright © 1985–1987, 1993–2018 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “The GNU Manifesto,”
     “Distribution” and “GNU GENERAL PUBLIC LICENSE,” with the
     Front-Cover Texts being “A GNU Manual,” and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”

* Menu:

* Distrib::                  最新のEmacsディストリビューションを入手する方法。
* Intro::                    Emacsの概念についてのイントロダクション

重要な一般的概念
* Screen::                   スクリーンで目にするものの使い方。
* User Input::               さまざまな入力イベント（文字、ボタン、ファンクションキー）
* Keys::                     キーシーケンス:
                               編集アクションをリクエストするための入力。
* Commands::                 編集を行うキーシーケンスにより実行される名前付きの関数。
* Entering Emacs::           シェルからのEmacsの起動。
* Exiting::                  Emacsの停止と終了。

基本的な編集コマンド
* Basic::                    もっとも基本的な編集コマンド。
* Minibuffer::               入力プロンプトにたいして引数を入力する。
* M-x::                      コマンドを名前で呼び出す。
* Help::                     コマンドについてEmacsに尋ねるコマンド。

テキストを変更する重要コマンド
* Mark::                     mark:
                               どうやってテキストのリージョンを区切るか。
* Killing::                  テキストのkill(切り取り)とyank(コピー)。
* Registers::                バッファーのテキストや位置の保存。
* Display::                  テキストの表示の制御。
* Search::                   文字列の検索と置換。
* Fixit::                    タイプミスを訂正するのに特に有用なコマンド。
* Keyboard Macros::          再生するためにキーストロークのシーケンスを記録する。

Emacsの主要な構造
* Files::                    ファイルの処理に関するすべて。
* Buffers::                  複数バッファー —
                               1度に複数のファイルを編集する。
* Windows::                  1つのフレームでの複数のテキスト片の閲覧。
* Frames::                   ディスプレーで複数のウィンドウを使用する。
* International::            非ASCII文字セットの使用。

上級の機能
* Modes::                    Emacsの基本動作を変更するメジャーモードとマイナーモード。
* Indentation::              行の先頭にある空白スペースの編集。
* Text::                     人間の言語のためのコマンドとモード。
* Programs::                 プログラム編集のためのコマンドとモード。
* Building::                 プログラムのコンパイル、実行、デバッグ。
* Maintaining::              大きなプログラムを保守するための機能。
* Abbrevs::                  タイプ量を減らすための略語の定義。
* Dired::                    ディレクトリー・ファイルマネージャー。
* Calendar/Diary::           カレンダーおよびダイアリー機能。
* Sending Mail::             Emacsでのメールの送信。
* Rmail::                    Emacsでのメールの閲覧。
* Gnus::                     柔軟なメール・ニュースリーダー。
* Host Security::            単独のコンピューターでのセキュリティー問題。
* Network Security::         ネットワークセキュリティーの管理。
* Document View::            PDF、PS、DVIファイルの閲覧。
* Shell::                    Emacsからのシェルコマンドの実行。
* Emacs Server::             Emacsを編集サーバーとして使用する。
* Printing::                 バッファーまたはリージョンのハードコピーの印刷。
* Sorting::                  Emacsでの行、パラグラフ、ページのソート。
* Picture Mode:: テキスト文字で作られたピクチャーの編集。
* Editing Binary Files::     Hexlモードでのバイナリーファイルの編集。
* Saving Emacs Sessions::    あるセッションから次のセッションへ、Emacsの状態を保存する。
* Recursive Edit::           他のコマンドを実行中に編集を行なう。
* Hyperlinking::             バッファー内のリンクをフォローする。
* Amusements::               さまざまなゲームとhack。
* Packages::                 追加機能のインストール。
* Customization::            Emacsの動作を変更する。

問題からのリカバリー
* Quitting::                 中止(quit)と中断(abort)。
* Lossage::                  Emacsがハングしたり誤動作するとき何を行なうか。
* Bugs::                     バグを報告すべきとき、そしてその方法について。
* Contributing::             Emacsの改良に貢献する方法。
* Service::                  あなた独自のEmacsのニーズにたいして助けを得る方法。

Appendices
* Copying::                  GNU General Public
                               Licenseは特定の条件に置いてGNUEmacsを再配布する許可をあなたに与えます。そして保証がないことも説明します。
* GNU Free Documentation License::  このドキュメントのライセンス。
* Emacs Invocation::         hairy(身の毛もよだつ、恐ろしい、困難な、難しい、危険な、やばい)な開始オプション。
* X Resources::              EmacsをカスタマイズするためのXリソース。
* Antinews::                 Emacsバージョン25についての情報。
* Mac OS / GNUstep::         macOSおよびGNUstepでのEmacsの使用。
* Microsoft Windows::        Microsoft
                               WindowsおよびMS-DOSでのEmacsの使用。
* Manifesto::                What’s GNU? Gnu’s Not Unix! —
                               GNUとはなんだ? => Gnu’s Not
                               Unix!(GNUはUnixではない!)。

* Glossary::                 このマニュアルで使用されている用語。
* Acknowledgments:: GNU Emacsの主要な貢献者。


インデックス(各インデックスは大きなメニューを含みます)
* Key Index::                標準的なEmacsキーシーケンス。
* Option Index::             コマンドラインオプション。
* Command Index::            標準的なコマンド名。
* Variable Index::           ドキュメントされた変数。
* Concept Index::            概念およびその他の一般的な項目のインデックス。



 — 詳細なノードリスト — —————————————-



以下は実際にはすでにリストされたノードのサブノードです。それらをここで記述するので、1ステップで移動できます:



スクリーンの構成



* Point::                    テキスト内で編集コマンドが作用する場所
* Echo Area::                スクリーンのいちばん下で、短いメッセージが表示されます
* Mode Line::                モードを説明するライン
* Menu Bar::                 メニューバーの使い方

基本的な編集コマンド



* Inserting Text::           単純に入力してテキストを挿入する。
* Moving Point::             何か修正したい場所にカーソルを移動する。
* Erasing::                  テキストの削除とkill。
* Basic Undo::               テキストの最近の変更を取り消す。
* Basic Files::              ファイルの読み込み、作成、保存。
* Basic Help::               文字が何を行うか尋ねる。
* Blank Lines::              空行の作成と削除
* Continuation Lines::       Emacsがスクリーンに収まりきれない行を表示する方法。
* Position Info::            ポイントのある場所の行と列は何か?
* Arguments::                コマンドをN回繰り返すための数引数。
* Repeating::                素早く前のコマンドを繰り返す。

ミニバッファー



* Basic Minibuffer::         ミニバッファーの基本的な使い方。
* Minibuffer File::          ミニバッファーでファイル名を入力する。
* Minibuffer Edit::          ミニバッファーで編集する方法。
* Completion::               ミニバッファーでの入力のための略語機能。
* Minibuffer History::       最近のミニバッファー引数の再使用。
* Repetition::               ミニバッファーを使ったコマンドの再実行。
* Passwords::                エコーエリアでパスワードを入力する。
* Yes or No Prompts::        エコーエリアでyes/noにこたえる。

Completion



* Completion Example::       補完の使い方の例。
* Completion Commands::      補完コマンドのリスト。
* Completion Exit::          補完とミニバッファーでのテキストの確定。
* Completion Styles::        補完のマッチが選ばれる方法。
* Completion Options::       補完のオプション。

Help



* Help Summary::             すべてのヘルプコマンドの要約リスト。
* Key Help::                 Emacsでキーが何を行うか尋ねる。
* Name Help::                コマンド、変数、関数名を尋ねる。
* Apropos::                  与えられたトピックに関係があるものを尋ねる。
* Help Mode::                へルポモードとヘルプバッファーの特別な機能。
* Package Keywords::         キーワード(トピック)でLispライブラリーを探す。
* Language Help::            国際的な言語サポートに関するヘルプ。
* Misc Help::                その他のヘルプコマンドについて。
* Help Files::               追加のヘルプファイルを表示するコマンド。
* Help Echo::                アクティブなテキストのヘルプとツールチップ。

マークとリージョン



* Setting Mark::             マークをセットするコマンド。
* Marking Objects::          テキスト単位の周辺にリージョンをセットするコマンド。
* Using Region::             リージョンの内容を操作する方法の要約。
* Mark Ring::                後で戻れるように保存された以前のマーク位置。
* Global Mark Ring::         さまざまなバッファーの以前のマーク位置。
* Shift Selection::          シフトを押してカーソル移動キーを使う。
* Disabled Transient Mark::  デフォルトでリージョンをハイライトせずにおく。

テキストのkillと移動



* Deletion and Killing::     テキストを削除するコマンド。
* Yanking::                  テキストを挿入するコマンド。
* Cut and Paste::            グラフィカルなディスプレーにおけるクリップボードと選択。
* Accumulating Text::        バッファーにテキストを追加する他の方法。
* Rectangles::               矩形領域のテキストの操作。
* CUA Bindings::             killとyankで‘C-x’/‘C-c’/‘C-v’を使う。

Deletion and Killing



* Deletion::                 少量のテキストや空の領域を削除するコマンド。
* Killing by Lines::         テキスト行を一度にkillする方法。
* Other Kill Commands::      大きなリージョン、および単語やセンテンスのような構文単位をkillするコマンド。
* Kill Options::             killに影響を与えるオプション。

Yanking



* Kill Ring::                killされたテキストが格納される場所。
* Earlier Kills::            もっと前にkillしたものをyankする。
* Appending Kills::          数回のkillを一緒にまとめてyankする。

グラフィカルなディスプレーでのカットアンドペースト操作



* Clipboard::                Emacsがシステムクリップボードを使う方法。
* Primary Selection::        一時的に選択されたテキストの選択。
* Secondary Selection::      ポイントとマークを変化させずに切り取る。

Registers



* Position Registers::       位置をレジスターに保存する。
* Text Registers::           テキストをレジスターに保存する。
* Rectangle Registers::      矩形領域をレジスターに保存する。
* Configuration Registers::  ウィンドウの設定をレジスターに保存する。
* Number Registers::         レジスターの中の数字。
* File Registers::           レジスターの中のファイル名。
* Keyboard Macro Registers::  レジスターの中のキーボードマクロ。
* Bookmarks::                レジスターと似ているが永続性があるブックマーク。

ディスプレーの制御



* Scrolling::                ウィンドウのテキストを上下に移動させるコマンド。
* Recentering::              カレント行を中央にするスクロールコマンド。
* Auto Scrolling::           必要なときテキストをスクロールして再表示する。
* Horizontal Scrolling::     ウィンドウの左右にテキストを移動させる。
* Narrowing::                表示を制限してバッファーの一部を編集する。
* View Mode::                読み取り専用バッファーの表示。
* Follow Mode::              Followモードで2つのウィンドウを1つとしてスクロールさせる。
* Faces::                    フェイスを使って表示スタイルを変更する方法。
* Colors::                   フェイスのカラーを指定する。
* Standard Faces::           主要な既定のフェイス。
* Text Scale::               バッファーのテキストサイズの拡大と縮小。
* Font Lock::                フェイスを使って文法をハイライトするマイナーモード。
* Highlight Interactively::  Emacsにハイライトするテキストを指示する。
* Fringes::                  ウィンドウフリンジの有効と無効。
* Displaying Boundaries::    バッファーの先頭と最後を表示する。
* Useless Whitespace::       行末の不要な空白文字の表示。
* Selective Display::        インデントの大きな行を隠す。
* Optional Mode Line::       モードラインの表示機能のオプション。
* Text Display::             テキスト文字が通常表示される方法。
* Cursor Display::           カーソル表示の機能。
* Line Truncation::          複数のスクリーン行で継続表示させずにスクリーン幅に行を切り詰める。
* Visual Line Mode::         単語の折り返しとスクリーン行にもとづく編集。
* Display Custom::           ディスプレーをカスタマイズする変数の情報。

検索と置換



* Incremental Search::       文字列をタイプすることにより始まる検索。
* Nonincremental Search::    文字列全体を指定してから検索する。
* Word Search::              単語の並びを検索する。
* Symbol Search::            ソースコードのシンボルを検索する。
* Regexp Search::            正規表現にマッチする検索。
* Regexps::                  正規表現の構文について。
* Regexp Backslash::         ‘\’で開始される正規表現の構築。
* Regexp Example::           複雑な正規表現の解説。
* Lax Search::               大文字小文字のように、似た文字にたいするいくつかの相違を検索で無視する。
* Replace::                  一部またはすべてのマッチを検索または置換する。
* Other Repeating Search::   いくつかの正規表現にマッチするすべてを処理する。
* Search Customizations::    検索のさまざまなカスタマイズ。

Incremental Search



* Basic Isearch::            基本的なインクリメンタル検索コマンド。
* Repeat Isearch::           同じ文字列を再度検索する。
* Isearch Yank::             検索文字列にテキストを取り込んだり、検索文字列を編集するコマンド。
* Error in Isearch::         文字列が見つからなかったとき。
* Special Isearch::          インクリメンタル検索での特別な入力。
* Not Exiting Isearch::      プレフィクス引数とスクロールコマンド。
* Isearch Minibuffer::       ミニバッファーヒストリーのインクリメンタル検索。

置換コマンド



* Unconditional Replace::    文字列にマッチするすべてを置換する。
* Regexp Replace::           regexpにマッチするすべてを置換する。
* Replacement and Lax Matches::  置換するテキストにたいするLax検索。
* Query Replace::            問い合わせの使い方。

タイプミス訂正のためのコマンド



* Undo::                     Undoコマンド。
* Transpose::                2つの文字、単語、行、リスト、...の入れ替え。
* Fixing Case::              最後に入力した文字の大文字小文字を訂正する。
* Spelling::                 単語またはファイル全体へのスペルチェッカーの適用。

Keyboard Macros



* Basic Keyboard Macro::     キーボードマクロの定義と実行。
* Keyboard Macro Ring::      以前のキーボードマクロが保存される場所。
* Keyboard Macro Counter::   マクロに増加する番号を挿入する。
* Keyboard Macro Query::     毎回違うことを行うマクロの作成。
* Save Keyboard Macro::      キーボードマクロの命名とファイルへの保存。
* Edit Keyboard Macro::      キーボードマクロを編集するには。
* Keyboard Macro Step-Edit::  キーボードマクロのインタラクティブな実行と編集。

ファイル処理



* File Names::               ファイル名引数をタイプ、編集する方法。
* Visiting::                 ファイルをvisitしてEmacsが編集する準備をする。
* Saving::                   保存して変更を永続化する。
* Reverting::                保存されていないすべての変更を取り消して前の状態に戻す。
* Autorevert:: 非ファイルバッファーの自動リバートについて。
* Auto Save::                定期的な自動保存によりデータを失うことから守る。
* File Aliases::             1つのファイルにたいする複数の名前を処理する。
* Directories::              ファイルディレクトリーの削除、作成、一覧。
* Comparing Files::          2つのファイルの異なる部分を探す。
* Diff Mode::                ファイルの異なる部分を編集するモード。
* Copying and Naming::       ファイルのvisit、作成、保存。
* Misc File Ops::            ファイルにたいして行うその他のコマンド。
* Compressed Files::         圧縮されたファイルへのアクセス。
* File Archives::            tar、zip、jar、...などのアーカイブファイルにたいする操作。
* Remote Files::             他のマシンにあるファイルへのアクセス。
* Quoted File Names::        ファイル名に含まれる特別な文字のクォート。
* File Name Cache::          よく使うファイルのリストにたいする補完。
* File Conveniences::        ファイルを探すための便利な機能。
* Filesets::                 複数ファイルの処理。

Saving Files



* Save Commands::            ファイルを保存するコマンドについて。
* Backup::                   Emacsがファイルの古いバージョンを保存する方法。
* Customize Save::           ファイルの保存のカスタマイズ。
* Interlocking::             Emacsが2人のユーザーによる1つのファイルへの同時編集から保護する方法。
* File Shadowing::           ファイルを自動的にshadowコピーする。
* Time Stamps::              Emacsによる保存されたファイルのタイムスタンプの更新。

バックアップファイル



* Backup Names::             バックアップファイルの命名方法。
* Backup Deletion::          Emacsによる余分な番号つきバックアップの削除。
* Backup Copying::           コピーとリネームによるバックアップの作成。

非ファイルバッファーの自動リバート

* Auto Reverting the Buffer Menu:: バッファーメニューの自動リバート。


自動保存 — 災害にたいする保護



* Auto Save Files::          ファイルを保存するまでの間、自動保存された変更が実際に保存されるファイル。
* Auto Save Control::        自動保存をいつ、どのような間隔で行うかの制御。
* Recover::                  自動保存ファイルからのテキストの復旧。

複数バッファーの使用



* Select Buffer::            新しいバッファーの作成と既存のバッファーの再選択。
* List Buffers::             既存のバッファーリストの取得。
* Misc Buffer::              リネーム、読み取り専用属性の変更、テキストのコピー。
* Kill Buffer::              不必要なバッファーのkill。
* Several Buffers::          すべてのバッファーにたいするリストの操作と、複数バッファーにたいする操作。
* Indirect Buffers::         他のバッファーのテキストを共有するインダイレクトバッファー。
* Buffer Convenience::       バッファー操作のための便利な機能とカスタマイズ。

バッファー処理の便利な機能とカスタマイズ



* Uniquify::                 ディレクトリー部分でバッファー名を一意にする。
* Icomplete::                素早いミニバッファーの選択について。
* Buffer Menus::             バッファーメニューの設定。

複数ウィンドウ



* Basic Window::             Emacsウィンドウの紹介。
* Split Window::             既存のウィンドウを分割して新しいウィンドウを作る。
* Other Window::             他のウィンドウへの移動と操作。
* Pop Up Window::            他のウィンドウのファイルまたはバッファーの検索。
* Change Window::            ウィンドウの削除とサイズ変更。
* Displaying Buffers::       Emacsがバッファーを表示するためにウィンドウを選択する方法。
* Temporary Displays::       編集不可バッファーの表示。
* Window Convenience::       ウィンドウ処理の便利な機能。

ウィンドウでのバッファーの表示



* Window Choice::            ‘display-buffer’が機能する方法。

フレームとグラフィカルなディスプレー



* Mouse Commands::           マウスによる移動、切り取り、貼り付け。
* Word and Line Mouse::      単語または行全体を選択するマウスコマンド。
* Mouse References::         リストからアイテムを選択するのにマウスを使う。
* Menu Mouse Clicks::        メニューを表示させるマウスクリック。
* Mode Line Mouse::          モードライン上でのマウスクリック。
* Creating Frames::          さまざまな内容とともに追加のEmacsフレームを作成する。
* Frame Commands::           フレームのアイコン化とフレームの切り替え。
* Fonts::                    フレームフォントの変更。
* Speedbar::                 スピードバーフレームの作り方と使い方。
* Multiple Displays::        1つのEmacsインスタンスが複数ディスプレーと通信する方法。
* Frame Parameters::         フレームのカラーや他のモードの変更。
* Scroll Bars::              スクロールバーの有効と無効、および使い方。
* Window Dividers::          マウスでドラッグできるウィンドウセパレーター。
* Drag and Drop::            ファイルを開いたりテキストを挿入するのにドラッグアンドドロップを使う。
* Menu Bars::                メニューバーの有効と無効。
* Tool Bars::                ツールバーの有効と無効。
* Dialog Boxes::             ダイアログボックス使用の制御。
* Tooltips::                 マウスの現在位置の情報の表示。
* Mouse Avoidance::          マウスポインターがテキストを隠すのを防ぐ。
* Non-Window Terminals::     フレームを1つだけ表示する端末での複数フレーム。
* Text-Only Mouse::          テキスト端末でのマウスの使用について。

国際化文字セットのサポート



* International Chars::      マルチバイト文字の基本的な概念。
* Language Environments::    使用する言語のためのセットアップ事項。
* Input Methods::            キーボードにないテキスト文字の入力。
* Select Input Method::      インプットメソッド選択を指定する。
* Coding Systems::           ファイルを読み書きしたりするときの文字セット変換。
* Recognize Coding::         どの変換を使用するかをEmacsが解決する方法。
* Specify Coding::           ファイルのコーディングシステムの明示的な指定。
* Output Coding::            出力のためのコーディングシステムの選択について。
* Text Coding::              ファイルのテキストに使う変換の選択。
* Communication Coding::     プロセス間通信のためのコーディングシステム。
* File Name Coding::         _ファイル名_のコーディングシステム。
* Terminal Coding::          端末の入出力の変換のためのコーディングシステムの指定。
* Fontsets::                 フォントセット、それは文字の全範囲をカバーするフォントのコレクション。
* Defining Fontsets::        新しいフォントセットの定義。
* Modifying Fontsets::       既存のフォントセットの修正。
* Undisplayable Characters::文字が表示されないとき。
* Unibyte Mode::             マルチバイト文字を使わずに1つの英文字セットを選択する。
* Charsets::                 Emacsが内部の文字コードをグループ化する方法。
* Bidirectional Editing::    右から左に記述する言語のサポート。

メジャーモードとマイナーモード



* Major Modes::              Textモード vs. Lispモード
                               vs. Cモード...
* Minor Modes::              マイナーモードは他と独立して有効にできる機能です。
* Choosing Modes::           ファイルをvisitしたときにモードが選択される方法。

Indentation



* Indentation Commands::     インデントを処理するほかのコマンド。
* Tab Stops::                Textモードのインデントのストップポイント。
* Just Spaces::              インデントにスペース文字だけを使用する。
* Indent Convenience::       インデントのオプション機能。

人間の言語にたいするコマンド



* Words::                    単語単位の移動とkill。
* Sentences::                センテンス単位の移動とkill。
* Paragraphs::               パラグラフ単位の移動。
* Pages::                    ページ単位の移動。
* Quotation Marks::          クォーテーションマークの挿入。
* Filling::                  テキストのフィルと調整。
* Case::                     テキストの大文字小文字の変更。
* Text Mode::                テキストファイルを編集するためのメジャーモード。
* Outline Mode::             アウトラインの編集。
* Org Mode::                 Emacsオーガナイザー。
* TeX Mode::                 TeXおよびLaTeXファイルの編集。
* HTML Mode::                HTMLおよびSGMLファイルの編集。
* Nroff Mode::               nroffフォーマッターへの入力の編集。
* Enriched Text::            フォント、カラーなどでenrichedテキストを編集する。
* Text Based Tables::        テキストベースのテーブルを編集するためのコマンド。
* Two-Column::               テキスト列を分割して別のウィンドウに表示する。

テキストのフィル



* Auto Fill::                Auto
                               Fillモードは長い行を自動的に分割します。
* Fill Commands::            パラグラフの再フィルと行の中央揃えコマンド。
* Fill Prefix::              インデントされていたり、コメントであるパラグラフのフィル。
* Adaptive Fill::            Emacsがフィルプレフィクスを自動的に決定する方法。

Outline Mode



* Outline Format::           アウトラインのテキストがどのように見えるか。
* Outline Motion::           アウトラインを移動するための特別なコマンド。
* Outline Visibility::       なにを表示するか制御するコマンド。
* Outline Views::            アウトラインと複数ビュー。
* Foldout::                  アウトラインをズームする折り畳み。

Org Mode



* Org Organizer::            TODOリストとアジェンダの管理。
* Org Authoring::            Orgバッファーをさまざまなフォーマットでエクスポートする。

TeXモード



* TeX Editing::              TeXモードで編集するための特別なコマンド。
* LaTeX Editing::            LaTeX入力ファイルのための追加のコマンド。
* TeX Print::                ファイルの一部をTeXで印刷するコマンド。
* TeX Misc::                 TeXモードのカスタマイズと関連する機能。

Enriched Text



* Enriched Mode::            Enrichedモードの開始と終了。
* Hard and Soft Newlines::   改行には2つの種類があります。
* Editing Format Info::      テキストプロパティーの編集方法。
* Enriched Faces::           太字、斜体、下線、など。
* Enriched Indentation::     左余白と右余白の変更。
* Enriched Justification::   テキストの中央揃え、左揃え、右揃え、など。
* Enriched Properties::      特別な“テキストプロパティー”サブメニュー。



テキストベースの表の編集



* Table Definition::         テキストベースのテーブルとは何か。
* Table Creation::           テーブルを作成する方法。
* Table Recognition::        テーブルをアクティブまたは非アクティブにする方法。
* Cell Commands::            テーブルのセル指向のコマンド。
* Cell Justification::       セル内容の位置調整。
* Table Rows and Columns::   行と列の追加と削除。
* Table Conversion::         プレーンテキストとテーブルの変換について。
* Table Misc::               テーブル、その他。

プログラムの編集



* Program Modes::            プログラムを編集するためのメジャーモード。
* Defuns::                   プログラムの主要なトップレベル要素を操作するためのコマンド。
* Program Indent::           ネスティングを示すためのインデントの調整。
* Parentheses::              カッコを操作するコマンド。
* Comments::                 コメントの挿入、kill、位置揃え。
* Documentation::            関数ドキュメントの取得。
* Hideshow::                 ブロックの選択的な表示。
* Symbol Completion::        プログラムまたは言語でのシンボルの補完。
* MixedCase Words::          identifiersLikeThisのような識別子の処理。
* Semantic::                 ソースコードのパースにもとづいた編集ツール。
* Misc for Programs::        その他、プログラムを編集するための便利なEmacs機能。
* C Modes::                  C、C++、Objective-C、Java、IDL、Pike、AWKモードの特別なコマンド。
* Asm Mode::                 Asmモードと特別な機能。
* Fortran:: Fortranモードと特別な機能。


トップレベルの定義とdefun



* Left Margin Paren::        開きカッコまたは同様の開始を意味する区切りは、それが左端にある場合はdefunの開始です。
* Moving by Defuns::         主要な定義を移動したりマークするコマンド。
* Imenu::                    バッファーのインデックスをメニューにする。
* Which Function::           Which
                               Functionモードはどの関数にいるか表示します。

プログラムのインデント



* Basic Indent::             1行のインデント。
* Multi-line Indent::        複数行を1度に再インデントするコマンド。
* Lisp Indent::              Lisp関数がどのようにインデントされるべきか指定する。
* C Indent::                 Cおよび関連するモードのインデントのための追加機能。
* Custom C Indent::          Cおよび関連するモードのインデントスタイルの制御。

カッコの編集にたいするコマンド



* Expressions::              対応が取れたカッコの式。
* Moving by Parens::         カッコ構造を上、下、横断して移動するコマンド。
* Matching::                 終了区切りの挿入による、マッチする開始区切りのフラッシュ表示。

コメントの操作



* Comment Commands::         コメントの挿入、kill、位置揃え。
* Multi-Line Comments::      複数行のコメントを追加・編集するコマンド。
* Options for Comments::コメント機能のカスタマイズ。



ドキュメントのルックアップ



* Info Lookup::              Infoファイルからライブラリー関数やコマンドを探す。
* Man Page::                 manからライブラリー関数やコマンドを探す。
* Lisp Doc::                 Emacs関数を探す、その他。

Cモードと関連するモード



* Motion in C::              Cステートメント単位での移動、その他。
* Electric C::               コロンおよび他の文字による、自動的な再インデント。
* Hungry Delete::            より強力なDELコマンド。
* Other C Commands::         コメントのフィル、マクロ展開の閲覧、その他のクールな機能。

Fortranモード

* Fortran Motion:: 命令文またはサブプログラムごとにポイントを移動する。
* Fortran Indent:: Fortranのためのインデントコマンド。
* Fortran Comments:: コメントの挿入と位置揃え。
* Fortran Autofill:: FortranをサポートするAuto Fill。
* Fortran Columns:: 有効なFortranのための列の計算。
* Fortran Abbrev:: Fortranキーワードのためのビルトインのabbrevs。

Fortranのインデント

* ForIndent Commands:: Fortranをインデントおよびフィルするコマンド。
* ForIndent Cont:: 継続行がインデントされる方法。
* ForIndent Num:: 行番号が自動インデントされる方法。
* ForIndent Conv:: トラブル防止のためにしたがわなければならない慣習。
* ForIndent Vars:: Fortranのインデントスタイルを制御する変数。


プログラムのコンパイルとテスト



* Compilation::              Lisp以外の言語(C、Pascal、など)のプログラムのコンパイル。
* Compilation Mode::         コンパイラーのエラーをvisitするモード。
* Compilation Shell::        compilationバッファーで使えるように、シェルを適切にカスタマイズする。
* Grep Searching::           grepによる検索。
* Flymake::                  オンザフライでの構文エラーの検索。
* Debuggers::                非Lispプログラムのための、シンボルデバッガーの実行。
* Executing Lisp::           Lispプログラムを編集するためのさまざまなモードと、Lispプログラムを実行する異なる機能。
* Lisp Libraries::           LispプログラムがEmacsにロードされる方法。
* Lisp Eval::                Emacsで1つのLisp式を実行する。
* Lisp Interaction::         EmacsバッファーでLispを実行する。
* External Lisp::            Emacsを通じて別のLispと通信する。

Emacsの下でデバッガーを実行する



* Starting GUD::             デバッガーサブプロセスを開始する方法。
* Debugger Operation::       デバッガーとソースバッファーの関係。
* Commands of GUD::          一般的なコマンドのキーバインディング。
* GUD Customization::        GUDにたいして独自のコマンドを定義する。
* GDB Graphical Interface::  GDB機能を使用して、グラフィカルなデバッグ環境を実装する拡張モード。

GDB Graphical Interface



* GDB User Interface Layout::  複数表示されたバッファーの制御。
* Source Buffers::           プログラムを制御するためにフリンジ・余白でマウスを使う。
* Breakpoints Buffer::       ブレークポイントのコントロールパネル。
* Threads Buffer::           スレッドの表示。
* Stack Buffer::             callスタックからのフレームの選択。
* Other GDB Buffers::        GDBの状態を制御するその他のバッファー。
* Watch Expressions::        speedbarで変数の値をモニターする。
* Multithreaded Debugging::  複数スレッドのプログラムのデバッグ。

大きなプログラムの保守



* Version Control::          バージョンコントロールシステムの使用。
* Change Log::               プログラムの変更履歴をメンテナンスする。
* Xref::                     プログラムの中の関数、メソッド、構造体、マクロ、...の定義と参照を探す。
* EDE::                      Emacsのための統合開発環境。
* Emerge:: 2つのバージョンのプログラムをマージする便利な方法。


Version Control



* Introduction to VC::       バージョンコントロールが機能する一般的な方法。
* VC Mode Line::             モードラインがバージョンコントロールの状態を表示する方法。
* Basic VC Editing::         バージョンコントロール下のファイルの編集方法。
* Log Buffer::               logエントリーバッファーで利用可能な機能。
* Registering::              バージョンコントロール下にファイルを置く。
* Old Revisions::            古いバージョンの調査と比較。
* VC Change Log::            VC Change Logの閲覧。
* VC Undo::                  コミット前後の変更の取り消し。
* VC Ignore::                バージョンコントロール下のファイルの無視。
* VC Directory Mode::        バージョンコントロールで管理されたファイルの一覧。
* Branches::                 開発における複数行。
* Miscellaneous VC:: その他のVCのさまざまなコマンドと機能。
* Customizing VC:: VCの動作を変更する変数。


バージョンコントロールの紹介



* Why Version Control?::     問題が示すところを理解するには。
* Version Control Systems::  バックエンドシステムとしてサポートされるバージョンコントロール。
* VCS Concepts::             バージョンコントロールに関連する単語と概念。
* VCS Merging::              ファイルの衝突を処理する方法。
* VCS Changesets::           変更がグループ化される方法。
* VCS Repositories::         バージョンコントロールのリポジトリーが格納される場所。
* Types of Log File::        VCS logとChangeLogの違い。

バージョンコントロール下での基本的な編集



* VC With A Merging VCS::    ロックしない:
                               CVSのデフォルトモード。
* VC With A Locking VCS::    RCSのデフォルトモード、SCCS、オプションでCVS。
* Advanced C-x v v::         プレフィクス引数で利用可能な上級機能。

VC Directory Mode



* VC Directory Buffer::      バッファーの外観と意味。
* VC Directory Commands::    VC
                               directoryバッファーで使用するコマンド。

ブランチのバージョンコントロール



* Switching Branches::       既存のブランチを取得する方法。
* Pulling / Pushing::        別の場所から変更を受け取る、別の場所に変更を送る。
* Merging::                  ブランチ間での変更の転送。
* Creating Branches::        新しいブランチを開始する方法。

VCのその他の機能とコマンド

* Change Logs and VC:: logエントリーからChangeLogファイルを生成する。
* VC Delete/Rename:: バージョンコントロールされたファイルの削除とリネームとは
* Revision Tags:: リビジョンにたいするシンボリック名。
* Version Headers:: 作業ファイルへのバージョンコントロールヘッダーの挿入。

VCのカスタマイズ

* General VC Options:: 複数のバックエンドに適用されるオプション。
* RCS and SCCS:: RCSとSCCSのためのオプションについて。
* CVS Options:: CVSにたいするオプションについて。


変更ログ(ChangeLog)



* Change Log Commands::      変更ログファイルを編集するためのコマンド。
* Format of ChangeLog::      変更ログファイルがどのように見えるか。

Xref



* Find Identifiers::         識別子をリストする等のために、識別子が定義(または参照)されている場所を探すコマンド。
* Tags Tables::              シンボルがどのファイルで定義されているかを記録するTagsテーブル。
* Select Tags Table::        特定のタグテーブルをvisitする方法。

Find Identifiers



* Looking Up Identifiers::   特定のタグの定義を見つけるコマンド。
* Xref Commands::            ‘*xref*’バッファーでのコマンド。
* Identifier Search::        検索と置換
* List Identifiers::         識別子をリストして<、それらから補完する。

Tags Tables



* Tag Syntax::               さまざまなタイプのコードおよびテキストファイルにたいするタグ構文。
* Create Tags Table::        ‘etags’によるタグテーブルの作成。
* Etags Regexps::            正規表現を使用した任意タグの作成。

Emergeでのファイルのマージ

* Overview of Emerge:: Emergeを開始する方法と基本的な概念。
* Submodes of Emerge:: Fastモード vs. Editモード。Skip PrefersモードとAuto Advanceモード。
* State of Difference:: 各相違にたいしてAまたはBの状態を指定することによりマージを行う。
* Merge Commands:: 相違を選択したり相違の状態を変更するコマンドなど。
* Exiting Emerge:: マージを終えた後に行うこと。
* Combining in Emerge:: 相違にたいする両方の候補を維持する方法。
* Fine Points of Emerge:: その他の問題。


Abbrevs



* Abbrev Concepts::          定義されたabbrevの基本。
* Defining Abbrevs::         abbrevを定義することにより、タイプしたとき展開されるようになります。
* Expanding Abbrevs::        展開の制御 —
                               プレフィクス、展開の取り消し。
* Editing Abbrevs::          定義されたabbrevのリスト全体の閲覧と編集。
* Saving Abbrevs::           他のセッションのためにabbrevのリスト全体を保存する。
* Dynamic Abbrevs::          すでにバッファーにある単語にたいする略語。
* Dabbrev Customization::    動的abbrevのための単語とは何か。ケースごとの処理。

ピクチャーの編集

* Basic Picture:: Pictureモードの基本概念と簡単なコマンド。
* Insert in Picture:: 自己挿入文字の後のカーソル移動方向の制御。
* Tabs in Picture:: タブストップとインデントにたいするさまざまな機能。
* Rectangles in Picture:: 矩形領域のクリアーと重ね合わせ。


ディレクトリーエディターDired



* Dired Enter::              Diredの呼び出し方。
* Dired Navigation::         Diredバッファーでの特別な移動コマンド。
* Dired Deletion::           Diredでのファイルの削除。
* Flagging Many Files::      ファイル名にもとづくファイルへのフラグ付け。
* Dired Visiting::           Diredによるその他のファイル操作。
* Marks vs Flags::           削除のためのフラグとマーク。
* Operating on Files::       1つまたは複数ファイルにたいするコピー、リネーム、プリント、圧縮など。
* Shell Commands in Dired::  マークしたファイルにたいするシェルコマンドの実行。
* Transforming File Names::  複数ファイルのリネームにパターンを使う。
* Comparison in Dired::      Diredの様式で‘diff’を実行する。
* Subdirectories in Dired::  Diredバッファーにたいするサブディレクトリーの追加。
* Subdir Switches:: Diredでのサブディレクトリーのスイッチ。
* Subdirectory Motion::      サブディレクトリー間の移動、上下への移動。
* Hiding Subdirectories::    サブディレクトリーの表示・非表示。
* Dired Updating::           重要でないファイル行の削除。
* Dired and Find::           Diredでファイルを選択するために‘find’を使う。
* Wdired::                   Diredバッファーの編集によりファイルを操作する。
* Image-Dired::              Diredでのイメージサムネイルの閲覧。
* Misc Dired Features::      その他のさまざまな機能。

カレンダーとダイアリー



* Calendar Motion::          カレンダー内の移動、日付の選択。
* Scroll Calendar::          過去または将来の月をスクリーンに表示する。
* Counting Days::            2つの日付の間の日数は?
* General Calendar::         カレンダーの終了と再計算。
* Writing Calendar Files::   さまざまなフォーマットで、カレンダーをファイルに書き込む。
* Holidays::                 休日の日付を表示する。
* Sunrise/Sunset::           日の出と日の入りの時間を地方時間で表示する。
* Lunar Phases::             月の位相の表示。
* Other Calendars::          他のカレンダーシステムへの日付の変換。
* Diary::                    ダイアリーからイベントを表示する。
* Daylight Saving::          夏時間がアクティブな期間を指定する方法。
* Time Intervals::           時間間隔の追跡。
* Advanced Calendar/Diary Usage:: カレンダーとダイアリーの上級のカスタマイズ。


カレンダー内での移動



* Calendar Unit Motion::     日、週、月、年単位での移動。
* Move to Beginning or End::  週、月、年の開始と終了への移動。
* Specified Dates::          今日の日付や、特定の日付への移動。

他のカレンダーへ/からの変換



* Calendar Systems::         (グレゴリオ歴以外の)Emacsが理解するカレンダー。
* To Other Calendar::        選択された日付をさまざまなカレンダーに変換する。
* From Other Calendar::      他のカレンダーで指定された日付に移動する。

ダイアリー



* Format of Diary File::     ダイアリーにイベントを入力する。
* Displaying the Diary::     ダイアリーのエントリーと、それに関連するカレンダーの日付を閲覧する。
* Date Formats::             日付を指定するさまざまな方法。
* Adding to Diary::          ダイアリーのエントリーを作成するコマンド。
* Special Diary Entries::    記念日、日付ブロック、周期的なエントリーなど。
* Appointments::             何かを行なう時刻のためのリマインダー。
* Importing Diary::          ダイアリーのイベントと他のフォーマットの変換。

カレンダーとダイアリーのさらに上級の機能

* Calendar Customizing:: カレンダーのレイアウトとフック。
* Holiday Customizing:: 独自の休日を定義する。
* Mayan Calendar:: マヤ暦で指定された日付への移動。
* Date Display Format:: フォーマットの変更。
* Time Display Format:: フォーマットの変更。
* Diary Customizing:: セットできるデフォルト。
* Non-Gregorian Diary:: 他のカレンダーにもとづくダイアリーエントリー。
* Diary Display:: ダイアリーを表示する方法の選択。
* Fancy Diary Display:: インクルードされたダイアリーファイルを使ったダイアリーエントリーのソート。
* Sexp Diary Entries:: より柔軟なダイアリーエントリー。


Sending Mail



* Mail Format::              メールメッセージのフォーマット。
* Mail Headers::             いくつかの標準的なメールヘッダーフィールドの詳細。
* Mail Aliases::             メールアドレスの短縮とグループ化。
* Mail Commands::            作成するメールを編集するための特別なコマンド。
* Mail Signature::           各メッセージに署名を追加する。
* Mail Amusements::          NSAを混乱させるキーワードや、fortuneのメッセージを累加する。
* Mail Methods::             他のメール作成方法を使用する。

Mail Commands



* Mail Sending::             メッセージを送信するコマンド。
* Header Editing::           ヘッダーフィールドに移動して編集するコマンド。
* Citing Mail::              返信するメッセージのクォート。
* Mail Misc::                ファイル添付、スペルチェックなど。

Rmailでメールを読む



* Rmail Basics::             Rmailの基本的な概念と簡単な使い方。
* Rmail Scrolling::          メッセージをスクロールする。
* Rmail Motion::             他のメッセージへの移動。
* Rmail Deletion::           メッセージの削除と完全な削除。
* Rmail Inbox::              メールがRmailファイルに取り込まれる方法。
* Rmail Files::              複数のRmailファイルの使用。
* Rmail Output::             メッセージを外部ファイルにコピーする。
* Rmail Labels::             メッセージにラベルをつけて分類する。
* Rmail Attributes::         属性と呼ばれる標準的なラベル。
* Rmail Reply::              閲覧しているメッセージにたいして返信する。
* Rmail Summary::            多くのメッセージの簡単な情報の要約。
* Rmail Sorting::            Rmailでのメッセージのソート。
* Rmail Display::            Rmailがメッセージを表示する方法とカスタマイズ。
* Rmail Coding::             Rmailがデコードされた文字セットを扱う方法。
* Rmail Editing::            Rmailでのメッセージのテキストとヘッダーの編集。
* Rmail Digest::             メッセージのダイジェストからメッセージを抽出する。
* Rmail Rot13::              rot13コードでエンコードされたメッセージの閲覧。
* Movemail::                 新たなメールのフェッチに関する詳細。
* Remote Mailboxes::         リモートmailboxからのメールの取得について。
* Other Mailbox Formats::    さまざまなフォーマットのローカルmailboxからのメールの取得。

Rmailのサマリー



* Rmail Make Summary::       さまざまな種類のサマリーの作成。
* Rmail Summary Edit::       サマリーからのメッセージの操作。

Gnus



* Buffers of Gnus::          グループ、サマリー、アーティクルバッファー。
* Gnus Startup::             Gnusの開始するにあたって知っておくべきこと。
* Gnus Group Buffer::        Gnusグループコマンドの短い説明。
* Gnus Summary Buffer::      Gnusサマリーコマンドの短い説明。

ドキュメントの閲覧



* DocView Navigation::       DocViewバッファーの操作。
* DocView Searching::        ドキュメント内の検索。
* DocView Slicing::          ページのどの部分を表示するか指定する。
* DocView Conversion::       変換に影響を与えたり、それを誘発するもの。

Emacsからシェルコマンドを実行する



* Single Shell::             シェルコマンドを実行してから、戻る方法。
* Interactive Shell::        Emacsを通じて入力を行なう永続的なシェル。
* Shell Mode::               永続的なシェルで使用される特別なEmacsコマンド。
* Shell Prompts::            シェルプロンプトを認識する2つの方法。
* Shell History::            シェルバッファーで前のコマンドを繰り返す。
* Directory Tracking::       サブシェルでのディレクトリーの変更の追跡。
* Shell Options::            Shellモードをカスタマイズするオプション。
* Terminal emulator::        端末エミュレーターとしてのEmacsウィンドウ。
* Term Mode::                Termモードで使用される特別なEmacsコマンド。
* Remote Host::              他のコンピューターへの接続。
* Serial Terminal::          シリアルポートへの接続。

シェルコマンドヒストリー



* Shell Ring::               ヒストリーリストからコマンドを取り出す。
* Shell History Copying::コマンドに移動してそれをコピーする。
* History References::       ‘!’スタイルのヒストリー参照の展開。

サーバーとしてのEmacsの使用



* TCP Emacs server::         TCPソケットのlisten。
* Invoking emacsclient::     Emacsサーバーへの接続。
* emacsclient Options::      Emacsクライアントの開始オプション。

ハードコピーの印刷



* PostScript::               バッファーまたはリージョンを、PostScriptとして印刷する。
* PostScript Variables::     PostScript印刷コマンドのカスタマイズ。
* Printing Package::         オプションの上級向け印刷インターフェース。

ハイパーリンクとナビゲーション機能



* EWW::                      Emacsのウェブブラウザー。
* Embedded WebKit Widgets::  EmacsバッファーでLispを実行する。
* Browse-URL::               URLをフォローするには。
* Goto Address mode::        URLのアクティブ化について。
* FFAP::                     ポイント位置のファイルを探す、など。

Emacs Lispパッケージ



* Package Menu::             パッケージを閲覧・管理するためのバッファー。
* Package Installation::     パッケージのインストールにたいするオプション。
* Package Files::            パッケージがインストールされる場所。

Customization



* Easy Customization::       設定を閲覧したり変更する便利な方法。
* Variables::                多くのEmacsコマンドは何を行なうか決定するためにEmacs変数を調べるので、変数をセットすることによりこれらの機能を制御できます。
* Key Bindings::             keymapsは各キーがどのコマンドを実行するか指定します。これらを変更することによりキーを再定義できます。
* Init File::                初期化ファイルで一般的なカスタマイズを記述する方法。

Easy Customizationインターフェース



* Customization Groups::     セッティングがクラス化される方法。
* Browsing Custom::          セッティングのブラウズとサーチ。
* Changing a Variable::      オプション値の編集、およびオプションをセットする方法。
* Saving Customizations::    将来のEmacsセッションのためにカスタマイズを保存する。
* Face Customization::       フェイスの属性を編集する方法。
* Specific Customization::   グループの特定のセッティングのカスタマイズ。
* Custom Themes::            カスタマイズセッティングのコレクション。
* Creating Custom Themes::   新しいカスタムテーマを作成する方法。

Variables



* Examining::                変数の値の検証とセッティング。
* Hooks::                    フック変数によりEmacsの一部にたいして特定の機会に実行するプログラムを指定できます。
* Locals::                   変数のバッファーごとの値。
* File Variables::           ファイルが変数の値を指定する方法。
* Directory Variables::      ディレクトリーにより変数の値を指定する方法。

ファイル内のローカル変数



* Specifying File Variables::  ファイルローカル変数の指定。
* Safe File Variables::      ファイルローカル変数が安全であることを確認する。

キーバインドのカスタマイズ



* Keymaps::                  一般的な考え方。グローバルキーマップ。
* Prefix Keymaps::           プレフィクスキーにたいするキーマップ。
* Local Keymaps::            キーマップをもつメジャーモードとマイナーモード。
* Minibuffer Maps::          ミニバッファーが使用する独自のキーマップ。
* Rebinding::                あるキーの意味を再定義する便利な方法。
* Init Rebinding::           初期化ファイルでのキーのリバインド。
* Modifier Keys::            キーバインドでの修飾キーの使用。
* Function Keys::            端末のファンクションキーのリバインド。
* Named ASCII Chars::        <TAB>と‘C-i’などを区別する方法。
* Mouse Buttons::            Emacsでのマウスボタンのリバインド。
* Disabling::                コマンドを無効にするとは、それを実行できるようにする前に確認が要求されることを意味します。これはビギナーを戸惑わせないようにするために行なわれます。

Emacsの初期化ファイル



* Init Syntax::              Emacs Lispでの定数の構文。
* Init Examples::            initファイルで何かを行なう方法。
* Terminal Init::            端末タイプごとのinitファイル。
* Find Init::                Emacsがinitファイルを探す方法について。
* Init Non-ASCII::           initファイルでの非ASCII文字の使用。

Emacsでトラブルに対処する



* DEL Does Not Delete::      <DEL>で削除できないとき、何を行なうべきか。
* Stuck Recursive::          モードラインのカッコの周囲の’[...]’。
* Screen Garbled::           画面上のゴミ。
* Text Garbled::             テキストの中のゴミ。
* Memory Full::              メモリー不足に対処する方法。
* Crashing::                 クラッシュ時にEmacsが何を行なうか。
* After a Crash::            クラッシュしたEmacsセッションでの編集をリカバリーする。
* Emergency Escape::         Emacsが応答しなくなったとき、何を行なうべきか。

バグの報告



* Known Problems::           既知の問題とバグについて読む方法。
* Bug Criteria::             本当にバグを見つけたのか?
* Understanding Bug Reporting::  バグを報告する効果的な方法。
* Checklist::                良いバグレポートのためにしたがうべきステップ。
* Sending Patches::          GNU Emacsにパッチを送る方法。

Contributing to Emacs Development



* Coding Standards::         Gnu Emacsのコーディング規約。
* Copyright Assignment::     FSFに著作権を譲渡する。

Emacs呼び出しにたいするコマンドライン引数



* Action Arguments::         ファイルのvisit、ライブラリーのロード、関数を呼び出す引数。
* Initial Options::          Emacsの開始に影響する引数。
* Command Example::          コマンドライン引数の使用例。
* Environment::              Emacsが使用する環境変数。
* Display X::                デフォルトディスプレーの変更と、リモートログインの使用。
* Font X::                   Xでのテキストのフォント選択。
* Colors X::                 ディスプレーカラーの選択。
* Window Size X::            Xでのスタートアップウィンドウのサイズ。
* Borders X::                Xでの内枠ボーダーと外枠ボーダー。
* Title X::                  初期フレームのタイトルの指定。
* Icons X::                  Xで使用するアイコンの選択。
* Misc X::                   その他のディスプレーオプション。

環境変数



* General Variables::        すべてのバージョンのEmacsが使用する環境変数。
* Misc Variables::           システム固有の変数。
* MS-Windows Registry::      MS-Windowsでの環境の代用。

Xオプションとリソース



* Resources::                EmacsでXリソースを使用する(概説)。
* Table of Resources::       Emacsに影響する特定のXリソースの表。
* Lucid Resources::          LucidメニューにたいするXリソース。
* Motif Resources::          MotifおよびLessTifメニューにたいするXリソース。
* GTK resources::            GTKウィジェットにたいするリソース。

GTK resources



* GTK Resource Basics::      GTK+リソースの基本的な使い方。
* GTK Widget Names::         GTK+ウィジェットの命名方法。
* GTK Names in Emacs::       Emacsが使用するGTK+ウィジェット。
* GTK styles::               GTK+ウィジェットの何がカスタマイズできるか。

EmacsとmacOS、GNUstep



* Mac / GNUstep Basics::     GNUstepまたはmacOSでのEmacsの基本的な使用方法。
* Mac / GNUstep Customization::  GNUstepまたはmacOSでのカスタマイズ。
* Mac / GNUstep Events::     ウィンドウシステムイベントが処理される方法。
* GNUstep Support::          GNUstepサポート状態の詳細。

EmacsとMicrosoft Windows/MS-DOS



* Windows Startup::          WindowsでEmacsを開始する方法。
* Text and Binary::          行末にCRLFを使用するテキストファイル。
* Windows Files::            Windowsのファイル名の慣習。
* ls in Lisp::               Diredにたいする‘ls’のエミュレーション。
* Windows HOME::             開始時にEmacsが‘.emacs’を探す場所。
* Windows Keyboard::         Windows特有のキーボード機能。
* Windows Mouse::            Windows特有のマウス機能。
* Windows Processes::        Windowsでのサブプロセスの実行。
* Windows Printing::         MS-Windowsでプリンターを指定する方法。
* Windows Fonts::            MS-Windowsでのフォントの指定。
* Windows Misc::             その他のWindowsの機能。
* MS-DOS:: MS-DOSでのEmacsの使用。

EmacsとMS-DOS

* MS-DOS Keyboard:: MS-DOSでのキーボードの慣習。
* MS-DOS Mouse:: MS-DOSでのマウスの慣習。
* MS-DOS Display:: MS-DOSでのフォント、フレーム、ディスプレーのサイズ。
* MS-DOS File Names:: MS-DOSでのファイル名の慣習。
* MS-DOS Printing:: MS-DOSでの印刷の特性。
* MS-DOS and MULE:: MS-DOSでの国際化のサポート。
* MS-DOS Processes:: MS-DOSでのサブプロセスの実行。




File: emacs-ja.info,  Node: Distrib,  Next: Intro,  Prev: Top,  Up: Top

ディストリビューション
**********************

GNU Emacsは“free software(フリーソフトウェアー、自由なソフトウェアー)”で
す。これはすべての人が自由に使用でき、特定の条件の元に自由に再配布できる
ことを意味します。GNU Emacsはパブリックドメイン(public domain: 特許権の
消滅状態)ではありません。copyright(版権)されており、配布については制限が
あります。しかし、それらの制限は良き共同的な市民(good cooperating
citizen)が行ないたいと欲するであろう、すべてのことを許すようデザインされ
ています。なにが許されていないか、それはあなたから取得するかもしれない
GNU Emacsの任意のバージョンの更なる共有を妨げる試みです。これの正確な条
件はEmacsのGNU General Public Licenseで見ることができ、このマニュアルに
も記載されています(1)。 *note Copying::を参照してください。

   GNU Emacsのコピーを入手する1つの方法は、それを所有する他の誰かから入
手する方法です。これを行なうための許可を求めたり、他の誰かに告げる必要は
ありません。ただコピーするだけです。インターネットへアクセスできるなら、
匿名FTPからGNU NEmacsの最新のディストリビューションバージョンを入手でき
ます。わたしたちのウェブサイトについての詳細は、
<https://www.gnu.org/software/emacs>を参照してください。

   コンピューターを購入したときに、GNU Emacsを入手するかもしれません。コ
ンピューター業者は、他のすべての人に適用されるのと同じ条件で、コピーを自
由に配布できます。これらの条件は、コンピューター業者がソースにたいして行
なった変更を含む完全なソースをあなたに与えることと、General Public
Licenseの通常の条件の下に、入手したGNU Emacsをあなたが再配布できることを
要求します。言い換えると、そのプログラムはあなたが入手したときはフリーで
なければならず、業者にとっては単にフリーという訳ではありません。

   GNU Emacsが有用だと思ったら、わたしたちの作業をサポートするために、ど
うかFree Software Foundationに*寄付を送ってください*。合衆国ではFree
Software Foundationへの寄付は、税金が控除されます。職場でGNU Emacsを使用
している場合は、どうかその企業に寄付を行なうよう提案してください。寄付を
するには、<https://my.fsf.org/donate/>を参照してください。あなたが手助け
できる他の方法については、<https://www.gnu.org/help/help.html>を参照して
ください。

   わたしたちは、このマニュアルと、Robert J. Chassellによる‘An
Introduction to Programming in Emacs Lisp’のハードコピーも販売しています
。あなたは、わたしたちのオンラインショップ<https://shop.fsf.org/>を訪れ
ることができます。販売による収益は、Free Software Foundationの目的 — す
なわち新しいソフトウェアーの開発、GNU Emacsを含む既存のプログラムの改良
をサポートします。

   Free Software Foundationに連絡する必要がある場合は、
<https://www.fsf.org/about/contact/>を参照するか、下記に手紙を送ってくだ
さい

     Free Software Foundation
     51 Franklin Street, Fifth Floor
     Boston, MA 02110-1301
     USA

   ---------- Footnotes ----------

   (1) このマニュアル自身はGNU Free Documentation Licenseにより保護され
ています。このライセンスの精神はGeneral Public Licenseと同様ですが、より
ドキュメントに適したものです。*note GNU Free Documentation License::を参
照してください。


File: emacs-ja.info,  Node: Intro,  Next: Screen,  Prev: Distrib,  Up: Top

イントロダクション
******************

あなたはEmacsのマニュアル読んでいるところです。Emacsは、セルフドキュメン
ト方式で、カスタマイズ可能で、拡張可能エディターであり、GNUの先進性を具
現化したものです( GNU (GNU’s Not Unix) の‘G’は発音します)。

   Emacsは“先進的(advanced)”であるというのは、単純な挿入と削除だけでなく
、プロセスの制御、プログラムのインデントの自動化、複数ファイルの同時表示
、整形済みテキストの編集、文字、単語、行、文、段落、ページを扱うのと同様
に、異なるプログラミム言語の式やコメントを扱う機能なども提供するからです
。

   “セルフドキュメント方式(Self-documenting)”とは、いつでも“ヘルプコマン
ド”として知られる、特別なコマンドを使うことができることです。これはどの
ようなオプションがあるのか、コマンドが何をするのかを見つけたり、与えられ
たトピックと関連するすべてのコマンドを見つけることができるコマンドです。
*note Help::を参照してください。

   “カスタマイズ可能(Customizable)”とは、シンプルな方法でEmacsコマンドの
動作を簡単に変更できるということです。たとえば、‘<**’で始まり‘**>’で終わ
るようなコメントのプログラム言語を使っている場合は、Emacsのコメント操作
コマンドに、これらの文字列を使うように指示できます(*note Comments::を参
照してください)。別の例としては、カーソル動作(上下左右)を再編成して使い
やすくカスタマイズできます。*note Customization::を参照してください。

   “拡張可能(Extensible)”とは、単純なカスタマイズではなく、まったく新し
いコマンドを作成できるということです。新しいコマンドは、Emacs自身の
Lisp処理系で動作する、Lisp言語でプログラムを記述されます。既存のコマンド
は、編集を行なっている最中でさえ、Emacsを再起動することなく再定義できま
す。Emacsのほとんどの編集コマンドはLispで記述されています。Lispで記述す
ることも可能ですが、効率のためにCで記述されているものもあります。拡張機
能の記述はプログラミングですが、プログラマーでない人も後でそれを使うこと
ができます。もしあなたがEmacs Lispを学びたければ、*note Emacs Lisp
Intro: (eintr)Top.を参照してください。


File: emacs-ja.info,  Node: Screen,  Next: User Input,  Prev: Intro,  Up: Top

1 画面の構成
************

Xウィンドウシステムを使うGNU/Linuxのようなグラフィカルなディスプレーの場
合、Emacsはグラフィカルなウィンドウに表示されます。テキスト端末の場合、
Emacsは端末スクリーン全体を表示領域として使います。Emacsが占有する画面ス
クリーンや、グラフィカルなウィンドウを指して、“フレーム(frame)”という用
語を使用します。Emacsの振る舞いは、どちらのフレームでも同じです。通常は
1個のフレームだけで始まりますが、必要ならば新たにフレームを作れます
(*note Frames::を参照してください)。

   それぞれのフレームにはいくつかの領域が含まれています。いちばん上のフ
レームは“メニューバー(menu bar)”で、メニューにある一連のコマンドにアクセ
スできます。グラフィカルなディスプレーでは、メニューバーのすぐ下に“ツー
ルバー(tool bar)”があり、アイコンをクリックすることにより編集コマンドを
実行できます。いちばん下のフレームは“エコーエリア(echo area)”で、メッセ
ージが表示されたり、Emacsが入力を求める際に使用されます。

   (もしあれば)ツールバーの下とエコーエリアの間の、フレームの主要な領域
の部分を、“ウィンドウ(the window)”といいます。このマニュアルでは“ウィン
ドウ”という言葉を、上記のような場合に使います。グラフィカルなディスプレ
ーのシステムでは、“ウィンドウ”という言葉を違う意味で用いますが、上述した
とおり、そのようなグラフィカルなウィンドウのことは、“フレーム”と呼ぶこと
にします。

   Emacsのウィンドウには、“バッファー(buffer)” — 編集、または閲覧してい
りテキストやグラフィック — が表示されます。グラフィカルなディスプレーで
は、ウィンドウの片側に“スクロールバー(scroll bar)”あり、これを使ってバッ
ファー内をスクロールできます。ウィンドウのいちばん下の行は、“モードライ
ン(mode line)”です。これには保存されてない変更や、使用されている編集モー
ド、現在のライン番号など、バッファーについての様々な情報が表示されます。

   Emacsを起動すると、通常フレームには1つのウィンドウが表示されます。し
かしこのウィンドウを水平方向、または垂直方向に分割して複数のウィンドウを
作成し、それぞれ異なるバッファーを表示することもできます(*note
Windows::を参照してください)。

   どんな時でも、1つのウィンドウが“選択されたウィンドウ(selected
window)”となります。グラフィカルなディスプレーでは、選択されたウィンドウ
には目立つカーソル(通常は塗りつぶされて点滅している)が表示され、他のウィ
ンドウには目立たないカーソル(通常はぬりつぶされていない四角)が表示されま
す。テキスト端末では、選択されたウィンドウのカーソルだけが表示されます。
選択されたウィンドウ上に表示されているバッファーを、“カレントバッファー
(current buffer)”と呼び、それが編集が行われているバッファーとなります。
多くのEmacsコマンドはカレントバッファーに暗黙に適用され、選択されてない
ウィンドウに表示されているテキストは参照用に使用します。もしグラフィカル
なディスプレーで複数のフレームを使っている場合、特定のフレームを選択する
と、そのフレームのウィンドウが選択されます。

* Menu:

* Point::                    テキスト内で編集コマンドが作用する場所
* Echo Area::                スクリーンのいちばん下で、短いメッセージが表示されます
* Mode Line::                モードを説明するライン
* Menu Bar::                 メニューバーの使い方


File: emacs-ja.info,  Node: Point,  Next: Echo Area,  Up: Screen

1.1 ポイント
============

カーソルは、選択されたウィンドウで多くの編集コマンドが作用する場所を示し
、その場所を“ポイント(point)”(1)と呼びます。多くのEmacsコマンドはポイン
トをテキスト中で移動し、テキスト中のさまざまな箇所で編集できるようにしま
す。マウスのボタン1(通常は左ボタン)をクリックしても、ポイントを移動でき
ます。

   デフォルトでは、選択されたウィンドウ上にある、塗りつぶされたボックス
のカーソルは文字の_上_に表示されますが、ポイントは2つの文字の_間_にある
と考える必要があります。つまりポイントは、カーソルが重なっている文字の
_前_にあります。たとえば、‘frob’というテキストで、‘b’にカーソルがある場
合、ポイントは‘o’と‘b’の間にあります。その位置に‘!’という文字を挿入する
と、‘fro!b’という結果になり、ポイントは‘!’と‘b’の間にあります。つまりカ
ーソルは‘b’の上にあり、実行前と同じです。

   Emacsでいくつかのファイルを編集して、各ファイルがそれぞれ専用のバッフ
ァーにある場合、各バッファには独自のポイント位置があります。バッファーが
表示されていなくても、後で表示されるときに備えて、ポイント位置を記録して
います。1つのフレームに複数のウィンドウがある場合、各ウィンドウには独自
のポイント位置があります。

   Emacsがカーソルをどのように表示するか制御する方法については、*note
Cursor Display::を参照してください。

   ---------- Footnotes ----------

   (1) “point”という用語は、文字‘.’に由来します。この文字は、現在ポイン
トと呼んでいる値を参照するためのTECO(オリジナルのEmacsを記述していた言語
)のコマンドです。


File: emacs-ja.info,  Node: Echo Area,  Next: Mode Line,  Prev: Point,  Up: Screen

1.2 エコーエリア
================

フレームの1番下の行は、“エコーエリア(echo area)”です。ここは、いろいろな
目的向けの短いテキスト表示に使われます。

   エコーエリアという名前は、あなたが打った文字が“エコーされる”ことが由
来で、これは複数の文字からなるコマンドが表示されることを意味します。1文
字のコマンドをエコーすることはありません。複数の文字からなるコマンド
(*note Keys::を参照してください)の途中で、入力中に1秒以上間を置くとエコ
ーされます。Emacsはそれまでに入力されたコマンドの文字を表示し、ユーザー
に残りの文字の入力を促します。いったんエコーが始まると、コマンドの残りは
、打つと同時にただちにエコーされます。これは、タイプに自信のあるユーザー
には速い応答を提供する一方で、自信のないユーザーには最大限のフィードバッ
クを与えるための機能です。

   エコーエリアは、コマンドを実行できなかったときに、“エラーメッセージ
(error message)”を表示するためにも使用されます。エラーメッセージと共に、
ビープ音が鳴ったり、画面が点滅する場合もあります。

   エコーエリアに有用なメッセージを表示するコマンドもあります。これらの
“有用”なメッセージは、エラーメッセージによく似ていますが、ビープ音を伴わ
ず点滅もしません。たとえば、コマンド‘C-x =’(<Ctrl>を押したまま‘x’をタイ
プし、<Ctrl>を離してから‘=’をタイプします)は、テキスト中のポイントの文字
位置と、ウィンドウの現在の列位置を示すメッセージを表示します。処理に時間
のかかるコマンドでは、実行中に‘...’(どの程度進行したかをパーセント表示で
示す場合もあります)で終わるメッセージをエコーエリアに表示し、完了時には
‘done’を最後に付け加えることがよくあります。

   エコーエリアに表示される有益なメッセージは、‘*Messages*’と呼ばれる特
別なバッファーに保存されます(まだバッファーについては説明していませんが
、詳細は*note Buffers::を参照してください)。画面上に短時間しか表示されな
いメッセージを見逃してしまった場合には、‘*Messages*’バッファーに切り替え
て、もう一度そのメッセージを見ることができます。‘*Messages*’のサイズは、
ある行数に制限されています。変数‘message-log-max’は、その行数を指定しま
す(まだ変数については説明していませんが、詳細は*note Variables::を参照し
てください)。いったんバッファーがこの行数を超えると、最後に1行加わるごと
に先頭の1行を削除します。

   Emacsがエコーエリアをどのように使用するか制御するオプションについては
、*note Display Custom::を参照してください。

   エコーエリアは“ミニバッファー(minibuffer)”の表示にも使われます。これ
は、編集しようとするファイル名のような、コマンドへの引数を読むのに使われ
るウィンドウです。ミニバッファーが使用されているとき、エコーエリアには
“プロンプト文字列(prompt string)”で始まるテキストが表示され、エコーエリ
アが一時的に選択されたウィンドウとなり、カーソルもその行に表示されます。
‘C-g’を打つと、いつでもミニバッファーから抜けられます。*note
Minibuffer::を参照してください。


File: emacs-ja.info,  Node: Mode Line,  Next: Menu Bar,  Prev: Echo Area,  Up: Screen

1.3 モードライン
================

ウィンドウの最後の行は“モードライン(mode line)”で、そのウィンドウで何が
進行しているか表示します。ウィンドウが1つしかない場合、モードラインはエ
コーエリアのすぐ上に表示されます。フレームでは最後から2番目の行になりま
す。グラフィカルなディスプレーでは、モードラインは立体的に描画されます。
通常、Emacsは目立つように選択されたウィンドウのモードラインを、選択され
ていないウィンドウと異なるカラーで描画します。

   モードラインに表示されるテキストは以下の書式です:

      CS:CH-FR  BUF      POS LINE   (MAJOR MINOR)

テキスト端末では、上記テキストの後ろからウィンドウの右端まで一連のダッシ
ュ表示されます。これらのダッシュはグラフィカルなディスプレーでは省略され
ます。

   CSとその後ろのコロンは、カレントバッファーのキャラクターセットと改行
の規則を説明しています。通常Emacsはこれらの設定を自動的に処理しますが、
このメッセージが便利なときもあります。

   CSはバッファーのキャラクターセットを説明します(*note Coding
Systems::を参照してください)。もしこれがダッシュ(‘-’)の場合、特定のキャ
ラクターセットの処理が行われていないことを意味します(例外として、以降で
説明する行末規則があります)。‘=’の場合は、変換が行われていないことを意味
し、通常はテキストに非テキストデータが含まれているときに使用されます。他
の文字はさまざまな“コーディングシステム(coding systems)” — たとえば‘1’は
ISO Latin-1を表します。

   テキスト端末ではCSの前に追加で2つの文字が表示され、それによりキーボー
ド入力と端末出力のコーディングシステムが示されます。さらに何らかの入力メ
ソッドを使用している場合は、CSの前に入力メソッドを識別する文字列が表示さ
れます(*note Input Methods::を参照してください)。

   CSの後ろの文字は、通常コロンです。もし違う文字が表示されている場合、
それはファイルのエンコーディングに特別な行末規則が使われていることを意味
します。通常ファイル内のテキストの各行は“改行文字(newline characters)”で
区切られていますが、他の2つの規則が使われる場合もあります。MS-DOSのファ
イルを編集する場合にはキャリッジリターン(carriage-return)とラインフィー
ド(linefeed)が使われ、コロンではなくバックスラッシュ(‘\’)または
‘(DOS)’(オペレーティングシステムに依存する)が表示されます。古いマッキン
トッシュシステムのファイルでは、改行文字の代わりにキャリッジリターン
(carriage-return)が使われ、そのような場合コロンではなくスラッシュ(‘/’)ま
たは‘(Mac)’が表示されます。いくつかのシステムでは行の区切りとして改行文
字を使う場合、コロンではなく‘(Unix)’と表示されます。

   ‘emacsclient’ (*note Invoking emacsclient::を参照)で作成されたフレー
ムでは、次の文字に‘@’が表示されます。これは通常、デーモン(*note Emacs
Server::を参照)として実行中のEmacsプロセスのフレームにたいして表示されま
す。

   モードラインの次の要素はCHで示される文字列です。2つのダッシュ(‘--’)が
表示されている場合、ウィンドウに表示されているバッファーとディスク上のフ
ァイルの内容が同じことを意味し、たとえばバッファーが未変更(unmodified)の
場合です。バッファーが変更されている場合には2つの星印(‘**’)が表示されま
す。読み出し専用のバッファーの場合には、バッファーが編集されている場合に
は‘%*’になり、バッファーが編集されていない場合には‘%%’となります。

   通常、CHの後ろの文字はダッシュ(‘-’)です。しかしカレントバッファーの
‘default-directory’ (*note File Names::を参照)がリモートマシン上(*note
File Names::を参照してください)にある場合、かわりに‘@’が表示されます。

   FRは選択されているフレームの名前です(*note Frames::を参照してください
)。これはテキスト端末でだけ表示されます。フレーム名の初期値は‘F1’です。

   BUFは、ウィンドウに表示されているバッファーの名前です。通常は編集中の
ファイル名と同じです。*note Buffers::を参照してください。

   POSはウィンドウの上またはウィンドウの下に、まだテキストがあるかを知ら
せます。もしバッファーが小さくてウィンドウに全体が表示されている場合、
POSには‘All’が表示されます。そうではなくバッファーの一部が表示されている
ときには、バッファーの先頭が表示されている場合には‘Top’、バッファーの最
後が表示されている場合には‘Bot’、‘NN%’と表示されている場合、NNはウィンド
ウの上部がバッファーのどこかをパーセント表示したものです。Size
Indication(サイズ表示)モードでは、バッファー全体のサイズを表示できます。

   LINEは、‘L’のあとに現在ポイントがある行の番号が続いたものです(Column
Number(列番号)モードをオンにすると、現在の列番号も表示できます。*note
Optional Mode Line::を参照してください)。

   majorは、そのバッファの“メジャーモード(major mode)”の名前です。メジャ
ーモードはバッファーを編集する際の主要なモードで、Textモード、Lispモード
、Cモードなどがあります。*note Major Modes::を参照してください。メジャー
モード名の後ろに追加の情報を表示するメジャーモードもあります。たとえば
Compilation buffer(コンパイルバッファー)やShell buffer(Shellバッファー
)などは、サブプロセスの状態を表示します。

   MINORは有効になっている“マイナーモード(minor modes)”の一覧で、上位の
メジャーモードに追加の機能を提供するための編集モードです。*note Minor
Modes::を参照してください。

   いくつかの機能は、それらが本当はマイナーモードではなくても、有効にな
っていればマイナーモードの一覧とともに表示されます。‘Narrow’は、表示中の
バッファーが、そのテキストの一部のみを編集するように制限されていることを
示します(*note Narrowing::を参照してください)。‘Def’は、キーボードマクロ
を定義中であることを示します(*note Keyboard Macros::を参照してください
)。

   さらにEmacsがリカーシブエディットにあるときには、モードを囲んでいるカ
ッコの周りに角カッコ(‘[...]’)が現れます。リカーシブエディット中も別のリ
カーシブエディットに入ると、角カッコは2重になります。リカーシブエディッ
トは、特定のバッファにだけ関係するものではなく、Emacs全体に影響するので
、角カッコはすべてのウィンドウのモード行に表示されるか、まったく表示され
ないのどちらかです。*note Recursive Edit::を参照してください。

   モードラインの外観は、その内容の書式と同様、変更できます。*note
Optional Mode Line::を参照してください。さらにモードラインはマウスに反応
します。モードラインの違う部分をクリックすることでさまざまなコマンドを実
行できます。*note Mode Line Mouse::を参照してください。また、モードライ
ンのマウス感応範囲上でマウスポインターをホバリングすると、モードライン上
でクリックして呼び出すことができるコマンドに関する情報を表示するツールチ
ップ(*note Tooltips::を参照)が表示されます。 Also, hovering the mouse
pointer above mouse-sensitive portions of the mode line shows tooltips
(*note Tooltips::) with information about commands you can invoke by
clicking on the mode line.


File: emacs-ja.info,  Node: Menu Bar,  Prev: Mode Line,  Up: Screen

1.4 メニューバー
================

各Emacsフレームには通常、最上部に“メニューバー(menu bar)”があり、よく使
われる操作を実行するために使用できます。これはあなた自身で簡単に確かめら
れますから、ここではそれらを列挙する必要はないでしょう。

   マウスをサポートするディスプレー上では、マウスを使ってメニューバーか
らコマンドを選ぶことができます。メニューアイテムの後にある右矢印は、その
アイテムにサブメニューがあることを示します。アイテムの最後に‘...’がある
場合は、コマンドを実際に実行する前に、そのコマンドがキーボードから引数を
読み取ることを意味します。

   メニューのコマンドの中には、他のコマンドと同様、キーが割り当てられて
いるものもあります。そのような場合、メニューのアイテムの後にキーバインデ
ィングが表示されます。メニューアイテムの完全なコマンド名や説明文を見るに
は、‘C-h k’とタイプしてから、通常どおりにマウスでメニューバーを選択して
ください(*note Key Help::を参照してください)。

   マウスを使う代わりに<F10>(コマンド‘menu-bar-open’を実行します)を押せ
ば、メニューバーの最初のアイテムを呼び出すことができます。その後は矢印キ
ー、または‘C-b’と‘C-f’(左右)、‘C-p’と‘C-n’(上下)でメニュー操作できます。
選択されたメニューアイテムを起動するときは<RET>、メニュー操作をキャンセ
ルするときは‘C-g’か‘<ESC> <ESC> <ESC>’を押します。(ただし、GUIツールキッ
トとともにビルドされたEmacsでは、メニューはそのツールキットにより描画お
よび制御され、メニュー操作をキャンセルするキーシーケンスは上記の説明とは
異なるかもしれません。)

   テキスト端末では、エコーエリアからメニューバーのメニューにアクセスす
ることもできます。これを行うには、変数‘tty-menu-open-use-tmm’をカスタマ
イズして、非‘nil’値にします。その後は<F10>をタイプするとメニューをドロッ
プダウンせずに、コマンド‘tmm-menubar’が実行されます(‘M-`’は常に
‘tmm-menubar’を呼び出します)。‘tmm-menubar’では、キーボードでメニューア
イテムを選択できます。暫定的な候補がエコーエリアに表示されるので、上矢印
か下矢印でメニューの異なるアイテムを表示し、<RET>を押せばアイテムを選択
できます。各メニューアイテムを文字か数字で指定することもできます(通常メ
ニューアイテム名のイニシャル)。この文字または数字とアイテム名は‘==>’で区
切られています。アイテムの文字または数字を押せばアイテムを選択することが
できます。


File: emacs-ja.info,  Node: User Input,  Next: Keys,  Prev: Screen,  Up: Top

2 ユーザー入力の種類
********************

GNU Emacsは、主にキーボードを使うようにデザインされています。マウスを使
ってメニューバーやツールバーの編集コマンドを実行することはできますが、キ
ーボードを使う場合に比べて効率的ではありません。したがって、このマニュア
ルには主にキーボードで編集する方法を記します。

   Emacsにたいするキーボード入力は、ASCIIを大きく拡張したバージョンが基
本となっています。‘a’、‘B’、‘3’、‘=’や空白文字(<SPC>)と表記します)などの
単純な文字は、それぞれに対応するキーをタイプして入力します。<RET>、
<TAB>、<DEL>、<ESC>、<F1>、<Home>、<LEFT>などの制御文字なども、この方法
で入力できますし、非英語キーボードの特定の文字も同様です(*note
International::を参照してください)。

   Emacsは“修飾キー(modifier keys)”を用いて入力された制御文字も認識しま
す。よく使用される修飾キーは、<Control>(通常<Ctrl>)というラベル)と、
<Meta>(通常<Alt>(1)というラベル)の2つです。たとえば、‘Control-a’は
<Ctrl>を押したままで‘a’を押して入力しますが、これを短く‘C-a’と記します。
同様に、‘<Meta>-a’または短く‘M-a’は、<Alt>を押したまま‘a’を押すことです
。修飾キーは英数文字以外のキーにも適用できます。例: ‘C-<F1>’、‘M-<LEFT>’

   <ESC>で始まる2文字キーシーケンスを使って、Meta文字を入力することもで
きます。したがって‘M-a’を‘<ESC> a’と入力することができます。
‘C-M-a’(<Ctrl>と<Alt>を両方押しながら‘a’を押下)は‘<ESC> C-a’と入力できま
す。<Meta>と違い、<ESC>は切り離された文字です。次の文字を押すとき<ESC>を
押しっぱなしにするのではなく、<ESC>を押して離してから次の文字を入力しま
す。この機能は<Meta>キーをあてにできない、一部のテキスト端末で有用です。

   グラフィカルなディスプレーでは、ウィンドウマネージャーが‘M-<TAB>’、
‘M-<SPC>’、‘C-M-d’、‘C-M-l’などのキーボード入力をブロックするかもしれま
せん。このような問題がある場合、ウィンドウマネージャーがこれらのキーをブ
ロックしないようにカスタマイズしたり、影響を受けるEmacsのコマンドをリバ
インド(rebind)したりできます(*note Customization::を参照してください)。

   単純な文字や制御文字、同様にマウスのクリックなどの非キーボード入力は
、総じて“入力イベント(input events)”と呼ばれます。Emacsが内部で入力イベ
ントをどのように処理するかについての詳細は、*note (elisp)Input Events::を
参照してください.

   ---------- Footnotes ----------

   (1) 歴史的な理由により、<Alt>のことを<Meta>という名前で参照します。


File: emacs-ja.info,  Node: Keys,  Next: Commands,  Prev: User Input,  Up: Top

3 キー
******

Emacsコマンドには、ただ1つの入力イベントで呼び出されるものが、いくつかあ
ります。たとえば‘C-f’はバッファーを1文字前方に移動します。他のコマンドは
、‘C-x C-f’や‘C-x 4 C-f’のように、2つ以上の入力イベントにより呼び出され
ます。

   “キーシーケンス(key sequence)”、短く書くと“キー(key)”は、1つの単位と
して考えることのできる、1つまたはそれ以上の一連の入力イベントの集まりの
ことです。もし、あるキーシーケンスがコマンドを呼び出すような場合、それを
“コンプリートキー(complete key)”と呼ぶことにします。たとえば‘C-f’、‘C-x
C-f’、‘C-x 4 C-f’などはコンプリートキーです。もし、あるキーシーケンスが
コマンドを呼び出すほど十分長くないとき、それを“プレフィクスキー(prefix
key)”と呼ぶことにします。たとえば前の例でいうと、‘C-x’や‘C-x 4’はプレフ
ィクスキーです。すべてのキーシーケンスは、コンプリートキーかプレフィクス
キーのどちらかになります。

   プレフィクスキーは、その後の入力イベントと組み合わせて、もっと長いキ
ーシーケンスを作るためのものです。たとえば‘C-x’ はプレフィクスキーなので
、‘C-x’と入力しただけではコマンドは呼び出されません。かわりにEmacsは更な
る入力を待ちます(もし１秒以上入力がない場合、入力を促すために‘C-x’がエコ
ーされます。*note Echo Area::を参照してください)。‘C-x’は、それに続く次
の入力イベントと組み合わされる、2イベントのキーシーケンスで、それはプレ
フィクスキー(‘C-x 4’)など)のときもあれば、コンプリートキー(‘C-x C-f’など
)のときもあります。キーシーケンスの長さに制限はありませんが、実際に3つ、
4つ以上の入力イベントの場合は、ほとんどありません。

   コンプリートキーに入力イベントを付け加えることはできません。たとえば
、‘C-f’はコンプリートキーなので、2イベントのシーケンス‘C-f C-k’は、1つで
はなく2つのキーシーケンスです。

   デフォルトではEmacsのプレフィクスキーは‘C-c’、‘C-h’、‘C-x’、‘C-x
<RET>’、‘C-x @’、‘C-x a’、‘C-x n’、‘C-x r’、‘C-x v’、‘C-x 4’、‘C-x 5’、
‘C-x 6’、<ESC>、‘M-g’、‘M-o’です(<F1>と<F2>は、‘C-h’と‘C-x 6’のエイリア
スです)。このリストは不変のものではありません。Emacsをカスタマイズすれば
、新しいプレフィクスキーを作ることができます。標準のプレフィクスキーを無
効にすることさえできますが、これはほとんどのユーザーにたいして推奨はでき
ません。たとえばプレフィクス定義‘C-x 4’を削除すると、‘C-x 4 C-f’は無効な
キーシーケンスになります。*note Key Bindings::を参照してください。

   プレフィックスキーのあとにヘルプ文字(‘C-h’や<F1>)を押すと、そのプレフ
ィックスで始まるコマンド一覧を表示できます。唯一の例外は<ESC>です。
‘<ESC> C-h’は‘C-M-h’と同じで、これは何かまったく別のことを行うコマンドで
す。しかし<F1>ならば、<ESC>で始まるコマンドの一覧を表示できます。


File: emacs-ja.info,  Node: Commands,  Next: Entering Emacs,  Prev: Keys,  Up: Top

4 キーとコマンド
****************

このマニュアルは、特定のキーが何を行うかを説明するページばかりです。しか
し、Emacsは直接キーに意味を与えてはいません。そのかわりに、Emacsは名前を
付けた“コマンド(commands)”に意味を持たせ、キーとコマンドを“バインディン
グ(binding)”することによって、キーに意味を与えています。

   すべてのコマンドには、プログラマーが選んだ名前が付いています。名前は
、たとえば‘next-line’、‘forward-word’のように、いくつかの英単語をダッシ
ュで区切って作られます。内部的には、それぞれのコマンドはLispの“関数
(function)”の特別な型で、コマンドに関連付けられたアクションは、関数を実
行することによって機能します。*note What Is a Function: (elisp)What Is a
Function.を参照してください。

   キーとコマンドの間のバインディングは、“keymaps”というテーブルに記憶さ
れます。*note Keymaps::を参照してください。

   “‘C-n’は下に1行動きます”という言い方は、通常の使用では関係ないが、
Emacsをカスタマイズする上では重要になる点を隠蔽しています。1行下に移動す
るコマンドは‘next-line’です。‘C-n’が‘next-line’にバインドされているから
効果があるのです。もし‘C-n’をコマンド‘forward-word’にリバインドしたら、
‘C-n’で1語前方に動くことになります。

   厳密に言えばキーはコマンドにバインドされているだけですが、このマニュ
アルでは‘C-n’をコマンドであるかのような言い回しをするときがあります。そ
のようなときは、処理を実行させるキーの後ろに、本当に処理を行うコマンドの
名前をカッコ内に記します。たとえば、“コマンド‘C-n’ (‘next-line’)は、ポイ
ントを垂直下方に移動します”というときは、コマンド‘next-line’がポイントを
垂直下方に移動し、それは通常‘C-n’にバインドされている、ということを意味
します。

   カスタマイズについて議論したので、“変数(variables)”にもふれておくべき
でしょう。コマンドの説明で、“これを変更する場合、変数 ‘mumble-foo’をセッ
トしてください”というときがあります。変数とは、値を保存するときに使用す
る名前のことです。このマニュアルに記載されている変数は、ほとんどがカスタ
マイズに関するものです。いくつかのコマンド、およびEmacsのある部分は、変
数調べてその変数にセットされた値により、動作がかわります。カスタマイズに
興味がでるまでは、、変数に関する情報は無視してかまいません。その後で変数
(*note Variables::を参照してください)の基本を読めば、特定の変数について
の情報に合点がいくでしょう。


File: emacs-ja.info,  Node: Entering Emacs,  Next: Exiting,  Prev: Commands,  Up: Top

5 Emacsの起動
*************

Emacsを呼び出す通常の方法は、シェルコマンド‘emacs’です。GUI端末上で実行
されるUnixシェルからは、‘emacs &’によりEmacsをバックグラウンドで実行でき
ます。この方法だとEmacsが端末ウィンドウに結びつけられないため、他のシェ
ルコマンドを実行できます(MS-WindowsでEmacsを開始する方法については、
*note Windows Startup::を参照)。

   Emacsを起動すると、初期フレームは‘*GNU Emacs*’という名前の特別なバッ
ファーを表示します。この“スタートアップ画面(startup screen)”には、
Emacsについての情報と、初心者にとって便利な一般的タスクへのリンクが含ま
れています。たとえば‘Emacs Tutorial’というリンクはEmacsのチュートリアル
を開きます。これはコマンド‘C-h t’ (‘help-with-tutorial’)と同じです。リン
クをアクティブにするには、ポイントをそこに動かして‘<RET>’をタイプするか
、‘mouse-1’(マウスの左ボタン)をクリックしてください。

   コマンドライン引数を使うと、Emacsが起動直後に1つ以上のファイルをアク
セスするよう指示できます。たとえば‘emacs foo.txt’は、‘foo.txt’の内容を表
示するバッファーとともにEmacsを起動します。これは他のエディターとの互換
性により存在する機能で、シェルから短い編集セッションを始めるときのために
デザインされています。Emacsをこの方法で呼び出すと、初期フレームは2つのウ
ィンドウに分割されます。1つは指定されたファイルで、もう1つはスタートアッ
プ画面です。*note Windows::を参照してください。

   一般的に、ファイルを編集するたびに新たにEmacsを起動するのは不必要で無
駄です。Emacsを使うときの推奨方法は、Emacsを1度だけ起動する方法で、ログ
インしたら起動して、同じEmacsセッションですべての編集作業を行うのです。
1つ以上のファイルをアクセスする方法は、*note Files::を参照してください。
この方法でEmacsを使うと、Emacsのセッションはキルリング(kill ring)、レジ
スター(registers)、アンドゥヒストリー(undo history)、マークリング(mark
ring)などの、値をもつコンテキストを蓄積するので、これを共有すれば編集が
より快適になります。これらの機能については、このマニュアルの後で説明しま
す。

   Emacsを実行中に、他のプログラムからファイルを編集する場合、既存の
Emacsセッションのファイルを開くために、‘emacsclient’というヘルパープログ
ラムを使うことができます。*note Emacs Server::を参照してください。

   コマンドライン引数を使って、EmacsにLispファイルをロードして初期フレー
ムに適用させたりできます。*note Emacs Invocation::を参照してください。

   変数‘inhibit-startup-screen’が非‘nil’の場合、Emacsはスタートアップ画
面を表示しません。この場合、コマンドラインに1つ以上のファイルが指定され
ていれば、Emacsは単にそれらのファイルを表示し、指定されていないときは
Lispの式を対話的に評価できる、‘*scratch*’という名前のバッファーを表示し
ます。*note Lisp Interaction::を参照してください。変数
‘inhibit-startup-screen’のセットは、Emacsのカスタマイズ機能(*note Easy
Customization::を参照してください)を使うか、初期設定ファイル(*note Init
File::を参照してください)を編集して行うことができます。(1)

   変数‘initial-buffer-choice’にファイルやディレクトリーの名前をセットす
ることにより、Emacsのスタートアップ時にファイルやディレクトリーを表示さ
せることもできます。‘initial-buffer-choice’の値に、その後に表示するバッ
ファーを戻す関数(引数なし)をセットすることもできます。
‘initial-buffer-choice’が非‘nil’の場合、コマンドラインにファイルを指定し
ても、それらのファイルは表示されますが、初期画面としては表示されません。

   ---------- Footnotes ----------

   (1) ‘site-start.el’の中で‘inhibit-startup-screen’をセットしても機能し
ません。なぜならスタートアップ画面は‘site-start.el’が読み込まれる前にセ
ットアップされるからです。‘site-start.el’についての情報は、*note Init
File::を参照してください。


File: emacs-ja.info,  Node: Exiting,  Next: Basic,  Prev: Entering Emacs,  Up: Top

6 Emacsの終了
*************

‘C-x C-c’
     Emacsをkill(終了)します。(‘save-buffers-kill-terminal’)。
‘C-z’
     テキスト端末ではEmacsをサスペンドします。グラフィカルなディスプレー
     では選択されたフレームをアイコン化(または“最小化”)します
     (‘suspend-frame’)。

   Emacsを“Kill”するというのは、Emacsプログラムを終了するという意味です
。これを行うには、‘C-x C-c’ (‘save-buffers-kill-terminal’)とタイプします
。2文字キーシーケンスが使われているのは、アクシデントにより間違ってタイ
プしづらくするためです。もし変更されたファイルがある場合、‘C-x C-c’をタ
イプすると、Emacsとそれらのバッファーを巡回して、バッファーを保存するか
問い合わせます。それらすべてを保存しない場合、未保存の変更が失われてしま
う前に、もう一度問い合わせます。サブプロセスがまだ実行中の場合にも、
Emacsをkillするとサブプロセスもkillされるので、問い合わせを行います
(*note Shell::を参照してください)。

   もしEmacsをサーバーとして使っている場合、‘C-x C-c’は特別に振る舞いま
す。もしクライアントフレームからタイプした場合は、クライアントのコネクシ
ョンをクローズします。*note Emacs Server::を参照してください。

   Emacsはオプションで、killしたときに表示していたファイルなどの、セッシ
ョン情報を記録することができます。この情報は次回Emacsを起動するとき利用
可能です。*note Saving Emacs Sessions::を参照してください。

   変数‘confirm-kill-emacs’の値が非‘nil’の場合、‘C-x C-c’はその値が関数
だとみなして、その関数を呼び出します。その関数呼び出しの結果が非‘nil’の
場合、セッションはkillされ、そうでない場合、Emacsは実行を続けます。
‘confirm-kill-emacs’の値として使うのに適した関数の1つが、‘yes-or-no-p’で
す。‘confirm-kill-emacs’のデフォルト値は‘nil’です。

   変数‘confirm-kill-processes’の値が‘nil’の場合、‘C-x C-c’はEmacsにより
開始されたサブプロセスをkillする前に確認を求めません。デフォルトでは、こ
の値は‘t’です。

   Emacsをexitするとき何が起こるかさらにカスタマイズするには、*note
(elisp)Killing Emacs::を参照してください。

   保存の問い合わせを行わずにEmacsをkillするときは、‘M-x kill-emacs’とタ
イプします。

   ‘C-z’は、コマンド‘suspend-frame’を実行します。グラフィカルなディスプ
レーでは、このコマンドは選択されたEmacsのフレームを後で戻れるように、“最
小化”(または“アイコン化”)して隠します(どのように隠されるかはウィンドウシ
ステムに依存します)。テキスト端末では、‘C-z’はEmacsを“サスペンド(休止
)”します。プログラムは一時的に停止し、制御は親プロセス(通常はシェル)に戻
ります。ほとんどのシェルではシェルのコマンド‘%emacs’で、サスペンド中の
Emacsを再開できます。

   テキスト端末は、通常、実行中のプログラムをkillしたりサスペンドする、
特定の特殊文字を監視しています。この端末の機能は、Emacsではオフになって
います。Emacsでの‘C-z’や‘C-x C-c’のキーの意味は、いくつかのオペレーティ
ングシステムでプログラムを休止させたり終了させたりするために用いる文字、
‘C-z’と‘C-c’にヒントを得たものですが、オペレーティングシステムとの関係は
それだけです。これらのキーは、他のコマンドを実行するようにカスタマイズで
きます(*note Keymaps::を参照してください)。


File: emacs-ja.info,  Node: Basic,  Next: Minibuffer,  Prev: Exiting,  Up: Top

7 基本的な編集コマンド
**********************

ここではテキストの入力、修正、ファイルへの保存といった基本操作について説
明します。これらに接するのが初めてなら、learn-by-doing(行ってみることで
学ぶ)形式のチュートリアルをやってみることを提案します。チュートリアルを
行うには‘C-h t’ (‘help-with-tutorial’)とタイプしてください。

* Menu:



* Inserting Text::           単純に入力してテキストを挿入する。
* Moving Point::             何か修正したい場所にカーソルを移動する。
* Erasing::                  テキストの削除とkill。
* Basic Undo::               テキストの最近の変更を取り消す。
* Files: Basic Files.        ファイルの読み込み、作成、保存。
* Help: Basic Help.          文字が何を行うか尋ねる。
* Blank Lines::              空行の作成と削除
* Continuation Lines::       Emacsがスクリーンに収まりきれない行を表示する方法。
* Position Info::            ポイントのある場所の行と列は何か?
* Arguments::                コマンドをN回繰り返すための数引数。
* Repeating::                素早く前のコマンドを繰り返す。


File: emacs-ja.info,  Node: Inserting Text,  Next: Moving Point,  Up: Basic

7.1 テキストの挿入
==================

普通の“グラフィック文字(graphic character)”(例 ‘a’、‘B’、‘3’、‘=’)は、対
応するキーをタイプして挿入することができます。これによりバッファーのポイ
ント位置に文字が追加されます。挿入によりポイントは前方に移動するので、ポ
イントは挿入された文字の直後になります。*note Point::を参照してください
。

   行を終了して新しい行を開始するには<RET>(‘newline’)を入力します(キーボ
ードで<RET>キーは、<Return>や<Enter>、もしくは↲のような奇妙な左矢印のラ
ベルがついているかもしれませんが、このマニュアルでは<RET>と呼ぶことにし
ます)。このコマンドは改行文字をバッファーに挿入してから、メジャーモード
に基づきインデント(*note Indentation::を参照してください)を行います。ポ
イントが行末にある場合には、新しく空行を作成してから新しい行をインデント
します。もしポイントが行の途中にある場合、行はその位置で分割されます。自
動インデントをオフにするには、Electric Indentモード(*note Indent
Convenience::を参照してください)を無効にするか、自動インデントを行わず改
行だけを挿入する‘C-j’を入力します。

   マニュアルの後ろで説明しますが、“マイナーモード(minor modes)”を利用す
ることにより、Emacsが挿入を処理する方法を変更できます。たとえばAuto
Fillモードというマイナーモードは行が長くなりすぎたとき自動的に行を分割し
ます(*note Filling::)。Overwrite modeというマイナーモードは、既存の文字
を右方に押しやるかわりに、既存の文字を置き換え(上書き)ます。*note Minor
Modes::を参照してください。

   対応するキーを押して挿入できるのはグラフィック文字だけです。他のキー
は編集コマンドとして動作し、文字自体の挿入はしません。たとえば、デフォル
トでは<DEL>は、コマンド‘delete-backward-char’を実行します(違うコマンドに
バインドされているモードもあります)。このキーはリテラルの‘DEL’(ASCIIの文
字コード127)を入力する訳ではありません。

   非グラフィック文字や、キーボードがサポートしていない文字を挿入するに
は、最初に‘C-q’ (‘quoted-insert’)で文字を“クォート(quote)”します。
‘C-q’の使い方は2つあります:

   • ‘C-q’に続けて非グラフィック文字(‘C-g’でさえも)をタイプすると、その
     文字が挿入されます。たとえば‘C-q <DEL>’は、リテラルの‘DEL’文字を挿
     入します。

   • ‘C-q’に続けて8進文字のシーケンスを入力すると、8進の文字コードに対応
     する文字が挿入されます。任意の8進数字を使うことができます。非8進数
     字により入力は終了します。もし終了文字が<RET>の場合、<RET>は入力の
     終了だけに用いられます。他の非8進文字は入力を終了させてから、通常の
     入力として扱われます。つまり‘C-q 1 0 1 B’は‘AB’を挿入します。

     8進数字での入力は、通常の非バイナリーのOverwriteモードでは無効にな
     っています。それにより上書きすることなく数字を挿入する便利な方法が
     提供されます。

8進のかわりに10進や16進を使うには、変数‘read-quoted-char-radix’に、10や
16をセットします。もし基数が16の場合、‘a’から‘f’は文字コードの一部として
扱われます。大文字小文字は区別されません。

   数は多くありませんが、一般的なUnicode文字は、‘C-x 8’で始まるコマンド
を通じて挿入できます。たとえば‘C-x 8 [’は、『‘』を挿入します。これは
Unicodeコードポイント‘U+2018’のLEFT SINGLE QUOTATION MARK(単独の左
“curved quote”、または“curly quote”と呼ばれることもあります)を挿入します
。同様に、‘C-x 8 ]’は『’』、‘C-x 8 {’は『“』、‘C-x 8 }’は『”』を挿入しま
す。また、Altキーも‘C-x 8’と同じように機能します。たとえば‘A-[’は‘C-x 8
[’と同様に、『‘』を挿入します。どの文字が‘C-x 8’による短縮入力をもつかを
確認するには、‘C-x 8 C-h’とタイプしてください。

   かわりにコマンド‘C-x 8 <RET>’ (‘insert-char’)を使うこともできます。こ
れはミニバッファーを使って、Unicode名かコードポイント(code-point)の入力
を求めます。もし名前を入力する時、コマンドが補完機能を提供します(*note
Completion::を参照してください)。コードポイントを入力する場合、それは
16進(Unicodeの規約による)、または指定した基数の数字(例 ‘#o23072’
(octal); *note (elisp)Integer Basics::を参照してください)であるべきです
。このコマンドは対応する文字をバッファーに挿入します。

   たとえば以下はすべて同じ文字を挿入します:

     C-x 8 <RET> left single quotation mark <RET>
     C-x 8 <RET> left sin <TAB> <RET>
     C-x 8 <RET> 2018 <RET>
     C-x 8 [
     A-[  (Altキーが機能する場合)
     `    (Electric Quoteモードの場合)

   ‘C-q’または‘C-x 8 ...’への数引数は、文字のコピーを何個挿入するかを指
定します(*note Arguments::を参照してください)。

   さらに加えて、あるコンテキストにおいては、`like this'のようにクォート
にgrave accentとapostropheを使用した場合は、たとえ‘C-x 8’コマンドを使用
していなくても、これは1つのクォーテーションマークを使用した形式‘like
this’のように変換されます。同様に、``like this''のように2重のgrave
accentとapostropheを使用した場合、これはダブルクォーテーションマークを使
用した形式“like this”のように変換されます。*note Quotation Marks::を参照
してください。


File: emacs-ja.info,  Node: Moving Point,  Next: Erasing,  Prev: Inserting Text,  Up: Basic

7.2 ポイント位置の変更
======================

文字の挿入以上のことを行うには、ポイントを移動する方法について知る必要が
あります(*note Point::を参照してください)。キーボードのコマンド‘C-f’、
‘C-b’、‘C-n’、‘C-p’は、それぞれ右・左・下・上にポイントを移動します。ほ
とんどのキーボードにある矢印キー — <RIGHT>、<LEFT>、<DOWN>、<UP>でもポイ
ントを移動できます。しかし多くのEmacsユーザーは矢印キーより、コントロー
ルキーのほうが速いと考えています。なぜなら矢印キーを押すためにそれらが配
置されている領域に手を動かす必要があるからです。

   ポイントを移動したい場所でマウスの左ボタンをクリックしてもポイントを
移動できます。Emacsは、さらに洗練された方法でポイントを移動する、さまざ
まなキーボードコマンドを提供します。

‘C-f’
     1文字前方(forward)に移動します (‘forward-char’)。

‘<RIGHT>’
     このコマンド(‘right-char’)は‘C-f’と同様に振る舞います。例外はポイン
     トのあるパラグラフがright-to-leftの場合です。*note Bidirectional
     Editing::を参照してください。

‘C-b’
     1文字後方(backward)に移動します (‘backward-char’)。

‘<LEFT>’
     このコマンド(‘left-char’)は‘C-b’と同様に振る舞います。例外は現在の
     パラグラフがright-to-leftの場合です。*note Bidirectional Editing::を
     参照してください。

‘C-n’
‘<DOWN>’
     スクリーンに表示された行で1行下に移動します(‘next-line’)。このコマ
     ンドは横方向の位置を変更しないよう試みます。そのため行の途中でコマ
     ンドを開始すると、次の行の途中に移動することになります。

‘C-p’
‘<UP>’
     スクリーンに表示された行で1行上に移動します(‘previous-line’)。この
     コマンドは‘C-n’と同様、行内の位置を保ちます。

‘C-a’
‘<Home>’
     行の先頭に移動します(‘move-beginning-of-line’)。

‘C-e’
‘<End>’
     行の最後に移動します(‘move-end-of-line’)。

‘M-f’
     1単語前方に移動します(‘forward-word’)。*note Words::を最終してくだ
     さい。

‘C-<RIGHT>’
‘M-<RIGHT>’
     このコマンド(‘right-word’)は‘M-f’と同様に振る舞います。例外は現在の
     パラグラフがright-to-leftの場合、1語_後方_に移動することになります
     。*note Bidirectional Editing::を参照してください。

‘M-b’
     1単語後方に移動します(‘backward-word’)。*note Words::を参照してくだ
     さい。

‘C-<LEFT>’
‘M-<LEFT>’
     このコマンド(‘left-word’)は‘M-b’と同様に振る舞います。例外は現在の
     パラグラフがright-to-leftの場合、1語_前方_に移動することになります
     。*note Bidirectional Editing::を参照してください。

‘M-r’
     スクリーン上のテキストを移動させることなく、ポイントの位置をウィン
     ドウ上で中央にもっとも近いテキスト行の左端に移動します。連続して呼
     び出すと、最上行の左端、最下行の左端へと循環的にポイントを移動しま
     す(‘move-to-window-line-top-bottom’)。

     数引数はスクリーンの行の何行目にポイントを移動するか指定します。数
     値はウィンドウの最上行から数えた行数です(0は最上行を意味します)。負
     の引数は最下行から数えた行数です(−1は最下行を意味します。数引数につ
     いては詳細は、*note Arguments::を参照してください。

‘M-<’
     バッファーの先頭に移動します(‘beginning-of-buffer’)。数引数Nが与え
     られた場合、最上行からN/10に移動します。グラフィカルなディスプレイ
     では、‘C-<HOME>’で同じことを行うことができます。

‘M->’
     バッファーの最後に移動します(‘end-of-buffer’)。グラフィカルなディス
     プレイでは、‘C-<END>’で同じことを行うことができます。

‘C-v’
‘<PageDown>’
‘<next>’
     画面を1画面前方にスクロールします。もし必要ならポイントをスクリーン
     上の位置に移動します(‘scroll-up-command’)。*note Scrolling::を参照
     してください。

‘M-v’
‘<PageUp>’
‘<prior>’
     画面を1画面後方にスクロールします。もし必要ならポイントをスクリーン
     上の位置に移動します(‘scroll-down-command’)。*note Scrolling::を参
     照してください。

‘M-g c’
     数値Nを読み取り、ポイントをバッファー位置Nに移動します。1を指定する
     とバッファーの先頭に移動します。

‘M-g M-g’
‘M-g g’
     数値Nを読み、ポイントをバッファーの先頭からN行目に移動します。行に
     1を指定するとバッファーの先頭に移動します。もしポイントがバッファー
     の数字の上または直後にある場合、その数がNのデフォルトになります。ミ
     ニバッファーで単に<RET>を押すと、その数が使われます。数値のプレフィ
     クス引数でNを指定して‘M-g M-g’に与えることもできます。単にプレフィ
     クス引数を与えた場合の‘M-g M-g’の動作については、*note Select
     Buffer::を参照してください。

‘M-g <TAB>’
     数値Nを読み取り、現在行のN列目に移動します。列0は最左列です。プレフ
     ィクス引数とともに呼び出された場合、引数で指定された数の列に移動し
     ます。

‘C-x C-n’
     カレントバッファー内の現在ポイントがある列を‘C-n’や‘C-p’の“半恒久的
     な目標列(semipermanent goal column)”として使用します。目標列が有効
     な場合、これらのコマンドで垂直に移動すると、その列もしくはできる限
     り近い列に移動しようと試みます。目標列はキャンセルされるまで有効で
     す。

‘C-u C-x C-n’
     目標列をキャンセルします。それ以降の‘C-n’や‘C-p’は通常どおり水平位
     置を保とうと試みます。

   バッファーのテキストがウィンドウの幅より長い場合、通常Emacsは2行以上
の“スクリーン行(screen lines)”で表示します。便宜上、‘C-n’と‘C-p’そして
‘<down>’と‘<up>’も、同様にスクリーン行にしたがってポイントを移動します。
これらのコマンドを“論理行(logical lines)”(たとえばバッファーのテキスト行
)にしたがって移動させるには、‘line-move-visual’に‘nil’をセットします。そ
うすると論理行が複数のスクリーン行となるような場合、カーソルは追加された
スクリーン行をスキップします。詳細は*note Continuation Lines::を参照して
ください。‘line-move-visual’などの変数をセットする方法については、*note
Variables::を参照してください。

   ‘C-n’や‘C-p’と異なり、ほとんどのEmacsコマンドは_論理的_な行に作用しま
す。たとえば‘C-a’ (‘move-beginning-of-line’)や‘C-e’
(‘move-end-of-line’)は、論理行の先頭もしくは最後に移動します。‘C-n’や
‘C-p’のようにスクリーン行に作用するコマンドの場合、わたしたちはそれを示
すようにします。

   ‘line-move-visual’が‘nil’の場合、変数‘track-eol’にも非‘nil’値をセット
できます。そうすると論理行の行末で‘C-n’や‘C-p’を開始すると、次の論理行の
行末に移動します。通常‘track-eol’は‘nil’です。

   通常‘C-n’をバッファーの最後の行で使用した場合、バッファーの最後でスト
ップします。しかし変数‘next-line-add-newlines’に非‘nil’値をセットした場
合、バッファーの最後の行で‘C-n’を押すと、行を追加してその行に移動します
。


File: emacs-ja.info,  Node: Erasing,  Next: Basic Undo,  Prev: Moving Point,  Up: Basic

7.3 テキストの消去
==================

‘<DEL>’
‘<BACKSPACE>’
     ポイントの前の文字、またはリージョンがアクティブのときはリージョン
     を削除します(‘delete-backward-char’)。

‘<Delete>’
     ポイントの後の文字、またはリージョンがアクティブのときはリージョン
     を削除します(‘delete-forward-char’)。

‘C-d’
     ポイントの後ろの文字を削除します(‘delete-char’)。

‘C-k’
     行末までkillします(‘kill-line’)。

‘M-d’
     次の単語(word)の末尾までを前方にkillします(‘kill-word’)。

‘M-<DEL>’
‘M-<BACKSPACE>’
     前の単語の先頭までを後方にkillします(‘backward-kill-word’)。

   コマンド‘<DEL>’ (‘delete-backward-char’)は、ポイントの前の文字を削除
して、カーソルと後ろの文字を後方に移動します。ポイントが行の先頭にある場
合、前の改行を削除して、その行を前の行と連結します。

   しかしリージョンがアクティブのとき、‘<DEL>’はリージョンのテキストを削
除します。リージョンの説明は、*note Mark::を参照してください。

   ほとんどのキーボードでは、<DEL>には<BACKSPACE>というラベルがついてい
ますが、このマニュアルでは<DEL>と呼ぶことにします(<DEL>を<Delete>と混同
しないでください。<Delete>についてはこの後で議論します)。いくつかのテキ
スト端末では、Emacsは<DEL>を正しく認識しません。もしこの問題に遭遇したと
きには、*note DEL Does Not Delete::を参照してください。

   コマンド<Delete> (‘delete-forward-char’)は、反対方向に削除します。こ
れはポイントの後ろの文字、たとえばカーソルの下の文字を削除します。ポイン
トが行末にある場合は、その行を次の行と連結します。‘<DEL>’と同様、リージ
ョンがアクティブのときはリージョンのテキストを削除します(*note Mark::を
参照してください)。

   ‘C-d’ (‘delete-char’)は、<Delete>と同じようにポイントの後ろの文字を削
除しますが、リージョンがアクティブかどうかは関係ありません。

   上述した削除コマンドについての詳細な情報は、*note Deletion::を参照し
てください。

   ‘C-k’ (‘kill-line’)は行を一度に消去(kill)します。もし行頭または行の途
中で‘C-k’とタイプすると、行末までのすべてのテキストをkillします。行末で
‘C-k’とタイプすると、その行を次の行と連結します。

   ‘C-k’と関連するコマンドについては、*note Killing::を参照してください
。


File: emacs-ja.info,  Node: Basic Undo,  Next: Basic Files,  Prev: Erasing,  Up: Basic

7.4 変更のアンドゥ
==================

‘C-/’
‘C-x u’
‘C-_’
     undoレコードにあるエントリーをundoします。通常1つのコマンドを元に戻
     す(‘undo’)ことに相当します(1つ目のキーはテキストモードのディスプレ
     イでは利用できないかもしれない)。

   Emacsはバッファー内のテキストに行われた変更のリストを記録しているので
、最近の変更はundoできます。これは‘C-/’(および‘C-x u’と‘C-_’)にバインド
されているコマンド‘undo’を使って行われます。通常このコマンドは最後の変更
をundoして、ポイントを変更前の位置に移動します。undoコマンドはバッファー
への変更のみに適用されるので、カーソルの動きをundoすることはできません。

   個々の編集コマンドは、通常undoレコードの個別のエントリーとなりますが
、とても単純なコマンドはグループ化される場合があります。1つのエントリー
が、実は複雑なコマンドのほんの一部の場合もあります。

   もし‘C-/’(またはそれの別名コマンド)を繰り返すと、undoされた箇所はさら
にundoされ、初期の変更もundoされ、ついには利用可能なundo情報の限界に達し
ます。もし記録された変更がすべてundoされている場合、undoコマンドはエラー
メッセージを表示して、何も行いません。

   ‘undo’コマンドについてさらに学ぶには、*note Undo::を参照してください
。


File: emacs-ja.info,  Node: Basic Files,  Next: Basic Help,  Prev: Basic Undo,  Up: Basic

7.5 ファイル
============

Emacsのバッファーに挿入したテキストは、Emacsのセッションの間だけ存在しま
す。テキストを永続化させるためには、それを“ファイル(file)”に保存しなけれ
ばなりません。

   ホームディレクトリーに、‘test.emacs’という名前のファイルがあるとしま
しょう。このファイルをEmacsで編集するには、以下を入力します

     C-x C-f test.emacs <RET>

ここでファイル名は、コマンド‘C-x C-f’ (‘find-file’)に与えられる、“引数
(argument)”です。このコマンドは引数を読み取るために“ミニバッファー
(minibuffer)”を使い、<RET>は引数を終端させます(*note Minibuffer::を参照
してください)。

   このコマンドに従うために、Emacsはそのファイルを“visit(訪問)”します: す
なわちバッファーを作成し、ファイル内容をバッファーにコピーし、編集のため
にバッファーを表示します。テキストを変更したら、‘C-x C-s’
(‘save-buffer’)と入力することにより、ファイルを“保存(save)”できます。こ
れにより変更されたバッファー内容は、‘test.emacs’に書き戻され永続化されま
す。保存するまでは、テキストへの変更はEmacs内部にだけ存在し、ファイル
‘test.emacs’は変更されません。

   ファイルを作成するには、すでにファイルが存在するかのように‘C-x C-f’で
ファイルをvisitするだけです。これはファイルに書き込みたいテキストを入力
できる、空のバッファーを作成します。最初にこのバッファーを‘C-x C-s’で保
存するとき、Emacsは実際にファイルを作成します。

   Emacsでファイルを使うことについてさらに学ぶには、*note Files::を参照
してください。


File: emacs-ja.info,  Node: Basic Help,  Next: Blank Lines,  Prev: Basic Files,  Up: Basic

7.6 ヘルプ
==========

もしキーが何をするか忘れた場合、‘C-h k’ (‘describe-key’)と入力して、それ
に続けて関心のあるキーを入力します。たとえば‘C-h k C-n’は、‘C-n’が何をす
るか表示します。

   プレフィクスキー‘C-h’は“ヘルプ(help)”が由来です。<F1>キーは‘C-h’の別
名です。‘C-h k’以外にも、異なる種類のヘルプを提供する多くのヘルプコマン
ドがあります。

   詳細については、*note Help::を参照してください。


File: emacs-ja.info,  Node: Blank Lines,  Next: Continuation Lines,  Prev: Basic Help,  Up: Basic

7.7 空行
========

空行を挿入したり削除するための、特別なコマンドとテクニックがあります。

‘C-o’
     カーソルの後ろに空行を挿入します(‘open-line’)。
‘C-x C-o’
     連続する空行を、1行残してすべて削除します(‘delete-blank-lines’)。

   これまで‘<RET>’ (‘newline’)が、どうやってテキストの新しい行を開始する
のか見てきました。しかし最初に空行を作ってからテキストを挿入するほうが、
何を行っているのかわかりやすいでしょう。これはキー‘C-o’ (‘open-line’)を
使えば、簡単に行うことができます。これはポイントの後ろに改行を挿入し、ポ
イントを改行の前に維持します。‘C-o’の後に新しい行のためのテキストを入力
します。

   複数の空行は‘C-o’を数回入力するか、何個の空行を作るのかを数引数で与え
れば作れます。方法については、*note Arguments::を参照してください。もし
フィルプレフィクスがあって、行頭で‘C-o’が入力された場合、新しい行にフィ
ルプレフィクスを挿入します。*note Fill Prefix::を参照してください。

   余分な空行を取り除く簡単な方法は、‘C-x C-o’ (‘delete-blank-lines’)で
す。連続する空行の中にポイントがあるとき、‘C-x C-o’は1行残してすべての空
行を削除します。ポイントが単独の空行にある場合、‘C-x C-o’はその空行を削
除します。ポイントが空でない行にある場合、‘C-x C-o’は、後続する空行があ
れば、それらすべてを削除します。


File: emacs-ja.info,  Node: Continuation Lines,  Next: Position Info,  Prev: Blank Lines,  Up: Basic

7.8 継続行
==========

バッファー内のテキストの行 — “論理行(logical line)” — がウィンドウに収ま
らないほど長い場合、Emacsがそれを2行以上の“スクリーン行(screen lines)”で
表示するときがあります。これは“行の折り返し(line wrapping)”または“継続
(continuation)”と呼ばれ、論理行は“継続された行(continued line)”と呼ばれ
ます。グラフィカルなディスプレーでは、Emacsは行の折り返しをウィンドウの
左右のフリンジ(fringes、縁)の小さな曲矢印で示します。テキスト端末では、
Emacsは右の余白に‘\’を表示して行の折り返しを示します。

   ほとんどのコマンドは、スクリーン行ではなく論理行にたいして作用します
。たとえば‘C-k’は論理行をkillします。前に説明したように、‘C-n’
(‘next-line’)と‘C-p’ (‘previous-line’)は特別な例外です。これらはスクリー
ン行にたいしてポイントを上下に移動させます(*note Moving Point::を参照し
てください)。

   Emacsはオプションで長い論理行を継続するかわりに、“切り詰める
(truncate)”ことができます。これは論理行が1つのスクリーン行を占めることを
意味します。もし論理行がウィンドウ幅より長い場合、行の残りは表示されませ
ん。グラフィカルなディスプレーでは切り詰められた行は、右フリンジの小さな
直矢印で示されます。テキスト端末では右余白の‘$’で示されます。*note Line
Truncation::を参照してください。

   デフォルトでは継続行はウィンドウの右端で折り返されます。折り返しが単
語の途中で発生すると、継続された行は読むのが難しくなります。普通の解決策
は、行が長くなりすぎる前に改行を挿入することです。もしお好みなら、行が長
くなりすぎたときにEmacsが自動的に改行を挿入するように、Auto Fillモードを
使うことができます。*note Filling::を参照してください。

   多くの長い論理行を含むファイルを編集する必要があり、それらすべてを改
行で分割するのが実用的でない場合があります。そのようなケースでは“単語折
り返し(word wrapping)”が有効なVisual Lineモードを使うことができます。こ
れは長い行を正確にウィンドウの右端で折り返すのではなく、ウィンドウの右端
に一番近い単語境界(スペースやタブなど)で折り返します。Visual Lineモード
では、‘C-a’、‘C-n’、‘C-k’などの編集コマンドも、論理行ではなくスクリーン
行を処理するように再定義されます。*note Visual Line Mode::を参照してくだ
さい。


File: emacs-ja.info,  Node: Position Info,  Next: Arguments,  Prev: Continuation Lines,  Up: Basic

7.9 カーソル位置の情報
======================

バッファーのある部分にたいしてサイズや位置、単語数や行数についての情報を
得るためのコマンドがあります。

‘M-x what-line’
     ポイントの行番号を表示します。
‘M-x line-number-mode’
‘M-x column-number-mode’
     現在の行番号および列番号の自動表示を切り替えます。*note Optional
     Mode Line::を参照してください。各行の前に行番号を表示したい場合は、
     *note Display Custom::を参照してください。

‘M-=’
     現在のリージョンの行数、単語数、文字数を表示します
     (‘count-words-region’)。リージョンについては、*note Mark::を参照し
     てください。

‘M-x count-words’
     現在のバッファーの行数、単語数、文字数を表示します。リージョン
     (*note Mark::を参照してください)がアクティブのときは、かわりにリー
     ジョンの数字を表示します。

‘C-x =’
     ポイントの後ろの文字の文字コード、ポイントの文字位置、ポイントの列
     位置を表示します(‘what-cursor-position’)。
‘M-x hl-line-mode’
     現在行のハイライト表示を有効または無効にします。*note Cursor
     Display::を参照してください。
‘M-x size-indication-mode’
     バッファーのサイズの自動表示を切り替えます。*note Optional Mode
     Line::を参照してください。

   ‘M-x what-line’は、エコーエリアに現在の行番号を表示します。通常このコ
マンドは不必要です。なぜならモードラインに現在の行番号が、すでに表示され
ているからです (*note Mode Line::を参照してください)。しかしバッファーが
ナロー(narrow: 制限)されている場合、モードラインはアクセスできる範囲につ
いての行番号しか表示しません(*note Narrowing::を参照してください)。それ
にくらべて‘what-line’は、制限されたリージョンとバッファー全体、両方の行
番号を表示します。

   ‘M-=’ (‘count-words-region’)はリージョン内の行数、単語数、文字数を報
告するメッセージを表示します(リージョンについての説明は、*note Mark::を
参照してください)。プレフィクス引数‘C-u M-=’を指定すると、このコマンドは
バッファー全体の数字を表示します。

   ‘M-x count-words’は同じことを行いますが、呼び出し規約が異なります。も
しリージョンがアクティブの場合はリージョン、そうでない場合はバッファーの
数字を表示します。

   コマンド‘C-x =’ (‘what-cursor-position’)は現在のカーソル位置と、その
位置にあるバッファー内容についての情報を表示します。エコーエリアには、以
下のような行が表示されます:

     Char: c (99, #o143, #x63) point=28062 of 36168 (78%) column=53

   ‘Char:’には、バッファー中のそのポイントにある文字が表示されます。カッ
コ内にはその文字に対応する文字コードが10進、8進、16進で表示されます。
‘C-x =’が文字の情報について表示する方法については、*note International
Chars::を参照してください。‘point=’はポイント位置を文字数(バッファーの最
初の文字は1、次の文字は2、...)で表示します。その後ろの数字ではバッファー
内の文字数の合計が表示され、カッコ内にはその位置が全体から見て何パーセン
トの位置なのかが表示されます。‘column=’にはポイントの水平位置、すなわち
ウィンドウの左端から数えて何番目の列かが表示されます。

   もしバッファーがナローされている場合、最初と最後の部分のテキストが一
時的にアクセス不能になります。‘C-x =’は現在アクセス可能な範囲についての
追加説明を表示します。たとえば以下のように表示します:

     Char: C (67, #o103, #x43) point=252 of 889 (28%) <231-599> column=0

ここで、新たに追加された2つの数字が、ポイントを設定できる文字位置の下限
と上限を示します。これら2つの位置のあいだの文字が参照可能な文字です。
*note Narrowing::を参照してください。

   関連はあるものの異なる機能が‘display-line-numbers-mode’(*note Display
Custom::を参照)です。


File: emacs-ja.info,  Node: Arguments,  Next: Repeating,  Prev: Position Info,  Up: Basic

7.10 数引数
===========

数学や計算機の用語では、引数(argument)という単語は、“関数や操作に与える
データ”を意味します。Emacsのコマンドには、数引数(numeric argument)(プレ
フィクス引数(prefix argument)とも呼ぶ)を指定できるものがあります。引数を
反復回数として解釈するコマンドもあります。たとえば、引数10を‘C-f’に指定
すると、カーソルを通常の1文字ではなく、10文字分前向きに移動します。これ
らのコマンドでは、引数を指定しないと引数1を指定したのと同等になります。
この種のコマンドの多くでは、負の引数を指定すると、逆向きの移動や逆の操作
を指示することになります。

   数引数を指定するもっとも簡単な方法は、<Meta>キーを押しながら数字また
はマイナス記号(と数字)を入力する方法です。以下はその例です:

     M-5 C-n

これは５行下に移動します。キー‘M-1’、‘M-2’、...、同様に‘M--’は、次のコマ
ンドへの引数をセットアップするコマンド、(‘digit-argument’と
‘negative-argument’)にバインドされています。数字をともなわない‘M--’は、
通常−1を意味します。

   2桁以上の数字を入力したい場合、2文字目以降の数字を入力するときに
<Meta>を押しつづける必要はありません。つまり50行下に移動するときは、以下
のように入力します:

     M-5 0 C-n

これは、(あなたが期待するように)‘0’を5つコピーして挿入してから1行下がる
のでは_ない_ことに注意してください。‘0’はプレフィクス引数の一部として扱
われます。

   (‘0’を5つコピーして挿入するときは、‘M-5 C-u 0’と入力します。ここで
‘C-u’はプレフィクス引数を終端させるので、次のキー入力はあなたが実行した
いコマンドです。ここでの‘C-u’の意味はこのケースだけに適用される使い方で
す。‘C-u’の通常の役割については以下を参照してください。)

   数引数を指定する別の方法として、‘M-1’、‘M-2’、...と入力するかわりに、
‘C-u’ (‘universal-argument’)のあとに数字(負の引数の場合はマイナス記号と
数字)を入力する方法があります。通常、数字をともなわないマイナス記号は
−1を意味します。

   単独の‘C-u’は、“4倍”という特別な意味をもち、次のコマンドの引数を4倍に
します。‘C-u C-u’は16倍です。つまり‘C-u C-u C-f’は16文字前方に移動します
。その他に便利な使い方としては‘C-u C-n’、‘C-u C-u C-n’(適当な割り合いで
画面を下に移動する)や、‘C-u C-u C-o’(16個の空行を作る)、‘C-u C-k’(4行削
除する)、などがあります。

   自分自身を挿入する文字の前に数引数を使えば、指定した分のコピーを挿入
できます。これは挿入したい文字が数字でないときは簡単です。たとえば
‘C-u 6 4 a’は、‘a’を64個コピーして挿入します。しかし数字を挿入したいとき
は、これではうまくいきません。‘C-u 6 4 1’は引数に641を指定することになっ
てしまいます。このようなときは引数と挿入したい数字を分けるために、他の
‘C-u’を使うことができます。たとえば‘C-u 6 4 C-u 1’とすれば、これは‘1’を
64個コピーして挿入します。

   引数の有無は確認しても、その値は無視するコマンドもあります。たとえば
コマンド‘M-q’ (‘fill-paragraph’)は、1行に収まるようできるだけテキストを
フィルしますが、引数をともなうと、余分なスペースを挿入してテキストが正確
に1行の最大幅を使うよう均等に割り付けてフィルします(‘M-q’については、
*note Filling::を参照してください)。このようなコマンドは、引数として単に
‘C-u’を指定するだけで充分です。

   引数の値を繰り返しの回数として使いますが、引数がないときは特別な処理
を行うコマンドもあります。たとえばコマンド‘C-k’ (‘kill-line’)に引数Nを指
定すると、これは行末の改行も含めてN行をkillします。しかし引数を指定しな
いで‘C-k’した場合、ポイントから改行までのテキストをkillするか、ポイント
が行末にある場合は改行をkillします。つまりコマンド‘C-k’を引数なしで2回呼
び出すと、‘C-k’に引数1を指定したのと同様、空でない行をkillできます
(‘C-k’についての情報は、*note Killing::を参照してください)。

   いくつかのコマンドは、‘C-u’だけの引数を通常の引数とは異なるものとして
扱います。また、マイナス記号のみの引数を、−1とは区別するコマンドもありま
す。これらの例外については、必要になったときに説明します。これらの例外は
、それぞれのコマンドを使いやすくするためにあり、コマンドのドキュメント文
字列に記載されています。

   コマンドの前に引数を入力するという点を強調するために、そしてコマンド
が呼び出されてから入力されるミニバッファー引数(*note Minibuffer::を参照
してください)と区別するために、わたしたちは“プレフィクス引数(prefix
argument)”という言葉を使います。

   グラフィカルなディスプレイでは‘C-0’、‘C-1’、...は‘M-0’、‘M-1’、...と
同じように振る舞います。


File: emacs-ja.info,  Node: Repeating,  Prev: Arguments,  Up: Basic

7.11 コマンドの繰り返し
=======================

単純なキーで呼び出されるものや、‘M-x COMMAND-NAME <RET>’で実行できるよう
な多くのコマンドは、数引数で繰り返し回数(*note Arguments::を参照してくだ
さい)を与えることで、その回数だけ繰り返すことができます。しかし、入力を
求めるものや数引数を別の目的に使うコマンドでは、この方法はうまくいきませ
ん。

   コマンド‘C-x z’ (‘repeat’)は、Emacsコマンドを何回も反復する別の方法で
す。このコマンドは、直前のEmacsコマンドが何であっても、それを繰り返しま
す。繰り返されるコマンドは、まえと同じ引数を使います。毎回新たに引数を読
み取ることはしません。

   コマンドを2回以上繰り返すには‘z’を追加して入力します。1つの‘z’でコマ
ンドを1回繰り返します。‘z’以外の文字を入力するか、マウスボタンを押すと繰
り返しを終了します。

   たとえば、20文字削除するために‘C-u 2 0 C-d’と入力したとしましょう。
‘C-x z z z’と入力すれば、(引数を含めて)削除コマンドをさらに3回繰り返し、
全部で80文字削除できます。始めの‘C-x z’でコマンドを1回繰り返し、そのあと
のそれぞれの‘z’で1回ずつ繰り返します。


File: emacs-ja.info,  Node: Minibuffer,  Next: M-x,  Prev: Basic,  Up: Top

8 ミニバッファー
****************

“ミニバッファー(minibuffer)”とは、Emacsのコマンドがファイル名、バッファ
ー名、Emacsコマンド名、Lisp式といった、複雑な引数を読み取るための場所で
す。なぜ“ミニバッファー”と呼ぶかというと、それがスクリーン上の小領域を占
める、特別な目的のためのバッファーだからです。ミニバッファーで引数テキス
トを編集するために、通常のEmacs編集コマンドを使うことができます。

* Menu:

* Basic Minibuffer::         ミニバッファーの基本的な使い方。
* Minibuffer File::          ミニバッファーでファイル名を入力する。
* Minibuffer Edit::          ミニバッファーで編集する方法。
* Completion::               ミニバッファーでの入力のための略語機能。
* Minibuffer History::       最近のミニバッファー引数の再使用。
* Repetition::               ミニバッファーを使ったコマンドの再実行。
* Passwords::                エコーエリアでパスワードを入力する。
* Yes or No Prompts::        エコーエリアでyes/noにこたえる。


File: emacs-ja.info,  Node: Basic Minibuffer,  Next: Minibuffer File,  Up: Minibuffer

8.1 ミニバッファーを使う
========================

ミニバッファーを使用中、ミニバッファーはエコーエリアにカーソルとともに表
示されます。ミニバッファーは通常、コロンが最後についた“プロンプト
(prompt)”から開始されます。プロンプトはどのような入力が期待されるか、そ
してそれがどのように使われるのかを示します。プロンプトは、フェイス
‘minibuffer-prompt’を使ってハイライトされます。

   ミニバッファーで入力するもっとも簡単な方法は、テキストを入力してから
<RET>で引数入力を完了してミニバッファーを終了する方法です。かわりに
‘C-g’を入力して引数を求めているコマンドをキャンセルし、ミニバッファーを
終了することもできます(*note Quitting::を参照してください)。

   コロンの前のカッコ内に“デフォルト引数(default argument)”を表示するプ
ロンプトもあります。このデフォルト値は、<RET>だけを入力したときに、引数
として使用されます。たとえばバッファー名を読み取るコマンドは、通常デフォ
ルト値としてバッファー名を表示します。<RET>を入力することでデフォルトの
バッファーにたいして処理を行うことができます。

   Minibuffer Electric Defaultモードというグローバルマイナーモードを有効
にしている場合、ミニバッファーの内容の変更を開始すると、Emacsはデフォル
ト引数を非表示にします。ミニバッファーのテキストを元に戻せば、ふたたびプ
ロンプトにデフォルト値が表示されます。さらに変数
‘minibuffer-eldef-shorten-default’を非‘nil’値に変更すると、スクリーンの
スペースを節約するために、‘(default DEFAULT-ARG)’のかわりに
‘[DEFAULT-ARG]’の形式でデフォルト値を表示します。このマイナーモードを有
効にするには、‘M-x minibuffer-electric-default-mode’とタイプしてください
。

   エコーエリアにミニバッファーが表示されると、他のエコーエリアの使用と
競合するかもしれません。ミニバッファーがアクティブなとき、エラーメッセー
ジや情報メッセージは一時的な表示となります。メッセージは数秒ミニバッファ
ーを隠すように表示されるか、なにかタイプするまでのあいだ表示され、その後
ミニバッファーに戻ります。ミニバッファーの使用中、Emacsはキーストローク
をエコーしません。


File: emacs-ja.info,  Node: Minibuffer File,  Next: Minibuffer Edit,  Prev: Basic Minibuffer,  Up: Minibuffer

8.2 ミニバッファーでのファイル名
================================

‘C-x C-f’ (‘find-file’)のようなコマンドは、ミニバッファーを使ってファイ
ル名引数を読み取ります。ファイル名を読み取るためにミニバッファーを使用し
ているとき、通常は最後にスラッシュがついたテキストで開始されています。こ
れは“デフォルトディレクトリー(default directory)”です。たとえば以下のよ
うに開始されていたとします:

     Find file: /u2/emacs/src/

ここで‘Find file: ’はプロンプト、‘/u2/emacs/src/’はデフォルトディレクト
リーです。ここで‘buffer.c’を入力すると‘/u2/emacs/src/buffer.c’を指定した
ことになります。デフォルトディレクトリーについての情報は、*note File
Names::を参照してください。

   あなたが望むかもしれないファイル名のデフォルト候補は、‘M-n’とタイプす
ることにより利用できます。*note Minibuffer History::を参照してください。

   ‘..’で親ディレクトリー内のファイルを指定できます。つまり
‘/a/b/../foo.el’は‘/a/foo.el’と同じです。‘M-<DEL>’を使えば、ディレクトリ
ー名を後方にkillできます(*note Words::を参照してください)。

   デフォルトディレクトリーとは無関係のファイルを指定する場合、デフォル
ト値全部を‘C-a C-k’でkillできます。かわりにデフォルト値を無視することも
できます。これはスラッシュで始まる絶対パスのファイル名か、チルダで始まる
ファイル名をデフォルトディレクトリーに続けて入力します。たとえば以下のよ
うにして‘/etc/termcap’を指定できます:

     Find file: /u2/emacs/src//etc/termcap

ダブルスラッシュにより、Emacsは2番目のスラッシュより前のすべてを無視しま
す。上の例では‘/u2/emacs/src/’は無視されるので、引数は‘/etc/termcap’とな
ります。無視される部分のファイル名は、端末に可能なら目立たないような表示
になります(これを無効にするには、コマンド‘M-x file-name-shadow-mode’で
File Name Shadowモードをオフにしてください)。

   リモートファイルの名前(*note Remote Files::を参照)を補完する際、ダブ
ルスラッシュは若干異なる挙動を示します。この場合のダブルスラッシュは、
Emacsがファイル名の部分だけを無視して、他の部分(method、host、username、
...など)を手付かずのままにするようにします。3つのスラッシュを連続してタ
イプすると、リモートファイル名の中のすべてを無視します。*note
(tramp)File name completion::を参照してください。

   Emacsは‘~/’をホームディレクトリーと解釈します。‘~/foo/bar.txt’はホー
ムディレクトリーにある、‘foo’というディレクトリーの、‘bar.txt’という名前
のファイルを指定します。さらに‘~USER-ID/’はログイン名がUSER-IDというユー
ザーの、ホームディレクトリーを意味します。‘~’の前のディレクトリー名は無
視されるので、‘/u2/emacs/~/foo/bar.txt’は‘~/foo/bar.txt’と同じです。

   MS-WindowsとMS-DOSでは、ユーザーは常にホームディレクトリーを持つとは
限らないので、Emacsはいくつかの代替ディレクトリーを使います。
MS-Windowsについては*note Windows HOME::、MS-DOSについては *note MS-DOS
File Names::を参照してください。 これらのシステムでは‘~USER-ID/’は現在の
ユーザーの場合だけ、つまりUSER-IDが現在のユーザーのログイン名のときだけ
がサポートされます。

   Emacsがファイル名を読みとるとき、デフォルトディレクトリーを挿入しない
ようにするには、変数‘insert-default-directory’を‘nil’に変更します。この
場合、ミニバッファーは空で開始されます。それでも相対パスでのファイル名引
数は、同じデフォルトディレクトリーにもとづいて解釈されます。

   ミニバッファーにリモートファイル名を入力することもできます。 *note
Remote Files::を参照してください。


File: emacs-ja.info,  Node: Minibuffer Edit,  Next: Completion,  Prev: Minibuffer File,  Up: Minibuffer

8.3 ミニバッファーでの編集
==========================

ミニバッファーは一風変わっていますがEmacsのバッファーなので、引数テキス
トを編集するための、通常のEmacsコマンドが利用可能です(しかしプロンプトは
“読み取り専用(read-only)”なので変更できません)。

   ミニバッファーでの<RET>は引数を完了させるので、これを使って改行を挿入
することはできません。‘C-q C-j’を使えば制御文字‘C-j’(改行文字と等しい)を
挿入できます(*note Inserting Text::を参照してください)。かわりに‘C-o’
(‘open-line’)を使うこともできます(*note Blank Lines::を参照してください
)。

   ミニバッファーの中では<TAB>、<SPC>、‘?’は“補完コマンド(completion
commands)”にバインドされている場合があります。これによりテキスト全部を入
力せずに、入力したいテキストを簡単に入力できます。*note Completion::を参
照してください。<RET>のときと同様、‘C-q’を使って<TAB>、<SPC>、‘?’のよう
な文字を入力できます。

   便宜上ミニバッファーでの‘C-a’ (‘move-beginning-of-line’)は、プロンプ
トの先頭ではなく引数テキストの先頭にポイントを移動します。これにより、た
とえば‘C-a C-k’で引数全体をkillことができます。

   ミニバッファーがアクティブのとき、エコーエリアは通常のEmacsウィンドウ
のように扱われます。たとえば(‘C-x o’で)他のウィンドウに切り替えて、そこ
でテキストを編集して、またミニバッファーのウィンドウにもどって引数の入力
を完了できます。ほかのウィンドウでテキストをkillしてからミニバッファーの
ウィンドウにもどり、引数にテキストをyankすることさえ可能です。しかしミニ
バッファーのウィンドウは分割(split)できないなどの制限もあります。*note
Windows::を参照してください。

   通常ミニバッファーのウィンドウは、スクリーン行で1行を占めます。しかし
2行以上のテキストをミニバッファーに追加すると、そのテキストに対応して自
動的に拡張されます。変数‘resize-mini-windows’は、ミニバッファーのサイズ
調整を制御します。デフォルト値は‘grow-only’で、これは今説明したとおりの
振る舞いを意味します。もし値が‘t’の場合、ミニバッファーから行を削除する
と。ミニバッファーのウィンドウは自動的に縮小されて、スクリーン行で1行ま
で小さくなります。値が‘nil’の場合、ミニバッファーのウィンドウは自動的に
サイズを変更しません。しかし通常のウィンドウのサイズ調整コマンドは使用で
きます(*note Windows::を参照してください)。

   変数‘max-mini-window-height’は、ミニバッファーのウィンドウのサイズ変
更するときの、最大高さを制御します。浮動少数を指定した場合は、フレームの
高さにたいする比になります。整数を指定した場合は最大行数になります。
‘nil’を指定すると、ミニバッファーのウィンドウの自動サイズ調整は行われま
せん。デフォルト値は0.25です。

   ミニバッファーでの‘C-M-v’コマンドは、他のウィンドウに表示されたコマン
ドのヘルプテキストをスクロールします。‘M-<PageUp>’や‘M-<PageDown>’(また
は‘M-<prior>’や‘M-<next>’)でも、ヘルプテキストをスクロールできます。これ
は長い補完候補のリストを選ぶときなどに便利です。*note Other Window::を参
照してください。

   通常Emacsはミニバッファーがアクティブのときは、ミニバッファーにたいし
て多くのコマンドを使用できないようにしています。ミニバッファーでこれらの
コマンドを使えるようにするには、変数‘enable-recursive-minibuffers’に
‘t’をセットしてください。

   アクティブでないとき、ミニバッファーは‘minibuffer-inactive-mode’にな
っており、‘mouse-1’をクリックすると、‘*Messages*’バッファーを表示します
。ミニバッファー専用のフレームを使用している場合、Emacsはそこでのキー入
力も認識します。たとえば‘n’は新しいフレームを作成します。


File: emacs-ja.info,  Node: Completion,  Next: Minibuffer History,  Prev: Minibuffer Edit,  Up: Minibuffer

8.4 補完
========

引数を入力する助けとなる、“補完(completion)”という機能が使えるときがあり
ます。これは引数の一部を入力すると、それまでに何を入力したかにもとづいて
、Emacsが残りあるいは残りの一部を補完してくれることを意味します。

   補完が利用可能なとき、特定のキー(通常は<TAB>、<RET>、<SPC>)が、ミニバ
ッファーの特別な補完コマンド(*note Completion Commands::を参照してくださ
い)にリバインドされています。これらのコマンドは、ミニバッファーのテキス
トを完了させようと試みます。これは引数を要求したコマンドが提供する、“補
完候補(completion alternatives)”にもとづいています。通常‘?’を入力すると
、補完候補のリストを見ることができます。

   補完は通常ミニバッファー内で行われますが、通常のバッファーないでもこ
の機能を利用可能なときがあります。*note Symbol Completion::を参照してく
ださい。

* Menu:

* Completion Example::       補完の使い方の例。
* Completion Commands::      補完コマンドのリスト。
* Completion Exit::          補完とミニバッファーでのテキストの確定。
* Completion Styles::        補完のマッチが選ばれる方法。
* Completion Options::       補完のオプション。


File: emacs-ja.info,  Node: Completion Example,  Next: Completion Commands,  Up: Completion

8.4.1 補完の例
--------------

ここでは簡単な例が理解しやすいでしょう。‘M-x’は、コマンド名を読み取るた
めにミニバッファーを使います。補完はミニバッファーのテキストと、既存の
Emacsコマンドの名前のマッチによって機能します。コマンドを
‘auto-fill-mode’を実行したいとします。‘M-x auto-fill-mode <RET>’をタイプ
すればよいのですが、補完を使えばもっと簡単になります。

   ‘M-x a u <TAB>’とタイプすると、<TAB>は‘au’で始まる補完候補(この例では
コマンド名)を探します。‘auto-fill-mode’、‘autoconf-mode’などの候補がいく
つかありますが、候補はすべて‘auto’で始まるので、ミニバッファーの‘au’は
‘auto’に補完されます(あなたのEmacsのセッションには、もっと多くのコマンド
が定義されているかもしれません。たとえば‘authorize-me’というコマンドが定
義されている場合には、Emacsが補完できるのは‘aut’までです)。

   もう一度<TAB>をタイプしても、次の文字は‘-’、‘a’、‘c’のどれなのか決定
できません。そのため文字は追加されず、かわりに<TAB>は可能性のある補完候
補の一覧を別のウィンドウに表示します。

   次に‘-f’と入力します。ミニバッファーには‘auto-f’が入力されました。こ
の文字で始まるコマンド名は、‘auto-fill-mode’だけです。ここで<TAB>を入力
すると、残りの部分が補完されて、ミニバッファーの引数は‘auto-fill-mode’に
なります。

   したがって‘a u <TAB> - f <TAB>’と入力するだけで、‘auto-fill-mode’と入
力できるのです。


File: emacs-ja.info,  Node: Completion Commands,  Next: Completion Exit,  Prev: Completion Example,  Up: Completion

8.4.2 補完コマンド
------------------

以下は補完が使えるときに、ミニバッファーで定義されている補完コマンドの一
覧です。

‘<TAB>’
     可能な限りミニバッファーのテキストを補完します。補完できないときは
     、可能性のある補完候補のリストを表示します(‘minibuffer-complete’)。
‘<SPC>’
     ミニバッファーのテキストを単語単位で補完します
     (‘minibuffer-complete-word’)。このコマンドは、引数にスペースが含ま
     れる可能性のあるファイル名などでは利用できません。
‘<RET>’
     最初に可能な限り補完した後で、ミニバッファーのテキストを引数として
     確定します。*note Completion Exit::を参照してください。
‘?’
     補完候補の一覧を表示します(‘minibuffer-completion-help’)。

   <TAB> (‘minibuffer-complete’)は、もっとも基本的な補完コマンドです。こ
れはミニバッファーのテキストとマッチする可能性のある、すべての補完候補を
検索して、できるかぎりの補完を試みます。補完候補が選択される方法について
は、*note Completion Styles::を参照してください。

   <SPC> (‘minibuffer-complete-word’)は、<TAB>と同じように補完をおこない
ますが、次のハイフンまたは空白までしか補完しません。ミニバッファーが
‘auto-f’の場合、‘auto-fill-mode’まで補完できますが、‘ill-’しか挿入しない
ので‘auto-fill-’となります。次に<SPC>を入力すると‘auto-fill-mode’が補完
されます。

   <TAB>や<SPC>が補完できない場合、マッチする補完候補のリスト(複数ある場
合)を、別のウィンドウに表示します。同じリストは‘?’
(‘minibuffer-completion-help’)でも表示できます。以下は補完一覧で使うこと
ができるコマンドです:

‘M-v’
‘<PageUp>’
‘<prior>’
     ミニバッファーで‘M-v’を入力すると、候補リストを表示しているウィンド
     ウを選択します(‘switch-to-completions’)。以下のコマンドを使うには、
     この方法がよいでしょう。<PageUp>と<prior>は同じことをおこないます。
     他の方法でもウィンドウを選択できます(*note Windows::を参照してくだ
     さい)。

‘<RET>’
‘mouse-1’
‘mouse-2’
     補完候補リストのバッファー内では、ポイント位置の補完候補を選択しま
     す(‘choose-completion’)。

‘<RIGHT>’
     補完候補リストのバッファー内では、次の補完候補にポイントを移動しま
     す(‘next-completion’)。

‘<LEFT>’
     補完候補リストのバッファー内では、前の補完候補にポイントを移動しま
     す(‘previous-completion’)。


File: emacs-ja.info,  Node: Completion Exit,  Next: Completion Styles,  Prev: Completion Commands,  Up: Completion

8.4.3 補完の終了
----------------

コマンドがミニバッファーの補完を使って引数を読みとる場合、引数を確定する
ために<RET> (‘minibuffer-complete-and-exit’)をタイプしたときに、何が起こ
るかも制御します。これには4種類の動作があります:

   • “強い補完(Strict completion)”は、正確にマッチする補完のみを許します
     。<RET>でミニバッファーを抜けるのは、ミニバッファーのテキストが正確
     にマッチしているか、1つに補完された場合だけです。それ以外の場合、
     Emacsはミニバッファーからのexit(入力を完了してミニバッファーから抜
     け出す)を拒絶します。かわりに補完を試み、補完できなかったときは、ミ
     ニバッファーのテキストの後ろに数秒‘[No match]’と表示します(‘C-g’を
     使えばミニバッファーを離れることができます)。

     この動作をおこなうコマンドの例は‘M-x’で、それは存在しないコマンド名
     を受けとるのは無意味だからです。

   • “慎重な補完(Cautious completion)”は強い補完と似ていますが、テキスト
     がすでに正確にマッチしているときだけexitできる点が異なります。テキ
     ストが正確なマッチに補完できるとき、<RET>は補完を行いますが、まだ
     exitしません。exitするには、もう一度<RET>を入力しなければなりません
     。

     慎重な補完は、たとえば存在しなければならないファイル名を読みとると
     きに使用されます。

   • “寛大な補完(Permissive completion)”は、任意の入力を許容します。補完
     候補はあくまでも提案です。<RET>では補完は行われず、単に入力された引
     数を確定します。

   • “確認付きの寛大な補完(Permissive completion with confirmation)”は、
     寛大な補完と似ていますが例外があります。<TAB>を入力して、テキストが
     ある中間的な状態まで補完されたとき(たとえばまだ正確なマッチに至らな
     いとき)、次に<RET>を入力しても引数は確定されません。かわりにEmacsは
     テキストの後ろに‘[Confirm]’を数秒表示して、確認を求めます。その次の
     <RET>は確認とみなされテキストが確定されます。これにより<TAB>により
     希望するマッチまで補完されたと勘違いして、<RET>を押してしまうなどの
     一般的な間違いを捕らえることができます。

     変数‘confirm-nonexistent-file-or-buffer’をカスタマイズして、確認動
     作を微調整できます。デフォルト値の‘after-completion’は、まさに説明
     したとおりに動作します。これを‘nil’に変更すると、Emacsは確認を求め
     なくなり、寛大な補完にフォールバックします。他の非‘nil’値に変更した
     場合、その前のコマンドが<TAB>かどうかにかかわらず、Emacsは確認を求
     めます。

     この動作はファイル名を読みとる‘C-x C-f’や、バッファー名を読み取る
     ‘C-x b’など、多くのコマンドで使われています。


File: emacs-ja.info,  Node: Completion Styles,  Next: Completion Options,  Prev: Completion Exit,  Up: Completion

8.4.4 補完候補が選択される方法
------------------------------

補完コマンドは、たくさんの可能性のある補完候補を、ミニバッファーに入力し
たものとマッチ(match)する、より少ないサブセットへと絞り込むことにより機
能します。*note Completion Example::では、そのようなマッチングの簡単な例
を紹介しました。どのような構成がマッチなのかを決定する手続きはとても複雑
です。Emacsは多くの状況下でもっとも妥当と思われる補完を試みます。

   Emacsは1つ以上の“補完スタイル(completion styles)”を使って補完をおこな
います。これはミニバッファーのテキストを補完候補とマッチングするための条
件のセットです。補完を行うとき、Emacsは補完スタイルを順番に試します。も
しあるスタイルが1つ以上のマッチを獲得した場合、それらは補完候補リストの
ために使用されます。もしあるスタイルがマッチを獲得できなかった場合、
Emacsは次のスタイルにフォールバックします。

   リスト変数‘completion-styles’は、使用する補完スタイルを定義します。そ
れぞれのリスト要素(list element)は、補完スタイルの名前(Lispシンボル)です
。デフォルトの補完スタイルは、リスト変数に以下の名前の要素が順番に並んで
います。

‘basic’
     ミニバッファーのポイントより前のテキストと、補完候補の先頭が同じで
     なければなりません。さらにミニバッファーのポイントより後ろのテキス
     トがある場合、補完候補の残りそれが含まれていなければなりません。

‘partial-completion’
     このアグレッシブな補完スタイルは、ミニバッファーのテキストをハイフ
     ンまたは空白で区切り、各単語ごとに補完をおこないます(たとえばコマン
     ド名を補完する場合、‘em-l-m’は、‘emacs-lisp-mode’に補完されます)。

     さらにミニバッファーのテキスト中の‘*’は、“ワイルドカード
     (wildcard)”として扱われます。これは補完候補の対応する位置にある文字
     列の、任意の文字とマッチします。

‘emacs22’
     この補完スタイルは‘basic’とにていますが、ミニバッファーのポイントよ
     り後のテキストを無視します。この名前は補完の動作がEmacs 22と同じだ
     からです。

以下の追加の補完スタイルが定義されており、‘completion-styles’に追加する
こともできます(*note Customization::を参照してください)。

‘substring’
     補完候補は、ミニバッファーのポイントより前のテキストと、ポイントよ
     り後のテキストが同じ順番で含まれていなければなりません。

     したがって、ミニバッファーのテキストが‘foobar’で、ポイントが‘foo’と
     ‘bar’の間にある場合、‘AfooBbarC’にマッチします。この場合A、B、Cは空
     文字列を含む任意の文字列です。

‘initials’
     このとてもアグレッシブな補完スタイルは、頭文字とイニシャルで補完を
     試みます。たとえばコマンド名の補完をする場合、‘lch’は
     ‘list-command-history’とマッチします。

‘emacs21’と呼ばれる、とてもシンプルな補完スタイルもあります。このスタイ
ルでは、ミニバッファーのテキストが‘foobar’の場合、‘foobar’で始まるものだ
けにマッチします。

   変数‘completion-category-overrides’を設定することにより、状況に応じて
異なる補完スタイルを使うことができます。たとえばバッファー名を補完すると
きは、デフォルトで‘basic’と‘substring’だけを使うよう指定できます。


File: emacs-ja.info,  Node: Completion Options,  Prev: Completion Styles,  Up: Completion

8.4.5 補完オプション
--------------------

大文字小文字の違いは、コマンド名のように大文字小文字を区別する
(case-sensitive)引数では重要です。たとえばコマンド名の補完では、‘AU’では
‘auto-fill-mode’に補完されません。大文字小文字の違いは、それが問題になら
ない引数の補完では無視されます。

   ファイル名を補完するとき、変数
‘read-file-name-completion-ignore-case’が非‘nil’なら、大文字小文字の違い
は無視されます。GNU/Linuxのように、ファイル名の大文字と小文字を区別する
システムでは、デフォルト値は‘nil’です。Microsoft Windowsのように、ファイ
ル名の大文字と小文字を区別しないシステムでは、非‘nil’です。バッファー名
を補完するとき、‘read-buffer-completion-ignore-case’が非‘nil’なら、大文
字小文字の違いは無視されます。デフォルトは‘nil’です。

   通常Emacsはファイル名を補完するとき、選ばれるべきではないと思われる、
特定の候補を無視します。これはリスト変数
‘completion-ignored-extensions’により決定されます。リストの要素はに文字
列を指定します。それらの文字列で終わるファイル名は、補完候補としては無視
されます。スラッシュ(‘/’)で終わる要素は、ディレクトリー名を表します。
‘completion-ignored-extensions’の標準的な値は‘".o"’、‘".elc"’、‘"~"’を含
むいくつかの要素です。たとえばディレクトリーに‘foo.c’、‘foo.elc’があると
き、‘foo’は‘foo.c’に補完されます。しかし_すべて_の補完候補が無視すべき文
字列で終わるとき、これらの候補は無視されません。前の例でいうと‘foo.e’は
‘foo.elc’に補完されます。Emacsは補完候補リストで補完候補を表示するとき、
‘completion-ignored-extensions’を無視します。

   Shellでの補完は、ファイル名補完の拡張されたバージョンです。*note
Shell Options::を参照してください。

   ‘completion-auto-help’に‘nil’がセットされていると、補完コマンドは補完
リストバッファーを表示しません。表示するには‘?’を入力しなければなりませ
ん。値が‘lazy’の場合、Emacsは2度目の補完を試みたときだけ、補完リストバッ
ファーを表示します。もし補完すべきものがない場合、1度目の<TAB>は‘Next
char not unique’と表示し、2度目の<TAB>で補完リストバッファーが表示されま
す。

   ‘completion-cycle-threshold’が非‘nil’のとき、補完コマンドは補完候補を
循環(cycle)することができます。ミニバッファーのテキストで１つ以上の補完
候補がある場合は通常、補完コマンドは補完できた文字までを表示します。
‘completion-cycle-threshold’を‘t’に変更すると、補完コマンドは補完候補の
中から最初の候補を表示します。それ以降の補完コマンドの呼び出しでは、その
次の補完候補を循環的に表示します。‘completion-cycle-threshold’を数値Nに
すると、補完候補がN以下のときだけ循環表示の動作をします。


File: emacs-ja.info,  Node: Minibuffer History,  Next: Repetition,  Prev: Completion,  Up: Minibuffer

8.5 ミニバッファーヒストリー
============================

ミニバッファーで入力したすべての引数は、“ミニバッファーヒストリーリスト
(minibuffer history list)”に保存されているので、簡単に後でまた使うことが
できます。以下のコマンドにより、前の引数をすばやく探してミニバッファーに
呼び出すことができます:

‘M-p’
     ミニバッファーヒストリーの前のアイテム、つまり以前のアイテムに移動
     します(‘previous-history-element’)。
‘M-n’
     ミニバッファーヒストリーの次のアイテムに移動します
     (‘next-history-element’)。
‘<UP>’
‘<DOWN>’
     ‘M-p’や‘M-n’と同様ですが、前のヒストリーアイテムに移動する前に、複
     数行アイテムの前、または次の行に移動します
     (‘previous-line-or-history-element’、および
     ‘next-line-or-history-element’)。
‘M-r REGEXP <RET>’
     REGEXPにマッチする、ミニバッファーヒストリーの以前のアイテムに移動
     します(‘previous-matching-history-element’)。
‘M-s REGEXP <RET>’
     REGEXPにマッチする、ミニバッファーヒストリーの以降のアイテムに移動
     します(‘next-matching-history-element’)。

   ミニバッファーでの‘M-p’ (‘previous-history-element’)は、ミニバッファ
ーのヒストリーリストのアイテムを1つずつ移動します。‘M-p’はヒストリーリス
トの以前のアイテムを取り出して、ミニバッファーの既存の内容を置き換えます
。‘M-n’ (‘next-history-element’)は、ミニバッファーのヒストリーリストを反
対方向、つまり以降のエントリーを取り出してミニバッファーの既存の内容を置
き換えます。

   ミニバッファーヒストリーに以降のエントリーがないとき(たとえば前に1回
も‘M-p’を入力していないとき)、Emacsはデフォルト引数のリストから、あなた
が入力するだろうと思われる値を取り出します。これは“未来のヒストリー”を移
動すると考えることもできます。

   ファイルにたいする“未来のヒストリー(future history)”には、カレントバ
ッファー内のポイント位置にあるファイル名やURLのような、あなたが便利だと
思うかもしれないいくつかの候補が含まれます。この場合、“未来のヒストリー
”に配されるデフォルトは、オプション‘file-name-at-point-functions’の値に
セットされた関数により制御されます。デフォルトでは、この値は‘ffap’パッケ
ージ((*note FFAP::)を参照)を呼び出します。これはポイント周辺のテキストか
らデフォルトとなるファイルやURLを推測します。この推測を無効にするには、
このオプションを‘nil’値にカスタマイズします。これにより“未来のヒストリー
”に含まれるのは、(もしあれば)カレントバッファーでvisitされたファイル、お
よびデフォルトディレクトリーのファイルだけになります。

   矢印キーの‘<UP>’と‘<DOWN>’は、‘M-p’や‘M-n’のように機能しますが、カレ
ントヒストリーアイテムが複数行の場合には、前(または次)のヒストリーアイテ
ムに移動する前に、前(または次)の行に移動します。

   ミニバッファーコマンドの‘M-p’または‘M-n’で挿入されたテキストを編集し
ても、ヒストリーリストのエントリーは変更されません。かわりに編集された引
数が確定されたとき、ヒストリーリストの最後に追加されます。

   ‘M-r’ (‘previous-matching-history-element’)でヒストリーリストの古い要
素を、‘M-s’ (‘next-matching-history-element’)で新しいエントリーを探すこ
とができます。これらのコマンドはどちらも引数として“正規表現(regular
expression)”を要求し、それにマッチした最初のエントリーをミニバッファーに
取り出します。正規表現についての説明は、*note Regexps::を参照してくださ
い。数引数Nを指定すると、それはN番目に一致したエントリーを取り出すことを
意味します。これらのコマンドはミニバッファーから呼び出されたとはいえ、ミ
ニバッファーを使って正規表現を読みとるという点では、変わったコマンドです
。正規表現に大文字が含まれていると、大文字小文字を区別する検索(*note Lax
Search::を参照してください)となります。

   ヒストリーをインクリメンタルサーチすることもできます。*note Isearch
Minibuffer::を参照してください。

   Emacsは引数の種類ごとに個別のリストを保持します。たとえばファイル名の
リストは、ファイル名を読みとるすべてのコマンドで使われたファイル名、とい
った具合です。ほかのヒストリーリストとしてはバッファー名やコマンド名
(‘M-x’で使われたもの)、コマンド引数(‘query-replace’のような引数で使われ
たもの)があります。

   変数‘history-length’には、ミニバッファーのヒストリーリストの最大の長
さを指定します。リストが長くなりすぎたときは、一番古い要素を削除して新し
い要素を追加します。‘t’を指定したときは、長さは無制限になります。

   変数‘history-delete-duplicates’には、重複したヒストリーを削除するかを
指定します。非‘nil’の場合、新しい要素が追加されるとリストからそれと同じ
要素がすべて削除されます。デフォルトは‘nil’です。


File: emacs-ja.info,  Node: Repetition,  Next: Passwords,  Prev: Minibuffer History,  Up: Minibuffer

8.6 ミニバッファーでのコマンドの繰り返し
========================================

ミニバッファーを使用したコマンドはすべて、“コマンドヒストリー(command
history)”という特別なヒストリーリストに記録されます。これにはコマンドの
引数の値も記録されるので、コマンド全体を再実行できます。特に‘M-x’はコマ
ンド名を読みとるので、‘M-x’を使用したものはすべてそこに記録されます。

‘C-x <ESC> <ESC>’
     コマンドヒストリーから最近のミニバッファーのコマンドを再実行します
     (‘repeat-complex-command’)。
‘M-x list-command-history’
     コマンドヒストリー全体を表示します。表示されたすべてのコマンドは
     ‘C-x <ESC> <ESC>’で再実行できます。一番最近のものが先頭に表示されま
     す。

   ‘C-x <ESC> <ESC>’は、ミニバッファーを使った最近のコマンドを再実行しま
す。引数を与えないと、一番最近のコマンドを実行します。数引数で再実行した
いコマンドを指定します。1は一番最近のコマンド、2はその前、といった具合で
す。

   ‘C-x <ESC> <ESC>’は、前のコマンドをLisp式に変換して、その式でミニバッ
ファーのテキストを初期化します。Lispを知らなくても、何のコマンドが再実行
用に表示されているか明白でしょう。単に<RET>を入力すると、コマンドを変更
せずに再実行します。実行する前にLisp式を編集して、コマンドを変更できます
。実行されたコマンドは、一番最近のコマンドと等しくなければ、コマンドヒス
トリーの一番先頭に追加されます。

   ‘C-x <ESC> <ESC>’で一度ミニバッファーの中に入れば、通常のミニバッファ
ーのヒストリーコマンド(*note Minibuffer History::を参照してください)を使
って、ヒストリーリスト中を移動できます。以前に実行したコマンドが見つけた
ら、式を編集して<RET>により実行できます。

   厳密に言うとインクリメンタルサーチはミニバッファーを使いません。これ
が複雑なコマンドのように振る舞うとしても、通常は‘C-x <ESC> <ESC>’で表示
されるヒストリーリストに含まれません。ヒストリーにインクリメンタルサーチ
コマンドを表示させるには、‘isearch-resume-in-command-history’に非‘nil’を
セットしてください。*note Incremental Search::を参照してください。

   ミニバッファーを使用した以前のコマンドのリストは、Lispのリスト値とし
て‘command-history’に格納されています。Lisp式の各要素は、1つのコマンドと
その引数をあらわしています。Lispプログラムは‘eval’に‘command-history’の
要素を使って呼び出すことで、コマンドを再実行できます。


File: emacs-ja.info,  Node: Passwords,  Next: Yes or No Prompts,  Prev: Repetition,  Up: Minibuffer

8.7 パスワードの入力
====================

Emacsでパスワードを入力したい場合があります。たとえばEmacsにFTPのような
ネットワークプロトコルを介して他のマシンのファイルをvisitし、マシンへの
アクセスのためにパスワードを与える場合などです(*note Remote Files::を参
照してください)。

   パスワードの入力はミニバッファーの使用と似ています。Emacsは
(‘Password: ’のような)プロンプトをエコーエリアに表示します。要求されたパ
スワードを入力した後、それを確定するために<RET>を押します。他の人がパス
ワードを見るのを防ぐために、入力した文字は通常の形式ではなく、ドット
(‘.’)で表示されます。

   ミニバッファーに関連付けられた多くの機能およびコマンドは、パスワード
入力では使用_できません_。ヒストリーや補完はできず、ウィンドウの変更や
Emacsでの他の処理も、パスワードをsubmitするまでは行うことができません。

   パスワードのタイプ中は、<DEL>を押して後方に、すなわち最後に入力した文
字から削除できます。‘C-u’で入力したすべての文字を削除できます。‘C-g’はパ
スワードプロンプトを閉じます(*note Quitting::を参照してください)。
‘C-y’は現在のkillリングからパスワードを挿入します(*note Killing::)。パス
ワードを確定するには、<RET>または<ESC>を入力します。他の自己挿入文字は、
対応する文字をパスワードに入力します.それ以外の入力は無視されます。


File: emacs-ja.info,  Node: Yes or No Prompts,  Prev: Passwords,  Up: Minibuffer

8.8 Yes or No プロンプト
========================

Emacsのコマンドが実行の過程で、yes-or-no(はい/いいえ)形式で質問して答え
を求めるかもしれません。これらの質問は大きく2つにわけることができます。

   1番目のyes-or-no形式の質問は、‘(y or n)’で終わるプロンプトのものです
。このような質問は、実際のところミニバッファーを使用しません。プロンプト
がエコーエリアに表示され、答えを‘y’または‘n’で入力すると、ただちにそれが
答えとなります。たとえばバッファーの保存で‘C-x C-w’ (‘write-file’)を入力
して既存のファイル名を入力すると、Emacsは以下のようなプロンプトを表示し
ます:

     File ‘foo.el’ exists; overwrite? (y or n)

この質問はミニバッファーを使用しないので、通常のミニバッファー編集コマン
ドは使えません。しかしいくつかのウィンドウをスクロールする操作は行えます
。‘C-l’による選択されたウィンドウの再センタリング、‘C-v’(または
<PageDown>か<next>)による前方へのスクロール、‘M-v’(または<PageUp>か
<prior>)による後方へのスクロール、‘C-M-v’による次のウィンドウの前方への
スクロール、‘C-M-S-v’による次のウィンドウの後方へのスクロールができます
。‘C-g’は質問を打ちきり、質問を発したコマンドを終了します(*note
Quitting::を参照してください)。

   2番目のyes-or-no形式の質問は、間違った答えが深刻な事態を招くような場
合に使用されます。これはミニバッファーを使い、‘(yes or no)’で終わるプロ
ンプトという特徴があります。たとえば変更が保存されていないファイルを
visitしているバッファーで、‘C-x k’ (‘kill-buffer’)を呼び出すと、Emacsは
ミニバッファーをアクティブにして以下のようなプロンプトを表示します:

     Buffer foo.el modified; kill anyway? (yes or no)

これに答えるには、ミニバッファーに‘yes’または‘no’と入力してから、<RET>を
押さなければなりません。ミニバッファーは前のセクションで説明したように動
作します。‘C-x o’による他のウィンドウへのスイッチ、ヒストリーコマンドの
‘M-p’や‘M-n’などが使用できます。‘C-g’でミニバッファーを閉じて、質問を発
したコマンドを終了できます。


File: emacs-ja.info,  Node: M-x,  Next: Help,  Prev: Minibuffer,  Up: Top

9 名前を指定してコマンドを実行する
**********************************

すべてのEmacsコマンドは、それを使えば実行できるような名前を持っています
。使いやすいようにキーバインディングされているコマンドも、たくさんありま
す。これらのコマンドはキーまたは名前で実行できます。キーがバインドされて
いないコマンドもたくさんあり、そのようなコマンドは名前でしか実行できませ
ん(キーバインドをセットアップする方法については、*note Key Bindings::を
参照してください)。

   慣例によりコマンド名は‘auto-fill-mode’や‘manual-entry’のように、ハイ
フンで区切られた、1つ以上の単語となっています。コマンド名は覚えやすいよ
うに、略されていない英単語が主に使われます。

   コマンドを名前で実行するには、最初に‘M-x’をタイプしてから、コマンド名
をタイプして<RET>で実行します。‘M-x’はミニバッファーを使ってコマンド名を
読みとります。ミニバッファーの先頭には、実行のために名前の入力が必要なこ
とを気付かせるため、‘M-x’という文字が“プロンプト”として表示されます。
<RET>でミニバッファーを抜けだしコマンドを実行します。ミニバッファーにつ
いての詳細は、*note Minibuffer::を参照してください。

   コマンド名の入力には補完が使用できます。たとえば‘forward-char’を呼び
出すには以下のように入力できます

     M-x forward-char <RET>

または

     M-x forw <TAB> c <RET>

‘forward-char’は、キー‘C-f’で呼び出されるのと同じコマンドであることに注
意してください。キーバインドの存在は、名前によるコマンドの実行を妨げませ
ん。

   ‘M-x’でコマンドを補完するとき、“obsolete(時代遅れ)”と宣言されたコマン
ドは無視されます。これらのコマンドにたいしては、完全な名前をタイプする必
要があります。時代遅れのコマンドとは、もっと新しく、より良い代替が存在し
ていて、将来のEmacsリリースにおいて廃止が予定されているコマンドのことで
す。

   ‘M-x’とコマンドの実行をキャンセルするには、コマンド名の入力のかわりに
‘C-g’を入力します。これによりコマンドを呼び出したレベルまで戻ります。

   ‘M-x’で呼び出すコマンドに数引数を渡すには、‘M-x’の前に数引数を指定し
ます。引数の値はコマンド名が読みとられるときにプロンプトとして表示され、
最終的に‘M-x’は引数をコマンドに渡します。たとえば、コマンド
‘forward-char’に数引数として42を渡すには、‘C-u 42 M-x forward-char
<RET>’とタイプできます。

   ‘M-x’で実行するコマンドがキーバインディングを持つ場合、Emacsはコマン
ド実行後にその旨をエコーエリアに表示します。たとえば‘M-x forward-word’と
入力すると、同じコマンドを‘M-f’で実行できるというメッセージが表示されま
す。このメッセージは変数‘suggest-key-bindings’に‘nil’にセットすればオフ
にできます。‘suggest-key-bindings’の値には数字も指定でき、この場合
Emaceは指定された秒数の間、キーバインドを表示します。バインディングを表
示するときのデフォルトは2秒です。

   キーバインドをもたないコマンドも、‘M-x’のプロンプトで、完全な名前より
短くタイプして呼び出すことができます。Emacsは、短縮入力が完全なコマンド
名より明らかに短く、‘extended-command-suggest-shorter’が非‘nil’の場合は
、そのような短縮入力をエコーエリアに表示します。‘suggest-key-bindings’の
セッティングは、そのようなヒントにも同様に効果を及ぼします。

   このマニュアルではコマンドを名前で実行するとき、名前を終了させるため
の<RET>を省くことがあります。つまり‘M-x auto-fill-mode <RET>’ではなく
‘M-x auto-fill-mode’と表記します。<RET>はコマンドに引数がある場合に強調
させる意味で使用します。

   ‘M-x’は‘execute-extended-command’を実行します。これは他のコマンドの名
前を読み取って実行するコマンドです。


File: emacs-ja.info,  Node: Help,  Next: Mark,  Prev: M-x,  Up: Top

10 ヘルプ
*********

Emacsはバラエティに富んだヘルプコマンドを提供しており、それらにはプレフ
ィクスキー‘C-h’(ファンクションキー<F1>でも可)からアクセスできます。以下
のセクションではこれらのコマンドについて説明します。‘C-h C-h’
(‘help-for-help’)と入力すれば、ヘルプコマンドの一覧を見ることもできます
。この一覧は<SPC>と<DEL>でスクロールでき、それから見たいヘルプコマンドを
入力するか、‘C-g’でキャンセルできます。

   多くのヘルプコマンドは、“ヘルプバッファー(help buffer)”という特別なバ
ッファーに情報を表示します。このバッファーでは<SPC>と<DEL>によりスクロー
ルし、<RET>でハイパーリンクをフォローすることができます。*note Help
Mode::を参照してください。

   特定の機能を探しているが、それが何と呼ばれているかわからない、どこを
見ればよいのかわからないときには、次の3つの方法を推奨します。まず最初に
aproposコマンドを試してください。次にマニュアルのインデックスを探してく
ださい。そしてFAQとパッケージのキーワードを探してください。

‘C-h a TOPICS <RET>’
     引数TOPICSと名前が一致するコマンドを検索します。引数にはキーワード
     、キーワードのリスト、正規表現(*note Regexps::を参照してください)を
     指定できます。*note Apropos::を参照してください。

‘C-h i d m emacs <RET> i TOPIC <RET>’
     Emacsのinfoマニュアルのインデックスから、TOPICを検索して最初にマッ
     チしたものを表示します。‘,’を押すと次にマッチしたものを表示します。
     TOPICには正規表現を指定できます。

‘C-h i d m emacs <RET> s TOPIC <RET>’
     同様ですが、インデックスではなくマニュアル本文の_テキスト_を検索し
     ます。

‘C-h C-f’
     Infoを使ってEmacs FAQを表示します。

‘C-h p’
     キーワードに基づいて、利用可能なEmacsパッケージを表示します。*note
     Package Keywords::を参照してください。

   他のさまざまなコンテキストでも、‘C-h’や<F1>は“ヘルプ”を意味します。た
とえばプレフィクスキーの後にこれらのキーを入力すると、プレフィクスキーに
続けて入力できるキーの一覧を表示することができます(このコンテキストでは
‘?’も使用できます。いくつかのプレフィクスキーは‘C-h’や‘?’に別の意味を持
たせているものがあるので使えませんが、それらのものでも<F1>はサポートされ
ています)。

* Menu:

* Help Summary::             すべてのヘルプコマンドの要約リスト。
* Key Help::                 Emacsでキーが何を行うか尋ねる。
* Name Help::                コマンド、変数、関数名を尋ねる。
* Apropos::                  与えられたトピックに関係があるものを尋ねる。
* Help Mode::                へルポモードとヘルプバッファーの特別な機能。
* Package Keywords::         キーワード(トピック)でLispライブラリーを探す。
* Language Help::            国際的な言語サポートに関するヘルプ。
* Misc Help::                その他のヘルプコマンドについて。
* Help Files::               追加のヘルプファイルを表示するコマンド。
* Help Echo::                アクティブなテキストのヘルプとツールチップ(“バルーンヘルプ”)。


File: emacs-ja.info,  Node: Help Summary,  Next: Key Help,  Up: Help

10.1 ヘルプの概要
=================

ここではビルトインのドキュメントにアクセスする、ヘルプコマンドの要約を記
します。これらの大部分については、以下のセクションで詳細を説明します。

‘C-h a TOPICS <RET>’
     名前がTOPICSにマッチするコマンドの一覧を表示します
     (‘apropos-command’)。
‘C-h b’
     有効なキーバインディングをすべて表示します。最初はマイナーモード、
     次にメジャーモード、それからグローバルのバインディングを表示します
     (‘describe-bindings’)。
‘C-h c KEY’
     キーシーケンスKEYがバインドされているコマンドの名前を表示します
     (‘describe-key-briefly’)。‘c’は“character”からきています。KEYについ
     てさらに詳しい情報を得るには、‘C-h k’を使います。
‘C-h d TOPICS <RET>’
     TOPICSにマッチするドキュメントをもつ、コマンドまたは変数を表示しま
     す(‘apropos-documentation’)。
‘C-h e’
     バッファー‘*Messages*’を表示します(‘view-echo-area-messages’)。
‘C-h f FUNCTION <RET>’
     FUNCTIONという名前の、Lisp関数のドキュメントを表示します
     (‘describe-function’)。コマンドもLisp関数なので、これはコマンドにも
     使用できます。
‘C-h h’
     ファイル‘HELLO’を表示します。このファイルは様々な文字セットの例です
     。
‘C-h i’
     GNUドキュメントブラウザー(‘info’)を実行します。Emacsのマニュアルは
     infoで利用できます。
‘C-h k KEY’
     KEYで実行されるコマンドの名前と、ドキュメントを表示します
     (‘describe-key’)。
‘C-h l’
     最近のキーストローク300回分のの説明を表示します(‘view-lossage’)。
‘C-h m’
     カレントのメジャーモード、およびマイナーモードのドキュメントを表示
     します(‘describe-mode’)。
‘C-h n’
     最近のEmacsの変更に関するニュースを表示します(‘view-emacs-news’)。
‘C-h o SYMBOL’
     SYMBOLという名前のLispシンボルのドキュメントを表示します
     (‘describe-symbol’)。これはすべての種類のシンボル、すなわち関数、変
     数、フェイスのドキュメントも表示します。
‘C-h p’
     トピックのキーワードでパッケージを見つけます(‘finder-by-keyword’)。
     これはパッケージメニューバッファーを使ってパッケージを一覧します。
     *note Packages::を参照してください。
‘C-h P PACKAGE <RET>’
     指定したパッケージのドキュメントを表示します(‘describe-package’)。
‘C-h r’
     Emacsのマニュアルをinfoで表示します(‘info-emacs-manual’)。
‘C-h s’
     現在の“構文テーブル(syntax table)”を表示します(‘describe-syntax’)。
     構文テーブルは、どの文字が開始デリミッターで、その文字が単語の一部
     なのかを定義します。詳細については、*note Syntax Tables:
     (elisp)Syntax Tables.を参照してください。
‘C-h t’
     Emacsの対話的なチュートリアルを開始します(‘help-with-tutorial’)。
‘C-h v VAR <RET>’
     Lisp変数VARのドキュメントを表示します(‘describe-variable’)。
‘C-h w COMMAND <RET>’
     COMMANDという名前のコマンドを実行するキーを表示します(‘where-is’)。
‘C-h C CODING <RET>’
     コーディングシステムCODINGを説明します(‘describe-coding-system’)。
‘C-h C <RET>’
     現在使用されているコーディングシステムを説明します。
‘C-h F COMMAND <RET>’
     infoを開始して、EmacsコマンドCOMMANDのドキュメントのノードに移動し
     ます(‘Info-goto-emacs-command-node’)。
‘C-h I METHOD <RET>’
     インプットメソッドMETHODを説明します(‘describe-input-method’)。
‘C-h K KEY’
     infoを開始して、キーシーケンスKEYのドキュメントのノードに移動します
     (‘Info-goto-emacs-key-command-node’)。
‘C-h L LANGUAGE-ENV <RET>’
     言語環境(language environment)LANGUAGE-ENVで使用される文字セット、
     コーディングシステム、インプットメソッドに関する情報を表示します。
‘C-h S SYMBOL <RET>’
     編集中のプログラム言語に基づいて、シンボルSYMBOLのinfoドキュメント
     を表示します(‘info-lookup-symbol’)。
‘C-h .’
     ポイントが特別なテキスト領域のとき(これには、たとえば‘*Help*’のリン
     クなどが含まれます)、ヘルプメッセージを表示します
     (‘display-local-help’)。


File: emacs-ja.info,  Node: Key Help,  Next: Name Help,  Prev: Help Summary,  Up: Help

10.2 キーのドキュメント
=======================

キーシーケンスに関する情報を得るためのヘルプコマンドは、‘C-h c’
(‘describe-key-briefly’)と‘C-h k’ (‘describe-key’)です。

   ‘C-h c KEY’は、KEYにバインドされているコマンドの名前を、エコーエリア
に表示します。たとえば‘C-h c C-f’は、‘forward-char’と表示します。

   ‘C-h k KEY’も同様ですが、さらに多くの情報が得られます。これはコマンド
が何をするかが正確に説明する、“ドキュメント文字列(documentation
string)”を含むヘルプバッファーを表示します。

   ‘C-h K KEY’は、KEYに対応するコマンドが説明されている、Emacsマニュアル
のセクションを表示します。

   ‘C-h c’、‘C-h k’、‘C-h K’はファンクションキー、メニュー、マウスイベン
ト(ただし‘C-h c’はマウス移動イベントを無視する)を含む、任意のキーシーケ
ンスにたいして動作します。たとえば‘C-h k’の後で、メニューバーからメニュ
ーアイテムを選択すれば、それにより実行されるコマンドのドキュメントが表示
されます。

   ‘C-h w COMMAND <RET>’は、COMMANDがバインドされているキーをリストしま
す。リストはエコーエリアに表示されます。コマンドがキーにバインドされてい
ないとき、それは‘M-x’を使って実行しなければならないことを意味します。
‘C-h w’はコマンド‘where-is’を実行します。


File: emacs-ja.info,  Node: Name Help,  Next: Apropos,  Prev: Key Help,  Up: Help

10.3 コマンドと変数名のヘルプ
=============================

‘C-h f FUNCTION <RET>’ (‘describe-function’)は、Lisp関数FUNCTIONのドキュ
メントをウィンドウに表示します。コマンドもLisp関数なので、この方法を使え
ば、名前を知っている任意のコマンドのドキュメントを閲覧できます。たとえば

     C-h f auto-fill-mode <RET>

は‘auto-fill-mode’のドキュメントを表示します。これはキーにバインドされて
いないコマンド(通常‘M-x’で実行する)のドキュメントを閲覧する、唯一の方法
です。

   ‘C-h f’は、LispプログラムからLisp関数を使うときも便利です。たとえば式
‘(make-vector len)’を書いたとしましょう。正しく‘(make-vector len)’を使っ
ているかチェックしたいときは、‘C-h f make-vector <RET>’と入力します。
‘C-h f’はコマンド名だけでなくすべての関数名を許容するので、‘M-x’では機能
するいつもの補完による短縮形が、‘C-h f’では機能しないと気付くかもしれま
せん。コマンド名では省略形が一意であっても、すべての関数名を含めたら一意
ではないかもしれないからです。

   ‘C-h f <RET>’を入力すると、バッファーのポイントがある位置の、一番内側
のLisp式で呼び出されている関数の名前が有効で、Lisp関数として定義されてい
れば、その関数の説明が表示されます(引数を入力するときデフォルトとして関
数名が表示されます)。たとえばポイントが‘(make-vector (car x)’の後ろにあ
るとき、ポイントを含む一番内側のリストは‘(make-vector’で始まっているので
、‘C-h f <RET>’により関数‘make-vector’の説明が表示されます。

   ‘C-h f’は、関数名を正しく記述しているか確かめたいときも便利です。‘C-h
f’のミニバッファーのプロンプトで、編集中のバッファーの関数名がデフォルト
として表示されるなら、それは定義されたLisp関数であることを意味します。本
当にドキュメントを見たい訳でなければ、‘C-g’を押してコマンド‘C-h f’をキャ
ンセルできます。

   ‘C-h v’ (‘describe-variable’)は、‘C-h f’と似ていますがLisp関数ではな
く、Lisp関数の説明を表示します。ポイントの周囲または前にあるLispシンボル
が、定義されたLisp変数名のときはそれがデフォルトとなります。*note
Variables::を参照してください。

   通常Emacsの変数または関数を説明するヘルプバッファーには、ソースファイ
ルがインストールされていれば、対応するソースコードへのハイパーリンクが含
まれています(*note Hyperlinking::を参照してください)。

   マニュアルからコマンドのドキュメントを探すには、‘C-h F’
(‘Info-goto-emacs-command-node’)を使います。これはEmacsのマニュアルだけ
でなく、さまざまなマニュアルを認識するので、正しいものを見つけられるでし
ょう。

   ‘C-h o’ (‘describe-symbol’)は、‘C-h f’や‘C-h v’と似ていますが、これは
任意のシンボル(関数、変数、フェイス)を説明します。シンボルが複数の定義を
もつ場合(たとえばシンボルが関数と変数の両方の定義をもつような場合)、この
コマンドはそれらすべてのドキュメントを順に表示します。


File: emacs-ja.info,  Node: Apropos,  Next: Help Mode,  Prev: Name Help,  Up: Help

10.4 Apropos(適切な)
====================

“apropos(折よい、適切な)”コマンドは、“What are the commands for working
with files?(ファイルを処理するコマンドは?)”のような質問に答えるものです
。より正確に言うと単語、単語のリスト、正規表現によって、“aproposパターン
”を指定します。

   以下の各aproposコマンドは、ミニバッファーでaproposパターンを読み取り
、パターンにマッチするアイテムを検索して、結果を別のウィンドウに表示しま
す。

‘C-h a’
     コマンドを検索します(‘apropos-command’)。プレフィクス引数を指定する
     と、非インタラクティブな関数も検索します。

‘M-x apropos’
     関数と変数を検索します。これを使えばインタラクティブな関数(コマンド
     )と非インタラクティブな関数の両方を検索できます。

‘M-x apropos-user-option’
     ユーザーがカスタマイズできる関数を検索します。プレフィクス引数を指
     定すると、カスタマイズできない変数も検索します。

‘M-x apropos-variable’
     変数を検索します。プレフィクス引数を指定すると、カスタマイズできる
     変数だけを検索します。

‘M-x apropos-local-variable’
     バッファーローカル変数を検索します。

‘M-x apropos-value’
     指定したパターンにマッチする値の変数を検索します。プレフィクス引数
     を指定すると、定義がパターンにマッチする関数と、プロパティーリスト
     がパターンにマッチする、Lispシンボルも検索します。

‘M-x apropos-local-value’
     値が指定されたパターンにマッチする、バッファーローカル変数を検索し
     ます。

‘C-h d’
     指定されたパターンにマッチするドキュメント文字列の関数、または変数
     を検索します(‘apropos-documentation’)。

   最も簡単な種類のaproposパターンは単語です。その単語が含まれていれば、
パターンにマッチします。ファイルを処理するコマンドを探すには、‘C-h a
file <RET>’と入力します。これは‘copy-file’、‘find-file’などの、名前に
‘file’を含むすべてのコマンドの一覧を表示します。各コマンド名には簡単な説
明と、それを呼び出すためのキーの一覧が一緒に表示されます。この例だと、
‘find-file’は‘C-x C-f’で呼び出せることがわかります。

   aproposバッファーの関数定義、変数、シンボルの属性についてもっと情報が
欲しいときは、‘mouse-1’または‘mouse-2’でクリックするか、そこに移動して
<RET>を押してください。

   2つ以上の単語をaproposパターンに指定したときは、マッチするために少な
くとも名前に2つの単語が含まれていなければなりません。たとえばポイントの
前のテキストをkillするコマンドを探すときは、‘C-h a kill back backward
behind before <RET>’などと試みることができます。これは実際のコマンド名
‘kill-backward’にマッチするでしょう。もし‘kill-text-before’というコマン
ドがあったなら、これも指定した単語を2つ含んでいるのでマッチします。

   より一層フレキシビリティを高めるために、正規表現(*note Regexps::)を指
定できます。aproposパターンに正規表現の特殊文字‘^$*+?.\[’が含まれている
と、それは正規表現として扱われます。

   Emacsコマンド命名の慣習に従うと、aproposパターンとして便利な単語がい
くつかあります。これらを‘C-h a’で使うことにより、命名の慣習の必要性を感
じることができるでしょう。

     char、line、word、sentence、paragraph、region、page、sexp、list、
     defun、rect、buffer、frame、window、face、file、dir、register、
     mode、beginning、end、forward、backward、next、previous、up、down、
     search、goto、kill、delete、mark、insert、yank、fill、indent、
     case、change、set、what、list、find、view、describe、default

   変数‘apropos-do-all’が非‘nil’の場合、ほとんどのaproposコマンドは、プ
レフィクス引数が与えられたかのように振る舞います。例外が1つあります。プ
レフィクス引数なしの‘apropos-variable’は、‘apropos-do-all’の値に関係なく
、常にすべての変数を検索します。

   デフォルトでは、‘apropos-documentation’を除くすべてのaproposコマンド
は、結果をアルファベット順に一覧します。変数‘apropos-sort-by-scores’が非
‘nil’のときは、かわりに結果の関連度を推測して、一番関連度が高いと思われ
るものを最初に表示します。‘apropos-documentation’コマンドは、デフォルト
で結果を関連度順で一覧します。これをアルファベット順にするには、変数
‘apropos-documentation-sort-by-scores’を‘nil’に変更してください。


File: emacs-ja.info,  Node: Help Mode,  Next: Package Keywords,  Prev: Apropos,  Up: Help

10.5 ヘルプモードのコマンド
===========================

ヘルプバッファーはViewモード(*note View Mode::を参照してください)と同じ
コマンドを提供します。たとえば前方へのスクロールは<SPC>、後方へのスクロ
ールは<DEL>か‘S-<SPC>’です。他にも特別なコマンドをいくつか提供します:

‘<RET>’
     ポイント位置のクロスリファレンス先をフォローします(‘help-follow’)。
‘<TAB>’
     ポイントを次のハイパーリンクへ進めます(‘forward-button’)。
‘S-<TAB>’
     ポイントを前のハイパーリンクへ戻します(‘backward-button’)。
‘mouse-1’
‘mouse-2’
     クリックしたハイパーリンク先をフォローします。
‘C-c C-c’
     ポイント位置のシンボルに関する、すべてのドキュメントを表示します
     (‘help-follow-symbol’)。
‘C-c C-f’
‘r’
     次ののヘルプトピックに前方へ移動します(‘help-go-forward’)。
‘C-c C-b’
‘l’
     前のヘルプトピックに戻ります(‘help-go-back’)。

   もし関数名、変数名、フェイス名(*note Faces::を参照してください)がヘル
プバッファーのドキュメントにあると、通常はアンダーラインされた“ハイパー
リンク(hyperlink)”として表示されます。関連するドキュメントを閲覧するには
、ポイントをそこに移動して<RET> (‘help-follow’)とタイプするか、ハイパー
リンクを‘mouse-1’または‘mouse-2’でクリックします。するとヘルプバッファー
の内容が入れ替わりますが、‘C-c C-b’、または‘l’ (‘help-go-back’)で元に戻
すことができます。元に戻る途中では、‘C-c C-f’または‘r’
(‘help-go-forward’)を使用して前に進むことができます。

   ヘルプバッファーには、infoマニュアル、ソースコード定義、URL(ウェブペ
ージ)へのハイパーリンクを含むこともできます。最初の2つはEmacs上で表示さ
れ、3番目のURLはコマンド‘browse-url’により、ウェブブラウザーを使って表示
されます。

   ヘルプバッファーでは、<TAB> (‘forward-button’)はポイントを次のハイパ
ーリンクへ進め、‘S-<TAB>’ (‘backward-button’)は前のハイパーリンクへ戻し
ます。これらのコマンドは循環的です。たとえば最後のハイパーリンクで
<TAB>をタイプすると、最初のハイパーリンクに戻ります。

   テキスト中のシンボルに関するすべてのドキュメントを閲覧するには、ポイ
ントをシンボルに移動して‘C-c C-c’ (‘help-follow-symbol’)とタイプします。
これは変数、関数、および/またはフェイスとしての、そのシンボルが意味する
、すべてのドキュメントを表示します。


File: emacs-ja.info,  Node: Package Keywords,  Next: Language Help,  Prev: Help Mode,  Up: Help

10.6 パッケージのキーワード検索
===============================

Emacsのたいていのオプション機能は、“パッケージ(packages)”にグループ化さ
れています。Emacsには数百のビルトインパッケージが含まれており、ネットワ
ークを通じて他のパッケージのインストールもできます(*note Packages::を参
照してください)。

   あるトピックに関連するパッケージを探すのを簡単にするため、ほとんどの
パッケージは、それが何をするかにもとづき、1つ以上の“キーワード
(keywords)”に関連付けられています。‘C-h p’ (‘finder-by-keyword’)とタイプ
すると、パッケージキーワードとキーワードの意味を説明するリストが表示され
ます。キーワードに属するパッケージのリストを表示するには、そのキーワード
の行で<RET>をタイプします。これによりパッケージメニューバッファー(*note
Package Menu::を参照してください)で、パッケージの一覧が表示されます。

   ‘C-h P’ (‘describe-package’)はパッケージ名(*note Packages::を参照)の
入力を求めて、パッケージの属性と、それが実装する機能をヘルプバッファーで
表示します。このバッファーは、ボタン形式で関連するパッケージのキーワード
を一覧します。ボタン‘mouse-1’か‘mouse-2’をクリックすると、そのキーワード
に関連する他のパッケージを見ることができます。


File: emacs-ja.info,  Node: Language Help,  Next: Misc Help,  Prev: Package Keywords,  Up: Help

10.7 国際化言語のサポートに関するヘルプ
=======================================

特定の言語環境(language environment: *note Language Environments::を参照
してください)の情報を得るには、‘C-h L’とタイプします。これはヘルプバッフ
ァーを開いて、言語環境でサポートされる言語の説明と、関連する文字セット、
コーディングシステム、インプットメソッド、およびその言語環境のサンプルテ
キストを表示します。

   コマンド‘C-h h’ (‘view-hello-file’)は、ファイル‘etc/HELLO’を表示しま
す。このファイルはさまざまな言語で“hello”をどのように言うのかを、いろい
ろな文字セットで表示するデモンストレーションです。

   コマンド‘C-h I’ (‘describe-input-method’)は、指定されたインプットメソ
ッド、または現在使われているインプットメソッド(デフォルト)の説明します。
*note Input Methods::を参照してください。

   コマンド‘C-h C’ (‘describe-coding-system’)は、指定されたコーディング
システム、または現在使われているものを説明します。*note Coding
Systems::を参照してください。


File: emacs-ja.info,  Node: Misc Help,  Next: Help Files,  Prev: Language Help,  Up: Help

10.8 その他のヘルプコマンド
===========================

‘C-h i’ (‘info’)は、infoプログラムを実行します。infoは構造化されたドキュ
メントファイルを閲覧するものです。Emacsマニュアル全体は、GNUシステムのた
めの他のマニュアルとともに、infoで利用可能です。infoを開始した後、‘h’を
タイプすると、infoの使い方のチュートリアルが実行されます。

   数引数Nを指定すると、‘C-h i’はinfoバッファー‘*info*<N>’を選択します。
これは同時に複数のinfoマニュアルを閲覧するとき便利です。プレフィクス引数
‘C-u’だけを指定した場合、‘C-h i’はドキュメントのファイル名を尋ねるので、
infoメニューのトップレベルにエントリーがないファイルでも閲覧できます。

   上記で説明しているヘルプコマンド‘C-h F FUNCTION <RET>’と‘C-h K KEY’は
、infoを実行して関数(FUNCTION)またはキー(KEY)に関するドキュメントを直接
開きます。

   プログラムを編集しているとき、そのプログラム言語のinfo版のマニュアル
を持っていれば、‘C-h S’ (‘info-lookup-symbol’)を使ってシンボル(キーワー
ド、関数、変数)のエントリーを、適切なマニュアルから探すことができます。
コマンドがどのように動作するかの詳細は、メジャーモードに依存します。

   何か予期しないことが起こって、何をタイプしたかわからなくなったときは
、‘C-h l’ (‘view-lossage’)を使います。‘C-h l’は最近の300回分のキーストロ
ークと、それらが呼び出したコマンドを表示します。馴染みのないコマンドを見
つけたら、‘C-h k’や‘C-h f’を使用して、それらのコマンドが何を行なうか調べ
ることができます。

   最近のエコーエリアのメッセージを調べるには、‘C-h e’
(‘view-echo-area-messages’)を使います。これはそれらのメッセージを保持す
るバッファー、‘*Messages*’を表示します。

   Emacsの各メジャーモードでは、一般的にいくつかのキーが再定義されていて
、編集動作も異なります。‘C-h m’ (‘describe-mode’)は、現在のメジャーモー
ドのドキュメントを表示します。これには通常このモードで変更されているコマ
ンドや機能、およびそれらのキーバインドについても説明されています。

   ‘C-h b’ (‘describe-bindings’)と‘C-h s’ (‘describe-syntax’)は、現在の
Emacs環境に関する、それ以外の情報を表示します。最初は現在のマイナーモー
ドのローカルバインディング、次に現在のメジャーモードで定義されているロー
カルバインディング、最後にグローバルバインディングが表示されます。‘C-h
s’は各文字の構文の説明とともに、構文テーブルの内容を表示します(*note
Syntax Tables: (elisp)Syntax Tables.を参照してください)。

   プレフィクスキーの後に‘C-h’、‘?’、<F1>をタイプすることにより、特定の
プレフィクスキーにたいする、サブコマンドのリストを得ることができます(こ
の方法が機能しないプレフィクスキーもあります。たとえば<ESC>です。‘<ESC>
C-h’は実際には‘C-M-h’と解釈され、これはdefunをマークするコマンドです。こ
のような場合でも‘<ESC> <F1>’や‘<ESC> ?’はうまく機能します)。


File: emacs-ja.info,  Node: Help Files,  Next: Help Echo,  Prev: Misc Help,  Up: Help

10.9 ヘルプファイル
===================

ビルトインのドキュメントとマニュアル以外にも、Emacsにはコピー条件
(copying conditions)、リリースノート(release notes)、デバッグ説明書
(instructions for debugging)、バグ報告(reporting bugs)などのトピックを説
明する、いくつかのファイルが含まれています。これらのファイルは、以下のコ
マンドで閲覧することができます。‘C-h g’をのぞき、これらはすべて、‘C-h
C-CHAR’という形式になっています。

‘C-h C-c’
     Emacsをコピー、再頒布する場合の規則を表示します
     (‘describe-copying’)。
‘C-h C-d’
     Emacsをデバッグするためのヘルプを表示します
     (‘view-emacs-debugging’)。
‘C-h C-e’
     外部のパッケージをどこで入手するかについての情報を表示します
     (‘view-external-packages’)。
‘C-h C-f’
     EmacsのFAQ(frequently-answered-questions: 頻繁に答えられる質問)のリ
     ストを表示します(‘view-emacs-FAQ’)。
‘C-h g’
     GNUプロジェクトに関する情報がある、ページ (http://www.gnu.org)を
     visitします(‘describe-gnu-project’)。
‘C-h C-m’
     Emacsマニュアルの印刷されたコピーの注文に関する情報を表示します
     (‘view-order-manuals’)。
‘C-h C-n’
     このバージョンの新しい機能の一覧が含まれるnewsファイルを表示します
     (‘view-emacs-news’)。
‘C-h C-o’
     Emacsおよび他のGNUソフトウェアーの最新バージョンを、注文またはダウ
     ンロードする方法を表示します(‘describe-distribution’)。
‘C-h C-p’
     Emacsの既知の問題(それにどう対処するかの提案がある場合もあります)を
     表示します(‘view-emacs-problems’)。
‘C-h C-t’
     EmacsのTODOリストを表示します(‘view-emacs-todo’)。
‘C-h C-w’
     GNU Emacsが完全に無保証なことにたいする、すべての詳細を表示します
     (‘describe-no-warranty’)。


File: emacs-ja.info,  Node: Help Echo,  Prev: Help Files,  Up: Help

10.10 アクティブテキストのヘルプとツールチップ
==============================================

Emacsでは拡大解釈される“アクティブテキスト”(active text: マウスのクリッ
クや<RET>に特別な反応をするテキスト)は、しばしばヘルプテキストに関連付け
られています。これにはEmacsのバッファーのハイパーリンク、同様にモードラ
インの一部が含まれます。グラフィカルなディスプレー、同様にいくつかのテキ
スト端末は、マウストラッキングをサポートしており、アクティブテキストの上
をマウスが通過することにより、ヘルプテキストを“ツールチップ(tooltip)”で
表示します。*note Tooltips::を参照してください。

   マウストラッキングをサポートしない端末では、バッファーのアクティブテ
キストにポイントを移動して、‘C-h .’ (‘display-local-help’)をタイプすれば
、ヘルプテキストを表示できます。これはヘルプテキストをエコーエリアに表示
します。ポイントがある場所のヘルプテキストが利用可能な場合に、常に表示さ
せるには、変数‘help-at-pt-display-when-idle’に‘t’をセットしてください。


File: emacs-ja.info,  Node: Mark,  Next: Killing,  Prev: Help,  Up: Top

11 マークとリージョン
*********************

Emacsのコマンドには、現在のバッファー内の、任意の連続する領域(region)を
操作するものがたくさんあります。そのようなコマンドが操作するテキストを指
定するには、領域の一方の端に“マーク(mark)”をセットし、もう一方の端にポイ
ントを移動します。ポイントとマークの間のテキストを、“リージョン
(region)”と呼びます。リージョンは常にポイントとマークの間で拡張され、そ
れは一方がテキストの先頭にある場合も変わりません。ポイントを移動すれば、
常にリージョンは変化します。

   テキストのある位置にマークをセットすると、マークは“アクティブ
(active)”になります。マークがアクティブのときは、リージョンもアクティブ
になります。Emacsはアクティブなリージョンの中にあるテキストを、フェイス
‘region’でハイライト表示します(*note Face Customization::を参照してくだ
さい)。

   バッファーのテキストを変更するコマンドを含む、特定の非移動系コマンド
(non-motion commands)の後で、Emacsは自動的にマークを“非アクティブ
(deactivates)”にし、これによりハイライトも解除されます。‘C-g’をタイプす
れば、いつでも明示的に非アクティブにすることができます(*note Quitting::を
参照してください)。

   上記のデフォルト動作は、Transient Markモード(暫定マークモード)という
名で知られています。Transient Markモードを無効にすると、Emacsは通常では
リージョンをハイライトしなくなります。*note Disabled Transient Mark::を
参照してください。

   あるバッファーでマークをセットしても、他のバッファーのマークは影響を
受けません。アクティブなマークがあるバッファーに戻ったとき、マークは以前
と同じ場所にあります。複数のウィンドウで同じバッファーを表示しているとき
、これらのウィンドウはそれぞれのポイント位置をもっているので、リージョン
も異なります。しかしこれらのウィンドウでは、マークの位置は共通です。
*note Windows::を参照してください。通常、選択されたウィンドウのリージョ
ンだけがハイライトされます。しかし変数‘highlight-nonselected-windows’が
非‘nil’の場合、各ウィンドウのリージョンがハイライトされます。

   rectangular region(矩形リージョン)という、違う種類のリージョンもあり
ます。*note Rectangles::を参照してください。

* Menu:

* Setting Mark::             マークをセットするコマンド。
* Marking Objects::          テキスト単位の周辺にリージョンをセットするコマンド。
* Using Region::             リージョンの内容を操作する方法の要約。
* Mark Ring::                後で戻れるように保存された以前のマーク位置。
* Global Mark Ring::         さまざまなバッファーの以前のマーク位置。
* Shift Selection::          シフトを押してカーソル移動キーを使う。
* Disabled Transient Mark::  デフォルトでリージョンをハイライトせずにおく。


File: emacs-ja.info,  Node: Setting Mark,  Next: Marking Objects,  Up: Mark

11.1 マークのセット
===================

マークをセットするためのコマンドがいくつかあります:

‘C-<SPC>’
     ポイント位置にマークをセットしてアクティブにします
     (‘set-mark-command’)。
‘C-@’
     同じです。
‘C-x C-x’
     ポイント位置にマークをセットしてアクティブにしてから、以前のマーク
     があった位置にポイントを移動します(‘exchange-point-and-mark’)。
‘Drag-mouse-1’
     ドラッグしたテキストの周りにポイントとマークをセットします。
‘mouse-3’
     ポイント位置にマークをセットしてから、クリックした場所にポイントを
     移動します(‘mouse-save-then-kill’)。
‘‘シフトを押したカーソル移動キー’’
     マークが非アクティブなら、ポイント位置にマークをセットしてポイント
     を移動します。*note Shift Selection::を参照してください。

   マークをセットするもっとも一般的な方法は、‘C-<SPC>’
(‘set-mark-command’)です(1)。これはポイントがある位置にマークをセットし
てから、アクティブにします。その後、マークをそこに残したままポイントを移
動できます。

   たとえばバッファーの一部を大文字に変換したいとします。これを行うには
対象のテキストの一方の端に移動して、‘C-<SPC>’をタイプし、対象のテキスト
がハイライトされるまでポイントを移動します。そして‘C-x C-u’
(‘upcase-region’)をタイプすると、リージョンのテキストが大文字に変換され
て、マークが非アクティブになります。

   マークがアクティブなときに非アクティブにしたいときは、‘C-g’をタイプし
ます(*note Quitting::を参照してください)。リージョンにたいして操作を行う
ほとんどのコマンドは、上記の例の‘C-x C-u’のように、自動的にマークを非ア
クティブにします。

   リージョンにたいしての操作は行わず、バッファーの位置を覚えておくため
にマークをセット(‘C-<SPC> C-<SPC>’とタイプ)して、後でそこに戻る(‘C-u
C-<SPC>’とタイプ)こともできます。詳細については、*note Mark Ring::を参照
してください。

   コマンド‘C-x C-x’ (‘exchange-point-and-mark’)は、ポイントとマークの位
置を交換します。ポイントの位置に問題はないが、リージョンのもう一方の端に
ポイントを移動したいとき‘C-x C-x’は便利です。2回目の‘C-x C-x’で、マーク
を新しいポイント位置にマークをセットしてから、ポイントを元の位置に戻すこ
とができます。このコマンドはマークが非アクティブのとき、最初にマークをア
クティブにします。これはマークが最後にどこにセットされたかを明確にするた
めに、リージョンをハイライトするためです。しかしプレフィクス引数とともに
呼び出せば、マークは非アクティブのままでリージョンもハイライトされません
。これを使えば‘C-u C-<SPC>’と同様の方法で、マークの位置にジャンプできま
す。

   マウスでマークをセットすることもできます。マウスの左ボタン
(‘down-mouse-1’)をクリックしてから、テキスト範囲をドラッグすると、最初に
マウスボタンを押した位置にマークがセットされ、マウスボタンを話した位置に
ポイントが置かれます。かわりにマウスの右ボタン(‘mouse-3’)をクリックすれ
ば、ポイントのある位置にマークがセットされ、クリックした位置にポイントが
移動します。これらのマウスコマンドに関する詳細な説明は、*note Mouse
Commands::を参照してください。

   最後にシフトキーを押しながらカーソルを移動するコマンド(‘S-<RIGHT>’、
‘S-C-f’、‘S-C-n’など)でマークをセットできます。これは“シフト選択
(shift-selection)”と呼ばれ、以前にシフト選択やマウスコマンドでセットされ
たアクティブなマークがないときに限り、ポイントを移動する前の位置にマーク
をセットします。マウスコマンドやシフト選択によるマークのセットは、通常の
マークとは少し異なります。続けてシフトを押さないカーソル移動コマンドを実
行するにより、マークは自動的に非アクティブになります。詳細は、*note
Shift Selection::を参照してください。

   ‘C-y’ (‘yank’)のようなテキストを挿入するコマンドの多くは、挿入された
テキストの先頭に、非アクティブなマークをセットします。これにより簡単にそ
の位置に戻ることができます(*note Mark Ring::を参照してください)。コマン
ドがこれを行っていることは、エコーエリアに‘Mark set’が表示されることで見
分けることができます。

   Xではアクティブなリージョンが変化するたびに、Emacsはリージョンのテキ
ストを“プライマリー選択(primary selection)”に保存します。これにより
‘mouse-2’をクリックして、他のXアプリケーションへテキストを挿入することが
できるようになります。*note Primary Selection::を参照してください。

   ---------- Footnotes ----------

   (1) ASCIIには、文字‘C-<SPC>’はありません。テキスト端末で‘C-<SPC>’をタ
イプすると、通常は文字‘C-@’が与えられます。このキーも
‘set-mark-command’にバインドされているので、もし異なる挙動を示すテキスト
端末の場合は、‘C-<SPC>’のかわりに‘C-@’を使うことを考えるのがよいかもしれ
ません。


File: emacs-ja.info,  Node: Marking Objects,  Next: Using Region,  Prev: Setting Mark,  Up: Mark

11.2 テキストオブジェクトをマークするコマンド
=============================================

単語(word)、リスト(list)、パラグラフ(paragraph: 段落)、ページ(page)など
のテキストオブジェクトの周辺に、ポイントを配置してマークするコマンドがあ
ります:

‘M-@’
     次の単語の末尾にマークをセットします(‘mark-word’)。ポイントは移動し
     ません。
‘C-M-@’
     次の対応のとれた式の後にマークをセットします(‘mark-sexp’)。ポイント
     は移動しません。
‘M-h’
     ポイントを現在のパラグラフの先頭に移動して、パラグラフの最後にマー
     クをセットします(‘mark-paragraph’)。
‘C-M-h’
     ポイントを現在のdefunの先頭に移動して、defunの最後にマークをセット
     します(‘mark-defun’)。
‘C-x C-p’
     ポイントを現在のページの先頭に移動して、ページの最後にマークをセッ
     トします(‘mark-page’)。
‘C-x h’
     ポイントを現在のバッファーの先頭に移動して、バッファーの最後にマー
     クをセットします(‘mark-whole-buffer’)。

   ‘M-@’ (‘mark-word’)は、次の単語の最後にマークをセットします(単語につ
いての情報は、*note Words::を参照してください)。繰り返し呼び出されると、
マークを1度に1単語進めてリージョンを拡張します。例外として、マークがアク
ティブでポイントの前にある場合、‘M-@’はマークを現在の位置から1単語後方に
移動します。

   このコマンドに数引数Nを指定することにより、N単語進めてマークするよう
指定できます。負の引数はN単語後方にマークを移動します。

   同様に‘C-M-@’ (‘mark-sexp’)は、対応のとれた式の最後にマークをセットし
ます(*note Expressions::を参照してください)。繰り返し呼び出すことにより
、後続の式にリージョンを拡張します。正または負の数引数を指定するとその数
に応じて前方または後方にマークを移動します。

   上記のリストの他のコマンドは、ポイントとマークの両方をセットするので
、バッファー内のオブジェクトを区切るコマンドです。‘M-h’
(‘mark-paragraph’)はパラグラフ(*note Paragraphs::を参照してください)、
‘C-M-h’ (‘mark-defun’)はトップレベルの関数定義(*note Moving by Defuns::を
参照してください)、‘C-x C-p’ (‘mark-page’)はページ(*note Pages::を参照し
てください)をマークします。繰り返して呼び出すと、同種の連続するオブジェ
クトへと、リージョンを拡張します。数引数も同様で、マークを移動したいオブ
ジェクトの数を指定します。

   ‘C-x h’ (‘mark-whole-buffer’)はポイントをバッファーの先頭、マークを最
後にセットすることによりバッファー全体をリージョンとします。


File: emacs-ja.info,  Node: Using Region,  Next: Mark Ring,  Prev: Marking Objects,  Up: Mark

11.3 リージョンを操作する
=========================

一度リージョンを設定すると、それを処理するいくつかの方法があります:

   • ‘C-w’ (*note Killing::)でkillします。
   • ‘M-w’ でkillリングにコピーします(*note Yanking::を参照してください
     )。
   • ‘C-x C-l’または‘C-x C-u’で、大文字小文字を変換します(*note Case::を
     参照してください)。
   • ‘C-u C-/’で変更をアンドゥ(undo)します(*note Undo::を参照してくださ
     い)。
   • ‘M-%’でリージョンの中のテキストを置換します(*note Query Replace::を
     参照してください)。
   • ‘C-x <TAB>’または‘C-M-\’でインデントします(*note Indentation::を参
     照してください)。
   • ‘M-x fill-region’でテキストとしてフィルします(*note Filling::を参照
     してください)。
   • ‘M-$’で単語のスペルをチェックします(*note Spelling::を参照してくだ
     さい)。
   • ‘M-x eval-region’でLispコードとして評価します(*note Lisp Eval::を参
     照してください)。
   • ‘C-x r s’でレジスターに保存します(*note Registers::を参照してくださ
     い)。
   • バッファーまたはファイルに保存します(*note Accumulating Text::を参
     照してください)。

   マークが非アクティブのときにはデフォルトの動作をするが、マークがアク
ティブのときはリージョンを処理するコマンドがいくつかあります。たとえば
‘M-$’ (‘ispell-word’)は、通常はポイントのある単語のスペルをチェックしま
すが、マークがアクティブのときはリージョンの中のテキストをチェックします
(*note Spelling::を参照してください)。通常そのようなコマンドはリージョン
が空のとき(たとえばマークとポイントが同じ位置のとき)は、デフォルトの動作
をします。空のリージョンにたいして処理を行いたいときは、変数
‘use-empty-active-region’を‘t’に変更してください。

   *note Erasing::で説明したように、<DEL> (‘backward-delete-char’)と
<Delete> (‘delete-forward-char’)もこの方法で動作します。マークがアクティ
ブのときはリージョンのテキストを削除します(例外として数引数Nに1以外が指
定されたとき、これらのコマンドはマークがアクティブか関係なく、N文字を削
除します)。変数‘delete-active-region’を‘nil’に変更すると、これらのコマン
ドはマークがアクティブのとき異なる動作をしなくなります。これを‘kill’に変
更するとリージョンを削除するかわりに、“kill”するようになります(*note
Killing::を参照してください)。

   その他のコマンドにはデフォルトの動作はなく、常にリージョンを処理しま
す。通常このようなコマンドには、‘C-w’ (‘kill-region’)や‘C-x C-u’
(‘upcase-region’)のように、名前に‘region’がついています。マークが非アク
ティブのときは“非アクティブなリージョン”、すなわちポイントと最後にマーク
をセットした位置の間にあるテキストにたいして処理を行います(*note Mark
Ring::を参照してください)。この動作を無効にするには、変数
‘mark-even-if-inactive’を‘nil’に変更してください。そうするとこれらのコマ
ンドはマークが非アクティブのときエラーをシグナルします。

   デフォルトでは、マークがアクティブでもテキストの挿入は普通に行われま
す。たとえば‘a’をタイプすると、‘a’が挿入されてからマークが非アクティブに
なります。マイナーモードのDelete Selectionモードは、この振る舞いを変更し
ます。Delete Selectionモードが有効な場合、マークがアクティブなときは、最
初にリージョンのテキストを削除してから、テキストが挿入されます。Delete
Selectionモードをオフにするには、‘M-x delete-selection-mode’とタイプして
ください。


File: emacs-ja.info,  Node: Mark Ring,  Next: Global Mark Ring,  Prev: Using Region,  Up: Mark

11.4 マークリング
=================

各バッファーは、“マークリング(mark ring)”の中に、以前のマークの位置を記
録しています。マークをセットするコマンドは、古いマークをこのリングに
pushします。マークリングの1つの使い方として、後で戻りたい場所を記録させ
る使い方があります。

‘C-<SPC> C-<SPC>’
     マークをアクティブにせずにマークをセットしてから、マークリングに
     pushします。
‘C-u C-<SPC>’
     マークがあった場所にポイントを移動し、マークリングから1つ前のマーク
     を復元します。

   コマンド‘C-<SPC> C-<SPC>’は、後で戻ってきたい位置をマークするときに便
利です。これは現在の位置をマークを(Emacsがリージョンをハイライト表示して
しまう)アクティブにすることなく、マークリングにpushします。実際にこれは
‘C-<SPC>’ (‘set-mark-command’)を連続して2回呼び出しています。最初の
‘C-<SPC>’はマークをセットし、2回目の‘C-<SPC>’はそれを非アクティブにして
います(Transient Markモードがオフの場合、‘C-<SPC> C-<SPC>’は一時的に
Transient Markモードを有効にします。*note Disabled Transient Mark::を参
照してください)。

   マークした位置に戻るには、‘C-u C-<SPC>’のようにプレフィクス引数を指定
して、‘set-mark-command’を使います。これはマークがあった場所にポイントを
移動して、もしマークがアクティブのときは非アクティブにします。‘C-u
C-<SPC>’を連続して呼び出すと、マークリングに保存された前の位置へジャンプ
していきます。この方法で移動した位置の情報は失われません。それらはリング
の最後に移動します。

   ‘set-mark-command-repeat-pop’を非‘nil’にセットすると、‘C-u C-<SPC>’の
後に続けて、‘C-u C-<SPC>’ではなく、‘C-<SPC>’でマークリングを巡回できます
。デフォルトでは‘set-mark-command-repeat-pop’は‘nil’です。

   各バッファーは自身のマークリングを持ちます。すべての編集コマンドは現
在のバッファーのマークリングを使います。特に‘C-u C-<SPC>’は常に同じバッ
ファーに留まります。

   変数‘mark-ring-max’は、マークリングに保持する最大のエントリー数を指定
します。デフォルトは16エントリーです。もしエントリー数が最大の場合、他の
エントリーをpushするとリストの一番古いものが捨てられます。‘C-u C-<SPC>’を
繰り返すと、リングの現在位置を巡回します。

   もし何度も同じ場所に戻りたいときは、マークリングでは不十分でしょう。
そのような場合は後で使うために、その位置をレジスターに記録できます(*note
Position Registers::を参照してください)。


File: emacs-ja.info,  Node: Global Mark Ring,  Next: Shift Selection,  Prev: Mark Ring,  Up: Mark

11.5 グローバルマークリング
===========================

各バッファーに属する普通のマークリングに加えて、Emacsには“グローバルマー
クリング(global mark ring)”が1つあります。以前マークをセットしてからバッ
ファーを切り替えた場合、マークをセットすると、マークはカレントバッファー
のマークリングに加えて、グローバルマークリングにも記録されます。その結果
、グローバルマークリングには訪れていたバッファーの系列が記録され、各バッ
ファーではマークを設定した箇所が記録されます。グローバルマークリングの長
さは、‘global-mark-ring-max’で制御され、デフォルトは16です。

   コマンド‘C-x C-<SPC>’ (‘pop-global-mark’)は、グローバルリングの最新の
バッファー位置にジャンプします。これもリングを巡回するので、連続して‘C-x
C-<SPC>’を使うことにより、古いバッファーのマーク位置に移動します。


File: emacs-ja.info,  Node: Shift Selection,  Next: Disabled Transient Mark,  Prev: Global Mark Ring,  Up: Mark

11.6 シフト選択
===============

シフトキーを押しながらカーソル移動コマンドをタイプすると、ポイントを移動
する前の位置にマークをセットするので、リージョンが元のポイント位置から新
しいポイント位置に拡張されます。この機能は“シフト選択
(shift-selection)”と呼ばれます。これは他のエディターでテキストを選択する
方法と似ています。

   シフト選択によるマークのセットは、これまでの説明とは少し異なる振る舞
いをします。最初に、マークを非アクティブにする通常の方法(バッファーのテ
キストを変更したり‘C-g’をタイプするなど)に加え、_シフトキーを押さない
(unshifted)_カーソル移動コマンドでも、マークが非アクティブになります。次
に、連続する_シフトキーを押した(shifted)_カーソル移動コマンドでは、マー
クの更新はされません。つまりシフトキーを押しながらカーソル移動コマンドを
繰り返すと、リージョンは継続的に変更されます。

   シフト選択は、シフトキーを押したカーソル移動キーが、別のコマンドにバ
インドされていない場合のみ動作します(*note Customization::を参照してくだ
さい)。たとえば‘S-C-f’を他のコマンドにバインドしていると、‘S-C-f’はシフ
ト選択バージョンの‘C-f’ (‘forward-char’)ではなく、バインドされたコマンド
を実行します。

   マウスコマンドによるマークのセットも、シフト選択によるマークのセット
と同様です(*note Setting Mark::を参照してください)。たとえばマウスをドラ
ッグしてリージョンを指定すると、シフトキーを押したカーソル移動コマンドを
使って、そのリージョンの拡張を続けることができます。どちらのケースも、シ
フトキーを押さないカーソル移動コマンドで、マークが非アクティブになります
。

   シフト選択をオフにするには、‘shift-select-mode’を‘nil’にセットしてく
ださい。これをセットしても、マウスコマンドによるマークのセッティングは無
効になりません。


File: emacs-ja.info,  Node: Disabled Transient Mark,  Prev: Shift Selection,  Up: Mark

11.7 Transient Markモードを無効にする
=====================================

マークとリージョンのデフォルト動作では、マークをアクティブにセットすると
、リージョンがハイライトされます。これはTransient Markモードと呼ばれます
。これはデフォルトで有効になっているマイナーモードです。‘M-x
transient-mark-mode’、または‘Options’メニューの‘Active Region
Highlighting’で切り替えることができます。オフにすることによりEmacsの操作
モードは変更されます。

   • ‘C-<SPC>’や‘C-x C-x’のようなコマンドでマークをセットしても、リージ
     ョンはハイライトされません。そのためマークがどこにあるか見分けるこ
     とができないので、覚えている必要があります。

     マークをセットしたらどこにセットしたか忘れる前にすぐ使うというのが
     、この問題にたいする通常の解決策です。ポイントとマークの位置を交換
     する‘C-x C-x’で、マークがどこかチェックすることもできます。

   • 通常マークがアクティブのときリージョンにたいして処理を行ういくつか
     のコマンドは、そのような振る舞いをしなくなります。たとえば普通‘M-%’
     (‘query-replace’)は、マークがアクティブのときはリージョンにたいして
     置換を行います。Transient Markがオフだと、常にポイントからバッファ
     ーの最後までを処理します。このような方法で動作するコマンドは、コマ
     ンド自身のドキュメントにより識別できます。

   Transient Markモードがオフのときは、‘C-<SPC> C-<SPC>’または‘C-u C-x
C-x’を使って一時的にアクティブにすることができます。

‘C-<SPC> C-<SPC>’
     ポイント位置にマークをセット(普通の‘C-<SPC>’と同様)して、マークが非
     アクティブになるまでの間、1度だけTransient Markモードを有効にします
     (実際にはこれは独立したコマンドではなく‘C-<SPC>’コマンドを2回行って
     います)。

‘C-u C-x C-x’
     ポイントとマークを交換してからマークをアクティブにして、次にマーク
     が非アクティブになるまでの間、Transient Markモードを一時的に有効に
     します(これはプレフィクス引数を指定した‘C-x C-x’
     (‘exchange-point-and-mark’)コマンドです)。

   これらのコマンドはマークをセットまたはアクティブにして、マークが非ア
クティブになるまでの間Transient Markモードを有効にします。これらを使う
1つの理由は、いくつかのコマンドはTransient Markモードがオフのとき、リー
ジョンにたいしてではなくバッファー全体を処理するからです。Transient
Markモードを一時的に有効にできれば、これらのコマンドをリージョンにたいし
て処理させることができます。

   リージョンをマウス(*note Setting Mark::を参照してください)、またはシ
フト選択(*note Shift Selection::を参照してください)で指定したときも、一
時的にTransient Markモードが有効になり、リージョンがハイライトされます。


File: emacs-ja.info,  Node: Killing,  Next: Registers,  Prev: Mark,  Up: Top

12 テキストのkillと移動
***********************

Emacsで“kill”とはテキストを消去して、“killリング”にコピーすることを意味
します。“yank”とは、killリングからテキストを取り出して、バッファーに戻す
ことを意味します(“cut(カット、切り取り)”と“paste(ペースト、貼り付け)”と
いう用語を使うアプリケーションもあります)。これはテキストブロックのセッ
トが、循環的にアクセスできるリングに格納されているイメージから、killリン
グと名付けられました。*note Kill Ring::を参照してください。

   killとyankは、Emacsでテキストを移動したりコピーするための、もっとも一
般的な方法です。これは用途が広いコマンドです。なぜなら、多くの異なる種類
の構文単位をkillするためのコマンドが存在するからです。

* Menu:

* Deletion and Killing::     テキストを削除するコマンド。
* Yanking::                  テキストを挿入するコマンド。
* Cut and Paste::            グラフィカルなディスプレーにおけるクリップボードと選択。
* Accumulating Text::        バッファーにテキストを追加する他の方法。
* Rectangles::               矩形領域のテキストの操作。
* CUA Bindings::             killとyankで‘C-x’/‘C-c’/‘C-v’を使う。


File: emacs-ja.info,  Node: Deletion and Killing,  Next: Yanking,  Up: Killing

12.1 削除とkill
===============

バッファーからテキストを消去するコマンドの多くは、それをkillリング(*note
Kill Ring::を参照)に保存します。これらは“kill”コマンドとして知られており
、通常名前に‘kill’が含まれます(例 ‘kill-line’)。killリングには、最近
killしたものが、1つだけではなくいくつか格納されているので、killはとても
安全な操作と言えます。なぜなら、以前にkillしたテキストが失われる心配をす
る必要がないからです。killリングは、すべてのバッファーで共有されているの
で、あるバッファーでkillしたテキストを、別のバッファーにyankすることがで
きます。

   ‘C-/’ (‘undo’)を使うと、killコマンドはアンドゥ(*note Undo::を参照して
ください)されるので、killしたテキストはバッファーに戻されますが、killリ
ングからは削除されません。

   グラフィカルなディスプレーでは、テキストをkillすると、それはシステム
のクリップボードにもコピーされます。 *note Cut and Paste::を参照してくだ
さい。

   テキストを消去してkillリングに保存しないコマンドは、“削除(delete)”コ
マンドとして知られており、名前に‘delete’が含まれています。これらは‘C-d’
(‘delete-char’)や<DEL> (‘delete-backward-char’)のように、一度に1文字削除
するものや、スペースや改行だけを削除するものが含まれます。重要なデータの
有意な量を消去するコマンドには、一般的にkill操作が用いられます。

   killとyankでマウスを使うこともできます。*note Cut and Paste::を参照し
てください。

* Menu:

* Deletion::                 少量のテキストや空の領域を削除するコマンド。
* Killing by Lines::         テキスト行を一度にkillする方法。
* Other Kill Commands::      大きなリージョン、および単語やセンテンスのような構文単位をkillするコマンド。
* Kill Options::             killに影響を与えるオプション。


File: emacs-ja.info,  Node: Deletion,  Next: Killing by Lines,  Up: Deletion and Killing

12.1.1 削除
-----------

削除とは、テキストを消去してkillリングに保存しないという意味です。テキス
トを削除するたいていのEmacsコマンドは、1文字または空白文字しか消去しませ
ん。

‘<DEL>’
‘<BACKSPACE>’
     前の文字を削除します。リージョンがアクティブのときは、リージョンの
     テキストを削除します(‘delete-backward-char’)。

‘<Delete>’
     次の文字を削除します。リージョンがアクティブのときは、リージョンの
     テキストを削除します(‘delete-forward-char’)。

‘C-d’
     次の文字を削除します(‘delete-char’)。

‘M-\’
     ポイントの周囲のスペースとタブを削除します
     (‘delete-horizontal-space’)。
‘M-<SPC>’
     スペースを1つ残して、ポイントの周囲のスペースとタブを削除します
     (‘just-one-space’)。
‘C-x C-o’
     現在行の周囲の空行を削除します(‘delete-blank-lines’)。
‘M-^’
     行間にある改行をインデントと共に削除して2行を1行にします
     (‘delete-indentation’)。

   基本的な削除コマンド<DEL> (‘delete-backward-char’)、<delete>
(‘delete-forward-char’)、‘C-d’ (‘delete-char’)については既に説明しました
。*note Erasing::を参照してください。数引数を指定すると、指定した数の文
字を削除します。リージョンがアクティブのとき、数引数に1を指定するか省略
した場合、<DEL>と<delete>は、リージョンのすべてのテキストを削除します。

   他の削除コマンドは、空白文字(スペース、タブ、改行)だけを削除するもの
です。‘M-\’ (‘delete-horizontal-space’)は、ポイントの前後にあるすべての
スペースとタブを削除します。プレフィクス引数を指定すると、ポイントの前に
あるスペースとタブだけを削除します。‘M-<SPC>’ (‘just-one-space’)も同様で
すが、前にスペースが何個あるかに関係なく、ポイントの前に1つのスペースを
残します。数引数Nを指定すると、Nが正のときはポイントの前に、N個のスペー
スを残します。Nが負の場合は、スペースとタブに加えて改行も削除し、ポイン
トの前に-N個のスペースを残します。コマンド‘cycle-spacing’は、
‘just-one-space’のようなコマンドで、よりフレキシブルな動作をします。これ
は連続で呼び出すと異なる処理を行います。1番目の呼び出しでは
‘just-one-space’と同様の処理をし、2番目の呼び出しではすべての空白文字を
削除し、3番目の呼び出しでは元の空白文字を復元します。

   ‘C-x C-o’ (‘delete-blank-lines’)は、現在行の下にあるすべての空行を削
除します。現在行が空行のときは、現在行の上にあるすべての空行も削除します
(空行を1つ、つまり現在行は残します)。単独の空行で実行するとその行を削除
します。

   ‘M-^’ (‘delete-indentation’)は、改行と周囲のスペース(通常1つのスペー
スを残す)を削除することにより、現在行とその上の行を結合します。*note
M-^: Indentation.を参照してください。

   コマンド‘delete-duplicate-lines’は、リージョン内の重複した行を検索し
て、それぞれ1行を残して削除します。通常は重複した行の最初の行を残します
が、プレフィクス引数‘C-u’を指定すると、最後の行を残します。プレフィクス
引数‘C-u C-u’を指定すると、隣接した重複行だけを検索します。これは行がソ
ート済みのとき効果的です。プレフィクス引数‘C-u C-u C-u’を指定すると、連
続する空行は残します。


File: emacs-ja.info,  Node: Killing by Lines,  Next: Other Kill Commands,  Prev: Deletion,  Up: Deletion and Killing

12.1.2 行のkill
---------------

‘C-k’
     行の残り、または1行以上をkillします(‘kill-line’)。
‘C-S-backspace’
     1度に行全体を削除します(‘kill-whole-line’)。

   もっとも簡単なkillコマンドは、‘C-k’ (‘kill-line’)です。これを行末で使
うと、その行を終端している改行をkillして、現在行と次の行を継げます(空行
なら削除します)。そうでない場合、‘C-k’はポイントから行末までを削除します
。ポイントの元の位置が行頭の場合は、空行が残ります。

   どちらのケースを適用するか決める際には、行末のスペースとタブは無視さ
れます。ポイントが行の一番最後の非空白文字の後にあるとき、‘C-k’は改行を
killすることに注意してください。空でない行全体をkillするときは、行頭で
‘C-k’を2回タイプしてください。

   このコンテキストで“行”とは、スクリーン行ではなく論理行を意味します
(*note Continuation Lines::を参照してください)。

   ‘C-k’に正の数値Nを与えると、N行とそれに続く改行をkillします(現在行の
ポイントの前にあるテキストはkillされません)。負の引数−Nを与えると、現在
行のポイントの前にあるテキストと、前のN行をkillします。‘C-k’に0を指定す
ると、現在行のポイントの前にあるテキストをkillします。

   変数‘kill-whole-line’が非‘nil’のときは、行頭での‘C-k’により行末の改行
も含めて行全体がkillされます。この変数は通常‘nil’です。

   ‘C-S-backspace’ (‘kill-whole-line’)は行中のポイントの位置に関わらず、
改行を含めた行全体をkillします。キーシーケンス‘C-S-backspace’をタイプで
きないテキスト端末がたくさんあることに注意してください。


File: emacs-ja.info,  Node: Other Kill Commands,  Next: Kill Options,  Prev: Killing by Lines,  Up: Deletion and Killing

12.1.3 その他のkillコマンド
---------------------------

‘C-w’
     リージョンをkillします(‘kill-region’)。
‘M-w’
     リージョンをkillリングにコピーします(‘kill-ring-save’)。
‘M-d’
     次の単語をkillします(‘kill-word’)。*note Words::を参照してください
     。
‘M-<DEL>’
     後方に1単語killします(‘backward-kill-word’)。
‘C-x <DEL>’
     センテンスの先頭までを後方にkillします(‘backward-kill-sentence’)。
     *note Sentences::を参照してください。
‘M-k’
     文の末尾までをkillします(‘kill-sentence’)。
‘C-M-k’
     後に続く対応のとれた式(balanced expressions)をkillします
     (‘kill-sexp’)。*note Expressions::を参照してください。
‘M-z CHAR’
     次のCHARまでをkillします(‘zap-to-char’)。

   一般によく使われるkillコマンドは‘C-w’ (‘kill-region’)で、これはリージ
ョンのテキストをkillします(*note Mark::を参照してください)。同様に‘M-w’
(‘kill-ring-save’)は、バッファーからテキストを消去せずに、リージョンのテ
キストをkillリングにコピーします。‘C-w’または‘M-w’をタイプしたとき、マー
クが非アクティブの場合、これらのコマンドはポイントと最後にセットしたマー
クの間にあるテキストにたいして処理を行います(*note Using Region::を参照
してください)。

   Emacsは特定の構文単位にたいするkillコマンドを提供します。単語
(words)にたいしては‘M-<DEL>’と‘M-d’(*note Words::を参照してください)、対
応のとれた式(balanced expressions)にたいしては‘C-M-k’(*note
Expressions::を参照してください)、センテンス(sentences: 文)にたいしては
‘C-x <DEL>’‘M-k’(*note Sentences::を参照してください)です。

   コマンド‘M-z’ (‘zap-to-char’)は、killと検索が組み合わされています。こ
れは文字を読み取り、ポイントからバッファー内の次にその文字が現れる場所ま
でをkillします。数引数は繰り返し回数です。負の引数の場合は後方に検索する
ことを意味し、ポイントの前のテキストをkillします。


File: emacs-ja.info,  Node: Kill Options,  Prev: Other Kill Commands,  Up: Deletion and Killing

12.1.4 killのオプション
-----------------------

いくつかの特別なバッファーは、“読み取り専用(read-only)のテキスト”を含ん
でいて、それらは変更できないのでkillもできません。killコマンドは読み取り
専用のバッファーにたいして特別な動作をします。バッファーから実際にテキス
トを削除せずに、killリングにコピーします。通常はビープ音をならし、その旨
のエラーメッセージを表示します。しかし変数‘kill-read-only-ok’を非‘nil’に
セットすると、なぜテキストが消去されないのかをエコーエリアにメッセージ表
示します。

   変数‘kill-do-not-save-duplicates’を非‘nil’に変更すると、同じものにた
いするkillは重複なくkillリングの1つのエントリーとなります。


File: emacs-ja.info,  Node: Yanking,  Next: Cut and Paste,  Prev: Deletion and Killing,  Up: Killing

12.2 yank
=========

“yank”するとは、以前killしたテキストを再び挿入するという意味です。テキス
トを移動またはコピーする通常の方法は、それをkillしてからどこかにyankする
方法です。

‘C-y’
     最後にkillしたものをポイント位置にyankします(‘yank’)。
‘M-y’
     yankしたテキストを、それより前にkillしたテキストに置き換えます
     (‘yank-pop’)。*note Earlier Kills::を参照してください。
‘C-M-w’
     次のコマンドがkillコマンドのときは、killしたものを、以前にkillした
     ものに追加します(‘append-next-kill’)。*note Appending Kills::を参照
     してください。

   基本的なyankコマンドは、‘C-y’ (‘yank’)です。これはもっとも最近killさ
れたものを挿入し、カーソルを挿入されたテキストの最後に移動します。また挿
入されたテキストの先頭にマークをセットして、それを非アクティブにします。
これにより‘C-u C-<SPC>’で簡単にその位置にジャンプできます(*note Mark
Ring::を参照してください)。

   ‘C-u C-y’のようにプレフィクス引数を指定すると、カーソルを挿入されたテ
キストの前に移動して、マークをテキストの最後にセットします。他のプレフィ
クス引数は、何回前のkillかを指定します。たとえば‘C-u 4 C-y’は、もっとも
最近killされたものから4番目に古いものを挿入します。

   グラフィカルなディスプレーでは、‘C-y’はまず最後にEmacsがkillした後に
、他のアプリケーションがシステムのクリップボードに、何らかのテキストをコ
ピーしていないか調べます。もしコピーしていたなら、かわりにクリップボード
のテキストを挿入します。このようにEmacsは効果的に“カット(cut)”や“コピー
(copy)”などの、他のアプリケーションで処理されたクリップボード操作を、
Emacsのkillのように扱います(ただしkillリングには記録されません)。詳細に
ついては、*note Cut and Paste::を参照してください。

* Menu:

* Kill Ring::                killされたテキストが格納される場所。
* Earlier Kills::            もっと前にkillしたものをyankする。
* Appending Kills::          数回のkillを一緒にまとめてyankする。


File: emacs-ja.info,  Node: Kill Ring,  Next: Earlier Kills,  Up: Yanking

12.2.1 killリング
-----------------

“killリング(kill ring)”とは、以前にkillされたテキストブロックからなるリ
ストです。すべてのバッファーにたいして、killリングは1つしかないので、あ
るバッファーでkillしたテキストを、他のバッファーにyankすることができます
。これはバッファーから他のバッファーへテキストを移動する、通常の方法です
(他の方法もいくつかあります。たとえばテキストをレジスターに格納すること
もできます。*note Registers::を参照してください。テキストを移動する他の
方法については、*note Accumulating Text::を参照してください)。

   killリングのエントリーの最大数は、変数‘kill-ring-max’で制御されます。
デフォルトは60です。エントリー数が制限に達しているとき新たにkillすると、
Emacsはkillリングの一番古いエントリーを削除して空きを作ります。

   killリングの実際の内容は、‘kill-ring’という名前の変数に格納されていま
す。killリングのエントリーの内容は、‘C-h v kill-ring’で見ることができま
す。


File: emacs-ja.info,  Node: Earlier Kills,  Next: Appending Kills,  Prev: Kill Ring,  Up: Yanking

12.2.2 過去にkillしたテキストをyankする
---------------------------------------

*note Yanking::で説明したように、‘C-y’に数引数を指定して、最後にkillされ
たものではないテキストをyankできます。これはkillリングのどのエントリーが
欲しいか覚えているとき便利です。もし覚えていないときは、‘M-y’
(‘yank-pop’)コマンドを使って、候補を探すことができます。

   もし前のコマンドがyankコマンドのとき、‘M-y’はyankされたテキストを、
1つ前にkillされたテキストで置き換えます。つまり2番目に新しいkillされたテ
キストを復元するには、最初に‘C-y’で最後にkillされたテキストをyankし、次
に‘M-y’でその1回前にkillされたテキストで置き換えます。‘M-y’は、‘C-y’また
は他の‘M-y’の後しか使えません。

   killリングのエントリーを指す(ポイントする)、last yankポインターという
概念で、‘M-y’を理解できるでしょう。なにかをkillする度に、last yankポイン
ターはリングの先頭に新たに作られたエントリーを指すように移動します。
‘C-y’は、last yankポインターが指すエントリーをyankします。‘M-y’はlast
yankポインターが違うエントリーを指すように移動して、バッファーのテキスト
をポインターが指すテキストに変更します。‘M-y’コマンドを繰り返すことによ
り、リングの任意のエントリーにポインターを移動できるので、任意のエントリ
ーをバッファーに取り込むことができます。やがてリングの最後に到達すると、
次の‘M-y’により再び最初のエントリーに戻ります。

   ‘M-y’はリング内でlast yankポインターを移動させますが、リング内のエン
トリーの順番は変更しません。リングのエントリーは、常に最後にkillされたも
のを先頭に、記憶されているもので一番古いエントリーへと並んでいます。

   last-yankポインターを何回進めるかを、‘M-y’に数引数で指定できます。負
の引数はリングの先頭に向かってポインターを移動させます。リングの先頭では
一番古いエントリーに戻り、そこから先頭へと移動します。

   望むテキストを見つけてバッファーに取り込んだら、‘M-y’コマンドを止めれ
ばそのテキストはそこに残ります。このテキストはkillリングのエントリーの単
なるコピーなので、それを編集してもリングの中のエントリーは変更されません
。新しく何かをkillしない限り、last-yankポインターは同じ位置に留まるので
、‘C-y’でそのテキストの別のコピーをyankできます。

   ‘C-y’に数引数を指定するときも、yankするエントリーにlast-yankポインタ
ーをセットします。


File: emacs-ja.info,  Node: Appending Kills,  Prev: Earlier Kills,  Up: Yanking

12.2.3 killしたテキストの追加
-----------------------------

通常はkillコマンドを実行するごとに、新しいエントリーがkillリングにpushさ
れます。しかし2回以上の連続するkillコマンドにより、killされたテキストを
1つのエントリーとしてまとめ、すべてのテキストを1単位として、あたかもそれ
がkillされたかのように、1回の‘C-y’でyankできます。

   つまりテキストを1つの単位としてyankしたいとき、そのテキストすべてを
1回でkillする必要はありません。すべてがkillされるまで行から行、単語から
単語へとkillを続け、それを一度に取得することができます。

   ポイントから前方にkillするコマンドは、直前にkillされたテキストの最後
に追加します。ポイントから後方にkillするコマンドは、テキストの先頭に追加
します。この方法により前方と後方を併用した連続するkillコマンドは、すべて
のkillされたテキストを再配置しなくてもよいように、1つのエントリーにまと
めます。数引数を指定してもkillの連続性は途切れません。たとえば以下のよう
なテキストを含むバッファーがあるとしましょう:

     This is a line ★of sample text.

ポイントの位置は★で示された場所です。‘M-d M-<DEL> M-d M-<DEL>’とタイプし
て、前方と後方へのkillを交互に行うと、最後にkillリングには‘a line of
sample’という1つのエントリー、バッファーには‘This is  text.’が残ります
(‘is’と‘text’の間には2つのスペースがあることに注意してください。これは
‘M-<SPC>’または‘M-q’で取り除くことができます)。

   同じテキストをkillする別の方法は、‘M-b M-b’で単語2つ後方に移動してか
ら、‘C-u M-d’で前方の単語4つをkillする方法です。これはバッファーとkillリ
ングに、正確に同じ結果をもたらします。‘M-f M-f C-u M-<DEL>’で後方に
killしても結果は同じです。killリングのエントリーは、常にバッファーから
killされる前と同じ順番になります。

   killコマンドと最後のキルコマンドの間に、(単なる数引数ではない)他のコ
マンドが入ると、killリングには新たなエントリーが作られます。しかし、あら
かじめ‘C-M-w’ (‘append-next-kill’)とタイプすることにより、最後にkillされ
たテキストに追加するように強制できます。‘C-M-w’は、後に続くコマンドが
killコマンドであれば、killしたテキストを前にkillしたテキストに付け加える
よう指示します。この方法でも、前方にkillするコマンドの場合は、前にkillさ
れたテキストの最後に追加され、後方にkillするコマンドの場合は、先頭に追加
されます。この方法により、1ヶ所にyankするために離れた場所にあるいくつか
のテキスト断片を、killして集めることができます。

   ‘M-w’ (‘kill-ring-save’)の後のkillコマンドは、‘M-w’でkillリングにコピ
ーされたテキストへの追加はしません。


File: emacs-ja.info,  Node: Cut and Paste,  Next: Accumulating Text,  Prev: Yanking,  Up: Killing

12.3 グラフィカルなディスプレーでのカットアンドペースト
=======================================================

ほとんどのグラフィカルなデスクトップ環境では、異なるアプリケーション間の
データ転送(通常はテキスト)に、“クリップボード(clipboard)”と呼ばれるシス
テム機能を使います。Xでは他にプライマリー選択(primary selection)とセカン
ダリー選択(secondary selection)という、同様の機能が利用可能です。Emacsを
グラフィカルなディスプレーで実行している場合、killとyankコマンドはこれら
の機能に統合されているので、Emacsと他のグラフィカルアプリケーション間で
、簡単にテキストを転送できます。

   デフォルトでは、Emacsはプログラム間テキスト転送のコーディングシステム
として、UTF-8を使います。もしコピーしたテキストが期待したものでない場合
、‘C-x <RET> x’または‘C-x <RET> X’とタイプして、他のコーディングシステム
を指定できます。‘x-select-request-type’をカスタマイズして、異なるデータ
タイプを要求することもできます。*note Communication Coding::を参照してく
ださい。

* Menu:

* Clipboard::                Emacsがシステムクリップボードを使う方法。
* Primary Selection::        一時的に選択されたテキストの選択。
* Secondary Selection::      ポイントとマークを変化させずに切り取る。


File: emacs-ja.info,  Node: Clipboard,  Next: Primary Selection,  Up: Cut and Paste

12.3.1 クリップボードを使う
---------------------------

“クリップボード(clipboard)”とは、ほとんどのグラフィカルなアプリケーショ
ンが、“カットアンドペースト”のために使う機能です。もしクリップボードが存
在する場合、Emacsのkillおよびyankコマンドもそれを使います。

   何らかのテキストを、‘C-w’ (‘kill-region’)のようなコマンドでkillしたり
、‘M-w’ (‘kill-ring-save’)のようなコマンドでkillリングにコピーしたとき、
そのテキストはクリップボードにも転送されます。

   Emacsのkillコマンドがテキストをクリップボードに転送すると、通常クリッ
プボードの既存の内容は失われます。オプションとして、
‘save-interprogram-paste-before-kill’を‘t’に変更できます。これにより、
Emacsは古いクリップボードのデータが失われることを防ぐために、最初にクリ
ップボードのデータをkillリングに保存します。これにはデータが大きくなると
、メモリー消費が増えるというリスクがあります。

   ‘C-y’ (‘yank’)のようなyankコマンドもクリップボードを使います。他のア
プリケーションがクリップボードを“所有”する場合(たとえばEmacsで最後に
killコマンドを実行した後に、他のアプリケーションでテキストをカットまたは
コピーした場合)、Emacsはkillリングではなくクリップボードからyankします。

   通常killリングを‘M-y’ (‘yank-pop’)で巡回することでは、クリップボード
は変更されません。しかし‘yank-pop-change-selection’を‘t’に変更すると、
‘M-y’は新しいyankをクリップボードに保存します。

   killおよびyankコマンドがクリップボードにアクセスしないようにするには
、変数‘select-enable-clipboard’を‘nil’に変更してください。

   多くのXデスクトップ環境は、“クリップボードマネージャー(clipboard
manager)”と呼ばれる機能をサポートします。もしEmacsがクリップボードのデー
タの現在の“持ち主”のときにEmacsを終了し、そのときクリップボードマネージ
ャーが実行されていると、Emacsはクリップボードのデータをクリップボードマ
ネージャーに転送するのでデータは失われません。ある状況において、これは
Emacsが終了するが遅くなる原因となります。Emacsがクリップボードマネージャ
ーにデータを転送しないようにするには、変数
‘x-select-enable-clipboard-manager’を‘nil’に変更してください。

   通常、クリップボードを通じて渡されるNULバイトを含む文字列は切り詰めら
れるため、Emacsはシステムのクリップボードに転送する前に、そのような文字
を“\\0”に置き換えます。

   Emacs 24以前は、killおよびyankコマンドは、クリップボードではなくプラ
イマリー選択(*note Primary Selection::を参照してください)を使っていまし
た。もしこのほうがよいなら、‘select-enable-clipboard’を‘nil’、
‘select-enable-primary’を‘t’、‘mouse-drag-copy-region’を‘t’に変更してく
ださい。この場合は、次のコマンドを使って、クリップボードに明示的にアクセ
スできます。リージョンをkillしてクリップボードに保存するには
‘clipboard-kill-region’、リージョンをkillリングにコピーするとともにクリ
ップボードに保存するには‘clipboard-kill-ring-save’、クリップボードの内容
をポイント位置にyankするには‘clipboard-yank’です。


File: emacs-ja.info,  Node: Primary Selection,  Next: Secondary Selection,  Prev: Clipboard,  Up: Cut and Paste

12.3.2 他のウィンドウアプリケーションにたいするカットアンドペースト
-------------------------------------------------------------------

Xウィンドウシステム下では、“プライマリー選択(primary selection)”に、Xア
プリケーションで最後に選択されたテキスト(通常はマウスのドラッグで選択さ
れる)が存在します。一般的に、このテキストは他のXアプリケーションに
‘mouse-2’をクリックして挿入することができます。プライマリー選択はクリッ
プボードとは別のものです。プライマリー選択の内容は、より脆弱です。なぜな
ら、クリップボードは明示的なカットまたはコピーだけにより上書きされるのに
くらべ、プライマリー選択はマウスでテキストが選択される度に上書きされるか
らです。

   Xの下では、リージョンがアクティブ(*note Mark::を参照してください)にな
ればいつでも、リージョンのテキストはプライマリー選択に保存されます。これ
は、そのリージョンの選択がマウスでドラッグやクリック(*note Mouse
Commands::を参照してください)されたのか、キーボードコマンド(たとえば
‘C-<SPC>’をタイプしてからポイントを移動したなど。*note Setting Mark::を
参照してください)なのかによらず適用されます。

   変数‘select-active-regions’を‘only’に変更すると、Emacsは一時的にアク
ティブになったリージョン(たとえばマウスやシフト選択など。*note Shift
Selection::を参照してください)だけをプライマリー選択に保存します。
‘select-active-regions’を‘nil’に変更すると、Emacsはアクティブなリージョ
ンをプライマリー選択に保存しません。

   プライマリー選択をEmacsのバッファーに挿入するには、挿入したい場所で
‘mouse-2’ (‘mouse-yank-primary’)をクリックします。*note Mouse
Commands::を参照してください。

   MS-Windowsはプライマリー選択を提供しませんが、Emacsは単一のEmacsセッ
ション内で選択されたテキストを内部に格納することにより、これをエミュレー
トします。したがってWindowsでも、プライマリー選択に関するすべての機能と
コマンドは、Xと同様に機能します。しかしこれは同一セッションにおけるカッ
トやペーストなどの場合で、Emacsセッションと他のアプリケーション間では機
能しません。


File: emacs-ja.info,  Node: Secondary Selection,  Prev: Primary Selection,  Up: Cut and Paste

12.3.3 セカンダリー選択
-----------------------

プライマリー選択に加えて、Xウィンドウシステムは“セカンダリー選択
(secondary selection)”として知られる、同様な第2の機能を提供します。最近
ではセカンダリー選択を使うXアプリケーションの数は多くありませんが、以下
のEmacsコマンドによりアクセスできます:

‘M-Drag-mouse-1’
     ボタンを押した場所からボタンを話した場所までを、セカンダリー選択と
     してセットします(‘mouse-set-secondary’)。ドラッグして選択されたテキ
     ストは、フェイス‘secondary-selection’を使ってハイライトされます。ウ
     ィンドウの上端または下端を越えてマウスをドラッグすると、
     ‘mouse-set-region’と同様にウィンドウは自動的にスクロールします
     (*note Mouse Commands::を参照してください)。

     このコマンドはkillリングを変更しません。

‘M-mouse-1’
     “セカンダリー選択”の始点をセットします(‘mouse-start-secondary’)。

‘M-mouse-3’
     ‘M-mouse-1’で指定された位置から、クリックされた点を終点とするセカン
     ダリー選択をセットします(‘mouse-secondary-save-then-kill’)。これは
     選択されたテキストをkillリングにも保存します。同じ場所での2回目の
     ‘M-mouse-3’は、作成されたセカンダリー選択をkillします。

‘M-mouse-2’
     クリックした場所にセカンダリー選択を挿入し、ポイントをyankしたテキ
     ストの最後に配します(‘mouse-yank-secondary’)。

   ‘Mouse-1’と同様、‘M-mouse-1’のダブルクリックで単語、トリプルクリック
で行を処理します。

   ‘mouse-yank-at-point’が非‘nil’の場合、‘M-mouse-2’はポイント位置に
yankします。どこをクリックしたか、さらにはフレームのどのウィンドウをクリ
ックしたかは関係ありません。*note Mouse Commands::を参照してください。


File: emacs-ja.info,  Node: Accumulating Text,  Next: Rectangles,  Prev: Cut and Paste,  Up: Killing

12.4 テキストの追加
===================

テキストのコピーや移動は、それをkillしてyankすることにより通常行います。
しかし多くの箇所にあるテキストブロックをコピーしたり、たくさんのテキスト
の断片を1ヶ所にコピーする便利な方法があります。ここではテキストの断片を
、バッファーやファイルに追加するコマンドを説明します。

‘M-x append-to-buffer’
     リージョンを指定したバッファーの内容の後に追加(append)します。
‘M-x prepend-to-buffer’
     リージョンを指定したバッファーの内容の前に追加(prepend)します。
‘M-x copy-to-buffer’
     リージョンを指定したバッファーにコピーして、バッファーの古い内容は
     削除されます。
‘M-x insert-buffer’
     指定したバッファーの内容を、現在のバッファーのポイント位置に挿入し
     ます。
‘M-x append-to-file’
     リージョンを指定したファイルの内容の最後に追加します。

   テキストをバッファーに追加するには、‘M-x append-to-buffer’を使います
。これはバッファー名を読み取り、リージョンのコピーを指定したバッファーに
挿入します。存在しないバッファーを指定すると、‘append-to-buffer’はそのバ
ッファーを作成します。テキストは、そのバッファーのポイント位置に挿入され
ます。バッファーを編集用に使っていると、コピーされたテキストはその時ポイ
ントがあった位置に挿入されます。

   バッファーのポイントは、コピーされたテキストの最後に残ります。連続し
て‘append-to-buffer’を使うと、テキストは指定したバッファーにコピーした順
番で追加されていきます。厳密に言うと‘append-to-buffer’は既存のバッファー
のテキストにたいして、常に追加をする訳ではありません。これはポイントがバ
ッファーの最後にあるときに追加をします。しかしバッファーを変更するのに
‘append-to-buffer’しか使わない場合、ポイントは常にバッファーの最後に位置
することになります。

   ‘M-x prepend-to-buffer’も‘append-to-buffer’と同様ですが、他のバッファ
ーのポイントはコピーされたテキストの前に置かれるので、連続してこのコマン
ドを使用すると、テキストは逆の順番に追加されます。‘M-x copy-to-buffer’も
同様ですが、他のバッファーの既存の内容は削除されるので、バッファーの内容
は新しくコピーされたテキストだけになります。

   コマンド‘M-x insert-buffer’は、追加するテキストを他のバッファーから取
得するために使われます。これはバッファー名の入力を求め、そのバッファーの
すべてのテキストのコピーを、現在のバッファーのポイント位置に挿入します。
ポイントは挿入されたテキストの先頭になります。挿入されたテキストの最後の
位置もマークリングに追加されます。マークは非アクティブになります。バッフ
ァーに関する背景情報は、*note Buffers::を参照してください。

   バッファーのテキストを追加するかわりに、‘M-x append-to-file’でテキス
トを直接ファイルに追加できます。これはファイル名の入力を求め、リージョン
のテキストを指定されたファイルの最後に追加します。ディスク上のファイルは
すぐに変更されます。

   ‘append-to-file’は、Emacsがvisitして_いない_ファイルだけに使うべきで
す。Emacsで編集中のファイルにたいして使用すると、それはEmacsの背後でファ
イルが変更されることになるため、編集内容が失われる可能性があります。

   テキストの移動に関する他の方法はレジスターに格納する方法です。*note
Registers::を参照してください。


File: emacs-ja.info,  Node: Rectangles,  Next: CUA Bindings,  Prev: Accumulating Text,  Up: Killing

12.5 矩形領域(Rectangles)
=========================

“矩形領域(rectangle)”コマンドは、テキストの矩形領域を操作します。矩形領
域のテキストとは、特定の行範囲内にある、特定の2つの列の間にある文字すべ
ての文字です。Emacsには矩形領域にたいしてkill、yank、クリアー、スペース
やテキストでフィル、削除を行うコマンドがあります。矩形領域コマンドは、複
数列のテキストを操作したり、テキストをそのように変更したり戻したりする場
合に便利です。

   コマンドで操作する矩形領域を指定するには、一方の角にマークを設定し、
その対角にポイントを置きます。このように設定した矩形領域を矩形リージョン
(region-rectangle)と呼びます。ポイントとマークが同じ列の場合、矩形リージ
ョンは空になります。ポイントとマークが同じ行の場合、矩形リージョンの高さ
は1行になります。

   矩形リージョンは、リージョンの制御と大体同じ方法で制御できます。しか
し、ポイントとマークの組がリージョンとして解釈されるのか、あるいは矩形領
域として解釈されるかは、それらを使うコマンドに依存することに注意してくだ
さい。

‘C-x r k’
     矩形リージョンをkillして、最後にkillされた矩形領域として、その内容
     を保存します(‘kill-rectangle’)。
‘C-x r M-w’
     矩形リージョンのテキストを、最後にkillされた矩形領域として保存しま
     す(‘copy-rectangle-as-kill’)。
‘C-x r d’
     矩形リージョンのテキストを削除します(‘delete-rectangle’)。
‘C-x r y’
     最後にkillされた矩形領域の左上隅がポイント位置になるようにyankしま
     す(‘yank-rectangle’)。
‘C-x r o’
     矩形領域にスペースを挿入します(‘open-rectangle’)。これにより矩形リ
     ージョンの以前の内容は右にずれます。
‘C-x r N’
     矩形リージョンの左端に行番号を挿入します
     (‘rectangle-number-lines’)。これにより矩形リージョンの以前の内容は
     右にずれます。
‘C-x r c’
     矩形リージョンの内容をスペースに置き換えてクリアーします
     (‘clear-rectangle’)。
‘M-x delete-whitespace-rectangle’
     指定された矩形領域の各行で、矩形領域の左端の列から空白文字を削除し
     ます。
‘C-x r t STRING <RET>’
     矩形領域の各行にたいして、内容をSTRINGに置き換えます
     (‘string-rectangle’)。
‘M-x string-insert-rectangle <RET> STRING <RET>’
     矩形領域の各行にたいして、STRINGを挿入します。
‘C-x <SPC>’
     Rectangle Markモードを切り替えます(‘rectangle-mark-mode’)。このモー
     ドがアクティブのとき矩形領域はハイライトされ、拡大・縮小が可能にな
     ります。標準のkillおよびyankコマンドは、それにたいして操作を行いま
     す。

   矩形領域の操作は2種類に分類できます。それは矩形領域を消去または挿入す
るものと、空の矩形領域を作るものです。

   矩形領域のテキストを消去するには2つの方法があります。‘C-x r d’
(‘delete-rectangle’)はテキストを無条件に削除します。‘C-x r k’
(‘kill-rectangle’)はテキストを取り除いて、それを“最後にkillされた矩形領
域”として保存します。両方とも矩形領域の各行の指定したテキストを消去する
ように、矩形リージョンを消去します。その行の後に続くテキストがある場合、
削除による隙間を生めるために後方に移動されます。

   矩形領域のkillは普通のkillとは異なります。矩形領域はkillリングには保
存されず、一番最後にkillされた矩形領域だけを記録する、特別な場所に保存さ
れます。矩形領域のyankは線形テキストのyankとは大きく異なるので、異なる
yankコマンドが使われるからです。矩形領域にたいしてyankのpopは定義されて
いません。

   ‘C-x r M-w’ (‘copy-rectangle-as-kill’)は矩形領域用の‘M-w’に相当します
。これはバッファーからテキストを削除することなく、最後にkillされた矩形領
域として、矩形領域を記録します。

   killされた矩形領域をyankするには、‘C-x r y’ (‘yank-rectangle’)とタイ
プします。矩形領域の最初の行はポイント位置に挿入されます。矩形領域の2行
目はポイントの1行下の位置に挿入され、以下同様に挿入されていきます。影響
を受ける行数は、保存された矩形領域の高さにより決定されます。

   たとえば1列のリスト2つを2列のリストに変換できます。一方の1列リストを
矩形領域としてkillしてもう一方の1列リストの隣にyankすればよいのです。

   ‘C-x r r R’と‘C-x r i R’で、矩形領域をレジスターにコピーしたり取り出
したりできます。*note Rectangle Registers::を参照してください。

   空の矩形領域を作るために使うことのできるコマンドが2つあります。‘C-x r
c’ (‘clear-rectangle’)は、矩形リージョンの既存のテキストを空白に置き換え
ます。‘C-x r o’ (‘open-rectangle’)は空白の矩形領域を挿入します。

   ‘M-x delete-whitespace-rectangle’は、指定した列を起点に水平方向の空白
文字を削除します。これは矩形領域の各行に適用され、開始列は矩形領域の左端
です。矩形領域の右端はこのコマンドに影響を及ぼしません。

   コマンド‘C-x r N’ (‘rectangle-number-lines’)は、矩形領域の左端に行番
号を挿入します。通常は矩形領域の最初の行を1として番号が開始されます。プ
レフィクス引数を指定すると、このコマンドは開始番号と、番号を出力する際の
書式文字列(*note (elisp)Formatting Strings::を参照してください)の入力を
求めます。

   コマンド‘C-x r t’ (‘string-rectangle’)は、矩形リージョンの各行を文字
列で置き換えます。文字列の幅は矩形領域と同じ幅である必要はありません。矩
形領域の後ろのテキストは、文字列の幅が少ないときは左に、文字列の幅が大き
いときは右にシフトされます。

   コマンド‘M-x string-insert-rectangle’は、‘string-rectangle’と同様です
が、各行に文字列を挿入し、元の文字列は右にシフトされます。

   コマンド‘C-x <SPC>’ (‘rectangle-mark-mode’)は、矩形リージョンをハイラ
イトするか、標準のリージョンをハイライトするかを切り替えます(最初にリー
ジョンをアクティブにする必要があります)。このモードが有効な場合、‘C-f’、
‘C-n’などのコマンドは矩形領域に合ったやり方でリージョンのサイズを変更し
、kill、yankは矩形領域を処理します。*note Killing::を参照してください。
このモードはリージョンがアクティブな間だけ持続します。

   標準のリージョンとは異なり、バッファー終端を越えたり、TABのような伸長
された空白スペースの中間のような、通常はポイントを置けない場所にも矩形リ
ージョンのコーナーを置くことができます。

   そのリージョンがrectangle-mark-modeにある場合、‘C-x C-x’は、矩形リー
ジョンの4隅のコーナーを巡回する、コマンド
‘rectangle-exchange-point-and-mark’を実行します。これはマークされたテキ
ストにたいする処理を呼び出す前に、矩形リージョンをのサイズを変更したい場
合に便利です。


File: emacs-ja.info,  Node: CUA Bindings,  Prev: Rectangles,  Up: Killing

12.6 CUAバインド
================

コマンド‘M-x cua-mode’は、多くのアプリケーションで使われている、
CUA(Common User Access)互換のキーバンドをセットアップします。

   CUAモードが有効な場合、‘C-x’、‘C-c’、‘C-v’、‘C-z’などのキーは、カット
(kill)、コピー、ペースト(yank)、アンドウのコマンドを呼び出します。
‘C-x’と‘C-c’によるカットとコピーは、リージョンがアクティブなときだけ処理
されます。リージョンが非アクティブのときはプレフィクスキーとして動作する
ので、‘C-x C-c’のような標準のEmacsコマンドは正常に機能します。変数
‘mark-even-if-inactive’は‘C-x’と‘C-c’に影響を及ぼさないことに注意してく
ださい(*note Using Region::を参照してください)。

   マークがアクティブのときに‘C-x C-f’のようなEmacsコマンドを入力するに
は、‘Shift’を押しながらプレフィクスキーを押す(例 ‘S-C-x C-f’)か、プレフ
ィクスキーを素早く2回タイプ(例 ‘C-x C-x C-f’)します。

   CUAモードがEmacs標準のキーバインドをオーバーライドするのを無効にしつ
つ、以下で説明するそれ以外のCUAモードの機能は使う場合は、変数
‘cua-enable-cua-keys’に‘nil’をセットしてください。

   CUA モードはデフォルトでDelete-Selectionモード(*note Mouse
Commands::を参照してください)を有効にするので、アクティブなリージョンが
あるときテキストをタイプすると、そのテキストで置き換えられます。CUAモー
ドでこれを無効にするには、変数‘cua-delete-selection’を‘nil’にセットして
ください。

   CUAモードは矩形領域を明白にハイライトする、強化された矩形領域サポート
を提供します。‘C-<RET>’を使うことにより矩形領域の選択が開始され、移動コ
マンドを使って拡張したり、‘C-x’と‘C-c’で切り取りとコピーができます。
<RET>により、矩形領域の四隅に時計方向へカーソルを移動させるので、任意の
方向に簡単に領域を拡張できます。タイプされた通常のテキストは、矩形領域の
各行の左か右(カーソルのある側)に挿入されます。

   この矩形領域サポートは、‘cua-rectangle-mark-mode’コマンドを呼び出すこ
とにより、CUAモードを有効にせずに使うこともできます。標準コマンド
‘rectangle-mark-mode’もあります。*note Rectangles::を参照してください。

   CUAモードでは、テキストや矩形領域を簡単にレジスターに保存したり、取り
出すことができます。これは1桁の数引数をkill、copy、yankコマンドに指定し
ます。たとえば‘C-1 C-c’はリージョンをレジスター‘1’にコピーし、‘C-2 C-v’は
レジスター‘2’の内容をyankします。

   CUAモードは、バッファー間での簡単にテキストを移動したりコピーするため
のグローバルマーク機能も提供します。‘C-S-<SPC>’を使って、グローバルマー
クのオンとオフが切り替えられます。グローバルマークがオンのときは、killま
たはコピーされたすべてのテキストは自動的にグローバルマークの位置に挿入さ
れ、タイプしたテキストも現在のカーソル位置ではなくグローバルマークに挿入
されます。

   たとえば複数のバッファーから単語をコピーして単語リストを作るには、単
語リストを作るバッファーにグローバルマークをセットします。次にリストにし
たい単語をマーク(‘S-M-f’など)してから、‘C-c’か‘M-w’でリストにコピーしま
す。そして<RET>でリストにコピーされた単語の後ろに改行を挿入すればよいの
です。


File: emacs-ja.info,  Node: Registers,  Next: Display,  Prev: Killing,  Up: Top

13 レジスター
*************

Emacsの“レジスター(registers)”は、テキストや矩形領域、位置、その他、後で
使うものを保存するための区画です。一度テキストや矩形領域をレジスターに保
存すれば、それをバッファーに何度もコピーできます。一度場所をレジスターに
保存すれば、何度でもその場所にジャンプして戻ることができます。

   各レジスターは1文字からなる名前があり、ここではRと表記することにしま
す。Rには、英字(‘a’など)または数字(‘1’など)を使用できます。大文字小文字
は区別されるので、レジスター‘a’とレジスター‘A’は同じではありません。たと
えば‘*’や‘C-d’のような、非英数字にレジスターをセットすることもできます。
‘C-g’と‘ESC’は対話的なコマンドを終了させるために予約済みなので、これらの
キーにレジスターをセットすることはできないことに注意してください。

   レジスターには位置、テキスト、矩形領域、数字、ウィンドウの設定、ファ
イル名が保存できますが、一度に保存できるのは1つです。レジスターに何か保
存すると、他の何かをそのレジスターに保存するまで残ります。レジスターRに
何が含まれているのか見るには。‘M-x view-register’を使います:

‘M-x view-register <RET> R’
     レジスターRに何が含まれるかの説明を表示します。

   レジスター名の入力を求めるコマンドはすべて、既存のレジスターを一覧す
るプレビュー(preview)ウィンドウを遅延表示します。遅延の長さは
‘register-preview-delay’でカスタマイズできます。遅延を無効にするには、
‘nil’をセットしてください。この場合、‘C-h’か<F1>で、明示的にプレビューウ
ィンドウを要求できます。

   “ブックマーク(Bookmarks)”はファイルと位置を記録するので、ファイルを再
び見るときは記録された位置から閲覧できます。ブックマークも本質的にレジス
ター同じなので、このチャプターに記載します。

* Menu:

* Position Registers::       位置をレジスターに保存する。
* Text Registers::           テキストをレジスターに保存する。
* Rectangle Registers::      矩形領域をレジスターに保存する。
* Configuration Registers::  ウィンドウの設定をレジスターに保存する。
* Number Registers::         レジスターの中の数字。
* File Registers::           レジスターの中のファイル名。
* Keyboard Macro Registers::  レジスターの中のキーボードマクロ。
* Bookmarks::                レジスターと似ているが永続性があるブックマーク。


File: emacs-ja.info,  Node: Position Registers,  Next: Text Registers,  Up: Registers

13.1 レジスターに位置を保存する
===============================

‘C-x r <SPC> R’
     現在のバッファーのポイント位置をレジスターRに記録します
     (‘point-to-register’)。
‘C-x r j R’
     レジスターRに記録されたバッファーの位置にジャンプします
     (‘jump-to-register’)。

   ‘C-x r <SPC>’ (‘point-to-register’)と、それに続けて文字‘R’をタイプす
ると、ポイント位置と現在のバッファーの両方をレジスターRも保存します。レ
ジスターは他の何かが保存されるまでこの情報を保持します。

   コマンド‘C-x r j R’は、Rに記録されたバッファーに切り替えて、記録され
た位置にポイントを移動します。レジスターの内容は変わらないので、保存した
位置に何度でもジャンプできます。

   ‘C-x r j’を使って保存した位置に移動するとき、保存されたバッファが
killされていた場合、‘C-x r j’は同じファイルをvisitしてバッファーを生成し
ようと試みます。もちろんこれはファイルをvisitしたバッファーだけの動作で
す。


File: emacs-ja.info,  Node: Text Registers,  Next: Rectangle Registers,  Prev: Position Registers,  Up: Registers

13.2 レジスターにテキストを保存する
===================================

同じテキストのコピーを何回も挿入したいとき、killリングからyankするのは不
便です。なぜなら何かkillするたびに、そのエントリーはリングの下の方へ移動
してしまうからです。代替として、テキストをレジスターに保存して、後で取り
出す方法があります。

‘C-x r s R’
     リージョンをレジスターRにコピーします(‘copy-to-register’)。
‘C-x r i R’
     レジスターRからテキストを挿入します(‘insert-register’)。
‘M-x append-to-register <RET> R’
     リージョンをレジスターRのテキストに追加します。

     レジスターRの内容がテキストの場合、そのレジスターに追加するのに‘C-x
     r +’ (‘increment-register’)も使用できます。レジスターRに数値が含ま
     れている場合、コマンド‘C-x r +’は違う動作をすることに注意してくださ
     い。*note Number Registers::を参照してください。

‘M-x prepend-to-register <RET> R’
     リージョンをレジスターRの先頭に追加します。

   ‘C-x r s R’は、リージョンのテキストのコピーを、Rという名前のレジスタ
ーに保存します。マークが非アクティブのとき、Emacsはまず最後にセットされ
たマークをアクティブにします。マークはこのコマンドの最後に非アクティブに
なります。*note Mark::を参照してください。同じコマンドにプレフィクス引数
を指定した‘C-u C-x r s R’は、テキストのコピーをレジスターRに保存してから
、バッファーのテキストを削除します。これはリージョンのテキストを、レジス
ターに移動したと考えることができます。

   ‘M-x append-to-register <RET> R’は、リージョンのテキストのコピーを、
Rという名前のレジスターにすでに保存されているテキストに追加します。プレ
フィクス引数を指定した場合、レジスターに追加した後にリージョンを削除しま
す。コマンド‘prepend-to-register’も同様ですが、これはリージョンのテキス
トをレジスターのテキストの_最後_ではなく_先頭_に追加します。

   ‘append-to-register’と‘prepend-to-register’を使ってテキストを集める場
合、セパレーターを使って個々に集めたテキストを分割したい場合があります。
そのようなときは‘register-separator’を構成して、セパレーター文字列をその
レジスターに保存します。たとえばテキストを収集する過程で、個々のテキスト
を2つの改行で分けたい場合、以下の設定を使うことができます。

     (setq register-separator ?+)
     (set-register register-separator "\n\n")

   ‘C-x r i R’は、レジスターRのテキストをバッファーに挿入します。通常は
ポイントをテキストの後に置き、非アクティブのマークをテキストの前にセット
します。数引数を指定したときは、ポイントをテキストの前、マークをテキスト
の後にセットします。


File: emacs-ja.info,  Node: Rectangle Registers,  Next: Configuration Registers,  Prev: Text Registers,  Up: Registers

13.3 レジスターに矩形領域を保存する
===================================

レジスターには線形のテキストだけでなく、矩形領域も保存できます。バッファ
ーで矩形領域を指定する方法は、*note Rectangles::を参照してください。

‘C-x r r R’
     矩形リージョンをレジスターRにコピーします
     (‘copy-rectangle-to-register’)。数引数を指定するとコピー後に矩形リ
     ージョンを削除します。
‘C-x r i R’
     レジスターRに矩形リージョンが保存されている場合、それを挿入します
     (‘insert-register’)。

   前に*note Text Registers::でも説明した‘C-x r i R’
(‘insert-register’)コマンドは、レジスターに矩形領域が保存されているとき
はテキストではなく矩形領域を挿入します。


File: emacs-ja.info,  Node: Configuration Registers,  Next: Number Registers,  Prev: Rectangle Registers,  Up: Registers

13.4 レジスターにウィンドウ設定を保存する
=========================================

選択されたフレームのウィンドウの設定や、すべてのフレームのすべてのウィン
ドウの設定もレジスターに保存して、後で設定を復元することができます。ウィ
ンドウの設定については、*note Windows::を参照してください。

‘C-x r w R’
     選択されたフレームのウィンドウの設定を、レジスターRに保存します
     (‘window-configuration-to-register’)。
‘C-x r f R’
     すべてのフレームおよびフレームに含まれるすべてのウィンドウの状態を
     、レジスターRに保存します(‘frameset-to-register’)。

   ‘C-x r j R’を使うと、ウィンドウまたはフレームの設定を復元できます。こ
れはカーソル位置を復元するコマンドと同じです。フレームの設定を復元すると
き、設定に含まれていないフレームは非表示になります。もしこれらのフレーム
を削除したいときは、かわりに‘C-u C-x r j R’を使います。


File: emacs-ja.info,  Node: Number Registers,  Next: File Registers,  Prev: Configuration Registers,  Up: Registers

13.5 レジスターに数字を保存する
===============================

数字をレジスターに保存して、その数字(10進)をバッファーに挿入したり、増加
させるコマンドがあります。これらのコマンドはキーボードマクロで使うと便利
です(*note Keyboard Macros::を参照してください)。

‘C-u NUMBER C-x r n R’
     NUMBERをレジスターRに保存します(‘number-to-register’)。
‘C-u NUMBER C-x r + R’
     Rに数字が保存しているときは、レジスターの数字をNUMBERだけ増加させま
     す。コマンド‘C-x r +’ (‘increment-register’)は、Rにテキストが保存さ
     れているときは異なる動作をすることに注意してください。*note Text
     Registers::を参照してください。
‘C-x r i R’
     レジスターRの数字をバッファーに挿入します。

   ‘C-x r i’は、他のレジスターの内容をバッファーに挿入するコマンドと同じ
です。‘C-x r +’に数字の引数を与えない場合、レジスターの値は1増加します。
‘C-x r n’に数字の引数を与えない場合、レジスターには0が保存されます。


File: emacs-ja.info,  Node: File Registers,  Next: Keyboard Macro Registers,  Prev: Number Registers,  Up: Registers

13.6 レジスターにファイル名を保存する
=====================================

特定の名前のファイルを頻繁にvisitする場合、その名前をレジスターにセット
しておけば、より便利にファイルをvisitすることができます。以下はNAMEとい
うファイルをレジスターRにセットするLispコードです:

     (set-register R '(file . NAME))

たとえば、

     (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))

はレジスター‘z’にファイル名をセットします。

   レジスターRに名前がセットされているファイルをvisitするには、‘C-x r j
R’とタイプします。これはある位置にジャンプしたり、フレームの設定を復元す
るのと同じコマンドです。


File: emacs-ja.info,  Node: Keyboard Macro Registers,  Next: Bookmarks,  Prev: File Registers,  Up: Registers

13.7 キーボードマクロのレジスター
=================================

あるキーボードマクロ(*note Keyboard Macros::を参照してください)を頻繁に
実行する必要がある場合、それをレジスターにセットしたり保存することができ
ればより便利でしょう(*note Save Keyboard Macro::を参照してください)。
‘C-x C-k x R’ (‘kmacro-to-register’)は、最後のキーボードマクロをレジスタ
ーRに保存します。

   レジスターRのキーボードマクロを実行するには、‘C-x r j R’とタイプしま
す(これはある位置にジャンプしたりフレームを復元するのと同じコマンドです
)。


File: emacs-ja.info,  Node: Bookmarks,  Prev: Keyboard Macro Registers,  Up: Registers

13.8 ブックマーク
=================

“ブックマーク(Bookmarks)”とは、ジャンプしたい位置を記録するレジスターの
ようなものです。レジスターとの違いは、長い名前をもつことができ、次の
Emacsセッションに自動的に引き継がれることです。ブックマークの典型的な使
い方は、さまざまなファイルのどこを読んでいたかを記録することです。

‘C-x r m <RET>’
     visitしているファイルのポイント位置に、ブックマークをセットします。

‘C-x r m BOOKMARK <RET>’
     ポイント位置に、BOOKMARKという名前のブックマークをセットします
     (‘bookmark-set’)。

‘C-x r M BOOKMARK <RET>’
     ‘C-x r m’と同様ですが、既存のブックマークを上書きしません。

‘C-x r b BOOKMARK <RET>’
     BOOKMARKという名前のブックマークにジャンプします(‘bookmark-jump’)。

‘C-x r l’
     すべてのブックマークを一覧します(‘list-bookmarks’)。

‘M-x bookmark-save’
     現在のすべてのブックマークの値を、デフォルトのブックマークファイル
     に保存します。

   visitしているファイル内のカレント位置を記録するには、コマンド‘C-x r
m’を使用します。これは、ブックマーク名のデフォルトとしてファイル名を使い
ます。ブックマークが指すファイルをもとにブックマークの名前を付ければ、
‘C-x r b’で任意のファイルを再びvisitして、同時にブックマーク位置に移動す
るという操作を楽に行えます。

   コマンド‘C-x r M’ (‘bookmark-set-no-overwrite’)は‘C-x r m’と同じよう
に機能しますが、指定されたブックマークがすでに存在する場合は、上書きする
かわりにエラーをシグナルします。

   すべてのブックマークのリストを別のバッファーに表示するには、‘C-x r l’
(‘list-bookmarks’)とタイプします。そのバッファーに切り替えて、ブックマー
クの定義の編集やブックマークに注釈をつけることができます。ブックマークバ
ッファーで‘C-h m’とタイプすれば、特別な編集コマンドに関する情報を見るこ
とができます。

   Emacsを終了するとき、もしブックマークの値を変更していたら、Emacsはブ
ックマークを保存します。‘M-x bookmark-save’コマンドで、いつでもブックマ
ークを保存できます。ブックマークは‘~/.emacs.d/bookmarks’というファイルに
保存されます(古いバージョンのEmacsとの互換性を保つため、もし
‘~/.emacs.bmk’というファイルがあればそのファイルに保存します)。ブックマ
ークコマンドは、デフォルトのブックマークファイルを自動的にロードします。
この保存とロードにより、ブックマークの内容を次のEmacsセッションに引き継
ぐことができるのです。

   ‘bookmark-save-flag’に1をセットすると、ブックマークをセットするコマン
ドはブックマークの保存も行ないます。こうすることにより、Emacsがクラッシ
ュしてもブックマークを失わずにすみます。この変数の値が数字の場合、それは
ブックマークを何回変更したら保存するという意味です。この変数に‘nil’をセ
ットすると、Emacsは明示的に‘M-x bookmark-save’を使ったときだけブックマー
クを保存します。

   変数‘bookmark-default-file’には、ブックマークを保存するデフォルトのフ
ァイルを指定します。

   ブックマークの位置は、周囲のコンテキストとともに保存されるので、ファ
イルが少し変更されていても、‘bookmark-jump’は正確な位置を見つけることが
できます。変数‘bookmark-search-size’は、ブックマーク位置のコンテキストの
前後何文字を記録するかを指定します。

   以下はブックマークを処理する追加のコマンドです:

‘M-x bookmark-load <RET> FILENAME <RET>’
     ブックマークのリストを含む、FILENAMEという名前のファイルをロードし
     ます。このコマンドは‘bookmark-write’と同様に、デフォルトのブックマ
     ークファイルに加えて、他のファイルのブックマークを使うことができま
     す。

‘M-x bookmark-write <RET> FILENAME <RET>’
     現在のすべてのブックマークをファイルFILENAMEに保存します。

‘M-x bookmark-delete <RET> BOOKMARK <RET>’
     BOOKMARKという名前のブックマークを削除します。

‘M-x bookmark-insert-location <RET> BOOKMARK <RET>’
     ブックマークBOOKMARKが指すファイル名をバッファーに挿入します。

‘M-x bookmark-insert <RET> BOOKMARK <RET>’
     ブックマークBOOKMARKが指すファイルの_内容_をバッファーに挿入します
     。


File: emacs-ja.info,  Node: Display,  Next: Search,  Prev: Registers,  Up: Top

14 ディスプレーの制御
*********************

ウィンドウに入りきらない大きなバッファーでは、Emacsはその一部しか表示で
きません。このチャプターでは、見たい部分のテキストを指定するコマンドや変
数と、どのようにしてテキストが表示されるかを説明します。

* Menu:

* Scrolling::                ウィンドウのテキストを上下に移動させるコマンド。
* Recentering::              カレント行を中央にするスクロールコマンド。
* Auto Scrolling::           必要なときテキストをスクロールして再表示する。
* Horizontal Scrolling::     ウィンドウの左右にテキストを移動させる。
* Narrowing::                表示を制限してバッファーの一部を編集する。
* View Mode::                読み取り専用バッファーの表示。
* Follow Mode::              Followモードで2つのウィンドウを1つとしてスクロールさせる。
* Faces::                    フェイスを使って表示スタイルを変更する方法。
* Colors::                   フェイスのカラーを指定する。
* Standard Faces::           主要な既定のフェイス。
* Text Scale::               バッファーのテキストサイズの拡大と縮小。
* Font Lock::                フェイスを使って文法をハイライトするマイナーモード。
* Highlight Interactively::  Emacsにハイライトするテキストを指示する。
* Fringes::                  ウィンドウフリンジの有効と無効。
* Displaying Boundaries::    バッファーの先頭と最後を表示する。
* Useless Whitespace::       行末の不要な空白文字の表示。
* Selective Display::        インデントの大きな行を隠す。
* Optional Mode Line::       モードラインの表示機能のオプション。
* Text Display::             テキスト文字が通常表示される方法。
* Cursor Display::           カーソル表示の機能。
* Line Truncation::          複数のスクリーン行で継続表示させずにスクリーン幅に行を切り詰める。
* Visual Line Mode::         単語の折り返しとスクリーン行にもとづく編集。
* Display Custom::           ディスプレーをカスタマイズする変数の情報。


File: emacs-ja.info,  Node: Scrolling,  Next: Recentering,  Up: Display

14.1 スクロール
===============

ウィンドウがバッファーのすべてのテキストを表示するには小さい場合、その一
部だけが表示されます。“スクロール”コマンドは、バッファーで表示される部分
を変更します。

   前方(forward)または上(up)へのスクロールは、ウィンドウに表示される部分
を先に進めます。これはウィンドウに表示されるバッファーのテキストを、上に
移動させるのと同じです。後方(backward)または下(down)へのスクロールは、ウ
ィンドウに表示される部分を前に戻します。これはウィンドウに表示されるバッ
ファーのテキストを下に移動させます。

   Emacsでのupとdownは、ウィンドウでテキストが移動する方向に基づいており
、テキストにたいしてウィンドウが移動する方向では_ありません_。この用語は
現在のscrolling upやscrolling downが広まる前に、Emacsで採用されました。
そのため<PageDown>は、Emacs的には上(up)にスクロールするという、奇妙な結
果となりました。

   ウィンドウに表示されているバッファー部分には、常にポイントが含まれて
います。もしウィンドウの下端か上端を越えてポイントを移動させると、ポイン
トを画面に表示させるために自動的にスクロールが発生します(*note Auto
Scrolling::を参照してください)。以下のコマンドで明示的にスクロールができ
ます:

‘C-v’
‘<PageDown>’
‘<next>’
     ウィンドウのほぼ全画面分、前方にスクロールします
     (‘scroll-up-command’)。
‘M-v’
‘<PageUp>’
‘<prior>’
     後方にスクロールします(‘scroll-down-command’)。

   ‘C-v’ (‘scroll-up-command’)は、ウィンドウ全体の高さに近い量、前方にス
クロールします。これにより下端の2行が上端になるようスクロールして、それ
に続く表示されていなかった行を表示します。ポイントが上端より上になってし
まう場合、ウィンドウの新たな上端の行に移動します。The <PageDown>(または
<next>)は、‘C-v’と同じです。

   ‘M-v’ (‘scroll-down-command’)は、同様の方法で後方にスクロールします。
<PageUp>(または<prior>)は、‘M-v’と同じです。

   スクロールコマンドでオーバーラップして表示される行数は、変数
‘next-screen-context-lines’で制御され、デフォルトは2です。数引数Nを与え
たときは、N行スクロールします。Emacsはポイントを変更しないよう試みるので
、テキストとポイントは一緒に上または下に動きます。‘C-v’に負の引数を与え
ると、‘M-v’のように反対方向へスクロールします。

   デフォルトでは、ウィンドウがバッファーの先頭または最後に到達していて
、これ以上スクロールできない場合、これらのコマンドは(beep音をならしたり
画面をフラッシュして)エラーをシグナルします。変数
‘scroll-error-top-bottom’を‘t’に変更すると、コマンドは可能な限り、つまり
バッファーの先頭の文字または最後の文字にポイントを移動します。ポイントが
すでにそこにあるときは、エラーをシグナルします。

   スクロールしたとき、ポイントが同じスクリーン位置に留まることを好むユ
ーザーもいます。そうすれば同じスクリーンにスクロールして戻ったとき、ポイ
ントが元の位置にあると便利だからです。この動作は変数
‘scroll-preserve-screen-position’を通じて利用可能です。変数の値が‘t’のと
き、スクロールコマンドによりポイントがウィンドウの外にでるような場合、
Emacsはポイントを先頭行または最終行に移動させるのではなく、同じスクリー
ン位置にポイントを調整して、カーソルを維持します。その他の非‘nil’値の場
合、Emacsはスクロールコマンドによりポイントがウィンドウに残っている場合
にも、この方法でポイントを調整します。この変数はこのセクションで説明する
すべてのスクロールコマンド、同様にマウスホイールによるスクロール(*note
Mouse Commands::を参照してください)に影響を与えます。一般的にいうと、こ
の変数は‘scroll-command’プロパティが非‘nil’のコマンドに影響を及ぼします
。*note (elisp)Property Lists::を参照してください。

   ときどき、特に‘C-v’や‘M-v’のようなキーを押したままにすると、キーボー
ドのオートリピートがアクティブになり、要求された高レートのスクロール要求
にEmacsが対応できなくなるときがあります。そのような場合、表示は更新され
ず、かなり長時間の間、Emacsが応答しなくなる可能性があります。変数
‘fast-but-imprecise-scrolling’を非‘nil’値にセットすることにより、この状
況に対処できます。これはスクロールコマンドにフォント表示化(*note Font
Lock::を参照してください)を行なわないように指示します。スクロールされる
テキストは、それらがデフォルトフェイスをもつと仮定されなくなり、フォント
表示化されなくなります。これにより、そのフェイスがすべて同じサイズのフォ
ントを使用していない場合には、(たとえばオートリピートではない)1回のスク
ロールでも、Emacsが誤ったバッファー位置にスクロールするかもしれません。

   コマンド‘M-x scroll-up’および‘M-x scroll-down’は、
‘scroll-up-command’および‘scroll-down-command’と同様に動作しますが、
‘scroll-error-top-bottom’を考慮しません。これらのコマンドは、Emacs 24以
前ではスクロールアップおよびスクロールダウンのためのデフォルトでした。コ
マンド‘M-x scroll-up-line’および‘M-x scroll-down-line’は、現在のウィンド
ウを1行スクロールさせます。もしこれらのコマンドを使う場合は、それにキー
バインドを割り当てたくなるでしょう(*note Init Rebinding::を参照してくだ
さい)。


File: emacs-ja.info,  Node: Recentering,  Next: Auto Scrolling,  Prev: Scrolling,  Up: Display

14.2 センタリング
=================

‘C-l’
     選択されているウィンドウで、現在行が中央になるようスクロールします
     。連続して呼び出すと、次は現在行が上端になり、その次は現在行が下端
     に、という順番で循環します。画面の再描画が行われる可能性があります
     (‘recenter-top-bottom’)。

‘M-x recenter’
     選択されているウィンドウで、現在行が中央になるようにスクロールしま
     す。画面の再描画が行われる可能性があります。

‘C-M-l’
     有用な情報が表示されるよう、発見的な手法でスクロールします
     (‘reposition-window’)。

   ‘C-l’ (‘recenter-top-bottom’)コマンドは、選択されたウィンドウにたいし
て“センタリング(recenters)”をします。これにより現在のスクリーン行がウィ
ンドウの中央、または中央に一番近い行になります。

   (‘C-l C-l’)のように‘C-l’を2回タイプすると、ポイントのある行が上端にな
るようにスクロールします。‘C-l’を3回タイプするとポイントのある行が下端に
なるようにスクロールします。連続して‘C-l’をタイプすることにより、上記の
3つの位置を循環してスクロールできます。

   リスト変数‘recenter-positions’をカスタマイズすることにより、循環する
順序を変更できます。リスト要素にはシンボル‘top’、‘middle’、‘bottom’また
は数値を指定します。数値に整数を指定すると、現在行が指定したスクリーン行
になるようスクロールします。数値に0.0から1.0の浮動小数点数は、ウィンドウ
の上端から現在行までを割合で指定します。デフォルトは‘(middle top
bottom)’で、これは上述した循環順序です。さらに変数‘scroll-margin’を、0以
外の値Nに変更すると、‘C-l’は常にウィンドウの上端または下端からスクリーン
行で、N行を残してスクロールします(*note Auto Scrolling::を参照してくださ
い)。

   ‘C-l’にプレフィクス引数を指定することもできます。‘C-u C-l’のようにプ
レフィクス引数だけを指定すると、単にポイントのある行を中央にします。正の
引数Nは、ポイントのある行がウィンドウの上端からN行目になるようにスクロー
ルします。0を指定すると、ポイントのある行が上端になるようにスクロールし
ます。負の引数-Nは、ポイントのある行がウィンドウの下端からN行目になるよ
うにスクロールします。引数を与えたときは、‘C-l’は画面をクリアーせず、異
なるスクリーン位置への循環もしません。

   変数‘recenter-redisplay’が非‘nil’値の場合、‘C-l’はスクリーンのクリア
ーと再描画を行います。特別な値‘tty’(デフォルト)は、これをテキスト端末上
のフレームだけに限定します。再描画はスクリーンが何らかの理由により文字化
けしてしまったときなどに便利です(*note Screen Garbled::を参照してくださ
い)。

   より原始的なコマンド‘M-x recenter’は、‘recenter-top-bottom’と同じよう
に振る舞いますが、スクリーン位置を循環しません。

   ‘C-M-l’ (‘reposition-window’)は、有用な情報がスクリーンに表示されるよ
うに、現在のウィンドウを発見的な手法によりスクロールします。たとえば
Lispファイルの場合、このコマンドは可能な限り現在のdefun全体がスクリーン
上に表示されるよう試みます。


File: emacs-ja.info,  Node: Auto Scrolling,  Next: Horizontal Scrolling,  Prev: Recentering,  Up: Display

14.3 自動スクロール
===================

ポイントが表示されているテキスト部分から外に移動すると、Emacsは“自動スク
ロール(automatic scrolling)”の処理を行います。通常自動スクロールは、ウィ
ンドウの垂直方向の中央にポイントをセンタリングしますが、この振る舞いを変
えるいくつかの方法があります。

   ‘scroll-conservatively’に小さい数字Nをセットすると、ポイントが少し
(N行以下)スクリーンの外に出たら、Emacsはポイントがスクリーンに表示される
のに充分なだけスクロールします。これでもしポイントの表示に失敗した場合、
Emacsはそのウィンドウの中央にポイント行が表示されるのに充分なだけのスク
ロールをします。‘scroll-conservatively’に大きな数字(100より大)も数字をセ
ットすると、どれだけポイントを移動させようと、自動スクロールはポイント行
を中央にセンタリングしなくなります。Emacsはポイントが表示されるように常
にテキストをスクロールします。ウィンドウの上端または下端かはスクロールの
方向に依存します。デフォルトでは‘scroll-conservatively’は 0で、これは常
にポイント行がウィンドウの中央にセンタリングされることを意味します。

   自動スクロールを制御する他の方法は、変数‘scroll-step’をカスタマイズす
ることです。この変数の値はポイントがスクリーンから外れたとき、何行を自動
スクロールさせるかを決定します。その行数スクロールしてもポイントが表示さ
れない場合、かわりにポイント行が中央にきます。デフォルト値は0で、スクロ
ール後は常にポイント行が中央にきます。

   自動コントロールを制御する3番目の方法は、変数
‘scroll-up-aggressively’と‘scroll-down-aggressively’をカスタマイズするこ
とで、これは直接スクロール後のポイントの垂直位置を指定します。
‘scroll-up-aggressively’の値には、‘nil’(デフォルト)、または0から1までの
浮動小数点数Fを指定します。ポイントがウィンドウの下端を越えたとき(たとえ
ば前方にスクロールしたとき)、Emacsはウィンドウの高さとウィンドウの下端か
らポイント行までの割合が、Fになるようスクロールします。つまりFを大きくす
るとより積極的(aggressive)、つまり新しいテキストがより多く表示されること
を意味します。デフォルト値‘nil’は0.5と同じです。

   同様に‘scroll-down-aggressively’は、ポイントがウィンドウの上端を越え
たとき(たとえば後方にスクロールしたとき)の振る舞いを設定します。値にはス
クロール後のウィンドウの上端からポイント行までのマージンを指定します。つ
まり‘scroll-up-aggressively’を大きくすると、より積極的になります。

   変数‘scroll-conservatively’、‘scroll-step’、および
‘scroll-up-aggressively’と‘scroll-down-aggressively’は、互いに矛盾する方
法で自動スクロールを制御します。したがって自動スクロールをカスタマイズす
る場合は、2つ以上の手法を選ぶべきではありません。もし2つ以上の変数をカス
タマイズする場合は、‘scroll-conservatively’、次に‘scroll-step’、そして最
後に‘scroll-up-aggressively’と‘scroll-down-aggressively’という優先順でカ
スタマイズしてください。

   変数‘scroll-margin’は(たとえscroll-up-aggressivelyや
scroll-down-aggressivelyに、上端または下端からのマージンがウィンドウにた
いして占める割合より大きくなるようなFを指定していても)、ポイントがウィン
ドウの上端または下端にどれだけ近づけるかを制限します。変数の値にはスクリ
ーン行の行数です。もしポイントがウィンドウの上端または下端から指定した行
数の位置にくると、Emacsは自動的にスクロールします。デフォルトでは
‘scroll-margin’は0です。デフォルトではそのウィンドウの高さの1/4に制限さ
れていますが、‘maximum-scroll-margin’をカスタマイズすることにより1/2まで
増加(または0まで減少)させることができます。


File: emacs-ja.info,  Node: Horizontal Scrolling,  Next: Narrowing,  Prev: Auto Scrolling,  Up: Display

14.4 水平スクロール
===================

“水平スクロール(Horizontal scrolling)”は、ウィンドウの行を右方向に移動さ
せます。そのため左端の近くのテキストは表示されなくなります。ウィンドウの
テキストが水平スクロールされると、テキスト行は折り返されるのではなく、切
り詰め(truncated)られます。ウィンドウが切り詰められた行を表示していると
き、ポイントがスクリーンの左端か右端を越えて移動すると、Emacsは自動的に
水平スクロールを行います。デフォルトではそのウィンドウ内のすべての行は一
緒に水平スクロールされますが、変数‘auto-hscroll-mode’に特別な値
‘current-line’をセットした場合は、カーソルを表示する行だけがスクロールさ
れます。自動的な水平スクロールを完全に無効にするには、変数
‘auto-hscroll-mode’に‘nil’をセットしてください。また自動的な水平スクロー
ルがオフになっている場合、ポイントがスクリーンの端を越えると、それを知ら
せるためにカーソルが表示されなくなることに注意してください(テキスト端末
の場合カーソルは端に残されます)。

   変数‘hscroll-margin’は、自動的なスクロールが起こる前に、ポイントがウ
ィンドウの左端または右端に、どれだけ近づけるかを制御します。変数の値は列
数で指定します。たとえば変数の値が5のときは、端から5列目にポイントが移動
すると、水平スクロールが発生します。

   変数‘hscroll-step’はmポイントが端に近づきすぎたときに、何列スクロール
するかを決定します。デフォルト値の0は、ポイントがウィンドウの中央になる
ようにスクロールされることを意味します。正の整数はスクロールされる列数を
指定します。浮動小数点数(0から1の値であること)は、スクロールされる量を、
ウィンドウの幅にたいする割合で指定します。

   以下のコマンドで明示的に水平スクロールすることもできます:

‘C-x <’
     現在のウィンドウのテキストを左にスクロールします(‘scroll-left’)。
‘C-x >’
     右にスクロールします(‘scroll-right’)。

   ‘C-x <’ (‘scroll-left’)は選択された、ウィンドウをウィンドウ幅から2列
少ない列数、左にスクロール(いいかえればウィンドウのテキストは左に移動)し
ます。数引数Nを指定すると、N列スクロールします。

   テキストが左にスクロールされて、ポイントがウィンドウの左端を越えると
、ポイントが表示されているテキストに戻るまで、カーソルはフリーズします。
これは‘auto-hscroll-mode’の設定とは独立しています(これはテキストを左にス
クロールするときのウィンドウの右端での振る舞いだけに影響します)。

   ‘C-x >’ (‘scroll-right’)は、同様に右にスクロールします。ウィンドウが
通常の表示(行の先頭がウィンドウの左端に表示されている状態)のときは、それ
以上スクロールできないので何も起こりません。これは‘C-x >’の引数を正確に
計算する必要がないことを意味します。充分に大きな引数を与えれば、通常の表
示が復元されます。

   これらのコマンドでウィンドウを水平方向にスクロールすると、自動水平ス
クロールの下限値がセットされます。自動スクロールはウィンドウのスクロール
を続けますが、前に‘scroll-left’にセットされた値を越えて右にスクロールで
きなくなります。‘auto-hscroll-mode’が‘current-line’にセットされていると
きは、カーソルを表示する行以外の行は、最小限度だけスクロールされるでしょ
う。


File: emacs-ja.info,  Node: Narrowing,  Next: View Mode,  Prev: Horizontal Scrolling,  Up: Display

14.5 ナローイング
=================

“ナローイング(Narrowing)”とはバッファーのある範囲にフォーカスを置き、他
の部分を一時的にアクセス不能にすることを意味します。扱うことのできる範囲
のことを、“アクセス可能範囲(accessible portion)”と呼びます。ナローイング
を取り消すと、バッファー全体に再びアクセスできるようになります。これを
“ワイドニング(widening)”と呼びます。バッファーにたいして、ナローイングに
より境界を設けることを、バッファーの“制限(restriction)”と呼びます。

   ナローイングにより、他の部分に気を取られずに、1つのサブルーチンやパラ
グラフに集中することが容易になります。ナローイングは、置換コマンドやキー
ボードマクロの繰り返しにより操作される範囲を制限するためにも使われます。

‘C-x n n’
     ポイントとマークの間にナローイングします(‘narrow-to-region’)。
‘C-x n w’
     バッファー全体をワイドニングして、再びアクセス可能にします
     (‘widen’)。
‘C-x n p’
     現在のページにナローイングします(‘narrow-to-page’)。
‘C-x n d’
     現在のdefunにナローイングします(‘narrow-to-defun’)。

   バッファーをナローイングしているときは、表示されている範囲がすべてで
す。残りの部分を見ることはできず、移動もできず(移動コマンドによりアクセ
ス可能範囲の外に移動することはできません)、変更もできません。しかし残り
の部分がなくなったわけではないので、ファイルを保存するとアクセス不能範囲
のテキストもすべて保存されます。ナローイングが有効なときは、モードライン
に‘Narrow’という単語が表示されます。

   主要なナローイングコマンドは、‘C-x n n’ (‘narrow-to-region’)です。こ
れは現在のバッファーを制限するので、現在のリージョンだけがアクセス可能に
なり、リージョンの前後のすべてのテキストはアクセス不能になります。ポイン
トとマークは変化しません。

   かわりに‘C-x n p’ (‘narrow-to-page’)を使うと、現在のページにナローイ
ングされます。ページの定義については、*note Pages::を参照してください。
‘C-x n d’ (‘narrow-to-defun’)は、ポイントを含むdefunにナローイングします
(*note Defuns::を参照してください)。

   ナローイングを取り消す方法は、‘C-x n w’ (‘widen’)です。これにより再び
バッファーのテキストすべてにアクセス可能になります。

   バッファーのどの範囲にナローイングされているかは、‘C-x =’コマンドを使
って情報を得ることができます。*note Position Info::を参照してください。

   ナローイングは、それを理解していないユーザーを容易に混乱させるので、
通常‘narrow-to-region’コマンドは無効になっています。このコマンドを使おう
とすると、Emacsは確認を求め、有効にするオプションを提供します。このコマ
ンドを有効にすると、それ以降は確認を求められなくなります。*note
Disabling::を参照してください。


File: emacs-ja.info,  Node: View Mode,  Next: Follow Mode,  Prev: Narrowing,  Up: Display

14.6 Viewモード
===============

Viewモードは、バッファーをスクリーン上でスキャンするためのマイナーモード
です。このモードは、バッファーを変更せずにスクロールする、便利なコマンド
を提供します。Emacsのカーソル移動コマンドとは別に、<SPC>で前方にスクロー
ル、‘S-<SPC>’または<DEL>で後方にスクロール、‘s’でインクリメンタルサーチ
ができます。

   ‘q’ (‘View-quit’)とタイプするとViewモードが無効になり、Viewモードが有
効になる前のパッファーの位置に戻ります。‘e’ (‘View-exit’)とタイプすると
Viewモードが無効になり、現在のバッファーと位置は維持されます。

   ‘M-x view-buffer’は、既存のEmacsバッファー名を入力として求め、そのバ
ッファーに切り替えてViewモードを有効にします。‘M-x view-file’はファイル
名を入力として求め、そのファイルをvisitしてViewモードを有効にします。


File: emacs-ja.info,  Node: Follow Mode,  Next: Faces,  Prev: View Mode,  Up: Display

14.7 Followモード
=================

“Followモード”は、同じバッファーを表示する2つのウィンドウを、1つの仮想ウ
ィンドウとしてスクロールするマイナーモードです。Followモードを使うには、
ウィンドウが1つだけのフレームを選択して、それを‘C-x 3’を使って縦に並べて
2分割してから、‘M-x follow-mode’とタイプします。それ以降はバッファーをど
ちらのウィンドウでも編集でき、どちらかのウィンドウをスクロールすると、他
方のウィンドウも追従してスクロールします。

   Followモードでは、一方のウィンドウで表示されている部分の外にポイント
を移動して、もう一方のウィンドウで表示されている部分にポイントを移動させ
ると、そのウィンドウが選択されます。つまり2つのウィンドウを1つの大きなウ
ィンドウとして扱えるのです。

   Followモードをオフにするには、もう一度‘M-x follow-mode’とタイプしてく
ださい。


File: emacs-ja.info,  Node: Faces,  Next: Colors,  Prev: Follow Mode,  Up: Display

14.8 テキストのフェイス
=======================

Emacsは“フェイス(faces)”と呼ばれる仕組みを通じて、テキストをいくつかの異
なるスタイルで表示できます。フェイスにはfont(フォント)、height(高さ)、
weight(太さ)、slant(傾き)、foreground(前景)およびbackground(背景)、
underline(アンダーライン)、overline(オーバーライン)などの様々な“フェイス
属性(face attributes)”を指定できます。ほとんどのメジャーモードはFont
Lockモードを通じて、テキストに自動的にフェイスを割り当てます。これらのフ
ェイスを割り当てる方法については、*note Font Lock::を参照してください。

   現在定義されているフェイスと、それがどのような外観なのかを見るには、
‘M-x list-faces-display’とタイプします。プレフィクス引数を指定すると、こ
のコマンドは正規表現の入力を求め、その正規表現にマッチするフェイスだけを
表示します(*note Regexps::を参照してください)。

   あるフェイスが、フレームが異なると違って見えるのことがあり得ます。た
とえばいくつかのテキスト端末ではすべてのフェース属性、特に特にfont、
height、widthはサポートされておらず、指定できるcolorも限られているものが
あります。加えて、ほとんどのEmacsフェースは視認性をよくするために、フレ
ームのバックグラウンドが明るい(light)か暗い(dark)かで属性が異なります。
デフォルトでは、Emacsはフレームの現在のバックグラウンドカラーに基づいて
、表示するフェイスの属性を自動的に選択します。しかし変数
‘frame-background-mode’に非‘nil’値を与えると、これをオーバーライドできま
す。値‘dark’ではすべてのフレームの背景色が暗い色であるかのように処理し、
値‘light’ではすべてのフレームの背景色が明るい色であるかのように処理させ
ることができます。

   フェイスの属性を変えてフェイスをカスタマイズして、将来のEmacsセッショ
ン用にカスタマイズ結果を保存することができます。詳細については、*note
Face Customization::を参照してください。

   ‘default’フェイスはテキストを表示するデフォルトのフェイスで、そのすべ
ての属性は指定されています。バックグラウンドカラーは、フレームのバックグ
ラウンドカラーとしても使用されます。*note Colors::を参照してください。

   他の特別なフェイスとしては、‘cursor’フェイスがあります。グラフィカル
なディスプレーでは、このフェイスのバックグラウンドカラーは、テキストカー
ソルを描画するのに使用されます。このフェイスで効果があるのはこの属性だけ
です。カーソルの下のテキストのフォアグラウンドカラーには、そのテキストの
バックグラウンドカラーが使われます。テキスト端末でのテキストカーソルの外
観は、‘cursor’フェイスではなく端末により決定されます。

   特定のフェイスの属性を指定するのにXのリソースを使うこともできます。
*note Resources::を参照してください。

   Emacsは可変幅フォント(variable-width fonts)を表示できますが、いくつか
のコマンド、特にインデントを行うコマンドは、可変幅の文字幅の表示をうまく
処理できません。そのため、ほとんどのフェイスにたいして可変幅フォントを使
わないこと、特にそれがFont Lockモードに割り当てられている場合は、使わな
いことを推奨します。


File: emacs-ja.info,  Node: Colors,  Next: Standard Faces,  Prev: Faces,  Up: Display

14.9 フェイスのカラー
=====================

フェイスには、さまざまなフォアグラウンドカラーとバックグラウンドカラーを
もたせることができます。フェイスにカラーを指定するとき、たとえばフェイス
をカスタマイズ(*note Face Customization::を参照してください)するときは、
“カラーネーム(color name)”か、“RGBトリプレット(RGB triplet)”で指定するこ
とができます。

   カラーネームとは、‘dark orange’や‘medium sea green’のような、事前に定
義された名前です。カラーネームの一覧を見るには、‘M-x
list-colors-display’とタイプします。表示されるカラーの順番を制御するには
、‘list-colors-sort’をカスタマイズします。このコマンドをグラフィカルなデ
ィスプレーで実行すると、Emacsで既知のカラーネームのすべてが表示されます
(これらは標準のX11のカラーネームで、Xの‘rgb.txt’で定義されています)。コ
マンドをテキスト端末で実行すると、端末で安全に表示することができる一部の
カラーだけが表示されます。フェイスには、さまざまなフォアグラウンドカラー
とバックグラウンドカラーを持たせることができます。しかしEmacsは、テキス
ト端末でもX11のカラーネームを理解できます。もしフェイスにX11のカラーネー
ムが指定されている場合、最も近い端末の色で表示されます。

   RGBトリプレットは、‘#RRGGBB’という形式の文字列で指定します。R、G、Bの
各コンポーネントは、そのそのコンポーネントに関連する色の強度を、1桁から
4桁(通常は2桁)の16進数で指定します。各コンポーネントは同じ桁数でなければ
なりません。16進数のAからFは、大文字小文字を区別しません。

   ‘M-x list-colors-display’は、カラーネームと、それに相当するRGBトリプ
レットを表示します。たとえば‘medium sea green’は‘#3CB371’と同じです。

   ‘M-x set-face-foreground’と‘M-x set-face-background’で、フェイスのフ
ォアグラウンドとバックグラウンドのカラーを変更できます。これらのコマンド
は、ミニバッファーでフェイス名とカラーの入力を求め(補完機能あり)、指定し
たカラーをフェイスにセットします。フェイスのカラーは全フレームに影響しま
すが、カスタマイズバッファーやXリソースを使うのとは異なり、将来のEmacsセ
ッションには引き継がれません。フレームパラメーターを使って、特定のフレー
ムのフォアグラウンドとバックグラウンドのカラーをセットすることもできます
。*note Frame Parameters::を参照してください。


File: emacs-ja.info,  Node: Standard Faces,  Next: Text Scale,  Prev: Colors,  Up: Display

14.10 標準フェイス
==================

以下はテキストの外見を指定する標準フェイスです。これらのフェイスの効果が
欲しい場合は、特定のテキストに適用することができます。

‘default’
     このフェイスは特定のフェイスをもたない普通のテキストに使われます。
     フェイスのバックグラウンドカラーは、フレームのバックグラウンドカラ
     ーとして使用されます。
‘bold’
     このフェイスは、デフォルトフォントのbold(太字)バージョンです。
‘italic’
     このフェイスはデフォルトフォントのitalic(斜体)バージョンです。
‘bold-italic’
     このフェイスはデフォルトフォントのbold italic(太字斜体)バージョンで
     す。
‘underline’
     このフェイスはunderline(下線)のテキストです。
‘fixed-pitch’
     このフェイスはfixed-width font(固定幅フォント)の使用を強制します。
     もし望むなら、このフェイスから他の固定幅フォントにカスタマイズする
     のは妥当ですが、可変幅フォントにするべきではありません。
‘fixed-pitch-serif’
     このフェイスは‘fixed-pitch’と似ていますが、フォントはセリフ(serif:
     HやIなどの上下のひげ飾り)をもち、伝統的なタイプライター文字に、より
     似ています。
‘variable-pitch’
     このフェイスはvariable-width font(可変幅フォント)の使用を強制します
     。
‘shadow’
     このフェースはまわりのテキストに比べて、そのテキストを目立たなくし
     ます。通常これはデフォルトの黒または白のフォアグラウンドカラーでは
     なく、グレーが使われます。

   以下は特別な目的のために、一時的にテキストの一部をハイライトするのに
使われるフェイスの、不完全なリストです(他にも多くのモードが、そのモード
の目的のために、独自のフェイスを定義しています)。

‘highlight’
     このフェイスはさまざまなコンテキスト、たとえばハイパーリンク上をマ
     ウスカーソルが通過したときなどに、テキストをハイライトするのに使わ
     れます。
‘isearch’
     このフェイスは、現在のIsearch(インクリメンタル検索)のマッチをハイラ
     イトするのに使われます(*note Incremental Search::を参照してください
     )。
‘query-replace’
     このフェイスは、現在の問い合わせ置換(Query Replace)のマッチをハイラ
     イトするのに使われます(*note Replace::を参照してください)。
‘lazy-highlight’
     このフェイスは、Isearchおよび問い合わせ置換で、カレントのマッチ(現
     在カーソルがあるマッチ)以外のマッチ(lazy matches)をハイライトするの
     に使われます。
‘region’
     このフェイスは、アクティブなリージョンを表示するのに使われます
     (*note Mark::を参照してください)。EmacsをGTK+サポートつきでビルドし
     た場合、カラーは現在のGTK+のテーマから提供されます。
‘secondary-selection’
     このフェイスは、Xのセカンダリー選択(secondary X selection)を表示す
     るのに使われます(*note Secondary Selection::を参照してください)。
‘trailing-whitespace’
     このフェイスは、‘show-trailing-whitespace’は非‘nil’のとき、行末の余
     分なスペースやタブをハイライトするためのものです(*note Useless
     Whitespace::を参照してください)。
‘escape-glyph’
     このフェイスは、制御文字やエスケープシーケンスを表示するためのもの
     です(*note Text Display::を参照してください)。
‘homoglyph’
     このフェイスは、類似文字(表示しようとする文字と似ているが異なる文字
     )を表示するためのものです(*note Text Display::を参照)。
‘nobreak-space’
     このフェイスは、no-breakスペース文字を表示するためのものです(*note
     Text Display::を参照してください)。
‘nobreak-hyphen’
     このフェイスは、no-breakハイフン文字を表示するためのものです(*note
     Text Display::を参照してください)。

   以下のフェイスは、Emacsフレームの一部の外見を制御します:

‘mode-line’
     このフェイスは、現在選択されているウィンドウのモードラインと、ツー
     ルキットメニューが使われていないときのメニューバーに使われます。デ
     フォルトでは、グラフィカルなウィンドウではraised(浮き彫り)効果をだ
     すため影つきで描画され、非ウィンドウの端末ではデフォルトのフェイス
     を反転して描画されます。
‘mode-line-inactive’
     ‘mode-line’と似ていますが、選択されていないウィンドウのモードライン
     に使われます(‘mode-line-in-non-selected-windows’が非‘nil’のとき)。
     このフェイスは‘mode-line’を継承するので、フェイスを変更するとすべて
     のウィンドウのモードラインが影響を受けます。
‘mode-line-highlight’
     ‘highlight’と似ていますが、モードライン上でマウスセンシティブ(マウ
     スに感応する)なテキスト範囲に使われます。通常このようなテキスト範囲
     は上にマウスポインターがくると、ツールチップ(*note Tooltips::を参照
     してください)をポップアップします。
‘mode-line-buffer-id’
     このフェイスは、モードライン上でバッファーを識別する部分に使われま
     す。
‘header-line’
     ‘mode-line’と似ていますが、ウィンドウのヘッダーラインのためのもので
     す。モードラインがウィンドウの一番下に表示されるように、ヘッダーラ
     インはウィンドウの一番上に表示されます。ほとんどのウィンドウはヘッ
     ダーラインを持ちません。Infoモードのような特別なモードだけがヘッダ
     ーラインを持ちます。
‘header-line-highlight’
     ‘highlight’や‘mode-line-highlight’と似ていますが、ヘッダー行のマウ
     スに感応する部分に使用されます。‘header-line’フェイスは
     ‘highlight’とは無関係にカスタマイズされるかもしれないので、このフェ
     イスが別に設けられています。
‘vertical-border’
     このフェイスは、テキスト端末上でウィンドウを縦に分割するとき使われ
     ます。
‘minibuffer-prompt’
     このフェイスは、ミニバッファーで入力を求めるプロンプトのテキストに
     使われます。デフォルトでは、Emacsは自動的にプロンプトのテキストの、
     テキストプロパティ(*note (elisp)Text Properties::を参照してください
     )のリスト‘minibuffer-prompt-properties’に、このフェイスを追加します
     (この変数はミニバッファーに入ったときに効果をあらわします)。
‘fringe’
     グラフィカルなウィンドウでの、左右のフリンジのためのフェイスです(フ
     リンジはEmacsフレームで、テキストエリアとウィンドウの左右の境界線の
     間にある、狭い領域です)。*note Fringes::を参照してください。
‘cursor’
     このフェイスの‘:background’属性は、テキストカーソルのカラーを指定し
     ます。*note Cursor Display::を参照してください。
‘tooltip’
     このフェイスは、ツールチップのテキストに使われます。デフォルトでは
     、EmacsがGTK+サポートつきでビルドされた場合、ツールチップはGTK+を通
     じて描画されるので、このフェイスは効果がありません。*note
     Tooltips::を参照してください。
‘mouse’
     このファイスは、マウスポインターのカラーを決定します。

   以下のフェイスは、Emacsフレームの一部の外見を制御するときと同様ですが
、テキスト端末またはEmacsをXサポートつき(ただしツールキットサポートなし
)でビルドしたときだけ使われます(それ以外の場合、フレームの対応する各要素
は広義なシステム設定により決定されます)。

‘scroll-bar’
     このフェイスは、スクロールバーの外見を決定します。*note Scroll
     Bars::を参照してください。
‘tool-bar’
     このフェイスは、ツールバーのアイコンのカラーを決定します。*note
     Tool Bars::を参照してください。
‘menu’
     このフェイスはEmacsメニューのカラーとフォントを決定します。*note
     Menu Bars::を参照してください。
‘tty-menu-enabled-face’
     このフェイスは、テキスト端末で利用可能なメニューアイテムを表示する
     のに使われます。
‘tty-menu-disabled-face’
     このフェイスは、テキスト端末で利用不可なメニューアイテムを表示する
     のに使われます。
‘tty-menu-selected-face’
     このフェイスは、テキスト端末でマウスをクリックするか、<RET>を押せば
     選択できるメニューアイテムを表示するのに使われます。


File: emacs-ja.info,  Node: Text Scale,  Next: Font Lock,  Prev: Standard Faces,  Up: Display

14.11 テキストのスケール
========================

現在のバッファーのデフォルトフェイスを大きくするには、‘C-x C-+’または
‘C-x C-=’をタイプします。小さくするには、‘C-x C--’をタイプします。デフォ
ルトのフェースの大きさ(グローバル)に復元するには、‘C-x C-0’とタイプしま
す。これらのキーは、すべて同じコマンド‘text-scale-adjust’にバインドされ
ており、このコマンドは最後のキーを判断して動作を決定します。

   これらのコマンドの最後のキーは、‘C-x’を前置せずに繰り返すことができま
す。たとえば‘C-x C-= C-= C-=’は、フェイスの大きさを3段階に大きくします。
各ステップで大きくなる倍率は1.2です。この倍率を変更するには、変数
‘text-scale-mode-step’をカスタマイズします。‘text-scale-adjust’コマンド
に数引数0を指定すると、‘C-x C-0’とタイプしたのと同様に、デフォルトの大き
さに復元します。

   コマンド‘text-scale-increase’および‘text-scale-decrease’は、‘C-x
C-+’および‘C-x C--’と同様、デフォルトフェイスを大きくまたは小さくします
。キーをバインドする場合、これらのコマンドは、‘text-scale-adjust’より便
利でしょう。

   コマンド‘text-scale-set’は、数引数で現在のバッファーのデフォルトフェ
イスの大きさを、絶対倍率で指定します。

   上記のコマンドは、現在のフォント倍率が1以外のときは、自動的にマイナー
モード‘text-scale-mode’を有効にし、そうでない場合は無効にします。


File: emacs-ja.info,  Node: Font Lock,  Next: Highlight Interactively,  Prev: Text Scale,  Up: Display

14.12 Font Lockモード
=====================

Font Lockモードはマイナーモードで、常に特定のバッファーにローカルで、バ
ッファーのテキストにフェイスを割り当てます(または“フォント表示化
(fontifies)します”)。各バッファーのメジャーモードは、Font Lockモードにど
のテキストをフォント表示可するか指示します。たとえばプログラム言語のモー
ドは、コメントや文字列、関数名のような、構文に関連する構成をフォント表示
化します。

   Font Lockモードはデフォルトで有効です。現在のバッファーでこれを切り替
えるには、‘M-x font-lock-mode’とタイプします。正の数引数は無条件にFont
Lockモードを有効にし、負または0の数引数を指定すると無効になります。

   ‘M-x global-font-lock-mode’とタイプすると、すべてのバッファーでFont
Lockモードを切り替えます。このセッティングを将来のEmacsセッションに引き
継ぐには、変数‘global-font-lock-mode’をカスタマイズ(*note Easy
Customization::を参照してください)するか、以下の行をinitファイルに追加し
ます。

     (global-font-lock-mode 0)

Global Font Lockモードを無効にしていたとしても、モードフック(mode
hooks)に関数を追加することにより、特定のメジャーモードでFont Lockモード
を有効にできます。たとえばCファイルの編集でFont Lockモードを有効にするに
は、以下のように記述します:

     (add-hook 'c-mode-hook 'font-lock-mode)

   Font Lockモードは、‘font-lock-string-face’、
‘font-lock-comment-face’のような、いくつかの特別な名前のフェイスを使って
処理を行います。これらすべてを簡単に探す方法には、‘M-x customize-group
<RET> font-lock-faces <RET>’を使います。それからカスタマイズバッファーで
それらのフェイスの外見をカスタマイズできます。*note Face
Customization::を参照してください。

   変数‘font-lock-maximum-decoration’をカスタマイズして、この機能をサポ
ートするメジャーモードにたいして、Font Lockモードで適用されるフォント表
示化のレベルを変更できます。値には数字を指定します(1は最小限のフォント表
示化で、3という高いレベルのモードもあります)。‘t’は“可能な限り高く”とい
う意味です(デフォルト)。効果を得るには、そのファイルがvisitされる_前_に
‘font-lock-maximum-decoration’をカスタマイズするべきです。この変数をカス
タマイズする時点で、すでにそのファイルをバッファーでvisitしている場合は
、そのバッファーをkillしてから、スタマイズ後に再度そのファイルをvisitし
てください。

   特定のモードに異なる数字を指定することもできます。たとえばC/C++モード
にはレベル1を指定して、他のモードにはデフォルトのレベルを適用するには、
以下の値を使います

     '((c-mode . 1) (c++-mode . 1)))

   コメントと文字列のフォント表示化(または“構文的”なフォント表示化)は、
バッファーのテキストの構文構造の解析に依存します。速度向上のため、Lispモ
ードを含めたいくつかのモードでは、特別な慣習に依存しています。たとえば一
番左の列の開きカッコ(open-parenthesis)または開き大カッコ(open-brace)は常
にdefunの開始であり、すなわち常に文字列またはコメントの外部にあるとみな
す、というように解析します。したがって文字列やコメントの中で、一番左の列
に開きカッコや開き大カッコを記述するのは避けるべきです。詳細については、
*note Left Margin Paren::を参照してください。

   Font Lockは、ほとんどのモードで既存のパターンをハイライトしますが、追
加のパターンをフォント表示化したいときもあるでしょう。特定のモードでハイ
ライトするパターンを追加するには、関数‘font-lock-add-keywords’を使うこと
ができます。たとえばCコメント中の‘FIXME:’という単語をハイライトするには
、以下を使います:

     (add-hook 'c-mode-hook
               (lambda ()
                (font-lock-add-keywords nil
                 '(("\\<\\(FIXME\\):" 1
                    font-lock-warning-face t)))))

font-lockのハイライトパターンからキーワードを削除するには、関数
‘font-lock-remove-keywords’を使います。*note (elisp)Search-based
Fontification::を参照してください。

   大きなバッファーのフォント表示化には、長い時間を要することもあります
。ファイルをvisitしたとき大きな遅延を避けるには、Emacsが最初はバッファー
の表示された部分だけをフォント表示化するようにします。バッファーをスクロ
ールすると、新たに表示される部分がフォント表示化されます。このタイプの
Font Lockは、“Just-In-Time”(または“JIT”) Lockと呼ばれます。カスタマイズ
グループ‘jit-lock’の値をカスタマイズすることにより、アイドル状態のときに
フォント表示可を行うことも含めて、JIT Lockがどのように振る舞うか制御でき
ます。*note Specific Customization::を参照してください。


File: emacs-ja.info,  Node: Highlight Interactively,  Next: Fringes,  Prev: Font Lock,  Up: Display

14.13 インタラクティブなハイライト
==================================

Highlight Changesモードは、最近変更されたバッファー部分のテキストに、異
なるフェイスを与えることにより“ハイライト”するマイナーモードです。
Highlight Changesモードを有効または無効にするには、‘M-x
highlight-changes-mode’を使います。

   Hi Lockモードは、指定した正規表現にマッチするテキストをハイライトする
、マイナーモードです。たとえば、プログラムのソースファイルで、特定の変数
へのすべての参照をハイライトしたり、何らかのプログラムの大量の出力の一部
をハイライトしたり、記事中の特定の名前をハイライトするために使用できます
。Hi Lockモードを有効または無効にするには、コマンド‘M-x hi-lock-mode’を
使います。すべてのバッファーでHi Lockモードを有効にするには、‘M-x
global-hi-lock-mode’を使うか、‘.emacs’ファイルに‘(global-hi-lock-mode
1)’と記述してください。

   Hi LockモードはFont Lockモード(*note Font Lock::を参照してください)と
同じように動作しますが、ハイライトするパターンを明示的に正規表現で指定し
ます。これらは以下のコマンドで制御できます(‘C-x w’で始まるキーバインドは
、‘M-s h’で始まるグローバルなバインドが優先されるため推奨されておらず、
将来のEmacsのバージョンで廃止されるでしょう)。

‘M-s h r REGEXP <RET> FACE <RET>’
‘C-x w h REGEXP <RET> FACE <RET>’
     REGEXPにマッチするテキストを、フェイスFACEを使ってハイライトします
     (‘highlight-regexp’)。ハイライトはバッファーがロードされている限り
     残ります。たとえば単語“whim”をデフォルトのフェイス(黄色いバックグラ
     ウンドカラー)でハイライトするには、‘M-s h r whim <RET> <RET>’とタイ
     プします。ハイライトには任意のフェイスを使うことができますが、Hi
     Lockモードはモード自身でいくつかのフェイスを提供しており、それらは
     デフォルト値のリストに事前ロードされています。フェイスの入力プロン
     プトで‘M-n’と‘M-p’を使うことにより、それらを巡回することができます
     。

     オプション‘hi-lock-auto-select-face’に非‘nil’値をセットすることによ
     り、このコマンド(およびその他のフェイスを読みとるHi Lockコマンド)は
     、入力を求めることなく、デフォルト値のリストから次のフェイスを自動
     的に選択します。

     このコマンドを複数回使用して、さまざまな正規表現を指定し、それぞれ
     を異なる方法でハイライトできます。

‘M-s h u REGEXP <RET>’
‘C-x w r REGEXP <RET>’
     REGEXPのハイライトを解除します(‘unhighlight-regexp’)。メニューから
     呼び出した場合、ハイライト解除する正規表現をリストから選択します。
     キーボードから呼び出した場合は、ミニバッファーを使います。一番最近
     追加された正規表現を表示し、‘M-n’を使って次に古い正規表現、‘M-p’で
     次に新しい正規表現を表示できます(手入力もでき、その場合は補完機能つ
     きです)。ハイライト解除したい正規表現がミニバッファーに表示されたら
     、‘<RET>’を押してミニバッファーを抜けだし、ハイライトを解除できます
     。

‘M-s h l REGEXP <RET> FACE <RET>’
‘C-x w l REGEXP <RET> FACE <RET>’
     REGEXPとのマッチを含む行全体を、フェイスFACEを使ってハイライトしま
     す(‘highlight-lines-matching-regexp’)。

‘M-s h p PHRASE <RET> FACE <RET>’
‘C-x w p PHRASE <RET> FACE <RET>’
     PHRASEにマッチするフレーズを、フェイスFACEでハイライトします
     (‘highlight-phrase’)。PHRASEには正規表現を指定できますが、スペース
     は空白文字にマッチする正規表現に置き換えられます。また、先頭に小文
     字を使用することにより、大文字小文字を区別しなくなります。

‘M-s h .’
‘C-x w .’
     ポイントの近くで見つかったシンボルを、次に利用可能なフェイスでハイ
     ライトします(‘highlight-symbol-at-point’)。

‘M-s h w’
‘C-x w b’
     現在ハイライトを行っている正規表現/フェイスのペアを、バッファーのポ
     イント位置に挿入します。挿入はプログラムを変更してしまわないように
     、コメント文字列でコメント化されます(このキーバインドは
     ‘hi-lock-write-interactive-patterns’コマンドを実行します)。

     これらのパターンは、コメントからも逆抽出されます。それは、コメント
     に記述されたテキストが適正で、‘M-x hi-lock-find-patterns’を呼び出し
     た、あるいはHi Lockモードが有効なときファイルをvisit(これは
     ‘hi-lock-find-patterns’を実行します)したときです。

‘M-s h f’
‘C-x w i’
     正規表現/フェイスのペアを、現在のバッファーのコメントから抽出します
     (‘hi-lock-find-patterns’)。これらのコマンドを使えば、
     ‘highlight-regexp’でパターンを対話的に入力、
     ‘hi-lock-write-interactive-patterns’でそれをファイルに保存、それら
     を編集(あるマッチのフェイスを別のフェイスにしたり)、そして最後にこ
     のコマンド(‘hi-lock-find-patterns’)で編集済みのパターンを、Hi Lockの
     ハイライトに適用することができます。

     変数‘hi-lock-file-patterns-policy’はファイルをvisitしたとき、Hi
     Lockモードがパターンを探して、それを自動的に抽出するべきかを制御し
     ます。値には‘nil’(ハイライトしない)、‘ask’(ユーザーに尋ねる)、また
     は関数を指定します。関数の場合、‘hi-lock-find-patterns’はパターンを
     引数としてその関数を呼び出します。関数が非‘nil’を返した場合、パター
     ンを使用します。デフォルトは‘ask’です。直接
     ‘hi-lock-find-patterns’を呼び出した場合、この変数の値に関係なく、常
     にパターンはハイライトされることに注意してください。

     現在のメジャーモードのシンボルが、リスト‘hi-lock-exclude-modes’のメ
     ンバーの場合、‘hi-lock-find-patterns’は何もしません。


File: emacs-ja.info,  Node: Fringes,  Next: Displaying Boundaries,  Prev: Highlight Interactively,  Up: Display

14.14 ウィンドウのフリンジ
==========================

グラフィカルなディスプレーでは、通常Emacsの各ウィンドウの左右の端に、狭
い“フリンジ(fringes: 縁、へり)”があります。フリンジは、ウィンドウのテキ
ストに関する情報を提供するシンボルの表示に使用されます。‘M-x
fringe-mode’とタイプしてフリンジ表示を切り替えたり、幅を変更できます。こ
のコマンドは全フレームのフリンジに影響します。選択されたフレームのフリン
ジだけを変更するには、‘M-x set-fringe-style’を使います。変数
‘fringe-mode’をカスタマイズして、フリンジへの変更を永続化できます。

   フリンジのもっとも一般的な使われかたは、継続行の表示です(*note
Continuation Lines::を参照してください)。テキストの1行が複数のスクリーン
行に分割されるとき、最初の行を除いた各行の左フリンジには曲矢印が表示され
、その行の先頭が実際の行頭ではないことを示します。そして、最後の行を除い
た各行の右フリンジにも曲矢印が表示され、その行の最後が実際の行末ではない
ことを示します。行の方向が右から左(*note Bidirectional Editing::を参照し
てください)の場合、フリンジの曲矢印の意味は逆になります。

   行が切り詰められているとき(*note Line Truncation::を参照してください
)は水平方向の直矢印を表示して、この行には水平スクロールしなければ見るこ
とのできないテキストがあることを示します。矢印の上でマウスをクリックすれ
ば、矢印の指す方向に水平スクロールします。

   フリンジはバッファーの境界(*note Displaying Boundaries::を参照してく
ださい)や、デバッグ(*note Debuggers::を参照してください)しているプログラ
ムが実行中であることを示すためにも使われます。

   現在の行がウィンドウの幅と正確に一致して、ポイントがその行の行末にあ
る場合、フリンジにはカーソルが描画されます。これを無効にするには、変数
‘overflow-newline-into-fringe’を‘nil’に変更します。これによりEmacsはウィ
ンドウ幅と同じ長さの行にたいしても、継続または切り詰めを行います。

   表示されているウィンドウの片側、または両側のフリンジを削除するために
‘fringe-mode’をカスタマイズする場合、フリンジ上にに表示する機能は利用で
きなくなりますが、行の継続と切り詰めの標識は例外です。フリンジが利用でき
ない場合、Emacsは特別なASCII文字(*note Continuation Lines::、および*note
Line Truncation::を参照してください)により、行の継続と切り詰めを示すため
に、最左および最右の文字セルを使用します。行の継続と切り詰めの標識に使用
される文字セルは、この目的のために予約されるので、各行に表示するテキスト
のための列数は減少します。バッファーのテキストには双方向のテキスト、およ
びleft-to-right(左から右)とright-to-left(右から左)の両方のパラグラフ
(*note Bidirectional Editing::を参照してください)が含まれるかもしれない
ので、、片側のフリンジを削除しただけでは依然として2つの文字セルが予約さ
れます。つまり行の継続と切り詰めの標識のために、ウィンドウの両側にそれぞ
れ1つの文字セルが予約されます。なぜなら、right-to-leftのパラグラフでは、
これらの標識はウィンドウの反対側に表示されるからです。


File: emacs-ja.info,  Node: Displaying Boundaries,  Next: Useless Whitespace,  Prev: Fringes,  Up: Display

14.15 バウンダリーの表示
========================

グラフィカルなディスプレーでは、Emacsはバッファーのバウンダリー
(boundary: 境界)を、フリンジに表示することもできます。この機能を有効にす
ると、最初の行と最後の行ではフリンジに、かぎカッコが表示されます。上矢印
または下矢印の場合、それはウィンドウをその方向に、もっとスクロールできる
ことを示します。

   バッファーローカルな変数‘indicate-buffer-boundaries’は、バッファーの
バウンダリーととウィンドウのスクロールが、フリンジでどのように表示される
かを制御します。値が‘left’(または‘right’)の場合、かぎカッコと矢印のビッ
トマップは、左フリンジ(または右フリンジ)に表示されます。

   値がalist(association list: 連想リスト。*note (elisp)Association
Lists::を参照してください)の場合、各要素の‘(INDICATOR . POSITION)’で、標
識(indicator)の位置(position)を指定します。INDICATORには‘top’、
‘bottom’、‘up’、‘down’、または‘t’(指定されていない標識のデフォルト位置
)を指定します。POSITIONには‘left’、‘right’、または‘nil’(標識を表示しない
)を指定します。

   たとえば‘((top . left) (t . right))’は、最上行の左フリンジにかぎカッ
コを表示し、右フリンジには最下行のかぎカッコとスクロール矢印を表示します
。左フリンジにかぎカッコだけを表示させる場合は、‘((top . left) (bottom .
left))’を使います。


File: emacs-ja.info,  Node: Useless Whitespace,  Next: Selective Display,  Prev: Displaying Boundaries,  Up: Display

14.16 不要なスペース
====================

意識せずに不必要なスペースを行末に残してしまったり、バッファーの最後に空
行を残してしまうことはよくあります。ほとんどの場合、そのような“行末の空
白文字(trailing whitespace)”は何の影響も及ぼしませんが、厄介物になる場合
もあります。

   バッファーローカルな変数‘show-trailing-whitespace’を‘t’にセットするこ
とにより、行末の空白文字を可視化できます。これによりEmacsはフェイス
‘trailing-whitespace’で、行末の空白文字を表示します。

   この機能は行末に空白文字を含む行の、行末にポイントがあるときは適用さ
れません。厳密にいえば、これも行末の空白文字なのですが、それを特別に表示
してしまうと、新しいテキストをタイプするとき面倒です。このような特別なケ
ースでは、ポイントの位置に表示されるカーソルより、空白文字があることが自
明だからです。

   ‘M-x delete-trailing-whitespace’とタイプすると、すべての行末の空白文
字を削除します。このコマンドは、バッファー内の各行の行末にあるすべての余
分なスペースと、バッファーの最後にある空行を削除します。バッファー内の空
行を削除しない場合は、変数‘delete-trailing-lines’を‘nil’に変更してくださ
い。リージョンがアクティブのときは、リージョン内の各行の行末の余分なスペ
ースを削除します。

   グラフィカルなディスプレーでは、Emacsはウィンドウの最後の使われていな
い行の左フリンジに小さなイメージを表示して、それを示すことができます。こ
のイメージはバッファーのテキストが何も含まれていないスクリーン行に表示さ
れるので、バッファーの最後にある空行は、このイメージが表示されないことで
見分けることができます。この機能を有効にするにはバッファーローカルな変数
‘indicate-empty-lines’に非‘nil’値をセットします。すべての新しいバッファ
ーでこの機能を有効または無効にするには、この変数のデフォルト値をセットし
ます(例 ‘(setq-default indicate-empty-lines t)’)

   Whitespaceモードはバッファーローカルなマイナーモードで、バッファー内
にある多くの種類の空白文字を視覚化します。これは空白文字を特別なフェイス
で描画するか、特別なグリフで表示することにより行われます。このモードを切
り替えるには、‘M-x whitespace-mode’とタイプします。視覚化される空白文字
の種類は、リスト変数‘whitespace-style’により決定されます。
‘M-x whitespace-toggle-options’とタイプして、カレントバッファーでこのリ
スト内の個々の要素のオンとオフを切り替えることができます。以下はリストに
指定できる要素の一部です(完全なリストは変数のドキュメントを参照してくだ
さい)。

‘face’
     特別なフェイスを使った視覚化をすべて有効にします。この要素には特別
     な意味があります。もしこれがリストに含まれていない場合、
     ‘space-mark’、‘tab-mark’、‘newline-mark’を除く他の視覚化は効果がな
     くなります。

‘trailing’
     行末の空白文字をハイライトします。

‘tabs’
     タブ文字をハイライトします。

‘spaces’
     スペースおよびnon-breaking space文字をハイライトします。

‘lines’
     80列以上の行をハイライトします。列の上限を変更するには、変数
     ‘whitespace-line-column’をカスタマイズします。

‘newline’
     改行をハイライトします。

‘empty’
     空行をハイライトします。

‘big-indent’
     非常に深いインデントをハイライトします。デフォルトでは、少なくとも
     4個の連続するTAB文字と、32個の連続するスペースからなる、任意のシー
     ケンスがハイライトされます。これを変更するには、正規表現
     ‘whitespace-big-indent-regexp’をカスタマイズしてください。

‘space-mark’
     スペースとnon-breaking文字を特別なグリフで描画します。

‘tab-mark’
     タブ文字を特別なグリフで描画します。

‘newline-mark’
     改行文字を特別なグリフで描画します。

   Global Whitespaceモードは、すべてのバッファーで空白文字を視覚化する、
グローバルなマイナーモードです。この機能を個別に切り替えるには、‘M-x
global-whitespace-toggle-options’を使用してください。


File: emacs-ja.info,  Node: Selective Display,  Next: Optional Mode Line,  Prev: Useless Whitespace,  Up: Display

14.17 選択的な表示
==================

Emacsには、与えられたレベルより多くインデントされた行を隠す機能がありま
す。これをプログラムの概要を理解するのに使うことができます。

   現在のバッファーの行を隠すには、数引数Nを指定して‘C-x $’
(‘set-selective-display’)をタイプします。すると少なくともN列のインデント
をもつ行は、スクリーンに表示されなくなります。隠された行の存在を示すのは
、表示されている行末に表示された3つのドット(‘...’)だけで、これは1行以上
の行が後に隠されていることを意味します。

   コマンド‘C-n’および‘C-p’は、隠された行が存在しないかのように、隠され
た行をスキップして移動します。

   隠された行は依然としてバッファーに存在し、ほとんどの編集コマンドはそ
れらを見ることができるので、隠されな行にポイントを移動することもありえま
す。これが起こるとカーソルは前の行の最後、つまり3つのドットの後ろに表示
されます。ポイントが表示されている行の行末、つまり改行の前にある場合、カ
ーソルは3つのドットの前に表示されます。

   隠された行のすべてを再び表示するには、引数を指定せずに‘C-x $’とタイプ
してください。

   変数‘selective-display-ellipses’に‘nil’をセットすると、隠された行があ
ることを示す3つのドットは表示されなくなり、隠された行があることを示す視
覚的な表示はなくなります。変数がセットされると、それは自動的にローカルに
なります。

   バッファーのテキストの一部を隠す他の方法については、*note Outline
Mode::を参照してください。


File: emacs-ja.info,  Node: Optional Mode Line,  Next: Text Display,  Prev: Selective Display,  Up: Display

14.18 モードラインのオプション
==============================

バッファーのパーセント表示POSは、ウィンドウの上端がバッファーのどの場所
にあるかを100分率で示します。‘M-x size-indication-mode’とタイプしてSize
Indicationモードをオンにすることにより、バッファーのサイズを追加で表示で
きます。サイズは以下のようにパーセント表示のすぐ後に表示されます:

     POS of SIZE

SIZEは、バッファーの文字数を人間が理解しやすい形式(‘k’は10^3、‘M’は
10^6、‘G’は10^9などの短縮形が使用されます)で表示します。

   Line Numberモードが有効なとき、ポイント位置の現在の行番号はモードライ
ンに表示されます。‘M-x line-number-mode’コマンドを使って、Line Numberモ
ードのオンとオフを切り替えることができます(通常はオンです)。行番号はそれ
が何であるかを示す文字‘L’とともに、バッファーのパーセント表示POSの後ろに
表示されます。

   同様に、‘M-x column-number-mode’でColumn Numberモードをオンにすること
により、現在の列番号を表示できます。列番号は文字‘C’で示されます。しかし
両方のモードが有効になっているときは、行番号と列番号は‘L’や‘C’ではなく、
‘(561,2)’のようにカッコつきで表示されます。マイナーモードとこれらのコマ
ンドの使い方については、*note Minor Modes::を参照してください。

   Column Numberモードでは、列番号はそのウィンドウの左マージンより0から
カウントされます。1からカウントした列番号を表示したい場合は、
‘column-number-indicator-zero-based’を‘nil’にセットしてください。

   ナローイング(*note Narrowing::を参照してください)によりバッファーを制
限している場合、アクセスできる部分にもとづいた行番号が表示されます。その
ため、これは‘goto-line’の引数として使用するには適しません(ファイル全体に
たいする行番号を見るには、‘what-line’コマンドを使います)。

   バッファーが非常に大きい場合(‘line-number-display-limit’の値より大)、
速度が遅くなるのでEmacsは行番号を計算しません。そのためモードラインに行
番号は表示されません。この制限を取り除くには、
‘line-number-display-limit’に‘nil’をセットします。

   バッファーの行が長いときも、行番号の計算が遅くなります。この理由によ
り、Emacsはポイントの近くの行の幅の平均文字数が、
‘line-number-display-limit-width’より大きいときは、行番号を表示しません
。デフォルト値は200文字です。

   Emacsはオプションで、時刻とシステムロードを、すべてのモードラインで表
示できます。この機能を有効にするには、‘M-x display-time’とタイプするか、
オプション‘display-time-mode’をカスタマイズします。モードラインに追加さ
れる情報は以下のような形式です:

     HH:MMPM L.LL

ここでHHとMMは時間と分で、後ろに‘AM’と‘PM’がつきます。L.LLは、過去数分間
における、システム全体で実行中または実行準備ができている(例: 利用可能な
プロセッサー待ち)プロセスの平均数です(オペレーティングシステムがサポート
しないフィールドは表示されません)。時刻を24時間表示にしたいときは、変数
‘display-time-24hr-format’に‘t’をセットしてください。

   もし未読メールがある場合、ロードレベルの後ろに‘Mail’という単語が表示
されます。グラフィカルなディスプレーでは、‘display-time-use-mail-icon’を
カスタマイズすることにより、‘Mail’のかわりにアイコンを使うことができます
。これによりモードラインのスペースが多少節約できます。
‘display-time-mail-face’をカスタマイズして、メールの表示を目立たせること
ができます。‘display-time-mail-file’を使ってチェックするメールファイルを
指定したり、‘display-time-mail-directory’で受信メールのディレクトリーを
指定できます(ディレクトリー内の空でない普通のファイルは、新しい受信メー
ルと判断されます)。

   Emacsをラップトップコンピューターで実行している場合、コマンド
‘display-battery-mode’を使うか、変数‘display-battery-mode’をカスタマイズ
することにより、モードラインにバッテリー充電状況を表示できます。変数
‘battery-mode-line-format’は、バッテリーの充電状況の表示方法を決定します
。モードラインに表示されるメッセージの正確さはオペレーティングシステムに
依存しており、通常はバッテリーの充電トータルにたいする現在のバッテリー充
電率が表示されます。

   グラフィカルなディスプレーでは、モードラインは立体的に描画されます。
この効果が気に入らない場合は、‘mode-line’フェイスをカスタマイズして、
‘box’属性に‘nil’をセットすることにより無効にできます。*note Face
Customization::を参照してください。

   デフォルトでは、選択されていないウィンドウのモードラインは、
‘mode-line-inactive’と呼ばれる、別のフェイスで表示されます。選択されたウ
ィンドウのモードラインだけが、‘mode-line’フェイスで表示されます。これに
より、どのウィンドウが選択されているかがわかりやすくなります。モードライ
ンがないミニバッファーが選択されているときは、ミニバッファーをアクティブ
にしたウィンドウのモードラインが、‘mode-line’で表示されます。結果として
通常のミニバッファーの使用では、モードラインは変化しません。

   変数‘mode-line-in-non-selected-windows’を‘nil’にセットすることにより
、‘mode-line-inactive’の使用を無効にできます。これによりすべてのモードラ
インが、‘mode-line’フェイスで表示されます。

   モードラインに表示される改行フォーマットは、変数‘eol-mnemonic-unix’、
‘eol-mnemonic-dos’、‘eol-mnemonic-mac’、および‘eol-mnemonic-undecided’を
セットすることにより、カスタマイズできます。


File: emacs-ja.info,  Node: Text Display,  Next: Cursor Display,  Prev: Optional Mode Line,  Up: Display

14.19 テキストが表示される方法
==============================

ほとんどの文字は、“印字文字(printing characters)”です。これらの文字がバ
ッファーに存在すると、スクリーンにそのまま表示されます。印字文字には
ASCIIの数字、文字、区切り文字、同様に多くの非ASCII文字が含まれます。

   ASCII文字セットには、印字されない“制御文字(control characters)”が含ま
れます。その中でも特別に表示されるものが2つあります。1つ目は改行文字
(Unicodeのコードポイント‘U+000A’)で、新しい行を開始するのに表示されます
。2つ目はタブ文字(‘U+0009’)で、次のタブストップ(通常は8文字ごと)までをス
ペースで表示します。タブを何文字のスペースで表示するかは、バッファーロー
カルな変数‘tab-width’で制御され、1から1000の整数で指定しなければなりませ
ん。バッファーのタブ文字がどのように表示されるかは、コマンドとしての
<TAB>の定義には関係ないことに注意してください。

   他のASCII制御文字としては、‘U+0020’(8進の40、10進の32)より下のコード
があり、それらはカレット(‘^’)と、その後ろに非制御文字バージョンの文字を
続けて、‘escape-glyph’フェイスで表示されます。たとえば文字
‘control-A’(‘U+0001’)は、‘^A’と表示されます。

   コード‘U+0080’(8進の200)から‘U+009F’(8進の237)までのrawバイトは、
‘escape-glyph’フェイスにより、“8進エスケープシーケンス(octal escape
sequences)”で表示されます。たとえば文字コード‘U+0098’(8進の230)は、
‘\230’と表示されます。バッファーローカルな変数‘ctl-arrow’を‘nil’に変更す
ると、ASCII制御文字も、カレットエスケープシーケンスではなく、8進エスケー
プシーケンスで表示されます。

   非ASCII文字の中には、ASCIIのスペースやハイフン(マイナス記号)と同じ外
観を持つものがあります。そのような文字は、意識せずにバッファーに入力され
たとき(たとえばyankなどで)、問題となることがあります。たとえばソースコー
ドコンパイラーは通常、非ASCIIのスペースを、空白文字として扱いません。こ
の問題に対処するため、Emacsはそのような文字を特別な方法
(‘U+00A0’(no-break space)は‘nobreak-space’フェイス、‘U+00AD’(soft
hyphen)、‘U+2010’(hyphen)、‘U+2011’ (non-breaking hyphen)は
‘nobreak-hyphen’フェイス)で表示します。これを無効にするには、変数
‘nobreak-char-display’を‘nil’に変更します。この変数に非‘nil’かつ非‘t’の
値を与えると、Emacsはハイライトされたバックスラッシュの後に、スペースま
たはハイフンを表示します。

   特定の文字コードの表示のカスタマイズは、ディスプレーテーブル(display
table)によって行われます。*note Display Tables: (elisp)Display Tables.を
参照してください。

   グラフィカルなディスプレーでは、Emacsが利用可能なフォントにグリフがな
い文字がいくつかあります。これらの“グリフがない文字(glyphless
characters)”は、通常16進文字を含むボックスで表示されます。テキスト端末で
は、端末エンコーディング(*note Terminal Coding::を参照してください)で表
示できない文字は、通常クエスチョン記号で表示されます。表示方法は、変数
‘glyphless-char-display-control’で制御できます。これらの文字の表示がより
目立つように、‘glyphless-char’フェイスをカスタマイズすることもできます。
詳細は、*note Glyphless Character Display: (elisp)Glyphless Chars.を参照
してください。

   Emacsはカレントのディスプレイでcurved quotes(‘‘’と‘’’)が表示可能か判
断を試みます。デフォルトでは、表示可能ならEmacsはメッセージやヘルプテキ
スト内のASCIIクォート(‘`’と‘'’)をcurved quotesに変換します。ユーザーオプ
ション‘text-quoting-style’をカスタマイズすることにより、この変換を有効ま
たは無効にできます(*note (elisp)Keys in Documentation::を参照)。

   curved quotes(‘‘’、‘’’、‘“’、‘”’)をASCII文字と同様な外観で見ることが
できる場合、それらは‘homoglyph’フェイスで表示されます。表示できないこと
が既知のcurved quotesは、それらのASCIIによる代替である‘`’、‘'’、‘"’が
‘homoglyph’で表示されます。


File: emacs-ja.info,  Node: Cursor Display,  Next: Line Truncation,  Prev: Text Display,  Up: Display

14.20 カーソルの表示
====================

テキスト端末では、カーソルの外見は端末により制御され、大部分はEmacsの制
御が及びません。いくつかの端末は、普通の固定的なカーソルと、目立つ点滅カ
ーソルの2種類を提供します。デフォルトではEmacsは目立つカーソルを使い、
Emacsを開始または再開したときは、そのカーソルに切り替えます。変数
‘visible-cursor’が‘nil’の場合、Emacsを開始または再開したとき、普通のカー
ソルを使います。

   グラフィカルなディスプレーでは、より多くのテキストカーソルのプロパテ
ィを変更できます。カラーを変えるには、フェイス‘cursor’の、属性
‘:background’を変更します(このフェイスの他の属性には、何を指定しても効果
はありません。カーソルの下にあるテキストはフレームのバックグラウンドカラ
ーを使って描画されます)。外見を変更するには、バッファーローカルな変数
‘cursor-type’をカスタマイズします。有効な値は、‘box’(デフォルト)、
‘hollow’(中抜きのボックス)、‘bar’(垂直のバー)、‘(bar . N)’(幅がNピクセル
の垂直バー), ‘hbar’(水平バー)、‘(hbar . N)’(高さがNピクセルの水平バー)、
または‘nil’(カーソルなし)です。

   デフォルトでは、カーソルは10回点滅する間にEmacsに何も入力がないと、点
滅をストップします。そして何らかの入力イベントがあると、また0からカウン
トを再開します。変数‘blink-cursor-blinks’をカスタマイズして、これを制御
できます。変数の値には、何の入力もないとき点滅をストップする点滅回数を指
定します。変数に0または負の値をセットすると、カーソルはずっと点滅したま
まになります。カーソルの点滅を無効にするには、変数‘blink-cursor-mode’を
‘nil’に変更するか(*note Easy Customization::を参照してください)、initフ
ァイルに以下の行を追加します:

       (blink-cursor-mode 0)

リスト変数‘blink-cursor-alist’をカスタマイズして、カーソルが点滅をストッ
プしたとき、どのように見えるかを変更できます。リストの各要素は、
‘(ON-TYPE . OFF-TYPE)’という形式を指定します。ON-TYPEには、点滅している
ときのカーソルを指定します(ON-TYPEには、上で説明したカーソルタイプを指定
します)。そしてOFF-TYPEには、点滅していないときのカーソルを指定します。

   タブ文字のように、特別に幅が広い文字もあります。そのような文字上にカ
ーソルがあるとき、通常はデフォルトの文字幅で描画されます。カーソルを文字
幅に伸ばすには、変数‘x-stretch-cursor’を非‘nil’値に変更してください。

   選択されていないウィンドウのカーソルは、通常点滅していない中抜きのボ
ックスで表示されます(カーソルにバーを使っている場合、より細いバーで表示
されます)。選択されていないウィンドウでカーソルを非表示にするには、変数
‘cursor-in-non-selected-windows’を‘nil’に変更してください。

   カーソルをよりはっきりと表示させるために、HL Lineモードを使用できます
。このモードでは、ポイントを含む行がハイライトされます。現在のバッファー
で有効または無効にするには、‘M-x hl-line-mode’を使います。このモードをグ
ローバルに有効または無効にするには、‘M-x global-hl-line-mode’を使用して
ください。


File: emacs-ja.info,  Node: Line Truncation,  Next: Visual Line Mode,  Prev: Cursor Display,  Up: Display

14.21 行の切り詰め
==================

Emacsは行を継続(*note Continuation Lines::を参照してください)するかわり
に、長い行を“切り詰めて”表示できます。これは、スクリーンやウィンドウの幅
より長い行は、全体が表示されないことを意味します。グラフィカルなディスプ
レーでは、行が切り詰められている場合、フリンジに小さな直矢印が表示されま
す。テキスト端末では、右端および/または左端の列に‘$’が表示されます。

   水平スクロールは、自動的に行の切り詰めを引き起こします(*note
Horizontal Scrolling::を参照してください)。特定のバッファーにたいして行
の切り詰めを明示的に有効にするには、コマンド‘M-x toggle-truncate-lines’を
使います。これは変数‘truncate-lines’をローカルに変更することで機能します
。値が非‘nil’のときは、長い行は切り詰められ、‘nil’のときは複数のスクリー
ン行に分けられます。変数‘truncate-lines’をセットすると、現在のバッファー
にローカルに適用されます。値を変更するまでは、デフォルト値(‘nil’)が使わ
れます。

   ウィンドウを分割して狭くなりすぎたとき、Emacsは自動的に行の切り詰めを
有効にします。これを制御する変数‘truncate-partial-width-windows’について
は、*note Split Window::を参照してください。


File: emacs-ja.info,  Node: Visual Line Mode,  Next: Display Custom,  Prev: Line Truncation,  Up: Display

14.22 Visual Lineモード
=======================

このモードでは、通常の行継続の代わりに、“単語での折り返し”が使われます。
通常の行継続のように、長い論理行は2行以上のスクリーン行に分割されます。
しかしEmacsはウィンドウの右端(RTL言語:Right-To-Leftlanguageでは左端)の近
くの、単語の境界で折り返すよう試みます。これは単語の途中で折り返さないこ
とにより、可読性を高めるためです。

   単語での折り返しは、オプションのマイナーモードである、Visual Lineモー
ドで有効になります。現在のバッファーでVisual Lineモードの有効と無効を切
り替えるには、‘M-x visual-line-mode’とタイプします。メニューバーから
Visual Lineモードを有効にすることもできます(Optionsメニューから、サブメ
ニュー‘Line Wrapping in this Buffer’の、メニューアイテム‘Word Wrap
(Visual Line Mode)’を選択します)。Visual Lineモードが有効なときは、モー
ドラインのモード表示に‘wrap’という文字が表示されます。コマンド‘M-x
global-visual-line-mode’は、全バッファーのVisual Lineモードを切り替えま
す。

   Visual Lineモードでは、いくつかのコマンドは論理行ではなくスクリーン行
に作用します。‘C-a’ (‘beginning-of-visual-line’)はスクリーン行の先頭に移
動し、‘C-e’ (‘end-of-visual-line’)はスクリーン行の最後に移動、‘C-k’
(‘kill-visual-line’)はテキストをスクリーン行の最後までkillします。

   論理行単位で移動するには、コマンド‘M-x next-logical-line’または‘M-x
previous-logical-line’を使います。これらのコマンドはVisual Lineモードが
有効であるかにかかわらず、次または前の論理行に移動します。これらのコマン
ドを頻繁に使う場合は、キーを割り当てると便利でしょう。*note Init
Rebinding::を参照してください。

   デフォルトでは、単語の折り返し表示はフリンジに表示されません。Visual
Lineモードは、長い論理行を含むファイルを編集するときに使われる場合があり
、折り返し行すべてにフリンジの表示をすると見にくくなるためです。これを変
更するには、変数‘visual-line-fringe-indicators’をカスタマイズしてくださ
い。


File: emacs-ja.info,  Node: Display Custom,  Prev: Visual Line Mode,  Up: Display

14.23 ディスプレーのカスタマイズ
================================

このセクションでは、Emacsスクリーンの外観を制御するさまざまな変数を説明
します。初心者はスキップして構いません。

   Emacsにバッファー内の各行にたいして行番号を表示させたい場合は、バッフ
ァーローカルな変数‘display-line-numbers’(デフォルトは‘nil’)をカスタマイ
ズします。この変数は行番号表示のさまざまなモードをサポートするために、い
くつかの異なる値をもつことができます。

‘t’
     バッファーテキストを表示する継続行ではないスクリーン各行の前に、、
     (絶対)行番号を表示します。その行が継続行の場合、またはスクリーン行
     全体がディスプレイ文字列(display string)、またはオーバーレイ文字列
     (overlay string)の場合、その行に番号は振られません。

‘relative’
     バッファーテキストを表示する非継続行の前に、相対行番号(relative
     line number)を表示します。行番号はポイントを表示する行にたいして相
     対的なので、カレント行から遠ざかるにしたがって、行番号は増加または
     減少します。

‘visual’
     この値により、Emacsにビジュアル的に行をカウントさせます。実際にディ
     スプレイに表示されている行だけがカウントされ、ラップして複数行を占
     めるスクリーン行は、複数回番号付けされます。表示される番号は、上述
     の値‘relative’のように相対的です。これはOutlineモード(*note Outline
     Mode::を参照)のような、テキストをフォールド(fold: 折り畳む)するモー
     ドで、正確なスクリーン行の番号により移動するときに役立つでしょう。

その他
     その他の非‘nil’値は、‘t’として扱われます。

   コマンド‘M-x display-line-numbers-mode’は、行番号表示を切り替える便利
な方法を提供します。このモードのグローバル版は、
‘global-display-line-numbers-mode’です。ユーザーオプション
‘display-line-numbers-type’は、上述した行番号表示のサブモードのどのモー
ドをアクティブにするかを制御します。

たとえグローバルに‘display-line-numbers-mode’をオンにしていても、ミニバ
ッファーやツールチップ内に行番号は表示されないことに注意してください。

   Emacsが相対行番号を表示しているとき、カレント行(ポイントを表示してい
る行)の前に表示される番号を制御できます。デフォルトでは、Emacsはカレント
行にたいしては、他のすべての行が相対行番号であっても、絶対行番号を表示し
ます。変数‘display-line-numbers-current-absolute’を‘nil’値にカスタマイズ
した場合、カレント行に表示される番号は0になります。これはカレント行の番
号が重要ではなく、大きなバッファー内のテキストにたいして、より多くの水平
方向の空きを残したいとき便利でしょう。

   ナロー(*note Narrowing::を参照)されたバッファーでは通常、ナローイング
の先頭から番号が開始されます。しかし、変数‘display-line-numbers-widen’を
非‘nil’値にカスタマイズした場合、ナローイングは無視されて、そのバッファ
ーの最初の文字から行番号が開始されます。

   Selective Display(選択的表示)モード(*note Selective Display::を参照
)、およびその他の(OutlineモードやOrgモードのような)ディスプレイから多く
の行を隠すモードでは、行番号のために予約済みのスペースにたいする法則性の
ない計算ミスを避けるために、変数‘display-line-numbers-width-start’および
‘display-line-numbers-grow-only’のカスタマイズ、または
‘display-line-numbers-width’に十分大きな値をセットしたいと思うかもしれま
せん。

   行番号は、特別なフェイス‘line-number’で表示されます。カレント行番号は
異なるフェイス‘line-number-current-line’で表示されるので、ポイントを表示
する行を見つける助けとなるように、カレント行番号に異なる外観を与えること
ができます。

   変数‘visible-bell’が非‘nil’の場合、Emacsは通常ベルサウンドを鳴らす場
面で、スクリーン全体を点滅するよう試みます。端末がスクリーンを点滅させる
方法を持たないとき、この変数は効果がありません。

   変数‘echo-keystrokes’は、複数文字キーのエコー表示を制御します。値には
エコーが開始されるまでの秒数を指定します。0の場合、エコーされません。何
かエコーされるべきものがあるときは、この変数の値が効果をもちます。*note
Echo Area::を参照してください。

   グラフィカルなディスプレーでは、Emacsはビジーのときにマウスポインター
を砂時計で表示します。この機能を無効にするには、変数
‘display-hourglass’に‘nil’をセットします。変数‘hourglass-delay’は、砂時
計が表示されるまでのビジーな時間を、秒数で指定します。デフォルトは1です
。

   マウスポインターがEmacsのフレーム内にある場合、文字をタイプしてテキス
トを挿入するまでの間、テキストを隠さないよう、Emacsはマウスポインターを
非表示にします(正確に言うとマウスポインターの非表示は、自己挿入的
(self-inserting)な文字をタイプしたときです。*note Inserting Text::を参照
してください)。マウスポインターを動かすと、再び表示されます。この機能を
無効にするには、変数‘make-pointer-invisible’に‘nil’をセットしてください
。

   グラフィカルなディスプレーでは、変数‘underline-minimum-offset’は、ア
ンダーラインされたテキストの、アンダーラインから文字の基底線までの最小距
離を、ピクセルで決定します。デフォルトでは値は1です。この変数を増加させ
ると、特定のフォントにおいて、アンダーラインされたテキストの可読性が向上
します(しかしEmacsは、カレント行にはアンダーラインを描画しません)。変数
‘x-underline-at-descent-line’は、テキストにアンダーラインを引く方法を決
定します。デフォルトは‘nil’で、これはフォントの基底線と同じレベルに描画
されることを意味します。これを‘t’に変更すると、Emacsはフォントが同じ大き
さになるよう、アンダーラインを少し下に描画します。(アンダーラインされる
テキストにたいして非デフォルトの行間が指定された場合、Emacsは追加される
行間の下にアンダーラインを描画する。*note (elisp)Line Height::を参照され
たい。)

   変数‘overline-margin’は、テキストの上のオーバーラインの垂直位置を、オ
ーバーライン自身の高さも含めて、ピクセルで指定します。デフォルトは2です
。

   テキスト端末には、bold(太字)かつ反転されたテキストが読みにくいものが
あります。関数‘tty-suppress-bold-inverse-default-colors’に、引数非
‘nil’を与えて呼び出すと、このような場合のbold-faceの効果を抑制します。

   デフォルトでは、rawバイトは8進形式で表示されます。たとえば10進値が
128のバイトは‘\200’のように表示されます。これを16進形式の‘\x80’で表示す
るよう変更するには、変数‘display-raw-bytes-as-hex’を‘t’にセットしてくだ
さい。


File: emacs-ja.info,  Node: Search,  Next: Fixit,  Prev: Display,  Up: Top

15 検索と置換
*************

他のエディターと同様、Emacsには文字列を検索(search)するコマンドがありま
す。Emacsには、文字列を違う文字列で置き換える(replace)コマンドもあります
。また、同じことを行いますが、固定文字列ではなくパターンを検索するコマン
ドもあります。

   ‘xref’の制御下にある複数ファイルにたいして検索したり((*note
Identifier Search::を参照してください)、Diredの‘A’コマンドを通じて検索し
たり(*note Operating on Files::を参照してください)、‘grep’コマンドを使っ
た検索(*note Grep Searching::を参照してください)も可能です。

* Menu:

* Incremental Search::       文字列をタイプすることにより始まる検索。
* Nonincremental Search::    文字列全体を指定してから検索する。
* Word Search::              単語の並びを検索する。
* Symbol Search::            ソースコードのシンボルを検索する。
* Regexp Search::            正規表現にマッチする検索。
* Regexps::                  正規表現の構文について。
* Regexp Backslash::         ‘\’で開始される正規表現の構築。
* Regexp Example::           複雑な正規表現の解説。
* Lax Search::               大文字小文字のような、類似した文字の違いを検索で無視する。
* Replace::                  一部またはすべてのマッチを検索または置換する。
* Other Repeating Search::   いくつかの正規表現にマッチするすべてを処理する。
* Search Customizations::    検索のさまざまなカスタマイズ。


File: emacs-ja.info,  Node: Incremental Search,  Next: Nonincremental Search,  Up: Search

15.1 インクリメンタル検索
=========================

Emacsにおける重要な検索コマンドは、“インクリメンタル検索(isearch:
incremental search)”です。これは検索する文字列の最初の文字をタイプすると
、すぐに検索が開始されます。検索文字列をタイプしていくにつれて、Emacsは
その文字列(それまでに入力した文字列)がどこにあるかを表示します。望む場所
を特定するのに充分な文字列をタイプしたところで、検索をストップできます。
次に何をするかによって、明示的な<RET>により検索を終えたり、続けることが
できます。

‘C-s’
     前方にインクリメンタル検索します(‘isearch-forward’)。
‘C-r’
     後方にインクリメンタル検索します(‘isearch-backward’)。

   メニューバーの‘Edit->Search’メニューからインクリメンタル検索を呼び出
すこともできます。

* Menu:

* Basic Isearch::            基本的なインクリメンタル検索コマンド。
* Repeat Isearch::           同じ文字列を再度検索する。
* Isearch Yank::             検索文字列にテキストを取り込んだり、検索文字列を編集するコマンド。
* Error in Isearch::         文字列が見つからなかったとき。
* Special Isearch::          インクリメンタル検索での特別な入力。
* Not Exiting Isearch::      プレフィクス引数とスクロールコマンド。
* Isearch Minibuffer::       ミニバッファーヒストリーのインクリメンタル検索。


File: emacs-ja.info,  Node: Basic Isearch,  Next: Repeat Isearch,  Up: Incremental Search

15.1.1 インクリメンタル検索の基本
---------------------------------

‘C-s’
     インクリメンタル検索を開始します(‘isearch-forward’)。
‘C-r’
     逆向きのインクリメンタル検索を開始します(‘isearch-backward’)。

   ‘C-s’ (‘isearch-forward’)は、前方へのインクリメンタル検索を開始します
。これはキーボードから文字を読み取り、タイプした文字が最初に出現するバッ
ファーの位置に、ポイントを移動します。

   たとえば‘C-s’とタイプした後に‘F’をタイプすると、検索を開始したバッフ
ァーのポイント位置より前方にある、最初の‘F’にカーソルを移動します。つぎ
に‘O’をタイプすると、前方にある最初の‘FO’にカーソルが移動します。この場
合、‘FO’の‘F’は、前に見つかった‘F’と同じ位置である必要はありません。もう
一度‘O’をタイプすると、カーソルは最初の‘FOO’に移動します。

   各ステップでEmacsは“カレントマッチ(current match: 現在のマッチ)”(検索
文字列にマッチしたバッファーのテキスト)を、‘isearch’フェイス(*note
Faces::を参照してください)でハイライトします。このハイライトをカスタマイ
ズするさまざまなオプションについては、*note Search Customizations::を参
照してください。その時点での検索文字列はエコーエリアにも表示されます。

   検索文字列を間違ってタイプしたときは、<DEL>をタイプします。<DEL>をタ
イプするごとに、検索文字列の最後の文字が取り消されます。失敗した検索への
対処についての詳細は、*note Error in Isearch::を参照してください。

   検索により到達した位置に満足したら、<RET>をタイプします。これは検索を
ストップして、検索により移動した位置にカーソルを残します。検索とは関係な
いコマンドも、検索をストップして、そのコマンドが実行されます。つまり
‘C-a’は検索をexitして行の先頭に移動し、矢印キーをタイプすると検索を
exitして対応する移動コマンドが処理される、などとなります。<RET>で検索を
終える必要があるのは、次のコマンドが印字文字をタイプするコマンドのときだ
けです。<DEL>、<RET>および他のいくつかの文字(‘C-q’、‘C-w’、‘C-r’、
‘C-s’、‘C-y’、‘M-y’、‘M-r’、‘M-c’、‘M-e’、および以下で説明する文字)は、
検索で特別な意味を持っています。検索をexitするコマンドを微調整できます。
*note Not Exiting Isearch::を参照してください。

   特別な例外として、検索文字列が空のときに<RET>を入力すると、非インクリ
メンタル検索(*note Nonincremental Search::を開始します(これは"カスタマイ
ズ可能"です。*note Search Customizations::を参照してください)。

   検索を中止して検索を開始した位置に戻るには、‘<ESC> <ESC> <ESC>’
(‘isearch-cancel’)、または‘C-g C-g’ (‘isearch-abort’)とタイプしてくださ
い。

   インクリメンタル検索を終了するとき、ポイントの元の位置をマークをアク
ティブにせず(ただしマークがすでにアクティブではなかったときだけ)に、マー
クリングに追加します。これにより、‘C-u C-<SPC>’、または‘C-x C-x’を使って
、検索を開始する前の位置に戻ることができます。*note Mark Ring::を参照し
てください(Emacsはマークがすでにアクティブでないときだけ、これを行ないま
す。検索を開始したときにマークがアクティブな場合は、‘C-u C-<SPC>’と‘C-x
C-x’の両方とも、マークに戻ります)。

   後方に検索するには、‘C-s’で検索を開始するかわりに、‘C-r’
(‘isearch-backward’)を使います。前方検索が検索を開始した位置より前方にあ
る最初のマッチを探すように、後方検索は検索を開始した位置より後方にある最
後のマッチを探します。


File: emacs-ja.info,  Node: Repeat Isearch,  Next: Isearch Yank,  Prev: Basic Isearch,  Up: Incremental Search

15.1.2 インクリメンタル検索の繰り返し
-------------------------------------

前方に‘FOO’を検索してマッチしたが、それは探しているマッチではなく、探し
ているのはバッファーのもっと前方に出現する‘FOO’だとしましょう。ここでも
う1度‘C-s’をタイプすることにより、検索文字列が次に出現する場所に移動しま
す。これは何回でも繰り返すことができます。もしタイプしすぎたときは、
‘C-s’を<DEL>で取り消すことができます。同様に後方へのインクリメンタル検索
では、‘C-r’により後方検索が繰り返されます。

   インクリメンタル検索中に手を止めて眺めてみると、検索文字列にたいする
カレントマッチ以外に、スクリーンに表示されている他のマッチもハイライトさ
れていることがわかります。これは検索するために、何回‘C-s’または‘C-r’を繰
り返せばよいのか予測しやすくするためです。その他のマッチは、カスタマイズ
可能なフェイス‘lazy-highlight’ (*note Faces::を参照してください)を使って
、現在のマッチとは異なってハイライトされます。この機能を無効にするには、
‘isearch-lazy-highlight’に‘nil’をセットしてください。マッチのハイライト
に関連するその他のカスタマイズについては、*note Search Customizations::を
参照してください。

   検索を終了した後、同じ文字列を再度検索するには、‘C-s C-s’とタイプしま
す。最初の‘C-s’はインクリメンタル検索を呼び出し、2回目の‘C-s’は最後に検
索した文字列の再検索を意味します。同様に、‘C-r C-r’は最後に検索した文字
列を後方に検索します。最後に検索された文字列の決定では、その文字列が
‘C-s’で検索されたのか、‘C-r’で検索されたのかは問題ではありません。

   前方に検索していて、検索している対象が検索開始点より後方にあるのに気
付いたときは、検索文字列を変更すること無く、‘C-r’で後方検索に切り替える
ことができます。同様に後方検索で‘C-s’をタイプすると、前方検索に切り替わ
ります。

   検索が失敗したとき、バッファーの先頭から検索を再開するには、もう一度
‘C-s’をタイプします。逆向きの繰り返し検索が失敗したときは、‘C-r’でバッフ
ァーの最後から検索を再開します。これは“wrapping around(巻き直し)”と呼ば
れ、これが発生すると、‘Wrapped’という単語が検索プロンプトに表示されます
。検索を続けて元の検索開始ポイントを通過すると、‘Overwrapped’に変化しま
す。これはすでに見たマッチを再訪していることを意味します。

   以前に検索した文字列を再利用するには、“サーチリング(search ring)”を使
います。コマンド‘M-p’または‘M-n’で、リングを移動して再使用したい文字列を
取り出します。これらのコマンドは、選択されたリング要素の文字列をミニバッ
ファーに残すので、それを編集することができます。‘C-s’と‘C-r’、または
<RET>とタイプすると、その文字列を受け入れて、その文字列にたいする検索を
開始します。サーチリングの中に保存されている、最近使用された検索文字列の
数は、変数‘search-ring-max’で指定され、デフォルトは16です。

   ミニバッファーの現在の検索文字列を、サーチリングのアイテムで置き換え
ずに編集するときは、‘M-e’とタイプするか、ミニバッファーを‘mouse-1’でクリ
ックします。<RET>、‘C-s’、‘C-r’とタイプすれば、編集を終了してそれを検索
できます。バッファーの検索を開始したポイントの後に続く文字を検索文字列に
追加するには、‘C-f’または‘<RIGHT>’とタイプしてください。


File: emacs-ja.info,  Node: Isearch Yank,  Next: Error in Isearch,  Prev: Repeat Isearch,  Up: Incremental Search

15.1.3 インクリメンタル検索でのyank
-----------------------------------

多くのケースで、ポイントの近くにあるテキストを検索文字列として使いたいこ
とがあるでしょう。このサブセクションで説明されているコマンドにより、これ
を便利に行なえるようになります。

   ‘C-w’ (‘isearch-yank-word-or-char’)は、検索された文字列のポイントの次
の文字または単語を、検索文字列に追加します。これはポイント位置にあるテキ
ストを検索する、簡単な方法です(コピーする対象を文字または単語のどちらに
するかの決定は、発見的に行われます)。

   同様に‘M-s C-e’ (‘isearch-yank-line’)は、検索文字列にカレント行の残り
の部分を追加します。ポイントが既に行末にある場合、次の行が追加されます。
プレフィクス引数Nを指定すると、次のN行を追加します。

   インクリメンタル検索での‘C-y’ (‘isearch-yank-kill’)は、カレントkillを
検索文字列に追加します。‘C-y’の後に‘M-y’ (‘isearch-yank-pop’)が呼び出さ
れると、追加するテキストを、もっと前にkillされたものに置き換えます。これ
は通常の‘M-y’ (‘yank-pop’)コマンドと似ています(*note Yanking::を参照して
ください)。エコーエリアで‘mouse-2’をクリックすることにより、はカレントの
X選択(*note Primary Selection::を参照してください)を検索文字列に追加しま
す(‘isearch-yank-x-selection’)。

   ‘C-M-w’ (‘isearch-del-char’)は検索文字列の最後の文字を削除し、‘C-M-y’
(‘isearch-yank-char’)は検索されたポイントの後の文字を追加します。ポイン
トの後ろの文字を追加する他の方法は、‘M-e’(*note Repeat Isearch::を参照し
てください)でミニバッファーに移動してから、検索文字列の最後で‘C-f’か
‘<RIGHT>’をタイプします。‘C-f’か‘<RIGHT>’をタイプするたびに、ポイントの
後の文字が検索文字列に順次追加されます。

   検索が大文字小文字を区別しない場合は通常、検索文字列にyankされるテキ
ストは小文字に変換されるので、検索は大文字小文字を区別しないままです
(*note case folding: Lax Search.を参照してください)。しかし、変数
‘search-upper-case’ (*note search-upper-case: Lax Search.を参照してくだ
さい)の値が‘not-yanks’以外の場合には、この小文字への変換は無効になります
。


File: emacs-ja.info,  Node: Error in Isearch,  Next: Special Isearch,  Prev: Isearch Yank,  Up: Incremental Search

15.1.4 インクリメンタル検索でのエラー
-------------------------------------

文字列が見つからなかった場合、エコーエリアに‘Failing I-Search’と表示され
て、文字列とできるかぎりマッチした位置に、カーソルが移動します。つまり
‘FOOT’を検索して‘FOOT’がない場合、カーソルは‘FOOL’という文字列の‘FOO’の
後ろに移動します。エコーエリアではマッチに失敗した検索文字列の一部が、フ
ェイス‘isearch-fail’を使ってハイライトされます。

   その時に行うことができる、いくつかの選択肢があります。もし文字列が間
違っている場合は、文字列を訂正するために、<DEL>でテキストを削除したり、
‘M-e’とタイプして、それを編集することができます。もし見つかった位置が望
む位置なら、<RET>をタイプしてその位置に留まることができます。または
‘C-g’をタイプして、検索文字列から検索できなかった文字(‘FOOT’の中の‘T’)を
取り除き、検索された部分の文字列(‘FOOT’の中の‘FOO’)を残します。その位置
でもう1回‘C-g’をタイプすると、検索全体を取り消し、ポイントは検索を開始し
た位置に戻ります。

   終了コマンドの‘C-g’は、検索において特別な処理を行います。このコマンド
の動作は、検索の状況に依存します。もし指定した文字列の検索が成功して、さ
らに検索文字の入力を待っているとき、‘C-g’は検索全体を取り消して、カーソ
ルを検索を開始したときの位置に移動します。検索文字列に検索に失敗した文字
が含まれているときに、‘C-g’がタイプされたときは、検索文字列から検索に失
敗した文字が取り除かれます。後に残るのは検索に成功した文字列で、さらに検
索文字の入力を待っているので、先のケースと同様、2回目の‘C-g’で検索全体が
取り消されます。


File: emacs-ja.info,  Node: Special Isearch,  Next: Not Exiting Isearch,  Prev: Error in Isearch,  Up: Incremental Search

15.1.5 インクリメンタル検索の特別な入力
---------------------------------------

前のサブセクションで説明した文字に加えて、インクリメンタル検索のときにタ
イプする文字列の中には、特別な効果をもつものがあります。ここではそれらに
ついて説明します。

   lax space matching(「だらしない、ゆるんだ、緩慢な、締まりのない」スペ
ースのマッチング。*note lax space matching: Lax Search.を参照してくださ
い)を切り替えるには、‘M-s <SPC>’とタイプします。

   検索でcase sensitivity(大文字小文字を区別するか)を切り替えるには、
‘M-c’または‘M-s c’とタイプします。*note case folding: Lax Search.を参照
してください。検索文字列が大文字を含む場合、デフォルトではその検索は
case-sensitive(大文字小文字を区別)します。

   検索が似ている文字、または等価な文字を考慮するかどうかを切り替えるに
は、‘M-s '’とタイプします。*note character folding: Lax Search.を参照し
てください。検索文字列にアクセント付きの文字が含まれる場合、その検索の間
、character foldingは無効になります。

   非表示のテキストを検索するかしないかは、‘M-s i’
(‘isearch-toggle-invisible’)とタイプして切り替えることができます。*note
Outline Search::を参照してください。

   インクリメンタル検索で、非正規表現による検索と、正規表現による検索を
切り替えるには、‘M-r’、または‘M-s r’ (‘isearch-toggle-regexp’)とタイプし
ます。*note Regexp Search::を参照してください。

   シンボルモードを切り替えるには、‘M-s _’とタイプします。*note Symbol
Search::を参照してください。

   改行文字を検索するには、検索文字列の途中で‘C-j’とタイプします。

   非ASCII文字を検索するには、以下の方法の1つを使います:

   • ‘C-q’に続けて、非グラフィック文字か8進数字をタイプします。これは
     ‘C-q’を使ってバッファーに文字を挿入するのと同様に、検索文字列にタイ
     プする文字を追加します(*note Inserting Text::を参照してください)。
     たとえばインクリメンタル検索で‘C-q C-s’をタイプすると、検索文字列に
     文字‘control-S’が追加されます。

   • ‘C-x 8 <RET>’に続けて、Unicode名か16進のコードポイントをタイプしま
     す。これは通常の‘insert-char’コマンドと同様に、検索文字列に指定した
     文字を追加します(*note Inserting Text::を参照してください)。

   • 入力メソッド(IM: input method)を使います(*note Input Methods::を参
     照してください)。検索を開始したとき、カレントバッファーで入力メソッ
     ドが有効の場合、ミニバッファーで検索もL字列をタイプするときにも、同
     じメソッドがアクティブになるでしょう。検索文字列をタイプするとき、
     ‘C-\\’ (‘isearch-toggle-input-method’)で、入力メソッドを切り替える
     ことができます。非デフォルトの入力メソッドに切り替えるには、‘C-^’
     (‘isearch-toggle-specified-input-method’)を使います。これは入力メソ
     ッドの名前を尋ねます。インクリメンタル検索で入力メソッドがアクティ
     ブのとき、検索プロンプトには以下のようなニーモニックが含まれます。

          I-search [IM]:

     IMはアクティブな入力メソッドのニーモニックです。インクリメンタル検
     索で入力メソッドを有効にすると、カレントバッファーでも入力メソッド
     が有効のまま残ります。

   インクリメンタル検索の中で‘M-s o’とタイプすることにより、カレントの検
索文字列で‘occur’を実行する、‘isearch-occur’が呼び出されます。*note
occur: Other Repeating Search.を参照してください。

   インクリメンタル検索で‘M-%’をタイプすると、‘query-replace’または
‘query-replace-regexp’が呼び出され(検索モードに依存します)、現在の検索文
字が置換対象になります。負のプレフィクス引数は、後方への置換を意味します
。*note Query Replace::を参照してください。

   インクリメンタル検索で‘M-<TAB>’をタイプすると、‘isearch-complete’が呼
び出され、サーチリング(以前に使用された検索文字列)を補完リストとして使っ
て、検索文字列の補完を試みます。*note Completion::を参照してください。多
くのオペレーティングシステムでは、キーシーケンス‘M-<TAB>’はウィンドウマ
ネージャーに捕えられます。その場合、これを使うには‘isearch-complete’を、
他のキーシーケンスに再バインドする必要があります(*note Rebinding::を参照
してください)。

   ディスプレーで最後に検索した文字列にたいするマッチをハイライトしたま
ま、検索をexitできます。これを行なうには、‘M-s h r’
(‘isearch-highlight-regexp’)とタイプします。これは最後の検索文字列を継承
するregexpと、ハイライトに表示するフェイスの入力を求めて、それらを引数と
して‘highlight-regexp’ (*note Highlight Interactively::を参照してくださ
い)を実行します。ハイライトを除去するには、‘M-s h u’
(‘unhighlight-regexp’)とタイプしてください。

   インクリメンタル検索がアクティブのとき、‘C-h C-h’
(‘isearch-help-map’)とタイプすると、特別なキーバインドのリストを含む、対
話的なヘルプにアクセスできます。これらのキーバインドは、キーマップ
‘isearch-mode-map’の一部です(*note Keymaps::を参照してください)。


File: emacs-ja.info,  Node: Not Exiting Isearch,  Next: Isearch Minibuffer,  Prev: Special Isearch,  Up: Incremental Search

15.1.6 インクリメンタル検索を終了させない
-----------------------------------------

このサブセクションでは、検索で特別な意味をもたないコマンドが、そのコマン
ドを実行する前に、検索をexitするかどうかを制御する方法を説明します。また
、(たとえそれらがインクリメンタル検索の一部ではなくても)カレントのインク
リメンタル検索をexitせずにタイプできる、2つのカテゴリーに属するコマンド
を説明します。

   インクリメンタル検索によりバインドされていないコマンドをタイプすると
通常、そのコマンドを実行する前に検索をexitします。したがって、そのコマン
ドは検索を呼び出したときのバッファーにたいして処理を行なうことになります
。しかし、変数‘search-exit-option’を‘nil’にカスタマイズした場合、(インク
リメンタル検索により解釈されないような)タイプした文字は、単に検索文字列
に追加されます。これにより、通常は検索をexitして、その文字にバインドされ
ているコマンドをそのバッファーにたいして呼び出す、‘C-a’のような制御文字
を検索文字列に含めることができるようになります。

プレフィクス引数
     インクリメンタル検索でプレフィクス引数を指定したコマンドをタイプす
     ると、デフォルトではその引数は次の検索アクションに適用されるか、検
     索をexitするコマンドに渡されます。他の言い方をすると、プレフィクス
     引数の入力自体は、検索を終了させません。

     以前のバージョンのEmacsでは、プレフィクス引数の入力は常に検索を終了
     させていました。この振る舞いに戻すには、変数
     ‘isearch-allow-prefix’に‘nil’をセットしてください。

     ‘isearch-allow-scroll’が非‘nil’のとき(以下を参照)、プレフィクス引数
     は上で説明したようなデフォルト動作をします。つまり、たとえ
     ‘isearch-allow-prefix’が‘nil’でも、プレフィクス引数は検索を終了させ
     ません。

スクロールコマンド
     通常スクロールコマンドは、インクリメンタル検索を終了させます。変数
     ‘isearch-allow-scroll’を非‘nil’値に変更すると、スクロールバーや
     ‘C-v’、‘M-v’、‘C-l’のようなスクロールコマンド(*note Scrolling::を参
     照してください)が利用可能になります。これは、これらのコマンドをバウ
     ンドされたキーシーケンスで呼び出したときだけ適用されます。つまり
     ‘M-x’は依然として検索を終了させます。これらのコマンドには、通常の方
     法でプレフィクス引数を与えることができます。この機能ではカレントマ
     ッチが表示されない位置にスクロールすることはできません。

     ‘isearch-allow-scroll’の機能は、正確にはスクロールではないが、テキ
     ストが表示されるスクリーン位置に影響する、‘C-x 2’
     (‘split-window-below’)や‘C-x ^’ (‘enlarge-window’)のような、コマン
     ドにも効果を及ぼします。これはコマンド名の‘isearch-scroll’プロパテ
     ィが非‘nil’のコマンドに適用されます。そのため、どのコマンドが影響を
     受けるかは、それらのプロパティを変更して制御できます。

     たとえば将来のEmacsセッションも含めて、インクリメンタル検索中に‘C-h
     l’を使えれば便利だと思ったら、まず‘C-h c’で何のコマンドが実行される
     か調べて(*note Key Help::を参照してください)、それが
     ‘view-lossage’だとわかります。その後はinitファイルに以下を追加しま
     す(*note Init File::を参照してください)。

          (put 'view-lossage 'isearch-scroll t)

     この機能はポイント、バッファー内容、マッチデータ、カレントバッファ
     ーや選択されているウィンドウ・フレームを変更しない任意のコマンドに
     適用できます。そして、そのコマンド自体がインクリメンタル検索を行っ
     てはなりません。この機能は、‘isearch-allow-scroll’が‘nil’(デフォル
     ト)の場合は無効です。


File: emacs-ja.info,  Node: Isearch Minibuffer,  Prev: Not Exiting Isearch,  Up: Incremental Search

15.1.7 ミニバッファーの検索
---------------------------

ミニバッファーがアクティブのときインクリメンタル検索を開始すると、
Emacsはミニバッファーの内容を検索します。通常のバッファーにたいする検索
とは異なり、エコーエリアはミニバッファーの表示に使われているので、検索文
字列はエコーエリアには表示されません。

   ミニバッファーでのインクリメンタル検索が失敗すると、ミニバッファーヒ
ストリーを検索します。*note Minibuffer History::を参照してください。ミニ
バッファーとミニバッファーのヒストリーは、一番古いヒストリー要素が最初で
、カレントのミニバッファーが最後にある、一連のページとして視覚化すること
ができます。前方検索の‘C-s’は前方、つまり新しいページを検索し、後方検索
の‘C-r’は後方、つまり古いページを検索します。普通のバッファーの検索と同
様、検索が失敗すると、最後から最初のページ、またはその逆に巻き直して検索
します。

   カレントマッチがヒストリーの要素にあった場合、ヒストリーの要素はミニ
バッファーに取り出されます。インクリメンタル検索を正常に終了(たとえば
<RET>をタイプ)すれば、それはミニバッファーに残ります。検索を取り消すのは
‘C-g’で、これによりミニバッファーの内容は検索を開始したときのものに復元
されます。


File: emacs-ja.info,  Node: Nonincremental Search,  Next: Word Search,  Prev: Incremental Search,  Up: Search

15.2 非インクリメンタル検索
===========================

Emacsには、従来式の非インクリメンタル検索もあります。これは検索を開始す
る前に、検索文字列全体を入力する必要があります。

‘C-s <RET> STRING <RET>’
     STRINGを検索します。
‘C-r <RET> STRING <RET>’
     後方にSTRINGを検索します。

   非インクリメンタル検索を開始するには、最初に‘C-s <RET>’をタイプします
。これにより、検索文字列を読みとるために、ミニバッファーに移動します。検
索文字列の入力を終了して検索を開始するには、<RET>をタイプします。文字列
が見つからなかったとき、検索コマンドはエラーをシグナルします。

   ‘C-s <RET>’とタイプすると、‘C-s’は通常どおりインクリメンタル検索を呼
び出します。しかし、このコマンドは指定した文字列が空のとき、非インクリメ
ンタル検索を行うコマンドを呼び出すよう、プログラムされています(そのよう
な用途以外に空の引数は無意味です)。‘C-r <RET>’も同様に、後方に非インクリ
メンタル検索を行なうコマンドを呼び出します。

   メニューバーの‘Edit->Search’メニューから非インクリメンタル検索を呼び
出すこともできます。

   よりシンプルな2つのコマンド、‘M-x search-forward’と‘M-x
search-backward’を使うこともできます。これらのコマンドは指定した文字をリ
テラルとして検索し、case folding(検索で大文字小文字を区別するか)を除く
lax-search機能(*note Lax Search::を参照してください)をサポートしません。


File: emacs-ja.info,  Node: Word Search,  Next: Symbol Search,  Prev: Nonincremental Search,  Up: Search

15.3 単語検索
=============

“単語検索(word search)”は、単語の並びを、その間にある区切り文字の種類と
は無関係に検索します。たとえば検索文字列に、1つのスペースで区切られた2つ
の単語を入力すると、2つの単語を区切るのが、1つまたはそれ以上のスペース、
改行文字、およびそれ以外の区切り文字の場合にもマッチします。これはテキス
ト文書を検索するとき特に有用です。なぜなら検索する単語が改行で区切られて
いるのか、スペースで区切られているのか考慮しなくてもよいからです。プログ
ラミング言語のためのメジャーモード、およびその他の特別なメジャーモード、
そのモードの構文的なニーズに適合するように、単語の定義が変更されているか
もしれないことに注意してください。

‘M-s w’
     インクリメンタル検索がアクティブのとき、単語検索モードに切り替えま
     す(‘isearch-toggle-word’)。非アクティブのときは、前方へのインクリメ
     ンタルな単語検索を開始します(‘isearch-forward-word’)。
‘M-s w <RET> WORDS <RET>’
     非インクリメンタルな単語検索を使って、WORDSを前方検索します。
‘M-s w C-r <RET> WORDS <RET>’
     非インクリメンタルな単語検索を使って、WORDSを後方検索します。
‘M-s M-w’
     リージョン内のテキストにたいして、Webを検索します。

   前方へのインクリメンタルな単語検索を開始するには、‘M-s w’とタイプしま
す。インクリメンタル検索が非アクティブの場合、これはコマンド
‘isearch-forward-word’を実行します。インクリメンタル検索がすでにアクティ
ブの場合(前方か後方かにかかわらず)、‘M-s w’は検索の方向と現在の検索文字
列は変更せずに、単語検索に切り替えます。単語検索をオフに切り替えるには、
再度‘M-s w’をタイプしてください。

   非インクリメンタルな単語検索を開始する場合、前方検索は‘M-s w <RET>’、
後方検索は‘M-s w C-r <RET>’をタイプします。これらはコマンド
‘word-search-forward’、または‘word-search-backward’を実行します。

   インクリメンタルな単語検索と、非インクリメンタルな単語検索では、マッ
チを見つける方法に若干の違いがあります。非インクリメンタルな単語検索では
、検索文字列の各単語は、単語全体に厳密に一致しなければなりません。インク
リメンタルな単語検索では、マッチの規則は緩くなります。検索文字列をタイプ
するとき、最初と最後の単語は、単語全体にマッチする必要はありません。これ
はタイプする度にマッチを処理するためです。これは(カーソルがある)カレント
マッチ以外のマッチ(lazy matches。*note Incremental Search::を参照してく
ださい)には適用されません。それらは単語全体がマッチしなければハイライト
されません。検索文字列をタイプしている間は、‘C-s’のような検索繰り返しキ
ーを使用するまで、検索プロンプトに‘Pending’が表示されます。

   単語検索コマンドは、character foldingを処理せず、lax whitespace
matching(*note lax space matching: Lax Search.を参照してください)が効果
をもたないように切り替えます。

   リージョン内のテキストにたいしてWebを検索するには、‘M-s M-w’とタイプ
します。このコマンドは、変数‘eww-search-prefix’により指定されたURLの検索
エンジンを使用して、リージョン内の単語にたいするインターネット検索を行な
います(*note EWW: (eww)Basics.を参照)。リージョンがアクティブでない場合
、このコマンドはユーザーに検索するURL、またはキーワードの入力を求めます
。


File: emacs-ja.info,  Node: Symbol Search,  Next: Regexp Search,  Prev: Word Search,  Up: Search

15.4 シンボル検索
=================

“シンボル検索(symbol search)”は、通常の検索と似ていますが、検索の境界が
シンボルの境界にマッチしていなければなりません。“シンボル”の意味は、メジ
ャーモードのコンテキストに依存しており、Emacs LispモードでのLispシンボル
のように、通常はソースコードのトークンを参照します。たとえばLispシンボル
‘forward-word’をインクリメンタルなシンボル検索すると、これは
‘isearch-forward-word’にはマッチしません。そのため、この機能は主にソース
コードの検索に有用です。

‘M-s _’
     インクリメンタル検索がアクティブのとき、シンボル検索モードに切り替
     えます(‘isearch-toggle-symbol’)。非アクティブのときは、前方へのイン
     クリメンタルなシンボル検索を開始します(‘isearch-forward-symbol’)。
‘M-s .’
     ポイントの近くにあるシンボルを、検索文字列の初期値に追加して、前方
     へのインクリメンタルなシンボル検索を開始します。
‘M-s _ <RET> SYMBOL <RET>’
     SYMBOLにたいして、前方への非インクリメンタルな検索をします。
‘M-s _ C-r <RET> SYMBOL <RET>’
     SYMBOLにたいして、後方への非インクリメンタルな検索をします。

   前方へのインクリメンタルなシンボル検索を開始するには、‘M-s _’(ポイン
トの近くにシンボルがあるときは‘M-s .’)をタイプします。インクリメンタル検
索が非アクティブのときは、コマンド‘isearch-forward-symbol’が実行されます
。すでにインクリメンタル前方へのインクリメンタルなシンボル検索を開始する
には、‘M-s _’(ポイントの近くにシンボルがあるときは‘M-s .’)をタイプします
。インクリメンタル検索が非アクティブのときは、コマンド
‘isearch-forward-symbol’が実行されます。すでにインクリメンタル検索がアク
ティブのとき、‘M-s _’は検索方向と現在の検索文字列を維持した状態で、シン
ボル検索に切り替えます(もう一度‘M-s _’をタイプすると、シンボル検索を無効
にできます)。インクリメンタルなシンボル検索では、検索み文字列をタイプす
る間は、検索文字列の先頭がシンボルの先頭にマッチだけが必要であり、
‘C-s’のような検索繰り返しキーを使用するまでは検索プロンプトに‘Pending’が
表示されます。

   非インクリメンタルなシンボル検索は、前方への検索は‘M-s _ <RET>’、後方
への検索は‘M-s _ C-r <RET>’をタイプします。非インクリメンタル検索では、
文字列の先頭と最後が、シンボルの先頭と最後にマッチする必要があります。

   シンボル検索コマンドは、character foldingを処理せず、lax whitespace
matching(*note lax space matching: Lax Search.を参照してください)が効果
をもたないように切り替えます。


File: emacs-ja.info,  Node: Regexp Search,  Next: Regexps,  Prev: Symbol Search,  Up: Search

15.5 正規表現検索
=================

“正規表現”(regular expression: “regexp”と略します)とは、文字列にマッチさ
せるための代替の文字列クラスを示すパターンです。Emacsはregexpにマッチす
る検索を、インクリメンタル、非インクリメンタルの両方で提供します。正規表
現の構文は、次のセクションで説明します。

‘C-M-s’
     インクリメンタルなregexp検索を開始します
     (‘isearch-forward-regexp’)。
‘C-M-r’
     逆方向のインクリメンタルなregexp検索を開始します
     (‘isearch-backward-regexp’)。

   regexpにたいするインクリメンタル検索は、‘C-M-s’
(‘isearch-forward-regexp’をタイプするか、プレフィクス引数(引数の値は何で
もよい)を指定して、‘C-s’を呼び出します。前方へのインクリメンタル検索中は
、‘M-r’をタイプします。このコマンドは‘C-s’と同様に、検索文字列をインクリ
メンタルに読みとりますが、検索文字列に正確に一致するバッファーのテキスト
を検索するのではなく、検索文字列をregexpとして扱います。検索文字列にテキ
ストを追加する度に、regexpは長くなり、新しいregexpを検索します。後方への
regexp検索には、‘C-M-r’(‘isearch-backward-regexp’)またはプレフィクス引数
を指定した‘C-r’を使います。後方へのインクリメンタル検索中は‘M-r’を使いま
す。

   通常のインクリメンタル検索の特別なキーシーケンス(*note Special
Isearch::)は、インクリメンタルなregexp検索でも同じようなことを行います。
たとえば検索開始直後に‘C-s’をタイプすると、最後に行ったインクリメンタル
検索で使ったregexpで、前方検索を行います。インクリメンタルなregexpと非
regexp検索は、独立したデフォルトを持ちます。これらは別のサーチリングも持
っており、これには‘M-p’と‘M-n’でアクセスできます。サーチリングに保存され
る検索regexpの最大数は、‘regexp-search-ring-max’の値により決定され、デフ
ォルトは16です。

   通常のインクリメンタル検索とは異なり、インクリメンタルregexp検索は、
デフォルトではlax space matchingを使いません。この機能を切り替えるには、
‘M-s <SPC>’ (‘isearch-toggle-lax-whitespace’)を使います。そうするとイン
クリメンタルregexp検索での<SPC>は、1つ以上の空白文字の並びにマッチするよ
うになります。変数‘search-whitespace-regexp’は、lax space matchingにたい
するregexpを指定します。*note Special Isearch::を参照してください。

   通常のインクリメンタル検索とは異なり、インクリメンタルなregexp検索で
はcharacter folding(*note Lax Search::を参照してください)を使用できませ
ん(インクリメンタルregexp検索の途中で、‘M-s '’によりcharacter foldingを
切り替えた場合、検索は非regexp検索となり、タイプした検索パターンはリテラ
ル文字列として解釈されます)。

   インクリメンタルregexp検索では、検索文字列の追加によりカーソルが前に
戻され、最初から検索しなおされることがありえます。たとえば検索文字列
‘foo’に‘\|bar’を追加すると、カーソルは‘foo’から、それより前にある最初の
‘bar’に戻ります。*note Regexps::を参照してください。

   前方および後方へのregexp検索は、対照的ではありません。なぜならEmacsで
のregexpに対するマッチは常に前方へ処理され、regexpの先頭から開始されるか
らです。したがって前方へのregexp検索は前方にスキャンし、可能性のある開始
位置から前方へとマッチを試みます。後方へのregexp検索は後方へスキャンし、
可能性のある開始位置から前方へとマッチを試みます。これらの検索手法はミラ
ーイメージではありません。

   regexpにたいする非インクリメンタルな検索は、コマンド
‘re-search-forward’および‘re-search-backward’で行われます。これらのコマ
ンドは‘M-x’から呼び出すか、インクリメンタルregexp検索からの‘C-M-s
<RET>’および‘C-M-r <RET>’で呼び出します。‘M-x’を使用してこれらのコマンド
を呼び出した場合は、指定したregexpを厳密に検索するので、case foldingを除
くlax-search機能(*note Lax Search::を参照してください)はサポートされませ
ん

   プレフィクス引数を指定したインクリメンタルregexp検索は、
‘isearch-forward’や‘isearch-backward’のような、通常の文字列を検索します
。*note Incremental Search::を参照してください。


File: emacs-ja.info,  Node: Regexps,  Next: Regexp Backslash,  Prev: Regexp Search,  Up: Search

15.6 正規表現の構文
===================

このセクション(および、マニュアル全般)では、ユーザーが通常使う正規表現の
機能を説明します。主にLispプログラムで使用される追加の機能については、
*note (elisp)Regular Expressions::を参照してください。

   正規表現は、いくつかの特殊文字と、それ以外の“普通”の文字からなる構文
を持ちます。通常の文字はそれと同じ文字にマッチし、それ以外の文字にはマッ
チしません。特殊文字は、‘$^.*+?[\’です。文字‘]’は、文字候補を終了させる
場合は特殊文字です(以下参照)。文字‘-’は、文字候補の中では特殊文字です。
正規表現の中に現れるその他の文字は、前に‘\’がついてない限り普通の文字で
す(Lispプログラム内で正規表現を使う場合、‘\’は2つ記述しなければなりませ
ん。このセクションの最後にある例を参照してください)。

   たとえば‘f’は特殊文字ではなく普通の文字なので、正規表現中の‘f’は文字
列‘f’にマッチし、他の文字列にはマッチしません(文字列‘ff’にはマッチ_しま
せん_)。同様に正規表現中の‘o’は、‘o’だけにマッチします(大文字小文字を区
別しない場合、これらのregexpは‘F’や‘O’にもマッチしますが、これを例外とし
てではなく、“同じ文字列”を一般化したものと考えます)。

   2つの正規表現AとBを結合できます。結合した結果は、Aが先頭の適当な部分
に一致して、Bが残りの部分に一致する正規表現となります。些細な例としては
、‘f’と‘o’という正規表現を結合すると、正規表現‘fo’となり、これは文字列
‘fo’だけにマッチします。ここまでは普通です。これより複雑ことを行うには、
特殊文字を使う必要があります。以下にリストを示します。

‘.’ (ピリオド)
     これは改行文字以外の任意の1文字にマッチする特殊文字です。たとえば正
     規表現‘a.b’は、最初が‘a’で最後が‘b’の3文字の文字列にマッチします。

‘*’
     単独では使用されません。これは接尾演算子で、前の正規表現の任意の回
     数、可能な限り多くの回数を含めた繰り返しを意味します。したがって
     ‘o*’は任意の個数の‘o’にマッチし、‘o’がない場合(0個の場合)も含めてマ
     ッチします。

     ‘*’は常に可能な限り_小さな_、前置表現に適用されます。したがって
     ‘fo*’は‘fo’の繰り返しではなく‘o’の繰り返しです。この正規表現は‘f’、
     ‘fo’、‘foo’、...にマッチします。

     マッチングにより構成される‘*’は、見つけられるだけの反復回数へと、直
     ちに処理されます。その後でパターンの残りの部分の処理を続けます。こ
     れが失敗すると、バックトラッキングが発生します。‘*’の反復回数をいく
     つか捨てて、パターンの残りの部分がマッチするように構成を変更します
     。たとえば文字列‘caaar’にたいして‘ca*ar’をマッチさせる場合、まず最
     初に‘a*’を、3つすべての‘a’にマッチさせます。しかしパターンの残りの
     部分は‘ar’ですが、マッチさせるために残っているのは‘r’だけなので、こ
     のマッチは失敗します。かわりに‘a*’を2つの‘a*’だけにマッチさせます。
     この選択により、regexpの残りの部分のマッチが成功します。

‘+’
     これは‘*’と同様に接尾演算子ですが、前置表現に最低1回マッチしなけれ
     ばならない点が異なります。したがって‘ca+r’は‘car’、‘caaaar’にマッチ
     しますが、‘cr’にはマッチしません。一方‘ca*r’は、これら3つすべての文
     字列にマッチします。

‘?’
     これは‘*’と同様に接尾演算子ですが、前置表現が1回出現するか、出現し
     ないかいずれかという点が異なります。したがって‘ca?r’は、‘car’または
     ‘cr’のいずれかになります。

‘*?’, ‘+?’, ‘??’
     これらは上述した演算子の、非“貪欲(greedy)”なタイプの演算子です。通
     常の演算子‘*’、‘+’、‘?’は、regexpがマッチする、できる限り長いマッチ
     を行います。しかしこれらの演算子に‘?’を後置すると、できる限り短いマ
     ッチを行います。

     したがって‘ab*’と‘ab*?’は、両方とも文字列‘a’と文字列‘abbbb’にマッチ
     しますが、文字列‘abbb’にマッチさせたとき、‘ab*’は文字列全体(有効な
     最長マッチ)にマッチしますが、‘ab*?’は‘a’(有効な最短マッチ)だけにマ
     ッチします。

     非貪欲な演算子は、与えられた開始位置から開始される、できるだけ短い
     文字列にマッチします。前方検索では、利用できる一番最初の開始位置は
     、常にカーソルの位置となります。したがって末尾が改行のテキスト
     ‘abbab’にたいして‘a.*?$’を検索すると、文字列全体にマッチします。こ
     れはマッチが最初の‘a’から開始されので、マッチさせることが_できる_の
     です。

‘\{N\}’
     これはN回の繰り返しを指定する接尾演算子です。つまり前置される正規表
     現に、正確にN回連続でマッチしなければなりません。たとえば‘x\{4\}’は
     、文字列‘xxxx’だけにマッチします。

‘\{N,M\}’
     これはN回からM回の繰り返しを指定する接尾演算子です。つまり前置され
     る正規表現が、最低N回、最大M回マッチしなければなりません。Mが省略さ
     れたときは、マッチ回数の上限はありませんが、前置される正規表現は少
     なくともN回マッチしなければなりません。
     ‘\{0,1\}’は、‘?’と同じです。
     ‘\{0,\}’は、‘*’と同じです.
     ‘\{1,\}’は、‘+’と同じです。

‘[ ... ]’
     これは‘[’で始まり‘]’で終わる、“文字集合(character set)”です。

     もっとも簡単なケースでは、2つのカッコの間に指定された文字が、マッチ
     できる文字集合となります。したがって‘[ad]’は1つの‘a’か1つの‘d’にマ
     ッチし、‘[ad]*’は‘a’と‘d’からなる任意の文字列にマッチします(空の文
     字列を含む)。結果として‘c[ad]*r’は、‘cr’、‘car’、‘cdr’、‘caddaar’、
     ...にマッチします。

     文字集合には、開始文字と終了文字の間に‘-’を記述することにより、文字
     の範囲を含めることもできます。したがって‘[a-z]’は、ASCII小文字とな
     ります。文字の範囲と特定の文字の指定を混ぜることもできます。
     ‘[a-z$%.]’は任意のASCII小文字と‘$’、‘%’、‘.’にマッチします。別の例
     としては、‘[α-ωί]’はギリシャ文字の小文字すべてにマッチします。

     いくつかの特別な“文字クラス(character classes)”を、文字集合に含める
     こともできます。文字の候補を含む文字クラスを‘[:’と‘:]’で囲んで指定
     します。たとえば‘[[:alnum:]]’は、任意のアルファベットと数字にマッチ
     します。文字クラスのリストは、*note (elisp)Char Classes::を参照して
     ください。

     文字集合に‘]’を含めるには、それを最初に記述しなければなりません。た
     とえば‘[]a]’は、‘]’または‘a’にマッチします。文字集合に‘-’を含めるに
     は、‘-’を、文字集合の最初または最後に記述するか、文字範囲の外に記述
     します。したがって‘[]-]’は、‘]’と‘-’の両方にマッチします。

     文字集合に‘^’を含めるには、集合の最初以外に記述します(最初に記述し
     た場合、補集合を指定したことになります。以下を参照してください)。

     大文字小文字を区別しない検索で文字の範囲を使う場合、範囲の先頭と最
     後を、大文字だけ、または小文字だけで記述するか、先頭と最後をアルフ
     ァベット以外で記述するべきです。‘A-z’のような大文字小文字を混成した
     範囲指定は不正な定義で、Emacsの将来のバージョンで変更されるかもしれ
     ません。

‘[^ ... ]’
     ‘[^’は“文字の補集合complemented character set”を開始します。つまり
     指定された文字以外がマッチします。したがって‘[^a-z0-9A-Z]’は、
     ASCII文字と数字_以外_にマッチします。

     ‘^’は文字集合で最初以外で使用された場合、特別な意味をもちません。
     ‘^’に続く文字は、先頭にあるものとして扱われます(いいかえると‘-’と
     ‘]’は、ここでは特別な意味をもちません)。

     もしマッチしない文字として改行が記述されていなければ、文字の補集合
     を改行にマッチさせることができます。これは‘grep’のようなプログラム
     における、regexpにたいする処理とは対照的です。

‘^’
     これは空文字列、ただしテキストの行頭だけにマッチする特殊文字です。
     それ以外ではマッチに失敗します。したがって‘^foo’は行の先頭にある
     ‘foo’にマッチします。

     歴史的な互換性により、この意味での‘^’の使用は、正規表現の先頭か、
     ‘\(’または‘\|’の後に記述された場合に限ります。

‘$’
     ‘^’と似ていますが、行末だけにマッチします。したがって‘x+$’は、行末
     にある1つ以上の‘x’にマッチします。

     歴史的な互換性により、この意味での‘$’の使用は、正規表現の最後か、
     ‘\)’または‘\|’の後に記述された場合に限ります。

‘\’
     これには2つの機能があります。まず特殊文字(‘\’を含む)をクォートする
     ことと、追加の特別な構成を導入することです。

     ‘\’は特殊文字をクォートするので、正規表現中の‘\$’は‘$’だけにマッチ
     し、‘\[’は‘[’だけにマッチします。

     ‘\’で始まる特別な構成については、以下のセクションを参照してください
     。

   注意: 歴史的な互換性から、特殊文字はそれが特殊な意味をもたないような
コンテキストで使用された場合は、通常の文字として扱われます。たとえば
‘*foo’は、‘*’が特殊文字として動作するための前置された表現がないので、普
通の文字として扱われます。このような振る舞いに依存することは、よい習慣で
はありません。特殊文字を記述する場合、それがどこに記述されようとクォート
するべきです。

   文字集合の候補中では‘\’は特別ではなく、‘-’と‘]’のもつ特別な意味を除去
することはありません。したがって、これらの文字が特別な意味をもたないよう
な場所にあるときは、これらの文字をクォートすべきではありません。これでは
明確ではないかもしれません。これらの特殊文字が特別な意味を_もつ_場所にあ
るとき、バックスラッシュを前置することによりクォートされるのです。たとえ
ば‘[^\]’(Lispの文字記法では‘"[^\\]"’)は、バックスラッシュ以外の任意の一
文字にマッチします。


File: emacs-ja.info,  Node: Regexp Backslash,  Next: Regexp Example,  Prev: Regexps,  Up: Search

15.7 正規表現でのバックスラッシュ
=================================

多くの場合、任意の文字を伴う‘\’はその文字だけに一致します。しかしいくつ
か例外があって、‘\’で始まる2文字のシーケンスが、特別な意味を持つ場合があ
ります。シーケンス内の2文字目にくる文字は、単独で使った場合には普通の文
字として扱われるものです。以下は‘\’の構成の表です。

‘\|’
     選択肢を指定します。2つの正規表現AとBの間に‘\|’を記述すると、それは
     AまたはBのいずれかにマッチする表現を形成します。これはまずAとのマッ
     チを試み、失敗した場合にBとのマッチを試みます。

     したがって‘foo\|bar’は、‘foo’または‘bar’のいずれかにマッチし、それ
     以外の文字列にはマッチしません。

     ‘\|’は、周囲の一番大きな表現に適用されます。‘\|’のグループ化の能力
     に制限をかけることができるのは、周囲の‘\( ... \)’によるグループ化だ
     けです。

     複数の‘\|’使用を処理するための、完全なバックトラッキング能力が存在
     します。

‘\( ... \)’
     3つの目的のためのグループ化構成です:

       1. 他の操作に使うために、一連の選択肢‘\|’を括ります。したがって
          ‘\(foo\|bar\)x’は、‘foox’または‘barx’のいずれかにマッチします
          。

       2. 接尾演算子‘*’、‘+’、‘?’を適用できるように、複雑な正規表現を括
          ります。したがって‘ba\(na\)*’は、‘bananana’のように、(0個以上
          の)文字列‘na’にマッチします。

       3. あとで参照できるように、マッチした部分文字列を記録します。

     この最後の使い方は、カッコでグループ化することが重要なのではありま
     せん。これは‘\\( ... \\)’構成の、2番目の意味とは異なる機能です。実
     際には、これら2つの機能が衝突することは、通常はありません。もし衝突
     するようなら、以下で説明する、shy(内気)なグループ化を使うことができ
     ます。

‘\(?: ... \)’
     マッチした部分文字列を記録しない、“shy(内気)なグループ化”を指定しま
     す。マッチした部分文字列は、‘\D’により後方参照できません(以下参照
     )。この機能は正規表現を機械的にまとめるときに役立ちます。これにより
     後方参照するためのグループにたいする番号づけに影響することなく、文
     法的な目的によるグループ化を行うことができます。

‘\D’
     D番目に‘\( ... \)’構成にマッチしたテキストと同じテキストにマッチし
     ます。これは“後方参照(back reference)”と呼ばれます。

     最後の‘\( ... \)’構成の後で、マッチ処理はこの構成にマッチしたテキス
     トの最初と最後を記録します。そして正規表現の後の部分で‘\’の後に数字
     Dを使うことにより、D番目の‘\( ... \)’構成にマッチしたテキストと同じ
     テキストにマッチさせることができます。

     正規表現に記述された最初の9つの‘\( ... \)’にマッチしたテキストは、
     正規表現で開きカッコが出現した順に、1から9までの数字が割り当てられ
     ます。そのため‘\1’から‘\9’を使うことにより、‘\( ... \)’構成にマッチ
     した、対応するテキストを参照することができます。

     たとえば‘\(.*\)\1’は改行を含まない、前半と後半が同一の文字列にマッ
     チします。‘\(.*\)’は、そのテキストが何であろうと前半にマッチします
     が、‘\1’は前半と正確に同じテキストにマッチしなければなりません。

     もし特定の‘\( ... \)’構成が１回以上マッチする場合(これは‘*’が後置さ
     れているとき簡単に発生します)、最後のマッチだけが記録されます。

‘\`’
     空の文字列にマッチしますが、文字列またはバッファー(またはアクセスで
     きる部分)の先頭に限定されます。

‘\'’
     空の文字列にマッチしますが、文字列またはバッファー(またはアクセスで
     きる部分)の最後に限定されます。

‘\=’
     空の文字列にマッチしますが、ポイント位置に限定されます。

‘\b’
     空の文字列にマッチしますが単語の先頭または最後に限定されます。した
     がって‘\bfoo\b’は、区切られた単語‘foo’にマッチします。
     ‘\bballs?\b’は、別々の単語‘ball’または‘balls’にマッチします。

     ‘\b’は、そこにどんなテキストが出現しようと、バッファーの先頭または
     最後にもマッチします。

‘\B’
     空の文字列にマッチしますが、単語の最初と最後_以外_にマッチします。

‘\<’
     空の文字列にマッチしますが、単語の先頭に限定されます。‘\<’は単語の
     構成文字が続く場合に限り、バッファーの先頭にマッチします。

‘\>’
     空の文字列にマッチしますが、単語の最後に限定されます。‘\<’は内容が
     単語の構成文字で終わる場合に限りバッファーの最後にマッチします。

‘\w’
     任意の単語構成文字にマッチします。どの文字が該当するかは、構文テー
     ブル(syntax table)により決定されます。*note Syntax Tables:
     (elisp)Syntax Tables.を参照してください。

‘\W’
     単語構成文字以外の任意の文字にマッチします。

‘\_<’
     空の文字列にマッチしますが、シンボルの先頭に限られます。シンボルは
     １文字以上のシンボル構成文字からなります。シンボル構成文字は、‘w’と
     ‘_’の構文をもつ文字です。‘\_<’はシンボル構成文字が続く場合に限り、
     バッファーの先頭にもマッチします。単語にたいしては、構文テーブル
     (syntax table)が、どの文字がシンボル構成文字かを判断します。

‘\_>’
     空の文字列にマッチしますが、シンボルの最後に限定されます。‘\_>’は内
     容がシンボル構成文字で終わる場合に限り、バッファーの最後にマッチし
     ます。

‘\sC’
     構文がCである、任意の文字にマッチします。ここでCとは、特定の構文ク
     ラスを表す文字です。したがって‘w’は単語構成文字、‘-’または‘ ’は空白
     文字、‘.’は通常の区切り文字、などとなります。*note Syntax Tables:
     (elisp)Syntax Tables.を参照してください。

‘\SC’
     構文がC以外の、任意の文字にマッチします。

‘\cC’
     カテゴリーCに属する、任意の文字にマッチします。たとえば‘\cc’は中国
     文字、‘\cg’はギリシャ文字にマッチします。既知のカテゴリーについての
     説明は、‘M-x describe-categories <RET>’をタイプしてください。

‘\CC’
     カテゴリーCに_属さない_、任意の文字にマッチします。

   単語と構文に関係する構成は構文テーブルのセッティングにより制御されま
す。*Note Syntax Tables: (elisp)Syntax Tables.


File: emacs-ja.info,  Node: Regexp Example,  Next: Lax Search,  Prev: Regexp Backslash,  Up: Search

15.8 正規表現の例
=================

以下にregexpの例を示します。これはEmacsがセンテンスの最後(末尾の空白は含
まない)を認識するために、デフォルトで使用するregexp(たとえば変数
‘sentence-end-base’)と似ています。

     [.?!][]\"')}]*

これには2つの連続する部分があります。1つは‘.’、‘?’、‘!’にマッチする文字
です。もう1つは閉じカッコ、クォート、カッコの0回以上の繰り返しです。


File: emacs-ja.info,  Node: Lax Search,  Next: Replace,  Prev: Regexp Example,  Up: Search

15.9 検索中のLaxマッチング
==========================

あなたは通常、タイプした文字と、検索されるテキストの間にある、特定の瑣末
な違いを、検索コマンドが無視することを望むでしょう。たとえば長さが異なる
空白文字シーケンスは通常、等しいとみなされ、大文字小文字の違いは通常問題
にならない、などです。これは“等価文字(character equivalence)”として知ら
れています。

   このセクションではEmacsのlax search(緩い検索)機能と、それを必要に応じ
て調整する方法について説明します。

   デフォルトでは、検索コマンドは“lax space matching(緩いスペースマッチ
ング)”を行います。これはスペースおよび一連のスペースは、テキスト中の1つ
またはそれ以上の空白文字にマッチします(インクリメンタルregexp検索は別の
デフォルトをもちます。*note Regexp Search::を参照してください)。したがっ
て‘foo bar’は‘foo bar’、‘foo  bar’、‘foo   bar’、...にマッチします
(‘foobar’にはマッチしません)。正確にいうと、Emacsは検索文字列中の一連の
スペースを、変数‘search-whitespace-regexp’で指定された正規表現にマッチさ
せます。たとえばスペースを一連の改行とスペースにマッチさせるには、変数に
‘"[[:space:]\n]+"’をセットします。この変数のデフォルト値は、そのバッファ
ーのメジャーモードに依存します。ほとんどのメジャーモードは、スペース、タ
ブ、フォームフィード文字を空白文字としてクラス化します。

   空白文字を正確にマッチさせたい場合は、インクリメンタル検索中に‘M-s
<SPC>’ (‘isearch-toggle-lax-whitespace’)とタイプすることにより、lax
space matchingをオフに切り替えることができます。もう1度‘M-s <SPC>’とタイ
プすると、lax space matchingふぁオンに切り替わります。すべての検索でlax
space matchingを無効にするには、‘search-whitespace-regexp’を‘nil’に変更
します。これにより検索文字列の中のスペースは、正確に1つのスペースにマッ
チするようになります。

   Emacsでの検索では、検索文字列を小文字で指定した場合、デフォルトでは検
索するテキストの大文字小文字は区別されません。したがって‘foo’を検索する
と、‘Foo’や‘fOO’もマッチします。regexp、特に文字集合でも同様に振る舞いま
す。つまり‘[ab]’は、‘a’、‘A’、‘b’、‘B’もマッチします。この機能は“case
folding”として知られており、これはインクリメンタル検索と非インクリメンタ
ル検索の両方でサポートされています。

   検索文字列のどこかに大文字があると、検索はcase-sensitive(大文字小文字
を区別する)になります。したがって‘Foo’を検索すると、‘foo’や‘FOO’は検索さ
れません。これは正規表現検索でもリテラル文字列検索と同様に適用されます。
検索文字列から大文字を削除すると、効果はなくなります。変数
‘search-upper-case’がこれを制御します。この変数が非‘nil’(デフォルト)の場
合、検索文字列の中の大文字は、検索をcase-sensitiveにします。これを
‘nil’にセットすることにより、大文字によるこの効果は無効になります。

   変数‘case-fold-search’に‘nil’をセットすると、すべての文字は大文字小文
字を含めて、完全にマッチしなければなりません。これはバッファーごとの変数
で、変数の変更はデフォルト値を変えない限り、通常はカレントバッファーだけ
が影響を受けます。*note Locals::を参照してください。これは置換コマンド
(*note Replace::を参照してください)や、ミニバッファーのヒストリー検索
(*note Minibuffer History::を参照してください)を処理する、非インクリメン
タル検索にも適用されます。

   インクリメンタル検索で‘M-c’、または‘M-s c’
(‘isearch-toggle-case-fold’)とタイプすると、検索が大文字小文字を区別する
かが、切り替わります。この効果は、現在の検索を超えて引き継がれませんが、
カレントの検索にたいして大文字を追加・削除したときの効果をオーバーライド
します.

   特定のコマンドや操作にたいする検索やマッチングにおいて、大文字小文字
の区別を制御する変数がいくつかあります。たとえば
‘tags-case-fold-search’は、‘find-tag’での大文字小文字の区別を制御します
。これらの変数を探すには、‘M-x apropos-variable <RET> case-fold-search
<RET>’とタイプしてください。

   case foldingでは、文字の大文字小文字の違いを無視するので、大文字は小
文字にマッチし、その逆もマッチします。case foldingを一般化したものが
“character folding”で、これは類似した文字間の違いの、より広いクラスを無
視します。たとえばcharacter foldingでは、文字‘a’は‘ä’や‘á’のようなアクセ
ント付きの類似文字にもマッチし、これらの変種を区別するための特殊記号も無
視します。加えて‘a’は、‘a’に似ている他の文字や、U+249C PARENTHESIZED
LATIN SMALL LETTER Aや、U+2100 ACCOUNT OF(これは小さい‘c’の上に小さい
‘a’があるような外観をもちます)のような、文字のグラフィカルな外観の一部に
‘a’をもつ文字にもマッチします。同様にASCIIのダブルクォート文字‘"’は、ダ
ブルクォートの変種としてUnicode標準で定義されている、他のすべての変種に
マッチします。最後に、character foldingにより、1つ以上の文字シーケンスは
違う長さの他の文字にもマッチするようになります。たとえば2つの文字‘ff’は
、U+FB00 LATIN SMALL LIGATURE FFにマッチします。文字シーケンスはまったく
同じではありませんが、character foldingでのマッチは“equivalent character
sequences(等価文字シーケンス)”として知られています。

   一般的にEmacsの検索コマンドは、デフォルトでは等価な文字シーケンスのマ
ッチのためにcharacter foldingを行ないません。変数‘search-default-mode’を
‘char-fold-to-regexp’にカスタマイズすることにより、この振る舞いを有効に
できます。*note Search Customizations::を参照してください。インクリメン
タル検索では、‘M-s '’ (‘isearch-toggle-char-fold’)とタイプすることにより
character foldingが切り替わりますが、これはその検索だけです(置換コマンド
は別のオプションによる異なるデフォルトをもちます。*note Replacement and
Lax Matches::を参照してください)。

   case foldingと同様に、検索文字列の一部として明示的に‘ä’のような文字の
変種をタイプすることにより、その検索でのcharacter foldingが無効になりま
す。検索文字列からそのような文字を削除すると、この効果はなくなります。


File: emacs-ja.info,  Node: Replace,  Next: Other Repeating Search,  Prev: Lax Search,  Up: Search

15.10 置換コマンド
==================

Emacsは検索と置換を行うコマンドをいくつか提供します。単純な‘M-x
replace-string’コマンドに加えて、出現する検索パターンごとに置換するかを
問い合わせる‘M-%’ (‘query-replace’)も提供します。

   置換コマンドは通常、ポイント位置からバッファーの最後までのテキストに
たいして処理を行います。リージョンがアクティブのときは、リージョンにたい
して処理を行います(*note Mark::を参照してください)。基本的な置換コマンド
は1つの“検索文字列”(またはregexp)を、1つの“置換文字列”で置き換えます。コ
マンド‘expand-region-abbrevs’を使用して、複数の置換を並行して処理するこ
とが可能です(*note Expanding Abbrevs::を参照してください)。

* Menu:

* Unconditional Replace::    文字列にマッチするすべて置換する。
* Regexp Replace::           regexpにマッチするすべてを置換する。
* Replacement and Lax Matches::  置換するテキストにたいするlax検索。
* Query Replace::            問い合わせの使い方。


File: emacs-ja.info,  Node: Unconditional Replace,  Next: Regexp Replace,  Up: Replace

15.10.1 無条件の置換
--------------------

‘M-x replace-string <RET> STRING <RET> NEWSTRING <RET>’
     すべてのSTRINGをNEWSTRINGで置換します。

   ポイントの後にある‘foo’のすべてのインスタンスを‘bar’に置換するには、
コマンド‘M-x replace-string’に2つの引数‘foo’と‘bar’を指定します。置換は
ポイントの後だけで発生するので、バッファー全体を置換したい場合は、最初に
バッファーの先頭に移動しなければなりません。バッファーの最後までのすべて
が置換されます。置換をバッファーの一部に制限したいときは、そのリージョン
部分をアクティブにします。リージョンがアクティブのときは、置換はそのリー
ジョンに制限されます(*note Mark::を参照してください)。

   ‘replace-string’が終了したとき、ポイントは最後に置換された位置に留ま
ります。以前のポイント位置(‘replace-string’コマンドを実行した場所)はマー
クリングに追加されるので(マークは非アクティブ)、‘C-u C-<SPC>’で戻ること
ができます。*note Mark Ring::を参照してください。

   プレフィクス引数を指定すると、置換対象は単語単位に制限されます。

   置換コマンドでのcase-sensitivity(大文字小文字の区別)とcharacter
foldingについては、*note Replacement and Lax Matches::を参照してください
。


File: emacs-ja.info,  Node: Regexp Replace,  Next: Replacement and Lax Matches,  Prev: Unconditional Replace,  Up: Replace

15.10.2 正規表現の置換
----------------------

‘M-x replace-string’コマンドは、正確にマッチする単一の文字列を置換します
。同様なコマンド‘M-x replace-regexp’は、指定した正規表現パターン(*note
Regexps::を参照してください)にマッチするすべてを置換します。

‘M-x replace-regexp <RET> REGEXP <RET> NEWSTRING <RET>’
     REGEXPにマッチするすべてをNEWSTRINGで置換します。

   ‘replace-regexp’では、NEWSTRINGが定数である必要はありません。REGEXPに
マッチした全体、または部分を参照することができます。NEWSTRINGでの‘\&’は
、置換されるマッチ全体を表します。NEWSTRINGでの‘\D’(Dは1から始まる数字
)は、REGEXP内でカッコでグループ化されたものの、D番目にマッチします(これ
は“後方参照(back reference)と呼ばれます”)。‘\#’は、このコマンドですでに
置換された件数を10進数で参照します。最初の置換では‘\#’は‘0’で、2番目の置
換では‘1’、...のようになります。たとえば、

     M-x replace-regexp <RET> c[ad]+r <RET> \&-safe <RET>

これは‘cadr’を‘cadr-safe’に、‘cddr’を‘cddr-safe’に置き換えます。

     M-x replace-regexp <RET> \(c[ad]+r\)-safe <RET> \1 <RET>

これは逆向きの置換をします。置換するテキストに‘\’を含めるときは、‘\\’と
入力しなければなりません。

   置換する文字列の一部を毎回手入力したいときは、置換文字列で‘\?’を使用
します。すると置換ごとにミニバッファーで置換文字列を編集できます(ポイン
ト位置は‘\?’を記述した場所です。)

   このサブセクションの残りの部分は、Lispの知識が必要となる特別な処理を
念頭に書かれています。大半の読者はスキップしても構いません。

   置換文字列の一部を計算するために、Lisp式を使うことができます。これを
行うには、置換文字列の中で、‘\,’に続けてLisp式を記述します。各置換におい
て式の値が計算され、それをクォートされていない文字列に変換します(もし文
字列の場合は、その文字列の内容が使われることを意味します)。そしてそれを
置換文字列内で、式が記述された場所に使用します。もし式がシンボルのときは
、シンボル名と、置換文字列中のシンボル名の後にあるの間に1つスペースは、
両方シンボルの値に置換されます。

   このような式の中では、いくつかの特別なシーケンスを使うことができます
。式の中での‘\&’や‘\D’は、通常のようにマッチした文字列全体と、部分マッチ
した文字列を参照します。Dには複数桁の数字を記述でき、カッコでグループ化
されたD番目の正規表現がマッチしなかったとき、‘\D’は‘nil’になります。
‘\#&’と‘\#D’を使って、それらのマッチを数字で参照することもできます(これ
はマッチまたは部分マッチが数字書式の場合に有効です)。ここでの‘\#’も、す
でに置換された数を意味します。

   ‘x’と‘y’の入れ替えは、以下の方法で行うことができます:

     M-x replace-regexp <RET> \(x\)\|y <RET>
     \,(if \1 "y" "x") <RET>

   ‘\,’により置換する文字列を計算するには、‘format’関数が便利なときがあ
ります(*note (elisp)Formatting Strings::を参照してください)。たとえば
73列目から80列目(もしそこに何もなければ)に、‘ABC00042’のような連番を振り
たいときは、以下を使うことができます。

     M-x replace-regexp <RET> ^.\{0,72\}$ <RET>
     \,(format "%-72sABC%05d" \& \#) <RET>


File: emacs-ja.info,  Node: Replacement and Lax Matches,  Next: Query Replace,  Prev: Regexp Replace,  Up: Replace

15.10.3 置換コマンドとLaxマッチ
-------------------------------

このサブセクションではlaxマッチに関する置換コマンドの振る舞いと、それを
カスタマイズする方法を説明します。一般的には、ほとんどの置換は、それと同
等な検索コマンドに比べて、デフォルトではより厳密なマッチを行ないます。

   インクリメンタル検索とは異なり、置換コマンドはデフォルトではlax space
matching(緩いスペースマッチング)を行いません(*note lax space matching:
Lax Search.を参照してください)。置換でlax space matchingを有効にするには
、変数‘replace-lax-whitespace’を非‘nil’に変更してください(これはEmacsが
置換文字列ではなく、置換するテキストを検索する方法だけに影響を与えます
)。

   ‘query-replace-regexp’がパターンを検索するときlax whitespace
matchingを使うかどうかを制御するのは、それに対応する変数
‘replace-regexp-lax-whitespace’です。

   置換コマンドの最初の引数がすべて小文字の場合、置換のための検索におい
て大文字小文字の違いを無視します。これは‘case-fold-search’が非‘nil’の場
合です。‘case-fold-search’を‘nil’にセットすると、すべての検索において常
に大文字小文字の違いが有効になります。

   さらにNEWSTRINGのすべて、または一部が小文字の場合、置換コマンドは大文
字小文字が出現するパターンを維持しようと試みます。したがって以下のコマン
ド、

     M-x replace-string <RET> foo <RET> bar <RET>

は小文字の‘foo’を小文字の‘bar’で置換し、すべて大文字の‘FOO’を‘BAR’、そし
て最初が大文字の‘Foo’を‘Bar’に置換します。(これら3つの候補、すなわち小文
字、すべて大文字、先頭が大文字は、‘replace-string’が認識できる唯一のパタ
ーンです)。

   置換文字列に大文字が使われている場合、テキストが挿入されるときは、常
に大文字のままとなります。大文字が最初の引数で使用されている場合、大文字
小文字の変換なしで、2番目の引数に与えられたとおりに置換されます。同様に
‘case-replace’と‘case-fold-search’の両方が‘nil’にセットされている場合、
大文字小文字の変換なしで置換されます。

   デフォルトでは置換コマンドは、置換するテキストを探すとき、character
folding(*note character folding: Lax Search.を参照してください)を使用し
ません。‘query-replace’と‘replace-string’でのマッチングでcharacter
foldingを有効にするには、変数‘replace-char-fold’に非‘nil’値をセットしま
す(このセッティングは、Emacsが置換するテキストを探す方法だけに影響し、置
換するテキストには影響を与えません。また、‘replace-regexp’にも影響を与え
ません)。


File: emacs-ja.info,  Node: Query Replace,  Prev: Replacement and Lax Matches,  Up: Replace

15.10.4 問い合わせつき置換
--------------------------

‘M-% STRING <RET> NEWSTRING <RET>’
     任意のSTRINGをNEWSTRINGで置換します。
‘C-M-% REGEXP <RET> NEWSTRING <RET>’
     REGEXPにたいする任意のマッチをNEWSTRINGで置換します。

   ‘foo’を‘bar’に置換するとき、すべてではなく、そのうちのいくつかだけを
置換したいときは、‘M-%’ (‘query-replace’)を使います。このコマンドは
‘foo’を1つずつ検索して、それを置換するかを毎回尋ねます。この問い合わせを
別とすれば、‘query-replace’は‘replace-string’と同様に機能します(*note
Unconditional Replace::を参照してください)。通常のように、
‘case-replace’が非‘nil’のときは、大文字小文字を区別します(*note
Replacement and Lax Matches::を参照してください)。数引数を指定すると、単
語区切り文字で区切られた単語だけを考慮します。負のプレフィクス引数は後方
に置換します。

   ‘C-M-%’ (‘query-replace-regexp’)は、regexpの検索と置換を行います。こ
れは‘query-replace’のように問い合わせを行う以外は、‘replace-regexp’と同
様に機能します。

   これらのコマンドで行なった以前の置換を再利用できます。
‘query-replace’や‘query-replace-regexp’が検索文字列の入力を求めるプロン
プトを表示しているとき、‘M-p’と‘M-n’を使用することにより、‘FROM -> TO’と
いう形式で、以前の置換を表示できます。ここでFROMは検索パターン、TOはそれ
の置換、これらの間に表示されるセパレータは変数
‘query-replace-from-to-separator’の値により決定されます。望む置換が表示
されたら、<RET>とタイプしてそれを選択します。この変数の値が‘nil’の場合、
置換はコマンドヒストリーに追加されず、再利用できません。

   これらのコマンドは、カレントのマッチを、フェイス‘query-replace’を使っ
てハイライトします。変数‘query-replace-highlight’を‘nil’にセットすること
により、このハイライトを無効にできます。他のマッチのハイライトにはインク
リメンタル検索(*note Incremental Search::を参照してください)と同様に、フ
ェイス‘lazy-highlight’が使われます。変数‘query-replace-lazy-highlight’を
‘nil’にセットすることにより、このハイライトを無効にできます。デフォルト
では‘query-replace-regexp’は、カレントマッチを置換する展開後の文字列を、
ミニバッファーに表示します。特別なシーケンス‘\&’および‘\N’を展開せずに維
持するには、‘query-replace-show-replacement’変数をカスタマイズしてくださ
い。

   変数‘query-replace-skip-read-only’に非‘nil’がセットされている場合、罹
患コマンドはread-only(読み取り専用)のテキスト内のマッチを無視します。デ
フォルトでは、それらを無視しません。

   以下は文字列またはregexpにたいするマッチが表示されているときにタイプ
できる文字です:

‘<SPC>’
‘y’
     マッチをNEWSTRINGで置き換えます。

‘<DEL>’
‘<Delete>’
‘<BACKSPACE>’
‘n’
     カレントマッチを置換せずに次のマッチへスキップします。

‘, (カンマ)’
     カレントマッチを置換して、結果を表示します。そして次に何をするかを
     文字入力するよう促します。置換がすでに行われているので、この状況で
     は<DEL>と<SPC>は等価で、どちらも次のマッチへ移動します。

     ここで‘C-r’(以下を参照)をタイプして、置換されたテキストを編集できま
     す。‘C-x u’をタイプして、置換を取り消すこともできます。これは
     ‘query-replace’を終了させるので、さらに置換を行う場合は、‘C-x <ESC>
     <ESC> <RET>’で置換を再開しなければなりません(*note Repetition::を参
     照してください)。

‘<RET>’
‘q’
     これ以上の置換を行わずに終了します。

‘. (ピリオド)’
     カレントマッチを置換してから、これ以上の検索を行わずに終了します。

‘!’
     これ以上の問い合わせをせずに、残りのマッチをすべて置換します。

‘^’
     前のマッチの位置に戻ります。これは間違えて変更したときや、再検証し
     たい場合に使います。

‘u’
     最後の置換をアンドゥ(undo: 取り消し)して、その置換が行われた位置に
     戻ります。

‘U’
     すべての置換をアンドゥして、最初の置換が行われた位置に戻ります。

‘C-r’
     再帰編集レベル(recursive editing level)に入ります。これはマッチを
     NEWSTRINGで置換するだけでなく、編集したい場合に使用します。編集を終
     えたら‘C-M-c’で再帰編集レベルを抜けて、次のマッチを処理します。
     *note Recursive Edit::を参照してください。

‘C-w’
     マッチを削除してから、‘C-r’と同様に再帰編集レベルに入ります。これは
     STRINGを削除してから、テキストを挿入することにより置換を行う場合に
     使用します。編集を終えたら‘C-M-c’で再帰編集レベルを抜けて、次のマッ
     チを処理します。

‘e’
     置換文字列をミニバッファーで編集します。<RET>でミニバッファーを抜け
     ると、カレントマッチをミニバッファーの内容で置換します。この新しい
     置換文字列は、残りのマッチにたいしても適用されます。

‘C-l’
     スクリーンを再描画します。その後でカレントマッチにたいして何を行う
     か、別の文字をタイプして指定しなければなりません。

‘Y (大文字)’
     複数バッファーの置換で、残りのバッファーの、残りのマッチをすべて置
     換します(これは選択したファイルにたいして問い合わせつきの置換を行う
     、Diredの‘Q’コマンドと似ています)。これはすべての一連の問い合わせに
     たいして、これ以上のユーザーとの対話なしに“yes”を答えます。

‘N (大文字)’
     複数バッファーの置換で、カレントバッファーの残りのマッチを置換せず
     に、次のバッファーへスキップします。これはカレントバッファーのマッ
     チにたいする問い合わせに“no”を答えて、次のバッファーへと処理を続け
     ます。

‘C-h’
‘?’
‘<F1>’
     上述したオプションの要約を表示します。その後でカレントマッチにたい
     して何を行うか、別の文字をタイプして指定しなければなりません。

   これらのエイリアス文字以外の文字は、‘query-replace’を終了してから、キ
ーシーケンスの残りの部分を読みとります。したがって‘C-k’とタイプすると、
‘query-replace’を終了してから、行末までをkillします。特に、‘C-g’は単に
‘query-replace’をexitします。

   一度終了した‘query-replace’を再開するには、‘C-x <ESC> <ESC>’を使いま
す。‘query-replace’は引数の読み取りにミニバッファーを使っているので、こ
のキーシーケンスで再開させることができます。*note C-x <ESC> <ESC>:
Repetition.を参照してください。

   オプション‘search-invisible’は、‘query-replace’が非表示のテキストを扱
う方法を決定します。*note Outline Search::を参照してください。

   選択されたファイルにたいして問い合わせつきの置換を行う、Diredの‘Q’コ
マンドについては、*note Operating on Files::を参照してください。regexpに
マッチするファイル名にたいして、ファイル名の変更、ファイルのコピー、ファ
イルのリンクを行うDiredのコマンドについては、*note Transforming File
Names::を参照してください。


File: emacs-ja.info,  Node: Other Repeating Search,  Next: Search Customizations,  Prev: Replace,  Up: Search

15.11 その他の検索およびループコマンド
======================================

ここでは正規表現にたいするマッチを検索する、その他のコマンドを説明します
。これらのコマンドは、パターンに大文字が含まれていないカ、
‘case-fold-search’が非‘nil’のときは、マッチングで大文字小文字を区別しま
せん。常にバッファー全体を検索する‘multi-occur’と
‘multi-occur-in-matching-buffers’をのぞき、これらはすべて、ポイント位置
からバッファーの最後まで、リージョンがアクティブなときはそのリージョンに
たいして処理を行います。

‘M-x multi-isearch-buffers’
     １つ以上のバッファー名の入力を求め(<RET>で終了)、それらのバッファー
     にたいして複数バッファーのインクリメンタル検索を開始します(あるバッ
     ファーでの検索に失敗すると、次の‘C-s’により、指定された次のバッファ
     ーへと検索を試みます)。プレフィクス引数を指定すると、regexpの入力を
     求め、regexpにマッチするバッファーにたいして、複数バッファーでのイ
     ンクリメンタル検索を開始します。

‘M-x multi-isearch-buffers-regexp’
     このコマンドは‘multi-isearch-buffers’と同様ですが、インクリメンタル
     なregexp検索を行います。

‘M-x multi-isearch-files’
     １つ以上のファイル名の入力を求め(<RET>で終了)、それらのファイルにた
     いして複数ファイルのインクリメンタル検索を開始します(あるファイルで
     検索に失敗すると、次の‘C-s’により、指定された次のファイルへと検索を
     試みます)。プレフィクス引数を指定すると、regexpの入力を求め、
     regexpにマッチするファイルにたいして、複数ファイルでのインクリメン
     タル検索を開始します。

‘M-x multi-isearch-files-regexp’
     このコマンドは‘multi-isearch-files’と同様ですが、インクリメンタルな
     regexp検索を行います。

     バッファーローカルな変数‘multi-isearch-next-buffer-function’をセッ
     トするいくつかのモード(たとえばChange Logモード)では、複数ファイル
     にたいするインクリメンタル検索は自動的にアクティブになります。

‘M-x occur’
‘M-s o’
     regexpの入力を求め、それへのマッチを含むバッファー内の各行をリスト
     表示します。プロンプトで‘M-n’をタイプした場合は、前のインクリメンタ
     ル検索から検索文字列を再利用できます。マッチするテキストは、
     ‘match’フェイスを使用してハイライトされます。数引数Nを指定すると、
     そのコンテキストでマッチした各行の、前後N行を表示します。

     コンテキスト行のデフォルト行数は、変数
     ‘list-matching-lines-default-context-lines’により指定されます。
     ‘list-matching-lines-jump-to-current-line’が非‘nil’のとき、カレント
     行はフェイス‘list-matching-lines-current-line-face’でハイライト表示
     され、ポイントはその行の最初のマッチの後にセットされます。

     インクリメンタル検索がアクティブのときは‘M-s o’を実行して、カレント
     のサーチリングを使うこともできます。

     あなたがタイプしたregexpにたいするマッチは完全な行を含むように拡張
     され、1つ前のマッチの終了の前から開始するマッチは考慮されないことに
     注意してください。

     ‘*Occur*’バッファーでは、エントリーをクリックするか、ポイントをそこ
     に移動して<RET>をタイプすることにより、検索されたバッファーの対応す
     る位置をvisitします。‘o’と‘C-o’はマッチを他のウィンドウに表示します
     (‘C-o’はそのウィンドウを選択しません)。かわりに‘C-x `’
     (‘next-error’)コマンドを使うことにより、マッチした場所を1つ1つ
     visitできます(*note Compilation Mode::を参照してください)。

     ‘*Occur*’バッファーで‘e’をタイプすることにより、Occur Editモードに
     切り替えます。このモードではエントリーにたいする編集結果が、元のバ
     ッファーのテキストに適用されます。‘C-c C-c’とタイプすることにより、
     Occurモードに戻ります。

     コマンド‘M-x list-matching-lines’は、‘M-x occur’の別名です。

‘M-x multi-occur’
     このコマンドは‘occur’と同じですが、複数のバッファーを検索する点が異
     なります。このコマンドは、1つずつバッファー名の入力を求めます。

‘M-x multi-occur-in-matching-buffers’
     このコマンドは‘multi-occur’と似ていますが、visitしているファイル名
     にマッチする正規表現を指定することにより、検索するバッファーを指定
     する点が異なります。プレフィクス引数を指定すると、正規表現にマッチ
     するバッファー名となります。

‘M-x how-many’
     regexpの入力を求め、バッファーのポイント位置以降に、何個のマッチが
     あるか表示します。リージョンがアクティブのときは、リージョンにたい
     して操作を行います。

‘M-x flush-lines’
     regexpの入力を求め、ポイント以降にあるテキストにたいして、マッチが
     含まれている行を削除します。カレント行のポイント以降にマッチする文
     字列が含まれているときは、カレント行を削除します。リージョンがアク
     ティブのときは、リージョンにたいして操作を行います。行の一部ににリ
     ージョンが含まれていて、さらにマッチの全体がリージョンに含まれてい
     るとき、その行は削除されます。

     マッチが行をまたいでいる場合、‘flush-lines’はそれらの行すべてを削除
     します。このコマンドは行を削除してから、次のマッチを検索します。し
     たがって、1行にマッチ全体と、次の行にまたがるマッチが両方含まれると
     き、次の行にまたがるマッチは無視されます。

‘M-x keep-lines’
     regexpの入力を求め、ポイント以降にあるテキストにたいして、マッチを
     _含まない_行を削除します。ポイントが行の先頭でない場合、このコマン
     ドは常にカレント行を維持します。リージョンがアクティブのときは、リ
     ージョンにたいして操作を行います。このコマンドは一部がリージョンに
     含まれるだけの行は削除しません(行を終端する改行は、その行の一部と判
     断します)。

     マッチが行をまたぐ場合、このコマンドはそれらすべての行を維持します
     。


File: emacs-ja.info,  Node: Search Customizations,  Prev: Other Repeating Search,  Up: Search

15.12 必要に応じて検索を調整する
================================

このセクションでは、他では説明されていない、その他の検索に関連した機能を
説明します。

   インクリメンタル検索にたいするデフォルトの検索モードは、変数
‘search-default-mode’により指定されます。この変数には、‘nil’、‘t’、また
は関数を指定できます。‘nil’の場合、デフォルトのモードはcharacter
foldingなしのリテラル検索です。しかし、case foldingにたいしては
‘case-fold-search’、lax-whitespace matchにたいしては
‘search-whitespace-regexp’により決定されます(*note Lax Search::を参照し
てください)。値が‘t’の場合、インクリメンタル検索のデフォルトはregexp検索
になります。デフォルト値には、case foldingとlax-whitespace matchingだけ
を行なう関数が指定されています。

   継続的なインクリメンタル検索でのカレントマッチは、‘isearch’フェイスで
ハイライトされます。変数‘search-highlight’を‘nil’にセットすることにより
、このハイライトを無効にできます。

   ディスプレーに表示されている、検索文字列にたいするその他のマッチは、
‘lazy-highlight’フェイスを使用してハイライトされます。変数
‘isearch-lazy-highlight’をセットして、このハイライトを無効にできます。以
下はlazy-highlightをカスタマイズする、その他の変数です:

‘lazy-highlight-initial-delay’
     表示されているマッチをハイライトするまでwaitする秒数です。

‘lazy-highlight-interval’
     マッチをハイライトする秒数です。

‘lazy-highlight-max-at-a-time’
     入力をチェックする前にハイライトする、マッチの最大数です。大きな数
     を指定するとハイライトに時間を要するかもしれず、その間に検索を継続
     するために‘C-s’や‘C-r’をタイプしても、それらすべてのマッチのハイラ
     イトを終了するまで、Emacsは反応しないでしょう。したがって小さな数を
     指定することにより、Emacsの反応を改善できます。

   インクリメンタル検索で検索文字列が空のときに<RET>を入力すると、通常こ
れは非インクリメンタル検索を開始します(実際には、これにより検索文字列の
編集が開始され、次の<RET>で検索を行ないます)。しかし、変数
‘search-nonincremental-instead’を‘nil’にセットした場合、検索文字列が空で
も、<RET>のタイプは常にインクリメンタル検索をexitします。

   デフォルトではインクリメンタル検索および問い合わせ付き置換コマンドは
不可視のテキストにもマッチしますが、そのようなマッチは隠され、不可視のテ
キストの外にできるだけ早くカレントマッチを移動させます。変数
‘isearch-hide-immediately’を‘nil’にカスタマイズした場合、マッチが見つか
った任意の不可視テキストは、検索または置換コマンドがexitするまで表示され
続けます。

   遅い回線で接続されたリモートマシンのディスプレーなど、遅い端末でイン
クリメンタルな検索をすると、検索によりディスプレーの大きな範囲を再描画し
なければならないことが、煩わしくなるかもしれません。Emacsは、遅い端末に
たいして特別なディスプレーモードを提供します。これは検索が別の小さなウィ
ンドウをポップアップして、マッチの周辺テキストをそのウィンドウに表示しま
す。小さいウィンドウは早く表示できるので、遅いスピードの影響による煩わし
さは軽減されます。変数‘search-slow-speed’は、Emacsがこのディスプレーモー
ドを使用する、ボーレートの下限値を決定します。変数
‘search-slow-window-lines’は、Emacsがポップアップして検索結果を表示する
ウィンドウの行数を制御します(デフォルトは1)。このウィンドウは通常、検索
を開始したバッファーを表示するウィンドウの下部にポップアップされますが、
‘search-slow-window-lines’の値が負の場合、ウィンドウは上部に配され、
‘search-slow-window-lines’の絶対値が表示される行数になります。


File: emacs-ja.info,  Node: Fixit,  Next: Keyboard Macros,  Prev: Search,  Up: Top

16 タイプミスを訂正するコマンド
*******************************

このチャプターでは、編集中に間違いに気付いたときに便利なコマンドを説明し
ます。これらのコマンドの中でもっとも基本的なのは、undoコマンド‘C-/’です
(これは‘C-x u’と‘C-_’にもバインドされています)。これは1つのコマンドやコ
マンドの一部(‘query-replace’の場合など)、または連続するいくつかの文字の
挿入を取り消します。連続して‘C-/’を繰り返すと、前へ前へと変更を取り消し
、undo情報が利用できる限界までさかのぼって、変更を取り消します。

   ここで説明するコマンドとは別に、<DEL> (‘delete-backward-char’)のよう
な削除コマンドでもテキストを消去できます。これらのコマンドは、このマニュ
アルの前のチャプターで説明しています。*note Erasing::を参照してください
。

* Menu:

* Undo::                     Undoコマンド。
* Transpose::                2つの文字、単語、行、リスト、...の入れ替え。
* Fixing Case::              最後に入力した文字の大文字小文字を訂正する。
* Spelling::                 単語またはファイル全体へのスペルチェッカーの適用。


File: emacs-ja.info,  Node: Undo,  Next: Transpose,  Up: Fixit

16.1 Undo(取り消し)
===================

“undo(取り消し)”コマンドは、バッファーのテキストにたいする最後の変更を無
効にします。バッファーはそれぞれ変更を個別に記録しており、undoコマンドは
常にカレントバッファーに適用されます。バッファーのレコードにより、バッフ
ァーにたいするすべての変更をundoできます。通常、個々の変種コマンドは、
undoレコードに個別のエントリーを作成しますが、‘query-replace’のようない
くつかのコマンドは、undo操作に柔軟性をもたせるために、コマンドによる変更
を複数のエントリーに分割します。連続した文字の挿入コマンドは、undo操作の
冗長性をなくすために、通常1つのundoレコードにまとめられます。

‘C-/’
‘C-x u’
‘C-_’
     カレントバッファーのundoレコードの、1エントリーでundoします
     (‘undo’)。

   undoを開始するには、‘C-/’(またはエイリアスの‘C-_’か‘C-x u’)をタイプし
ます(1)。これは一番最近のバッファーにたいする変更を取り消して、バッファ
ーが変更される前の位置にポイントを戻します。連続して‘C-/’(またはそれのエ
イリアス)を繰り返すと、現在のバッファーにたいする変更を、前へ前へとさか
のぼって取り消します。すでに記録されている変更がすべて取り消されていると
き、undoコマンドはエラーをシグナルします。

   undo以外のコマンドは、undoコマンドの順序性を損ないます。undo以外のコ
マンドを開始した時点から、undoしてきた一連のundoコマンド全体が、undoレコ
ードとして記録されます。したがってundoした変更を再適用するには、undoの順
序性を損なわないような‘C-f’のようなコマンドをタイプしてから、‘C-/’を1回
以上タイプして、undoコマンドをundoしていきます。

   以前のundoコマンドを再実行せずにundoを再開したいときは、かわりに‘M-x
undo-only’を使います。これは‘undo’と同様ですが、すでにundoした変更を再実
行しません。

   バッファーをうっかり変更してしまったのに気付いたら、モードラインのア
スタリスクが表示されなくなるまで‘C-/’を繰り返しタイプするのが、もっとも
簡単な復旧方法です。undoコマンドによりモードラインのアスタリスクが消えた
とき、それはバッファーの内容がファイルを最後に読み込んだとき、または保存
したときと同じ内容だということを意味します。バッファーを意図して変更した
か覚えていないときは、‘C-/’を1回タイプします。最後の変更がundoされたのを
確認して、それが意図した変更なのか確かめます。もしそれが意図しない変更だ
ったならundoしたままにします。意図した変更だった場合、上で説明した方法で
変更を再実行します。

   かわりに‘M-x revert-buffer’を使用して、そのバッファーが最後にvisitさ
れたとき、または最後に保存されたとき以降のすべての変更を破棄できます
(*note Reverting::を参照)。

   アクティブなリージョンがあるとき、‘undo’は“選択的なundo(selective
undo)”を行います。これはバッファー全体ではなく、リージョンにたいして一番
最近の変更をundoします。しかしTransient Markモードがオフのとき(*note
Disabled Transient Mark::を参照してください)、‘C-/’は、リージョンではな
く、常にバッファー全体を操作します。この場合‘undo’コマンドにプレフィクス
引数を指定（‘C-u C-/’)することにより、選択的なundoができます。同じリージ
ョンにたいしてさらに変更をundoしたいときは、‘undo’コマンドを繰り返します
(プレフィクス引数は必要ありません)。

   undoレコードを作らない、特別なバッファーがいくつかあります。それは名
前がスペースで始まるバッファーです。これらのバッファーはEmacsにより内部
的に使用されており、通常ユーザーが閲覧したり編集しないテキストを保持しま
す。

   バッファーにたいするundo情報が大きくなりすぎたとき、Emacsは一番古いレ
コードを、時々(“ガベージコレクション(garbage collection)の間”)廃棄します
。変数‘undo-limit’、‘undo-strong-limit’、‘undo-outer-limit’をセットする
ことにより、どれだけのundo情報を保持するか指定することができます。これら
の値はバイト数で指定します。

   変数‘undo-limit’は、ソフトリミットをセットします。Emacsはこのサイズに
達するまでのコマンドのundoデータを保持します。制限を超えることもあり得ま
すが、これを超える古いデータは保持しません。デフォルト値は80000です。変
数‘undo-strong-limit’は、厳密なリミット(stricter limit)をセットします。
この制限を超えるような以前のコマンド(一番最近のコマンドではない)は記憶さ
れません。‘undo-strong-limit’のデフォルト値は120000です。

   これらの変数の値にかかわらず、一番最近の変更はundo情報が
‘undo-outer-limit’(通常は12,000,000)より大きくならない限り、廃棄されるこ
とはありません。もしこれを超えるような場合、Emacsはundoデータを廃棄して
、それにたいする警告を発します。これは一番最近のコマンドをundoできない唯
一の状況です。これが発生した場合、将来同じことが起こらないように
‘undo-outer-limit’の値を増やすことができます。しかしコマンドがそのような
大きなundoデータを作るとは考えられない場合、それは多分バグなので、それを
報告すべきです。*note Reporting Bugs: Bugs.を参照してください。

   ---------- Footnotes ----------

   (1) ‘C-/’以外に、‘undo’コマンドは‘C-x u’にもバインドされています。な
ぜならこれは初心者が記憶するのが簡単だからです。‘u’は“undo”に由来してい
ます。このコマンドは‘C-_’にもバインドされています。なぜならいくつかのテ
キスト端末では、‘C-/’とタイプすることにより、‘C-_’が入力されるからです。


File: emacs-ja.info,  Node: Transpose,  Next: Fixing Case,  Prev: Undo,  Up: Fixit

16.2 テキストの入れ替え
=======================

‘C-t’
     2つの文字を入れ替えます(‘transpose-chars’)。
‘M-t’
     2つの単語を入れ替えます(‘transpose-words’)。
‘C-M-t’
     バランスのとれた2つの式を入れ替えます(‘transpose-sexps’)。
‘C-x C-t’
     2つの行を入れ替えます(‘transpose-lines’)。

   2つの文字を入れ違いに入力してしまう間違いはよくありますが、それらが隣
接しているときは‘C-t’(‘transpose-chars’)コマンドで訂正できます。通常
‘C-t’はポイントの左右にある文字を入れ替えます。行末でこのコマンドを使う
場合、最後の文字と改行を入れ替えるのはおそらく無意味なので、‘C-t’は行末
の2文字を入れ替えます。このような入れ違いミスにすぐ気付いたときは、
‘C-t’だけで訂正できます。すぐに間違いに気付かなかった場合、‘C-t’をタイプ
する前に、入れ替えて入力してしまった文字の間にカーソルを移動しなければな
りません。単語の最後の文字とスペースを入れ替えて入力してしまった場合、そ
こに戻るには単語移動コマンド(‘M-f’、‘M-b’など)が良い方法です。それ以外で
は、逆向きの検索(‘C-r’)が最善な方法の場合があります。*note Search::を参
照してください。

   ‘M-t’は、ポイントの前にある単語と、後にある単語を入れ替えます
(‘transpose-words’)。このコマンドはポイントより後方、またはポイントがあ
る単語を前方に移動して、ポイントをその後に移動します。文字の間にある区切
り文字は移動しません。たとえば‘FOO, BAR’は、‘BAR FOO,’ではなく、
‘BAR, FOO’に入れ替わります。

   ‘C-M-t’ (‘transpose-sexps’)も似ていますが、これは2つの式(*note
Expressions::を参照してください)を入れ替えます。そして‘C-x C-t’
(‘transpose-lines’)は、行を入れ替えます。これらは‘M-t’と同様に動作します
が、入れ替えを行うテキスト単位が異なります。

   入れ替えコマンドに数引数を指定すると、反復回数になります。これは入れ
替えコマンドに、ポイントより前(またはポイントがある)の移動させる文字(ま
たは単語、式、行)を、何文字(または単語、式、行)後に移動させるか指示しま
す。たとえば‘C-u 3 C-t’は、ポイントの前にある文字を3文字後ろに移動します
。つまり‘f★oobar’は‘oobf★ar’に変更されます。これは‘C-t’を3回繰り返したの
と同じです‘C-u - 4 M-t’はポイントの前にある単語を、後方に単語4つ分移動し
ます。‘C-u - C-M-t’は、引数を指定しない‘C-M-t’の効果を取り消します。

   数引数0には特別な意味が割り当てられています(繰り返し回数としては、0に
意味がありません)。これはポイントの後ろで終わる文字(または単語、式、行
)を、マーク位置で終わる文字(または単語、式、行)と入れ替えます。


File: emacs-ja.info,  Node: Fixing Case,  Next: Spelling,  Prev: Transpose,  Up: Fixit

16.3 大文字小文字の変換
=======================

‘M-- M-l’
     最後に入力した単語を小文字に変換します。‘Meta--’はメタとマイナスで
     あることに注意して下さい。
‘M-- M-u’
     最後に入力した単語をすべて大文字に変換します。
‘M-- M-c’
     最後に入力した単語の先頭を大文字、それ以外を小文字に変換します。

   単語の大文字小文字を間違えてタイプするのは、とても一般的な間違えです
。そのため、単語の大文字小文字の変換コマンド‘M-l’、‘M-u’、‘M-c’に負の数
引数を指定すると、カーソルを移動しないという特性があります。最後に入力し
た単語のタイプミスに気付いたら、単に大文字小文字を変換して、タイプを続け
ることができます。*note Case::を参照してください。


File: emacs-ja.info,  Node: Spelling,  Prev: Fixing Case,  Up: Fixit

16.4 スペルのチェックと訂正
===========================

このセクションでは、1つの単語、またはバッファーの一部のスペルをチェック
するコマンドを説明します。これらのコマンドはHunspell、Aspell、Ispell、ま
たはEnchantのうちのいずれかのスペルチェッカープログラムがインストールさ
れている場合だけ機能します。これらのプログラムはEmacsの一部ではありませ
んが、GNU/Linuxまたは他のフリーなオペレーティングシステムには、通常1つは
インストールされています。 *note Aspell: (aspell)Top.を参照してください
。

‘M-$’
     ポイントがある単語スペルの、チェックと訂正をします(‘ispell-word’)。
     リージョンがアクティブのときは、リージョンに含まれるすべての単語に
     たいして行います。
‘M-x ispell’
     バッファーにある単語スペルの、チェックと訂正をします。リージョンが
     アクティブのときは、リージョンに含まれるすべての単語にたいして行い
     ます。
‘M-x ispell-buffer’
     バッファーにある単語スペルの、チェックと訂正をします。
‘M-x ispell-region’
     リージョンにある単語スペルの、チェックと訂正をします。
‘M-x ispell-message’
     メールメッセージのドラフト(引用部分を除く)にたいして、単語スペルの
     チェックと訂正をします。
‘M-x ispell-change-dictionary <RET> DICT <RET>’
     スペルチェッカーのプロセスを再起動して、DICTを辞書として使用させま
     す。
‘M-x ispell-kill-ispell’
     スペルチェッカーのサブプロセスをkillします。
‘M-<TAB>’
‘<ESC> <TAB>’
‘C-M-i’
     ポイントの前にある単語を、スペル辞書をもとに補完します
     (‘ispell-complete-word’)。
‘M-x flyspell-mode’
     スペルミスした単語をハイライトする、Flyspellモードを有効にします。
‘M-x flyspell-prog-mode’
     コメントと文字列にたいして、Flyspellモードを有効にします。

   ポイントの前または周囲にある単語スペルをチェックしたり訂正するには、
‘M-$’ (‘ispell-word’)をタイプします。リージョンがアクティブのときは、リ
ージョン内のすべての単語スペルをチェックします。*note Mark::を参照してく
ださい(Transient Markモードがオフのとき、‘M-$’はリージョンを無視して、常
にポイントの前または周囲の単語にたいして動作します。*note Disabled
Transient Mark::を参照してください)。

   同様に、コマンド‘M-x ispell’はリージョンがアクティブのときはリージョ
ン、それ以外のときはバッファー全体にたいして、スペルチェックを行います。
コマンド‘M-x ispell-buffer’および‘M-x ispell-region’は、スペルチェックを
バッファー全体にたいして行うのか、リージョンにたいして行うかを明示します
。このコマンドはバッファー全体をチェックしますが、インデントされているテ
キストと、以前のメッセージの引用と思われるテキストはチェックしません。
*note Sending Mail::を参照してください。

   これらのコマンドは、正しくないと思われる単語に出会うと、それをどうす
るかを尋ねます。通常は番号が振られた“近い単語(near-misses: 正しくないと
思われる単語に似た単語)”のリストを表示します。これにたいして1文字をタイ
プして応答しなければなりません。以下は有効な応答文字です。

‘数字’
     今回だけは近い単語の一覧で単語を置き換えます。近い単語には番号が振
     られており、選択するにはその番号をタイプします。

‘<SPC>’
     その単語を間違いと判断することは変更しませんが、その単語をここでは
     変更せずスキップします。

‘r NEW <RET>’
     今回は単語をNEWで置き換えます(置換文字列にスペルエラーがないか再ス
     キャンされます)。

‘R NEW <RET>’
     単語をNEWで置き換え、‘query-replace’を実行します。これによりバッフ
     ァーの他の箇所の間違えを置換できます(置換にスペルエラーがないか再ス
     キャンされます)。

‘a’
     正しくないと思われる単語を正しいものとして受け入れますが、それは今
     回の編集セッションに限られます。

‘A’
     正しくないと思われる単語を正しいものとして受け入れますが、それは今
     回の編集セッションとそのバッファーに限られます。

‘i’
     この単語をプライベートな辞書ファイルに挿入するので、今後(将来のセッ
     ションを含めて)はその単語を正しいと認識します。

‘m’
     ‘i’と同様ですが、辞書の補完情報も指定できます。

‘u’
     この単語の小文字バージョンを、プライベートな辞書ファイルに挿入しま
     す。

‘l WORD <RET>’
     WORDにマッチする単語を辞書から探します。これらの単語は近い単語の新
     しいリストになるので、置換で数字をタイプして選択できるようになりま
     す。WORDにはワイルドカードとして‘*’を使うことができます。

‘C-g’
‘X’
     対話的なスペルチェックを終了します(ポイントはチェックされた単語の位
     置に残されます)。‘C-u M-$’でチェックを再開できます。

‘x’
     対話的なスペルチェックを終了します(ポイントはチェックを開始したとき
     の位置に戻ります)。

‘q’
     対話的なスペルチェックを終了して、スペルチェッカーのサブプロセスを
     killします。

‘?’
     オプションの一覧を表示します。

   Textモードおよびそれに関連するモードでは、‘M-<TAB>’
(‘ispell-complete-word’)で、スペル訂正にもとづくバッファー内補完を行いま
す。単語の最初の部分を入力してから‘M-<TAB>’をタイプすると、補完一覧が表
示されます(ウィンドウマネージャーが‘M-<TAB>’を横取りしてしまう場合は、
‘<ESC> <TAB>’または‘C-M-i’をタイプします)。補完対象には番号か文字が振ら
れているので、その番号か文字をタイプして選択します。

   1度プロセスが開始されれば、スペルチェッカーのサブプロセスは待機状態で
実行を続けるので、一連のスペルチェックコマンドは素早く完了します。プロセ
スを終了させたいときは‘M-x ispell-kill-ispell’を使います。スペルの訂正を
行うとき以外プロセスがCPU時間を使うことはないので、これは通常必要ありま
せん。

   スペルチェッカーは、スペルを2つの辞書から探します。それは標準辞書と個
人用辞書です。標準辞書は変数‘ispell-local-dictionary’で指定されます。こ
れが‘nil’のときは、変数‘ispell-dictionary’で指定されます。両方が‘nil’の
とき、スペルプログラムは既定の辞書を使います。コマンド‘M-x
ispell-change-dictionary’は、バッファーにたいする標準辞書をセットしてか
らサブプロセスを再起動することにより、これにより異なる標準辞書を使うこと
ができます。個人用の辞書は、変数‘ispell-personal-dictionary’で指定します
。これが‘nil’のとき、スペルプログラムは個人辞書を、各スペルチェッカーが
指定する既定の場所から探します。

   単語の補完には別の辞書が使われます。変数‘ispell-complete-word-dict’は
、この辞書のファイル名を指定します。補完辞書は、単語の変化形を検知するた
めにスペルチェックが使用する、単語にたいするroot語(接辞を含まない語)と
affix語(接辞語)に関する情報を使用できないので、、別の辞書でなければなり
ません。補完辞書はもたないが、スペルチェック辞書はあもつ言語もいくつかあ
ります。

   Flyspellモードは、タイプした単語のスペルを自動的にチェックするマイナ
ーモードです。認識できない単語を見つけると、その単語をハイライトします。
‘M-x flyspell-mode’とタイプすると、カレントバッファーのFlyspellモードを
切り替えます。すべてのTextバッファーでFlyspellモードを有効にするには、
‘text-mode-hook’に、‘flyspell-mode’を追加します。*note Hooks::を参照して
ください。

   Flyspellモードが間違ったスペルの単語をハイライトしているとき、それを
‘mouse-2’ (‘flyspell-correct-word’)でクリックして、可能な定性とアクショ
ンを表示するメニューを表示できます。加えて‘C-.’、または‘<ESC>-<TAB>’
(‘flyspell-auto-correct-word’)はポイント位置の単語にたいする可能な訂正を
提案し、‘C-c $’ (‘flyspell-correct-word-before-point’)は可能な訂正のメニ
ューをポップアップします。もちろん、間違ったスペルの単語を、常にお好みの
方法で手修正できます。

   Flyspell Progモードは通常のFlyspellモードと同じように機能しますが、コ
メントと文字列に含まれた単語だけをチェックします。この機能はプログラムを
編集する場合に便利です。‘M-x flyspell-prog-mode’をタイプして、現在のバッ
ファーにたいするこのモードの有効と無効を切り替えます。すべてのプログラミ
ングに関連したモードでこのモードを有効にするには、‘prog-mode-hook’に
‘flyspell-prog-mode’を追加します(*note Hooks::を参照してください)。


File: emacs-ja.info,  Node: Keyboard Macros,  Next: Files,  Prev: Fixit,  Up: Top

17 キーボードマクロ
*******************

このチャプターでは一連の編集コマンドを記録して、後で簡単に繰り返す方法を
説明します。

   “キーボードマクロ(keyboard macro)”とは、Emacsのユーザーにより定義され
る、一連のキー入力からなるコマンドです。たとえば‘C-n M-d C-d’を40回繰り
返しタイプしていることに気付いたとしましょう。‘C-n M-d C-d’を行うキーボ
ードマクロを定義して、それを39回以上繰り返すことにより、作業スピードをあ
げることができます。

   キーボードマクロは、コマンドを実行・記録することにより定義します。違
う言い方をすると、キーボードマクロの定義では、初回はマクロの定義が実行さ
れるということです。この方法により、頭だけで考えるのではなく、コマンドの
影響を目で見ることができます。コマンド列の入力を終了して定義を終了すると
きは、キーボードマクロが定義されるとともに、入力したコマンド列の影響とし
てマクロが1回実行されたことになります。その後はマクロを呼び出すことによ
り、コマンド列全体を実行することができます。

   キーボードマクロは、LispではなくEmacsコマンド言語(Emacs command
language)で記述されている点が、通常のEmacsコマンドと異なります。しかし
Emacsコマンド言語は、高度なことや一般的なことを記述するプログラム言語と
して、充分にパワフルとはいえません。そのような事項には、Lispを使わなけれ
ばなりません。

* Menu:

* Basic Keyboard Macro::     キーボードマクロの定義と実行。
* Keyboard Macro Ring::      以前のキーボードマクロが保存される場所。
* Keyboard Macro Counter::   マクロに増加する番号を挿入する。
* Keyboard Macro Query::     毎回違うことを行うマクロの作成。
* Save Keyboard Macro::      キーボードマクロの命名とファイルへの保存。
* Edit Keyboard Macro::      キーボードマクロを編集するには。
* Keyboard Macro Step-Edit::  キーボードマクロのインタラクティブな実行と編集。


File: emacs-ja.info,  Node: Basic Keyboard Macro,  Next: Keyboard Macro Ring,  Up: Keyboard Macros

17.1 基本的な使い方
===================

‘<F3>’
     キーボードマクロの定義を開始します
     (‘kmacro-start-macro-or-insert-counter’)。
‘<F4>’
     キーボードマクロを定義しているときは定義を終了します。それ以外の場
     合は一番最近のキーボードマクロを実行します
     (‘kmacro-end-or-call-macro’)。
‘C-u <F3>’
     最後のキーボードマクロを再実行してから、キーをマクロ定義に追加しま
     す。
‘C-u C-u <F3>’
     最後のキーボードマクロを再実行せずに、キーをマクロ定義に追加します
     。
‘C-x C-k r’
     リージョンの中の各行の行頭にたいして、最後のキーボードマクロを実行
     します(‘apply-macro-to-region-lines’)。

   キーボードマクロの定義を開始するには、<F3>をタイプします。それからは
キーを入力して実行を続けますが、それは同時にマクロ定義の一部になります。
その間は、モードラインに‘Def’が表示されて、マクロの定義中であることを示
します。終了するときは<F4> (‘kmacro-end-or-call-macro’)をタイプして、定
義を終了します。たとえば、

     <F3> M-f foo <F4>

これは1単語前方に移動してから、‘foo’を挿入するマクロを定義します。<F3>と
<F4>は、マクロの一部とはならないことに注意してください。

   マクロを定義した後は、<F4>でそれを呼び出すことができます。上記の例で
は、それは‘M-f foo’ againをタイプしたのと同じ効果をもちます(<F4>コマンド
の2つの役割に注意してください。これはマクロを定義しているときはマクロの
定義を終了し、そうでないときは最後のマクロを呼び出します)。<F4>に数引数
‘n’を与えることもできます。これはマクロを‘n’回呼び出すことを意味します。
引数に0を与えると、エラーになるか、‘C-g’(MS-DOSでは‘C-<BREAK>’)をタイプ
するまで、マクロを永久に繰り返します。

   上記の例は、キーボードマクロを使った便利なトリックをデモンストレイト
する例です。テキストの一定間隔の位置にたいして繰り返し操作を行いたいとき
は、マクロの一部に移動コマンドを含めます。この例ではマクロの繰り返しによ
り、連続する単語の後ろに文字列‘foo’を挿入していきます。

   キーボードマクロの定義を終了した後でも、‘C-u <F3>’をタイプすることに
より、マクロの定義にキーストロークを追加できます。これは<F3>に続けてマク
ロの定義を再タイプするのと同じです。結果として、そのマクロの以前の定義が
再実行されることになります。変数‘kmacro-execute-before-append’を‘nil’に
変更すると、既存のマクロにキーストロークが追加されるまでは実行されません
(デフォルトは‘t’)。最後に実行したキーボードマクロを再実行することなく、
定義の最後にキーストロークを追加するには、‘C-u C-u <F3>’をタイプしてくだ
さい。

   コマンドがミニバッファーから引数を読みとる場合、ミニバッファーにたい
する入力は、コマンドと一緒にマクロの一部となります。したがってマクロを再
生すると、そのコマンドの引数は入力されたのと同じになります。たとえば、

     <F3> C-a C-k C-x b foo <RET> C-y C-x b <RET> <F4>

これはカレント行をkillして、バッファー‘foo’にそれをyankした後、元のバッ
ファーに戻ります。

   ほとんどのキーボードコマンドは、キーボードマクロの定義で普通に機能し
ますが、いくつか例外があります。‘C-g’ (‘keyboard-quit’)をタイプすると、
キーボードマクロの定義が終了します。‘C-M-c’ (‘exit-recursive-edit’)は信
頼できません。これはマクロの中で再帰編集(recursive edit)を開始したときは
期待通りに再帰編集から抜け出しますが、キーボードマクロの呼び出し前に開始
された再帰編集を抜け出すには、キーボードマクロからも抜け出す必要がありま
す。同様に、マウスイベントもキーボードマクロで使用できますが。信頼はでき
ません。マクロによりマウスイベントが再生されるときは、マクロを定義したと
きのマウス位置が使用されます。この効果は予測が困難です。

   コマンド‘C-x C-k r’ (‘apply-macro-to-region-lines’)は、リージョン内の
各行のにたいして、最後に定義されたキーボードマクロを繰り返します。これは
1行ずつポイントをリージョン内の行頭に移動してからマクロを実行します。

   上記で説明した<F3>と<F4>に加えて、Emacsはキーボードマクロを定義したり
実行するための、古いキーバインドもサポートします。<F3>と同様にマクロ定義
を開始するには、‘C-x (’ (‘kmacro-start-macro’)とタイプします。プレフィク
ス引数を指定すると、最後のキーボードマクロの定義に追加します。マクロ定義
を終了するには‘C-x )’ (‘kmacro-end-macro’)とタイプします。一番最近のマク
ロを実行するには、‘C-x e’ (‘kmacro-end-and-call-macro’)とタイプします。
マクロ定義中に‘C-x e’を入力すると、マクロ定義を終了してからすぐに実行さ
れます。‘C-x e’をタイプした後すぐに‘e’をタイプすることにより、そのマクロ
を１回以上繰り返すことができます。(マクロの実行に使用されるときの)<F4>と
同様、‘C-x e’には繰り返し回数を引数指定できます。

   ‘C-x )’に、繰り返し回数を引数として与えることができます。これはマクロ
を定義した後、すぐにマクロが繰り返されることを意味します。マクロの定義は
、定義することによりマクロが実行されるので、最初の1回として数えられます
。したがって‘C-u 4 C-x )’は、マクロを3回すぐに追加実行します。


File: emacs-ja.info,  Node: Keyboard Macro Ring,  Next: Keyboard Macro Counter,  Prev: Basic Keyboard Macro,  Up: Keyboard Macros

17.2 キーボードマクロリング
===========================

すべての定義されたキーボードマクロは、“キーボードマクロリング(keyboard
macro ring)”に記録されます。キーボードマクロリングはすべてのバッファーで
共有され、1つだけしかありません。

‘C-x C-k C-k’
     リングの先頭にあるキーボードマクロを実行します
     (‘kmacro-end-or-call-macro-repeat’)。
‘C-x C-k C-n’
     キーボードマクロリングを、次のマクロ(古く定義されたもの)にローテー
     トします(‘kmacro-cycle-ring-next’)。
‘C-x C-k C-p’
     キーボードマクロリングを前のマクロ(新しく定義されたもの)にローテー
     トします(‘kmacro-cycle-ring-previous’)。

   キーボードマクロリングを操作するすべてのコマンドは、同じ‘C-x C-k’を使
います。これらのコマンドでは、すぐ後にコマンドを実行して繰り返す場合には
、互いに‘C-x C-k’プレフィクスを必要としません。たとえば、

     C-x C-k C-p C-p C-k C-k C-k C-n C-n C-k C-p C-k C-d

これは、キーボードマクロリングを2つ前のマクロが先頭にくるようにローテー
トして、3回実行します。次にキーボードマクロリングをローテートして、元は
先頭だったマクロを先頭に戻して１回実行します。次にキーボードマクロリング
を1つ前のマクロが先頭にくるようにローテートして、それを実行します。そし
て最後にそれを削除しています。

   コマンド‘C-x C-k C-k’ (‘kmacro-end-or-call-macro-repeat’)は、マクロリ
ングの先頭にあるキーボードマクロを実行します。もう一度すぐに‘C-k’をタイ
プすると、マクロを繰り返すことができます。すぐに‘C-n’か‘C-p’をタイプすれ
ば、マクロリングをローテートすることができます。

   キーボードマクロを定義しているとき、‘C-x C-k C-k’は<F4>と同様に振る舞
いますが、すぐ後にタイプされた場合は異なります。このセクションで説明する
ほとんどのキーバインドは、‘C-x C-k’プレフィクスが必要ない場合があります
。たとえば、すぐに‘C-k’をタイプした場合は、マクロを再実行します。

   コマンド‘C-x C-k C-n’ (‘kmacro-cycle-ring-next’)および‘C-x C-k C-p’
(‘kmacro-cycle-ring-previous’)は、マクロリングをローテートして、次または
前のキーボードマクロをリングの先頭に移動させます。新しく先頭となったマク
ロの定義は、エコーエリアに表示されます。お望みのマクロが先頭にくるまで、
すぐに‘C-n’または‘C-p’を繰り返しタイプすれば、マクロリングのローテートを
続けることができます。新しくマクロリングの先頭にきたマクロを実行するには
、単に‘C-k’をタイプします。

   Emacsはマクロリングの先頭を、最後に定義されたキーボードマクロとして扱
います。たとえば、そのマクロは<F4>で実行でき、‘C-x C-k n’で名前をつける
ことができます。

   キーボードマクロリングに格納できるマクロの最大数は、カスタマイズ可能
な変数‘kmacro-ring-max’により決定されます。


File: emacs-ja.info,  Node: Keyboard Macro Counter,  Next: Keyboard Macro Query,  Prev: Keyboard Macro Ring,  Up: Keyboard Macros

17.3 キーボードマクロカウンター
===============================

キーボードマクロには、それぞれカウンターが割り当てられています。これはマ
クロの定義を開始したとき0に初期化されます。カウンターの数値をバッファー
に挿入することもできます。カウンターの数値は、マクロが呼び出された回数に
もとづきます。バッファーにカウンターの値が挿入される度に、カウンターは増
加します。

‘<F3>’
     キーボードマクロの定義では、キーボードマクロカウンターの値をバッフ
     ァーに挿入します(‘kmacro-start-macro-or-insert-counter’)。
‘C-x C-k C-i’
     キーボードマクロカウンターの値をバッファーに挿入します
     (‘kmacro-insert-counter’)。
‘C-x C-k C-c’
     キーボードマクロカウンターをセットします(‘kmacro-set-counter’)。
‘C-x C-k C-a’
     プレフィクス引数をキーボードマクロカウンターに加えます
     (‘kmacro-add-counter’)。
‘C-x C-k C-f’
     挿入するキーボードマクロカウンターの書式を指定します
     (‘kmacro-set-format’)。

   キーボードマクロを定義しているとき、コマンド<F3>
(‘kmacro-start-macro-or-insert-counter’)は、キーボードマクロカウンターの
現在の値をバッファーに挿入して、カウンターを1増加させます(マクロを定義し
ていないとき、<F3>はマクロの定義を開始します。*note Basic Keyboard
Macro::を参照してください)。異なる増分の指定には、数引数を使うことができ
ます。単にプレフィクス‘C-u’を指定すると、それは0増加させるのと同じです。
つまり現在のカウンターの値を挿入しますが、カウンターの値は変化しません。

   例として数字が振られたリストを構築するために、キーボードマクロカウン
ターを使う方法を見てみましょう。以下のキーシーケンスを考えてください:

     <F3> C-a <F3> . <SPC> <F4>

マクロ定義の一部として、現在の行の先頭に文字列‘0. ’が挿入されます。バッ
ファーの他の箇所で<F4>でマクロを呼び出すと、その行の先頭に文字列‘1. ’が
挿入されます。その後に呼び出すと‘2. ’、‘3. ’、...が挿入されます。

   コマンド‘C-x C-k C-i’ (‘kmacro-insert-counter’)は、<F3>と同様のことを
行いますが、これはキーボードマクロの定義外でも使用できます。キーボードマ
クロが定義中でなく実行もされていない場合、これはキーボードマクロリングの
先頭にあるマクロのカウンター値を挿入および増加します。

   コマンド‘C-x C-k C-c’ (‘kmacro-set-counter’)は現在のマクロカウンター
を、数引数の値にセットします。マクロ内で使用した場合、マクロ実行ごとに処
理します。プレフィクス引数に単に‘C-u’を指定した場合、マクロの現在の繰り
返し実行おいて、カウンターが最初にもっていた値に、カウンターをリセットし
ます(この繰り返しにおける増加を取り消します)。

   コマンド‘C-x C-k C-a’ (‘kmacro-add-counter’)は、プレフィクス引数を現
在のマクロカウンターに加えます。単に‘C-u’を引数に指定すると、任意のキー
ボードマクロにより最後に挿入された値に、カウンターをリセットします(通常
これを使うときは、最後の挿入は同じマクロによる同じカウンターです)。

   コマンド‘C-x C-k C-f’ (‘kmacro-set-format’)は、マクロカウンターを挿入
するときに使われる書式の入力を求めます。デフォルトの書式は‘%d’で、これは
パディングなしの10進数字が挿入されることを意味します。ミニバッファーに何
も入力せずにexitすることにより、このデフォルト書式にリセットできます。
‘format’関数(この関数はさらに1つの整数の引数をとります)が受け入れる書式
文字列を指定できます(*note (elisp)Formatting Strings::を参照してください
)。ミニバッファーに書式文字列を入力するときは、書式文字列をダブルクォー
テーションで括らないでください。

   キーボードマクロの定義および実行がされていないときにこのコマンドを使
うと、新しい書式はそれ以降のマクロ定義すべてに影響を及ぼします。既存のマ
クロは、それが定義されたときの書式を使いつづけます。キーボードマクロ定義
中に書式をセットすると、そのマクロが定義されている箇所に影響を及ぼします
が、それ以降のマクロには影響を与えません。マクロの実行においては、そのマ
クロ定義の時点の書式が使われます。マクロの実行中にマクロ書式を変更すると
、これは定義中における書式の変更と同様、それ以降のマクロに影響を与えませ
ん。

   ‘C-x C-k C-f’によりセットされた書式は、レジスターに格納された数字の挿
入には影響しません。

   マクロの繰り返しにおいてレジスターを増加してカウンターとして使う場合
、これはキーボードマクロカウンターと同じことです。*note Number
Registers::を参照してください。大抵の用途では、キーボードマクロカウンタ
ーを使う方が単純です。


File: emacs-ja.info,  Node: Keyboard Macro Query,  Next: Save Keyboard Macro,  Prev: Keyboard Macro Counter,  Up: Keyboard Macros

17.4 変化のあるマクロの実行
===========================

キーボードマクロで、‘query-replace’のように変更を行うか応答を求める効果
を作ることができます。

‘C-x q’
     マクロ実行中にこの箇所に到達すると確認を求めます
     (‘kbd-macro-query’)。

   マクロ定義中に問い合わせを行いたい箇所で‘C-x q’をタイプします。マクロ
定義中は‘C-x q’は何も行いませんが、後でマクロを実行すると‘C-x q’は実行を
続けるか対話的に確認を求めます。

   以下は‘C-x q’にたいする有効な応答です:

<SPC> (または‘y’)
     キーボードマクロの実行を続けます。

<DEL> (または‘n’)
     マクロのこの繰り返しでの残りの部分をスキップして、次の繰り返しを開
     始します。

<RET> (または‘q’)
     マクロのこの繰り返しでの残りの部分をスキップして、これ以上の繰り返
     しを取り消します。

‘C-r’
     マクロの一部ではない編集を行うことができる、再帰編集レベル
     (recursive editing level)に入ります。‘C-M-c’を使って再帰編集を抜け
     ると、キーボードマクロを続行するか再び確認を求められます。ここで
     <SPC>をタイプすると、マクロ定義の残りの部分が実行されます。マクロの
     残りの部分が期待したように動作するためにポイントとテキストを残すの
     は、ユーザーの責任です。

   ‘C-x q’に数引数を指定した‘C-u C-x q’は、完全に異なる関数を実行します
。これはマクロ定義中およびマクロ実行中の両方で、キーボード入力を読みとる
再帰編集に入ります。定義中のときは、再帰編集の中で行った編集はマクロの一
部とはなりません。マクロ実行中は、再帰編集により各繰り返しにおいて特別な
編集を行う機会が与えられます。*note Recursive Edit::を参照してください。


File: emacs-ja.info,  Node: Save Keyboard Macro,  Next: Edit Keyboard Macro,  Prev: Keyboard Macro Query,  Up: Keyboard Macros

17.5 キーボードマクロの命名と保存
=================================

‘C-x C-k n’
     一番最近定義したキーボードマクロに、名前(持続期間はEmacsセッション
     中)を与えます(‘kmacro-name-last-macro’)。
‘C-x C-k b’
     一番最近定義したキーボードマクロを、キーにバインド(持続期間は
     Emacsセッション中)します(‘kmacro-bind-to-key’)。
‘M-x insert-kbd-macro’
     キーボードマクロの定義を、Lispコードとしてバッファーに挿入します。

   キーボードマクロを後で使うために保存するには、‘C-x C-k n’
(‘kmacro-name-last-macro’)を使って、それに名前を与えることができます。こ
れはミニバッファーを使って名前を引数として読み取り、最後のキーボードマク
ロの現在の定義を実行するための、名前を定義します(後でこのマクロの定義を
追加した場合、その名前のマクロ定義は変更されません)。マクロ名はLispシン
ボルで、‘M-x’で呼び出せ、‘global-set-key’でキーにバインドできる有効な名
前をつけます。キーボードマクロ以外に定義されている名前を指定すると、エラ
ーメッセージが表示され何も変更はされません。

   ‘C-x C-k b’ (‘kmacro-bind-to-key’)の後に、バインドしたいキーシーケン
スを続けることにより、最後のキーボードマクロ(の現在の定義)をキーにバイン
ドすることもできます。グローバルキーマップ(global keymap)の任意のキーシ
ーケンスにバインドできますが、大部分のキーシーケンスはすでに他のバインド
をもっているので、キーシーケンスの選択は慎重に行う必要があります。任意の
キーマップで既存のバインドをもつキーシーケンスにバインドしようとすると、
既存のバインドを置き換える前に確認を求めます。

   既存のバインドの上書きに起因する問題を避けるには、キーシーケンス‘C-x
C-k 0’から‘C-x C-k 9’と、‘C-x C-k A’から‘C-x C-k Z’を使います。これらの
キーシーケンスは、キーボードマクロのバインド用に予約されています。これら
のキーシーケンスにバインドするには、キーシーケンス全体ではなく数字か文字
だけをタイプすればバインドできます。たとえば、

     C-x C-k b 4

これは最後のキーボードマクロをキーシーケンス‘C-x C-k 4’にバインドします
。

   1度マクロにコマンド名をつければ、その定義をファイルに保存できます。そ
れは他の編集セッションでも使用できます。最初に定義を保存したいファイルを
visitします。次に以下のコマンドを使います:

     M-x insert-kbd-macro <RET> MACRONAME <RET>

これは後で実行するとき、今と同じ定義のマクロとなるLispコードをバッファー
に挿入します(これを行うためにLispコードを理解する必要はありません。なぜ
ならあなたのかわりに‘insert-kbd-macro’がLispコードを記述するからです)。
それからファイルを保存します。後でそのファイルを‘load-file’ (*note Lisp
Libraries::を参照してください)でロードできます。initファイル‘~/.emacs’
(*note Init File::を参照してください)に保存すれば、そのマクロはEmacsを実
行する度に定義されます。

   ‘insert-kbd-macro’に数引数を与えると、(もしあれば)MACRONAMEにバインド
したキーを記録するためのLispコードが追加されるので、ファイルをロードした
とき同じキーにマクロが割り当てられます。


File: emacs-ja.info,  Node: Edit Keyboard Macro,  Next: Keyboard Macro Step-Edit,  Prev: Save Keyboard Macro,  Up: Keyboard Macros

17.6 キーボードマクロの編集
===========================

‘C-x C-k C-e’
     最後に定義されたキーボードマクロを編集します(‘kmacro-edit-macro’)。
‘C-x C-k e NAME <RET>’
     以前に定義されたキーボードマクロNAMEを編集します
     (‘edit-kbd-macro’)。
‘C-x C-k l’
     過去300回分のキーストロークを、キーボードマクロとして編集します
     (‘kmacro-edit-lossage’)。

   ‘C-x C-k C-e’または‘C-x C-k <RET>’ (‘kmacro-edit-macro’)をとタイプし
て、最後のキーボードマクロを編集できます。これはマクロ定義をバッファーに
整形出力して、それを編集するために特化したモードに入ります。そのバッファ
ーで‘C-h m’をタイプすると、マクロを編集する方法の詳細が表示されます。編
集を終了するには‘C-c C-c’をタイプしてください。

   名前をつけたキーボードマクロ、またはキーにバインドしたマクロは、‘C-x
C-k e’ (‘edit-kbd-macro’)とタイプして編集できます。このコマンドに続けて
そのマクロを呼び出すときのキー入力(‘C-x e’、‘M-x NAME’、またはその他のキ
ーシーケンス)を入力します。

   ‘C-x C-k l’ (‘kmacro-edit-lossage’)とタイプして、最近300回のキースト
ロークをマクロとして編集できます。


File: emacs-ja.info,  Node: Keyboard Macro Step-Edit,  Prev: Edit Keyboard Macro,  Up: Keyboard Macros

17.7 キーボードマクロのステップ編集
===================================

‘C-x C-k <SPC>’ (‘kmacro-step-edit-macro’)とタイプして、最後のキーボード
マクロをインタラクティブに1コマンドずつ再生および編集できます。マクロを
‘q’または‘C-g’で終了しなければ、編集されたマクロでマクロリングの最後のマ
クロを置き換えます。

   このマクロ編集機能は、最初(または次)に実行されるコマンドと、それにた
いする操作を尋ねるプロンプトをミニバッファーに表示します。‘?’を入力すれ
ば、オプションの要約を表示できます。以下のオプションが利用可能です:

   • <SPC>および‘y’は、現在のコマンドを実行して、キーボードマクロの次の
     コマンドに進みます。
   • ‘n’、‘d’、および<DEL>は、現在のコマンドをスキップして削除します。
   • ‘f’は、キーボードマクロの実行において現在のコマンドをスキップします
     が、マクロから削除はしません。
   • <TAB>は、現在のコマンドと、現在のコマンドのすぐ後に続く同じようなコ
     マンドを実行します。たとえば連続する文字の挿入
     (‘self-insert-command’に相当)には、<TAB>が使われます。
   • ‘c’は、(これ以上の編集は行わずに)キーボードマクロの最後まで実行を続
     けます。実行が正常に終了した場合、編集されたマクロで元のキーボード
     マクロを置き換えます。
   • ‘C-k’は、キーボードマクロの残りの部分をスキップおよび削除して、ステ
     ップ編集を終了し、編集されたマクロで元のキーボードマクロを置き換え
     ます。
   • ‘q’および‘C-g’は、キーボードマクロのステップ編集を取り消して、キー
     ボードマクロにたいして行った編集を破棄します。
   • ‘i KEY... C-j’は、一連のキーシーケンス(最後の‘C-j’は含まれません)を
     読み取って実行し、キーボードマクロの現在のコマンドの前に挿入します
     (現在のコマンドはスキップしません)。
   • ‘I KEY...’は、1つのキーシーケンスを読み取って実行し、キーボードマク
     ロの現在のコマンドの前に挿入します(現在のコマンドはスキップしません
     )。
   • ‘r KEY... C-j’は、一連のキーシーケンス(最後の‘C-j’は含まれません)を
     読み取って実行し、現在のコマンドをそれで置き換えます(実行は挿入され
     たキーシーケンスの次に移ります)。
   • ‘R KEY...’は、1つのキーシーケンスを読み取って実行し、キーボードマク
     ロの現在のコマンドを、そのキーシーケンスで置き換えます(実行は挿入さ
     れたキーシーケンスの次に移ります)。
   • ‘a KEY... C-j’は、現在のコマンドを実行してから、一連のキーシーケン
     ス(最後の‘C-j’は含まれません)を読み取って実行してから、それをキーボ
     ードマクロの現在のコマンドの後ろに挿入します(実行は現在のコマンドと
     、その後ろに挿入されたキーシーケンスの次に移ります)。
   • ‘A KEY... C-j’は、キーボードマクロの残りのコマンドを実行してから、
     一連のキーシーケンス(最後の‘C-j’は含まれません)を読み取って実行し、
     それらをキーボードマクロの最後に追加します。それからステップ編集を
     終了し、編集されたマクロで元の元のキーボードマクロを置き換えます。


File: emacs-ja.info,  Node: Files,  Next: Buffers,  Prev: Keyboard Macros,  Up: Top

18 ファイルの処理
*****************

オペレーティングシステムは“ファイル”にデータを永続化するので、Emacsで編
集するテキストの大部分はファイルから読み込んで、最終的にファイルに格納し
ます。

   ファイルを編集するには、Emacsにファイルを読み込み、ファイルのテキスト
を含むバッファーを準備するよう、指示しなければなりません。これを、ファイ
ルの“visit(訪問)”と呼びます。編集コマンドは直接バッファーのテキスト、つ
まりEmacs内部のコピーに適用されます。変更がファイルに反映されるのは、バ
ッファーをファイルに“保存(save)”したときだけです。

   ファイルのvisitや保存に加え、Emacsはファイルの削除、コピー、名前の変
更、ファイルへの追加、ファイルの複数バージョンの保持、ディレクトリーの操
作を行うことができます。

* Menu:

* File Names::               ファイル名引数をタイプ、編集する方法。
* Visiting::                 ファイルをvisitしてEmacsが編集する準備をする。
* Saving::                   保存して変更を永続化する。
* Reverting::                保存されていないすべての変更を取り消して前の状態に戻す。
* Autorevert:: 非ファイルバッファーの自動リバートについて。
* Auto Save::                定期的な自動保存によりデータを失うことから守る。
* File Aliases::             1つのファイルにたいする複数の名前を処理する。
* Directories::              ファイルディレクトリーの削除、作成、一覧。
* Comparing Files::          2つのファイルの異なる部分を探す。
* Diff Mode::                ファイルの異なる部分を編集するモード。
* Copying and Naming::       ファイルのコピー、命名、リネーム。
* Misc File Ops::            ファイルにたいして行うその他のコマンド。
* Compressed Files::         圧縮されたファイルへのアクセス。
* File Archives::            tar、zip、jar、...などのアーカイブファイルにたいする操作。
* Remote Files::             他のマシンにあるファイルへのアクセス。
* Quoted File Names::        ファイル名に含まれる特別な文字のクォート。
* File Name Cache::          補完のための、よく使うファイルの一覧。
* File Conveniences::        ファイルを探すための便利な機能。
* Filesets::                 複数ファイルの処理。


File: emacs-ja.info,  Node: File Names,  Next: Visiting,  Up: Files

18.1 ファイルの名前
===================

ファイルを操作するEmacsコマンドの多くは、ミニバッファー(*note Minibuffer
File::を)を使って、ファイル名の指定を求めます。

   ミニバッファーでは、通常の補完およびヒストリーコマンドを使うことがで
きます(*note Minibuffer::を参照してください)。ファイル名の補完では、ファ
イル名の拡張子が変数‘completion-ignored-extensions’に含まれているファイ
ルは無視されます(*note Completion Options::を参照してください)。またほと
んどのコマンドは、ファイルの読み込みにおいて、確認をともなう寛大な補完
(permissive completion with confirmation)を使います。この補完では、存在
しないファイル名が許されますが、存在しないファイル名の入力を完了するため
に<RET>をタイプすると、Emacsは‘[Confirm]’を表示し、この確認に同意するた
めに2番目の<RET>をタイプしなければなりません。詳細については、*note
Completion Exit::を参照してください。

   ミニバッファーのヒストリーコマンドは、ファイル名を読み取るための特別
な機能をいくつか提供します。*note Minibuffer History::を参照してください
。

   それぞれのバッファーは、バッファーローカルな変数‘default-directory’に
、“デフォルトのディレクトリー”を格納しています。ミニバッファーを使ってフ
ァイル名を読み取るとき、通常Emacsはミニバッファーの初期内容として、デフ
ォルトディレクトリーを挿入します。変数‘insert-default-directory’を
‘nil’に変更することにより、この挿入を抑制できます。常にEmacsは任意の相対
パスで指定されたファイル名を、デフォルトディレクトリーにたいする相対パス
とみなします。たとえばディレクトリーを指定しないファイル名は、デフォルト
ディレクトリーのファイルを指定します。

   ファイルをvisitするとき、Emacsはvisitしているバッファーの
‘default-directory’に、そのファイルのディレクトリーをセットします。‘C-x
b’のようなコマンドを通じて、ファイルをvisitしていないバッファーを新たに
作成すると、通常そのバッファーのデフォルトディレクトリーは、現在のバッフ
ァーのデフォルトディレクトリーをコピーします。現在のバッファーの
‘default-directory’の値を見るために、‘M-x pwd’コマンドを使用できます。
‘M-x cd’コマンドはディレクトリー名の入力を求め、バッファーの
‘default-directory’もそのディレクトリーをセットします(これを行うことによ
りバッファーのファイル名は変更されません)。

   例として、ファイル‘/u/rms/gnu/gnu.tasks’をvisitしているとします。この
ときデフォルトディレクトリーは‘/u/rms/gnu/’にセットされます。ファイル名
を読み取るコマンドを呼び出して、ミニバッファーでディレクトリー名を省略し
て単に‘foo’と入力すると、これはファイル‘/u/rms/gnu/foo’を指定したことに
なります。‘../.login’と入力すると‘/u/rms/.login’、‘new/foo’と入力すると
‘/u/rms/gnu/new/foo’を指定したことになります。

   ミニバッファーにファイル名をタイプするとき、2つのショートカットを使う
ことができます。2つのスラッシュは、2番目のスラッシュの前にあるすべてを無
視します。そして‘~/’は、ユーザーのホームディレクトリーです。*note
Minibuffer File::を参照してください。

   文字‘$’は、ファイル名を置き換える環境変数の代用として使われます。環境
変数の名前は、‘$’の後ろのすべての英数字から構成されます。‘$’の後ろの、大
カッコ(braces)に囲まれた変数名も使用できます。たとえばシェルコマンド
‘export FOO=rms/hacks’は、名前が‘FOO’の環境変数をセットするために使われ
ます。すると‘/u/$FOO/test.c’と‘/u/${FOO}/test.c’はどちらも、
‘/u/rms/hacks/test.c’の省略形となります。環境変数が定義されていないとき
は、何の置き換えも発生せず、文字‘$’はそれ自身を意味します。Emacs外部でセ
ットされた環境変数は、それがEmacsの開始前に適用されたときだけ、Emacsに影
響を与えることに注意してください。

   ‘$’により環境変数が展開されるようなとき、名前に‘$’を含むファイルにア
クセスする場合は、‘$$’とタイプします。1つの‘$’が環境変数を展開するのと同
時に、2つのペアは1つの‘$’に変換されます。かわりにファイル名を‘/:’でクォ
ートすることもできます(*note Quoted File Names::を参照してください)。名
前が文字‘~’で始まるファイル名も、‘/:’でクォートするべきです。

   ファイル名に非ASCII文字を含めることができます。*note File Name
Coding::を参照してください。


File: emacs-ja.info,  Node: Visiting,  Next: Saving,  Prev: File Names,  Up: Files

18.2 ファイルのvisit(訪問)
==========================

‘C-x C-f’
     ファイルをvisitします(‘find-file’)。
‘C-x C-r’
     変更を許さない閲覧用として、ファイルをvisitします
     (‘find-file-read-only’)。
‘C-x C-v’
     最後にvisitしたファイルとは異なるファイルを、かわりにvisitします
     (‘find-alternate-file’)。
‘C-x 4 f’
     別のウィンドウでファイルをvisitします(‘find-file-other-window’)。選
     択されたウィンドウに表示されているものは変更しません。
‘C-x 5 f’
     新しいフレームでファイルをvisitします(‘find-file-other-frame’)。選
     択されたフレームに表示されているものは変更しません。
‘M-x find-file-literally’
     内容を変換せずにファイルをvisitします。

   ファイルを“Visiting(訪問)”するとは、そのファイル内容をEmacsのバッファ
ーに読み込むことを意味するので、それを編集することができます。Emacsは
visitするファイルごとに、新しいバッファーを作成します。

   ファイルをvisitするには、‘C-x C-f’ (‘find-file’)とタイプして、visitし
たいファイルの名前をミニバッファーで入力します。ミニバッファーでは、
‘C-g’をタイプして、コマンドを中止することができます。ミニバッファーでの
ファイル名の入力についての詳細は、*note File Names::を参照してください。

   ファイルは存在するが、システムが読み込みを許さない場合、エコーエリア
にエラーメッセージが表示されます(GNUおよびUnixシステムでは、‘su’や
‘sudo’のような方法を使用して、そのようなファイルをvisitできるかもしれな
い。*note Remote Files::を参照されたい。) それ以外の場合、スクリーンに新
しいテキストが表示され、モードラインバッファー名が表示されることで、‘C-x
C-f’が成功したことを知ることができます。通常Emacsは、ファイル名からディ
レクトリー名を省いて、バッファー名を作ります。たとえば
‘/usr/rms/emacs.tex’という名前のファイルは、バッファー名‘emacs.tex’とな
ります。その名前のバッファーがすでにある場合、Emacsは一意な名前を作りま
す。通常の方法はディレクトリー名にもとづく接尾辞の追加です(たとえば
‘<rms>’、‘<tmp>’など)が、違う方法を選択することもできます。*note
Uniquify::を参照してください。

   新しいファイルを作成するには、同じコマンド‘C-x C-f’を使ってvisitする
だけです。Emacsはエコーエリアに‘(New file)’と表示しますが、他の点では既
存の空のファイルをvisitしたのと同じく振る舞います。

   ファイルをvisitした後で編集コマンドにより行われた変更は、Emacsのバッ
ファーに反映されます。バッファーを“保存(save)”するまでは、visitしている
ファイルに影響はありません。バッファーが保存されていない変更を含むとき、
そのバッファーが“変更されている(modified)”といいます。これはバッファーを
保存しなければ、その変更が失われることを意味します。モードラインの左余白
の近くに2つのアスタリスクが表示され、バッファーが変更されていることを示
します。

   すでにEmacsがvisitしているファイルをvisitした場合、‘C-x C-f’は他のコ
ピーを作らず既存のバッファーに切り替えます。切り替えを行う前に、最後に
visitまたは保存した後にファイルが変更されているか確認します。もしファイ
ルが変更されているとき、Emacsはそれの再読み込みを提案します。

   ‘large-file-warning-threshold’ (デフォルトは10000000で、これは約
10MB)より大きなファイルのvisitを試みると、Emacsは最初に確認を求めます。
‘y’を応えることにより、ファイルのvisitを続けます。しかしEmacsは、Emacsバ
ッファーの最大サイズ(Emacsが割り当てられるメモリー量の制限と、Emacsが扱
える整数により制限されます)を超えるバッファーは、visitできないことに注意
してください。この場合、Emacsは最大バッファーサイズを超えた旨を知らせる
エラーメッセージを表示します。

   ファイル名にシェル形式のワイルドカード文字が含まれている場合、Emacsは
それにマッチするすべてのファイルをvisitします。(大文字小文字を区別しない
ファイルシステムでは、Emacsは大文字小文字に関係なくワイルドカードをマッ
チします)。ワイルドカードには‘?’、‘*’および‘[...]’シーケンスが含まれます
。ミニバッファーでワイルドカード‘?’をファイル名に入力するには、‘C-q ?’と
タイプする必要があります。ワイルドカード文字を実際に名前に含むファイルを
visitする方法についての情報は、*note Quoted File Names::を参照してくださ
い。‘find-file-wildcards’をカスタマイズして、ワイルドカード機能を無効に
することができます。

   無意識に間違ったファイル名をタイプして違うファイルをvisitした場合、
‘C-x C-v’ (‘find-alternate-file’)で実際に望むファイルをvisitできます。
‘C-x C-v’は‘C-x C-f’と似ていますが、これは現在のバッファーをkillします
(変更されている場合は最初に保存するか確認を求めます)。‘C-x C-v’がvisitす
るファイルの名前を読み取るときは、ミニバッファーにデフォルトのファイル名
全体を挿入して、ポイントをディレクトリー名の後に置きます。これは名前を少
し間違えた場合などに便利です。

   実際はディレクトリーであるファイルをvisitしたとき、EmacsはEmacsのディ
レクトリーブラウザーのDiredを呼び出します。*note Dired::を参照してくださ
い。この振る舞いは、変数‘find-file-run-dired’を‘nil’にセットすることによ
り無効にできます。この場合、ディレクトリーをvisitするとエラーになります
。

   実際には他のファイルの集まりであるような“アーカイブファイル(file
archives)”の場合、アーカイブされたメンバーを操作できる、Diredに似た環境
を呼び出す特別なモードでvisitします。これらの機能については、*note File
Archives::を参照してください。

   オペレーティングシステムが変更を許していない、または読み取り専用にし
ているファイルをvisitした場合、Emacsもバッファーを読み取り専用にするので
、保存すると問題を起こすような変更を防ぐことができます。‘C-x C-q’
(‘read-only-mode’)で、バッファーを書き込み可能にできます。*note Misc
Buffer::を参照してください。

   予期せぬ入力による変更を防ぐために、読み込み専用でファイルをvisitした
い場合は、‘C-x C-f’のかわりにコマンド‘C-x C-r’ (‘find-file-read-only’)で
visitします。

   ‘C-x 4 f’ (‘find-file-other-window’)は‘C-x C-f’と同様ですが、指定した
ファイルを含むバッファーは、別のウィンドウで選択されます。‘C-x 4 f’の前
に選択されていたウィンドウは、すでに表示していたのと同じバッファーの表示
を続けます。1つのウィンドウしか表示されていないときにこのコマンドを使う
と、これはウィンドウを2つに分割し、1つのウィンドウには前に表示されていた
のと同じバッファー、別の1つには新しい要求されたファイルを表示します。
*note Windows::を参照してください。

   ‘C-x 5 f’ (‘find-file-other-frame’)も同様ですが、新しいフレームををオ
ープンするか、指定したファイルをすでに表示している既存のフレームを選択し
ます。*note Frames::を参照してください。

   グラフィカルなディスプレーでは、ファイルをvisitする追加の方法が２つあ
ります。1つ目は、Emacsが適したGUIツールキットによりビルドされているとき
、マウスによるコマンドの呼び出し(メニューバーやツールバーのクリックによ
る)は、ミニバッファーでファイル名の入力を求める代わりに、そのツールキッ
ト標準のファイル選択(file selection)ダイアログを表示します。GNU/Linuxお
よびUnixプラットフォームでは、GTK+、LessTif、Motifツールキットとともに構
築されていると、Emacsはこれを行います。MS-WindowsとMacでは、GUIバージョ
ンのデフォルトにより行われます。これをカスタマイズする情報については、
*note Dialog Boxes::を参照してください。

   2つ目は、Emacsはのドラッグアンドドロップ(drag and drop)サポートで、通
常のEmacsウィンドウにファイルをドロップすることにより、そのウィンドウで
ファイルをvisitします。例外としてDiredバッファーを表示しているウィンドウ
にファイルをドロップすると、表示されているディレクトリーにファイルを移動
またはコピーします。詳細については*note Drag and Drop::と*note Misc
Dired Features::を参照してください。

   テキスト端末、およびGUIツールキットなしでビルドされているグラフィカル
なディスプレーでは、アイテム‘Visit New File’と‘Open File’をもつメニュー
バーの‘File’メニューから、、ファイルをvisitできます。

   文字エンコーディングと使用されている改行規則を検知するために、Emacsは
自動的に内容をスキャンします。そして、それらをEmacsの内部エンコーディン
グとバッファーの改行規則に変換します。バッファーを保存するとき、Emacsは
逆の変換を行い、元のエンコーディングと改行規則でファイルをディスクに書き
込みます。*note Coding Systems::を参照してください。

   ファイルにたいして特別なエンコーディングや変換を行わずに、非ASCII文字
のシーケンスとして編集したいときは、‘M-x find-file-literally’コマンドを
使います。これは‘C-x C-f’と同様ですが、フォーマット変換(*note Format
Conversion: (elisp)Format Conversion.を参照してください)、文字コード変換
(*note Coding Systems::を参照してください)、自動解凍(*note Compressed
Files::を参照してください)を行わず、‘require-final-newline’による最後の
改行も追加しません(*note Customize Save::を参照してください)。同じファイ
ルをすでに通常(非リテラル)の方法でvisitしている場合、このコマンドはそれ
をリテラル(そのままの文字の列)としてvisitするかを尋ねます。

   2つの特別なフック変数により、ファイルをvisitする操作を変更して拡張す
ることができます。存在しないファイルをvisitすることにより、
‘find-file-not-found-functions’の関数が実行されます。この変数は関数のリ
ストを保有し、それらはどれか1つが非‘nil’を返すまで、(引数を指定せずに
)1つずつ呼び出されます。これはノーマルフックではないため、その事実を示す
ために名前の最後が‘-hook’ではなく、‘-functions’で終わっています。

   ファイルが存在するしないにかかわらず、ファイルをvisitするのに成功する
と、引数なしで関数‘find-file-hook’を呼び出します。この変数はノーマルフッ
クです。ファイルが存在しない場合、最初に
‘find-file-not-found-functions’を実行します。*note Hooks::を参照してくだ
さい。

   ファイルを編集するために自動的にメジャーモードを指定し(*note Choosing
Modes::を参照してください)、そのファイルのために特別なローカル変数を定義
する方法がいくつかあります(*note File Variables::を参照してください)。


File: emacs-ja.info,  Node: Saving,  Next: Reverting,  Prev: Visiting,  Up: Files

18.3 ファイルの保存
===================

Emacsでのバッファーの“保存(Saving)”は、バッファーの内容を、そのバッファ
ーによりvisitされているファイルに書き戻すことを意味します。

* Menu:

* Save Commands::            ファイルを保存するコマンドについて。
* Backup::                   Emacsがファイルの古いバージョンを保存する方法。
* Customize Save::           ファイルの保存のカスタマイズ。
* Interlocking::             Emacsが2人のユーザーによる1つのファイルへの同時編集から保護する方法。
* Shadowing: File Shadowing.  ファイルを自動的に“shadows”コピーする。
* Time Stamps::              Emacsによる保存されたファイルのタイムスタンプの更新。


File: emacs-ja.info,  Node: Save Commands,  Next: Backup,  Up: Saving

18.3.1 ファイルを保存するコマンド
---------------------------------

ファイルの保存と書き込みに関するコマンドが、いくつかあります。

‘C-x C-s’
     現在のバッファーを、そのファイルに保存します(‘save-buffer’)。
‘C-x s’
     任意、またはすべてのバッファーを、それらのファイルに保存します
     (‘save-some-buffers’)。
‘M-~’
     現在のバッファーが変更されたことを忘れます(‘not-modified’)。プレフ
     ィクス引数(‘C-u’)を指定すると、現在のバッファーを変更済みとマークし
     ます。
‘C-x C-w’
     現在のバッファーを、指定したファイル名で保存します(‘write-file’)。
‘M-x set-visited-file-name’
     現在のバッファーが保存される場所で、ファイル名を変更します。

   ファイルを保存して変更を永続化させたいときは、‘C-x C-s’
(‘save-buffer’)とタイプします。保存が完了すると、‘C-x C-s’は以下のような
メッセージを表示します:

     Wrote /u/rms/gnu/gnu.tasks

現在のバッファーが変更されていない(新規作成されたとき、または最後に変更
されたときから変更していない)場合、保存しても意味がないので実際の保存は
行われません。かわりに‘C-x C-s’は、エコーエリアに以下のようなメッセージ
を表示します:

     (No changes need to be saved)

   ‘C-u C-x C-s’のようにプレフィクス引数を指定すると、Emacsはそのバッフ
ァーを次回の保存が行われるときバックアップするようマークします。*note
Backup::を参照してください。

   コマンド‘C-x s’ (‘save-some-buffers’)は、任意、またはすべての変更され
たバッファーの保存を提案します。これはバッファーごとに何を行うか尋ねます
。使用できる応答は、‘query-replace’と同様です。

‘y’
     このバッファーを保存し、残りのバッファーについて尋ねます。
‘n’
     このバッファーは保存せずに、残りのバッファーについて尋ねます。
‘!’
     このバッファーを保存し、残りのバッファーを尋ねることなくすべて保存
     します。
‘<RET>’
     これ以上の保存をせずに、‘save-some-buffers’を終了します。
‘.’
     このバッファーを保存したら、他のバッファーをどうするか尋ねることな
     く、‘save-some-buffers’を終了します。
‘C-r’
     現在尋ねられているバッファーを閲覧します。Viewモードから抜けると、
     再び‘save-some-buffers’はどうするか尋ねます。
‘d’
     そのバッファーに対応するファイルとDiffをとり、どのような変更を保存
     するのか確認できます。これはコマンド‘diff-buffer-with-file’ (*note
     Comparing Files::を参照してください)を呼び出します。
‘C-h’
     これらのオプションについての、ヘルプメッセージを表示します。

‘save-some-buffers-default-predicate’の値をカスタマイズして、どのバッフ
ァーにたいしてEmacsが問い合わせるか制御できます。

   Emacsを終了するキーシーケンス‘C-x C-c’は、‘save-some-buffers’を呼び出
すので、同じ質問をします。

   バッファーを変更したが変更を保存したくないとき、保存されるのを防ぐた
めにできることがいくつかあります(それ以外の‘C-x s’または‘C-x C-c’で間違
って保存してしまうのはあなたの責任です)。まずできることは、‘M-~’
(‘not-modified’)とタイプすることで、これはバッファーが変更されているとい
うマークをクリアーします。これを行うと、保存コマンドに、バッファーが保存
を必要しないと信じこませることができます(‘~’は数学のシンボルで、“not(否
定)”として使われることがあります。したがって‘M-~’はメタと“not”になります
。)。かわりにファイルからテキストを読み込むことにより、ファイルをvisitま
たは保存された後に行った、すべての変更を取り消すことができます。これは
“リバート(reverting: 復元)”と呼ばれます。*note Reverting::を参照してくだ
さい(undoコマンド‘C-x u’を繰り返すことにより、変更がすべての変更を取り消
すこともできますが、リバートの方が簡単です)。

   ‘M-x set-visited-file-name’は、現在のバッファーがvisitしているファイ
ルの名前を変更します。このコマンドはミニバッファーを使って、新しいファイ
ル名を読み取ります。その後に、そのバッファーがそのファイル名のファイルを
visitしているとマークし、バッファー名も合わせて変更します。
‘set-visited-file-name’は、新しくvisitするファイルへの保存はしません。こ
れは後で保存するときのために、Emacs内のレコードを変更するだけです。これ
はバッファーを変更されている(modified)とマークするので、そのバッファーで
の_将来_の‘C-x C-s’で、保存が行われます。

   バッファーにたいして、違うファイルをvisitしているとマークしてすぐに保
存したい場合は、‘C-x C-w’ (‘write-file’)を使います。このコマンドは、
‘set-visited-file-name’の後すぐに‘C-x C-s’をするのと同じですが、‘C-x
C-w’はファイルが存在するとき確認を求める点が異なります。ファイルを
visitしていないバッファーでの‘C-x C-s’は、‘C-x C-w’と同じ効果をもちます
。したがってファイル名を読み取り、バッファーがそのファイルをvisitしてい
るとマークした後、バッファー内容をそのファイルに保存します。ファイルを
visitしていないバッファーのデフォルトファイル名は、バッファー名と、バッ
ファーのデフォルトディレクトリーから合成されます(*note File Names::を参
照してください)。

   新しいファイル名が何らかのメジャーモードに関連する場合、大抵は‘C-x
C-w’によりそのメジャーモードへの切り替えが行われます。コマンド
‘set-visited-file-name’もこれを行います。*note Choosing Modes::を参照し
てください。

   Emacsがファイルを保存する際、ディスクの最新バージョンのファイル日付を
確認して、それがEmacsが最後に読み込み、または書き込みしたときと異なる場
合、Emacsはその事実をユーザーに知らせます。なぜならそれはおそらく同時編
集による問題を示しており、それをすぐにユーザーに知らせる必要があるからで
す。*note Simultaneous Editing: Interlocking.を参照してください。


File: emacs-ja.info,  Node: Backup,  Next: Customize Save,  Prev: Save Commands,  Up: Saving

18.3.2 バックアップファイル
---------------------------

ほとんどのオペレーティングシステムでは、ファイルを書き換えるとファイルに
入っていたそれまでの記録は、自動的に破棄されます。したがって、Emacsでフ
ァイルを保存すると、ファイルの古い内容は捨てられます。しかし実際に保存す
る前に、Emacsが慎重に古い内容を“バックアップ(backup)”ファイルと呼ばれる
別のファイルにコピーすれば、古い内容は失われません。

   Emacsは最初にバッファーからファイルに保存されたときだけ、バックアップ
ファイルを作成します。その後ファイルを何回保存しようと、バックアップは変
更されません。しかしバッファーをkillしてから、そのファイルを再びvisitす
ると、新しいバックアップファイルが作成されます。

   ほとんどのファイルにたいして、変数‘make-backup-files’はバックアップフ
ァイルを作るかを決定します。ほとんどのオペレーティングシステムでは、デフ
ォルト値は‘t’なので、Emacsはバックアップファイルを書き込みます。

   バージョンコントロールシステム(version control system: *note Version
Control::を参照してください)で管理されているファイルにたいして、バックア
ップファイルを作るかは、変数‘vc-make-backup-files’により決定されます。バ
ージョンコントロールシステムに以前のバージョンがある場合、バックアップフ
ァイルを作るのは不必要なので、デフォルト値は‘nil’です。 *note General VC
Options::を参照してください。

   選択できるオプションは、Emacsにファイルごとに1つのバックアップを作ら
せる方法と、編集するファイルごとに番号がついた、一連のファイルを作る方法
があります。*note Backup Names::を参照してください。

   変数‘backup-enable-predicate’のデフォルト値は、一時的なファイルのため
に使われるディレクトリー(変数‘temporary-file-directory’または
‘small-temporary-file-directory’で指定されます)のファイルは、バックアッ
プしないような値になっています。

   前に保存されたバッファーにたいしても、バッファーから他のバックアップ
ファイルを作るよう、Emacsに明示的に指示することができます。バッファーを
‘C-u C-x C-s’で保存すると、この保存したバージョンが、次にバックアップす
るときのバックアップになります。‘C-u C-u C-x C-s’はバッファーを保存しま
すが、最初に元のファイル内容を新しいバックアップファイルとします。‘C-u
C-u C-u C-x C-s’は両方を行います。まず前の内容でバックアップを作成し、次
回に保存したときは、今回保存したものをバックアップにします。

   変数‘backup-directory-alist’をカスタマイズして、指定したパターンにマ
ッチする特定のファイルにたいして、指定したディレクトリーにバックアップを
作成させることができます。典型的な使い方は、要素‘("." . DIR)’を追加する
ことにより、すべてのバックアップを絶対パスDIRに作る方法です。異なるディ
レクトリーにある同じ名前のファイルによる、バックアップファイルの名前の衝
突を避けるため、Emacsはバックアップファイルの名前を変更します。‘("." .
".~")’を追加すると、これは元のファイルがあるディレクトリーに、非表示の
‘.~’というディレクトリーを作って、そこにバックアップを作成します。
Emacsはバックアップを作るため、必要ならディレクトリーを作成します。

* Menu:

* Names: Backup Names.       バックアップファイルの命名方法。
* Deletion: Backup Deletion.  Emacsによる余分な番号つきバックアップの削除。
* Copying: Backup Copying.   コピーとリネームによるバックアップの作成。


File: emacs-ja.info,  Node: Backup Names,  Next: Backup Deletion,  Up: Backup

18.3.2.1 単一または番号つきバックアップ
.......................................

Emacsのバックアップファイル作成では、バックアップの名前は通常、編集され
るファイル名の後ろに‘~’をつけて作成されます。したがって‘eval.c’のバック
アップファイルは、‘eval.c~’になります。

   アクセスコントロールによりEmacsが通常の名前でバックアップファイルを書
き込めない場合、‘~/.emacs.d/%backup%~’というバックアップファイルに書き込
みます。この1つのファイルしか存在しないので、一番最近作られたバックアッ
プだけが利用可能です。

   Emacsは“番号つきバックアップファイル(numbered backup files)”を作るこ
ともできます。番号つきバックアップファイルの名前は、元のファイル名の後ろ
に‘.~’と番号と‘~’をつけたものです。したがって‘eval.c’のバックアップファ
イルは、‘eval.c.~1~’、‘eval.c.~2~’、...、‘eval.c.~259~’、...となります。

   変数‘version-control’は、単一のバックアップファイルを作るか、複数の番
号つきバックアップファイルを作るかを決定します。有効な値は以下のとおりで
す:

‘nil’
     すでに番号つきバックアップのあるファイルにたいしては、番号つきバッ
     クアップを作ります。それ以外は単独のバックアップをつくります。これ
     がデフォルトです。
‘t’
     番号つきバックアップを作ります。
‘never’
     番号つきバックアップをつくらず、常に単一のバックアップを作ります。

この変数をセットする通常の方法は、initファイルやcustomizationバッファー
を通じて、グローバルにセットする方法です。しかし特定のバッファーにローカ
ルに‘version-control’をセットして、そのバッファーのバックアップ作成を制
御することができます(*note Locals::を参照してください)。特定のファイルを
visitするとき、常にEmacsに‘version-control’をローカルにセットさせること
ができます(*note File Variables::を参照してください)。Rmailモードのよう
ないくつかのモードは、この変数をセットします。

   さまざまなGNUユーティリティーにたいして、何をすべきか指示する環境変数
‘VERSION_CONTROL’をセットすると、Emacsも開始時にこの環境変数にしたがって
、Lisp変数‘version-control’をセットします。環境変数の値が‘t’または
‘numbered’のときは、‘version-control’は‘t’になります。値が‘nil’または
‘existing’のときは、‘version-control’は‘nil’になります。もし‘never’また
は‘simple’のときは、‘version-control’は‘never’になります。

   変数‘make-backup-file-name-function’に適切なLisp関数をセットすること
により、Emacsがバックアップファイル名を作る通常の方法をオーバーライドで
きます。


File: emacs-ja.info,  Node: Backup Deletion,  Next: Backup Copying,  Prev: Backup Names,  Up: Backup

18.3.2.2 バックアップの自動削除
...............................

ディスク容量の過度な消費を防ぐため、Emacsは自動的に番号つきバックアップ
を削除することができます。一般的にEmacsは一番古いバックアップと、一番新
しいバックアップをいくつか保持し、その間にあるバックアップを削除します。
これは新しいバックアップが作られる度に行なわれます。

   2つの変数‘kept-old-versions’および‘kept-new-versions’が、この削除を制
御します。これらの変数の値は順に、削除せずに残す一番古い番号(小さい番号
)のバックアップと、一番新しい番号(大きい番号)で、新しいバックアップが作
られる度に評価されます。中間のバックアップ(一番古いものと一番新しいもの
を除いたもの)は、余分なバージョンで、これらのバックアップは削除されます
。これらの変数の値は余分なバージョンを削除するとき、つまり新しいバックア
ップが作られた直後に使われます。新しく作られたバックアップは、
‘kept-new-versions’のカウントに含まれます。デフォルトでは、両方の変数の
値は2です。

   ‘delete-old-versions’が‘t’のとき、Emacsは何も尋ねずに余分なバックアッ
プファイルを削除します。‘nil’(デフォルト)のとき、Emacsは余分なバージョン
のバックアップを削除するか尋ねます。他の値の場合、Emacsはバックアップの
自動削除をしません。

   Diredの‘.’(ピリオド)コマンドでも、古いバージョンを削除できます。*note
Flagging Many Files::を参照してください。


File: emacs-ja.info,  Node: Backup Copying,  Prev: Backup Deletion,  Up: Backup

18.3.2.3 コピー vs. リネーム
............................

バックアップファイルは、古いファイルをコピーまたはリネームすることで作る
ことができます。コピーとリネームは、古いファイルが複数の名前をもつ場合
(ハードリンクされている場合)に、異なる効果をもちます。古いファイルがバッ
クアップファイルにリネームされた場合、ハードリンクされた別の名前で参照さ
れるファイルは、バックアップファイルとなります。かわりに古いファイルをコ
ピーすると、ハードリンクされた別の名前で参照されるファイルは、編集中のフ
ァイルのままで、それらの名前でアクセスする内容は新しい内容となります。

   バックアップファイルを作る方法は、編集中のファイルの所有者とグループ
にも影響します。コピーが使われた場合、それらは変化しません。リネームが使
われた場合、そのユーザーがファイルの所有者となり、ファイルのグループはデ
フォルト(オペレーティングシステムごとにグループのデフォルトは異なります
)のグループになります。

   リネームとコピーの選択は、以下の変数により行われます:

   • 変数‘backup-by-copying’が非‘nil’(デフォルトは‘nil’)の場合、コピーが
     使用されます。

   • 上記以外の場合、変数‘backup-by-copying-when-linked’が非‘nil’(デフォ
     ルトは‘nil’)で、ファイルが複数の名前をもつ場合は、コピーが使用され
     ます。

   • 上記以外の場合、変数‘backup-by-copying-when-mismatch’が非‘nil’(デフ
     ォルトは‘t’)で、リネームによりファイルの所有者かグループが変更され
     る場合は、コピーが使用されます。

     ‘backup-by-copying-when-mismatch’を‘nil’に変更すると、Emacsはファイ
     ルの所有者のユーザーIDの数字をチェックします。もしこの数字が
     ‘backup-by-copying-when-privileged-mismatch’の値より大きい場合、
     ‘backup-by-copying-when-mismatch’が非‘nil’であるかのように振る舞い
     ます。

   • 上記以外の場合、リネームがデフォルトの選択となります。

   ファイルがバージョンコントロールシステムで管理されている場合(*note
Version Control::を参照してください)、通常、Emacsは普通の方法でそのファ
イルのバックアップを作りません。しかし“コミット”(“チェックイン”とも呼ば
れる。*note VCS Concepts::を参照されたい)は、バックアップを作るのと似た
ところがあります。これらの操作は通常ハードリンクをこわし、同じファイルに
たいする別のファイル名でのvisitを切断します。Emacsにできることはありませ
ん。バージョンコントロールシステムがこれを行うのです。


File: emacs-ja.info,  Node: Customize Save,  Next: Interlocking,  Prev: Backup,  Up: Saving

18.3.3 ファイル保存のカスタマイズ
---------------------------------

変数‘require-final-newline’の値が‘t’のとき、ファイルの保存または書き込み
により、ファイルの終端に改行がないときは、何も尋ねずに改行を追加します。
値が‘visit’の場合、Emacsはファイルをvisitした直後に、終端に改行がないフ
ァイルの改行を追加します(これによりバッファーは変更されたとマークされま
す。undoはできません)。値が‘visit-save’の場合、Emacsはそのような改行を
visitと保存のときに追加します。値が‘nil’の場合、Emacsはファイルの終端を
変更しません。それ以外の非‘nil’値は、改行を追加するかをEmacsが尋ねること
を意味します。デフォルトは‘nil’です。

   ファイルの終端に常に改行があると想定する、特定の種類のファイルのため
にデザインされたメジャーモードがいくつかあります。そのようなメジャーモー
ドは、変数‘require-final-newline’に、変数‘mode-require-final-newline’の
値(デフォルトは‘t’)をセットします。後者の変数の値をセットすることにより
、これらのモードが終端の改行を取り扱う方法を制御できます。

   通常プログラムがファイルに書き込むとき、オペレーティングシステムはデ
ータをディスクにコミットする前に、ファイルのデータをメインメモリーにキャ
ッシュします。これにより大幅にパフォーマンスを向上できます。たとえばラッ
プトップを使っている場合、ファイルを書き込む度にディスクをスピンアップ
(spin-up)しなくて済みます。しかし、キャッシュをディスクにコミットする前
にオペレーティングシステムがクラッシュすることにより、データを失うリスク
もあります。

   このリスクを減少させるため、Emacsはファイルを保存した後に‘fsync’シス
テムコールを呼び出すことができます。‘fsync’により、データを失うリスクを
皆無にすることはできません。その理由の一部は、多くのシステムは‘fsync’を
正しく実装していないことであり、他の理由の一部はEmacsのファイル保存手段
は通常ディレクトリー更新に頼っており、これは‘fsync’が正しく実装されてい
ても、クラッシュを生き延びることはできないでしょう。

   ‘write-region-inhibit-fsync’変数は、ファイルを保存した後にEmacsが
‘fsync’を呼び出すかを制御します。この変数のデフォルト値は、Emacsを対話的
に使用しているときは‘nil’、バッチモードの時は‘t’です(*note Batch Mode:
Initial Options.を参照)。

   Emacsは自動保存ファイルの書き込みに‘fsync’を使うことはありません。な
ぜなら、それらのファイルのデータは、いずれにせよ失われるものだからです。


File: emacs-ja.info,  Node: Interlocking,  Next: File Shadowing,  Prev: Customize Save,  Up: Saving

18.3.4 同時編集からの保護
-------------------------

同時編集(Simultaneous editing)は、2人のユーザーが同じファイルをvisitして
、両者が変更と保存を行ったときに発生します。これが発生していることを誰も
知らせなければ、最初に保存したユーザーは、後で自分の変更が失われているこ
とに気付くでしょう。

   いくつかのシステムでは、Emacsは2番目のユーザーがファイルの変更を開始
すると、すぐに警告を発します。また、すべてのシステムにおいて、Emacsはフ
ァイルを保存するときにチェックして、他のユーザーの変更を上書きすることを
警告します。ファイルを保存するかわりに適切な訂正アクションをとることによ
り、他のユーザーの変更を失わなわずに済みます。

   ファイルをvisitしているEmacsバッファーで最初の変更を行うとき、Emacsは
ファイルが“ロック(locked)”されていることを記録します(これは同じディレク
トリーにある、特別な内容の、特別な名前のシンボリックリンク(1)を作ること
により行われます)。変更を保存したとき、Emacsはロックを解除します。このア
イデアは、ファイルをvisitしているEmacsバッファーに保存されていない変更が
あるとき、ファイルはロックされているとするものです。

   変数‘create-lockfiles’を‘nil’にセットすることにより、ロックファイルの
作成を抑制することができます。*警告:*これにより、この機能が提供する利点
を失うことになります。

   他のユーザーによりロックされているファイルをvisitしているバッファーの
変更を開始すると、“衝突(collision)”が起こります。Emacsが衝突を検知すると
、Lisp関数‘ask-user-about-lock’を呼び出して、何を行うか尋ねます。カスタ
マイズのためにこの関数を再定義できます。この関数の標準定義は、ユーザーに
質問をして、3つの有効な応えを受け取ります。

‘s’
     ロックを横取りします。すでにファイルを変更したユーザーはロックを失
     い、あなたがロックを取得します。
‘p’
     続行します。他のユーザーがロックしている如何にかかわらずファイルの
     編集を続けます。
‘q’
     終了します。これはエラー(‘file-locked’)を引き起こし、バッファーの内
     容は変更されません。あなたが試みた修正は実際には行われません。

   Emacsまたはオペレーティングシステムがクラッシュすると、偽のロックファ
イルが残ることがあり、このような偽のロックファイルによる警告を受けること
があります。偽の衝突だと確信できるときは、Emacsにとにかく実行させる‘p’を
使います。

   ロックはファイル名にもとづいて機能するので、ファイルが複数の名前を持
っていて、2人のユーザーがそれぞれ別のファイル名で同時編集を行うことを、
Emacsが防ぐことはできないことに注意してください。

   ロックファイルに書き込みできない状況がいくつかあります。たとえばシス
テム権限不足や他の理由により、Emacsがロックファイルが作成できない場合で
す。このような場合でも保存を試みたときに、ファイルの最終変更日時をチェッ
クすることにより、Emacsは衝突を検知できます。最後にEmacsがvisitまたは保
存したときからファイルが変更されているとき、それは他の何らかの手段により
ファイルが変更されたことを示し、Emacsが保存を行うことによりそれらが失わ
れることを意味します。そのようなときEmacsは警告メッセージを表示して、保
存する前に確認を求めます。保存するときは‘yes’、保存を取り消すときは
‘no’または‘C-g’と応えてください。

   すでに同時編集が発生しているとき、バッファーとファイルを比較する方法
の1つは、‘M-x diff-buffer-with-file’コマンドです。*note Comparing
Files::を参照してください。

   ---------- Footnotes ----------

   (1) システムがシンボリックリンクをサポートしていなければ、通常のファ
イルが使われます。


File: emacs-ja.info,  Node: File Shadowing,  Next: Time Stamps,  Prev: Interlocking,  Up: Saving

18.3.5 ファイルのシャドーイング
-------------------------------

特定のファイルと等しい“shadow”コピーを１つ以上の場所、ことによると異なる
マシン間で保持するように計画できます。これを行うにはまず、“shadowファイ
ルグループ”をセットアップしなければなりません。これはリストにあるサイト
間で共有される同じ名前のファイルのセットです。ファイルグループは永続的で
、将来のEmacsセッションでも、現在のセッションと同様に適用されます。一度
グループをセットアップすると、Emacsを終了する度に、編集したファイルをグ
ループの他のファイルにコピーします。‘M-x shadow-copy-files’をタイプする
ことにより、Emacsを終了せずにコピーすることもできます。

   “shadowクラスター”は、ディレクトリーを共有するホストのグループなので
、それらのコピーは、そのディレクトリーにあるすべてのファイルを更新するの
に充分です。shadowクラスターはそれぞれ名前を持ち、プライマリーホスト(コ
ピーを行うホスト)のネットワークアドレスと、プライマリーホスト以外でクラ
スターに含めるホストを選択するための正規表現を指定します。
‘M-x shadow-define-cluster’によりshadowクラスターを定義できます。

‘M-x shadow-initialize’
     ファイルのシャドーイング(shadowing)をセットアップします。
‘M-x shadow-define-literal-group’
     サイト間で共有される単一のファイルを定義します。
‘M-x shadow-define-regexp-group’
     ファイルのグループがマッチするすべてのファイルを、ホスト間で共有す
     るようにします。
‘M-x shadow-define-cluster <RET> NAME <RET>’
     shadowファイルのクラスターNAMEを定義します。
‘M-x shadow-copy-files’
     すべての保留中のshadowファイルをコピーします。
‘M-x shadow-cancel’
     ファイルにたいするshadow指示を取り消します。

   shadowファイルグループをセットアップするには、
‘M-x shadow-define-literal-group’または
‘M-x shadow-define-regexp-group’を使います。詳細な情報は、これらの関数の
ドキュメント文字列を参照してください。

   ファイルをshadowにコピーする前に、Emacsは確認を求めます。“no”を応える
ことにより、その時だけはコピーを回避できます。特定のファイルにたいして今
後もshadowingを取り消したい場合、‘M-x shadow-cancel’を使うことにより、
shadowファイルグループを削除または変更します。


File: emacs-ja.info,  Node: Time Stamps,  Prev: File Shadowing,  Up: Saving

18.3.6 タイムスタンプの自動更新
-------------------------------

ファイルにタイムスタンプを書き込むことができます。これによりファイルを編
集・保存する度に、タイムスタンプが自動的に更新されます。タイムスタンプは
、ファイルの最初の8行になければならず、以下のような形式、

     Time-stamp: <>

または以下のような形式です:

     Time-stamp: " "

   その後、フック‘before-save-hook’に関数‘time-stamp’を追加します(*note
Hooks::を参照してください)。ファイルを保存するとき、この関数は現在の日時
で自動的にタイムスタンプを更新します。コマンド‘M-x time-stamp’を使って、
手動でタイムスタンプを更新することもできます。デフォルトではタイムスタン
プの書式は、localeのセッティング(*note Environment::を参照してください
)と、タイムゾーン(*note (elisp)Time of Day::を参照してください)にしたが
います。カスタマイズに関しては、Customグループの‘time-stamp’を参照してく
ださい。


File: emacs-ja.info,  Node: Reverting,  Next: Autorevert,  Prev: Saving,  Up: Files

18.4 バッファーのリバート
=========================

ファイルをvisitしているバッファーにたいして、広範な変更をした後に気が変
わったときは、“リバート(revert: 復元)”することにより。変更をファイルの保
存されたバージョンに戻すことができます。間違えてリバートしてしまうことに
より、大量の作業結果を失うこともあり得るので、Emacsは最初に確認を求めま
す。

   ‘revert-buffer’コマンドは、ファイルが少ししか変更されていないときは、
前にポイントがあったテキスト部分とだいたい同じ位置にポイントを置くよう試
みます。しかし広範な変更を行っていた場合、ポイントは大きく異なる場所に置
かれることになります。

   リバートはバッファーをnot modified(変更されていない)とマークします。
また、バッファーのundoヒストリーもクリアーされます(*note Undo::を参照し
てください)。したがってリバートはundoできません。再び気を変えても、
undoコマンドを使ってリバートした変更を元にもどすことはできません。

   ファイルに関連付けられていない、Diredバッファーのようなバッファーでも
、リバートすることができます。それらの場合、リバートはその内容を再計算す
ることを意味します。‘C-x b’で明示的に作成したバッファーは、リバートでき
ません。リバートを試みると‘revert-buffer’はエラーを報告します。

   自動的かつ頻繁に変更されるファイル、たとえば実行を続けるプロセスのロ
グ出力などを編集しているとき、Emacsが確認なしにリバートできたら便利でし
ょう。このような振る舞いをさせるには、変数‘revert-without-query’に正規表
現のリストをセットします。ファイル名がそれらの正規表現の1つにマッチした
とき、‘find-file’および‘revert-buffer’は、バッファーが変更されていないと
きは、ファイルが変更される度に自動的にリバートします(もしテキストを編集
していた場合、変更を放棄するのはおそらく正しくありません)。

   Emacsにバッファーを定期的にリバートするよう、指示することもできます。
特定のバッファーにたいしてこれを行うには、‘M-x auto-revert-mode’とタイプ
して、マイナーモードのAuto-Revertモードを有効にします。カレントバッファ
ーがvisitしているファイルがディスク上で変更されたとき、自動的にリバート
します。すべてのバッファーにたいして同じことを行うには、‘M-x
global-auto-revert-mode’とタイプして、Global Auto-Revertモードを有効にし
ます。これらのマイナーモードはリモートのファイルにたいするチェックやリバ
ートはしません。なぜならそれは通常とても遅いからです。この動作は、変数
‘auto-revert-remote-files’を非‘nil’にセットすることにより変更できます。

   デフォルトでは、Auto-Revertモードは“ファイル通知(file
notifications)”を使用して機能します。これにより、ファイルシステムへの変
更が、OSからEmacsに報告されます。変数‘auto-revert-use-notify’を‘nil’にカ
スタマイズして、ファイル通知を無効にできます。その場合、Emacsは5秒ごとに
ポーリングして、ファイルの変更をチェックするでしょう。変数
‘auto-revert-interval’を通じて、ポーリングの間隔を変更できます。

   すべてのシステムでファイル通知がサポートされている訳ではありません。
サポートされないシステムでは、‘auto-revert-use-notify’はデフォルトで
‘nil’です。

   Auto-Revertモードの1つの使い方は、システムログのようなファイルを
“tail”することです。これにより、それらのファイルにたいする、他のプログラ
ムによる変更を、継続的に表示できます。これを行うには、ポイントをバッファ
ーの最後に移動します。そうすればファイル内容が変更されても、ポイントはそ
の位置に留まります。しかし、ファイルがファイルの終端方向に向かって変更さ
れるだけだと確信できるときは、かわりにAuto-Revert Tailモード
(‘auto-revert-tail-mode’)を使います。このモードは、これをより効果的に行
います。Auto-Revert Tailモードは、リモートのファイルにたいしても機能しま
す。

   バッファーが自動リバートされたとき、メッセージが生成されます。これは
‘auto-revert-verbose’を非‘nil’にセットすることにより、抑制できます。

   Diredバッファー(*note Dired::を参照)では、Auto-Revertモードはそのバッ
ファーのディレクトリーでファイルが作成、または削除されたとき更新を行いま
す。

   バージョンコントロールシステムの下にあるファイルを、以前のバージョン
にリバーとするコマンドについては、*note VC Undo::を参照してください。バ
ージョンコントロールシステムの下にあるファイルをvisitしているときの自動
リバートの特性については、*note VC Mode Line::を参照してください。


File: emacs-ja.info,  Node: Autorevert,  Next: Auto Save,  Prev: Reverting,  Up: Files

18.5 非ファイルバッファーの自動リバート
=======================================

通常Global Auto Revertモードは、ファイルのバッファーだけをリバートします
。非ファイルバッファーにたいして自動リバートを行うには、2つの方法があり
ます。1つはそれらのバッファーにたいしてAuto Revertモードを有効にする方法
です(‘M-x auto-revert-mode’を使います)。もう1つは
‘global-auto-revert-non-file-buffers’に非‘nil’値をセットする方法です。後
者はそれが実装されているすべての種類のバッファーにたいして、自動リバート
を有効にします(以下のメニューにリストされています)。

   ファイルバッファーと同様、非ファイルバッファーはそれらにたいして作業
を行っているときや、リバートすると失われてしまう情報が含まれているとき、
通常はリバートすべきではありません。したがって、それらがmodified(変更さ
れている)のときはリバートしません。非ファイルバッファーが変更されている
とマークするのは、ファイルバッファーのときより通常難しいので、トリッキー
になり得ます。

   他のトリッキーな点に関する詳細は、効率の問題です。自動リバートはしば
しばバッファーにたいするすべての可能な変更を検知しようとせず、広範または
簡単に検知できる変更だけを検知します。したがって、非ファイルバッファーに
自動リバートを有効にすることは、バッファーのすべての情報が最新であると常
に保証はしませんし、手動によるリバートを無用にする必要もないからです。

   それとは反対に、特定のバッファーは‘auto-revert-interval’で指定された
秒数ごとに自動的にリバートします(これは現在のところBuffer Menuだけに適用
されます)。この場合、自動リバートはリバートの際、‘auto-revert-verbose’が
非‘nil’でも、何もメッセージを表示しません。

   詳細はバッファーの特性に依存し、それらは対応するセクションで説明され
ています。

* Menu:

* Auto Reverting the Buffer Menu::  Buffer
                                      Menuの自動リバートについて。
* Auto Reverting Dired::     Diredバッファーの自動リバートについて。


File: emacs-ja.info,  Node: Auto Reverting the Buffer Menu,  Next: Auto Reverting Dired,  Up: Autorevert

18.5.1 Buffer Menuの自動リバート
--------------------------------

非ファイルバッファーの自動リバートが有効なとき、必要性の有無にかかわらず
、Buffer Menu (*note Several Buffers::を参照) は‘auto-revert-interval’で
指定された秒数ごとに自動的にリバートされます。(リバートする必要があるか
チェックするのは、恐らく実際にリバートするより長い時間を要する)。

   Buffer Menuがmodifiedと不適切にマークされたときは、‘g’により手動でリ
バートして自動リバートを再開します。しかし特定のバッファーにたいして削除
や表示のマークをつけた場合は、慎重になる必要があります。なぜならリバート
はすべてのマークを消去するからです。マークの追加はバッファーのmodifiedフ
ラグをセットするという事実は、自動的なマークの消去からの自動リバートを防
ぎます。


File: emacs-ja.info,  Node: Auto Reverting Dired,  Prev: Auto Reverting the Buffer Menu,  Up: Autorevert

18.5.2 Diredバッファーの自動リバート
------------------------------------

Diredバッファーは、バッファーのメインディレクトリーのファイルリストが変
化したとき(たとえば新しいファイルの追加や削除)だけ、自動リバートします。
特定のファイルの情報が変化したとき(たとえばサイズの変化)や、サブディレク
トリーへの追加は自動リバートしません。_すべて_のリストされた情報が最新で
あることを確実にするには、Diredバッファーで自動リバートが_有効であっても
_、手動で‘g’を使ってリバートする必要があります。メインディレクトリーにリ
ストされているファイルへの変更や保存で、実際に自動リバートが起こるのに気
付くかもしれません。これはファイルの変更や保存は、たとえばバックアップフ
ァイルやauto-saveファイルにより、高い確率でディレクトリー自身を変更する
からです。しかし、これは保証されているわけではありません。

   Diredバッファーがmodifiedとマークされ、残したい変更がない場合、大抵は
‘g’でバッファーを手動でリバートすることにより、自動リバートを再開できま
す。しかし1つ例外があります。ファイルにフラグやマークをつけた場合、安全
にバッファーをリバートできます。これはフラグやマークを消去しません(もち
ろんマークされたファイルが削除されていない場合です)。しかしバッファーは
リバートの後でさえmodifiedの状態に留まるので、自動リバートは再開しません
。これは、もしファイルにたいしてフラグやマークをつけた場合、それはバッフ
ァーにたいして作業をしており、警告なしにバッファーが変更されることを望ま
ないだろうからです。マークやフラグがある状態で自動リバートを再開したいと
きは、‘M-~’を使ってバッファーをnon-modifiedとマークします。しかしマーク
やフラグの追加・削除・変更により、バッファーは再びmodifiedとマークされま
す。

   現在のところ、リモートのDiredバッファーは、自動リバートされません。特
定のファイルだけをリストするように、シェルのワイルドカードやファイル引数
を与えられたDiredバッファーも同じです。‘*Find*’および‘*Locate*’は、どち
らも自動リバートしません。

   Diredバッファーの自動リバートは、いくつかのシステムでは満足に機能しな
いかもしれないことに注意してください。


File: emacs-ja.info,  Node: Auto Save,  Next: File Aliases,  Prev: Autorevert,  Up: Files

18.6 自動保存－災害にたいする防御
=================================

Emacsは定期的に、visitしているファイルを、実際に使っているファイルを変更
せずに、別のファイルに自動的に保存するときがあります。これは“自動保存
(auto-saving)”と呼ばれます。これはシステムがクラッシュしたとき、失われて
しまう作業をある程度以下に制限するためのものです。

   Emacsが自動保存するときだと決定すると、各バッファーを判断して、それら
のバッファーの自動保存が有効で、最後に自動保存されてから変更されている場
合は、自動保存します。ファイルが実際に自動保存されている場合は、自動保存
の間、エコーエリアに‘Auto-saving...’というメッセージが表示されます。自動
保存の間のエラーはキャッチされるので、ユーザーがタイプして実行したコマン
ドに、干渉することはありません。

* Menu:

* Files: Auto Save Files.    ファイルを保存するまでの間、自動保存された変更が実際に保存されるファイル。
* Control: Auto Save Control.  自動保存をいつ、どのような間隔で行うかの制御。
* Recover::                  自動保存ファイルからのテキストの復旧。


File: emacs-ja.info,  Node: Auto Save Files,  Next: Auto Save Control,  Up: Auto Save

18.6.1 自動保存ファイル
-----------------------

自動保存は通常、visitしているファイルへの保存はしません。なぜなら永続化
したくない変更を保存するのは、好ましくないからです。そのかわりに、自動保
存は“auto-saveファイル”と呼ばれる別のファイルに保存し、visitしているファ
イルへの変更は、保存を明示的に要求したとき(‘C-x C-s’など)に行います。

   auto-saveファイルの名前は通常、visitしているファイル名の前後に‘#’をつ
けて作られます。したがって‘foo.c’というファイルをvisitしているバッファー
は、‘#foo.c#’というファイルに自動保存されます。ファイルをvisitしていない
バッファーのほとんどは、明示的に要求した場合だけ自動保存されます。それら
のバッファーが自動保存されるとき、auto-saveファイル名は、バッファー名の
前後に‘#’をつけて、その後ろに数字と文字を付け加えて一意な名前にします。
たとえば送信メッセージを作成する‘*mail*’バッファーは、‘#*mail*#704juu’の
ような名前のファイルに、自動保存されます。Emacsの一部(関数
‘make-auto-save-file-name’および‘auto-save-file-name-p’)を違った方法で再
プログラムしない限り、auto-saveファイル名はこの方法で作成されますバッフ
ァーの自動保存に使われるファイル名は、そのバッファーの自動保存をオンにし
たときに計算されます。

   変数‘auto-save-file-name-transforms’は、auto-saveファイル名をある程度
制御することを許します。これに一連の正規表現を指定して置換することにより
、auto-saveファイル名を変更します。デフォルト値は、リモートのファイル
(*note Remote Files::を参照してください)を、ローカルマシンの一時ディレク
トリーのauto-saveファイルに変換します。

   大きなバッファーから大量のテキストを削除したとき、そのバッファーにた
いする自動保存は一時的にオフになります。これは、もしテキストをうっかり削
除してしまった場合、それがauto-saveファイルに含まれていて、そこから探せ
る方が便利だからです。これが発生した後、再び自動保存を有効にするには、バ
ッファーを‘C-x C-s’で保存するか、‘C-u 1 M-x auto-save-mode’を使います。

   別のauto-saveファイルではなく、visitしているファイル自体に自動保存し
たい場合は、グローバルなマイナーモード‘auto-save-visited-mode’を有効にし
ます。このモードでは、自動保存は明示的な保存と等価です。このモードは上述
の‘auto-save’と直交(orthogonal)するモードであり、両方同時に有効にできる
ことに注意してください。しかし、いくつかのバッファーで‘auto-save’モード
がアクティブで、かつ時代遅れの‘auto-save-visited-file-name’変数が非
‘nil’値の場合、そのバッファーは‘auto-save-visited-mode’の影響を受けない
でしょう。

   ‘auto-save-visited-mode’モードの自動保存処理の間隔は、変数
‘auto-save-visited-interval’を使用してカスタマイズできます。
‘auto-save-interval’と‘auto-save-timeout’は、‘auto-save-visited-mode’に
影響を与えません。これらの変数の詳細は、*note Auto Save Control::を参照
してください。

   バッファーのauto-saveファイルは、そのバッファーをvisitしているファイ
ルに保存したとき削除されます(変数‘delete-auto-save-files’を‘nil’にセット
することにより、これを禁じることができます)。‘C-x C-w’または
‘set-visited-file-name’で、visitされているファイル名を変更することにより
、あたらしくvisitされているファイル名にもとづいてauto-saveファイル名はリ
ネームされます。


File: emacs-ja.info,  Node: Auto Save Control,  Next: Recover,  Prev: Auto Save Files,  Up: Auto Save

18.6.2 自動保存の制御
---------------------

ファイルをvisitする度に、そのファイルバッファーの自動保存は、オンになり
ます(バッチモードでは異なります。*note Initial Options::を参照してくださ
い)。この変数のデフォルトは‘t’なので、ファイルをvisitしているバッファー
の自動保存は通常、常に行われます。現在のバッファーの自動保存を切り替える
には、‘M-x auto-save-mode’とタイプします。Auto Saveモードはバッファーロ
ーカルに動作するマイナーモードです(*note Minor Modes::を参照してください
)。

   Emacsは最後に自動保存されてから何文字タイプしたかにもとづいて、定期的
に自動保存を行います。変数‘auto-save-interval’は、自動保存と自動保存の間
に何文字タイプされたかを指定します。デフォルトは300です。Emacsは小さすぎ
る値は受け付けません。‘auto-save-interval’を20より小さな値にカスタマイズ
した場合、Emacsは20と指定されたかのように振る舞います。

   自動保存はタイピングをストップしたときも行われます。デフォルトでは
30秒アイドル状態が続くと実行されます。(このときEmacsはガベージコレクショ
ンも実行します; *note (elisp)Garbage Collection::を参照してください)。こ
の間隔を変更するには、変数‘auto-save-timeout’をカスタマイズします。実際
の実行間隔は、現在のバッファーの大きさに応じて長くなります。これは、自動
保存が実感できるほど時間がかかるような大きなバッファーを編集しているとき
は、それをなるべく無くすようにする狙いです。アイドル状態のときの自動保存
は、2つの事を達成します。最初に、端末を少しの間離れるときなどに、すべて
の作業の保存を保証します。次に、実際にタイプしているときは自動保存を避け
ます。

   ‘auto-save-visited-mode’が有効なとき、Emacsはアイドル5秒後に、ファイ
ルをvisitしているバッファーを自動保存するでしょう。アイドル時の間隔は、
変数‘auto-save-visited-interval’でカスタマイズできます。

   Emacsは、致命的なエラーが発生したときも自動保存を行います。これには
‘kill %emacs’のようなコマンドによるEmacsジョブのkill、電話回線やネットワ
ーク回線の切断が含まれます。

   コマンド‘M-x do-auto-save’により、明示的に自動保存を行うことができま
す。


File: emacs-ja.info,  Node: Recover,  Prev: Auto Save Control,  Up: Auto Save

18.6.3 自動保存からのデータ復旧
-------------------------------

コマンド‘M-x recover-file <RET> FILE <RET>’により、auto-saveファイルの内
容を使って、失われたデータを復旧できます。これはFILEをvisitして、(確認を
求めた後で)auto-saveファイル‘#FILE#’の内容をリストアします。その後‘C-x
C-s’で復旧したテキストを、FILE自身に保存できます。たとえばファイル
‘foo.c’を、そのauto-saveファイル‘#foo.c#’で復旧するには、以下のようにし
ます:

     M-x recover-file <RET> foo.c <RET>
     yes <RET>
     C-x C-s

   ‘M-x recover-file’は確認を求める前に、指定したファイルとauto-saveファ
イルのあるディレクトリー一覧を表示するので、ファイルのサイズや日付を確認
できます。auto-saveの方が古い場合、‘M-x recover-file’はそれを読み込むよ
うに提案しません。

   Emacsまたはコンピューターがクラッシュしたとき、‘M-x recover-session’コ
マンドで編集していたすべてのファイルを、それらのauto-saveファイルで復旧
できます。これは最初に中断されたセッションの記録された一覧を表示します。
ポイントを移動して選択してから、‘C-c C-c’をタイプします。

   ‘recover-session’は、そのセッションの間に編集されていた各ファイルにつ
いて、ファイルを復旧するか尋ねます。‘y’と応えると‘recover-file’を呼び出
し、通常の方法で復旧を行います。これは元のファイルとauto-saveファイルの
日付を表示して、ファイルの復旧を行うかもう1度尋ねます。

   ‘recover-session’が完了すると、復旧を選択したファイルがEmacsバッファ
ーに表示されます。実際にファイル自体を 更新するためには、これらを保存す
るのが唯一の方法です。

   Emacsは中断されたセッションについての情報を、ディレクトリー
‘~/.emacs.d/auto-save-list/’の、‘.saves-PID-HOSTNAME~’という名前のファイ
ルに記録します。‘auto-save-list-file-prefix’を‘nil’にセットすると、復旧
用にセッションが記録されなくなります。


File: emacs-ja.info,  Node: File Aliases,  Next: Directories,  Prev: Auto Save,  Up: Files

18.7 ファイルのエイリアス
=========================

シンボリックリンクとハードリンクは、同じファイルを参照するためにいくつか
の名前を使うことを可能にします。ハードリンクは、ファイルを直接参照する他
の名前です。それらすべての名前は同じように有効で、それらの間に優先順位は
ありません。対照的にシンボリックリンクは、ある種の定義されたエイリアス
(別名)です。‘foo’が‘bar’へのシンボリックリンクの場合、そのファイルをどち
らの名前でも参照できますが、‘bar’が実際の名前で、‘foo’はエイリアスに過ぎ
ません。シンボリックリンクがディレクトリーを指すときは、さらに複雑なケー
スが発生します。

   Emacsがすでに異なる名前でvisitしている場合、通常はエコーエリアにメッ
セージを表示して、そのファイルをvisitしている既存のバッファーを使います
。これはハードリンクおよびシンボリックリンクをサポートしているシステム、
または長いファイル名を切り詰めるシステムで長い名前のファイルを使っている
場合、またはファイル名の大文字小文字を区別しないシステムで発生します。変
数‘find-file-suppress-same-file-warnings’を非‘nil’値にセットすることによ
り、メッセージを表示しないようにできます。変数
‘find-file-existing-other-name’を‘nil’にセットすれば、この機能全体を無効
にできます。その場合、同じファイルを異なる名前でvisitすると、それぞれの
ファイル名で別々のバッファーが使われます。

   変数‘find-file-visit-truename’が非‘nil’の場合、バッファー用に記録され
るファイル名は、指定した名前ではなく、ファイルの“本当の名前”(これはすべ
てのシンボリックリンクを対象の名前で置き換えて作られます)が使われます。
‘find-file-visit-truename’をセットするは、
‘find-file-existing-other-name’にも暗に影響します。

   シンボリックリンクを通じてアクセスされるようなディレクトリーにたいし
ては通常、優先的にリンクされた名前をEmacsに表示させたいときがあります。
これを行うには‘directory-abbrev-alist’をカスタマイズします。このリストの
各要素は‘(FROM . TO)’という書式です。これはディレクトリー名にFROMが出現
したときは常に、FROMをTOで置き換えることを意味します。文字列FROMは正規表
現です(*note Regexps::を参照してください)。正規表現はディレクトリー名の
最初の文字にマッチさせる必要があるので、‘\`’で始まります(埋め込みの改行
をサポートするディレクトリー名の場合は、‘^’で無効にします)。TOには同じデ
ィレクトリーを指す、絶対パスによる普通のディレクトリー名を指定する必要が
あります。文字列TOでホームディレクトリーを指定するのに、‘~’を使用しない
でください。Emacsはこれらの変換を個別に行います。以下は通常シンボリック
リンク‘/fsf’でアクセスされる、‘/home/fsf’を指定する例です:

     (("\\`/home/fsf" . "/fsf"))


File: emacs-ja.info,  Node: Directories,  Next: Comparing Files,  Prev: File Aliases,  Up: Files

18.8 ファイルディレクトリー
===========================

ファイルシステムは、ファイルを“ディレクトリー”にグループ化します。“ディ
レクトリーリスト”は、ディレクトリーに含まれるファイルのリストです。
Emacsはディレクトリーを作成および削除するコマンドを提供し、簡単な形式(フ
ァイル名のみ)、および詳細な形式(サイズ、日付、その他の属性を含む)のディ
レクトリーリストを作成します。EmacsにはDiredと呼ばれるディレクトリーブラ
ウザーも含まれています。詳細は*note Dired::(‘C-x d’で呼び出せる)を参照し
てください。

‘C-x C-d DIR-OR-PATTERN <RET>’
     簡単なディレクトリーリストを表示します(‘list-directory’)。
‘C-u C-x C-d DIR-OR-PATTERN <RET>’
     詳細なディレクトリーリストを表示します。
‘M-x make-directory <RET> DIRNAME <RET>’
     DIRNAMEという名前の新しいディレクトリーを作成します。
‘M-x delete-directory <RET> DIRNAME <RET>’
     DIRNAMEという名前のディレクトリーを削除します。もし空でない場合、そ
     れらを再帰的に削除するか尋ねます。

   ディレクトリーリストを表示するコマンドは、‘C-x C-d’
(‘list-directory’)です。これはミニバッファーを使って、リストを表示するデ
ィレクトリーと、リストするファイルを指定するワイルドカードが含まれたパタ
ーンの両方により、ファイル名を読み取ります。たとえば

     C-x C-d /u2/emacs/etc <RET>

これはディレクトリー‘/u2/emacs/etc’のファイルをリストします。以下はファ
イル名のパターンを指定する例です。

     C-x C-d /u2/emacs/src/*.c <RET>

   通常、‘C-x C-d’は名前だけを含む、簡単なディレクトリーリストを表示しま
す。数引数(値は関係なし)は、サイズ、日付、所有者を含む詳細な一覧を作成す
るよう指示します。

   ディレクトリーリストのテキストは、主に下位プロセスとして‘ls’を実行す
ることにより取得されます。2つのEmacs変数が、‘ls’に指定するスイッチを制御
します。‘list-directory-brief-switches’には、簡単な一覧に使うためのスイ
ッチを文字列で指定します(デフォルトは‘"-CF"’)。
‘list-directory-verbose-switches’には、詳細な一覧に使うためのスイッチを
文字列で指定します(デフォルトは‘"-l"’)。

   詳細なディレクトリー一覧では、Emacsはディレクトリーが含まれるディスク
の空き容量についての情報を追加します。変数
‘directory-free-space-program’および‘directory-free-space-args’を通じて
、ローカルファイルシステムにたいしてこれが行われる方法をカスタマイズでき
ます。‘directory-free-space-program’には実行するプログラム(デフォルトは
‘df’)、そのプログラムに渡す引数は‘directory-free-space-args’(デフォルト
はシステム依存)を指定します(MS-WindowsおよびMS-DOSでは、これら2つの変数
は無視され、同様な機能をもつEmacsの内部実装がかわりに使用される)。

   コマンド‘M-x delete-directory’は、ミニバッファーを使ってディレクトリ
ー名の入力を求め、空のときはディレクトリーを削除します。ディレクトリーが
空でない場合、再帰的に削除するか確認を求めます。“Trash(ごみ箱)”(または
“Recycle Bin”)の機能をもつシステムでは、変数
‘delete-by-moving-to-trash’を‘t’に変更することにより、指定したディレクト
リーを無条件に削除するかわりに、ごみ箱に移動します。ごみ箱の使い方につい
ての情報は、*note Misc File Ops::を参照してください。


File: emacs-ja.info,  Node: Comparing Files,  Next: Diff Mode,  Prev: Directories,  Up: Files

18.9 ファイルの比較
===================

コマンド‘M-x diff’は、ミニバッファーを使って2つのファイル名の入力を求め
、‘*diff*’という名前のバッファーに、2つのファイルの違いを表示します。こ
れは‘diff’プログラムに、変数‘diff-switches’で指定されたオプションを指定
して実行することにより機能します。‘diff-switches’には文字列を指定します
。デフォルトはunified context diff形式を指定する‘"-u"’です。プログラムに
ついての情報は、*note Diff: (diffutils)Top.を参照してください。

   ‘diff’コマンドの出力は、Diffモードと呼ばれるメジャーモードを使って表
示されます。*note Diff Mode::を参照してください。

   (より高機能な)代替物は‘M-x ediff’です(*note Ediff: (ediff)Top.を参照
)。

   コマンド‘M-x diff-backup’は指定したファイルと、そのファイルの一番最近
のバックアップを比較します。バックアップファイル名を指定したときは、
‘diff-backup’は指定されたバックアップファイルと、それの元となるファイル
を比較します。それ以外の点は‘M-x diff’と同じです。

   コマンド‘M-x diff-buffer-with-file’は指定されたバッファーと、それに対
応するファイルを比較します。これはバッファーを保存すると、ファイルにどの
ような変更がされるかを表示します。

   コマンド‘M-x compare-windows’はカレントウィンドウと、カレントウィンド
ウの前に選択されていたウィンドウを比較します(Emacsのウィンドウについての
詳細は、*note Windows::を参照してください)。比較はそれぞれのウィンドウの
ポイント位置から、それぞれのバッファーのポイントの初期位置を、対応するバ
ッファーのマークリング(*note Mark Ring::を参照)にpushした後に開始されま
す。それから各ウィンドウのポイントを1文字ずつ前方に移動していきます。文
字がマッチしなくなるとコマンドは終了します。

   コマンドを開始したとき、2つのウィンドウのポイントの後ろのテキストがマ
ッチしない場合、‘M-x compare-windows’は2つのウィンドウでマッチするテキス
トが見つかるまでポイントを進めてから終了します。したがって‘M-x
compare-windows’を繰り返し使うと、毎回1つのマッチする範囲をスキップする
か、次の開始点を探します。

   数引数を指定すると、‘compare-windows’は空白文字の違いを無視します。変
数‘compare-ignore-case’が非‘nil’の場合、大文字小文字の違いを無視して比較
します。変数‘compare-ignore-whitespace’が非‘nil’の場合、
‘compare-windows’はデフォルトでは空白文字の違いを無視しますが、数引数が
指定されたときは、その回のコマンド呼び出しでは、これをオフにします。

   ‘M-x smerge-mode’を使って、Smergeモードに切り替えることができます。こ
れは‘diff3’プログラムの出力を編集するマイナーモードです。これは通常、バ
ージョン管理システムと、バージョン管理システムの外でのupdateをマージする
とき、ファイルへの変更が競合して失敗した結果です。Smergeモードは特定の変
更を選択することにより、競合を解決するコマンドを提供します。

   ファイルをマージする強力なインターフェースを提供するEmerge機能につい
ては、 *note Emerge::を参照してください。


File: emacs-ja.info,  Node: Diff Mode,  Next: Copying and Naming,  Prev: Comparing Files,  Up: Files

18.10 Diffモード
================

Diffモードは、‘M-x diff’や他の同様なコマンドの出力のために使用されるメジ
ャーモードです。この種の出力は“patch”と呼ばれます。なぜならそれが特定の
変更を自動的に適用するために、‘patch’コマンドに渡されるからです。手動で
Diffモードを選択するには、‘M-x diff-mode’とタイプします。

   パッチに指定された変更は、“hunk(欲張り)”にグループ化されます。これは
変更された行を１行以上含むテキストと、それに隣接するテキストです。
hunksには変更のコンテキストを提供するために、変更されていない行も含むこ
とができます。それぞれのhunkには“hunkヘッダー”が前についていて、これは
hunkが出現する古い方の行番号と、新しい行番号が指定されます。Diffモードは
実際のhunkの内容と区別するため、hunkヘッダーをハイライトします。

   他のバッファーと同様に、Diffモードのバッファーを編集することができま
す(もし読み込み専用の場合、最初にそれを書き込み可にする必要があります。
*note Misc Buffer::を参照してください)。hunkを変更すると、Diffモードは
patchを正しい状態に保つために、hunkヘッダーの行番号を自動的に修正しよう
と試みます。自動的な行番号の修正を無効にするには、変数
‘diff-update-on-the-fly’を‘nil’に変更してください。

   DiffモードはCompilationモードと同様に、各hunkをエラーメッセージとして
扱います。したがって‘C-x `’のようなコマンドを使って、対応するソースの位
置をvisitすることができます。

   それに加えてDiffモードは、移動、操作、patchの一部を適用するために、以
下のコマンドを提供します:

‘M-n’
     次のhunkが開始される位置に移動します(‘diff-hunk-next’)。

     このコマンドには副作用があります。これは移動先のhunkを“refines(不純
     物を取り除く)”して、よりよい粒度で変更をハイライトします。この機能
     を無効にするには‘M-x diff-auto-refine-mode’とタイプして、マイナーモ
     ードのDiff Auto-Refineモードをオフに切り替えます。デフォルトでDiff
     Auto-Refineモードを無効にするには、以下をinitファイルに追加します
     (*note Hooks::を参照してください):

          (add-hook 'diff-mode-hook
                    (lambda () (diff-auto-refine-mode -1)))

‘M-p’
     前のhunkが開始される位置に移動します(‘diff-hunk-prev’)。これは
     ‘M-n’と同様、Diff Auto-Refineモードが無効でなければ、移動先のhunkを
     refiningする副作用があります。

‘M-}’
     複数ファイルへのpatchで、次のファイルが開始される位置に移動します
     (‘diff-file-next’)。

‘M-{’
     複数ファイルへのpatchで、前のファイルが開始される位置に移動します
     (‘diff-file-prev’)。

‘M-k’
     ポイントがある位置のhunkをkillします(‘diff-hunk-kill’)。

‘M-K’
     複数ファイルへのpatchで、現在のファイル部分をkillします
     (‘diff-file-kill’)。

‘C-c C-a’
     このhunkを対象ファイルに適用します(‘diff-apply-hunk’)。プレフィクス
     引数‘C-u’を指定すると、このhunkを復元します。

‘C-c C-b’
     ポイント位置のhunkの変更を、よりよい粒度でハイライトします
     (‘diff-refine-hunk’)。これにより変更された各行について実際に変更さ
     れた箇所を確実に見ることができます。

‘C-c C-c’
     このhunkに対応するソースファイルの行へジャンプします
     (‘diff-goto-source’)。

‘C-c C-e’
     このパッチでEdiffセッションを開始します。*note Ediff: (ediff)Top.を
     参照してください。

‘C-c C-n’
     表示を現在のhunkに制限します(‘diff-restrict-view’)。*note
     Narrowing::を参照してください。プレフィクス引数‘C-u’を指定すると、
     複数ファイルへのpatchで、表示を現在のファイルに制限します。制限を解
     除するには、‘C-x n w’ (‘widen’)を使います。

‘C-c C-r’
     バッファー全体の比較方向を逆転します(‘diff-reverse-direction’)。

‘C-c C-s’
     ポイント位置でhunkを分割します(‘diff-split-hunk’)。これは手動で
     patchを編集するためのもので、‘diff’プログラムに‘-u’または
     ‘--unified’オプションを指定して生成された、“unified diff format(統
     一diffフォーマット)”だけで機能します。‘diff’に‘-c’または
     ‘--context’オプションを指定して生成された、“context diff format(コ
     ンテキストdiffフォーマット)”のhunkを分割するには、最初に‘C-c C-u’で
     、バッファーをunified diff formatに変換する必要があります。

‘C-c C-d’
     バッファー全体を、“context diff format”に変換します
     (‘diff-unified->context’)。プレフィクス引数を指定すると、リージョン
     のテキストだけを変換します。

‘C-c C-u’
     バッファー全体をunified diff formatに変換します
     (‘diff-context->unified’)。プレフィクス引数を指定すると、unified
     formatからcontext formatに変換します。マークがアクティブのときは、
     リージョンのテキストだけを変換します。

‘C-c C-w’
     空白文字の変更を無視して、カレントhunkを再diffします
     (‘diff-ignore-whitespace-hunk’)。

‘C-x 4 A’
     それぞれのhunkについて、‘C-x 4 a’が行うようにChangeLog(*note Change
     Log::を参照してください)のエントリーを生成します
     (‘diff-add-change-log-entries-other-window’)。これは、あとで実際に
     変更の説明を記入できるように、変更ログの雛形を作ります。Diffモード
     での‘C-x 4 a’自体は、現在のhunkのファイルのためのものですが、関数名
     はpatch自体から取得します。これはpatchにより削除される関数のための
     、ログエントリーを作るのに有用です。

   patchには変更された行の行末に、無意識に入力された望んでいない空白文字
が含まれている場合があります。この問題を扱うには2つの方法があります。1つ
目はDiffバッファーでWhitespaceモード(*note Useless Whitespace::を参照し
てください)を有効にする方法で、これは自動的に変更された行の行末にある空
白文字をハイライトします。2つ目はコマンド‘M-x
diff-delete-trailing-whitespace’を使う方法で、patchにより変更された行の
行末の空白文字を検索して、patchとpatchされたソースファイルの両方からそれ
を取り除きます。このコマンドは変更を保存しないので、ユーザーが変更を保存
するか決定することができます(変更されたファイルはエコーエリアに表示され
ます)。プレフィクス引数を指定すると、patchされたファイルではなく、元のソ
ースファイルを変更しようと試みます。


File: emacs-ja.info,  Node: Copying and Naming,  Next: Misc File Ops,  Prev: Diff Mode,  Up: Files

18.11 Copying, Naming and Renaming Files
========================================

Emacsにはファイルをコピー、命名、リネームするためのコマンドがいくつかあ
ります。これらはすべてミニバッファーを使用してOLD(またはTARGET)とNEWの
2つのファイル名を読み取り、それらをコピー、またはファイル名に調整します
。これらのコマンドは、ワイルドカードを含むファイル名は許容しません。

   これらすべてのコマンドは、引数NEWが単なるディレクトリー名(*note
(elisp)Directory Names::を参照)の場合には、そのディレクトリーを実際の新
しい名前として、OLDをそれの非ディレクトリー成分とします。たとえば、コマ
ンド‘M-x rename-file <RET> ~/foo <RET> /tmp/ <RET>’は、‘~/foo’を
‘/tmp/foo’にリネームします。GNU、およびその他のPOSIXシステムでは、ディレ
クトリー名は‘/’で終端されます。

   これらのコマンドはすべて、新しいファイル名がすでに存在する場合は確認
を求めます。

   ‘M-x copy-file’はファイルOLDのコンテンツを、ファイルNEWにコピーします
。

   ‘M-x copy-directory’は、シェルコマンド‘cp -r’と同じようにディレクトリ
ーをコピーします。NEWがディレクトリー名の場合、このコマンドはOLDディレク
トリーのコピーを作成して、それをNEWの下に配します。それ以外では、このコ
マンドはOLDのコンテンツを、新しいNEWという名前のディレクトリーにすべてコ
ピーします。

   ‘M-x rename-file’は、ファイルOLDをNEWにリネームします。すでにファイル
名NEWが存在する場合、確認に‘yes’と答えなければリネームは行われません。な
ぜなら、名前NEWの古い内容が失われてしまうからです。OLDとNEWが異なるファ
イルシステム上にある場合は、ファイルOLDがコピーされた後に削除されます。

   ファイルがバージョンコントロール(*note Version Control::を参照してく
ださい)の配下にある時は、‘M-x rename-file’のかわりに
‘M-x vc-rename-file’を使ってリネームします。*note VC Delete/Rename::を参
照してください。

   ‘M-x add-name-to-file’は、既存のファイルの古い名前を削除せずに、新し
い名前を追加します。新しい名前は、既存のファイルのハードリンクとして作成
されます。新しい名前は、そのファイルがあるのと同じファイルシステムになけ
ればなりません。MS-Windowsでは、このコマンドはファイルがNTFSファイルシス
テムにあるときだけ機能します。MS-DOS、およびその他いくつかのリモートシス
テムタイプでは、ファイルをコピーすることにより機能します。

   ‘M-x make-symbolic-link’は、TARGETを指すNEWという名前のシンボリックリ
ンクを作成します。これにより、今後NEWというファイルを開こうとすると、そ
の時点でTARGETという名前のファイルが何であれ、ファイルのオープンが行われ
たときは、そのファイルを開きます。その時点でTARGETという名前のファイルが
存在しないときはエラーになります。このコマンドは引数TARGETを展開しないの
で、リンクの対象を相対パスで指定できます。しかし、このコマンドはTARGET内
の先頭の‘~’は展開するので、簡単にホームディレクトリーを指定できます。ま
た、先頭の‘/:’は取り除くので、リテラル‘~’および‘/:’で始まる相対パスを指
定することができます。*note Quoted File Names::を参照してください。
MS-Windowsでは、このコマンドはMS Windows Vista以降だけで機能します。
NEWがリモートのときは、そのシステムタイプに依存して機能します。


File: emacs-ja.info,  Node: Misc File Ops,  Next: Compressed Files,  Prev: Copying and Naming,  Up: Files

18.12 その他のファイル操作
==========================

Emacsには、ファイルを操作する他のコマンドがたくさん存在します。それらは
すべて1つのファイルを操作します。ファイル名にワイルドカードは指定できま
せん。

   ‘M-x delete-file’はファイルの入力を求め、そのファイルを削除します。
1つのディレクトリーにある、複数のファイルを削除する場合、‘delete-file’よ
りDiredを使う方が便利でしょう。*note Dired Deletion::を参照してください
。

   ‘M-x move-file-to-trash’は、ファイルをシステムの“Trash”(または
“Recycle Bin”)に移動します。この機能は、ほとんどのオペレーティングシステ
ムで利用可能です。Trashに移動されたファイルは、後で気が変わったとき元に
戻すことができます。

   デフォルトでは、Emacsの削除コマンドはTrashを_使いません_。一般的な削
除コマンドでTrash(それが利用可能な場合)を使うには、変数
‘delete-by-moving-to-trash’を‘t’に変更します。これはコマンド‘M-x
delete-file’と‘M-x delete-directory’ (*note Directories::を参照してくだ
さい)、およびDired (*note Dired Deletion::を参照してください)の削除コマ
ンドに影響を与えます。‘M-x delete-file’および‘M-x delete-directory’にプ
レフィクス引数を与えると、‘delete-by-moving-to-trash’の値にかかわらず、
Trashを使わずに完全に削除します。

   ファイルがバージョンコントロール(*note Version Control::を参照してく
ださい)の配下にある時は、‘M-x delete-file’のかわりに‘M-x
vc-delete-file’を使って、ファイルを削除します。*note VC Delete/Rename::を
参照してください。

   ‘M-x insert-file’(‘C-x i’も)は、指定したファイルの内容のコピーを、現
在のポイント位置に挿入し、ポイントの位置は変更せずに挿入された内容の前に
残します。挿入した内容の後の位置はマークリングに追加され、マークは非アク
ティブになります(*note Mark Ring::を参照してください)。

   ‘M-x insert-file-literally’も‘M-x insert-file’と同様ですが、ファイル
はliterally(そのまま)挿入されます。つまり‘M-x find-file-literally’コマン
ド(*note Visiting::を参照してください)と同様に、特別なエンコーディングや
変換なしに、ASCII文字の並びとして扱われます。

   ‘M-x write-region’は‘M-x insert-file’の逆です。このコマンドはリージョ
ンの内容を、指定されたファイルにコピーします。‘M-x append-to-file’はリー
ジョンのテキストを、指定されたファイルの末尾に加えます。*note
Accumulating Text::を参照してください。変数
‘write-region-inhibit-fsync’の値は、これらのコマンドおよびファイルの保存
に影響を与えます。*note Customize Save::を参照してください。

   ‘M-x set-file-modes’はファイル名と、その後に“ファイルモード(file
mode)”を読み込んで、指定されたファイルにそのファイルモードを適用します。
ファイルモード(または“ファイルパーミッション(file permissions)”とも呼ば
れます)は、ファイルが読み込み可能か、書き込み可能か、実行可能か、そして
それは誰にたいしてなのかを決定します。このコマンドは、‘chmod’コマンドに
指定する形式の、シンボルまたは8進のファイルモードを読み取ります。たとえ
ば‘u+x’は、そのファイルを所有するユーザーに実行可能の権限を追加すること
を意味します。ファイルモードをサポートしないオペレーティングシステムでは
、効果はありません。‘chmod’はこの関数の便利なエイリアスです。


File: emacs-ja.info,  Node: Compressed Files,  Next: File Archives,  Prev: Misc File Ops,  Up: Files

18.13 圧縮ファイルへのアクセス
==============================

Emacsは、圧縮されたファイルをvisitするとき、自動的に解凍します。また、そ
れらのファイルを変更して保存するときも、自動的に再圧縮します。Emacsは圧
縮ファイルを名前で認識します。ファイル名が‘.gz’で終わっていれば、それは
ファイルが‘gzip’で圧縮されていることを示します。他の拡張子の場合は、他の
圧縮プログラムを示します。

   自動的な解凍と圧縮は、Emacsがファイル内容を操作するすべてに適用されま
す。これにはvisit、保存、内容のバッファーへの挿入、ロード、バイトコンパ
イルが含まれます。

   この機能を無効にするには、コマンド‘M-x auto-compression-mode’とタイプ
します。変数‘auto-compression-mode’をカスタマイズすることにより、永続的
に無効にすることができます。


File: emacs-ja.info,  Node: File Archives,  Next: Remote Files,  Prev: Compressed Files,  Up: Files

18.14 ファイルアーカイブ
========================

名前が‘.tar’で終わるファイルは通常、‘tar’プログラムで作られた“アーカイブ
”です。Emacsはそれらを、Tarモードと呼ばれる特別なモードで表示します。こ
れは内容をDiredに似たリストで提供します(*note Dired::を参照してください
)。リストの移動はDiredのときと同様で、アーカイブに含まれるファイルを
visitできます。しかしTarモードでは、Diredコマンドのすべてが利用可能では
ありません。

   Auto Compressionモードが有効な場合(*note Compressed Files::を参照して
ください)、Tarモードは圧縮アーカイブ(ファイルの拡張子が‘.tgz’、
‘.tar.Z’、‘.tar.gz’)も使うことができます。

   キー‘e’、‘f’、<RET>はすべて、ファイルをファイル自身のバッファーに展開
します。それをバッファーで編集して、バッファーを保存すると、編集されたバ
ージョンでTarバッファーのものを置き換えます。Tarバッファーでファイル名を
マウスでクリックしても、同様なことが行えます。‘v’はファイルをバッファー
にViewモードで展開します(*note View Mode::を参照してください)。‘o’は、フ
ァイルを展開して他のウィンドウで表示するので、ファイルの編集とアーカイブ
の操作を同時に行うことができます。

   キー‘I’は、新しい(標準)ファイルをアーカイブに追加します。ファイルは最
初は空ですが、上記のコマンドを使用してすぐに編集することができます。この
コマンドはカレントのファイルの前に新しいファイルを挿入するので、Tarバッ
ファーの最上行で使用すると、新しいファイルがアーカイブの最上行となり、バ
ッファーの最後で使用すると、新しいファイルがアーカイブの最下行になります
。

   Diredと同様に、‘d’は後で‘x’を使ったときにファイルを削除するためにマー
クし、‘u’はマークを外します。‘C’はファイルをアーカイブからディスクにコピ
ーし、‘R’はアーカイブのファイルをリネームします。‘g’はバッファーをディス
ク上のアーカイブでリバートします。キー‘M’、‘G’、‘O’は、ファイルのパーミ
ッションビット、グループ、所有者を変更します。

   Tarバッファーの保存により、構成要素に変更が施された、新しいバージョン
のアーカイブをディスクに書き込みます。

   Tarモードを使うのに、‘tar’プログラムは必要ありません。Emacsは直接アー
カイブを読み込みます。しかし圧縮アーカイブへのアクセスには、適切な解凍プ
ログラムが必要です。

   ‘arc’、‘jar’、‘lzh’、‘zip’、‘rar’、‘7z’、‘zoo’、および自己解凍実行形
式の‘exe’には、互いに似通った異なるArchiveモードが使われます。

   ArchiveモードのキーバインドはTarモードと同様で、それに加えてキー‘m’は
後に続く操作のためにファイルをマークし、‘M-<DEL>’はマークされたファイル
のマークをすべて外します。キー‘a’は、1行に収まらないようなアーカイブの、
詳細なファイル情報の表示を切り替えます。ファイルのリネーム、ファイルモー
ドや所有者の変更をサポートするアーカイブ書式は、いくつかに限られます。

   Tarモードとは異なり、Archiveモードはアーカイブの展開と格納に、アーカ
イブプログラムを実行します。しかし、展開したりアーカイブ内のファイルを操
作するときだけこれらのプログラムが必要で、アーカイブの目録を見るには必要
ありません。プログラム名とセットできるオプションの詳細は、Customizeグル
ープ‘Archive’でセットできます(*note Customization Groups::を参照してくだ
さい)。


File: emacs-ja.info,  Node: Remote Files,  Next: Quoted File Names,  Prev: File Archives,  Up: Files

18.15 リモートファイル
======================

他のマシンにあるファイルを、特別なファイル名構文を使って参照できます:

     /METHOD:HOST:FILENAME
     /METHOD:USER@HOST:FILENAME
     /METHOD:USER@HOST#PORT:FILENAME

このリクエストを発行するために、Emacsは‘ssh’のような、リモートログインプ
ログラムを使います。どのmethodを使うかは、常にファイル名で指定しなければ
なりません。たとえば‘/ssh:USER@HOST:FILENAME’は‘ssh’を使います。ファイル
名のmethodに擬似methodの‘-’を使用したとき、Emacsは以下によりmethodを選択
します:

  1. ホスト名が‘ftp.’(ドット付き)で始まるとき、EmacsはFTPを使います。
  2. ユーザー名が‘ftp’または‘anonymous’のとき、EmacsはFTPを使います。
  3. 変数‘tramp-default-method’が‘ftp’にセットされているとき、Emacsは
     FTPを使います。
  4. ‘ssh-agent’が実行されているとき、Emacsは‘scp’を使います。
  5. 上記以外の場合、Emacsは‘ssh’を使います。

変数‘tramp-mode’を‘nil’にセットすることにより、リモートファイル名の機能
を完全にオフにすることができます。個別のケースについて機能をオフにするに
は、ファイル名を‘/:’でクォートします(*note Quoted File Names::を参照して
ください)。

   FTPを通じたリモートファイルへのアクセスは、以下で説明するAnge-FTPパッ
ケージで処理されます。他の方法によりリモートファイルへのアクセスは
Trampパッケージにより処理され、これにはそれ自身のマニュアルがあります。
*note The Tramp Manual: (tramp)Top.を参照してください。

   Ange-FTPパッケージでは、リモートファイル名にユーザー名USERがしている
ときは、FTPを通じてその名前でログインします。USERが指定されていないとき
、Emacsはローカルシステムのユーザー名でログインします。しかし変数
‘ange-ftp-default-user’に文字列がセットされているときは、かわりにその文
字列を使用します。Emacsは、ログイン時にパスワードの入力も求めます。

   パフォーマンス的な理由により、FTPを通じたファイルのアクセス時に、デフ
ォルトではEmacsはバックアップファイルを作成しません。バックアップを作成
するには、変数‘ange-ftp-make-backup-files’を非‘nil’値に変更してください
。

   デフォルトではリモートファイルの自動保存ファイルは、変数
‘auto-save-file-name-transforms’で指定された、ローカルマシンの一時ディレ
クトリーに作成されます。*note Auto Save Files::を参照してください。

   匿名FTPでアクセスできるファイルをvisitするには、特別なユーザー名
‘anonymous’または‘ftp’を使います。これらのユーザー名にたいするパスワード
は、特別に処理されます。これは変数
‘ange-ftp-generate-anonymous-password’により制御されます。この変数の値が
文字列の場合、その文字列がパスワードとして使用されます。非‘nil’(デフォル
ト)の場合、‘user-mail-address’の値が使用されます。‘nil’の場合、Emacsは通
常どおりパスワードの入力を求めます(*note Passwords::を参照してください
)。

   セキュリティー上の理由で、リモートマシンとの間にある“ファイアーウォー
ル(firewall)”により、ファイルにアクセスできないときがあります。対象ファ
イルにアクセスできるマシンから“ゲートウェイ(gateway)”マシンにログインで
きて、FTPサーバーがゲートウェイ機能をサポートしている場合は、リモートフ
ァイル名を使うことができます。これを行うには変数
‘ange-ftp-gateway-host’にゲートウェイマシンの名前をセットして、
‘ange-ftp-smart-gateway’を‘t’にセットする必要があります。それ以外の場合
でもリモートファイル名が機能するようにできますが、その方法は複雑です。こ
れらの方法は、‘M-x finder-commentary <RET> ange-ftp <RET>’とタイプして読
むことができます。


File: emacs-ja.info,  Node: Quoted File Names,  Next: File Name Cache,  Prev: Remote Files,  Up: Files

18.16 ファイル名のクォート
==========================

特殊な文字や構文を含むファイルにたいする特別な効果を防ぐために、絶対ファ
イル名を“クォート”できます。これを行うには先頭に‘/:’を追加します。

   たとえばリモートにあるように見える名前の、ローカルなファイルの名前を
クォートすることにより、リモートファイル名として扱われないようにすること
ができます。したがって名前が‘/foo:’というディレクトリーがあり、そこに
‘bar’という名前のファイルがある場合、Emacsでは、そのファイルを
‘/:/foo:/bar’という名前で参照できます。

   リモートファイル名もローカル部分の特殊文字だけをクォートしたい場合は
ローカル部分だけをクォートできます。たとえば‘/ssh:baz:/:/foo:/bar’は、ホ
スト‘baz’上のディレクトリー‘/foo:’のファイル‘bar’を参照します。

   ‘/:’は、‘~’がユーザーのホームディレクトリーを意味する、特別な文字とし
て扱われることを防ぐこともできます。たとえば‘/:/tmp/~hack’は、ディレクト
リー‘/tmp’のファイル‘~hack’を参照します。

   ‘/:’によるクォートは、ミニバッファーでの名前に‘$’を含むファイル名の入
力にも使用できます。これが機能するには、ミニバッファーの最初の内容が
‘/:’で始まらなければなりません(2回‘$’を記述することでも同様な効果が得ら
れます。詳細は*note File Names with $::を参照してください)。

   ファイルをvisitするときに、ワイルドカードをクォートすることもできます
。たとえば‘/:/tmp/foo*bar’は、ファイル‘/tmp/foo*bar’をvisitします。

   同じ効果を得るための別の方法は、‘/tmp/foo[*]bar’と入力する方法です。
これは‘/tmp/foo*bar’だけにマッチするワイルドカード指定です。しかしクォー
トしなくても同じ結果が得られるので、ワイルドカード文字をクォートする必要
がない場合がたくさんあります。たとえば‘/tmp’の中に‘foo’で始まり‘bar’で終
わるファイルが‘foo*bar’だけの場合、‘/tmp/foo*bar’と指定することにより、
‘/tmp/foo*bar’だけをvisitすることができます。


File: emacs-ja.info,  Node: File Name Cache,  Next: File Conveniences,  Prev: Quoted File Names,  Up: Files

18.17 ファイル名キャッシュ
==========================

“ファイル名キャッシュ(file name cache)”により、ファイルがどこにあるか正
確に覚えていなくても、名前でファイルがどこにあるかを簡単に指定することが
できます。ファイル名をミニバッファーでタイプするとき、‘C-<TAB>’
(‘file-cache-minibuffer-complete’)で、ファイル名キャッシュを使ったファイ
ル名を補完が行なわれます。‘C-<TAB>’を繰り返すと、最初にタイプした内容か
ら補完できる利用可能な候補を順番に表示します(しかし‘C-<TAB>’文字は、多く
のテキスト端末でタイプできないことに注意してください)。

   ファイル名キャッシュは自動的に充填されません。かわりに以下のコマンド
を使ってファイル名をキャッシュにロードします。

‘M-x file-cache-add-directory <RET> DIRECTORY <RET>’
     DIRECTORYの各ファイルを、ファイル名キャッシュに加えます。
‘M-x file-cache-add-directory-using-find <RET> DIRECTORY <RET>’
     DIRECTORYの各ファイルを、ファイル名キャッシュに加えるとともに、ネス
     トされたサブディレクトリーのすべてのファイルを、ファイル名キャッシ
     ュに加えます。
‘M-x file-cache-add-directory-using-locate <RET> DIRECTORY <RET>’
     DIRECTORYの各ファイルを、ファイル名キャッシュに加えるとともに、ネス
     トされたサブディレクトリーのすべてのファイルを、ファイル名キャッシ
     ュに加えます。ファイルの検索には、‘locate’を使用します。
‘M-x file-cache-add-directory-list <RET> VARIABLE <RET>’
     VARIABLEにリストされた各ディレクトリーのファイル名を、ファイル名キ
     ャッシュに加えます。VARIABLEはLisp変数で、‘load-path’と同様、値はデ
     ィレクトリーのリストです。
‘M-x file-cache-clear-cache <RET>’
     キャッシュをクリアーして、すべてのファイル名を削除します。

   ファイル名キャッシュは永続的ではありません。キャッシュが維持されるの
はEmacsのセッションの間だけです。キャッシュの内容は、
‘file-cache-display’コマンドで閲覧できます。


File: emacs-ja.info,  Node: File Conveniences,  Next: Filesets,  Prev: File Name Cache,  Up: Files

18.18 ファイル検索の便利な機能
==============================

このセクションでは、最近開いたファイルの検索、バッファーからのファイル名
の読み取り、イメージファイルの閲覧などの、便利な機能を紹介します。

   ‘M-x recentf-mode’でRecentfモードを有効にすると、‘File’メニューに最近
開いたファイルを含むサブメニューが含まれるようになります。‘M-x
recentf-save-list’は現在の‘recent-file-list’をファイルに保存し、‘M-x
recentf-edit-list’でそれを編集できます。

   ‘M-x ffap’コマンドは、‘find-file’を一般化した、より強力なデフォルト決
定のための機能で、基本的にはポイント位置のテキストにもとづいて決定を行な
います。Partial Completionモードは‘find-file’を拡張する、‘ffap’とともに
使用できるその他の機能を提案します。*note Completion Options::を参照して
ください。

   イメージファイルをvisitすることにより、Imageモードが選択されます。こ
のメジャーモードでは、‘C-c C-c’ (‘image-toggle-display’)とタイプすること
により、Emacsバッファーでファイルのイメージ表示と、イメージの元となるテ
キスト(またはraw byte)表示を切り替えることができます。さらに‘C-c C-x’
(‘image-toggle-hex-display’)とタイプすると、Emacsバッファー内でイメージ
としてファイルを表示、または16進表記で表示を切り替えることができます。フ
ァイルのイメージ表示は、Emacsがそのようなイメージの表示をサポートするよ
うにコンパイルされているときだけ機能します。イメージがフレームの高さまた
は幅より大きい場合、通常のポイント移動キー(‘C-f’、‘C-p’、...)は、イメー
ジの他の部分の表示に使われます。‘n’ (‘image-next-file’)および‘p’
(‘image-previous-file’)を押すことにより、同じディレクトリーにある次また
は前のイメージをvisitします。

   アニメーションが可能なイメージの場合、コマンド<RET>
(‘image-toggle-animation’)で、アニメーションの開始と停止ができます。オプ
ション‘image-animate-loop’が非‘nil’でなければ、アニメーションの再生は1回
です。‘f’ (‘image-next-frame’)と‘b’ (‘image-previous-frame’)により、アニ
メーションの各フレームを切り替えることができます。これらのコマンドは数引
数を指定することにより、指定した数の分だけ先のフレームを表示できます。
‘F’ (‘image-goto-frame’)により、特定のフレームを指定することができます。
フレームは1からインデックスがつきます。‘a +’ (‘image-increase-speed’)と
タイプすると、アニメーションのスピードが早くなり、‘a -’
(‘image-decrease-speed’)で遅くなります。また‘a r’
(‘image-reverse-speed’)で逆再生されます。コマンド‘a 0’
(‘image-reset-speed’)は、スピードを元の値にリセットします。

   EmacsがImageMagickのサポートつきでコンパイルされている場合、さまざま
なイメージを描画するのに、ImageMagickを使うことができます。変数
‘imagemagick-enabled-types’は、EmacsがImageMagickを使って描画できるイメ
ージの種類のリストです。リストの各要素は、ImageMagick内部でのイメージ種
類にたいする名前で、シンボルまたは等価な文字列で指定します(たとえば
‘BMP’は‘.bmp’イメージです)。利用可能なイメージの種類にたいして
ImageMagickを有効にするには、‘imagemagick-enabled-types’を‘t’に変更しま
す。変数‘imagemagick-types-inhibit’は、変数‘imagemagick-enabled-types’の
値にかかわらずmImageMagickを使わずに描画するイメージ種類のリストです(リ
ストのデフォルトには‘C’および‘HTML’などが含まれ、これらはImageMagickはイ
メージとして描画できるが、Emacsはイメージとして描画しないものです)。
ImageMagickを完全に無効にするには、‘imagemagick-types-inhibit’を‘t’に変
更してください。

   Image-Diredパッケージはイメージをサムネールとして表示するのにも使用さ
れます。*note Image-Dired::を参照してください。


File: emacs-ja.info,  Node: Filesets,  Prev: File Conveniences,  Up: Files

18.19 ファイルセット
====================

定期的に特定のファイルのグループを編集する場合、それらを“ファイルセット
(fileset)”として定義できます。これによりvisit、‘query-replace’、シェルコ
マンドなどの特別な操作を、すべてのファイルに一度に行うことができます。フ
ァイルセットを使うには、initファイル(*note Init File::を参照)に、式
‘(filesets-init)’を追加しなければなりません。これはメニューバーの
‘File’メニューに、サブメニュー‘Filesets’を追加します。

   ファイルセットを定義する一番簡単な方法は、ファイルを1つずつ追加する方
法です。ファイルセットNAMEにファイルを追加するには、そのファイルを
visitして‘M-x filesets-add-buffer <RET> NAME <RET>’をタイプします。ファ
イルセットNAMEが存在しない場合、現在のファイルだけを含む新しいファイルセ
ットを作成します。コマンド‘M-x filesets-remove-buffer’は、ファイルセット
から現在のファイルを削除します。

   ‘M-x filesets-edit’(または‘Filesets’メニューの‘Edit Filesets’を選択
)で、ファイルセットを直接編集することもできます。編集はCustomizeバッファ
ーで行われます(*note Easy Customization::を参照してください)。ファイルセ
ットは通常、単純なファイルのリストですが、ファイル名にマッチする正規表現
で、ファイルセットを定義することもできます。より複雑なファイルセットの例
は、Customizeバッファーに記されています。将来のEmacsセッションで同じファ
イルセットを使うには、‘Save for future sessions’を選択するのを忘れないで
ください。

   コマンド‘M-x filesets-open’を使って、ファイルセットのすべてのファイル
をvisitし、それらを‘M-x filesets-close’で閉じることができます。‘M-x
filesets-run-cmd’を使って、ファイルセットのすべてのファイルにたいして、
シェルコマンドを実行します。これらのコマンドは‘Filesets’メニューからも利
用可能で、メニューには既存のファイルセットが、サブメニューとして表示され
ています。

   異なるコンセプトのファイルセット(バージョンコントロール操作のためにグ
ループにまとめられたファイル)については、*note Version Control::を参照し
てください。この種のファイルセットには名前がなく、Emacsセッション間で引
き継がれません。


File: emacs-ja.info,  Node: Buffers,  Next: Windows,  Prev: Files,  Up: Top

19 複数バッファーの使用
***********************

Emacsで編集するテキストは、“バッファー(buffer)”と呼ばれるオブジェクトの
中に存在します。ファイルをvisitするたびに、そのファイルのテキストを保持
するために、バッファーが使われます。Diredを呼び出すたびに、ディレクトリ
ーリストを保持するためにバッファーが使われます。‘C-x m’でメッセージを送
信すると、メッセージのテキストを保持するためにバッファーが使われます。コ
マンドのドキュメントは、‘*Help*’という名前のバッファーに表示されます。

   それぞれのバッファーは、任意の長さの一意な名前を持っています。バッフ
ァーがウインドウに表示されているとき、バッファーの名前はモードライン
(*note Mode Line::を参照してください)に表示されます。バッファー名での大
文字と小文字の違いは重要です。ほとんどの場合、ほとんどのバッファーは
visitしているファイルから作られ、それらの名前はファイル名から生成されま
す。しかし、新しい空のバッファーを、任意の名前で作成することもできます。
新しく開始されたEmacsにはいくつかのバッファーがあり、それらの中には
‘*scratch*’という名前の、Lisp式を評価するのに使用されるバッファーも含ま
れます。そのバッファーはファイルに関連付けられていません(*note Lisp
Interaction::を参照してください)。

   “選択”されるバッファーは、常に1つだけです。そのバッファーを“カレント
バッファー(current buffer: 現在のバッファー)”と呼びます。「コマンドは“そ
のバッファー(the buffer)”を操作します」という言い方をするときがあります
。これはカレントバッファーを操作するというのが、本当の意味です。Emacsの
ウィンドウが1つだけのとき、そのウィンドウに表示されているバッファーがカ
レントになります。複数のウィンドウがあるとき、“選択されたウィンドウ”に表
示されているバッファーがカレントになります。*note Windows::を参照してく
ださい。

   バッファーの“コンテンツ(contents: 内容)”とは、オプションでテキストプ
ロパティ(*note Text properties: International Chars.を参照)のセットをも
つ一連の文字から構成されます。テキストプロパティにより、文字により多くの
情報を指定できます。

   バッファーのテキスト的な内容は別として、それぞれのバッファーはいくつ
かの情報を記録しています。それらは、(もしあれば)visitしているファイルは
何か、変更されているか、有効なメジャーモードとマイナーモードは何か(*note
Modes::を参照してください)、などの情報です。これらは、“バッファーローカ
ルな変数(buffer-local variables)”に格納され、これらの変数はバッファーご
とに異なる値をもつことができます。*note Locals::を参照してください。

   バッファーのサイズは、いくつかの最大値を超えて大きくすることはできま
せん。これは一番大きいバッファーの位置が、“Emacsの整数(Emacs integers)”で
表されることにより定義されます。なぜならEmacsはそのデータ型を使用して、
バッファーの位置を追跡するからです。通常の64ビットマシンでは、バッファー
の最大サイズは2^{61} - 2バイト、およそ2EiBです。通常の32ビットマシンでは
、バッファーの最大サイズは通常2^{29} - 2バイト、およそ512MiBです。バッフ
ァーのサイズはシステムのメモリー量によっても制限されます。

* Menu:

* Select Buffer::            新しいバッファーの作成と既存のバッファーの再選択。
* List Buffers::             既存のバッファーリストの取得。
* Misc Buffer::              リネーム、読み取り専用属性の変更、テキストのコピー。
* Kill Buffer::              不必要なバッファーのkill。
* Several Buffers::          すべてのバッファーにたいするリストの操作と、複数バッファーにたいする操作。
* Indirect Buffers::         他のバッファーのテキストを共有するインダイレクトバッファー。
* Buffer Convenience::       バッファー操作のための便利な機能とカスタマイズ。


File: emacs-ja.info,  Node: Select Buffer,  Next: List Buffers,  Up: Buffers

19.1 バッファーの作成と選択
===========================

‘C-x b BUFFER <RET>’
     BUFFERという名前のバッファーを、選択または作成します
     (‘switch-to-buffer’)。
‘C-x 4 b BUFFER <RET>’
     同様ですが、他のウィンドウでBUFFERを選択します
     (‘switch-to-buffer-other-window’)。
‘C-x 5 b BUFFER <RET>’
     同様ですが、別のフレームでBUFFERを選択します
     (‘switch-to-buffer-other-frame’)。
‘C-x <LEFT>’
     バッファーリストの、前のバッファーを選択します(‘previous-buffer’)。
‘C-x <RIGHT>’
     バッファーリストの、次のバッファーを選択します(‘next-buffer’)。
‘C-u M-g M-g’
‘C-u M-g g’
     数字Nを読み取って、カレントバッファーではない、一番最近選択された、
     別のウィンドウにあるバッファーの、N行目に移動します。

   ‘C-x b’ (‘switch-to-buffer’)コマンドは、ミニバッファーを使ってバッフ
ァー名を読み取ります。それからそのバッファーをカレントとして、現在選択さ
れたウィンドウに表示します。空の入力は、そのとき他のウィンドウに表示され
ていない、一番最近カレントだったバッファーを指定します。

   バッファー名を入力するとき、通常の補完とヒストリーコマンドを使うこと
ができます(*note Minibuffer::を参照してください)。‘C-x b’および関連する
コマンドは、ミニバッファーの補完に、“確認つきの寛大な補完(permissive
completion with confirmation)”を使うことに注意してください。存在しないバ
ッファー名にたいする補完の後、すぐに<RET>をタイプすると、Emacsは
‘[Confirm]’を出力し、バッファー名を確定するために2回目の<RET>をタイプし
なければなりません。詳細は、*note Completion Exit::を参照してください。
その他の補完オプションと機能についての詳細は、*note Completion
Options::を参照してください。

   存在しないバッファーを指定すると、‘C-x b’はファイルをvisitしていない
新しい空のバッファーを作成し、編集用にそのバッファーを選択します。変数
‘major-mode’は、新しいバッファーのメジャーモードのデフォルトを決定します
。デフォルトでは、これはFundamentalモードです。*note Major Modes::を参照
してください。新しいバッファーを作る1つの理由は、それを一時的なノートと
して使うためです。これを保存しようと試みると、Emacsは保存に使うファイル
名を尋ね、バッファーのメジャーモードは、ファイル名にもとづきメジャーモー
ドを再割り当てします(*note Choosing Modes::を参照してください)。

   少ないバッファーの切り替えでは、コマンド‘C-x <LEFT>’および‘C-x
<RIGHT>’を使うのが便利です。‘C-x <LEFT>’ (‘previous-buffer’)は前のバッフ
ァー(現在のフレームの一番最近選択されたバッファー順)、‘C-x <RIGHT>’
(‘next-buffer’)は逆方向のバッファーに移動します。

   現在のウィンドウとは別のウィンドウにバッファーを選択するには、‘C-x 4
b’ (‘switch-to-buffer-other-window’)とタイプします。これはミニバッファー
を使ってバッファー名の入力を求め、選択されているウィンドウではない別のウ
ィンドウに、そのバッファーを表示して、そのウィンドウを選択します。

   同様に‘C-x 5 b’ (‘switch-to-buffer-other-frame’)はバッファー名の入力
を求め、他のフレーム(*note Frames::を参照)にそのバッファーを表示して、そ
のフレームを選択します。他のウィンドウまたはフレームにすでにバッファーが
表示されている場合、Emacsは新しく作成するのではなく、そのウィンドウまた
はフレームを選択します。

   ‘C-x 4 b’および‘C-x 5 b’コマンドが表示するウィンドウまたはフレームを
取得する方法については、*note Displaying Buffers::を参照してください。

   これらに加えて、‘C-x C-f’や、その他のファイルをvisitするコマンドでも
、すでにファイルをvisitしているバッファーに切り替えることができます。
*note Visiting::を参照してください。

   プレフィクス引数だけを指定した‘C-u M-g M-g’ ‘goto-line’は、ミニバッフ
ァーを使って数字Nを読み取り、別のウィンドウにあるカレントバッファー以外
の、一番最近選択されたバッファーを選択して、ポイントをそのバッファーの
N行目の先頭に移動します。これは他のバッファーの行番号を参照するバッファ
ーで特に有用です。ポイントが数字の直後にある場合、‘goto-line’はNのデフォ
ルトとしてその数字を使います。ただの‘C-u’ではないプレフィクス引数では、
異なる振る舞いをすることに注意してください。‘C-u 4 M-g M-g’はミニバッフ
ァーから数字を読み取らず、_カレントバッファー_の4行目にジャンプします(プ
レフィクス引数を指定しない‘M-g M-g’は、数字Nを読み取ってカレントバッファ
ーのN行目に移動することを思い出してください。*note Moving Point::を参照
してください)。

   Emacsはスペースで開始される名前のバッファーを、内部的な用途のために使
用しています。それらのバッファーは特別な方法で扱われます。たとえば、それ
らのバッファーではundo情報が記録されません。そのようなバッファー名を使う
ことは避けるのが最良です。


File: emacs-ja.info,  Node: List Buffers,  Next: Misc Buffer,  Prev: Select Buffer,  Up: Buffers

19.2 既存のバッファーを一覧する
===============================

‘C-x C-b’
     既存のバッファーをリストします(‘list-buffers’)。

   既存のバッファーのリストを表示するには、‘C-x C-b’とタイプします。これ
により、‘*Buffer List*’という名前のバッファーにバッファーメニューがポッ
プアップします。リストの各行にはバッファー名、サイズ、メジャーモード、
visitしているファイルが表示されます。バッファーは、カレントだった順でリ
ストされます。したがって、一番最近カレントだったバッファーが先頭に表示さ
れます。このセクションでは、バッファーリストが表示される方法と、リスト内
に示されるさまざまなものの解釈の仕方について説明します。‘*Buffer List*’バ
ッファーの特別なモードと、利用可能なコマンドについては、*note Several
Buffers::を参照してください。

   行の最初のフィールドの‘.’は、そのバッファーがカレントであることを示し
ます。‘%’は読み取り専用バッファーであることを示します。‘*’はそのバッファ
ーが変更されていることを示します。いくつかのバッファーが変更されていて、
それらを保存するべきだと思ったときは、‘C-x s’ (*note Save Commands::を参
照してください)で保存します。以下はバッファーリストの例です:

     CRM Buffer                Size  Mode              File
     . * .emacs                3294  Emacs-Lisp        ~/.emacs
      %  *Help*                 101  Help
         search.c             86055  C                 ~/cvs/emacs/src/search.c
      %  src                  20959  Dired by name     ~/cvs/emacs/src/
       * *mail*                  42  Mail
      %  HELLO                 1607  Fundamental       ~/cvs/emacs/etc/HELLO
      %  NEWS                481184  Outline           ~/cvs/emacs/etc/NEWS
         *scratch*              191  Lisp Interaction
       * *Messages*            1554  Messages

この例でバッファー‘*Help*’は、ヘルプを要求されたことにより作成されます
(*note Help::を参照してください)。これはファイルをvisitしていません。バ
ッファー‘src’は、ディレクトリー‘~/cvs/emacs/src/’にたいして、Diredが作成
したバッファーです。ファイルをvisitしているバッファーだけを一覧するには
、‘C-u C-x C-b’のように、コマンドにプレフィクス引数を与えます。

   ‘list-buffers’は名前がスペースで始まるバッファーを省略します(そのバッ
ファーがファイルをvisitしていない限り)。これらのバッファーは、Emacsによ
り内部的に使用されます。


File: emacs-ja.info,  Node: Misc Buffer,  Next: Kill Buffer,  Prev: List Buffers,  Up: Buffers

19.3 その他のバッファー操作
===========================

‘C-x C-q’
     バッファーの読み取り専用の状態を切り替えます(‘read-only-mode’)。
‘M-x rename-buffer <RET> BUFFER <RET>’
     カレントバッファーの名前を変更します。
‘M-x rename-uniquely’
     カレントバッファーの末尾に‘<NUMBER>’を加えてリネームします。
‘M-x view-buffer <RET> BUFFER <RET>’
     バッファーBUFFERをスクロールして閲覧します。*note View Mode::を参照
     してください。

   バッファーを読み取り専用にすることができます、これはバッファーのテキ
ストにたいして挿入や削除を行うコマンドが許されないことを意味します(とは
いえ、他の‘C-x <RET> f’のようなコマンドは、バッファーを変更済みとマーク
することは可能。*note Text Coding::を参照されたい)。読み取り専用バッファ
ーのモードラインでは、左余白の近くに‘%%’または‘%*’が表示されます。*note
Mode Line::を参照してください。読み取り専用バッファーは通常、Diredや
Rmailのように、そのバッファーのテキストを操作する専用コマンドをもつ、サ
ブシステムにより作成されます。アクセスが制御されているファイルをvisitし
たときも、そのバッファーに書き込めない旨が通知されます。

   コマンド‘C-x C-q’ (‘read-only-mode’)は、読み取り専用バッファーを書き
込み可能に、書き込み可能なバッファーを読み取り専用にします。これは各バッ
ファーにローカルな変数‘buffer-read-only’をセットすることにより機能します
(値が非‘nil’のときバッファーは読み取り専用)。オプション
‘view-read-only’を非‘nil’値に変更すると、‘C-x C-q’でバッファーを読み取り
専用にしたとき、そのバッファーでViewモードが有効になります(*note View
Mode::を参照してください)。

   ‘M-x rename-buffer’は、カレントバッファーの名前をリネームします。新し
い名前はミニバッファーで指定します。デフォルトはありません。他のバッファ
ーで使用済の名前を指定するとエラーとなり、リネームされません。

   ‘M-x rename-uniquely’は、カレントバッファーの後ろに数字を追加して、似
てはいるが異なる名前を作成します。このコマンドに引数は必要ありません。こ
れは複数のshellバッファーを作成するのに便利です。‘*shell*’バッファーをリ
ネームしてから、再度‘M-x shell’を行うと、これは新しく‘*shell*’という名前
のバッファーを作成します。一方リネームされた古いshellバッファーは、新し
い名前で実行を続けます。この方法はmailバッファー、compilationバッファー
、そして特定の名前で特別なバッファーを作成するEmacs機能に適しています(こ
れらの機能のいくつか、たとえば‘M-x compile’、‘M-x grep’などでは、コマン
ドを再度実行する前に他のバッファーに切り替える必要があります。さもないと
カレントバッファーの名前を変更せずに、そのバッファーを再使用します)。

   コマンド‘M-x append-to-buffer’および‘M-x insert-buffer’も、あるバッフ
ァーから他のバッファーへテキストをコピーするのに使用できます。*note
Accumulating Text::を参照してください。


File: emacs-ja.info,  Node: Kill Buffer,  Next: Several Buffers,  Prev: Misc Buffer,  Up: Buffers

19.4 バッファーのkill
=====================

しばらくの間、Emacsセッションを続けていると、多くのバッファーが溜まって
しまう場合があります。必要のないバッファーを“kill”したほうがよいと思うか
もしれません(他のエディターではこの操作を“close(閉じる)”と呼び、“バッフ
ァーを閉じる”とか、ファイルをvisitしているバッファーでは“ファイルを閉じ
る”のように表現するものもあります)。ほとんどのオペレーティングシステムで
は、バッファーをkillすることにより、バッファーのためにEmacsが使用してい
たメモリーをオペレーティングシステムに解放するので、他のプログラムがそれ
を使えるようになります。以下はバッファーをkillするコマンドです:

‘C-x k BUFFER <RET>’
     バッファーBUFFERをkillします(‘kill-buffer’)。
‘M-x kill-some-buffers’
     バッファーを1つずつkillするか尋ねます。
‘M-x kill-matching-buffers’
     正規表現にマッチするすべてのバッファーをkillするか尋ねます。

   ‘C-x k’ (‘kill-buffer’)は、ミニバッファーで指定した名前のバッファーを
1つkillします。<RET>だけをタイプしたときはデフォルトが使われ、これはカレ
ントバッファーをkillします。カレントバッファーをkillすると、最近カレント
だったが、今は別のウィンドウにも表示されていないバッファーがカレントにな
ります。ファイルをvisitしているバッファーが変更されているとき、それを
killしようとすると確認を求められます。そのバッファーをkillする前に、確認
に‘yes’を応えなければkillできません。

   コマンド‘M-x kill-some-buffers’は、各バッファーについて1つずつ確認を
求めます。‘yes’と応えると、‘kill-buffer’と同様にバッファーをkillすること
を意味します。このコマンドは名前がスペースで始まる、Emacsが内部的に使用
するバッファーは無視します。

   コマンド‘M-x kill-matching-buffers’は、正規表現の入力を求め、名前がそ
の正規表現にマッチするすべてのバッファーをkillします。*note Regexps::を
参照してください。‘kill-some-buffers’と同様、このコマンドはkillする前に
確認を求めます。このコマンドは通常、名前がスペースで始まる、Emacsが内部
的に使うバッファーを無視します。内部的なバッファーも同じようにkillするに
は、プレフィクス引数を指定して‘kill-matching-buffers’を呼び出します。

   さまざまなバッファーをkillするにはBuffer Menu機能も便利です。*note
Several Buffers::を参照してください。

   バッファーがkillされるときに特別な処理を行いたい場合、フック
‘kill-buffer-hook’にフック関数を追加できます(*note Hooks::を参照してくだ
さい)。

   (多くの人がそうしているように)何日間も1つのEmacsセッションを使ってい
ると、何日か前に使ったバッファーが溜まってくるかもしれません。コマンド
‘M-x clean-buffer-list’は、それらを一掃するのに便利です。これは長い間使
用されていない、変更されていないバッファーをすべてkillします。3日間表示
されていない普通のバッファーはkillされます。しかし自動的にkillされるべき
ではない特定のバッファーを指定したり、使われていない時間が短いバッファー
でもkillするように指定できます。これらのデフォルト、およびこのコマンドの
挙動の他の動向は、‘clean-buffer-list’のドキュメント文字列で説明されてい
る、いくつかのオプションをカスタマイズすることにより制御できます。

   Midnightモードを有効にすることにより、1日ごとにバッファーを一掃するこ
ともできます。Midnightモードは毎日真夜中に‘clean-buffer-list’、またはノ
ーマルフック‘midnight-hook’に指定された関数を実行します(*note Hooks::を
参照してください)。Midnightモードを有効にするには、Customizationバッファ
ーを使って変数‘midnight-mode’を‘t’にセットします。*note Easy
Customization::を参照してください。


File: emacs-ja.info,  Node: Several Buffers,  Next: Indirect Buffers,  Prev: Kill Buffer,  Up: Buffers

19.5 複数バッファーにたいする操作
=================================

‘M-x buffer-menu’
     すべてのEmacsバッファーの、バッファーリストの編集を開始します。
‘M-x buffer-menu-other-window’
     同様ですが、別のウィンドウで行います。

   ‘C-x C-b’ (*note List Buffers::を参照してください)でオープンされる
“Buffer Menu”は、単にバッファーを一覧するだけではありません。これは
Diredに似たインターフェースで、バッファーにたいしてさまざまな操作を行う
ことができます。ここでは、バッファーの保存、kill(Diredとの一貫性を保つた
め、ここではそれらを“削除(delete)”する、と呼びます)、表示ができます。

   Buffer Menuを使うには‘C-x C-b’とタイプして、‘*Buffer List*’バッファー
が表示されたウィンドウに切り替えます。‘M-x buffer-menu’とタイプして、選
択されたウィンドウにBuffer Menuを開くこともできます。コマンド‘M-x
buffer-menu-other-window’は、Buffer Menuを別のウィンドウに開いて、そのウ
ィンドウを選択します。

   Buffer Menuは読み取り専用バッファーで、このセクションで説明する特別な
コマンドだけを通じて変更します。このバッファーでは、通常のカーソル移動コ
マンドを使うことができます。以下のコマンドは、バッファーのカレント行に適
用されます。

‘d’
     そのバッファーの削除(kill)フラグをセットしてから、ポイントを次の行
     に移動します(‘Buffer-menu-delete’)。削除フラグは、各行のバッファー
     名の前の文字‘D’により示されます。削除は‘x’コマンド(以下参照)をタイ
     プしたときだけ発生します。

‘C-d’
     ‘d’と同様ですが、ポイントを下ではなく上に移動します
     (‘Buffer-menu-delete-backwards’)。

‘s’
     そのバッファーの保存フラグをセットします(‘Buffer-menu-save’)。保存
     フラグは各行のバッファー名の前の文字‘S’により示されます。保存は
     ‘x’コマンド(以下参照)をタイプしたときだけ発生します。同じバッファー
     に保存と削除の両方をリクエストできます。

‘x’
     すべての削除および保存フラグを処理します(‘Buffer-menu-execute’)。

‘u’
     カレント行のすべてのフラグを取り除いてから、下に移動します
     (‘Buffer-menu-unmark’)。プレフィックス引数を指定した場合は、フラグ
     を取り除いた後、上に移動します。

‘<DEL>’
     前の行に移動して、その行のすべてのフラグを取り除きます
     (‘Buffer-menu-backup-unmark’)。

‘M-<DEL>’
     すべて行から特定のフラグを取り除きます
     (‘Buffer-menu-unmark-all-buffers’)。これは、1文字の入力を求めて、そ
     の文字でマークされたバッファーのマークを取り除きます。<RET>をタイプ
     した場合は、すべてのマークを取り除きます。

‘U’
     すべての行のすべてのフラグを取り除いてから、下に移動します
     (‘Buffer-menu-unmark-all’)。

フラグを取り除くコマンド‘d’と‘C-d’には、繰り返し回数として数引数を指定で
きます。

   以下のコマンドは、カレント行にリストされたバッファーを即座に処理しま
す。これらのコマンドにも、繰り返し回数を数引数として指定できます。

‘~’
     バッファーを変更されていない(unmodified)とマークします
     (‘Buffer-menu-not-modified’)。*note Save Commands::を参照してくださ
     い。

‘%’
     バッファーの読み取り専用属性を切り替えます
     (‘Buffer-menu-toggle-read-only’)。*note Misc Buffer::を参照してくだ
     さい。

‘t’
     そのバッファーを、tagsテーブルとしてvisitします
     (‘Buffer-menu-visit-tags-table’)。*note Select Tags Table::を参照し
     てください。

   以下は、他のバッファーを選択するために使われるコマンドです:

‘q’
     Buffer Menuメニューを閉じます(‘quit-window’)。一番最近に表示されて
     いたバッファーが、その場所に表示されます。

‘<RET>’
‘f’
     そのウィンドウの‘*Buffer List*’バッファーを置き換えて。この行のバッ
     ファーを選択します(‘Buffer-menu-this-window’)。

‘o’
     ‘C-x 4 b’のように‘*Buffer List*’を表示したまま、その行のバッファー
     を他のウィンドウで選択します(‘Buffer-menu-other-window’)。

‘C-o’
     この行のバッファーを他のウィンドウで表示しますが、選択はしません
     (‘Buffer-menu-switch-other-window’)。

‘1’
     この行のバッファーを、フレーム全体のウィンドウで選択します
     (‘Buffer-menu-1-window’)。

‘2’
     現在のフレームを2つのウィンドウにセットアップして、この行のバッファ
     ーを一方のウィンドウで選択し、もう一方のウィンドウに以前のカレント
     バッファー(‘*Buffer List*’)は除く)を表示します
     (‘Buffer-menu-2-window’)。

‘b’
     この行のバッファーをbury(つまりバッファーリストの最後)に移動します
     (‘Buffer-menu-bury’)。

‘m’
     ‘v’コマンドで抜けるとき、この行のバッファーを他のウィンドウで表示さ
     れるようにマークします(‘Buffer-menu-mark’)。表示フラグは行の先頭に
     文字‘>’で示されます(1つのバッファーが削除と表示のフラグを両方もつこ
     とはないでしょう)。

‘v’
     この行のバッファーを選択し、‘m’コマンドでフラグづけされたバッファー
     も他のウィンドウで表示します(‘Buffer-menu-select’)。バッファーにフ
     ラグをつけていないとき、このコマンドは‘1’と等価です。

   以下はバッファーリスト全体に影響を与えるコマンドです:

‘S’
     ポイントがある列の数値にしたがって、Buffer Menu全体をソートします。
     数引数Nを指定すると、N番目の列でソートします
     (‘tabulated-list-sort’)。

‘T’
     非ファイルバッファーを削除または再挿入します
     (‘Buffer-menu-toggle-files-only’)。このコマンドは、そのようなバッフ
     ァーがバッファーリストに含まれるか否かを切り替えます。

   バッファー‘*Buffer List*’は通常、バッファーの作成およびkillにより自動
的に更新はされません(内容は単なるテキストです)。バッファーを作成・削除・
リネームした場合、それが行われたか確かめるために‘*Buffer List*’を更新す
るには、‘g’ (‘revert-buffer’)とタイプします。このバッファーのAuto
Revertモードを有効にすれば、このバッファーが変更されたとマークされない限
り、‘auto-revert-interval’秒ごとに定期的に更新させることができます。
Global Auto Revertモードは、‘global-auto-revert-non-file-buffers’が非
‘nil’のときだけ、‘*Buffer List*’バッファーに適用されます。 詳細は、*note
global-auto-revert-non-file-buffers: Autorevert.を参照してください。


File: emacs-ja.info,  Node: Indirect Buffers,  Next: Buffer Convenience,  Prev: Several Buffers,  Up: Buffers

19.6 インダイレクトバッファー
=============================

“インダイレクトバッファー(indirect buffer: 間接バッファー)”は、そのイン
ダイレクトバッファーの“ベースバッファー(base buffer: 基底バッファー)”と
呼ばれる、他のバッファーのテキストを共有します。ある点においては、ファイ
ルに置けるシンボリックリンクの、バッファー版に例えることができます。

‘M-x make-indirect-buffer <RET> BASE-BUFFER <RET> INDIRECT-NAME <RET>’
     ベースバッファーBASE-BUFFERの、インダイレクトバッファー
     INDIRECT-NAMEを作成します。
‘M-x clone-indirect-buffer <RET>’
     カレントバッファーの、インダイレクトバッファーを作成します。
‘C-x 4 c’
     カレントバッファーのインダイレクトバッファーを作成して、それを別の
     ウィンドウで選択します(‘clone-indirect-buffer-other-window’)。

   インダイレクトバッファーのテキストは、常にベースバッファーのテキスト
と等しく、どちらかを編集すると、その変更はすぐにもう一方から見えるように
なります。しかし他の観点では、インダイレクトバッファーとベースバッファー
は、完全に分離されています。これらのバッファーは異なる名前、異なるポイン
ト値、異なるナローイング、異なるマーカー、異なるメジャーモード、異なるロ
ーカル変数をもつことができます。

   インダイレクトバッファーはファイルをvisitできませんが、ベースバッファ
ーはvisitできます。インダイレクトバッファーの保存を試みると、それは実際
にはベースバッファーの保存として機能します。ベースバッファーをkillすると
インダイレクトバッファーもkillされますが、インダイレクトバッファーの
killは、ベースバッファーに影響を与えません。

   インダイレクトバッファーの1つの使い方としては、アウトラインの複数の視
点からの表示です。*note Outline Views::を参照してください。

   手早くインダイレクトバッファーを作成するには、コマンド‘M-x
clone-indirect-buffer’を使う方法があります。これはカレントバッファーをベ
ースバッファーとする、インダイレクトバッファーを作成して選択します。数引
数を指定すると、インダイレクトバッファーの名前の入力を求めます。指定しな
い場合、カレントバッファー名の後ろに‘<N>’を付加した名前を使います。‘C-x
4 c’ (‘clone-indirect-buffer-other-window’)は、‘M-x
clone-indirect-buffer’と同様に機能しますが、新しいバッファーを他のウィン
ドウで選択します。これらの関数はインダイレクトバッファーを作成した後、フ
ック‘clone-indirect-buffer-hook’を実行します。

   インダイレクトバッファーを作成する、より一般的な方法はコマンド‘M-x
make-indirect-buffer’です。これはバッファーBASE-BUFFERから、名前が
INDIRECT-NAMEのインダイレクトバッファーを作成します。これらの名前は、ミ
ニバッファーを使って入力が求められます。


File: emacs-ja.info,  Node: Buffer Convenience,  Prev: Indirect Buffers,  Up: Buffers

19.7 バッファー処理の便利な機能とカスタマイズ
=============================================

このセクションではバッファーを切り替えをもっと便利にする、モードと機能を
いくつか説明します。

* Menu:

* Uniquify::                 ディレクトリー部分でバッファー名を一意にする。
* Icomplete::                素早いミニバッファーの選択について。
* Buffer Menus::             バッファーメニューの設定。


File: emacs-ja.info,  Node: Uniquify,  Next: Icomplete,  Up: Buffer Convenience

19.7.1 バッファー名を一意にする
-------------------------------

同じ名前のファイルを複数のバッファーでvisitしているとき、Emacsはバッファ
ーに区別可能な名前をつけなければなりません。デフォルトの方法はファイルを
ディレクトリーの一部を後ろに追加する方法です。たとえば同時にファイル
‘/foo/bar/mumble/name’と‘/baz/quux/mumble/name’をvisitしている場合、バッ
ファーの名前は‘name<bar/mumble>’と‘name<quux/mumble>’になるでしょう。
Emacsは名前を一意にするために必要な分だけ、ディレクトリー名の一部を追加
します。

   オプション‘uniquify-buffer-name-style’をカスタマイズして、一意なバッ
ファー名を構築するための異なるスタイルを選択することができます。

   命名方法‘forward’は、バッファー名の先頭部分に、ファイルのディレクトリ
ー名の一部を含めます。この方法を使うとファイル‘/u/rms/tmp/Makefile’と
‘/usr/projects/zaphod/Makefile’をvisitしているバッファーの名前は、
‘tmp/Makefile’と‘zaphod/Makefile’になるでしょう。

   対照的に命名方法‘post-forward’は、バッファーを‘Makefile|tmp’および
‘Makefile|zaphod’と名づけます。デフォルトの
‘post-forward-angle-brackets’は、‘post-forward’と同様ですが、一意なパス
を山形カッコ(angle brackets)で囲います。命名方法‘reverse’では、
‘Makefile\tmp’および‘Makefile\zaphod’となります。‘post-forward’と
‘reverse’の重要な違いは、2つのファイルを区別するのに1つのディレクトリ名
では不足するときです。‘reverse’はディレクトリー名を逆順にして命名するの
で、ファイル‘/top/middle/file’は‘file\middle\top’となります。一方
‘post-forward’はディレクトリー名を正順でファイル名に追加するので
‘file|top/middle’となります。‘uniquify-buffer-name-style’が‘nil’にセット
されていると、バッファー名の後ろに単に‘<2>’、‘<3>’と加えることにより、バ
ッファー名を作成します。

   タイプする前にバッファー名に_注意_すれば、バッファー名にディレクトリ
ー名を付加する方法に重要な違いはありません。しかしルールを知った経験豊富
なユーザーは、それほど注意する必要はないでしょう。そして、その場合いずれ
かのルールでバッファー名が表示されていれば，思い出し利用するのが容易にな
ることでしょう。


File: emacs-ja.info,  Node: Icomplete,  Next: Buffer Menus,  Prev: Uniquify,  Up: Buffer Convenience

19.7.2 素早いミニバッファーの選択
---------------------------------

グローバルなマイナーモードのIcompleteモードは、ミニバッファーで利用可能
な補完候補を素早く選択する便利な方法を提供します。これが有効な場合、ミニ
バッファーでタイプすることにより、すでにタイプした文字にマッチする、利用
可能な候補を連続で表示します。

   ‘C-j’とタイプすることにより、常にリストの最初の補完候補を選択できます
。つまり特定の補完候補を選択するには、まずその候補をリストの先頭にするこ
とです。これを行うには2つの方法があります。1つ目の方法は、補完候補の名前
をさらにタイプすることにより、違う候補が含まれないように、希望する補完候
補にリストを絞りこむ方法です。もう1つは‘C-.’および‘C-,’を使って、望む候
補が先頭にくるまでリストをローテートする方法です。

   ‘M-<TAB>’は‘C-j’のようにリストの最初の補完候補を選択しますが、ミニバ
ッファーを抜けないので、さらに編集を続けることができます。これはファイル
名の入力で通常使われます。‘M-<TAB>’により、いくつかのディレクトリー階層
をたどることができます。

   Icompleteモードを有効にするには、‘M-x icomplete-mode’とタイプするか、
変数‘icomplete-mode’を‘t’にカスタマイズします(*note Easy
Customization::を参照してください)。


File: emacs-ja.info,  Node: Buffer Menus,  Prev: Icomplete,  Up: Buffer Convenience

19.7.3 バッファーメニューのカスタマイズ
---------------------------------------

‘M-x bs-show’
     ‘M-x list-buffers’と同様にバッファーリストを作成しますが、カスタマ
     イズが可能です。
‘M-x ibuffer’
     バッファーのリストを作成して、Dired様式でそれらを操作できるようにし
     ます。

   ‘M-x bs-show’は、通常‘C-x C-b’で表示されるのと同じようなバッファーリ
ストを表示しますが、これはより柔軟な方法で表示をカスタマイズできます。た
とえば、表示すべきバッファー属性のリスト、バッファー名の列幅の最小と最大
、決して表示されないバッファーや常に表示するバッファー名にたいする正規表
現を指定することができます。通常のバッファーリストよりこちらのほうが好ま
しい場合、このコマンドを‘C-x C-b’にバインドできます。このバッファーリス
トをカスタマイズするには、Customグループの‘bs’(*note Easy
Customization::を参照)を使用するか、‘bs-customize’を呼び出してください。

   MSBグローバルマイナーモード(“MSB”は“mouse select buffer”が由来)は、カ
スタマイズ可能なマウスによる別のBuffer Menuを、好みに応じて提供します。
これは通常‘C-Down-mouse-1’、または‘C-<F10>’にバインドされている
‘mouse-buffer-menu’と、そのコマンドを置き換えます。メニューはCustomグル
ープ‘msb’でカスタマイズが可能です。

   IBufferとは、バッファーのリストを閲覧して、フィルタリング、マーキング
、さまざまな方法によるソート、およびバッファーにたいする処理を含む、
Dired(*note Dired::を参照)に似た操作をバッファーに行うメジャーモードです
。


File: emacs-ja.info,  Node: Windows,  Next: Frames,  Prev: Buffers,  Up: Top

20 複数ウィンドウ
*****************

Emacsのフレームは、2つ以上のウィンドウに分割できます。複数のウィンドウで
異なるバッファーを表示したり、1つのバッファーの異なる部分を表示できます
。複数フレームは自ずと複数ウィンドウになります。なぜならフレームには、そ
れぞれウィンドウがあるからです。ウィンドウは1つのフレームだけに属します
。

* Menu:

* Basic Window::             Emacsウィンドウの紹介。
* Split Window::             既存のウィンドウを分割して新しいウィンドウを作る。
* Other Window::             他のウィンドウへの移動と操作。
* Pop Up Window::            他のウィンドウのファイルまたはバッファーの検索。
* Change Window::            ウィンドウの削除とサイズ変更。
* Displaying Buffers::       Emacsがバッファーを表示するためにウィンドウを選択する方法。
* Window Convenience::       ウィンドウ処理の便利な機能。


File: emacs-ja.info,  Node: Basic Window,  Next: Split Window,  Up: Windows

20.1 Emacsウィンドウの概念
==========================

Emacsの各ウィンドウには、常に1つのEmacsバッファーが表示されます。1つのバ
ッファーは、複数のウィンドウに表示される場合があります。この場合、バッフ
ァーのテキストへの任意の変更は、それが表示されているすべてのウィンドウで
表示されます。しかし各ウィンドウは独自にポイント値をもっているので、ウィ
ンドウごとにバッファーの異なる部分を表示できます。

   常に1つのEmacsウィンドウが、“選択されたウィンドウ”となります。このウ
ィンドウに表示されているバッファーが、カレントバッファーとなります。グラ
フィカルなディスプレーでは、選択されたウィンドウのカーソルは、点滅する塗
りつぶされたカーソルとなり、選択されていないウィンドウでは、中抜きボック
スのカーソルになります。テキスト端末では、カーソルは選択されたウィンドウ
だけで描画されます。*note Cursor Display::を参照してください。

   ポイントを移動するコマンドは、選択されたEmacsウィンドウのポイント値だ
けに影響します。他のEmacsウィンドウのポイント値は、たとえ同じバッファー
を表示していたとしても変更されません。これと同じことは、‘C-x b’のような
バッファー切り替えコマンドについても言えます。これらは他のウィンドウには
影響を与えません。しかし‘C-x 4 b’のような、別のウィンドウを選択して、バ
ッファーを切り替えるコマンドもあります。(たとえば)‘C-h f’
(‘describe-function’)や‘C-x C-b’ (‘list-buffers’)を含む、ウィンドウで情
報を表示するコマンドは、選択されたウィンドウに影響を与えることなく、選択
されていないウィンドウのバッファーを切り替えます。

   複数ウィンドウで同じバッファーを表示しているとき、これらは異なるリー
ジョンを持ちます。なぜなら、それらは異なるポイント値を持つことができるか
らです。しかしバッファーごとにマーク位置は1つだけなので、これらは同じマ
ーク位置をもちます。

   それぞれのウィンドウには、独自のモードラインがあり、それにはバッファ
ー名、変更状態、そのウィンドウに表示されているバッファーのメジャーモード
とマイナーモードが表示されます。選択されたウィンドウのモードラインは、異
なる色で表示されます。詳細については、*note Mode Line::を参照してくださ
い。


File: emacs-ja.info,  Node: Split Window,  Next: Other Window,  Prev: Basic Window,  Up: Windows

20.2 ウィンドウの分割
=====================

‘C-x 2’
     選択されたウィンドウを上下に2分割します(‘split-window-below’)。
‘C-x 3’
     選択されたウィンドウを左右に2分割します(‘split-window-right’)。
‘C-mouse-2’
     ウィンドウのモードライン上では、ウィンドウを分割します。

   ‘C-x 2’ (‘split-window-below’)は、選択されたウィンドウを上下に2つのウ
ィンドウに分割します。分割した後は、上が選択されたウィンドウになり、新た
に分割されたウィンドウが下になります。2つのウィンドウは最初同じポイント
値をもち、(可能な限り)同じバッファー部分を表示します。必要ならポイントを
スクリーン上に残したまま、ウィンドウをスクロールできます。デフォルトでは
2つのウィンドウの高さは、元のウィンドウの高さの半分になります。正の数引
数は上のウィンドウの高さが何行分かを指定し、負の数引数は下のウィンドウが
何行分の高さかを指定します。

   変数‘split-window-keep-point’を‘nil’に変更すると、‘C-x 2’はスクリーン
に表示されるテキストができるだけ前と同じになるように、ウィンドウに表示さ
れるバッファー部分と、各ウィンドウのポイント位置を調整します。さらにポイ
ントが元のウィンドウの下半分にあったときは、上ではなく下のウィンドウが選
択されます。

   ‘C-x 3’ (‘split-window-right’)は、選択されたウィンドウを左右に2つのウ
ィンドウに分割します。左のウィンドウが選択されたウィンドウとなり、右のウ
ィンドウには同じバッファーの同じ部分が表示され、ポイント位置も同じです。
正の数引数は左のウィンドウの幅を列数で指定し、負の数引数は右のウィンドウ
の幅を数引数で指定します。

   ウィンドウを‘C-x 3’で分割すると、分割されたウィンドウの幅はフレーム全
体の幅より小さくなります。ウィンドウの幅が狭くなりすぎると、継続行が使わ
れたバッファーを読むことが困難になる場合があります(*note Continuation
Lines::を参照してください)。したがってウィンドウの幅が50列より狭くなった
とき、Emacsは自動的に行を切り詰めに切り替えます。この切り詰めは、変数
‘truncate-lines’の値に関係なく発生します(*note Line Truncation::を参照し
てください)。‘truncate-lines’のかわりに、この自動切り詰めを制御するのは
、変数‘truncate-partial-width-windows’です。この変数の値が正の整数(デフ
ォルトは50)の場合、それは自動的な行切り詰めが発生する前の、分割ウィンド
ウの最小のトータル幅(total width)を指定します。この値が‘nil’の場合、自動
的な行切り詰めは無効です。他の非‘nil’値では、分割されたウィンドウの幅に
関係なく、Emacsは行を切り詰めます。ウィンドウのトータル幅(total width)と
は、‘window-total-width’ (*note (elisp)Window Sizes::を参照してください
)で報告される列単位の値で、これにはフリンジと、継続および切り詰めのため
のグリフ、マージン、スクロールバーが含まれます。

   テキスト端末では、左右に分割されたウィンドウを垂直に分割する分割線は
、‘vertical-border’フェイスで描画されます。

   ウィンドウのモードライン上で‘C-mouse-2’をクリックすると、クリックした
位置に垂直分割線を配してウィンドウを分割します。Emacsがコンパイルされた
方法に依存しますが、ウィンドウのスクロールバー上で‘C-mouse-2’をクリック
すると、クリックした位置に水平分割線を配してウィンドウを分割します(この
機能は、EmacsがGTK+のスクロールバーを使っているときは機能しません)。

   デフォルトでは、ウィンドウを分割したとき、Emacsは分割されたウィンドウ
のサイズをフレームのデフォルトフォントの整数倍にします。これによりスクリ
ーンが正確に2分割されない場合があります。変数‘window-resize-pixelwise’を
非‘nil’値にセットすると、Emacsは分割されたウィンドウのサイズを、同じピク
セル数にします(元のサイズが奇数のピクセル数の場合、1ピクセル増減されます
)。フレームのピクセル数がフレームの文字サイズ倍でない場合、このオプショ
ンが‘nil’でも、少なくとも1つのウィンドウがピクセル幅のサイズ変更をされる
ことに注意してください。


File: emacs-ja.info,  Node: Other Window,  Next: Pop Up Window,  Prev: Split Window,  Up: Windows

20.3 他のウィンドウの使用
=========================

‘C-x o’
     他のウィンドウを選択します(‘other-window’)。
‘C-M-v’
     次のウィンドウをスクロールします(‘scroll-other-window’)。
‘Mouse-1’
     ウィンドウのテキスト領域を‘mouse-1’でクリックすると、そのウィンドウ
     を選択してクリックした位置にポイントを移動します。モードラインをク
     リックすると、ポイントを移動せずにそのウィンドウを選択します。

   キーボードで‘C-x o’ (‘other-window’)をタイプして、ウィンドウを切り替
えることができます。‘o’は“other”のoで、0(ゼロ)ではありません。2つ以上の
ウィンドウがある時、このコマンドはすべてのウィンドウを順繰りに選択します
(一般的に上からした、左から右)。一番右または一番下のウィンドウの後は、左
上のウィンドウに戻ります。数引数は上記の順番で何番目のウィンドウに移動す
るかを意味します。負の引数は逆向きで同じことを行います。ミニバッファーが
アクティブのとき、ミニバッファーウィンドウはこの順番では最後のウィンドウ
になります。ミニバッファーのウィンドウから他のウィンドウに切り替えて、後
からミニバッファーに戻って引数の入力を終了させることができます。*note
Minibuffer Edit::を参照してください。

   通常のスクロールコマンド(*note Display::を参照してください)は、選択さ
れたウィンドウだけに適用されますが、次のウィンドウをスクロールするコマン
ドが1つあります。‘C-M-v’ (‘scroll-other-window’)は、‘C-x o’が選択するウ
ィンドウをスクロールします(このコマンドは‘C-v’のように正または負の引数を
とります。ミニバッファーでの‘C-M-v’は、ミニバッファーに関連付けられたヘ
ルプウィンドウがあれば、標準的な次のウィンドウではなくヘルプウィンドウを
スクロールします。*note Minibuffer Edit::を参照してください)。

   ‘mouse-autoselect-window’を非‘nil’値にセットしている場合、マウスが選
択されたウィンドウ以外のウィンドウに移動すると、そのウィンドウが選択され
ます。この機能はデフォルトでオフです。


File: emacs-ja.info,  Node: Pop Up Window,  Next: Change Window,  Prev: Other Window,  Up: Windows

20.4 他のウィンドウでの表示
===========================

‘C-x 4’は、異なるウィンドウ(他の既存のウィンドウや、選択されたウィンドウ
を分割することにより新たに作成されたウィンドウ)のバッファーに切り替える
、さまざまなコマンドのプレフィクスキーです。Emacsがウィンドウを選択また
は作成する方法については、*note Window Choice::を参照してください。

‘C-x 4 b BUFNAME <RET>’
     他のウィンドウのバッファーBUFNAMEを選択します
     (‘switch-to-buffer-other-window’)。*note Select Buffer::を参照して
     ください。

‘C-x 4 C-o BUFNAME <RET>’
     バッファーBUFNAMEを選択せずに、別のウィンドウに表示します
     (‘display-buffer’)。ウィンドウが選択される方法についての詳細は、
     *note Displaying Buffers::を参照してください。

‘C-x 4 f FILENAME <RET>’
     ファイルFILENAMEをvisitして、他のウィンドウでバッファーを選択します
     (‘find-file-other-window’).  *note Visiting::を参照してください。

‘C-x 4 d DIRECTORY <RET>’
     DIRECTORYのDiredバッファーを、別のウィンドウで選択します
     (‘dired-other-window’)。*note Dired::を参照してください。

‘C-x 4 m’
     ‘C-x m’ (*note Sending Mail::を参照してください)と同様に、メールメ
     ッセージの編集を開始しますが、別のウィンドウで行います
     (‘compose-mail-other-window’)。

‘C-x 4 .’
     ‘M-.’ (*note Xref::を参照してください)と同様に、識別子の定義を検索
     しますが、別のウィンドウで行います
     (‘xref-find-definitions-other-window’)。
‘C-x 4 r FILENAME <RET>’
     ファイルFILENAMEを読み取り専用でvisitして、別のウィンドウでバッファ
     ーを選択します(‘find-file-read-only-other-window’)。*note
     Visiting::を参照してください。


File: emacs-ja.info,  Node: Change Window,  Next: Displaying Buffers,  Prev: Pop Up Window,  Up: Windows

20.5 ウィンドウの削除とリサイズ
===============================

‘C-x 0’
     選択されたウィンドウを削除します(‘delete-window’)。
‘C-x 1’
     フレームから選択されたウィンドウ以外のすべてのウィンドウを削除しま
     す(‘delete-other-windows’)。
‘C-x 4 0’
     選択されていたウィンドウを削除して、それに表示されていたバッファー
     をkillします(‘kill-buffer-and-window’)。このキーシーケンスの最後の
     文字はゼロです。
‘C-x ^’
     選択されたウィンドウの高さを増やします(‘enlarge-window’)。
‘C-x }’
     選択されたウィンドウの幅を増やします
     (‘enlarge-window-horizontally’)。
‘C-x {’
     選択されたウィンドウの幅を減らします
     (‘shrink-window-horizontally’)。
‘C-x -’
     バッファーに多くの行数が必要ない場合、そのウィンドウを縮小します
     (‘shrink-window-if-larger-than-buffer’)。
‘C-x +’
     すべてのウィンドウの高さを同じにします(‘balance-windows’)。

   選択されたウィンドウを削除するには、‘C-x 0’ (‘delete-window’)とタイプ
します(これはゼロです)。一度ウィンドウが削除されると、そのウィンドウが占
めていたスペースは隣接したウィンドウに与えられます(しかしミニバッファー
の場合、それがアクティブな場合でも適用されません)。ウィンドウの削除は、
ウィンドウを表示用に使っていたバッファーに影響を与えません。そのバッファ
ーは存在し続け、‘C-x b’で切り替えることができます。

   ‘C-x 4 0’ (‘kill-buffer-and-window’)は、コマンド‘C-x 0’より強力なコマ
ンドです。これはカレントバッファーをkillしてから、選択されたウィンドウを
削除します。

   ‘C-x 1’ (‘delete-other-windows’)は、選択されたウィンドウ_以外_のすべ
てのウィンドウを削除します。選択されたウィンドウはフレーム全体に拡張され
ます(このコマンドは、ミニバッファーのウィンドウがアクティブのとき使うこ
とができません。これを試みるとエラーがシグナルされます)。

   コマンド‘C-x ^’ (‘enlarge-window’)は、フレームの高さを変えずに垂直方
向に隣接するウィンドウのスペースを縮小して、選択されたウィンドウの高さを
増やします。正の数引数を与えると、このコマンドは指定した行数分ウィンドウ
の高さを増やします。負の数引数を与えると、指定した行数分ウィンドウの高さ
を増やします。垂直方向に隣接するウィンドウが存在しない場合(たとえばウィ
ンドウの高さがフレーム全体の高さと同じとき)、エラーをシグナルします。こ
のコマンドは変数‘window-min-height’(デフォルトは4)で指定された、最小行数
よりウィンドウの高さを縮小しようとしても、エラーをシグナルします。

   同様に‘C-x }’ (‘enlarge-window-horizontally’)は、選択されたウィンドウ
の幅を増やし、‘C-x {’ (‘shrink-window-horizontally’)は幅を減らします。こ
れらのコマンドは、変数‘window-min-width’(デフォルトは10)で指定された最小
列数よりウィンドウの幅を縮小すると、エラーをシグナルします。

   モードライン(*note Mode Line Mouse::を参照してください)、またはウィン
ドウ分割線(window dividers。*note Window Dividers::を参照してください)を
マウスでクリックすることにより、ウィンドウの高さの変更およびウィンドウの
分割や削除を行なう、別の方法を提供します。

   ‘C-x -’ (‘shrink-window-if-larger-than-buffer’)は、バッファー全体を表
示するのに必要な高さより選択されたウィンドウの高さが大きいときは、選択さ
れたウィンドウの高さを減らします。余った行数はフレームの他のウィンドウに
与えられます。

   ‘C-x +’ (‘balance-windows’)を使って、選択されたフレームのすべてのウィ
ンドウの高さを均等にすることもできます。


File: emacs-ja.info,  Node: Displaying Buffers,  Next: Window Convenience,  Prev: Change Window,  Up: Windows

20.6 ウィンドウでのバッファーの表示
===================================

ユーザーのコマンドの結果として、任意のバッファーが表示またはポップアップ
されるのは、Emacsでは一般的な処理です。コマンドがこれを行うには、いくつ
かの異なる方法があります。

   ‘C-x C-f’ (‘find-file’)のような多くのコマンドは、選択されたウィンドウ
を“乗っ取って”バッファーを表示します。これらのコマンドは通常、
‘switch-to-buffer’を内部的に呼び出すことにより機能します(*note Select
Buffer::を参照してください)。

   選択されたウィンドウを乗っ取らずに、たとえばウィンドウを分割して新し
いウィドウを作り、そこにバッファーを表示するといったような、利口な表示を
試みるコマンドがいくつかあります。さまざまなヘルプコマンド(*note
Help::)を含む、そのようなコマンドは内部的に‘display-buffer’を呼び出すこ
とにより機能します。詳細は、*note Window Choice::を参照してください

   他のコマンドは‘display-buffer’と同じことを行いますが、それに加えてバ
ッファーの編集を開始できるように、表示されたウィンドウを選択します。コマ
ンド‘C-x `’ (‘next-error’)が1つの例です(*note Compilation Mode::を参照し
てください)。そのようなコマンドは、内部的に関数‘pop-to-buffer’を呼び出す
ことにより機能します。*note Switching to a Buffer in a Window:
(elisp)Switching Buffers.を参照してください。

   名前が‘-other-window’で終わるコマンドは、‘display-buffer’と同じように
振る舞います。例外はそれらが決して選択されたウィンドウに表示しない点です
。これらのコマンドのいくつかは、プレフィクスキー‘C-x 4’にバインドされて
います(*note Pop Up Window::を参照してください)。

   名前が‘-other-frame’で終わるコマンドは、‘display-buffer’と同じように
振る舞います。例外は、i)選択されたウィンドウに決して表示しない、ii)ウィ
ンドウを分割してバッファーを表示するのではなく新しいフレームを作成して表
示する(あたかも変数‘pop-up-frames’が‘t’されているかのように)、という2点
です(*note Window Choice::を参照してください)。これらのコマンドのいくつ
かは、プレフィクスキー‘C-x 5’にバインドされています。

* Menu:

* Window Choice::            ‘display-buffer’が機能する方法。
* Temporary Displays::       編集不可バッファーの表示


File: emacs-ja.info,  Node: Window Choice,  Next: Temporary Displays,  Up: Displaying Buffers

20.6.1 ‘display-buffer’が機能する方法
-------------------------------------

‘display-buffer’コマンド(およびこのコマンドを内部的に呼び出すコマンド)は
、以下で与えられたステップに従って、表示するウィンドウを選択します。この
ステップの順番を変更する方法については、*note Choosing a Window for
Display: (elisp)Choosing Window.を参照してください。

   • 最初に、他のバッファーを考慮せずに、そのバッファーが選択されたウィ
     ンドウに表示されるべきかをチェックします。これを行うようEmacsに指示
     するには、望むバッファー名をリスト‘same-window-buffer-names’に加え
     るか、リスト‘same-window-regexps’にバッファー名にマッチする正規表現
     を追加します。デフォルトではこれらの変数は‘nil’なので、このステップ
     はスキップされます。

   • 上記以外の場合、バッファーがすでに既存のウィンドウに表示されている
     ときは、そのウィンドウを再利用します。通常は選択されたフレームのウ
     ィンドウだけが考慮されますが、変数‘pop-up-frames’を‘t’に変更してい
     る場合(以下参照)、他のフレームのウィンドウも再利用可能です、

   • 上記以外の場合、オプションで新しいフレームを作成して、バッファーを
     そこに表示します。デフォルトではこのステップはスキップされます。こ
     れを有効にするには変数‘pop-up-frames’を非‘nil’値に変更します。特別
     な値‘graphic-only’は、グラフィカルなディスプレーだけで、これを行う
     ことを意味します。

   • 上記以外の場合、選択されたフレームのウィンドウを分割することにより
     、新しいウィンドウを作成して、バッファーを新しく作成したウィンドウ
     に表示しようと試みます。

     分割は垂直または水平に行われる可能性があり、それは変数
     ‘split-height-threshold’および‘split-width-threshold’に依存します。
     これらの変数には整数値を指定します。‘split-height-threshold’が選択
     されたウィンドウの高さより小さい場合、分割により下が新しいウィンド
     ウになります。上記以外の場合、‘split-width-threshold’が選択されたウ
     ィンドウの幅より小さい場合、分割により右が新しいウィンドウになりま
     す。どちらの条件も適用できなかったとき、Emacsは分割により下を新しい
     ウィンドウにしようと試みますが、それは選択されたウィンドウが以前に
     分割されていなかった場合に限られます(過剰な分割を避けるため)。

   • 上記以外の場合、そのウィンドウに前に表示されていたバッファーを表示
     します。通常は選択されたフレームのウィンドウだけが考慮されますが、
     変数‘pop-up-frames’が非‘nil’の場合、他のフレームのウィンドウかもし
     れません。

   • 上記以外の場合、選択されたフレームの既存のウィンドウのバッファーを
     表示します。

   • 何らかの理由により上記すべてが失敗した場合、新しいフレームを作成し
     て、そこにバッファーを表示します。

   ‘display-buffer’の振る舞いをカスタマイズするための、より上級かつ柔軟
な方法は、次のセクションで言及されているオプション
‘display-buffer-alist’を使用する方法です。


File: emacs-ja.info,  Node: Temporary Displays,  Prev: Window Choice,  Up: Displaying Buffers

20.6.2 編集不可バッファーの表示
-------------------------------

ウィンドウに表示されるバッファーの中には、編集のためではなく閲覧するため
のものがあります。Helpコマンド(*note Help::)は通常、この目的のために
‘*Help*’と呼ばれるバッファーを使用し、ミニバッファーの補完(*note
Completion::)は別の‘*Completions*’と呼ばれるバッファーを使用します。この
ようなバッファーは通常、短時間しか表示されません。

   Emacsは通常、このような一時的に表示されるウィンドウを、上述した
‘display-buffer’を通じて表示します。一方、‘*Completions*’バッファーは通
常、そのフレームにいくつウィンドウが表示されているかに関わらず、選択され
たフレームの最下のウィンドウに表示されます。

   一時的なバッファーを他のやり方でEmacsに表示させたい場合、わたしたちは
変数‘display-buffer-alist’　(*note Choosing a Window for Display:
(elisp)Choosing Window.を参照してください)のカスタマイズを推奨します。た
とえば、前のセクションで説明したようにウィンドウを分割することにより
‘*Completions*’を表示するには、初期化ファイル(*note Init File::を参照し
てください)で以下のフォームを使用します:

     (customize-set-variable
      'display-buffer-alist
      '(("\\*Completions\\*" display-buffer-pop-up-window)))

   Emacsは通常、バッファーの内容のすべてを表示するのに必要な大きさのウィ
ンドウを作成するという点において、‘*Completions*’バッファーは特別です。
たとえば‘*Help*’バッファーなど、他の一時表示でこのようなウィンドウのリサ
イズを行なうには、マイナーモード(*note Minor Modes::を参照してください
)の‘temp-buffer-resize-mode’ (*note Temporary Displays: (elisp)Temporary
Displays.を参照してください)に切り替えます。

   ‘temp-buffer-resize-mode’でリサイズされるウィンドウの最大サイズは、オ
プション‘temp-buffer-max-height’と‘temp-buffer-max-width’ (*note
Temporary Displays: (elisp)Temporary Displays.)で制御できます。最大サイ
ズは、ウィンドウが含まれるフレームのサイズを超えることはできません。


File: emacs-ja.info,  Node: Window Convenience,  Prev: Displaying Buffers,  Up: Windows

20.7 ウィンドウ処理のための便利な機能
=====================================

Winnerモードは、ウィンドウの設定変更(たとえばフレームのウィンドウがどの
ように分割されたか)を記録するグローバルマイナーモードなので、それらを
undoできます。Winnerモードは‘M-x winner-mode’、または変数‘winner-mode’を
カスタマイズすることにより、切り替えることができます。このモードが有効な
場合、‘C-c left’ (‘winner-undo’)は、左のウィンドウの設定変更をundoします
。undoしてから気が変わった場合、‘C-c right’ (‘M-x winner-redo’)を使って
、undoした変更を再実行することができます。

   Followモード(‘M-x follow-mode’)は、複数のウィンドウの同じバッファーを
同期するので、バッファーの隣接した部分が常に表示されます。*note Follow
Mode::を参照してください。

   Windmoveパッケージは、フレーム内の隣接したウィンドウ間を直接移動する
コマンドを定義します。rightの部分をleft、up、downに置き換えると、対応す
る方向の隣接するウィンドウを選択します。‘M-x
windmove-default-keybindings’は、これらのコマンドを‘S-right’などにバイン
ドします。これにより、これらのキーを使ったシフト選択が無効になります
(*note Shift Selection::を参照してください)。

   コマンド‘M-x compare-windows’は、異なるウィンドウに表示されたテキスト
を比較します。*note Comparing Files::を参照してください。

   Scroll Allモード(‘M-x scroll-all-mode’)は、スクロールおよびポイント移
動コマンドが、表示されているすべてのウィンドウに適用されるグローバルマイ
ナーモードです。


File: emacs-ja.info,  Node: Frames,  Next: International,  Prev: Windows,  Up: Top

21 フレームとグラフィカルなディスプレー
***************************************

Emacsがグラフィカルなディスプレー(たとえばXウィンドウシステム)で開始され
たときは、システムレベルのグラフィカルな表示領域(display region)を占有し
ます。このマニュアルではこれを“フレーム”と呼び、“ウィンドウ”という言葉は
フレームでバッファーを表示する部分のために使います。フレームには最初1つ
のウィンドウが含まれていますが、これを複数のウィンドウに分割することがで
きます。フレームには通常、メニューバー、ツールバー、エコーエリアも含まれ
ます。

   追加のフレームを作ることもできます(*note Creating Frames::を参照して
ください)。同じEmacsセッションで作られたすべてのフレームは、背後にあるバ
ッファーや、その他のデータにアクセスします。たとえば１つ以上のフレームで
表示されているバッファーは、あるフレームに表示されているものに変更を加え
ると、即座に他のフレームに反映されます。

   ‘C-x C-c’とタイプすると、現在表示されているすべてのフレームを閉じて、
他に表示されているフレームがなければ、Emacsセッションを終了します(*note
Exiting::を参照してください)。選択されたフレームだけを閉じるには、‘C-x 5
0’(これは‘o’ではなくゼロです)とタイプします。

   このセクションでは、グラフィカルなディスプレーに特有の機能(特にマウス
コマンド)と、複数フレームを管理する機能について説明します。テキスト端末
では、これらの機能の多くは利用できません。しかしテキスト端末で複数のフレ
ームを作ることは可能です。そのようなフレームは1度に１つだけ表示され、テ
キスト画面全体を占有します(*note Non-Window Terminals::を参照してくださ
い)。テキスト端末の中には、マウスを使うことが可能なものがいくつかありま
す(GNUおよびUnix systemsでこれを行うには、*note Text-Only Mouse::を、
MS-DOSでこれを使うには、 *note MS-DOS Mouse::を参照してください )。メニ
ューはすべてのテキスト端末でサポートされています。

* Menu:

* Mouse Commands::           マウスによる移動、切り取り、貼り付け。
* Word and Line Mouse::      単語または行全体を選択するマウスコマンド。
* Mouse References::         リストからアイテムを選択するのにマウスを使う。
* Menu Mouse Clicks::        メニューを表示させるマウスクリック。
* Mode Line Mouse::          モードライン上でのマウスクリック。
* Creating Frames::          さまざまな内容とともに追加のEmacsフレームを作成する。
* Frame Commands::           フレームのアイコン化とフレームの切り替え。
* Fonts::                    フレームフォントの変更。
* Speedbar::                 スピードバーフレームの作り方と使い方。
* Multiple Displays::        1つのEmacsインスタンスが複数ディスプレーと通信する方法。
* Frame Parameters::         フレームのカラーや他のモードの変更。
* Scroll Bars::              スクロールバーの有効と無効、および使い方。
* Window Dividers::          マウスでドラッグできるウィンドウセパレーター。
* Drag and Drop::            ファイルを開いたりテキストを挿入するのにドラッグアンドドロップを使う。
* Menu Bars::                メニューバーの有効と無効。
* Tool Bars::                ツールバーの有効と無効。
* Dialog Boxes::             ダイアログボックス使用の制御。
* Tooltips::                 マウスの現在位置の情報の表示。
* Mouse Avoidance::          マウスポインターがテキストを隠すのを防ぐ。
* Non-Window Terminals::     フレームを1つだけ表示する端末での複数フレーム。
* Text-Only Mouse::          テキスト端末でのマウスの使用。


File: emacs-ja.info,  Node: Mouse Commands,  Next: Word and Line Mouse,  Up: Frames

21.1 編集のためのマウスコマンド
===============================

‘mouse-1’
     クリックした場所にポイントを移動します(‘mouse-set-point’)。

‘Drag-mouse-1’
     ドラッグにより選択されたテキストを取り囲むリージョンをアクティブ化
     して、そのテキストをプライマリー選択に置きます
     (‘mouse-set-region’)。

‘mouse-2’
     クリックした場所にポイントを移動して、そこにプライマリー選択の内容
     を挿入します(‘mouse-yank-primary’)。

‘mouse-3’
     リージョンがアクティブなときは、近くにあるリージョンの終端をクリッ
     クした位置に移動します。アクティブでないときは現在のポイントにマー
     クをセットして、ポイントをクリックした位置に移動します。結果となる
     リージョンはkillリングに保存されます。2回目のクリックでリージョンを
     killします(‘mouse-save-then-kill’)。

   もっとも基本的なマウスコマンドは‘mouse-set-point’で、これはウィンドウ
のテキスト領域でマウスの左ボタン、‘mouse-1’をクリックすることにより呼び
出されます。これはポイントをクリックされた位置に移動します。そのウィンド
ウが選択されたウィンドウでなかったとき、そのウィンドウが選択されたウィン
ドウになります。‘mouse-1’をダブルクリックして、リージョンをアクティブに
することもできます(*note Word and Line Mouse::を参照)。

   クリックしたフレームが選択されたフレームでなかった場合は通常、クリッ
クされたフレームが選択されたフレームになるのに加えて、ウィンドウも選択さ
れてカーソルがセットされます。Xウィンドウシステムでは、変数
‘x-mouse-click-focus-ignore-position’を‘t’にセットすることにより、これを
変更できます。この場合、選択されていないフレームへの最初のクリックではフ
レームだけを選択し、他は変更しません。次にクリックするとそのウィンドウを
選択してカーソルをその位置にセットします。

   ‘mouse-1’を押してテキストの周辺をドラッグすると、最初にマウスボタンを
押した位置にマークが置かれ、ボタンを離した位置にポイントがセットされ
(*note Mark::を参照してください)、その領域がアクティブになります
(‘mouse-set-region’)。それに加えてリージョンのテキストがプライマリー選択
となります(*note Primary Selection::を参照してください)。

   変数‘mouse-drag-copy-region’を非‘nil’値に変更すると、テキストの周囲を
ドラッグすることにより、そのテキストをkillリングに追加します。デフォルト
は‘nil’です。

   ドラッグしている途中でマウスがウィンドウの上または下を超えた場合、マ
ウスがウィンドウ内に戻るまで、ウィンドウが一定の割合でスクロールします。
この方法により、スクリーン全体に収まらないリージョンを選択できます。1度
に何行スクロールするかは、マウスがウィンドウの縁からどれだけ離れたかに依
存します。変数‘mouse-scroll-min-lines’は、最小ステップサイズを指定します
。

   マウスの真ん中のボタン、‘mouse-2’をクリックすると、クリックした位置に
ポイントを移動して、プライマリー選択の内容を挿入します
(‘mouse-yank-primary’)。*note Primary Selection::を参照してください。こ
の振る舞いは、他のXアプリケーションと一貫性があります。かわりに
‘mouse-2’を、‘mouse-yank-at-click’にバインドできます。これはクリックした
位置にyankするコマンドです。

   変数‘mouse-yank-at-point’を非‘nil’値に変更すると、‘mouse-2’はポイント
を移動しません。これはどこをクリックしたか、フレームのどのウィンドウをク
リックしたかに関係なく、ポイントのある位置にテキストを挿入します。この変
数は‘mouse-yank-primary’と‘mouse-yank-at-click’の両方に影響します。

   マウスの右ボタン、‘mouse-3’をクリックすると、コマンド
‘mouse-save-then-kill’が実行されます。これはどこをクリックしたかと、リー
ジョンの状態に依存していくつかのアクションを処理します。

   • アクティブなリージョンがないときは、‘mouse-3’のクリックにより、ポイ
     ントがあった位置にマークをセットし、クリックした位置にポイントを置
     いて、リージョンをアクティブにします。

   • リージョンがアクティブなときは、‘mouse-3’のクリックにより、クリック
     した位置に近いリージョンの終端を、クリックした位置に調整します。調
     整されたリージョンのテキストは、killリングにコピーされます。元のリ
     ージョンのテキストがすでにkillリングにある場合は、それを置き換えま
     す。

   • 元のリージョンが‘mouse-1’のダブルクリックまたはトリプルクリックで選
     択されたものである場合、リージョンは単語全体、または行全体にたいし
     て定義されているので(*note Word and Line Mouse::を参照してください
     )、‘mouse-3’によるリージョンの調整も単語全体または行全体を単位とし
     て行われます。

   • 同じ場所で連続して2回‘mouse-3’を使うことにより、すでに選択されてい
     るリージョンをkillできます。したがってマウスでテキストをkillする簡
     単な方法は、まずリージョンの始端を決めるため‘mouse-1’をクリックして
     、もう一方の終端で‘mouse-3’を2回クリックします。テキストを削除せず
     にkillリングにコピーするには、‘mouse-3’を1回だけクリックするか、テ
     キスト範囲をドラッグします。その後は適当な場所でyankしてコピーでき
     ます。

   ‘mouse-save-then-kill’コマンドは、変数‘mouse-drag-copy-region’の値に
もしたがいます(上記参照)。変数の値が非‘nil’のときは、コマンドがアクティ
ブなリージョンをセットまたは調整したとき、常にリージョンのテキストは
killリングにも追加されます。一番最近のkillリングのエントリーが同じ方法で
追加されたものである場合、新しいエントリーを作成せず、そのエントリーを置
き換えます。

   上記で説明した任意のマウスコマンドを使ってセットしたリージョンは、シ
フト選択以外のマウス移動コマンド、および通常のマークを非アクティブ化する
方法により、マークが非アクティブになります。*note Shift Selection::を参
照してください。

   スクロールに使うことができる“ホイール”があるマウスもいくつかあります
。Emacsはデフォルトで、マウスホイールによるウィンドウのスクロールを、ほ
とんどのグラフィカルなディスプレーでサポートします。この機能を切り替える
には、‘M-x mouse-wheel-mode’を使います。変数‘mouse-wheel-follow-mouse’お
よび‘mouse-wheel-scroll-amount’は、(どこでホイールによるスクロール操作が
行われたかによる)スクロール対象の選択方法と、バッファーがスクロールされ
る量を決定します。変数‘mouse-wheel-progressive-speed’は、スクロールの早
さがホイールを移動した早さにリンクするかを決定します。

   チルトホイール(横スクロール)つきのマウスの場合、Emacsは水平スクロール
もサポートします。この機能はデフォルトではオフで、変数
‘mouse-wheel-tilt-scroll’でオンになります。水平スクロールの方向を逆転し
たい場合は、変数‘mwheel-flip-direction’を非‘nil’値にカスタマイズしてくだ
さい。


File: emacs-ja.info,  Node: Word and Line Mouse,  Next: Mouse References,  Prev: Mouse Commands,  Up: Frames

21.2 単語と行にたいするマウスコマンド
=====================================

以下の‘mouse-1’の変種は、1度に単語全体または行全体を選択します。Emacsは
選択されたテキスト周辺のリージョンをアクティブにして、killリングにもコピ
ーされます。

‘Double-mouse-1’
     クリックした単語や文字周辺のテキストを選択します。

     シンボルの構文をもつ文字(C modeでのアンダースコアーなど)をダブルク
     リックすると、シンボルを取り囲むその文字を選択します。開きカッコ(ま
     たは閉じカッコ)の構文をもつ文字をダブルクリックすると、そのカッコで
     始まる(または終わる)グループを選択します。区切り文字の構文をもつ文
     字(Cのシングルクォーテーションやダブルクォーテーション)をダブルクリ
     ックすると、文字列定数を選択します(Emacsはその文字により開始するの
     か(または終了するのか)を、発見的な手法を使って見つけ出します)。

     カッコによるグループ化、または文字列の区切り文字の先頭をダブルクリ
     ックすると、そのリージョンの最後にポイントが移動します。新たな位置
     を表示するために必要なら、バッファーの表示を前方にスクロールします
     。カッコによるグループ化、または文字列の区切り文字の終端をダブルク
     リックしても、デフォルトではポイントはそのリージョンの終端に留まり
     、リージョンの先頭がウィンドウ上端より上にある場合は表示されません
     。必要ならバッファーの表示を後方にスクロールすてリージョンの先頭に
     移動するように変更するには、ユーザーオプション
     ‘mouse-select-region-move-to-beginning’を非‘nil’にセットしてくださ
     い。

‘Double-Drag-mouse-1’
     単語全体を単位として、ドラッグした箇所のテキストを選択します。

‘Triple-mouse-1’
     クリックした行を選択します。

‘Triple-Drag-mouse-1’
     行全体を単位として、ドラッグした箇所のテキストを選択します。


File: emacs-ja.info,  Node: Mouse References,  Next: Menu Mouse Clicks,  Prev: Word and Line Mouse,  Up: Frames

21.3 マウスで参照をフォローする
===============================

Emacsのバッファーには“ボタン”や、アクティブ化(例えばクリック)したとき何
らかのアクション(例えば参照をフォローする)を行う、“ハイパーリンク”を含む
ものがあります。ボタンのテキストは通常、アンダーラインが引かれていたり、
周囲にボックスが描かれて、視覚的にハイライトされています。ボタンの上にマ
ウスを移動すると、マウスカーソルの形状が変化して、ボタンがライトアップさ
れます。変数‘mouse-highlight’を‘nil’に変更すると、Emacsはこのハイライト
機能を無効にします。

   ボタンをアクティブにするには、ポイントをそこに移動して<RET>をタイプす
るか、‘mouse-1’または‘mouse-2’でボタンをクリックします。たとえばDiredバ
ッファーでは、ファイル名がボタンです。これをアクティブにすることにより、
Emacsはそのファイルをvisitします(*note Dired::を参照してください)。
‘*Compilation*’バッファーでは、各エラーメッセージがボタンです。これをア
クティブにすることにより、そのエラーにたいするソースコードをvisitします
(*note Compilation::を参照してください)。

   ボタンを‘mouse-1’でクリックすると、ボタンがアクティブになりますが、マ
ウスボタンを押してから離すまで一定時間(厳密に言うと450ミリ秒以上)が経過
すると、Emacsはボタンをアクティブにせず、ポイントをクリックした場所に移
動します。この方法によりボタンをアクティブにせずにポイントを移動するのに
、マウスを使用できます。マウスをボタンの上にドラッグすると、通常どおりリ
ージョンをセットして、ボタンはアクティブにしません。

   ボタンにたいして‘mouse-1’がどのように適用されるかは、
‘mouse-1-click-follows-link’をカスタマイズすることにより変更できます。変
数の値が正の整数の場合、それはボタンのアクティブ化を取り消すのに、何ミリ
秒マウスボタンを押しつづける必要があるかを指定します。前のパラグラフで説
明したように、デフォルトは450です。値が‘nil’の場合、‘mouse-1’は単にクリ
ックした場所にポイントを移動するだけで、ボタンをアクティブにしません。値
が‘double’の場合、シングルクリックでポイントのセット、ダブルクリックでボ
タンをアクティブにします。

   選択されていないウィンドウのボタンでも通常、‘mouse-1’でクリックすれば
ボタンがアクティブになります。変数
‘mouse-1-click-in-non-selected-windows’を‘nil’に変更した場合、選択されて
いないウィンドウのボタンを‘mouse-1’でクリックすると、クリックした位置に
ポイントを移動してウィンドウを選択しますが、ボタンはアクティブになりませ
ん。


File: emacs-ja.info,  Node: Menu Mouse Clicks,  Next: Mode Line Mouse,  Prev: Mouse References,  Up: Frames

21.4 メニューにたいするマウスクリック
=====================================

<Ctrl>および<SHIFT>で修飾されたマウスクリックにより、メニューが表示され
るものがいくつかあります。

‘C-mouse-1’
     このメニューはバッファーを選択するためのものです。

     MSB(“mouse select buffer”)グローバルマイナーモードは、このメニュー
     をスマートで、よりカスタマイズ可能なものにします。 *note Buffer
     Menus::を参照してください。

‘C-mouse-2’
     このメニューには、フェイスや他のテキストプロパティーをテストしたり
     、それらを設定するものが含まれます(後者は主にEnriched textを編集す
     るのに便利です。*note Enriched Text::を参照してください)。

‘C-mouse-3’
     このメニューは、モードに特有なメニューです。Menu-barモードがオンの
     場合、ほとんどのモードでは、このメニューに、そのモード特有なメニュ
     ーバーのメニューと同じアイテムを表示します。このボタンに異なるメニ
     ューを指定するモードもいくつかあります。Menu-barモードがオフの場合
     、このメニューにはモード特有のメニューだけでなく、本来メニューバー
     に含まれるべきすべてのアイテムが含まれるので、メニューバーを表示せ
     ずに、それらにアクセスすることができます。

‘S-mouse-1’
     このメニューはそのウィンドウのバッファーの、デフォルトのフェイスを
     変更するためのものです。*note Text Scale::を参照してください。

   グラフィカルなアプリケーションには、‘mouse-3’をモード特有なメニューに
使うものもいくつかあります。‘mouse-3’で‘mouse-save-then-kill’コマンドを
実行するかわりに、Emacsにこのようなメニューを表示させるには、以下の行を
initファイルに追加して‘mouse-3’をリバインドします(*note Init
Rebinding::を参照してください)。

     (global-set-key [mouse-3] 'mouse-popup-menubar-stuff)


File: emacs-ja.info,  Node: Mode Line Mouse,  Next: Creating Frames,  Prev: Menu Mouse Clicks,  Up: Frames

21.5 モードラインのマウスコマンド
=================================

ウィンドウのモードラインをマウスでクリックして、ウィンドウを選択したり操
作することができます。

   モードラインのいくつかの領域、たとえばバッファー名や、メジャーモード
およびマイナーモードは、独自のマウスバインディングをもっています。これら
の領域にマウスを移動すると、その領域がハイライトされ、特別なバインディン
グが表示されます(*note Tooltips::を参照してください)。このセクションのコ
マンドは、それらの領域には適用できません。

‘mouse-1’
     モードラインを‘mouse-1’でクリックすると、それが属するウィンドウを選
     択します。モードライン上で‘mouse-1’でドラッグすることにより、それを
     移動することができるので、ウィンドウの高さを変更することができます
     。マウスでの高さの変更により、ウィンドウが削除されることはありませ
     ん。ウィンドウの高さが定められた最小値より小さくなる場合は、拒絶さ
     れます。

‘mouse-2’
     モードラインを‘mouse-2’でクリックすると、そのウィンドウがフレーム全
     体に表示されます。

‘mouse-3’
     モードラインを‘mouse-3’でクリックすると、それが属するウィンドウを削
     除します。フレームにウィンドウが1つしかないときは、何もしません。

‘C-mouse-2’
     モードラインを‘C-mouse-2’でクリックすると、クリックした位置でウィン
     ドウを左右に分割します(*note Split Window::を参照してください)。

   さらに、左右に並んだモードラインの間にある分割線を、‘mouse-1’でクリッ
クしてドラッグすることにより、垂直の境界線を左右に移動できます。

   ウィンドウのサイズ変更は、‘window-resize-pixelwise’の値に影響されるこ
とに注意してください。詳細は*note Split Window::を参照してください。


File: emacs-ja.info,  Node: Creating Frames,  Next: Frame Commands,  Prev: Mode Line Mouse,  Up: Frames

21.6 フレームの作成
===================

プレフィクスキー‘C-x 5’は、‘C-x 4’に類似しています。‘C-x 4’コマンドが、
選択されたフレームの別ウィンドウにバッファーを表示するのにたいして、‘C-x
5’は異なるフレームを使います。可視またはアイコン化(“最小化”とも言われる
。*note (elisp)Visibility of Frames::を参照)されたフレームで、すでに要求
されたバッファーが表示されている場合、そのフレームを手前に表示して非アイ
コン化(“最小化解除”)されます。それ以外の場合は、新しいフレームが現在の表
示端末に作成されます。

   以下の‘C-x 5’コマンドは、選択するバッファーを検索したり作成する方法が
異なります。

‘C-x 5 2’
     新しいフレームを作成します(‘make-frame-command’)。
‘C-x 5 b BUFNAME <RET>’
     バッファーBUFNAMEを他のフレームで選択します。これは
     ‘switch-to-buffer-other-frame’を実行します。
‘C-x 5 f FILENAME <RET>’
     ファイルFILENAMEをvisitして、そのバッファーを他のフレームで選択しま
     す。これは‘find-file-other-frame’を実行します。*note Visiting::を参
     照してください。
‘C-x 5 d DIRECTORY <RET>’
     ディレクトリーDIRECTORYにたいするDiredバッファーを、他のフレームで
     選択します。これは‘dired-other-frame’を実行します。*note Dired::を
     参照してください。
‘C-x 5 m’
     他のフレームでメールメッセージの作成を開始します。これは
     ‘compose-mail-other-frame’を実行します。これは‘C-x m’の異なるフレー
     ム版です。*note Sending Mail::を参照してください。
‘C-x 5 .’
     他のフレームで識別子の定義を検索します。これは
     ‘xref-find-definitions-other-frame’を実行する、‘M-.’の複数フレーム
     版です。*note Xref::を参照してください。
‘C-x 5 r FILENAME <RET>’
     ファイルFILENAMEを読み取り専用でvisitして、そのバッファーを他のフレ
     ームで選択します。これは‘find-file-read-only-other-frame’を実行しま
     す。*note Visiting::を参照してください。

   “フレームパラメーター(frame parameters)”を指定することにより、新しく
作成されるフレームの外見と動作を制御できます。*note Frame Parameters::を
参照してください。


File: emacs-ja.info,  Node: Frame Commands,  Next: Fonts,  Prev: Creating Frames,  Up: Frames

21.7 フレームコマンド
=====================

以下のコマンドは、フレームを削除したり操作するために使われます:

‘C-x 5 0’
     選択されたフレームを削除します(‘delete-frame’)。1つしかフレームがな
     いときは、エラーをシグナルします。

‘C-z’
     選択されたEmacsフレームを最小化(またはアイコン化)します
     (‘suspend-frame’)。*note Exiting::を参照してください。

‘C-x 5 o’
     他のフレームを選択して手前に表示します。このコマンドを繰り返すと、
     端末のすべてのフレームを循環することができます。

‘C-x 5 1’
     現在の端末の、選択されたフレーム以外のすべてのフレームを削除します
     。

‘M-<F10>’
     カレントフレームの最大化を切り替えます。フレームが最大化されている
     ときはスクリーン全体に表示されます。

‘<F11>’
     カレントフレームのフルスクリーンモードを切り替えます(フルスクリーン
     と最大化の違いは、前者がウィンドウマネージャーの装飾を隠すことで、
     これによりEmacs自身のスクリーンスペースが若干増えます)。

   フレームを本当に最大化またはフルスクリーンにするためには、変数
‘frame-resize-pixelwise’を非‘nil’値にカスタマイズする必要があるウィンド
ウマネージャーもいくつかあります。この変数を非‘nil’値にセットすると、一
般的にフレームのサイズ変更を行や列の整数倍ではなく、ピクセル単位で行うこ
とができます。

   ‘C-x 5 0’ (‘delete-frame’)コマンドは、選択されたフレームを削除します
。しかしEmacsセッションとの対話能力が失われるのを防ぐため、Emacsセッショ
ンの最後のフレームの削除は拒絶します。Emacsがデーモンとして実行されてい
るとき(*note Emacs Server::を参照してください)は、普通の対話的なフレーム
がすべて削除された後も、常に仮想的なフレーム(virtual frame)が残ります。
この場合、‘C-x 5 0’は最後の対話的なフレームを削除できます。Emacsセッショ
ンに再接続するには、‘emacsclient’を使うことができます。

   ‘C-x 5 1’ (‘delete-other-frames’)コマンドは、現在の端末(端末にはグラ
フィカルなディスプレーとテキスト端末の両方が含まれます)の、カレントのフ
レーム以外のすべてのフレームを削除します。*note Non-Window Terminals::を
参照してください)。他のグラフィカルなディスプレー、またはテキスト端末で
開いたフレームをもっている場合、これらは削除されません。

   ‘C-x 5 o’ (‘other-frame’)コマンドは、現在の端末の次のフレームを選択し
ます。EmacsをXウィンドウシステム上のウィンドウマネージャーで使っていて、
どんなフレームだろうと、マウスカーソルが上にくるとそのフレームを選択(ま
たは“フォーカスを与える”)するようになっている場合、このコマンドが正常に
機能するために、変数‘focus-follows-mouse’を‘t’に変更する必要があります。
これは‘C-x 5 o’を呼び出し、マウスカーソルを選択されたフレームにワープさ
せます。


File: emacs-ja.info,  Node: Fonts,  Next: Speedbar,  Prev: Frame Commands,  Up: Frames

21.8 フォント
=============

デフォルトでは、Emacsはグラフィカルなディスプレーでテキストを表示するの
に、10ポイントのmonospaceフォントを使います。違うフォントを指定する異な
る方法がいくつかあります:

   • ‘Options’メニューの‘Set Default Font’をクリックします。これは既存の
     グラフィカルなフレームすべてのデフォルトを、選択したフォントにしま
     す。これを将来のセッションのために保存するには、‘Options’メニューの
     ‘Save Options’をクリックしてください。

   • 以下のように、‘font’パラメーターを指定するように、変数
     ‘default-frame-alist’を変更する行をinitファイルに追加します:

          (add-to-list 'default-frame-alist
                       '(font . "DejaVu Sans Mono-10"))

     これはこのinitファイルで再起動した後の、Emacsが作るすべてのグラフィ
     カルなフレームのデフォルトを、指定したフォントにします。

   • 以下のようにXリソースファイルに、Xリソースセッティング
     ‘emacs.font’を追加します:

          emacs.font: DejaVu Sans Mono-12

     Xリソースファイルが効果を表すには、Xを再起動するか‘xrdb’コマンドを
     使わなければなりません。*note Resources::を参照してください。Xリソ
     ースファイルでは、フォント名をクォートしないでください。

   • EmacsをGNOMEデスクトップで実行している場合、変数
     ‘font-use-system-font’を‘t’(デフォルトは‘nil’)にセットして、Emacsに
     デフォルトのシステムフォントを使うように指示できます。これが機能す
     るには、EmacsがGsetting(または古いGconf)のサポートつきでコンパイル
     されていなければなりません。

   • コマンドラインオプション‘-fn’(または‘--font’)を使います。*note Font
     X::を参照してください。

   現在使っているフォントをチェックするには、‘C-u C-x =’コマンドが有用で
す。これはポイント位置の文字の説明と、それを描画しているフォント名を表示
します。

   Xでは、フォント名を表現する異なる方法がいくつか存在します。1番目は
“Fontconfigパターン”を使う方法です。Fontconfigパターンは以下の形式をもち
ます:

     FONTNAME[-FONTSIZE][:NAME1=VALUES1][:NAME2=VALUES2]...

このフォーマットでは、大カッコ(brackets)の中の要素は省略可能です。
FONTNAMEは、‘Monospace’や‘DejaVu Sans Mono’のような、フォントの“ファミリ
ー名”です。FONTSIZEは、フォントの“ポイントサイズ”(1“プリンターポイント
”はおよそ1/72インチです)で、エントリー‘NAME=VALUES’は、フォントのslantや
weightなどのセッティングを指定します。VALUESには1つの値か、カンマで区切
られた値のリストを指定します。それらに加えていくつかのプロパティー値は、
ある種のプロパティー名だけで有効なものがあり、それらについては‘NAME=’部
分を省略できます。

   以下は、一般的なフォントプロパティーの一覧です:

‘slant’
     ‘italic’、‘oblique’、‘roman’のうちの、どれか1つです。

‘weight’
     ‘light’、‘medium’、‘demibold’、‘bold’、‘black’のうちの、どれか1つで
     す。

‘style’
     slantとweightを組み合わせた、特別なstyleを定義するフォントがいくつ
     かあります。たとえば‘Dejavu Sans’は、‘book’ styleを定義し、これは
     slantおよびweightプロパティーをオーバーライドします。

‘width’
     ‘condensed’、‘normal’、‘expanded’のうちの、どれか1つです。

‘spacing’
     ‘monospace’、‘proportional’、‘dual-width’、‘charcell’のうちの、どれ
     か1つです。

以下はFontconfigパターンの例です:

     Monospace
     Monospace-12
     Monospace-12:bold
     DejaVu Sans Mono:bold:italic
     Monospace-12:weight=bold:slant=italic

   Fontconfigパターンの、より詳細な説明は、Fontconfigのマニュアルを参照
してください。これはFontconfigとともに配布されており、
<https://fontconfig.org/fontconfig-user.html>からオンラインで利用可能で
す。

   フォントを指定する2番目の方法は、“GTKフォントパターン”を使う方法です
。これらは以下の構文を使います。

     FONTNAME [PROPERTIES] [FONTSIZE]

FONTNAMEはファミリー名、PROPERTIESはスペースで区切られたプロパティー値の
リストで、FONTSIZEはポイントサイズです。GTKフォントパターンで指定するプ
ロパティーは以下のようなものでしょう:

   • Slantプロパティー: ‘Italic’、‘Oblique’。省略したときはデフォルトの
     slant(roman)が暗に指定されます。
   • Weightプロパティー: ‘Bold’、‘Book’、‘Light’、‘Medium’、
     ‘Semi-bold’、‘Ultra-light’。省略したときは‘Medium’ weightが暗に指定
     されます。
   • Widthプロパティー: ‘Semi-Condensed’、‘Condensed’。省略したときはデ
     フォルトのwidthが使用されます。

以下にGTKフォントパターンの例をいくつか示します:

     Monospace 12
     Monospace Bold Italic 12

   フォントを指定する3番目の方法は、“XLFD”(“X Logical Font
Description”)を使う方法です。これはXでフォントを指定する際の伝統的な手法
です。以下のように、各XLFDは14の単語か数字をダッシュで区切ったものからな
ります:

     -misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1

XLFDでのワイルドカード文字(‘*’)は、任意の文字の並び(noneを含む)にマッチ
し、‘?’は任意の1文字にマッチします。しかしマッチングは実装依存で、長い名
前の中のダッシュにたいするワイルドカードのマッチが不正確なことがあります
。信頼できる結果を得るためには、14個すべてのダッシュを指定して、ワイルド
カードを1つのフィールドだけに使います。XLFDでは大文字小文字の違いは重要
ではありません。XLFDの構文は以下のとおりです:

     -MAKER-FAMILY-WEIGHT-SLANT-WIDTHTYPE-STYLE...
     ...-PIXELS-HEIGHT-HORIZ-VERT-SPACING-WIDTH-REGISTRY-ENCODING

エントリーは以下の意味をもちます:

MAKER
     フォントのmanufacturer(製造者名)です。
FAMILY
     フォントのファミリー名です(たとえば‘courier’)。
WEIGHT
     フォントのweightで、通常は‘bold’、‘medium’、‘light’のどれかです。他
     の値をサポートするフォント名もいくつかあります。
SLANT
     フォントのslantで、通常は‘r’(roman)、‘i’(italic)、‘o’(oblique)、
     ‘ri’(reverse italic)、‘ot’(other)のどれかです。他の値をサポートする
     フォント名もいくつかあります。
WIDTHTYPE
     フォントのwidthで、通常は‘normal’、‘condensed’、‘semicondensed’、
     ‘extended’のどれかです。他の値をサポートするフォント名もいくつかあ
     ります。
STYLE
     オプションの追加のstyle名です。通常これは空で、ほとんどのXLFDでは、
     この位置に2つのハイフンを続けて指定します。style名には、‘ja’や
     ‘ko’のような、ISO-639 language nameの2文字を指定することもできます
     。CJKスクリプトをサポートするいくつかのフォントは、style名の部分に
     この記述をもちます。
PIXELS
     フォントのheightをピクセルで指定します。
HEIGHT
     プリンターのポイントの1/10を単位とした、スクリーン上のフォントの
     heightです。フォントのポイントサイズの10倍です。垂直解像度(vertical
     resolution)を与えれば、HEIGHTとPIXELSは比例します。したがって一方を
     指定して、もう一方に‘*’を指定するのが一般的です。
HORIZ
     フォントが意図するインチあたりのピクセル数で表した、水平解像度
     (horizontal resolution)です。
VERT
     フォントが意図するインチあたりのピクセル数で表した、垂直解像度
     (vertical resolution)です。通常、システムのフォント解像度は、スクリ
     ーンにたいして正しい値になっています。したがって、これとHORIZには
     ‘*’を指定するのが普通です。
SPACING
     これには‘m’(monospace)、‘p’(proportional)、‘c’(character cell)を指
     定します。
WIDTH
     ピクセル単位で表した文字の平均widthの10倍です。
REGISTRY
ENCODING
     フォントを描画するXフォント文字セット(X font character set)です(Xフ
     ォント文字セットはEmacs文字セットと同じではありませんが、似ています
     )。フォントの選択をチェックするのに、‘xfontsel’コマンドを使うことが
     できます。通常は、REGISTRYに‘iso8859’、ENCODINGに‘1’を使うべきです
     。

   フォントを指定する4番目の方法は、フォントニックネーム(font nickname)を
使う方法です。特定のフォントは通常のフォント指定のかわりに、短いニックネ
ームをもつものがあります。たとえば‘6x13’は以下と同じです

     -misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1

   X上でのEmacsは、2つのタイプのフォントを認識します。1つは“クライアント
サイド”のフォントで、これはXftおよびFontconfigライブラリーにより提供され
ます。もう1つは“サーバーサイド”のフォントで、これはXサーバー自身により提
供されます。ほとんどのクライアントサイドフォントは、アンチエイリアシング
(antialiasing)やサブピクセルンティング(subpixel hinting)などの、サーバー
サイドフォントにはない、進んだフォント機能をサポートします。Fontconfigと
GTKパターンは、クライアントサイドフォントだけにマッチします。

   すべての文字が同じ幅をもつ固定幅フォントを使いたいと思うでしょう。
XftおよびFontconfigフォントでは、‘fc-list’コマンドを使って、以下のように
して利用可能な固定幅フォントを一覧することができます。

     fc-list :spacing=mono
     fc-list :spacing=charcell

サーバーサイドのXフォントにたいしては、‘xlsfonts’プログラムを使って、以
下のようにして利用可能な固定幅フォントを一覧することができます。

     xlsfonts -fn '*x*' | grep -E '^[0-9]+x[0-9]+'
     xlsfonts -fn '*-*-*-*-*-*-*-*-*-*-*-m*'
     xlsfonts -fn '*-*-*-*-*-*-*-*-*-*-*-c*'

XLFDのSPACINGフィールドが、‘m’または‘c’のフォントは固定幅フォントです。
特定のフォントの外見を見るには、以下のように‘xfd’コマンドを使います:

     xfd -fn 6x13

これはフォント‘6x13’の全体を表示します。

   Emacsを実行しているときは、特定の種類のテキスト(*note Faces::を参照し
てください)や、特定のフレーム(*note Frame Parameters::を参照してください
)のフォントをセットすることもできます。


File: emacs-ja.info,  Node: Speedbar,  Next: Multiple Displays,  Prev: Fonts,  Up: Frames

21.9 スピードバーフレーム
=========================

“スピードバー(speedbar)”は、簡単に他のフレームを操作したり処理するための
、特別なフレームです。スピードバーが存在するとき、それは常に“アタッチさ
れたフレーム(attached frame)”と呼ばれる、特定のフレームに対応しています
。すべてのスピードバー操作は、そのフレームにたいして処理されます。

   ‘M-x speedbar’とタイプすると、スピードバーを作成して、カレントフレー
ムに関連付けます。スピードバーを解除するには、再度‘M-x speedbar’とタイプ
するか、スピードバーを選択して‘q’とタイプします(他のEmacsフレームを削除
するのと同じ方法で、スピードバーフレームを削除することもできます)。スピ
ードバーを他のフレームに関連付けたいときは、一旦解除してから、そのフレー
ムで‘M-x speedbar’を呼び出します。

   スピードバーは、さまざまなモードを処理できます。デフォルトモードは
“File Display(ファイル表示)”モードで、これはアタッチされたフレームの、選
択されたウィンドウのカレントディレクトリーのファイルを、1行に1ファイルず
つ表示します。ディレクトリー以外をクリックすると、アタッチされたフレーム
の、選択されたウィンドウでそのファイルをvisitし、ディレクトリーをクリッ
クすると、スピードバーでそのディレクトリーを表示します(*note Mouse
References::を参照してください)。各行には‘[+]’や‘<+>’が記されたボックス
があり、それをクリックすると、そのアイテムの内容を“展開”します。ディレク
トリーを展開すると、ディレクトリーの内容を、ディレクトリー自身の行の下に
加えてスピードバー表示します。通常のファイルを展開すると、ファイルの中の
tagリストをスピードバー表示に加えます。tag名をクリックして、アタッチされ
たフレームの選択されたウィンドウで、tagにジャンプできます。ファイルまた
はディレクトリーが展開されているときは、‘[+]’が‘[-]’に変化します。ボック
スを再度クリックすると、アイテムを収納して、内容を隠すことができます。

   キーボードを使ってスピードバーを操作することもできます。スピードバー
でポイントのある行で<RET>をタイプするのは、そのアイテムをクリックするの
と等しく、<SPC>はアイテムを展開または収納します。‘U’は、カレントディレク
トリーの親ディレクトリーを表示します。カレント行のファイルをコピー、削除
、リネーム<するには、‘C’、‘D’、‘R’をタイプします。新しいディレクトリーを
作成するには、‘M’をタイプします。

   スピードバーのモードで、他に一般的な目的に使われるのは“Buffer
Display(バッファー表示)”モードです。このモードでは、スピードバーは
Emacsバッファーのリストを表示します。このモードに切り替えるにはスピード
バーで‘b’をタイプします。File Displayモードに戻るには、‘f’をタイプします
。スピードバーのウィンドウのどこかを‘mouse-3’でクリック(またはモードライ
ンを‘mouse-1’でクリック)して、ポップアップメニューの‘Displays’を選択して
も、表示モードを変更することができます。

   Rmailモード、Info、GUDを含むいくつかのメジャーモードは、スピードバー
に選択可能な便利なアイテムを配する、特別な方法をもっています。たとえば
Rmailモードでは、スピードバーはRmailファイルのリストを表示し、カレントメ
ッセージを他のRmailファイルに移動する場合は、それの‘<M>’ボックスをクリッ
クします。

   スピードバーの使い方とプログラミングに関する詳細は、*note Speedbar:
(speedbar)Top.を参照してください。


File: emacs-ja.info,  Node: Multiple Displays,  Next: Frame Parameters,  Prev: Speedbar,  Up: Frames

21.10 複数ディスプレー
======================

1つのEmacsが、1つ以上のXディスプレーと通信できます。最初、Emacsは環境変
数‘DISPLAY’、または‘--display’オプション(*note Initial Options::を参照し
てください)で指定された、ただ1つのディスプレーに表示されます。他のディス
プレーに接続するには、コマンド‘make-frame-on-display’を使います:

‘M-x make-frame-on-display <RET> DISPLAY <RET>’
     ディスプレーDISPLAYに新しいフレームを作成します。

   1つのXサーバーは、1つ以上のスクリーンを処理できます。1つのサーバーに
属する2つのスクリーンでフレームを開いた場合、Emacsはそれらが1つのキーボ
ードを共有するのを知っているので、これらのスクリーンから到着するすべての
コマンドを1つの入力ストリームとして扱います。

   異なるXサーバーでフレームを開いた場合、Emacsは各サーバーごとに別な入
力ストリームを作成します。各サーバーは、それぞれ選択されたフレームをもち
ます。特定のXサーバーで入力したコマンドは、そのサーバーの選択されたフレ
ームに適用されます。


File: emacs-ja.info,  Node: Frame Parameters,  Next: Scroll Bars,  Prev: Multiple Displays,  Up: Frames

21.11 フレームパラメーター
==========================

変数‘default-frame-alist’の中の、“フレームパラメーター(frame
parameters)”のデフォルトリストを指定することにより、すべてのフレームのデ
フォルトの外見と振る舞いを制御することができます。この値はエントリーのリ
ストで、各エントリーにはパラメーター名と、そのパラメーターの値を指定しま
す。これらのエントリーはEmacsが新しいフレームを作るとき(初期フレームを含
む)に効果を及ぼします。

   たとえば以下のファイルをinitファイル(*note Init File::を参照してくだ
さい)に追加することにより、デフォルトのフレーム幅が90列、デフォルトのフ
レーム高さが40行、デフォルトフォントに‘Monospace-10’を指定します。

     (add-to-list 'default-frame-alist '(width  . 90))
     (add-to-list 'default-frame-alist '(height . 40))
     (add-to-list 'default-frame-alist '(font . "Monospace-10"))

   フレームパラメーターのリストと、その効果については、*note
(elisp)Frame Parameters::を参照してください.

   変数‘initial-frame-alist’をカスタマイズすることにより、初期フレームだ
けに適用されるフレームパラメーターのリストを指定することもできます。

   EmacsがX ツールキットを使ってコンパイルされている場合、カラーとフォン
トを指定するフレームパラメーターは、メニューとメニューバーには影響を及ぼ
しません。なぜなら、それらはEmacsが直接描画しているのではなく、ツールキ
ットにより描画されているからです。

   セッションの保存とリストアのためにdesktopライブラリーを使用している場
合は、desktopファイルに記録されたフレームが、これらのパラメーターととも
にリストアされることに注意してください。これらのフレームがリストアされる
ときは、initファイル内で‘default-frame-alist’および
‘initial-frame-alist’で指定されているフレームパラメーターよりも、記録さ
れたパラメーターが優先されます。これを避ける方法については、*note Saving
Emacs Sessions::を参照してください。


File: emacs-ja.info,  Node: Scroll Bars,  Next: Window Dividers,  Prev: Frame Parameters,  Up: Frames

21.12 スクロールバー
====================

グラフィカルなディスプレーでは、Emacsウィンドの横に“垂直スクロールバー
(vertical scroll bar)”があります。スクロールバーのupボタンまたはdownボタ
ンを‘mouse-1’でクリックすると、ウィンドウを1行ずつスクロールします(しか
し、これらのボタンがないようにスクロールバーをカスタマイズできるツールキ
ットもある)。スクロールバー内部のボックスの上または下を‘mouse-1’でクリッ
クすると、‘M-v’または‘C-v’と同様に、ほぼウィンドウ全体の高さ分スクロール
します(*note Moving Point::を参照) (これも、いくつかのツールキットでは動
作が異なるかもしれない)。スクロールバー内部のボックスをドラッグすると、
連続してスクロールします。

   EmacsがXウィンドウシステム上でXツールキットサポートなしでコンパイルさ
れている場合、スクロールバーは違った振る舞いをします。スクロールバーの任
意の箇所を‘mouse-1’でクリックすると‘C-v’のように前方にスクロールし、
‘mouse-3’でクリックすると‘M-v’のように後方にスクロールします。スクロール
バーで‘mouse-2’をクリックすると、スクロールバー内部のボックスを上下にド
ラッグできます。

   垂直スクロールバーの使用を切り替えるには、‘M-x scroll-bar-mode’とタイ
プします。このコマンドは、まだ作成されていないフレームも含めて、すべての
フレームに適用されます。選択されたフレームの垂直スクロールバーだけ切り替
えたい場合は、コマンド‘M-x toggle-scroll-bar’を使用してください。

   起動時に垂直スクロールバーの使用を制御するには、変数
‘scroll-bar-mode’をカスタマイズします。この変数の値は、‘right’(ウィンド
ウの右にスクロールバーを配します)、‘left’(ウィンドウの左にスクロールバー
を配します)、‘nil’(垂直スクロールバーを無効にします)のどれかです。
EmacsがXウィンドウシステム上でGTK+サポートつきでコンパイルされている、ま
たはMS-Windows、macOSの場合、デフォルトでは右にスクロールバーを配します
。EmacsがXウィンドウシステム上でGTK+サポートなしでコンパイルされている場
合、(古いXアプリケーションの慣例にしたがって)スクロールバーを左に配しま
す。

   Xリソース‘verticalScrollBars’を使って、スクロールバーの有効または無効
にすることができます(*note Resources::を参照してください)。スクロールバ
ーの幅を制御するにはフレームパラメーター‘scroll-bar-width’を変更してくだ
さい(*note (elisp)Frame Parameters::を参照してください)。

   (GTK+またはMotifとともに)X上でEmacsを使っている場合、変数
‘scroll-bar-adjust-thumb-portion’をカスタマイズして、スクロールバーの“オ
ーバースクロール(overscrolling: たとえばバッファーの最後が表示されていて
もさらに下にスクロールします)”を制御できます。変数の値が非‘nil’の場合、
バッファーの最後が表示されていてもスクロールバーを下にドラッグできます。
‘nil’の場合、バッファーの最後が表示されたとき、内部のボックスはスクロー
ルバーの最下になります。バッファー全体が表示されているときは、オーバース
クロールできません。

   スクロールバーの視覚的な外見は、‘scroll-bar’フェイスにより制御されま
す。

   グラフィカルなフレームでは、垂直スクロールバーは暗に横並びのウィンド
ウを区別する役目を担っています。垂直スクロールバーが無効なとき、Emacsは
デフォルトでは幅1ピクセルの“垂直ボーダー(vertical border)”によりそのよう
なウィンドウを区別します。このボーダーは右側のウィンドウの最初の1ピクセ
ルの列を占め、したがってそこに表示されていたグリフの左端ピクセルの上に上
書きされることになるでしょう。これらのピクセルに重要な情報が含まれる場合
は、window dividerを有効にしてそれらを可視にできます(*note Window
Dividers::を参照)。垂直ボーダーの見栄えを複製するには、フレームの
‘right-divider-width’パラメーターを1にセットして、‘window-divider’フェイ
スを‘vertical-border’のフェイスから継承してください(*note Window
Dividers: (elisp)Window Dividers.を参照)。

   ツールキットサポート付きのグラフィカルなディスプレーでは、Emacsは各ウ
ィンドウの最下に“水平スクロールバー(horizontal scroll bar)”も提供します
。スクロールバーのleftボタンまたはrightボタンを‘mouse-1’でクリックすると
、ウィンドウを1列ずつ水平にスクロールします(これらのボタンを表示しないよ
うスクロールバーをカスタマイズできるツールキットがあることに注意)。スク
ロールバーの内部ボックスの左または右下を‘mouse-1’でクリックすると、ウィ
ンドウは4列スクロールします。スクロールバー内部のボックスをドラッグする
と、連続してスクロールします。

   このような水平スクロールにより、そのウィンドウのポイント位置が、右側
または左側の見えない場所になるかもしれないことに注意してください。文字を
タイプしてテキストを挿入したり、キーボードコマンドでポイントを移動するこ
とにより通常、ポイントは視界に戻るでしょう。

   水平スクロールバーの使用を切り替えるには、‘M-x
horizontal-scroll-bar-mode’とタイプします。このコマンドは、まだ作成され
ていないフレームも含めて、すべてのフレームに適用されます。選択されたフレ
ームの水平スクロールバーだけ切り替えたい場合は、コマンド‘M-x
toggle-horizontal-scroll-bar’を使用してください。

   起動時に水平スクロールバーの使用を制御するには、変数
‘horizontal-scroll-bar-mode’をカスタマイズしてください。

   Xリソース‘horizontalScrollBars’を使って、水平スクロールバーを有効また
は無効にすることができます(*note Resources::を参照してください)。スクロ
ールバーの高さを制御するには、フレームパラメーター‘scroll-bar-height’を
変更してください(*note (elisp)Frame Parameters::を参照してください)。


File: emacs-ja.info,  Node: Window Dividers,  Next: Drag and Drop,  Prev: Scroll Bars,  Up: Frames

21.13 Window Divider
====================

グラフィカルなディスプレーでは、ウィンドウの外観を分割するために、
“window dividers”を使用することができます。window dividersはマウスでドラ
ッグできるバーなので、隣接したウィンドウを簡単にリサイズできます。

   window dividersの表示を切り替えるには、コマンド‘M-x
window-divider-mode’を使用します。

   dividersをどこに表示するかカスタマイズするには、オプション
‘window-divider-default-places’を使用します。変数の値には‘bottom-only’
(dividersをウィンドウの下だけに表示します)、‘right-only’ (dividersをウィ
ンドウの右だけに表示します)、または‘t’ (下と右の両方に表示します)を指定
します。

   このモードにより表示されるwindow dividersの幅を調整するには、オプショ
ン‘window-divider-default-bottom-width’および
‘window-divider-default-right-width’をカスタマイズします。

   ウィンドウの列の最初の1ピクセル(window dividerが無効な場合は横並びの
ウィンドウを区別する垂直ボーダーに使用されます)を可視とするwindow
dividerは、垂直スクロールバーが無効のときにも有用です(*note Scroll
Bars::を参照)。

   window dividersについての詳細は、*note Window Dividers: (elisp)Window
Dividers.を参照してください。


File: emacs-ja.info,  Node: Drag and Drop,  Next: Menu Bars,  Prev: Window Dividers,  Up: Frames

21.14 ドラッグアンドドロップ
============================

ほとんどのグラフィカルなデスクトップ環境で、Emacsは“ドラッグアンドドロッ
プ(drag and drop)”操作にたいする、基本的なサポートを提供します。たとえば
Emacsのフレームにテキストをドロップすると、ドロップされた箇所にテキスト
を挿入し、ファイルをドロップすると、Emacsフレームはそのファイルをvisitし
ます。特別なケースとしては、Diredバッファーにファイルをドロップすること
により、バッファーに表示されているディレクトリーにファイルを移動またはコ
ピーします(アプリケーションの慣例に基づきます)。

   ファイルをドロップすると、通常はドロップされたウィンドウでファイルを
visitします。そのような場合に、新しいウィンドウでファイルをvisitしたいと
きは、変数‘dnd-open-file-other-window’をカスタマイズします。

   現在のところ、XDNDおよびMotif drag and drop protocolsと、古いKDE 1.x
protocolがサポートされています。

   Emacsはオプションで、テキストのリージョンを他のバッファーの他の部分へ
ドラッグする操作もサポートします。これを有効にするには、変数
‘mouse-drag-and-drop-region’を非‘nil’値にカスタマイズしてください。通常
そのテキストは、ドロップ先が元のリージョンと同じなら移動(カットアンドペ
ースト)され、他のバッファーならそのリージョンがコピーされます。この変数
の値が‘shift’、‘control’、‘alt’のような修飾キー名の場合、その修飾キーを
押しながらテキストをドロップすると、ドロップ先がドラッグ元と同じバッファ
ーでも、テキストはカットされずにコピーされます。

   ドラッグ元とドロップ先が異なるバッファーのときにもテキストをカットす
るためには、オプション
‘mouse-drag-and-drop-region-cut-when-buffers-differ’を非‘nil’値にセット
します。デフォルトでは、グラフィカルなディスプレイの選択されたテキストは
ツールチップ内に表示され、ドラッグ中にはマウスカーソルとともにポイントが
移動します。このような動作を抑止するには、オプション
‘mouse-drag-and-drop-region-show-tooltip’、および/または
‘mouse-drag-and-drop-region-show-cursor’に‘nil’をセットしてください。


File: emacs-ja.info,  Node: Menu Bars,  Next: Tool Bars,  Prev: Drag and Drop,  Up: Frames

21.15 メニューバー
==================

‘M-x menu-bar-mode’で、メニューバーの使用を切り替えることができます。引
数を指定しないと、このコマンドはグローバルマイナーモードのMenu Barを切り
替えます。引数を指定した場合、引数が正ならMenu Barモードをオンにして、負
ならオフにします。起動時にメニューバーの使用を制御するには、変数
‘menu-bar-mode’をカスタマイズしてください。

   熟練したユーザーは、テキストのために更なる行を得るために、メニューを
オフにしている場合がしばしばあります(特にテキスト端末時)。メニューバーが
オフでも、ポップアップメニューをサポートするディスプレーなら、
‘C-mouse-3’でメニュー内容を含むポップアップメニューを表示できます。*note
Menu Mouse Clicks::を参照してください。

   メニューバーのコマンドを呼び出す方法については、*note Menu Bar::を参
照してください。メニューバーのメニューの視覚的な外見をカスタマイズする方
法は、*note X Resources::を参照してください。


File: emacs-ja.info,  Node: Tool Bars,  Next: Dialog Boxes,  Prev: Menu Bars,  Up: Frames

21.16 ツールバー
================

グラフィカルなディスプレーでは、Emacsはフレームのトップ、メニューバーの
直下に“ツールバー(tool bar)”を配します。これはマウスでクリックすることに
より、さまざまなコマンドを呼び出すことができるアイコンが1列に並んだもの
です。

   (デフォルトの)グローバルツールバーは、一般的なコマンドを含みます。自
身のツールバーを定義するメジャーモードもいくつか存在します。バッファーが
それらのメジャーモードの場合、モードのツールバーにより、グローバルツール
バーが置き換えられます。

   ツールバーの使用を切り替えるには、‘M-x tool-bar-mode’とタイプします。
このコマンドは、まだ作成されていないフレームを含むすべてのフレームに適用
されます。起動時にツールバーの使用を制御するには、変数‘tool-bar-mode’を
カスタマイズします。

   EmacsがGTK+サポートつきでコンパイルされている場合、ツールバーアイテム
には、イメージ、テキストラベル、またはそれら両方を含むことができます。デ
フォルトではEmacsはGnomeデスクトップの、ツールバースタイルセッティングに
したがいます。もし何も定義されていない場合、ツールバーのアイテムにはイメ
ージだけが表示されます。特定のツールバースタイルを強要するには、変数
‘tool-bar-style’をカスタマイズしてください。

   フレームパラメーター‘tool-bar-position’で、GTK+ツールバーのためのツー
ルバーの配置を制御することもできます。*note (elisp)Frame Parameters::を
参照してください。

   NSビルドはツールバーをウィンドウ装飾と判断するため、ウィンドウが装飾
されていないときはツールバーを表示しません。*note (elisp)Frame
Parameters::を参照してください。macOSでは、フレームがフルスクリーンのと
きツールバーは表示されませんが、スクリーン上端にマウスポインターを移動す
ることにより表示することができます。


File: emacs-ja.info,  Node: Dialog Boxes,  Next: Tooltips,  Prev: Tool Bars,  Up: Frames

21.17 ダイアログボックスの使用
==============================

ダイアログボックスとは、yes-or-noの質問(はい／いいえで応える問いかけ)を
したり、他の何か特別な質問を問いかけるための、特別な種類のメニューです。
コマンドを呼び出すためにマウスを使い、それがユーザーへの質問を要するよう
な操作の場合、多くのEmacsコマンドはyes-or-noを問うために、ダイアログボッ
クスを使います。

   ダイアログボックスの使用を無効にするには、変数‘use-dialog-box’を
‘nil’に変更します。この場合、Emacsはエコーエリアとキーボード入力を使って
yes-or-noプロンプトを処理します。この変数はファイル選択ウィンドウの使用
も制御します(しかしこれらはすべてのプラットフォームでサポートされている
わけではありません)。

   ファイル選択ウィンドウはファイル名を問うための、特別な種類のダイアロ
グボックスです。変数‘use-file-dialog’をカスタマイズすれば、他の種類のダ
イアログボックスの使用して、ファイル選択ウィンドウを使用しないようにでき
ます。変数‘use-dialog-box’ですべてのダイアログボックスを使用しないように
している場合、この変数は効果がありません。

   EmacsがGTK+サポートつきでコンパイルされている場合、EmacsはGTK+のファ
イル選択ダイアログを使います。Emacsは非表示のファイル(名前がドットで始ま
るファイル)の表示の有効・無効を切り替えるボタンを、ダイアログボックスに
追加します。この切り替えをデフォルトで有効にしたい場合、変数
‘x-gtk-show-hidden-files’を‘t’に変更します。さらにEmacsは、GTK+ファイル
選択ダイアログにヘルプテキストを追加します。このヘルプテキストを無効にす
るには、変数‘x-gtk-file-dialog-help-text’を‘nil’に変更してください。


File: emacs-ja.info,  Node: Tooltips,  Next: Mouse Avoidance,  Prev: Dialog Boxes,  Up: Frames

21.18 ツールチップ
==================

“ツールチップ”は、小さい特別なフレームに、マウスのカレント位置に関するテ
キスト情報を表示します。ツールチップはウィンドウの重要なテキストの上や、
ツールバーのボタンやメニューアイテムのような、Emacsフレームの他の部分の
上でマウスを停止させたときにアクティブになります。

   ツールチップの使用は、コマンド‘M-x tooltip-mode’で切り替えることがで
きます。Tooltipモードが無効な場合、ヘルプテキストは、かわりにエコーエリ
アに表示されます。ツールチップの使用を起動時に制御するには、変数
‘tooltip-mode’をカスタマイズしてください。

   以下の変数はツールチップ表示にたいするカスタマイズオプションを提供し
ます:

‘tooltip-delay’
     この変数は、最初のツールチップを表示する前に、Emacsがwaitする長さを
     指定します。値は秒です。

‘tooltip-short-delay’
     この変数は、すでに最初のツールチップが表示されているとき、異なるア
     イテムにたいする後続のツールチップを表示する前に、Emacsがwaitする長
     さを指定します。値は秒です。

‘tooltip-hide-delay’
     マウスが静止しているとき、ツールチップを隠すまでの秒数です。

‘tooltip-x-offset’
‘tooltip-y-offset’
     マウスポインター位置から、ツールチップの左上隅までのXオフセットと
     Yオフセットを、ピクセルで指定します。‘tooltip-frame-parameters’が、
     ‘left’および‘top’パラメーターをインクルードするためにカスタマイズさ
     れている場合、これらは無視されることに注意してください。オフセット
     には、ツールチップがマウスのクリックと干渉するような、マウスポイン
     ターのホットスポットを覆い隠さない値を指定するべきです。

‘tooltip-frame-parameters’
     ツールチップの表示のために、フレームパラメーターが使用されます。
     *note (elisp)Frame Parameters::、および*note (elisp)Tooltips::を参
     照してください。

   ツールチップの表示にたいする追加のカスタマイズオプションについては、
‘M-x customize-group <RET> tooltip <RET>’を使用してください。

   EmacsがGTK+サポートつきでビルドされている場合、ツールチップはGTK+を通
じて、GTK+のツールチップのデフォルトの外見を使います。これを無効にするに
は、変数‘x-gtk-use-system-tooltips’を‘nil’に変更します。これを行うか、
EmacsがGTK+サポートなしでビルドされた場合は、ツールチップテキストのほと
んどの属性は‘tooltip’フェイスとXリソース(*note X Resources::を参照してく
ださい)により指定されます。

   “GUDツールチップ”は、プログラムをGUDでデバッグしているときに変数の値
を表示する、特別なツールチップです。*note Debugger Operation::を参照して
ください。


File: emacs-ja.info,  Node: Mouse Avoidance,  Next: Non-Window Terminals,  Prev: Tooltips,  Up: Frames

21.19 マウスの回避
==================

グラフィカルな端末では、マウスポインターがEmacsフレームのテキストを隠し
てしまうことがありえます。この問題を避けるために、Emacsは2つの方法を提供
します。

   1番目の方法は、ユーザーが自己挿入文字をタイプしたとき、Emacsがマウス
ポインターを非表示にして、マウスポインターを動かしたときに、ポインターが
Emacsフレームの内側にあるときは、再びポインターを表示する方法です。この
機能を無効にするには、変数‘make-pointer-invisible’を‘nil’にセットしてく
ださい。*note Display Custom::を参照してください。

   2番目の方法はMouse Avoidance(マウス回避)モードを使って、マウスポイン
ターをポイントから遠ざける方法です。Mouse Avoidanceモードを使うには、変
数‘mouse-avoidance-mode’をカスタマイズします。この変数にさまざまな値をセ
ットすることにより、マウスを遠ざけるいくつかの方法を選択できます。

‘banish’
     キーが押されたらポインターをフレームの隅に移動します。ポインターを
     どこに遠ざけるかは、変数‘mouse-avoidance-banish-position’でカスタマ
     イズできます。
‘exile’
     カーソルがポインターに近づきすぎたときだけポインターを遠ざけて、カ
     ーソルが離れたらポインターを元に戻します。
‘jump’
     カーソルがポインターに近づきすぎたら、ランダムな方向と距離にポイン
     ターを移動します。
‘animate’
     ‘jump’と同様ですが、移動モーションをアニメ化します。
‘cat-and-mouse’
     ‘animate’と同じです。
‘proteus’
     ‘animate’と同様ですが、マウスポインターの外見も変更します。

   コマンド‘M-x mouse-avoidance-mode’を使って、このモードを有効にするこ
ともできます。Mouse Avoidanceモードがマウスを移動したときは、常にそのフ
レームを前に表示します。


File: emacs-ja.info,  Node: Non-Window Terminals,  Next: Text-Only Mouse,  Prev: Mouse Avoidance,  Up: Frames

21.20 非ウィンドウ端末
======================

テキスト端末では、Emacsは1度に1つのEmacsフレームしか表示できません。それ
でも複数のEmacsフレームを作成して、それらを切り替えることができます。こ
れらの端末でフレームを切り替えるのは、異なるウィンドウの設定を切り替える
のによく似ています。

   ‘C-x 5 2’を使うと新しいフレームを作成してそれに切り替えます。‘C-x 5
o’を使うと既存のフレームを巡回します。‘C-x 5 0’を使うと、カレントフレー
ムを削除します。

   各フレームには区別するための番号があります。端末が1度に1つのフレーム
しか表示できない場合、選択されたフレームの番号Nが、モードラインの先頭に
近い位置に、‘FN’という形式で表示されます。

   ‘FN’は、フレームの実際の初期名称です。フレームにもっと意味のある名前
を与えて、その名前でフレームを選択できます。コマンド‘M-x set-frame-name
<RET> NAME <RET>’を使うと、選択されたフレームに新しい名前を指定し、‘M-x
select-frame-by-name <RET> NAME <RET>’を使うとその名前に一致するフレーム
を選択します。指定した名前は、そのフレームが選択されたときに、モードライ
ンに表示されます。


File: emacs-ja.info,  Node: Text-Only Mouse,  Prev: Non-Window Terminals,  Up: Frames

21.21 テキスト端末でのマウスの使用
==================================

端末ウィンドウでのマウスクリックをサポートするテキスト端末がいくつかあり
ます。

   ‘xterm’と互換性のある端末エミュレーターでは、‘M-x xterm-mouse-mode’を
使って、Emacsに簡単なマウスの使用 — 基本的には修飾なしのシングルクリック
だけがサポートされます — を制御させることができます。より新しいバージョ
ンの‘xterm’は、マウストラッキングもサポートします。そのようなクリックに
たいする通常の‘xterm’のマウス機能は、マウスボタンを押すときに<SHIFT>キー
を押すことにより、利用できます。Xterm Mouseモードはグローバルマイナーモ
ードです(*note Minor Modes::を参照してください)。コマンドを繰り返すと、
このモードを再びオフにします。

   GNU/Linuxのコンソールでは、‘M-x gpm-mouse-mode’を使ってマウスサポート
を有効にできます。これが機能するためにはgpmサーバーがインストールされて
いて、システムで実行されていなければなりません。このモードが有効な場合、
EmacsとGPMを使用する他のプログラムとの間で、マウスによるテキスト転送がで
きないことに注意してください。これはGPMとLinux kernelによる制限です。

   MS-DOSでのマウスサポートに関する情報は、*note MS-DOS Mouse::を参照し
てください 。


File: emacs-ja.info,  Node: International,  Next: Modes,  Prev: Frames,  Up: Top

22 国際化文字セットのサポート
*****************************

Emacsは、広範囲な国際化文字セット(international character sets)をサポー
トします。それらには、ラテンアルファベットの変種であるEuropeanと
Vietnamese、同様にArabic scripts、(Bengali、Hindi、Thaiのような言語にた
いする)Brahmic scripts 、Cyrillic、Ethiopic、Georgian、Greek、(Chineseと
Japaneseにたいする)Han、(Koreanにたいする)Hangul、Hebrew、IPAが含まれま
す。Emacsは他の国際化されたソフトウェアー(ワープロやメーラー)などで使わ
れる、それらの文字にたいするさまざまなエンコーディングもサポートします。

   Emacsは関連するアクティビティーのすべてをサポートすることにより、国際
化文字セットの編集を可能にします:

   • 非ASCII文字のファイルをvisitしたり、非ASCIIのテキストを保存したり、
     非ASCIIのテキストを、EmacsとEmacsが呼び出すプログラム(コンパイラー
     、スペルチェッカー、メーラーなど)に引き渡すことができます。言語環境
     のセッティングとは、コーディングシステムのセッティングと、その他の
     言語に特有な文化のためのオプションを処理することです。かわりに各コ
     マンドにエンコードあるいはデコードする方法を指定できます。*note
     Text Coding::を参照してください.

   • さまざまなスクリプトでエンコードされた、非ASCII文字を表示することが
     できます。これはグラフィカルなディスプレー上で適切なフォントを使う
     こと(*note Defining Fontsets::を参照してください)、そしてテキスト表
     示のために特別なコードを送信すること(*note Terminal Coding::を参照
     してください)により機能します。正しく表示できない文字があるときは、
     *note Undisplayable Characters::を参照してください。これには考えら
     れる原因と、解決方法が記述されています。

   • 本来、右から左に記述されるスクリプトの文字は、表示のために再配置さ
     れます(*note Bidirectional Editing::を参照)。これらのスクリプトには
     Arabic、Hebrew、Syriac、Thaana、それ以外にもいくつか存在します。

   • 非ASCII文字を挿入したり検索することができます。これを行うために、言
     語にあったインプットメソッド(IM: input method。*note Select Input
     Method::を参照してください)を指定するか、言語環境を選択したときにセ
     ットアップされた、デフォルトのインプットメソッドを使うことができま
     す。キーボードが非ASCII文字を生成できる場合、適切なキーボードコーデ
     ィングシステムを選択できます。Emacsはそれらの文字を受け入れることが
     できるでしょう。Latin-1文字は、‘C-x 8’プレフィクスを使って入力する
     こともできます。*note Unibyte Mode::を参照してください.

     Xウィンドウシステムでは、Emacsがキーボード入力を正しく解釈するため
     に、localeに適切な値をセットする必要があります。*note locales:
     Language Environments.を参照してください。

   このチャプターの残りの部分では、これらの問題について詳細を説明します
。

* Menu:

* International Chars::      マルチバイト文字の基本的な概念。
* Language Environments::    使用する言語のためのセットアップ事項。
* Input Methods::            キーボードにないテキスト文字の入力。
* Select Input Method::      インプットメソッド選択を指定する。
* Coding Systems::           ファイルを読み書きしたりするときの文字セット変換。
* Recognize Coding::         どの変換を使用するかをEmacsが解決する方法。
* Specify Coding::           ファイルのコーディングシステムの明示的な指定。
* Output Coding::            出力のためのコーディングシステムの選択について。
* Text Coding::              ファイルのテキストに使う変換の選択。
* Communication Coding::     プロセス間通信のためのコーディングシステム。
* File Name Coding::         _ファイル名_のコーディングシステム。
* Terminal Coding::          端末の入出力の変換のためのコーディングシステムの指定。
* Fontsets::                 フォントセット、それは文字の全範囲をカバーするフォントのコレクション。
* Defining Fontsets::        新しいフォントセットの定義。
* Modifying Fontsets::       既存のフォントセットの修正。
* Undisplayable Characters::  文字が表示されないとき。
* Unibyte Mode::             マルチバイト文字を使わずに1つの英文字セットを選択する。
* Charsets::                 Emacsが内部の文字コードをグループ化する方法。
* Bidirectional Editing::    右から左に記述する言語のサポート。


File: emacs-ja.info,  Node: International Chars,  Next: Language Environments,  Up: International

22.1 国際化文字セットのイントロダクション
=========================================

国際化文字セットとスクリプトのユーザーは、ファイルを保存するために、多少
の差はありますが、標準化された多くのコーディングシステムを確立しています
。これらのコーディングシステムは通常は“マルチバイト(multibyte)”で、これ
は1つの非ASCII文字を表すのに、2つ以上のバイトシーケンスを対応させること
を意味します。

   Emacsは、内部的には“Unicode”標準のスーパーセットである、マルチバイト
文字エンコーディングを使用します。この内部的なエンコーディングは、ほとん
どすべての既知のスクリプトを、1つのバッファーまたは文字列に混成すること
を可能にします。Emacsはファイルを読み書きしたり、サブプロセスとデータを
やりとりするとき、このマルチバイト文字エンコーディングと、他のさまざまな
コーディングシステムをコード変換します。

   コマンド‘C-h h’ (‘view-hello-file’)は、ファイル‘etc/HELLO’を表示しま
す。これは、多くの異なる言語で、“hello”をどのように記述するかを、さまざ
まな文字で例示するファイルです。もしもある文字が端末で表示できないときは
、それらの文字は‘?’か、中抜きのボックスで表示されます。

   これらの文字セットを使う国のキーボードでも、一般的にはすべての文字に
対応するキーはもっていません。キーボードがサポートしない文字は、‘C-x 8
<RET>’ (‘insert-char’)を使って挿入することができます。*note Inserting
Text::を参照してください。一般的な文字のいくつかは略記が利用できます。た
とえば‘C-x 8 [’とタイプ(Electric Quoteモードでは、通常は単に‘`’とタイプ
)することにより、left single quotation mark ‘を挿入できます。Emacsはさま
ざまな“インプットメソッド(IM: input methods)”をサポートします。これはあ
るスクリプトの文字をタイプするのを簡単にするもので、通常1つのスクリプト
または言語に1つです。*note Input Methods::を参照してください。

   プレフィクスキー‘C-x <RET>’は、マルチバイト文字、コーディングシステム
、インプットメソッドに属するコマンドにたいして使用されます。

   コマンド‘C-x =’ (‘what-cursor-position’)は、ポイント位置にある文字の
情報を表示します。文字の位置に加えて、*note Position Info::で説明したよ
うに、このコマンドはその文字がどのようにエンコードされているかを表示しま
す。たとえば、このコマンドは文字‘c’に大して、以下のような行をエコーエリ
アに表示します:

     Char: c (99, #o143, #x63) point=28062 of 36168 (78%) column=53

   ‘Char:’の後ろの4つの値は、ポイント位置の文字を説明するためのもので、
1つ目はその文字自身、その後ろに文字コードを10進(decimal)、8進(octal)、
16進(hex)で表示します。非ASCIIのマルチバイト文字の場合、バッファーのコー
ディングシステムでその文字を安全に1バイトでエンコードできる場合は、
‘file’とそのバッファーのコーディングシステムで表した文字コードの16進表記
が続きます。その文字のエンコーディングが1バイトより長い場合、Emacsは
‘file ...’と表示します。

   特別なケースとして、文字コードが128(8進の0200)から159(8進の0237)の範
囲の場合、それはraw(生)のバイトを表し、それに対応する表示可能な文字はあ
りません。そのような文字は‘eight-bit-control’文字セットに属し、エスケー
プされた8進表記で表示されます。この場合、‘C-x =’は‘file’のかわりに、
‘part of display ...’と表示します。

   プレフィクス引数を指定した(‘C-u C-x =’)では、その文字の詳細な情報をウ
ィンドウに表示します:

   • 文字セット名(character set name)と、文字セットでその文字が識別され
     るコード。ASCII文字の場合、‘ascii’文字セットに属すると識別されます
     。

   • その文字のスクリプト(script)、構文(syntax)、カテゴリー
     (categories)。

   • 現在のインプットメソッドで(もしその文字をサポートしていれば)、その
     文字を入力するためにタイプするキー。

   • その文字のエンコード。バッファー内部のエンコードと、ファイルに保存
     したときの外部のエンコードの両方。

   • グラフィカルなディスプレーでEmacsを実行しているときはフォント名と、
     その文字にたいするグリフコード(glyph code)。Emacsをテキスト端末で実
     行している場合、端末に送るコード。

   • その文字のテキストプロパティー(*note (elisp)Text Properties::を参照
     してください)。これにはその文字を表示するのに使われるデフォルト以外
     のフェイスと、それを含むオーバーレイ(overlays)が含まれます(*note
     (elisp)Overlays::を参照してください)。

   以下は例です(マニュアルに収まるように折り返している行もあります):

                  position: 1 of 1 (0%), column: 0
                 character: ê (displayed as ê) (codepoint 234, #o352, #xea)
         preferred charset: unicode (Unicode (ISO10646))
     code point in charset: 0xEA
                    script: latin
                    syntax: w        which means: word
                  category: .:Base, L:Left-to-right (strong), c:Chinese,
                            j:Japanese, l:Latin, v:Viet
                  to input: type "C-x 8 RET ea" or
                            "C-x 8 RET LATIN SMALL LETTER E WITH CIRCUMFLEX"
               buffer code: #xC3 #xAA
                 file code: #xC3 #xAA (encoded by coding system utf-8-unix)
                   display: by this font (glyph code)
         xft:-PfEd-DejaVu Sans Mono-normal-normal-
             normal-*-15-*-*-*-m-0-iso10646-1 (#xAC)

     Character code properties: customize what to show
       name: LATIN SMALL LETTER E WITH CIRCUMFLEX
       old-name: LATIN SMALL LETTER E CIRCUMFLEX
       general-category: Ll (Letter, Lowercase)
       decomposition: (101 770) ('e' '^')


File: emacs-ja.info,  Node: Language Environments,  Next: Input Methods,  Prev: International Chars,  Up: International

22.2 言語環境
=============

サポートされているすべての文字セットは、マルチバイト文字が利用可能なとき
は、Emacsバッファーの中でサポートされます。その文字を表示するために、特
定の言語を選択する必要はありません。しかしさまざまなデフォルト値をセット
するために、“言語環境(language environment)”を選択することは重要です。大
まかに言うと、言語環境とは、言語の選択というよりも、好ましいスクリプト選
択の提示です。

   言語環境は、テキストを読み込むとき、それを認識するコーディングシステ
ムを制御します(*note Recognize Coding::を参照してください)。これはファイ
ル、到着メール、その他のEmacsで読む任意のテキストに適用されます。これは
新しくファイルを作成するときに使う、デフォルトのコーディングシステムも指
定します。それぞれの言語環境は、デフォルトのインプットメソッドも指定しま
す。

   言語環境を選択するには、‘current-language-environment’をカスタマイズ
するか、コマンド‘M-x set-language-environment’を使います。このコマンドを
使うとき、どのバッファーがカレントかで違いは生じません。なぜなら、その効
果はEmacsセッションにグローバルで適用されるからです。サポートされている
言語環境の一覧は、変数‘language-info-alist’を参照してください。コマンド
‘C-h L LANG-ENV <RET>’ (‘describe-language-environment’)を使うと、言語環
境LANG-ENVの、より詳細な情報が参照できます。サポートされる言語環境には、
以下が含まれます:

     ASCII、Arabic、 Belarusian、Bengali、 Brazilian Portuguese、
     Bulgarian、 Burmese、Cham、 Chinese-BIG5、Chinese-CNS、
     Chinese-EUC-TW、Chinese-GB、Chinese-GB18030、Chinese-GBK、
     Croatian、Cyrillic-ALT、Cyrillic-ISO、Cyrillic-KOI8、 Czech、
     Devanagari、 Dutch、English、 Esperanto、Ethiopic、 French、
     Georgian、 German、Greek、Gujarati、 Hebrew、IPA、 Italian、
     Japanese、Kannada、 Khmer、Korean、Lao、 Latin-1、Latin-2、
     Latin-3、Latin-4、Latin-5、Latin-6、Latin-7、Latin-8、Latin-9、
     Latvian、Lithuanian、 Malayalam、Oriya、 Persian、Polish、 Punjabi、
     Romanian、 Russian、Sinhala、 Slovak、Slovenian、Spanish、 Swedish、
     TaiViet、 Tajik、Tamil、 Telugu、Thai、 Tibetan、Turkish、 UTF-8、
     Ukrainian、 Vietnamese、Welsh、 Windows-1255

   グラフィカルなディスプレーでは、使用されている言語環境で使われている
スクリプトを表示するために、適切なフォントをもっている必要があります。フ
ォントのセットアップについては、*note Fontsets::を参照してください。

   環境変数‘LC_ALL’、‘LC_CTYPE’、‘LANG’をセットすることにより、使用する
文字セットのlocaleを指定するオペレーティングシステムがいくつかあります
(もしこれらの１つ以上がセットされている場合、特に1番目のものが空でない場
合、それは正にこの目的のためにlocaleを指定しています)。起動の間、Emacsは
文字セットのlocale名を、システムのlocaleエイリアステーブルから探して、そ
の正規化された名前(canonical name)を、変数
‘locale-charset-language-names’および‘locale-language-names’(前者は後者
をオーバーライドします)のエントリーにたいしてマッチし、マッチが見つかっ
たら対応する言語環境を選択します。これはディスプレーテーブルと端末のコー
ディングシステム、localeコーディングシステム、localeに必要な好ましいコー
ディングシステム — そして最後に重要なのは — Emacsがキーボードから送られ
た非ASCII文字をデコードする方法を調整します。

   Emacs実行中に、(‘M-x setenv’を使って)環境変数‘LC_ALL’、‘LC_CTYPE’、
‘LANG’を変更した場合、新しいlocaleにたいする言語環境を再調整するために、
後で‘set-locale-environment’コマンドを呼び出したいと思うかもしれません。

   ‘set-locale-environment’関数は通常、システムメッセージをデコードする
ために、言語環境により確立された、優先されるコーディングシステムを使用し
ます。しかしlocaleが変数‘locale-preferred-coding-systems’のエントリーに
マッチした場合、Emacsはかわりに対応するコーディングシステムを使用します
。たとえばlocaleの‘ja_JP.PCK’が、‘locale-preferred-coding-systems’の
‘japanese-shift-jis’にマッチした場合、Emacsは通常なら
‘japanese-iso-8bit’が使われるような場合でも、エンコーディングにそのコー
ディングシステムを使用します。

   initファイルで明示的にコマンド‘set-language-environment’を使うか、
‘current-language-environment’をカスタマイズすることにより、起動時に選択
された言語環境をオーバーライドできます。

   特定の言語環境LANG-ENVの効果に関する情報を表示するには、コマンド‘C-h
L LANG-ENV <RET>’ (‘describe-language-environment’)を使います。これはこ
の言語環境に有効な言語、文字セットのリスト、コーディングシステム、インプ
ットメソッドを表示します。これはこの言語環境で使われるスクリプトを例示す
る、サンプルテキストも表示します。LANG-ENVに空の入力を与えると、このコマ
ンドは選択されている言語環境を説明します。

   ノーマルフック‘set-language-environment-hook’により、任意の言語環境を
カスタマイズできます。コマンド‘set-language-environment’は、新しい言語環
境をセットアップした後に、このフックを実行します。フック関数は変数
‘current-language-environment’をチェックすることにより、特定の言語環境を
テストできます。このフックはキーボード入力にたいするコーディングシステム
や端末出力、デフォルトのインプットメソッドなど、特定の言語環境にたいして
非デフォルトのセッティングが必要な場所に設定します

   新しい言語環境のセットアップを開始する前に、
‘set-language-environment’はまずフック‘exit-language-environment-hook’を
実行します。このフックは‘set-language-environment-hook’によるカスタマイ
ズを取り消すのに便利です。たとえば、特定の言語環境にたいして
‘set-language-environment-hook’を使って特別なキーバインドをセットアップ
した場合は、‘exit-language-environment-hook’で通常のキーバインドに復元す
るべきです。


File: emacs-ja.info,  Node: Input Methods,  Next: Select Input Method,  Prev: Language Environments,  Up: International

22.3 インプットメソッド
=======================

“インプットメソッド(IM: input method)”は、対話的入力のために具体的にデザ
インされた、一種の文字変換です。Emacsでは、各言語はそれ自身のインプット
メソッドをもっています。同じ文字を使う複数の言語で、1つのインプットメソ
ッドを共有できます。複数のインプットメソッドをサポートする言語もあります
。

   一番簡単な種類のインプットメソッドは、ASCII文字を他のアルファベットに
マッピングすることにより機能します。これによりASCIIのかわりに他のアルフ
ァベットを使うことが可能になります。GreekとRussianのインプットメソッドは
この方式で機能します。

   より強力なテクニックがコンポジション(composition: 複合)です。これは文
字のシーケンスを1つの文字に変換します。Europeanのインプットメソッドの多
くが、アクセント文字を後(または前)に続けた文字シーケンスから、1つの非
ASCII文字を生成するためにコンポジションを使います。たとえば、インプット
メソッドのいくつかは、‘o ^’のシーケンスを1つのアクセントつき文字に変換し
ます。これらのインプットメソッドは、それら自身では特別なコマンドをもちま
せん。これらすべてが行うのは、文字シーケンスを複合して、プリント文字にす
ることです。

   音節記号(syllabic scripts)のためのインプットメソッドは通常、マッピン
グと、それに続けてコンポジションを使います。ThaiとKoreanのためのインプッ
トメソッドは、この方式で機能します。最初に複数の文字が、特定の音や口調の
ためのシンボルにマッピングされます。次にこれらシンボルのシーケンスから音
節全体を作り、それを1つの音節記号にマッピングします。

   ChineseとJapaneseには、さらに複雑な方式が必要です。Chineseのインプッ
トメソッドでは、最初にChineseの単語の音声スペルを入力するか(特にインプッ
トメソッド‘chinese-py’)、文字の一部をシーケンスとして入力します(インプッ
トメソッド‘chinese-4corner’、‘chinese-sw’など)。通常1つの入力シーケンス
は、多くのChinese文字に対応します。‘C-f’、‘C-b’、‘C-n’、‘C-p’(または矢印
キー)、またはこの状況では特別な意味をもつ数字を指定することにより、意図
するものを選択します。

   文字の候補は、概念的には複数の行にアレンジされ、各行は10個の候補をも
ちます。通常Emacsは1度に1行をエコーエリアに表示します。行頭に‘(I/J)’が表
示され、これはトータルJ行中、I番目の行かを示します。‘C-n’または‘C-p’をタ
イプすると、次または前の行を表示します。

   ‘C-f’または‘C-b’をタイプすると、カレント行の候補の間を前方または後方
に移動します。これを行うとき、Emacsはカレント候補を特別な色でハイライト
します。‘C-<SPC>’とタイプすると、カレント候補を選択して、それを入力に使
用します。各行の候補には番号も付けられています。この番号は各候補の前に表
示されます。番号をタイプすると、カレント行の番号に関連付けられた候補を選
択し、それを入力に使用します。

   これらChineseのインプットメソッドでは、<TAB>はすべての文字候補をバッ
ファーに表示します。候補の1つを‘mouse-2’でクリックすることにより選択しま
す。‘C-f’、‘C-b’、‘C-n’、‘C-p’、および数字キーは通常どおり機能しますが、
それらはエコーエリアではなく、文字候補を表示したバッファーをハイライトし
ます。

   Japaneseのインプットメソッドでは、最初に音声スペルを使って単語全体を
入力します。つぎに単語がバッファーに入った後で、より大きな辞書を使って
Emacsがそれを1つ以上の文字に変換します。1つの音声スペルは、いくつかの
Japaneseの単語に対応します。これらの1つを選択するには、‘C-n’または
‘C-p’を使って候補を巡回します。

   インプットメソッドをオフにして、入力した文字シーケンスが複合されない
ようにするのが便利なときがあります。たとえばインプットメソッド
‘latin-1-postfix’では、シーケンス‘o ^’は、アクセントつきの‘o’に複合され
ます。これらの文字を個別に入力したいときはどうすればよいでしょう?

   1つは、アクセントを2度タイプする方法です。これは文字とアクセントを個
別に入力するための特別な機能です。たとえば‘o ^ ^’により、2つの文字‘o^’が
得られます。他の方法としては‘o’の後に別の文字 — 複合されない何か別の文字
— を入力してすぐにそれを削除する方法です。たとえば‘o o <DEL> ^’とタイプ
することにより、‘o’と‘^’を個別に得ることができます。もう1つは、より一般
的ですがタイプが容易とは言えない方法で、2つの文字が欠号されるのを防ぐた
めに、文字の間で‘C-\\ C-\\’を使用する方法です。これは、コマンド
‘C-\\’(‘toggle-input-method’)を2回使用しています。 *note Select Input
Method::を参照してください。

   ‘C-\ C-\’は、インクリメンタル検索の中で使うのが特に便利です。なぜなら
これは複合される文字が入力されるのを待つのを止めて、それまでに入力した文
字で検索を開始するからです。

   現在のインプットメソッドを使って、ポイント位置の後ろの文字を入力する
方法を探すには、‘C-u C-x =’をタイプします。*note Position Info::を参照し
てください。

   変数‘input-method-highlight-flag’および‘input-method-verbose-flag’は
、インプットメソッドで何が起きているかを告げる方法を制御します。
‘input-method-highlight-flag’が非‘nil’の場合、部分的な入力シーケンスがバ
ッファーでハイライトされます(この機能を無効にしているインプットメソッド
もあります)。‘input-method-verbose-flag’が非‘nil’の場合、次にタイプでき
る文字の一覧をエコーエリア(ただしミニバッファーにいるときは除く)に表示し
ます。

   フック変数‘quail-activate-hook’に関数で変更を行うことにより、入力メソ
ッドが機能する方法を変更できます。*note Hooks::を参照してください。たと
えば、関数‘quail-translation-keymap’によりリターンされるキーマップ内のキ
ーバインディングを、‘define-key’を使用して、定義することによりその入力メ
ソッドのいくつかのキーを再定義できます。*note Init Rebinding::を参照して
ください。

   キーボードにない文字をタイプする他の方法は、‘C-x 8 <RET>’
(‘insert-char’)を使って、Unicode名またはコードポイント(code-point)にもと
づいて1つの文字を挿入する方法です。*note Inserting Text::を参照してくだ
さい。


File: emacs-ja.info,  Node: Select Input Method,  Next: Coding Systems,  Prev: Input Methods,  Up: International

22.4 インプットメソッドの選択
=============================

‘C-\’
     選択されたインプットメソッドを有効または無効にします
     (‘toggle-input-method’)。

‘C-x <RET> C-\ METHOD <RET>’
     カレントバッファーにたいして、新しいインプットメソッドを選択します
     (‘set-input-method’)。

‘C-h I METHOD <RET>’
‘C-h C-\ METHOD <RET>’
     インプットメソッドMETHODの説明を表示します
     (‘describe-input-method’)。デフォルトでは、(もしあれば)カレントのイ
     ンプットメソッドを説明します。これは特定のインプットメソッドの使い
     方に関する、すべての詳細説明を表示します。

‘M-x list-input-methods’
     サポートされている、すべてのインプットメソッドのリストを表示します
     。

   カレントバッファーにたいするインプットメソッドを選択するには、‘C-x
<RET> C-\’ (‘set-input-method’)を使います。このコマンドはミニバッファー
からインプットメソッドの名前を読み取ります。この名前は通常、それが使われ
ることを意図した言語環境で開始されます。変数‘current-input-method’は選択
されたインプットメソッドを記録します。

   インプットメソッドは非ASCII文字を表すために、さまざまなASCII文字のシ
ーケンスを使います。インプットメソッドを一時的にオフにできると便利なとき
もあります。そのようなときは‘C-\’ (‘toggle-input-method’)をタイプします
。インプットメソッドを再度有効にするには、もう1度‘C-\’をタイプします。

   ‘C-\’をタイプしたときに、まだインプットメソッドが選択されていない場合
、インプットメソッドを指定するように求めます。これはインプットメソッドを
指定する‘C-x <RET> C-\’を使ったときと同じ効果です。

   ‘C-u C-\’のようにプレフィクス引数を指定した場合、
‘toggle-input-method’は常にインプットメソッドを尋ねます。このときデフォ
ルトとして提案されるのは、もっとも最近選択されたインプットメソッドです。

   言語環境の選択により、さまざまなバッファーで使用するデフォルトのイン
プットメソッドが指定されます。デフォルトのインプットメソッドがある場合、
‘C-\’とタイプしてカレントバッファーでそれを選択できます。変数
‘default-input-method’はデフォルトのインプットメソッドを指定します
(‘nil’は、それが存在しないことを意味します)。

   複数の異なるインプットメソッドをサポートする言語環境では、
‘set-language-environment’で選択されるデフォルトとは違うインプットメソッ
ドを使いたいときもあるでしょう。‘set-language-environment-hook’を使って
、特定の言語環境にたいして異なるデフォルトのインプットメソッドを使うよう
Emacsに指示できます(*note set-language-environment-hook: Language
Environments.を参照してください)。たとえば:

     (defun my-chinese-setup ()
       "Set up my private Chinese environment."
       (if (equal current-language-environment "Chinese-GB")
           (setq default-input-method "chinese-tonepy")))
     (add-hook 'set-language-environment-hook 'my-chinese-setup)

これは言語環境をChinese-GB languageに選択したときは、常にデフォルトのイ
ンプットメソッドを‘chinese-tonepy’にセットします。

   特定のインプットメソッドを自動的にアクティブにするようEmacsに指示でき
ます。たとえば:

     (add-hook 'text-mode-hook
       (lambda () (set-input-method "german-prefix")))

これはTextモードで自動的にインプットメソッド‘german-prefix’をアクティブ
にします。

   英文字スクリプトのためのいくつかのインプットメソッドは、それらのスク
リプトで一般的に使用されているさまざまなキーボードエミュレートするために
、(実質的には)他のアルファベットに再マッピングすることにより機能します。
この再マッピングがどのように正しく行われるかは、実際のキーボードレイアウ
トに依存します。キーボードがどのレイアウトなのかを指定するには、コマンド
‘M-x quail-set-keyboard-layout’を使います。

   コマンド‘M-x quail-show-key’を使って、ポイントの後ろにある文字を入力
するために、選択されたキーボードレイアウトの、どのキー(またはキーシーケ
ンス)をタイプすればよいのか表示できます。コマンド‘C-u C-x =’もこの情報と
、それに加えてその文字に関する他の情報を表示します。

   ‘M-x list-input-methods’は、サポートされているすべてのインプットメソ
ッドを一覧します。この一覧は各インプットメソッドの情報と、モードラインに
表示される文字列を表示します。


File: emacs-ja.info,  Node: Coding Systems,  Next: Recognize Coding,  Prev: Select Input Method,  Up: International

22.5 コーディングシステム
=========================

さまざまな言語のユーザーは、多少の差はあれ、それらを表示するための標準の
コーディングシステムを確立しています。Emacsはこれらのコーディングシステ
ムを、内部的に使用しません。データを読み込むときは、さまざまなコーディン
グシステムからEmacs独自のコーディングシステムに変換し、データを書き込む
ときには、内部コーディングシステムから他のコーディングシステムに変換しま
す。ファイルの読み書き、端末とのやりとり、サブプロセスとのデータ交換にお
いて、変換が可能です。

   Emacsは各コーディングシステムに名前を割り当てます。ほとんどのコーディ
ングシステムは、1つの言語で使用され、コーディングシステムの名前は、言語
の名前で始まります。複数の言語で使用されるコーディングシステムもあります
。これらのコーディングシステムの名前は、通常‘iso’で始まります。
‘no-conversion’、‘raw-text’、‘emacs-internal’のような特別なコーディング
システムもあります。

   まとめて“コードページ(codepages)”として知られる、特別なクラスのコーデ
ィングシステムは、MS-WindowsおよびMS-DOSのソフトウェアーによりエンコード
されたテキストをサポートするためにデザインされています。これらのコーディ
ングシステムの名前は‘cpNNNN’という形式で、NNNNは3桁から4桁のコードページ
番号です。これらのコーディングもほかのコーディングシステムと同様に使うこ
とができます。たとえばコードページ850でエンコードされたファイルをvisitす
るには、‘C-x <RET> c cp850 <RET> C-x C-f FILENAME <RET>’とタイプします。

   非ASCII文字のさまざまな表現の変換に加えて、コーディングシステムは行末
変換(end-of-line conversion)も行います。Emacsは、ファイル内の行の区切り
方として、3つの異なる変換を扱います。つまり、改行(Unix)、復帰改行(DOS)、
復帰(Mac)です。

‘C-h C CODING <RET>’
     コーディングシステムCODINGの説明を表示します
     (‘describe-coding-system’)。

‘C-h C <RET>’
     カレントで使用しているコーディングシステムCODINGの説明を表示します
     (‘describe-coding-system’)。

‘M-x list-coding-systems’
     サポートされているすべてのコーディングシステムのリストを表示します
     。

   コマンド‘C-h C’ (‘describe-coding-system’)は、特定のコーディングシス
テムについて、それらのコーディングシステムで規定されている、行末変換も含
めた情報を表示します。引数にコーディングシステム名を指定できます。引数が
空のときには、さまざまな目的のために選択されている、現在のコーディングシ
ステムの、カレントバッファにたいするものとデフォルトの両方について表示す
るとともに、コーディングシステムを認識するための優先順位表を表示します
(*note Recognize Coding::を参照してください)。

   サポートされているすべてのコーディングシステムのリストを表示するには
、‘M-x list-coding-systems’とタイプします。表示されるリストは、モードラ
インに表示される文字も含めて、各コーディングシステムの情報を提供します。

   リストに表示される各コーディングシステム — ただし何の変換も行わない
‘no-conversion’は除く — は、プリントする文字をどのように変換するか、しな
いかを指定しますが、改行変換については、各ファイル内容にもどづいて決定す
るので選択をしません。たとえばファイルが行区切りに改行復帰文字を使ってい
るように見えるときは、DOSの改行変換を使います。

   リストされた各コーディングシステムは、改行変換を厳密に指定する3つの変
種があります。

‘...-unix’
     何の改行変換も行いません。ファイルは行区切りに改行文字を使っている
     と仮定します(これは通常Unix、GNUシステム、macOSで使われている慣習で
     す)。

‘...-dos’
     ファイルが行区切りに改行復帰文字を使っていると仮定し、適切な変換を
     行います(これは通常Microsoftシステムで使われている慣習です(1))。

‘...-mac’
     ファイルが行区切りに復帰文字を使っていると仮定し、適切な変換を行い
     ます(これはクラシックなMac OSで使われていた慣習です)。

   これらのコーディングシステムの変種は、それらが完全に予測可能なため、
簡略化のために‘list-coding-systems’の表示からは省略されています。たとえ
ばコーディングシステム‘iso-latin-1’は‘iso-latin-1-unix’、
‘iso-latin-1-dos’、‘iso-latin-1-mac’という変種をもちます。

   コーディングシステム‘unix’、‘dos’、‘mac’は、それぞれ
‘undecided-unix’、‘undecided-dos’、‘undecided-mac’の別名です。これらのコ
ーディングシステムは改行変換だけを指定し、文字コード変換はテキスト字体か
ら推論されるよう残します

   コーディングシステム‘raw-text’は、主にASCIIテキストのファイルに適して
いますが、ファイルには、非ASCII文字の符号を意味しない127を越えるバイト値
が含まれるかもしれません。‘raw-text’では、 Emacsはそれらのバイト値を変更
せずにコピーし、カレントバッファーの‘enable-multibyte-characters’を
‘nil’にセットして、それらは適切に解釈されるます。‘raw-text’は、出会った
データに基づく通常の方法で行末変換を処理し、使用する行末変換を指定する変
種も3つもちます。

   対照的に、コーディングシステム‘no-conversion’は、いかなる文字コード変
換 — 非ASCIIバイト値や行末にたいしても — を行いません。これは、バイナリ
ーファイル、tarファイル、 そのまま処理する必要があるその他のファイルを読
み書きするのに便利です。これも‘enable-multibyte-characters’を‘nil’にセッ
トします。

   いかなる種類の変換もしないでファイルを編集するもっとも簡単な方法は、
‘M-x find-file-literally’コマンドを使うことです。このコマンドは、
‘no-conversion’を使い、ファイルを見る前にファイルの内容を変換するかもし
れない、Emacsのその他の機能を抑制します。*note Visiting::を参照してくだ
さい。

   コーディングシステム‘emacs-internal’(または‘utf-8-emacs’)は、Emacs内
部エンコーディングのままで格納された、非ASCII文字を含むファイルであるこ
とを意味します。これは出会ったデータに基づいて行末変換を処理し、行末変換
の種類を指定する通常の3つの変種を持ちます。

   ---------- Footnotes ----------

   (1) これはMIMEの‘text/*’の本体、および他のネットワーク転送のコンテキ
ストでも指定されています。これはEmacsが直接サポートしないSGMLリファレン
ス構文のrecord-start/record-endとは異なります。


File: emacs-ja.info,  Node: Recognize Coding,  Next: Specify Coding,  Prev: Coding Systems,  Up: International

22.6 コーディングシステムの認識
===============================

Emacsはテキストを読み込むとき、どのコーディングシステムが使われているか
認識しようと試みます。これはファイルの読み込み、サブプロセスからの出力、
X選択からのテキストなど、さまざまです。Emacsは大抵の場合 — 自分の好みを
1度指定しておけば、自動的に正しいコーディングシステムを選択できます。

   データにどのバイトシーケンスが出現するかにより、認識あるいは識別され
るコーディングシステムもいくつかあります。しかし識別される可能性さえない
コーディングシステムもあります。たとえばLatin-1とLatin-2を識別する方法は
ありません。これらは同じバイト値を異なる意味で使用します。

   Emacsはこのようなシチュエーションを、コーディングシステムの優先リスト
により処理します。Emacsがファイルを読み込むときは常に、それに使用するコ
ーディングシステムを指定しなければ、Emacsはデータを各コーディングシステ
ムに照らしてチェックし、それを優先順位の上から順に、データに適合するコー
ディングシステムが見つかるまで続けます。そして、そのコーディングシステム
で、ファイル内容が表示できると仮定して変換を行います。

   コーディングシステムの優先リストは、選択されている言語環境に依存しま
す(*note Language Environments::を参照してください)。たとえばFrenchを使
うのなら、おそらくEmacsにはLatin-2よりLatin-1を選んでほしいでしょう。
Czechを使うなら、おそらくLatin-2のほうがよいでしょう。これが言語環境を指
定する理由の1つです。

   しかし、コマンド‘M-x prefer-coding-system’を使って、優先リストの詳細
を変更できます。このコマンドはミニバッファーからコーディングシステムの名
前を読み取り、それを優先リストの先頭に追加して、他のすべてのものより優先
するようにします。このコマンドを数回使うと、使用するごとに優先リストの先
頭に1つの要素が追加されます。

   ‘iso-8859-1-dos’のような、行末変換を指定したコーディングシステムを使
うと、‘iso-8859-1’を優先して認識を試み、その際DOSの行末変換を使うことを
Emacsに指示することになります。

   ファイルにたいして使用するコーディングシステムをファイル名が示してい
ることがあります。変数‘file-coding-system-alist’は、この対応関係を指定し
ます。このリストに要素を追加する特別な関数は、
‘modify-coding-system-alist’です。たとえば、すべての‘.txt’の読み書きに、
コーディングシステム‘chinese-iso-8bit’を使用したいなら、つぎのLisp式を実
行します:

     (modify-coding-system-alist 'file "\\.txt\\'" 'chinese-iso-8bit)

1つ目の引数は‘file’、2番目の引数はこれを適用するファイルを決定する正規表
現、3番目の引数は、これらのファイルに対して使用するコーディングシステム
です。

   Emacsはファイルの内容にもとづいて、使用する行末変換の種類を認識します
。復帰のみ、あるいは復帰改行のシーケンスだけであれば、対応する行末変換を
選択します。変数‘inhibit-eol-conversion’を非‘nil’にセットすることにより
、行末変換の自動的な使用を抑止できます。これを行うとDOSスタイルのファイ
ルは、バッファー内に可視の‘^M’という文字を表示します。モードラインの左端
に目立たないように表示される改行タイプ指示‘(DOS)’より、こちらのほうを好
む人もいます。

   デフォルトでは、コーディングシステムの自動検知はエスケープシーケンス
を検出します。文字シーケンスがエスケープ文字で開始されていて、そのシーケ
ンスが有効なISO-2022であれば、それはEmacsにファイルをデコードするエンコ
ーディングに、ISO-2022を使うことを告げています。

   しかし、ファイルの中のエスケープシーケンスを、そのまま読み取りたい場
合もあるでしょう。そのような場合、変数‘inhibit-iso-escape-detection’を非
‘nil’にセットします。これにより、コード検知はエスケープシーケンスを無視
するようになり、ISO-2022エンコーディングは使用されません。この結果として
、すべてのエスケープシーケンスがバッファー内で可視になります。

   変数‘inhibit-iso-escape-detection’のデフォルト値は‘nil’です。わたした
ちは特別な操作を除いて、これを変更しないことを推奨します。なぜなら、
EmacsディストリビューションのEmacs Lispソースファイルのいくつかは、コー
ディングシステム‘iso-2022-7bit’でエンコードされた非ASCII文字を含んでおり
、エスケープシーケンス検知を抑止しているときにこれらのファイルをvisitす
ると、正しくデコードされないからです。

   変数‘auto-coding-alist’および‘auto-coding-regexp-alist’は、それぞれフ
ァイル名に含まれる特定パターン、およびファイルに含まれる特定パターンによ
りコーディングシステムを指定する一番強い方法です。これらの変数は、ファイ
ル自身に含まれる‘-*-coding:-*-’タグさえオーバーライドします。たとえば、
Emacsはtarおよびアーカイブファイルに、‘auto-coding-alist’を使います。こ
れはアーカイブのメンバーファイルに‘-*-coding:-*-’が含まれている場合、
Emacsが混乱してそれをファイル全体に適用するのを防ぎます。

   コーディングシステムを指定する他の方法は、変数
‘auto-coding-functions’を使う方法です。たとえばビルトインの1つ
‘auto-coding-functions’は、XMLファイルにたいするエンコーディングを検知し
ます。前の2つと異なり、この変数は‘-*-coding:-*-’タグをオーバーライドしま
せん.


File: emacs-ja.info,  Node: Specify Coding,  Next: Output Coding,  Prev: Recognize Coding,  Up: International

22.7 ファイルのコーディングシステムの指定
=========================================

Emacsがファイルのエンコーディングを正しく認識しなかった場合、‘C-x <RET>
r’ (‘revert-buffer-with-coding-system’)で、正しいコーディングシステムで
ファイルを再読み込みできます。このコマンドは、使用するコーディングシステ
ムの入力を求めます。ファイルのデコードに実際に使われているコーディングシ
ステムを見るには、モードラインの左端の近くのコーディングシステムのニーモ
ニック文字を見るか、‘C-h C’ (‘describe-coding-system’)をタイプします。

   特定のファイルのコーディングシステムを指定するのに、そのファイル自身
の最初に‘-*-...-*-’構成を指定するか、ファイルの最後にローカル変数リスト
(*note File Variables::を参照してください)を使用できます。これは
‘coding’という名前の“変数”に、値を定義することにより行われます。Emacsは
実際には変数‘coding’をもっていません。かわりに変数をセットして、特定のフ
ァイルにたいしてコーディングシステムを指定するのにこれを使います。たとえ
ば‘-*-mode: C; coding: latin-1; -*-’は、Latin-1コーディングシステム、同
様にCモードを指定することを指示します。ファイルの中でコーディングを明示
的に指定した場合、これは‘file-coding-system-alist’をオーバーライドします
。


File: emacs-ja.info,  Node: Output Coding,  Next: Text Coding,  Prev: Specify Coding,  Up: International

22.8 出力のためのコーディングシステムの選択
===========================================

Emacsがバッファーにたいして1度コーディングシステムを選択すると、そのコー
ディングシステムは、‘buffer-file-coding-system’に記録されます。これによ
り‘save-buffer’や‘write-region’などの、バッファーからファイルに書き込む
際のデフォルトに、それを使用するようになります。
‘set-buffer-file-coding-system’を使って、バッファーのコーディングシステ
ムとは異なるコーディングシステムで、ファイルに書き込むよう指定できます
(*note Text Coding::を参照してください)。

   Emacsがサポートする任意の文字を、任意のEmacsバッファーに挿入できます
が、ほとんどのコーディングシステムは、それらの文字のサブセットしか処理す
ることができません。したがって挿入した文字は、そのバッファーを保存するの
に使われるコーディングシステムではエンコードできないかもしれません。たと
えば、‘iso-8859-2’でエンコードされたPolishのファイルをvisitして、それに
Russianの単語を追加することは可能です。このバッファーを保存するとき、
Emacsは‘buffer-file-coding-system’の現在の値を使用できません。なぜなら追
加された文字が、そのコーディングシステムではエンコードできないからです。

   これが発生した場合、Emacsは(‘M-x prefer-coding-system’または‘M-x
set-language-environment’によりセットされた)もっとも適したコーディングシ
ステムを試します。そのコーディングシステムがバッファーのすべての文字をエ
ンコードできたら、Emacsはそれを使って、その値を
‘buffer-file-coding-system’に格納します。そうでなければEmacsはバッファー
内容をエンコードするのに適したコーディングシステムのリストを表示して、そ
れらのコーディングシステムを1つ選ぶよう求めます。

   メールメッセージに適さない文字を入力した場合、Emacsの振る舞いは若干異
なります。この場合、追加でMIMEメッセージに推奨されたもっとも適したコーデ
ィングシステムかをチェックします。もしそうでなければ、この事実を知らせ、
他のコーディングシステムの入力を求めます。これにより、メール受信者のメー
ルソフトがデコードするのが困難なエンコードで、無意識にメッセージを送るよ
うなことがなくなります(入力をもとめられたときに、適さないコーディングシ
ステムを選ぶ、という選択肢もまだ残っています)。

   メールメッセージを送信するとき、Emacsはメッセージテキストのエンコーデ
ィングに使うコーディングシステムを決定する、4つの異なる方法をもっていま
す。最初にバッファー自身の‘buffer-file-coding-system’が非‘nil’なら、それ
を使います。次に‘sendmail-coding-system’が非‘nil’なら、それを使います。
3番目は‘default-sendmail-coding-system’の値を使います。上述した値のすべ
てが‘nil’の場合、Emacsは、新たなファイルに使用されるデフォルトコーディン
グシステム(選択された言語環境により制御される、
‘buffer-file-coding-system’の値)を使用して送信メールをエンコードします。


File: emacs-ja.info,  Node: Text Coding,  Next: Communication Coding,  Prev: Output Coding,  Up: International

22.9 ファイルのテキストにたいするコーディングシステムの指定
===========================================================

Emacsがファイル内容にたいして、自動的に正しいコーディングシステムを選択
しない場合、コーディングシステムを指定するために、以下のコマンドを使用で
きます。

‘C-x <RET> f CODING <RET>’
     カレントバッファーのファイルを、コーディングシステムCODINGを使って
     保存または再visitします(‘set-buffer-file-coding-system’)。

‘C-x <RET> c CODING <RET>’
     直後に続くコマンドのコーディングシステムにCODINGを指定します
     (‘universal-coding-system-argument’).

‘C-x <RET> r CODING <RET>’
     コーディングシステムCODINGを使って、現在のファイルを再visitします
     (‘revert-buffer-with-coding-system’)。

‘M-x recode-region <RET> RIGHT <RET> WRONG <RET>’
     コーディングシステムWRONGを使ってデコードされたリージョンを、かわり
     にコーディングシステムRIGHTを使ってデコードします。

   コマンド‘C-x <RET> f’ (‘set-buffer-file-coding-system’)は、カレントバ
ッファーのファイルのコーディングシステムをセットします(たとえばファイル
を保存またはリバートするときに使うコーディングシステム)。これはミニバッ
ファーを使ってコーディングシステムを指定します。モードラインのコーディン
グシステムインディケーターを‘mouse-3’でクリックしても、このコマンドを呼
び出すことができます。

   バッファーのすべての文字を処理できないコーディングシステムを指定した
場合、Emacsは問題となる文字について警告します。そしてそのバッファーを保
存するときのコーディングシステムの選択を求めます。

   このコマンドを、カレントバッファーのエンコーディングの際の改行変換の
指示に使うこともできます(*note end-of-line conversion: Coding Systems.を
参照してください)。たとえば‘C-x <RET> f dos <RET>’は、カレントバッファー
を、DOSスタイル(行末が改行復帰文字)で保存します。

   ファイルにたいしてコーディングシステムを指定する他の方法は、ファイル
をvisitするときに指定する方法です。最初にコマンド‘C-x <RET> c’
(‘universal-coding-system-argument’)を使います。このコマンドはミニバッフ
ァーを使ってコーディングシステムを読み取ります。ミニバッファーを抜けた後
、_その直後に続くコマンド_に、指定したコーディングシステムが使用されます
。

   たとえば直後に続くコマンドが‘C-x C-f’の場合、そのコーディングシステム
を使ってファイルを読み込みます(そして後で保存するときのために、そのコー
ディングシステムを記録します)。直後に続くコマンドが‘C-x C-w’の場合、その
コーディングシステムを使ってファイルを書き込みます。‘C-x <RET> f’のかわ
りに、この方法で保存するときのコーディングシステムを指定した場合、バッフ
ァーにそのコーディングシステムが処理できない文字が含まれていても警告はさ
れません。

   ‘C-x i’や‘C-x C-v’、同様に‘C-x C-f’の別ウィンドウ版‘C-x <RET> c’など
、その他のファイルコマンドも指定されたコーディングシステムに影響されます
。そして‘M-x shell’ (*note Shell::を参照してください)を含む、サブプロセ
スを開始するコマンドも影響を受けます。直後に続くコマンドがコーディングシ
ステムを使用しない場合、‘C-x <RET> c’は何の影響も与えません。

   変換をせずにファイルをvisitする簡単な方法は、‘M-x
find-file-literally’コマンドです。*note Visiting::を参照してください。

   変数‘buffer-file-coding-system’のデフォルト値は、新しいファイルを作成
するときに選択されるコーディングシステムを指定します。これは新しいファイ
ルを作成するときや、バッファーを作成してそれをファイルに保存するときに適
用されます。言語環境の選択は、この変数を言語環境にたいして適した、デフォ
ルトのコーディングシステムにセットします。

   間違ったコーディングシステムでファイルをvisitしたときは、‘C-x <RET>
r’ (‘revert-buffer-with-coding-system’)でこれを正すことができます。これ
は指定したコーディングシステムを使って、現在のファイルを再visitします。

   テキストの一部が、すでに間違ったコーディングシステムでバッファーに挿
入されてしまった場合、‘M-x recode-region’を使ってデコードしなおすことが
できます。これは正しいコーディングシステムと、実際に使われた間違ったコー
ディングシステムの入力を求め、変換を行います。最初にリージョンを間違った
コーディングシステムでエンコードして、その後で正しいコーディングシステム
でデコードします。


File: emacs-ja.info,  Node: Communication Coding,  Next: File Name Coding,  Prev: Text Coding,  Up: International

22.10 プロセス間通信にたいするコーディングシステム
==================================================

このセクションでは、他のプロセスと通信するときに使うコーディングシステム
を指定する方法を説明します。

‘C-x <RET> x CODING <RET>’
     選択したテキストを、他のグラフィカルなアプリケーションと送受信する
     ために、コーディングシステムCODINGを使用します
     (‘set-selection-coding-system’)。

‘C-x <RET> X CODING <RET>’
     次回に選択するテキストを、他のグラフィカルなアプリケーションと送受
     信するために、コーディングシステムCODINGを使用します
     (‘set-next-selection-coding-system’)。

‘C-x <RET> p INPUT-CODING <RET> OUTPUT-CODING <RET>’
     カレントバッファーでのサブプロセスの入出力に、コーディングシステム
     INPUT-CODINGとOUTPUT-CODINGを使用します
     (‘set-buffer-process-coding-system’)。

   コマンド‘C-x <RET> x’ (‘set-selection-coding-system’)は、選択したテキ
ストを他のウィンドウアプリケーションに送信するとき、および他のアプリケー
ションで選択されたテキストを受信するときのコーディングシステムを指定しま
す。このコマンドは、このコマンドを再度使って設定をオーバーライドするまで
、以降のすべての選択に適用されます。コマンド‘C-x <RET> X’
(‘set-next-selection-coding-system’)は、Emacsで次に選択されるテキスト、
または次に読み取られるテキストのためのコーディングシステムを指定します。

   変数‘x-select-request-type’は、Xウィンドウシステムからのリクエストに
より、他のアプリケーションで選択されたテキストを受信する際のデータタイプ
を指定します。値が‘nil’(デフォルト)の場合、Emacsは‘UTF8_STRING’、
‘COMPOUND_TEXT’の順に試み、さらにさまざまな経験則を用いて、2つの結果から
より適したものを選択します。どちらも成功しなかったとき、Emacsは
‘STRING’にフォールバックします。‘x-select-request-type’の値が、
‘COMPOUND_TEXT’、‘UTF8_STRING’、‘STRING’、‘TEXT’のうちのどれかであった場
合、Emacsはリクエストされたタイプだけを使用します。値がこれらのシンボル
のリストだった場合、Emacsはリストのリクエストタイプを順に試行し、どれか
が成功するか、すべてを試みるまで続けます。

   コマンド‘C-x <RET> p’ (‘set-buffer-process-coding-system’)は、サブプ
ロセスの入出力のコーディングシステムを指定します。このコマンドはカレント
バッファーに適用されます。サブプロセスは通常、それぞれ自身のバッファーを
もっています。したがってサブプロセスに対応するバッファーでこのコマンドを
実行することにより、特定のサブプロセスとの送受信に使用するコーディングシ
ステムを指定できます。

   サブプロセスを開始するコマンドの直前に‘C-x <RET> c’
(‘universal-coding-system-argument’)を使うことにより、そのプロセスとの通
信で使用するコーディングシステムを指定することもできます。*note Text
Coding::を参照してください。

   デフォルトでは、プロセス通信の入出力は現在の言語環境に依存します。

   変数‘locale-coding-system’は、システムのエラーメッセージや、
‘format-time-string’のフォーマットやタイムスタンプなどの、システム文字列
のエンコードおよびデコードで使用するコーディングシステムを指定します。こ
のコーディングシステムは、Xウィンドウシステムでの非ASCIIキーボードによる
入力のデコード、およびバッチモードのときに標準出力とエラーストリームに送
るテキストのエンコードにも使用されます。通常は環境変数‘LC_ALL’、
‘LC_CTYPE’、‘LANG’のうちの1つで指定される、背景にあるシステムのテキスト
表現(text representation)と互換性のあるコーディングシステムを選択するべ
きです(上記の順番で最初の環境変数の値が空でない場合、それはテキスト表現
を決定します)。


File: emacs-ja.info,  Node: File Name Coding,  Next: Terminal Coding,  Prev: Communication Coding,  Up: International

22.11 ファイル名にたいするコーディングシステム
==============================================

‘C-x <RET> F CODING <RET>’
     ファイル名のエンコードおよびデコードに、コーディングシステム
     CODINGを使用します(‘set-file-name-coding-system’)。

   コマンド‘C-x <RET> F’ (‘set-file-name-coding-system’)は、ファイルの
_名前_に使用するコーディングシステムを指定します。ファイルの_内容_の読み
込みと書き込みには影響がありません。

   実際にこのコマンドが行うのは、変数‘file-name-coding-system’に値をセッ
トすることだけです。変数にコーディングシステムの名前(Lispシンボルか文字
列)をセットすると、Emacsはすべてのファイル操作において、ファイル名のエン
コードにそのコーディングシステムを使用します。これによりファイル名に非
ASCII文字 — または少なくとも指定されたコーディングシステムではエンコード
できる非ASCII文字 — を使うことが可能になります。

   ‘file-name-coding-system’が‘nil’の場合、Emacsは言語環境により選択され
、変数‘default-file-name-coding-system’に格納される、デフォルトのコーデ
ィングシステムを使用します。デフォルトの言語環境では、ファイル名の非
ASCII文字は特別にエンコードはされません。これらはEmacsの内部表現を使って
、ファイルシステム上に表示されます。

   Emacsが、MS-WindowsのNTファミリーの子孫(Windows 2000、XP、および以降
すべてのバージョン)にあたるバージョンで実行されている場合、
‘file-name-coding-system’の値は大部分が無視されます。これはEmacsがデフォ
ルトでUnicodeファイル名を直接渡せるAPIを使用するからです。一方、Windows
9Xでは、ファイル名は変数‘file-name-coding-system’を使ってエンコードされ
ており、この変数にはカレントのシステムロケールにたいして適切なコードペー
ジ(*note codepage: Coding Systems.を参照してください)がセットされている
必要があります。変数‘w32-unicode-filenames’の値は、Emacsがファイル名を引
数とするOS関数を呼び出すUnicode APIを使うかどうかを制御します。この変数
はスタートアップコードにより、Windows 9Xでは‘nil’、新しいバージョンの
MS-Windowsでは‘t’にセットされます。

   *警告: *Emacsセッションの途中で‘file-name-coding-system’(または言語環
境)を変更した場合、すでにvisitしているファイルの名前が、古いコーディング
システムを使えばエンコードできるが、新しいコーディングシステムではエンコ
ードされない(または違ってエンコードされる)という問題が発生します。このよ
うなバッファーをvisitしたファイル名で保存を試みると、間違ったファイル名
で保存するか、エラーが発生します。このような問題が発生したときは‘C-x
C-w’を使って、そのバッファーにたいして新しいファイル名を指定してください
。

   ファイル名をエンコードするとき間違いが発生した場合、コマンド‘M-x
recode-file-name’を使って、ファイル名のコーディングシステムを変更します
。このコマンドは古いコーディングシステムでの既存のファイル名と、変換した
いコーディングシステムの入力を求めます。


File: emacs-ja.info,  Node: Terminal Coding,  Next: Fontsets,  Prev: File Name Coding,  Up: International

22.12 端末入出力にたいするコーディングシステム
==============================================

‘C-x <RET> t CODING <RET>’
     端末の出力に、コーディングシステムCODINGを使用します
     (‘set-terminal-coding-system’)。

‘C-x <RET> k CODING <RET>’
     キーボード入力に、コーディングシステムCODINGを使用します
     (‘set-keyboard-coding-system’)。

   コマンド‘C-x <RET> t’ (‘set-terminal-coding-system’)は、端末出力のた
めのコーディングシステムを指定します。端末出力の文字コードを指定した場合
、端末へのすべての文字出力は、指定したコーディングシステムに変換されます
。

   この機能は、特定の言語または文字セットをサポートするようビルドされた
、特定の文字端末で有用です — たとえばEuropean端末は、ISO Latin文字セット
の1つをサポートします。マルチバイトテキストを使う場合は、端末のコーディ
ングシステムを指定する必要があります。これにより、Emacsは端末が実際にど
の文字を処理できるのか知ることができます。

   デフォルトでは、Emacsが端末タイプまたはlocale指定により、正しいコーデ
ィングシステムを推論できない場合、端末への出力は変換されません。

   コマンド‘C-x <RET> k’ (‘set-keyboard-coding-system’)、または変数
‘keyboard-coding-system’は、キーボード入力のためのコーディングシステムを
指定します。キーボード入力の文字コード変換は、非ASCIIのグラフィック文字
を送信するキーをもつ端末で有用です — たとえば、いくつかの端末はISO
Latin-1、またはそれのサブセットのためにデザインされています。

   デフォルトでは、キーボード入力はシステムのlocale設定にもとづいて変換
されます。端末がlocaleにより暗に指定されるエンコードを実際にはサポートし
ない場合(たとえば、‘M-i’をタイプしたときに非ASCII文字が挿入されるのに気
づいたとき)、エンコーディングをオフにするために
‘keyboard-coding-system’を‘nil’にセットする必要があるでしょう。これは、

     (set-keyboard-coding-system nil)

をinitファイルに記述することにより、行うことができます。

   キーボード入力にたいするコーディングシステムを使用した変換と、インプ
ットメソッドの使用は似通った点があります。これらは両方ともキーボード入力
シーケンスを1つの文字に変換します。しかし、インプットメソッドは人間によ
り対話的に使用されることが便利なようにデザインされており、通常はASCIIの
プリント文字のシーケンスが、変換されたシーケンスになります。通常、コーデ
ィングシステムは非グラフィック文字のシーケンスを変換します。


File: emacs-ja.info,  Node: Fontsets,  Next: Defining Fontsets,  Prev: Terminal Coding,  Up: International

22.13 フォントセット
====================

フォントは通常、1つのアルファベットまたはスクリプトの形状を定義します。
したがってEmacsがサポートするスクリプトの全範囲を表示するには、多くのフ
ォントのコレクションが要求されます。Emacsではこのようなコレクションのこ
とを“フォントセット(fontset)”と呼びます。フォントセットはフォント仕様の
リストとして定義され、それぞれが文字コードのある範囲を処理し、指定された
フォントでカバーしない文字にたいしては他のフォントセットにフォールバック
します。

   それぞれのフォントセットは、フォントと同様に名前をもちます。しかしフ
ォントはシステムに格納されていて、利用可能なフォント名はシステムで定義さ
れていますが、フォントセットはEmacs自身で定義されます。1度フォントセット
を定義したら、1つのフォントを使える場所ならどこでも、フォントセットを名
前で指定して使用することができます。もちろんEmacsのフォントセットに使用
できるのは、システムがサポートするフォントだけです。もしある文字がスクリ
ーン上で空のボックスや16進コードで表示される場合、それは使用しているフォ
ントセットがその文字にたいするフォントをもっていないことを意味します。こ
のような場合や、文字は表示されるが、それが意図したものとは異なる場合、多
分追加のフォントをインストールする必要があるでしょう。オペレーティングシ
ステムにはインストールできるオプションのフォントがあるはずです。またはサ
ポートされたスクリプトのほとんどのフォントを含むGNU Intlfontsパッケージ
をインストールすることもできます。(1)

   Emacsは3つのフォントセットを自動的に作成します。それは“スタンダードフ
ォントセット(standard fontset)”、“スタートアップフォントセット(startup
fontset)”、“デフォルトフォントセット(default fontset)”の3つです。デフォ
ルトフォントセットは、さまざまな非ASCII文字のフォントをもち、他の2つのフ
ォントセットのデフォルトのフォールバック先です(デフォルトフォントをセッ
トしたときは、デフォルトフォントセットではなくデフォルトフォント)。しか
しこれはフォントのファミリー名を指定しないので、これを直接使うと、結果は
少しランダムに思えるかもしれません。Emacsを‘-fn’オプションで実行すること
により、特定のフォントセットを使用するように指示できます。たとえば、

     emacs -fn fontset-standard

‘Font’でフォントセットを指定することもできます(*note X Resources::を参照
してください)。

   使用するフォントセットが何も指定されていない場合、EmacsはASCIIフォン
トを使用し、そのフォントがカバーしない文字にたいするフォールバックに
‘fontset-default’を使用します。名前とは裏腹にスタンダードフォントセット
は、明示的に要求されたときだけ使用されます。

   特定のフォントセットの情報を表示するためには、
‘M-x describe-fontset’コマンドを使用します。これこのコマンドはフォントセ
ットの名前(デフォルトはカレントフレームで使用されているフォントセット)を
尋ねて、文字のすべての部分範囲(subrange)と、フォントセット内でそれらに割
り当てられたフォントを表示します。

   フォントセットは、すべての文字コードにたいしてフォントを指定する必要
はありません。フォントセットが特定の文字にたいしてフォントを指定していな
い、または指定したフォントがシステムに存在しない場合、フォントセットは文
字を正しく表示できません。この場合、その文字は16進コード、細いスペース、
または空のボックスがかわりに表示されます(詳細は、*note glyphless
characters: Text Display.を参照してください)。

   ---------- Footnotes ----------

   (1) EmacsをXで実行している場合、以下のようにして新しくインストールし
たフォントの場所を、X serverに指示する必要があるでしょう:
     xset fp+ /usr/local/share/emacs/fonts
     xset fp rehash


File: emacs-ja.info,  Node: Defining Fontsets,  Next: Modifying Fontsets,  Prev: Fontsets,  Up: International

22.14 フォントセットの定義
==========================

XでEmacsを実行している場合、Emacsは‘standard-fontset-spec’の値により、ス
タンダードフォントセットを作成します。このフォントセットの名前は、

     -*-fixed-medium-r-normal-*-16-*-*-*-*-*-fontset-standard

または単に短く‘fontset-standard’です。

   GNUstep、およびmacOSではスタンダードフォントセットは、
‘ns-standard-fontset-spec’の値を使って作成され、MS Windowsでは
‘w32-standard-fontset-spec’の値を使って作成されます。

   スタンダードフォントセットのボールド、イタリック、ボールドイタリック
などの変種も自動的に作成されます。これらの変種の名前には‘medium’のかわり
に‘bold’、または‘r’のかわりに‘i’、またはその両方が使われます。

   Emacsは‘Font’リソース、または‘-fn’引数で指定した任意のデフォルト
ASCIIフォント、またはEmacsが起動時に見つけたデフォルトフォントにもとづい
て、フォントセットを自動的に作成します。これが“スタートアップフォントセ
ット(startup fontset)”で、名前は‘fontset-startup’です。Emacsは
CHARSET_REGISTRYフィールドを‘fontset’、CHARSET_ENCODINGフィールドを
‘startup’で置き換えてフォントセットを生成して、その置き換えた文字列をフ
ォントセットの指定に用います。

   たとえば以下の形式でEmacsを起動した場合、

     emacs -fn "*courier-medium-r-normal--14-140-*-iso8859-1"

Emacsは以下のフォントセットを生成して、それをXウィンドウの初期フレームに
使用します:

     -*-courier-medium-r-normal-*-14-140-*-*-*-*-fontset-startup

   スタートアップフォントセットは、そのフォントでサポートされているすべ
ての文字にたいして指定したフォントか、異なるregistryまたはencodingのフォ
ントを使用し、それ以外の文字は‘fontset-default’にフォールバックして表示
するでしょう。

   Xリソースの‘Emacs.Font’では、フォントセット名を実際のフォント名のよう
に指定できます。しかし‘Emacs*Font’のようなワイルドカードを使ったリソース
にフォントセット名を指定しないように注意してください — ワイルドカードを
使った指定は、メニューのようなフォントセットを処理できないものも含めて、
他のさまざまな目的にも適用されます。*note X Resources::を参照してくださ
い。

   ‘Fontset-N’という名前のXリソースを使って、追加のフォントセットを指定
できます。ここでNは0から始まる整数です。リソースの値はつぎのような形式で
す:

     FONTPATTERN, [CHARSET:FONT]...

ここでFONTPATTERNは、最後の2つのフィールドを除いて、標準のXフォント名の
形式です(前のfontset-startupの例を参照)。最後の2つのフィールドは、
‘fontset-ALIAS’の形式をもつべきです。

   すべてのフォントセットには2つの名前、長い名前と短い名前があります。長
い名前はFONTPATTERNです。短い名前は‘fontset-ALIAS’で、これは長い名前の最
後の2つのフィールドです(たとえば、スタートアップ時に自動的に作成されるフ
ォントセットは‘fontset-startup’)。どちらの名前でもフォントセットを参照で
きます。

   ‘CHARSET:FONT’という構成は、ある文字セットにたいして、(このフォントセ
ットでは)どのフォントを使用するかを指定します。ここでCHARSETは、文字セッ
トの名前で、FONTはその文字セットに使用するフォントです。1つのフォントセ
ットの定義の中で、この構成を何度でも使用できます。

   他の文字セットにたいしては、EmacsはFONTPATTERNにもとづいて選択します
。これは文字セットを記述する値で‘fontset-ALIAS’を置き換えます。ASCII文字
フォントにたいしては、‘fontset-ALIAS’を‘ISO8859-1’で置き換えます。

   これに加えて、複数の連続するフィールドがワイルドカードの場合、Emacsは
それらを1つのワイルドカードにまとめます。これは、オートスケールされたフ
ォントの使用を避けるためです。大きいフォントをスケーリングしたフォントは
編集に適しておらず、小さいフォントをスケーリングしたフォントも同様です。
なぜならEmacsがそうするように、もともと小さなフォントを使うほうがよいか
らです。

   したがって、FONTPATTERNが以下の場合、

     -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24

ASCII文字にたいするフォント指定は、以下のようになるでしょう:

     -*-fixed-medium-r-normal-*-24-*-ISO8859-1

そしてChinese GB2312文字にたいするフォント指定は、以下のようになるでしょ
う:

     -*-fixed-medium-r-normal-*-24-*-gb2312*-*

   上記のフォント指定に一致するChineseフォントがないかもしれません。ほと
んどのXディストリビューションには、FAMILYフィールドが‘song ti’か
‘fangsong ti’のChineseフォントだけが含まれています。そのような場合、
‘Fontset-N’をつぎのように指定します:

     Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
             chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*

そうするとChinese GB2312の文字を除くフォント指定では、FAMILYフィールドが
‘fixed’となり、Chinese GB2312の文字に対するフォント指定では、FAMILYフィ
ールドが‘*’となります。

   フォントセットのリソース値を処理してフォントセットを作る関数は、
‘create-fontset-from-fontset-spec’と呼ばれます。フォントセットを作るため
に、この関数を明示的に呼ぶこともできます。

   フォントの命名についての詳細は、*note Fonts::を参照してください。


File: emacs-ja.info,  Node: Modifying Fontsets,  Next: Undisplayable Characters,  Prev: Defining Fontsets,  Up: International

22.15 フォントセットの修正
==========================

常にフォントセットをスクラッチから作成する必要はありません。軽微な変更だ
けが必要なときは、既存のフォントセットを修正するのが簡単な方法でしょう。
‘fontset-default’の修正は、それをフォールバックに使用する他のフォントセ
ットにも影響するので、特定のスクリプトのためにEmacsが選択するフォントに
関する問題を解決する、効果的な方法になり得ます。

   フォントセットは関数‘set-fontset-font’を使って、文字、文字セット、ス
クリプトフォントを修正する文字範囲、使用されるフォントの指定を修正するこ
とができます。以下は例です:

     ;; Use Liberation Mono for latin-3 charset.
     (set-fontset-font "fontset-default" 'iso-8859-3
                       "Liberation Mono")

     ;; Prefer a big5 font for han characters.
     (set-fontset-font "fontset-default"
                       'han (font-spec :registry "big5")
                       nil 'prepend)

     ;; Use DejaVu Sans Mono as a fallback in fontset-startup
     ;; before resorting to fontset-default.
     (set-fontset-font "fontset-startup" nil "DejaVu Sans Mono"
                       nil 'append)

     ;; Use MyPrivateFont for the Unicode private use area.
     (set-fontset-font "fontset-default"  '(#xe000 . #xf8ff)
                       "MyPrivateFont")


   システムにインストールされているフォントが壊れていたり、使用されてい
る文字にたいして好ましくない結果を生成するフォントがあるかもしれません。
そのような場合、文字を表示するのに必要となる適切なフォントの検索に、それ
らのフォントを完全に無視するように、Emacsに指示したいと思うかもしれませ
ん。‘face-ignored-fonts’の値(リスト変数です)に、不適切なフォントを追加す
ることによりこれを行なうことができます。以下は、そのような設定を
‘~/.emacs’に記述する例です:

     (add-to-list 'face-ignored-fonts "Some Bad Font")


File: emacs-ja.info,  Node: Undisplayable Characters,  Next: Unibyte Mode,  Prev: Modifying Fontsets,  Up: International

22.16 表示できない文字
======================

あなたの端末では表示できない非ASCII文字が、いくつか存在するかもしれませ
ん。ほとんどのテキスト端末は、1つの文字セットだけをサポートします
(Emacsに何を使うか指示するには、変数‘default-terminal-coding-system’を使
用します。*note Terminal Coding::を参照してください)。そのコーディングシ
ステムではエンコードできない文字は、デフォルトでは‘?’と表示されます。

   グラフィカルなディスプレーでは、より広範囲の文字を表示できますが、そ
れらすべてのフォントがインストールされていないかもしれません。フォントが
ない文字は、中空のボックスで表示されます。

   Latin-1文字を使用するとき、端末がLatin-1を表示できない場合、かわりに
ニーモニックASCIIシーケンスを表示できます。たとえばo-umlautのかわりに
‘"o’が表示されます。これを行うには‘iso-ascii’をロードします。

   端末がLatin-1を表示できる場合、Latin-1と等しい文字とASCIIニーモニック
を混交して、他のEuropean文字セットを表示できます。これは変数
‘latin1-display’をカスタマイズすることにより有効になります。ニーモニック
ASCIIシーケンスは、ほとんどがインプットメソッドのプレフィクスに対応しま
す。


File: emacs-ja.info,  Node: Unibyte Mode,  Next: Charsets,  Prev: Undisplayable Characters,  Up: International

22.17 Unibyte編集モード
=======================

ISO 8859 Latin-N文字セットは、さまざまなEuropean言語で必要とされるアクセ
ント文字と区切り文字を扱うために、8進の0240から0377(10進の160から250)の
範囲の文字コードを定義しています。Emacsはこの範囲のバイトを、たとえ
unibyteバッファー(たとえばマルチバイト文字を無効にしている場合)でも、そ
れらを文字としてではなく、rawバイトとみなします。しかし、それでもEmacsは
これらの文字コードを、あたかも_1つ_も1バイト文字セットに属するかのように
1度に扱うことができます。これらのコードの_どれ_を使うかを指定するには、
‘M-x set-language-environment’を呼び出して、‘Latin-N’のような適切な言語
環境を指定します。*note Disabling Multibyte Characters: (elisp)Disabling
Multibyte.を参照してください。

   端末や使っているフォントがこれらの文字をサポートしている場合、Emacsは
160から255の文字を読み取り可能な文字として表示できます。これは自動的に行
われます。グラフィカルなディスプレーでは、Emacsはフォントセットを通じて
1バイト文字として表示できます。これは現在の言語環境で、それらに対応する
マルチバイト文字を表示することにより行われます。これを行うには、変数
‘unibyte-display-via-language-environment’に非‘nil’値を設定します。この
セッティングは、これらのバイトを表示する方法だけに影響しますが、Emacsが
それらを文字としてではなくrawバイトとして扱うという基礎事実は変わらない
ことに注意して下さい。

   端末でLatin-1文字セットを表示できない場合、Emacsはこれらの文字をその
文字が少なくとも何であるかを明確に理解できるような、ASCIIシーケンスとし
て表示できます。これを行うには、ライブラリー‘iso-ascii’をロードします。
他のLatin-N文字セットに対しても似たようなライブラリを実装できますが、こ
れは まだ行われていません。

   通常、非ISO 8859文字セット(10進文字の128から159のコードも含む)は、8進
でエスケープ表示されます。ライブラリー‘disp-table’の関数
‘standard-display-8bit’を使うことにより、非標準の拡張バージョンのISO
8859文字セットに変更できます。

   1バイトの非ASCII文字を入力する2つの方法があります:

   • 選択した言語環境のインプットメソッドを使用することができます。*note
     Input Methods::を参照してください。unibyteバッファーでインプットメ
     ソッドを使用した場合、入力した非ASCII文字は、ユニバイトに変換されま
     す。

   • キーボードが、非ASCII文字を表現する(10進の)128以上の文字コードを生
     成できるならば、それらの文字コードを直接タイプすることができます。

     グラフィカルなディスプレーでは、これらのキーを使うのに特別なことを
     する必要はありません。それらは単純に機能するでしょう。テキスト端末
     では、コマンド‘M-x set-keyboard-coding-system’を使うか、変数
     ‘keyboard-coding-system’をカスタマイズして、キーボードが使用するコ
     ーディングシステムを指定します(*note Terminal Coding::を参照してく
     ださい)。この機能を有効にすることにより、おそらくMeta文字を入力する
     ために<ESC>を使う必要が生じるでしょう。しかし、コンソール端末、また
     は‘xterm’のような端末エミュレータでは、Metaを<ESC>にアレンジするこ
     とが可能です。また8ビット文字を直接キーボードから入力したり、
     <Compose>キーや<AltGr>キーを使うこともできます。*note User Input::を
     参照してください。

   • 非ASCIIのLatin-1、および、数は多くありませんが他のプリント文字入力
     の合成文字(compose-character)プレフィックスとして‘C-x 8’を使用でき
     ます。‘C-x 8’は、(ミニバッファーや他のバッファーでの)挿入、検索、キ
     ーシーケンスが許される他のコンテキストなどで使用できます。

     ライブラリー‘iso-transl’をロードすることにより‘C-x 8’は機能します。
     1度ライブラリーをロードすると、<Alt>修飾キーがある場合は、‘C-x 8’と
     同じ目的で使用できます。後続の文字を修飾するには、アクセント文字と
     一緒に<Alt>を使用します。さらにLatin-1の専用アクセント文字キー(dead
     accent characters)があると、1度‘iso-transl’をロードした後は、それら
     のキーも後続の文字を合成するように定義されます。

     ‘C-x 8 C-h’を使用すると、利用可能なすべての‘C-x 8’翻訳をリストしま
     す。


File: emacs-ja.info,  Node: Charsets,  Next: Bidirectional Editing,  Prev: Unibyte Mode,  Up: International

22.18 文字セット
================

Emacsでは“文字セット(character set)”を縮めて、“charset”と呼びます。
Emacsは、ほとんどの有名なcharsets(‘ascii’、‘iso-8859-1’、‘cp1250’、
‘big5’、‘unicode’など)に加えて、Emacs自身のcharsets(‘emacs’、
‘unicode-bmp’、‘eight-bit’など)をサポートします。すべてのサポートされた
文字は、1つ以上のcharsetsに属します。

   Emacsは通常、charsetsにたいして正しいことを行う(does the right
thing)ので、あなたはそれらを心配する必要はありません。しかし、charsetsの
背景の詳細を知ることが助けになる場合もあります。

   1つの例はフォント選択です(*note Fonts::を参照してください)。それぞれ
の言語環境(*note Language Environments::を参照してください)は、さまざま
な文字にたいする優先リスト(priority list)を定義します。フォントを検索す
るとき、Emacsは最初に一番優先度の高いcharsetsを表示できるものを探すこと
を試みます。たとえばJapanese言語環境では、charsets ‘japanese-jisx0208’は
一番高い優先度をもっているので、Emacsは‘registry’プロパティーが
‘JISX0208.1983-0’のフォントの使用を試みます。

   charsetsに関する情報を得るのに使うことができるコマンドが2つあります。
コマンド‘M-x list-charset-chars’はcharset名の入力を求め、その文字セット
のすべての文字を表示します。コマンド‘M-x describe-character-set’は
charset名の入力を求め、Emacsでの内部表現も含めたそのcharsetに関する情報
を表示します。

   ‘M-x list-character-sets’は、すべてのサポートされたcharsetsを表示しま
す。このリストはcharsetsの名前と、各charsetを識別する追加の情報を与えま
す。詳細については、Information Processing Society of Japan/Information
Technology Standards Commission of Japan (IPSJ/ITSCJ)
(https://www.itscj.ipsj.or.jp/itscj_english/)により保守されている、ISO
International Register of Coded Character Sets to be Used with Escape
Sequences (ISO-IR)
(https://www.itscj.ipsj.or.jp/itscj_english/iso-ir/ISO-IR.pdf)を参照して
ください。このリストでは、charsetsは2つのカテゴリーに分かれています。“通
常のcharsets(normal charsets)”が最初にリストされ、その後に“追加の
charsets(supplementary charsets)”が続きます。追加のcharsetは他の
charsetを定義するのに(サブセットの親として)使用されるか、古いバージョン
のEmacsとの互換性のために提供されます。

   バッファーの文字がどのcharsetに属するか探すには、ポイントをその文字の
前において、‘C-u C-x =’をタイプします(*note International Chars::を参照
してください)。


File: emacs-ja.info,  Node: Bidirectional Editing,  Prev: Charsets,  Up: International

22.19 双方向の編集
==================

EmacsはArabicやFarsi、Hebrewのような、テキストを水平方向の右から左に記述
するスクリプトで書かれたテキストの編集をサポートします。しかし数字やそれ
らのスクリプトに埋め込まれたLatinテキストは、左から右に表示されます。
Latin文書の中に少量のArabicやHebrewのテキスト部分が含まれている場合も、
稀ではありません(例: プログラムソース内のコメントや文字列)。これらの理由
により、これらのスクリプトを使うテキストは、実際には“双方向
(bidirectional)”、つまりそれらはleft-to-right(左から右)の文字と
right-to-left(右から左)文字の混交されたものになります。

   このセクションでは、双方向テキストを編集するためにEmacsが提供する機能
とオプションを説明します。

   Emacsはright-to-leftおよび双方向テキストを、いわゆる“logical”順(また
は“reading”順)で格納します。バッファーまたは文字列の最初の文字の位置は、
次に読む文字の前になります。双方向テキストを“visual”順に再配置するには、
表示時間が発生します。結果として文字の位置は、それらが表示される位置にた
いして単調に増加しなくなります。Emacsは表示のための双方向テキストの再配
置を、Unicode Standard Annex #9 (http://unicode.org/reports/tr9/)で説明
されているUBA(Unicode Bidirectional Algorithm)で実装しています。
right-to-leftパラグラフ中に長い英文テキストが出現するような、基本となる
パラグラフと継続行が逆方向のときに表示する方法だけが、UBAと異なります。

   バッファーローカルな変数‘bidi-display-reordering’は、表示用にバッファ
ーのテキストを再配置するかどうかを制御します。この変数の値が非‘nil’の場
合、Emacsは右から左の方向に表示される文字を再配置します。デフォルト値は
‘t’です。

   双方向テキストの各パラグラフは、それ自身の“base direction(基本方向
)”をもっており、それはright-to-leftまたはleft-to-rightです。
left-to-rightのパラグラフはスクリーンの左端から開始し、右端に到達すると
切り詰め、または継続されます。対照的にright-to-leftのパラグラフのテキス
トは右端から開始し、左端で継続、または切り詰められて表示されます。デフォ
ルトでは、パラグラフの境界は空行(たとえば行全体が空白文字からなる行)です
。これを変更するために、2つの変数‘bidi-paragraph-start-re’と
‘bidi-paragraph-separate-re’をカスタマイズできます。これらの値には正規表
現(文字列)を指定します。たとえば単一の改行を新たなパラグラフの開始とする
場合は、両方の変数に‘\"^\"’をセットします。これら2つの変数はバッファーロ
ーカルです(*note Locals::を参照)。

   Emacsは、パラグラフを開始するテキストにもとづいて、各パラグラフの基本
方向を動的に決定します。しかし、バッファーのパラグラフにたいして特定の基
本方向を強制する必要もあるでしょう。変数‘bidi-paragraph-direction’が非
‘nil’の場合、これは基本方向の動的な決定を無効にして、バッファーのすべて
のパラグラフの方向を、このバッファーローカルな値で指定された方向に強制し
ます。値には‘right-to-left’と‘left-to-right’が指定できます。これ以外の値
は‘nil’と解釈されます。

   かわりにパラグラフの先頭に特別な文字を挿入することにより、パラグラフ
の基本方向を制御できます。特別な文字‘RIGHT-TO-LEFT MARK’またはRLMは、以
降に続くパラグラフをright-to-left方向に強制します。その効果は
‘LEFT-TO-RIGHT MARK’またはLRMによりleft-to-right方向に再強制されるまで続
きます(‘C-x 8 <RET>’を使ってこれらの文字を挿入できます)。GUIセッションで
はLRM文字およびRLM文字は、極端に細いスペースで表示されます。テキスト端末
では、それらはスペースで表示されます。

   文字は表示用に再配置されるので、logical順で処理を行うEmacsコマンドや
バッファーの拡大は、普通とは異なる効果を生みます。たとえばコマンド
‘C-f’および‘C-b’はポイントをlogical順で移動するので、再配置された双方向
テキストではポイントがジャンプすることがあります。同様に隣接する文字位置
の範囲をカバーするハイライトされたリージョンは、リージョンが再配置された
テキストにかかる場合には不連続に見える場合があります。これは双方向テキス
トをサポートする他のプログラムの振る舞いとしては普通であり、似通っていま
す。

   <LEFT>や‘C-<RIGHT>’のように、矢印キーにバインドされたカーソル移動コマ
ンドは、カレントパラグラフの基本方向にしたがいます。left-to-rightパラグ
ラフでは、修飾キーの有無に関わらず、<RIGHT>にバインドされるコマンドは、
バッファーテキスト内を_前方(forward)_に移動しますが、right-to-leftパラグ
ラフではかわりに_後方(backward)_に移動することになります。これは、
right-to-leftパラグラフのバッファー位置は、ディスプレイ上を左に移動する
ことにより大部分は増加するという事実を反映しています。

   パラグラフ外に移動した際、先行または後続するパラグラフの基本方向が、
移動する前のパラグラフの方向と異なる場合は、矢印キーのもつ意味は変化する
でしょう。これが発生したときは、新たな基本方向に合わせて矢印キーを押下す
る必要があります。

   デフォルトでは、<LEFT>および<RIGHT>はlogical方向に移動しますが、
‘visual-order-cursor-movement’が非‘nil’の場合、これらのコマンドはそれぞ
れスクリーン位置を左または右に、必要ならスクリーン行の次行または前行へと
移動します。これは周辺の双方向コンテキストに依存して、多くのバッファー位
置が移動される可能性を秘めることに注意してください。


File: emacs-ja.info,  Node: Modes,  Next: Indentation,  Prev: International,  Up: Top

23 メジャーモードとマイナーモード
*********************************

Emacsには多くの“編集用モード(editing modes)”が含まれており、これは基本的
な振る舞いを、編集に便利な方法に変更します。これらの編集用モードは“メジ
ャーモード(major modes)”と“マイナーモード(minor modes)”に分けられます。

   メジャーモードは、Cソースファイル(*note Programs::を参照してください
)などの特定のファイルタイプや、shellバッファー(*note Shell::を参照してく
ださい)などの、特別なタイプの非ファイルバッファーにたいして作業するため
の特別な機能を提供します。メジャーモードは互いに排他であり、各バッファー
は常に1つのメジャーモードをもちます。

   マイナーモードはオンとオフを切り替えることができるオプションの機能で
、ファイルやバッファーのタイプに特定する必要はありません。たとえばAuto
Fillモードは、単語の間にタイプした<SPC>で行を区切るマイナーモードです
(*note Auto Fill::を参照してください)。マイナーモードは互いに独立してい
て、選択されたメジャーモードからも独立しています。

* Menu:

* Major Modes::              Textモード vs. Lispモード
                               vs. Cモード...
* Minor Modes::              マイナーモードは他と独立して有効にできる機能です。
* Choosing Modes::           ファイルをvisitしたときにモードが選択される方法。


File: emacs-ja.info,  Node: Major Modes,  Next: Minor Modes,  Up: Modes

23.1 メジャーモード
===================

すべてのバッファーはメジャーモードをもっており、そのバッファーがカレント
である間の編集の動作を決定します。モードラインには通常カレントのメジャー
モード名がカッコ内に表示されます(*note Mode Line::を参照してください)。

   もっとも特殊化されていないメジャーモードは、“Fundamental(基本)モード
”と呼ばれます。このモードには、モード独自の再定義や変数設定がないので、
各Emacsコマンドはもっとも一般的な振る舞いをし、各ユーザーオプションはデ
フォルトの状態になっています。

   Lispや英文テキストのように、Emacsが認識できる特定のタイプのテキスト編
集には、LispモードやTextモードのような、より特殊化されたメジャーモードを
通常は使用します。ほとんどのメジャーモードは3つのグループに分けられます
。最初のグループはプレインまたはマークアップされた通常テキストのためのモ
ードを含みます。これにはTextモード、HTMLモード、SGMLモード、TeXモードや
Outlineモードなどが含まれます。2番目のグループはプログラミング言語特有の
モードです。これらは、Lispモード(いくつかの変種を有する)、Cモード、
Fortranモードなどが含まれます。3番目のグループはファイルに直接関連付けら
れていないメジャーモードが含まれます。これらはEmacsが特別の目的のために
作るバッファーで使用されるものです。例としては、Diredが作成するバッファ
ーのためのDiredモード(*note Dired::を参照)、‘C-x m’で作成されるバッファ
ーのためのMessageモード(*note Sending Mail::を参照)、下位のシェルプロセ
スとの通信用のバッファーのためのShellモード(*note Interactive Shell::を
参照)などが含まれます。

   通常、メジャーモードは最初にファイルをvisitしたとき、またはバッファー
を作成したときに、Emacsにより自動的にセットされます。‘M-x’コマンドを使う
ことにより、新しいメジャーモードを明示的に選択することができます。モード
の名前に‘-mode’を追加することにより、モードを選択するコマンド名を得るこ
とができます(たとえば、Lispモードを選択する場合は‘M-x lisp-mode’)。すべ
てのバッファーは厳密に1つのメジャーモードをもつので、メジャーモードを“オ
フ”にする方法はなく、かわりに他のメジャーモードに切り替えなければなりま
せん。

   バッファーローカルな変数‘major-mode’の値は、メジャーモードコマンドと
同じ名前のシンボル(たとえば‘lisp-mode’)です。この変数は自動的にセットさ
れます。あなた自身が変更するべきではありません。

   ‘major-mode’のデフォルト値は、メジャーモードが指定されていないファイ
ルを使うときや、‘C-x b’で作成した新しいバッファーのメジャーモードを決定
します。通常、デフォルト値はFundamentalモードを指定する、シンボル
‘fundamental-mode’です。Customizationインターフェースを通じて、このデフ
ォルト値を変更できます(*note Easy Customization::を参照してください)。
initファイルに以下のような行を追加しても変更できます(*note Init File::を
参照してください):

     (setq-default major-mode 'text-mode)

‘major-mode’のデフォルト値が‘nil’の場合、メジャーモードは前のカレントバ
ッファーから引き継がれます。

   特殊化されたメジャーモードは、特定のキーにたいして、そのモードにより
適した何かを行うよう、意味づけが変更される場合があります。たとえばプログ
ラミングに関連するモードでは、<TAB>には、カレント行をその言語のルールに
したがってインデントする機能がバインドされます(*note Indentation::を参照
してください)。一般的に変更されるキーは<TAB>、<DEL>、‘C-j’です。多くのモ
ードがモード自身の特別なコマンドを定義しており、それらは通常、プレフィク
スキーが‘C-c’であるようなキーシーケンスにバインドされます。メジャーモー
ドはユーザーオプションと変数も変更できます。たとえばプログラミングに間す
るモードは通常、変数‘comment-start’にバッファーローカルな値をセットしま
す。これはソースコードのコメントがどのように区切られるかを決定します
(*note Comments::を参照してください)。

   カレントメジャーモードのキーバインディング一覧も含めたドキュメントを
閲覧するには、‘C-h m’ (‘describe-mode’)とタイプします。*note Misc
Help::を参照してください。

   Fundamentalモード以外のすべてのメジャーモードは、“モードフック(mode
hook)”を定義します。これはバッファーでそのモードが有効になるたびに実行さ
れる、カスタマイズ可能なLisp関数のリストです。フックに間する詳細は、
*note Hooks::を参照してください。各モードフックはメジャーモード名の後に
名前がつけられます。たとえばFortranモードのモードフックは、
‘fortran-mode-hook’です。さらに、すべてのテキストベースのメジャーモード
は、‘text-mode-hook’を実行し、多くの、プログラミング言語のモード(Emacsと
ともに配布されるものを含む) は、その言語モード自身のモードフックの前に、
‘prog-mode-hook’を実行します(1) 。フック関数は変数‘major-mode’の値を調べ
て、どのモードに入ろうとしているか調べることができます。

   モードフックは、一般的にマイナーモードを有効にするために使用されます
(*note Minor Modes::を参照してください)。たとえば以下の行をinitファイル
に記述すると、すべてのテキストベースのメジャーモードでFlyspellマイナーモ
ード(*note Spelling::を参照してください)を、Emacs LispモードでEldocマイ
ナーモード(*note Lisp Doc::を参照してください)を有効にすることができます
:

     (add-hook 'text-mode-hook 'flyspell-mode)
     (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)

   ---------- Footnotes ----------

   (1) より具体的には、そのモードは‘prog-mode’から”派生”したモードです
(*note (elisp)Derived Modes::を参照)。


File: emacs-ja.info,  Node: Minor Modes,  Next: Choosing Modes,  Prev: Major Modes,  Up: Modes

23.2 マイナーモード
===================

マイナーモードは明確な方法でEmacsの動作を変更する、オプションの編集用モ
ードです。メジャーモードとは異なり、いつでも任意の数のマイナーモードを有
効にできます。いくつかのマイナーモードは“バッファーローカル
(buffer-local)”で、特定のバッファーにたいしてオン(有効)にして、他のバッ
ファーではオフ(無効)に切り替えることができます。それ以外のマイナーモード
は“グローバル(global)”で、それが有効な間はEmacsセッションのすべてのバッ
ファーで行う、すべての操作に影響します。ほとんどのマイナーモードはデフォ
ルトで無効ですが、デフォルトで有効なものもいくつかあります。

   ほとんどのバッファーローカルなマイナーモードは、モードラインのメジャ
ーモード標識のすぐ後ろに有効であることを示します。たとえばモードラインに
‘Fill’と表示されているとき、それはAuto Fillモードが有効であることを意味
します。*note Mode Line::を参照してください。

   メジャーモードと同様に、各マイナーモードは“モードコマンド(mode
command)”に関連付けられていて、それはモード名の後ろに‘-mode’を付けた名前
です。たとえばAuto Fillモードのモードコマンドは‘auto-fill-mode’です。し
かしメジャーモードのコマンドは、単純にそのモードを有効にするだけですが、
マイナーモードのモードコマンドは、モードを有効または無効にすることができ
ます。

   • ‘M-x’を通じて、またはバインドしたキー(*note Key Bindings::を参照し
     てください)をタイプすることにより、モードコマンドをプレフィクスキー
     なしで直接呼び出すと、それはマイナーモードを“切り替え(toggles)”ます
     。つまり、マイナーモードがオフのときはオンに、オンのときはオフに切
     り替えます。

   • プレフィクス引数を指定してモードコマンドを呼び出すと、引数が0または
     負のときは無条件にマイナーモードをオフにし、それ以外のときは無条件
     にオンに切り替えます。

   • Lispからモードコマンドが呼び出された場合、引数が省略されているか
     ‘nil’のとき、マイナーモードは無条件にオンになります。これはメジャー
     モードのモードフックからマイナーモードをオンに切り替えるのを簡単に
     します(*note Major Modes::を参照してください)。非‘nil’の引数は、上
     で説明したインタラクティブなプレフィクス引数と同様に処理されます。

   ほとんどのマイナーモードは、モードコマンドと同じ名前の“モード変数
(mode variable)”をもっています。変数の値が非‘nil’のときはモードが有効で
、‘nil’なら無効です。一般的に、Lispから直接モード変数を変更して、モード
を有効または無効にするべきではありません。かわりにモードコマンドを使うべ
きです。しかしCustomizeインターフェース(*note Easy Customization::を参照
してください)を通じてのノード変数のセットは、Customizeが自動的にモードコ
マンドを実行するので、常に正しくモードを有効または無効にします。

   以下にいくつかのバッファーローカルなマイナーモードのリストを示します:

   • Abbrevモードは、事前に定義された省略形(abbreviation)の定義にもとづ
     いて、テキストを自動的に展開します。*note Abbrevs::を参照してくださ
     い。

   • Auto Fillモードは、行が長くなりすぎるのを防ぐため、タイプされた文字
     にしたがって改行を挿入します。*note Filling::を参照してください。

   • Auto Saveモードはバッファー内容を定期的に保存して、クラッシュした場
     合等に失われる作業量を減らします。*note Auto Save::を参照してくださ
     い。

   • Electric Quoteモードは、クォーテーションマークを自動的に変換します
     。たとえば、`like this'とタイプするとこれは、‘like this’のように再
     クォートされます。どうのような種類のテキストを処理するかを制御でき
     ます。また特定のバッファーにたいしてこれを完全に無効にできます。
     *note Quotation Marks::を参照してください。

   • Enrichedモードは、書式つきのテキストの編集と保存を可能にします。
     *note Enriched Text::を参照してください。

   • Flyspellモードは、自動的に間違ったスペルの単語をハイライトします。
     *note Spelling::を参照してください。

   • Font-Lockモードは、プログラム内で見つかった特定のテキスト単位を自動
     的にハイライトします。このモードはデフォルトでグローバルに有効にな
     っていますが、個別のバッファーで無効にすることができます。*note
     Faces::を参照してください。

   • Display Line Numbersモードは‘display-line-numbers’の便利なラッパー
     であり、‘display-line-numbers-type’の値を使用してセッティングします
     。*note Display Custom::を参照してください。

   • Outline minorモードは、Outlineモードと呼ばれるメジャーモードと同様
     な機能を提供します。*note Outline Mode::を参照してください。

   • Overwriteモードは、通常のプリント文字の挿入により、後の文字をずらす
     かわりに、既存のテキストを置き換えます。たとえば、ポイントが
     ‘FOOBAR’の‘B’の前にある場合、‘G’をタイプすると通常は‘FOOGBAR’となり
     ますが、Overwriteモードでは‘FOOGAR’になります。Overwriteモードでは
     、コマンド‘C-q’は次の文字が何であれ、たとえそれが数字であってもその
     文字を挿入します — これにより既存のテキストを置き換える代わりに文字
     を挿入する方法が与えられます。モードコマンド‘overwrite-mode’は、
     <Insert>キーにバインドされています。

   • Binary Overwriteモードは、バイナリーファイルを編集するための、
     Overwriteモードの変種です。このモードは改行とタブを他の文字と同じよ
     うに扱うので、他の文字を上書きしたり、他の文字で上書きさせたりする
     ことができます。Binary Overwriteモードでは‘C-q’の後の数字は、通常ど
     おり8進文字コードを指定します。

   • Visual Lineモードは、 単語単位の折り返し(word wrapping)を処理します
     。これにより長い行は単語境界で折り返されます。*note Visual Line
     Mode::を参照してください。

以下に便利なグローバルマイナーモードをいくつか示します:

   • Column Numberモードは、現在の列番号をモードラインに表示します。
     *note Mode Line::を参照してください。

   • Delete Selectionモードでは、リージョンがアクティブの場合、最初にリ
     ージョンのテキストを削除してからテキストを挿入します。*note Using
     Region::を参照してください。

   • Icompleteモードは、ミニバッファーで補完がアクティブのとき、利用可能
     な候補を表示します。*note Icomplete::を参照してください。

   • Line Numberモードは、現在の行番号をモードラインに表示します。このモ
     ードはデフォルトで有効です。*note Mode Line::を参照してください。

   • Menu Barモードは、各フレームにメニューバーを表示します。このモード
     はデフォルトで有効です。*note Menu Bars::を参照してください。

   • Scroll Barモードは、各ウィンドウにスクロールバーを表示します。この
     モードはデフォルトで有効ですが、スクロールバーが表示されるのはグラ
     フィカルな端末だけです。*note Scroll Bars::を参照してください。

   • Tool Barモードは、各フレームにツールバーを表示します。このモードは
     デフォルトで有効ですが、ツールバーが表示されるのはグラフィカルな端
     末だけです。*note Tool Bars::を参照してください。

   • Transient Markモードはリージョンをハイライトして、マークがアクティ
     ブなときはEmacsの多くのコマンドがリージョンにたいして操作を行うよう
     になります。このモードはデフォルトで有効です。*note Mark::を参照し
     てください。


File: emacs-ja.info,  Node: Choosing Modes,  Prev: Minor Modes,  Up: Modes

23.3 ファイルのモードを選択する
===============================

ファイルをvisitしたとき、Emacsは自動的にメジャーモードを選択します。これ
は通常、ファイル名にもとづいて選択されます—たとえば名前が‘.c’で終わるフ
ァイルは通常、Cモードで編集されます — が、ファイル内の特別なテキストにも
とづいてメジャーモードが選択されるときもあります。この特別なテキストは、
バッファーローカルなマイナーモードを有効にするためにも使用されます。

   以下は、これの正確な手順です:

   最初にEmacsは、ファイルにファイルローカル(file-local)なモード変数が含
まれているかチェックします。*note File Variables::を参照してください。メ
ジャーモードを指定するファイルローカル変数が存在する場合、Emacsは他の条
件をすべて無視してそのメジャーモードを使用します。ファイルローカル変数を
使用してメジャーモードを指定する方法はいくつかあります。一番単純なのは、
空行でない最初の行に、そのモードの名前と、モード名の前後に‘-*-’を記述す
る方法です。他のテキストがその行にあっても問題はありません。たとえば、

     ; -*-Lisp-*-

これはEmacsにLispモードを使用するよう指示します。Lispがこの行をコメント
として扱うように、セミコロンがどのように使われているか注意してください。
以下のように書くこともできます

     ; -*- mode: Lisp;-*-

ファイルローカル変数を使用して、バッファーローカルなマイナーモードを指定
することもできます。これは‘eval’指定を使用して行います。たとえば、空行で
ない最初の行に以下を記述すると、これはバッファーをLispモードにして、
Auto-Fillモードを有効にします。

     ; -*- mode: Lisp; eval: (auto-fill-mode 1); -*-

しかし、ほとんどのマイナーモードはユーザー個人の好みが表れるものなので、
この方法でマイナーモードを有効にするのは、通常は不適切です。特定のファイ
ルタイプにたいしてマイナーモードを個人的に使用したい場合は、メジャーモー
ドフックを通じてマイナーモードを有効にするのが、より良い方法です。

   2番目に、メジャーモードを指定するファイル変数が存在しない場合、
Emacsは最初の行が‘#!’で開始されていないかチェックします。もし該当したら
、それはそのファイルがファイルの最初の行に記述された名前のインタープリタ
ーを実行する(ファイルの残りはインタープリターへの入力として使用されます
)ことにより機能する、実行可能なシェルコマンドであることを示します。した
がってEmacsはインタープリター名を使って、モードの選択を試みます。たとえ
ば、‘#!/usr/bin/perl’で始まるファイルは、Perlモードで開かれます。変数
‘interpreter-mode-alist’は、インタープリター名とメジャーモードの対応を指
定します。

   最初の行が‘#!’で開始されている場合、最初の行で‘-*-’の機能は通常は使用
できません。なぜならインタープリターを実行するときにシステムが混乱するか
らです。そのため、Emacsはそのようなファイルにたいしては、1行目と同じよう
に2行目の‘-*-’を探します。これはマジック文字列‘'\"’で開始されるman pageで
、troffプリプロセッサーのリストを指定することと同じです。

   3番目に、Emacsは変数‘magic-mode-alist’にもとづいて、バッファーの先頭
のテキストを調べて、メジャーモードの決定を試みます。デフォルトではこの変
数は‘nil’(空のリスト)なので、Emacsはこのステップをスキップしますが、
initファイルでこれをカスタマイズできます(*note Init File::を参照してくだ
さい)。変数の値には、以下の形式のリスト要素を指定します

     (REGEXP . MODE-FUNCTION)

ここでREGEXPは正規表現(*note Regexps::を参照してください)で、
MODE-FUNCTIONはメジャーモード関数です。ファイルの先頭のテキストが
REGEXPにマッチした場合、EmacsはMODE-FUNCTIONで指定したメジャーモードを選
択します。

   ‘magic-mode-alist’の要素は、以下の形式でも指定できます

     (MATCH-FUNCTION . MODE-FUNCTION)

ここでMATCH-FUNCTIONは、バッファーの先頭で呼び出されるLisp関数です。この
関数が非‘nil’を返した場合、EmacsはメジャーモードをMODE-FUNCTIONにセット
します。

   4番目に —Emacsが適正なメジャーモードをまだ見つけていない場合 — 今度は
ファイル名を調べます。ファイル名とメジャーモードの対応付けは、変数
‘auto-mode-alist’で制御されます。この変数の値は、各要素が以下の形式のリ
ストです。

     (REGEXP . MODE-FUNCTION)

または以下の形式です

     (REGEXP MODE-FUNCTION FLAG)

たとえば、通常見られるようなリストの要素は、‘("\\.c\\'" . c-mode)’のよう
な形式で、これは名前が‘.c’で終わるファイルにたいして、Cモードを選択する
役目を負っています(正規表現で‘.’がもつ特別な意味を打ち消すために、文字列
に‘\’を含めなければなりません。これはLisp構文では‘\\’と記述する必要があ
ります)。要素が‘(REGEXP MODE-FUNCTION FLAG)’の形式をもち、FLAGが非
‘nil’の場合、EmacsはMODE-FUNCTIONを呼び出した後、EmacsはREGEXPとマッチし
た接尾辞を捨てて、ほかのマッチを検索します。

   GNU/Linuxおよび、ファイル名の大文字小文字を区別する他のシステムでは、
Emacsは‘auto-mode-alist’の検索で大文字小文字を区別します。この検索が失敗
すると、2回目は大文字小文字を区別せずにalistを再検索します。2回目の検索
を行わないようにするには、変数‘auto-mode-case-fold’を‘nil’に変更します。
Microsoft Windowsのような、ファイル名の大文字小文字を区別しないシステム
では、Emacsは大文字小文字を区別しないで‘auto-mode-alist’を検索します。

   最後に、Emacsが_まだ_使用するメジャーモードを見つけられない場合、
Emacsはバッファーの先頭のテキストと、変数‘magic-fallback-mode-alist’を比
較します。この変数は上述した‘magic-mode-alist’と同じように機能しますが、
‘auto-mode-alist’の_後_に調べられるという点が異なります。デフォルトでは
‘magic-fallback-mode-alist’にはイメージファイル、HTML/XML/SGMLファイル、
PostScriptファイル、およびUnixスタイルのConfファイルをチェックする形式が
含まれています。

   バッファーのメジャーモードを変更したとき、‘M-x normal-mode’とタイプす
ると、Emacsが自動的に選択するメジャーモードに戻ることができます。この関
数は‘find-file’がメジャーモードを選択するために呼び出す関数と同じです。
この関数は、(もしあれば)ファイルの‘-*-’ 行およびローカル変数リストも処理
します。*note File Variables::を参照してください。

   コマンド‘C-x C-w’および‘set-visited-file-name’は、新しいファイル名が
何らかのモードに関係がある場合は、新しいメジャーコードに変更します(その
バッファーがファイルをvisitしていない場合、‘C-x C-s’も同じことを行います
)。しかしバッファーの内容がメジャーモードを指定していて、ある種の特別な
メジャーモードはモードの変更を許しません。このモード変更機能をオフにする
には、‘change-major-mode-with-file-name’を‘nil’にセットして下さい。


File: emacs-ja.info,  Node: Indentation,  Next: Text,  Prev: Modes,  Up: Top

24 インデント
*************

“インデント(Indentation)”とは、“空白文字”(スペースやタブ文字)を行のテキ
ストの先頭に挿入したり調整することを指します。このチャプターでは、インデ
ントコマンドと、Textモードやそれに関連するモード、同様にプログラミング言
語のモードでの一般的なオプションを記します。プログラミング用のモードでの
インデントに関する追加のドキュメントは、*note Program Indent::を参照して
ください。

   インデントを行うもっとも簡単な方法は、<TAB>キーです。ほとんどのメジャ
ーモードでは、これによりコマンド‘indent-for-tab-command’が実行されます
(Cおよびそれに関連するモードでは、<TAB>は同じように振る舞うコマンド
‘c-indent-line-or-region’を実行する。*note C Indent::を参照されたい)。

<TAB>
     空白文字を挿入、またはモードに適した方法でカレント行をインデントし
     ます(‘indent-for-tab-command’)。リージョンがアクティブのときは、リ
     ージョンのすべての行をインデントします。

   <TAB>の正確な動作は、メジャーモードに依存します。Textモードおよびそれ
に関連するモードでは、<TAB>は通常、空白とタブ文字を組み合わせたものを挿
入して、ポイントを次のタブストップに進めます。このために、先行する行の最
初の空白以外の文字の位置は、追加のタブストップとして扱われるので、
<TAB>を使って先行する行にポイントを揃えることができます。リージョンがア
クティブ(*note Using Region::を参照してください)な場合、<TAB>は特別な動
作をします。これはリージョンの各行をインデントするので、各行の最初の空白
以外の文字は、先行する行に揃えられます。

   プログラミング関連のモードでは、<TAB>はコードのカレント行にたいして、
前の行のコードの意味を理解してインデントします。リージョンがアクティブな
場合、リージョンのすべての行はこの方法でインデントされます。ポイントが最
初にカレント行のインデント領域にあった場合、その行の最初の空白以外の文字
に再配置されます。

   単にタブ文字をバッファーに挿入したいときは、‘C-q <TAB>’とタイプします
(*note Inserting Text::を参照してください)。

* Menu:

* Indentation Commands::     インデントを処理するほかのコマンド。
* Tab Stops::                Textモードのインデントのストップポイント。
* Just Spaces::              インデントにスペース文字だけを使用する。
* Indent Convenience::       インデントのオプション機能。


File: emacs-ja.info,  Node: Indentation Commands,  Next: Tab Stops,  Up: Indentation

24.1 インデントコマンド
=======================

<TAB> (‘indent-for-tab-command’)コマンドとは別に、Emacsは他の方法でイン
デントを処理する、さまざまなコマンドを提供します。

‘C-M-o’
     カレント行をポイント位置で分割します(‘split-line’)。その行のポイン
     トの後にあるテキストは新しい行となり、ポイントがあった位置と同じ列
     にインデントされます。このコマンドは、最初にポイントを複数のスペー
     スまたはタブを飛び越えて移動させます。その後、ポイントは挿入された
     行の前に配されます。

‘M-m’
     カレント行の最初の空白以外の文字に移動(前方または後方)します
     (‘back-to-indentation’)。その行に空白文字しかない場合は、その行の行
     末に移動します。

‘M-i’
     ポイント位置の空白文字を次のタブストップまでインデントします
     (‘tab-to-tab-stop’)。*note Tab Stops::を参照してください。

‘M-x indent-relative’
     ポイントが前の行(実際には最後の空行以外の行)の、最初の空白以外の文
     字に揃うように、ポイント位置に空白文字を挿入します。ポイントがすで
     にその位置より右にある場合は、かわりに‘tab-to-tab-stop’を実行します
     — ただし数引数を指定した場合は何もしません。

‘M-^’
     前の行とカレント行をマージします(‘delete-indentation’)。このコマン
     ドはカレント行の前にある任意のインデントと、行の境界を1つのスペース
     で置き換えて、2つの行を明解に結合(join)します。

     特別なケースとして、結合された文字が連続する開きカッコまたは閉じカ
     ッコの場合、または他の改行が続く場合、1つのスペースは省略されます
     (Lispコードにたいして有用)。

     fillプレフィクスが存在して、それが改行の後ろにあった場合、‘M-^’は
     fillプレフィクスを削除します。*note Fill Prefix::を参照してください
     。

‘C-M-\’
     リージョンのすべての行にたいして、各行の先頭で<TAB>をタイプしたかの
     ようにインデントします(‘indent-region’)。

     数引数が与えられた場合、その列番号までリージョンのすべての行をイン
     デントします。

‘C-x <TAB>’
     このコマンドは、リージョン内で開始されるすべての行のインデントを変
     更するのに使用されます。インデントの変更は、影響を受ける行を厳格な
     (rigid)単位として移動することにより行われます。

     引数を指定しないで呼び出されたとき、このコマンドは影響を受ける行の
     インデントを対話的に調整するために、transientモードをアクティブにし
     ます。transientモードがアクティブの間は、<LEFT>または<RIGHT>により
     、スペース1文字単位で左または右にインデントします。‘S-<LEFT>’または
     ‘S-<RIGHT>’とタイプすることにより、タブストップ単位で左または右にイ
     ンデントすることもできます。他のキーをタイプするとtransientモードは
     無効になり、通常の編集を再開します。

     プレフィクス引数Nを指定して呼び出すと、このコマンドは行をN個のスペ
     ースでインデントします(transientモードは有効になりません)。Nに値を
     与えると後方にインデントするので、リージョン内の行のすべてのインデ
     ントを除去したいときは、以下のように充分に大きい負の引数を与えます
     。

          C-u -999 C-x <TAB>


File: emacs-ja.info,  Node: Tab Stops,  Next: Just Spaces,  Prev: Indentation Commands,  Up: Indentation

24.2 タブストップ
=================

Emacsは、特定の列番号が“タブストップ”になるよう定義しています。これらは
Textモードおよびそれに関連するモードで、<TAB>および‘M-i’のようなコマンド
により、空白文字が挿入されるときのストップポイントとして使用されます。変
数‘tab-stop-list’は、これらの位置を制御します。デフォルト値は‘nil’で、こ
れはタブストップが8列ごとという意味です。値には、タブストップの列番号を
、0基準の列番号のリスト(昇順)で指定することもできます。Emacsは最後の要素
と、その1つ前の要素の差分を繰り返すことにより、リストを無限に拡張します
。

   変数‘tab-stop-list’を直接カスタマイズするかわりに、コマンド‘M-x
edit-tab-stops’を通じて、タブストップを視認しながらセットする便利な方法
があります。このコマンドは、以下のようなタブストップの説明を含んだバッフ
ァーに切り替えます。

             :       :       :       :       :       :
     0         1         2         3         4
     0123456789012345678901234567890123456789012345678
     To install changes, type C-c C-c

最初の行は各タブストップ位置にコロンを示します。その後の2行はコロンが示
す位置を表示します。‘tab-stop-list’の値が‘nil’(デフォルト)の場合、最初は
コロンが表示されません。

   異なるタブストップを置きたい列に、コロンを配して指定するために、この
バッファーを編集できます。このバッファーはOverwriteモードを使用します
(*note Minor Modes::を参照してください)。Emacsは、最後に明示した2つのス
トップの差分を繰り返すことにより、タブストップのリストを無限に拡張するこ
とを思い出してください。編集が終わったら、新しいタブストップを有効にする
ために、‘C-c C-c’とタイプします。通常、新しいタブストップのセッティング
は、すべてのバッファーに適用されます。しかし‘M-x edit-tab-stops’を呼び出
したバッファーにたいして、ローカルな変数‘tab-stop-list’を作成していた場
合(*note Locals::を参照してください)、新しいタブストップのセッティングは
、そのバッファーだけに適用されます。将来のEmacsセッションのためにタブス
トップのセッティングを保存するには、Customizeインターフェースを使用して
‘tab-stop-list’の値を保存します(*note Easy Customization::を参照してくだ
さい)。

   このセクションで議論したタブストップは、バッファーでタブ文字が表示さ
れる方法には影響しないことに注意してください。タブ文字は常に次の“タブス
トップ表示(display tab stop)”まで拡張される、空のスペースとして表示され
ます。*note Text Display::を参照してください。


File: emacs-ja.info,  Node: Just Spaces,  Next: Indent Convenience,  Prev: Tab Stops,  Up: Indentation

24.3 タブ vs. スペース
======================

インデントコマンドは通常、最小になるような一連のタブ文字とスペースを挿入
(または削除)することにより、望む列に行を揃えます。タブ文字は次の“タブス
トップ表示(display tab stop)”まで伸長された、空のスペースとして表示され
ます。デフォルトでは、‘tab-width’列ごと(デフォルトは8)に、1つのタブスト
ップ表示があります。*note Text Display::を参照してください。

   もし望むなら、すべてのインデントをスペースだけで行うこともできます。
これを要求するには、バッファーローカルな変数‘indent-tabs-mode’を‘nil’に
セットします。バッファーローカルな変数についての情報は、*note Locals::を
参照してください。しかし‘C-q <TAB>’は、‘indent-tabs-mode’の値とは無関係
に、常にタブ文字を挿入することに注意してください。

   ‘indent-tabs-mode’を‘nil’にセットする1つの理由は、すべてのエディター
がタブ文字を同じ方法で表示するわけではないという理由です。Emacsユーザー
も同様で、彼らはカスタマイズされた‘tab-width’により、異なる値をもつかも
しれません。スペースだけを使うことにより、ファイルが常に同じように見える
ことを保証できます。Emacsでどのように見えるかだけに関心がある場合、この
問題に取り組む他の方法は、ファイルローカルな変数‘tab-width’をセットする
方法です(*note File Variables::を参照してください)。

   空白以外の文字の列を常に保ちながら、スペースをタブに、またはその逆の
変換を行うコマンドも存在します。‘M-x tabify’は、リージョンの連続するスペ
ースをスキャンして、インデントを変更せずに、少なくとも2文字の連続するス
ペースをタブに変換します。‘M-x untabify’は、リージョンのすべてのタブを適
正な数のスペースに変更します。


File: emacs-ja.info,  Node: Indent Convenience,  Prev: Just Spaces,  Up: Indentation

24.4 インデントの便利な機能
===========================

変数‘tab-always-indent’は、<TAB> (‘indent-for-tab-command’)コマンドの動
作を微調整します。デフォルト値は‘t’で、これは*note Indentation::で説明し
た動作を与えます。値をシンボル‘complete’に変更すると、<TAB>は最初にカレ
ント行のインデントを試みます、すでにその行がインデントされている場合、こ
のコマンドはポイント位置のテキストの補完を試みます(*note Symbol
Completion::を参照してください)。値が‘nil’の場合、<TAB>はポイントが行の
左端かインデント位置にあるときだけインデントを行い、それ以外はタブ文字を
挿入します。

   Electric Indentモードはグローバルなマイナーモードで、これは<RET>をタ
イプしたあと自動的にインデントを行います。このモードはデフォルトで有効で
す。このマイナーモードを切り替えるには、‘M-x electric-indent-mode’とタイ
プします。1つのバッファーにたいしてモードを切り替えるには、‘M-x
electric-indent-local-mode’を使用してください。


File: emacs-ja.info,  Node: Text,  Next: Programs,  Prev: Indentation,  Up: Top

25 人間の言語のためのコマンド
*****************************

このチャプターでは“テキスト(text)” — 人間の言語(対照的なものとしてコンピ
ューターのプログラム言語があります)における、文字シーケンスという意味 —
にたいして動作する、Emacsコマンドを説明します。これらコマンドは、人間の
言語の構文および文体の規則に配慮した方法で動作します。単語、センテンス
(文)、パラグラフ(段落)、大文字に関する規則があります。“フィル(filling)”
— パラグラフの行をおおよそ同じ長さに再配置するという意味 — を行うコマン
ドもあります。これらのコマンドは主にテキストの編集を意図しており、プログ
ラムの編集にも便利なときがあります。

   Emacsには、人間言語のテキストを編集するためのメジャーモードがいくつか
あります。ファイルが普通のテキストを含む場合は、Textモードを使います。こ
れはEmacsを、テキストの構文規則にたいして少しカスタマイズしたものです。
Outlineモードは。アウトライン構造でテキストを操作する特別なコマンドを提
供します。*note Outline Mode::を参照してください。

   Orgモードは、Outlineモードを拡張してEmacsを本格的なオーガナイザーに変
えます。これによりTODOリストを管理したり、ノートを保存して、それを多くの
フォーマットで公開することができます。 *note The Org Manual: (org)Top.を
参照してください。

   EmacsにはTeXやLaTeX (*note TeX Mode::を参照してください)、HTMLやSGML
(*note HTML Mode::を参照してください)、XML (*note The nXML Mode Manual:
(nxml-mode)Top.を参照してください)、 GroffやNroff (*note Nroff Mode::を
参照してください)のような、コマンドが埋め込まれたテキストのための、他の
メジャーモードがあります。

   テキスト文字で作られたAA(ASCII art)のピクチャーを編集する必要がある場
合は、そのような絵を編集するための特別なメジャーモードのPictureモードを
使用します *note Picture Mode::を参照してください。

   テキストを記述するときは、自動タイピングの機能が便利でしょう。*note
The Autotype Manual: (autotype)Top.を参照してください。

* Menu:

* Words::                    単語単位の移動とkill。
* Sentences::                センテンス単位の移動とkill。
* Paragraphs::               パラグラフ単位の移動。
* Pages::                    ページ単位の移動。
* Quotation Marks::          クォーテーションマークの挿入。
* Filling::                  テキストのフィルと調整。
* Case::                     テキストの大文字小文字の変更。
* Text Mode::                テキストファイルを編集するためのメジャーモード。
* Outline Mode::             アウトラインの編集。
* Org Mode::                 Emacsオーガナイザー。
* TeX Mode::                 TeXおよびLaTeXファイルの編集。
* HTML Mode::                HTMLおよびSGMLファイルの編集。
* Nroff Mode::               nroffフォーマッターへの入力の編集。
* Enriched Text::            フォント、カラーなどでenrichedテキストを編集する。
* Text Based Tables::        テキストベースのテーブルを編集するためのコマンド。
* Two-Column::               テキスト列を分割して別のウィンドウに表示する。


File: emacs-ja.info,  Node: Words,  Next: Sentences,  Up: Text

25.1 単語
=========

Emacsは、単語単位で移動するコマンドをいくつか定義しています:

‘M-f’
     1単語前方に移動します(‘forward-word’)。
‘M-b’
     1単語後方に移動します(‘backward-word’)。
‘M-d’
     単語の最後までkillします(‘kill-word’)。
‘M-<DEL>’
     単語の先頭までkillします(‘backward-kill-word’)。
‘M-@’
     次の単語の最後にマークをセットします(‘mark-word’)。
‘M-t’
     2つの単語を入れ替える、または他の単語を飛び越えて単語をドラッグしま
     す(‘transpose-words’)。

   これらのキーは文字単位のコマンド‘C-f’、‘C-b’、‘C-d’、<DEL>、‘C-t’に類
似していることに注目してください。‘M-@’は‘C-@’(これは‘C-<SPC>’の別名です
)が由来です。

   コマンド‘M-f’ (‘forward-word’)および‘M-b’ (‘backward-word’)は、単語単
位で前方または後方に移動します。これらの<Meta>ベースのキーシーケンスは、
1文字単位で移動するキーシーケンス‘C-f’および‘C-b’に類似しています。類似
点は数引数にも拡張されます。これらは繰り返し回数を指定します。‘M-f’に負
の引数を与えると後方に移動し、‘M-b’に負の引数を与えると前方に移動します
。前方への移動は単語の最後の文字の直後で停止し、後方への移動は、最初の文
字の直前で停止します。

   ‘M-d’ (‘kill-word’)は、ポイントの後ろの単語をkillします。正確に言うと
、ポイントから、‘M-f’で移動する位置までのすべてをkillします。したがって
ポイントが単語の途中にある場合、‘M-d’はポイントの後だけをkillします。ポ
イントと次の単語の間に区切り文字がある場合、それは単語と一緒にkillされま
す（次の単語だけをkillして、その前にある区切り文字はkillしたくないときは
、‘M-f’で最後まで移動して、‘M-<DEL>’で単語を後方にkillします)。‘M-d’は
‘M-f’と同様の引数を取ります。

   ‘M-<DEL>’ (‘backward-kill-word’)は、ポイントの前の単語をkillします。
これはポイントから、‘M-b’で移動する位置までのすべてをkillします。たとえ
ばポイントが‘FOO, BAR’のスペースの後ろにある場合、これは‘FOO, ’をkillし
ます。‘FOO’だけをkillして、カンマとスペースは残したい場合は、‘M-<DEL>’の
かわりに‘M-b M-d’を使用します。

   ‘M-t’ (‘transpose-words’)は、ポイントの前またはポイントを含む単語を、
次の単語と交換します。単語間の区切り文字は移動されません。たとえば
‘FOO, BAR’は、‘BAR FOO,’ではなく、‘BAR, FOO’に入れ替えられます。入れ替え
については、*note Transpose::を参照してください。

   リージョンにたいして操作を行う際、単語単位で操作したいときは、コマン
ド‘M-@’ (‘mark-word’)を使用します。このコマンドは‘M-f’で移動する位置にマ
ークをセットします。このコマンドにつての詳しい詳細は、*note Marking
Objects::を参照してください。

   単語にたいするコマンドが理解する単語境界は、構文テーブル(syntax
table)で制御されます。単語の区切り文字に、(たとえば)任意の文字を使うこと
ができます。*note Syntax Tables: (elisp)Syntax Tables.を参照してください
。

   以上に加えて、リージョンまたはバッファーに含まれる単語数のカウントと
リポートを行う‘M-=’ (‘count-words-region’)および‘M-x count-words’コマン
ドについては、*note Position Info::を参照してください。


File: emacs-ja.info,  Node: Sentences,  Next: Paragraphs,  Prev: Words,  Up: Text

25.2 センテンス
===============

センテンス(文)とパラグラフ(段落)を操作するEmacsコマンドは、単語を処理す
るコマンドと同様、ほとんどがMetaキーに割り当てられています。

‘M-a’
     センテンスの先頭に、後方へ移動します(‘backward-sentence’)。
‘M-e’
     センテンスの最後に、前方へ移動します(‘forward-sentence’)。
‘M-k’
     センテンスの最後まで、前方にkillします(‘kill-sentence’)。
‘C-x <DEL>’
     センテンスの最初まで、後方にkillします(‘backward-kill-sentence’)。

   コマンド‘M-a’ (‘backward-sentence’)および‘M-e’ (‘forward-sentence’)は
、センテンスの先頭または最後に移動します。これらのコマンドのバインディン
グは、行の先頭と最後に移動する‘C-a’と‘C-e’に似せて選ばれました。似ていな
い点は、‘M-a’または‘M-e’を繰り返すと、センテンス単位で連続して移動するこ
とです。

   センテンスにたいして後方に移動すると、ポイントはセンテンスの最初の文
字の直前に移動します。前方に移動したときは、センテンスを終了させる区切り
文字の直後に移動します。どちらもセンテンスの境界にある空白文字にポイント
を移動することはありません。

   ‘C-a’と‘C-e’がkillコマンド‘C-k’をもつように、‘M-a’と‘M-e’にも対応する
killコマンドがあります。‘M-k’ (‘kill-sentence’)は、ポイントからセンテン
スの最後までをkillします。正の数引数Nを指定すると、次のNセンテンスを
killします。負の数引数−Nを指定すると、後方にN番目のセンテンスの先頭まで
をkillします。

   ‘C-x <DEL>’ (‘backward-kill-sentence’)は、センテンスの先頭までを後方
にkillします。

   センテンスのコマンドは、センテンスの最後に2つのスペースを置くという
Americanのタイピストの慣習に、ユーザーが従うと仮定します。つまりセンテン
スの最後は‘.’、‘?’、‘!’の後ろに改行または2つのスペースがあると仮定し、そ
の間に任意の個数の‘)’、‘]’、‘'’、‘"’が許されます。パラグラフの先頭および
最後は、センテンスの先頭および最後でもあります。この慣習にしたがうことに
より、Emacsのセンテンスにたいするコマンドがセンテンスの最後のピリオドと
、省略形を示すピリオドを区別できるので便利になります。

   センテンスの間を1つのスペースにしたい場合は、
‘sentence-end-double-space’を‘nil’にセットすることにより、センテンスのコ
マンドが1つのスペースで止まるようになります。しかし、これにはセンテンス
の終わりのピリオドと、省略形を示すピリオドを区別できなくなるという欠点が
あります。したがって便利で信頼できる編集のために、2つのスペースの慣習に
したがうことを推奨します。変数‘sentence-end-double-space’はフィルにも影
響します(*note Fill Commands::を参照してください)。

   変数‘sentence-end’は、センテンスの終了を認識する方法を制御します。非
‘nil’の場合、その値は正規表現にすべきで、それはセンテンスの最後の数文字
(センテンスの後ろのスペースも含む)とのマッチに使用されます。値が‘nil’(デ
フォルト)の場合、Emacsは‘sentence-end-double-space’の値のような、変数条
件に照らしてセンテンスの最後を計算します。

   Thaiのようないくつかの言語は、センテンスの最後を示すのにピリオドを使
用しません。そのような場合は変数‘sentence-end-without-period’に‘t’をセッ
トします。


File: emacs-ja.info,  Node: Paragraphs,  Next: Pages,  Prev: Sentences,  Up: Text

25.3 パラグラフ
===============

パラグラフ(段落)を操作するEmacsコマンドもMetaキーに割り当てられています
。

‘M-{’
     前のパラグラフの先頭に、後方へ移動します(‘backward-paragraph’)。
‘M-}’
     次のパラグラフの最後に、前方へ移動します(‘forward-paragraph’)。
‘M-h’
     そのパラグラフ、または次のパラグラフの周囲にポイントとマークを配し
     ます(‘mark-paragraph’)。

   ‘M-{’ (‘backward-paragraph’)は、カレントのパラグラフ、または前のパラ
グラフの先頭に移動します(呼び出し時にポイントがある場所に依存する。パラ
グラフの定義は以下を参照)。同様に、‘M-}’ (‘forward-paragraph’)は、カレン
トのパラグラフ、または次のパラグラフの最後に移動します。パラグラフの前に
空行がある場合、‘M-{’はその空行に移動します。

   パラグラフにたいして操作をしたい場合、‘M-h’ (‘mark-paragraph’)とタイ
プすることにより、パラグラフの周囲にリージョンがセットされます。たとえば
‘M-h C-w’は、パラグラフの周囲またはポイントの後ろをkillします。‘M-h’は、
ポイント位置のパラグラフの先頭にポイントを、最後にマークを配します。ポイ
ントがパラグラフの間(連続する空行の中、または境界)にある場合、‘M-h’はポ
イントの後ろに続くパラグラフの周囲にリージョンをセットします。パラグラフ
の最初の行の前に空行がある場合、その空行はリージョンに含まれます。 リー
ジョンがすでにアクティブの場合、このコマンドはポイントを変更せずにマーク
をセットします。連続する‘M-h’は、マークをパラグラフ単位で先にセットしま
す。

   パラグラフの定義はメジャーモードに依存します。Fundamentalモード、同様
にTextモードとそれに関連するモードでは、パラグラフと、その隣接するパラグ
ラフを分けるのは１行以上の“空行” — 空の行、スペースとタブだけからなる行
、およびそれらに改ページ文字がついた行 — です。プログラミング言語に関す
るモードでは、通常パラグラフは同じような方法で定義されるので、パラグラフ
がないプログラムなどにたいしても、パラグラフのコマンドを使うことができま
す。

   Textモードでは、インデントされた行自体では、パラグラフの区切りには_な
らない_ことに注意してください。インデントされた行をパラグラフの分割に使
用したい場合は、かわりにParagraph-Indent Textモードを使用します。*note
Text Mode::を参照してください。

   フィルプレフィクスをセットしている場合、フィルプレフィクスで始まって
いないすべての行は、パラグラフの区切りとなります。*note Filling::を参照
してください。

   パラグラフ境界の正確な定義は、変数‘paragraph-separate’および
‘paragraph-start’により制御されます。‘paragraph-start’の値には、パラグラ
フを開始または分割する行にマッチする正規表現を指定します。
‘paragraph-separate’の値には、パラグラフの一部とならないような、パラグラ
フを分割する行にマッチする正規表現を指定します。新しいパラグラフを開始す
るパラグラフに含まれる行は、‘paragraph-start’にはマッチしますが、
‘paragraph-separate’にはマッチしません。たとえばFundamentalモードでは、
‘paragraph-start’は‘"\f\\|[ \t]*$"’、‘paragraph-separate’は
‘"[ \t\f]*$"’です。

   ‘paragraph-start’と‘paragraph-separate’はテキストの左マージンにマッチ
しますが、行頭である必要はないので、パラグラフ関数がマージンのセッティン
グに応じてテキストリージョン内で同じように確実に機能させるために、これら
のregexpに‘^’を使用するべきでないことに注意してください。


File: emacs-ja.info,  Node: Pages,  Next: Quotation Marks,  Prev: Paragraphs,  Up: Text

25.4 ページ
===========

“改ページ文字”(formfeed character: ASCIIコード12で、‘control-L’とも表示
されます)でページに分割されているものがあり、Emacsではそれらがエスケープ
シーケンス‘^L’で表示されます(*note Text Display::を参照してください)。伝
統的には、そのようなテキストファイルのハードコピーを印刷する場合、各改ペ
ージ文字で改ページされます。ほとんどのEmacsコマンドは、この文字をほかの
文字と同様に扱うので、‘C-q C-l’で挿入して、<DEL>で削除などができます。そ
れに加えて、Emacsはページ単位の移動や操作を行うコマンドを提供します。

‘M-x what-page’
     ポイント位置のページ番号と、ページ内での行番号を表示します。
‘C-x [’
     前のページ境界にポイントを移動します(‘backward-page’)。
‘C-x ]’
     次のページ境界にポイントを移動します(‘forward-page’)。
‘C-x C-p’
     現在のページ(または他のページ)の周囲に、ポイントとマークを配します
     (‘mark-page’)。
‘C-x l’
     現在のページの行数を数えます(‘count-lines-page’)。

   ‘M-x what-page’は、ファイルの先頭から数えたページ数と、そのページの行
数をエコーエリアに表示します。

   ‘C-x [’ (‘backward-page’)コマンドは、前のページ区切りの直後にポイント
を移動します。ポイントがすでにページ区切りの直後にある場合は、そのページ
区切りをスキップして、その前のページ区切りに移動します。数引数は繰り返し
回数を指定します。‘C-x ]’ (‘forward-page’)コマンドは、次のページ区切りに
前方に移動します。

   ‘C-x C-p’ (‘mark-page’)コマンドは、ポイントを現在のページの先頭(ペー
ジの先頭に隣接するページ区切りの後ろ)、マークをページの最後(ページの最後
に隣接するページ区切りの後ろ)に配します。

   ‘C-x C-p C-w’は、ページを他の場所に移動するためにkillする便利な方法で
す。‘C-x [’または‘C-x ]’で他のページへ移動して、そこにkillされたページを
yankすれば、すべてのページは再び適切に区切られます。‘C-x C-p’のリージョ
ンに後続のページ区切りだけが含まれるのは、これが期待したよう確実に機能さ
せるためです。

   ‘C-x C-p’に数引数を指定すると、現在のページから数えて何ページ目に移動
するかを指定します。0は現在のページ、1は次のページ、−1は前のページを意味
します。

   ‘C-x l’ (‘count-lines-page’)コマンドは、ページをどこで2つに分割するか
の良い指標になります。これは現在のページの全行数と、カレント行の前にある
行数と、後ろにある行数を以下のように表示します。

     Page has 96 (72+25) lines

合計が1少ないのに注意してください。これはポイントが行の先頭にない場合は
正しくなります。

   変数‘page-delimiter’は、ページがどこで始まるかを制御します。この値に
はページを分割する行の先頭にマッチする正規表現を指定します(*note
Regexps::を参照してください)。この変数の値は通常‘"^\f"’で、これは行の先
頭の改ページ文字にマッチします。


File: emacs-ja.info,  Node: Quotation Marks,  Next: Filling,  Prev: Pages,  Up: Text

25.5 クォーテーションマーク
===========================

テキストをクォートするための一般的な方法の1つは、typewriter convention(タ
イプライター方式)です。これは'like this'のようなstraight apostrophesによ
るクォートや、"like this"のようなダブルクォートを使用します。別の一般的
な方法としてはcurved quote convention(曲クォート方式)があります。これは
‘like this’や`̀like thi”のように、左右のシングルクォーテーションマークや
ダブルクォーテーションマークを使用します。(1)テキストファイルにおいては
、typewriter quotesはシンプルで可搬性があり、curved quotesはあいまいさが
少なく見栄えもよくなります。

   Electric Quoteモードにより、curved quotesをタイプするのが簡単になりま
す。オプションでタイプした文字`を‘、'を’、``を“、''を”に変換します。この
デフォルトのクォートリストは、変数‘electric-quote-chars’をカスタマイズし
て変更できます。値には左シングルクォート、右シングルクォート、左ダブルク
ォート、右ダブルクォートに対応する、4つの文字からなるリストを指定します
。デフォルト値は‘'(?‘ ?’ ?“ ?”)’です。

   Electric Quoteモードは、このモードをどこでアクティブにするかを制御す
る変数を通じて、カスタマイズできます。‘electric-quote-paragraph’が非
‘nil’の場合、テキストパラグラフ内でアクティブになります。
‘electric-quote-comment’が非‘nil’の場合、プログラミング言語のコメント内
でアクティブになります。‘electric-quote-string’が非‘nil’の場合、プログラ
ミング言語の文字列定数内でアクティブになります。デフォルトでは、
‘electric-quote-string’が‘nil’で、それ以外の変数が‘t’です。

   Electric Quoteモードはデフォルトで無効になっています。これを単一のバ
ッファーで切り替えるには‘M-x electric-quote-local-mode’、グローバルに切
り替えるには‘M-x electric-quote-mode’とタイプします。1回だけこれを抑制し
たいときは、‘`’や‘'’のかわりに、‘C-q `’と‘C-q '’を使用します。Electric
Quoteモードが無効または非アクティブのときにcurved quoteを挿入する場合、
『‘』は‘C-x 8 [’、『’』は‘C-x 8 ]’、『“』は‘C-x 8 {’、『”』は‘C-x 8 }’と
タイプします。*note Inserting Text::を参照してください。
‘electric-quote-chars’の値は、これらのキーバインドには影響を与えないこと
に注意してください。これらの値は‘electric-quote-mode’のキーバインドでは
なく、‘global-map’のバインドのためのものです。

   ---------- Footnotes ----------

   (1) curved single quote文字、U+2018 LEFT SINGLE QUOTATION MARKと
U+2018 RIGHT SINGLE QUOTATION MARKです。curved double quote文字はU+201C
LEFT DOUBLE QUOTATION MARKとU+201D RIGHT DOUBLE QUOTATION MARKです。これ
らの文字を表示できないテキスト端末では、Infoリーダーはそれらをtypewriter
ASCII quote文字として表示するかもしれません。


File: emacs-ja.info,  Node: Filling,  Next: Case,  Prev: Quotation Marks,  Up: Text

25.6 テキストのフィル
=====================

テキストを“フィル(fill)”するとは、指定した幅に収まるように行を分割するこ
とを意味します。Emacsはフィルを2つの方法で行います。Auto Fillモードでは
、自己挿入文字によるテキストの挿入で、自動的にフィルされます。テキストを
編集するときに使用できる、明示的なフィルコマンドもあります。

* Menu:

* Auto Fill::                Auto
                               Fillモードは長い行を自動的に分割します。
* Fill Commands::            パラグラフの再フィルと行の中央揃えコマンド。
* Fill Prefix::              インデントされていたり、コメントであるパラグラフのフィル。
* Adaptive Fill::            Emacsがフィルプレフィクスを自動的に決定する方法。


File: emacs-ja.info,  Node: Auto Fill,  Next: Fill Commands,  Up: Filling

25.6.1 Auto Fillモード
----------------------

“Auto Fill”モードは、行が長くなりすぎたとき、スペースの箇所で行を自動的
に分割する、バッファーローカルなマイナーモード(*note Minor Modes::を参照
)です。

‘M-x auto-fill-mode’
     Auto Fillモードを有効または無効にします。
‘<SPC>’
‘<RET>’
     Auto Fillモード中は、適切なときに行を分割します。

   モードコマンド‘M-x auto-fill-mode’は、カレントバッファーのAuto Fillモ
ードを切り替えます。他のマイナーモードと同様、正の数引数はAuto Fillモー
ドを有効にし、負の引数は無効にします。特定のメジャーモードでAuto Fillモ
ードを自動的に有効にするには、モードフックに‘auto-fill-mode’を追加します
(*note Major Modes::を参照してください)。Auto Fillモードが有効なときは、
モードラインにモード指標の‘Fill’が表示されます(*note Mode Line::を参照し
てください)。

   Auto Fillモードは、行が望ましい幅より長くなったとき、空白の位置で自動
的に行を分割します。行の分割は、<SPC>か<RET>をタイプしたときだけ発生しま
す。行の分割をさせずにスペースまたは改行を挿入したいときは、‘C-q <SPC>’ま
たは‘C-q C-j’とタイプします。‘C-o’も行の分割を発生させずに改行を挿入しま
す。

   Auto Fillモードが行を分割するときは、“適応型フィルプレフィクス
(adaptive fill prefix)”にしたがうよう試みます。フィルプレフィクスがカレ
ントパラグラフの最初の１行目、および/または2行目で推論できる場合、そのフ
ィルプレフィクスは新しい行に挿入されます(*note Adaptive Fill::を参照して
ください)。そうでない場合、新しい行はその行で<TAB>をタイプしたかのように
インデントされます(*note Indentation::を参照してください)。プログラミン
グ言語に関するモードでは、行がコメントの途中で改行された場合、新しいコメ
ント区切りが適切に挿入されてコメントが分割されます。

   Auto Fillモードはパラグラフ全体を再フィルしません。これは行の分割はし
ますが、行のマージはしません。したがって、パラグラフの途中を編集している
ときは、適切にフィルされていないパラグラフがあり得ます。これをフィルする
には、フィルコマンドを明示的に呼び出してください (*note Fill Commands::を
参照してください)。


File: emacs-ja.info,  Node: Fill Commands,  Next: Fill Prefix,  Prev: Auto Fill,  Up: Filling

25.6.2 明示的なフィルコマンド
-----------------------------

‘M-q’
     カレントパラグラフをフィルします(‘fill-paragraph’)。
‘C-x f’
     フィルの列幅をセットします(‘set-fill-column’)。
‘M-x fill-region’
     リージョンの各パラグラフをフィルします(‘fill-region’)。
‘M-x fill-region-as-paragraph’
     リージョンを1つのパラグラフとしてフィルします。
‘M-o M-s’
     行を中央に揃えます。

   コマンド‘M-q’ (‘fill-paragraph’)は、カレントのパラグラフを“フィル”し
ます。このコマンドは特定の最大列幅に適合するような方法で、パラグラフの改
行を再配分して、パラグラフの余分なスペースやタブ文字を削除します。

   ‘M-q’は通常、ポイントがあるパラグラフに作用しますが、ポイントがパラグ
ラフの間にあるときは、ポイントの後ろのパラグラフに作用します。リージョン
がアクティブの場合、かわりにリージョンのテキストに作用します。‘M-x
fill-region’を呼び出して、リージョンのテキストを明確にフィルすることもで
きます。

   ‘M-q’および‘fill-region’は、パラグラフの境界を探すために、通常の
Emacsの条件式を使用します。より細かく制御するには、ポイントとマークの間
にあるすべてを1つのパラグラフとして再フィルする、‘M-x
fill-region-as-paragraph’を使用することができます。このコマンドはリージ
ョンの空行を削除するので、分割されたテキストブロックは、1つのブロックに
結合されます。

   ‘M-q’に数引数を指定した場合、これはテキストのフィルと同時に“割付
(justify)”も指示します。これは行の右端が正確にフィル列になるように、余分
なスペースが挿入されることを意味します。余分なスペースを削除するには、引
数を指定せずに‘M-q’を使用します(‘fill-region’と同じ)。

   フィルのための行の最大幅は、バッファーローカルな変数‘fill-column’によ
り指定されます。デフォルト値は70です(*note Locals::を参照してください)。
カレントバッファーの‘fill-column’をセットする一番簡単な方法は、コマンド
‘C-x f’ (‘set-fill-column’)を使用する方法です。数引数を指定すると、それ
を新しいフィル列として使用します。‘C-u’だけを指定すると、このコマンドは
現在のポイントの水平位置を‘fill-column’にセットします。

   コマンド‘M-o M-s’ (‘center-line’)は、現在のフィル列でカレント行を中央
に揃えます。数引数Nを指定すると、Nを中央に揃えた後、ポイントを先に移動し
ます。このバインディングはTextモードのためのもので、利用可能なのはTextモ
ードとそれに関連するモードだけです(*note Text Mode::を参照してください
)。

   デフォルトでは、Emacsは2つのスペースまたは改行が後にあるピリオドを、
センテンスの終わりと判断します。後に1つのスペースしかないピリオドは、セ
ンテンスの終わりではなく、省略形を示します。それに合わせて、フィルコマン
ドも後に1つのスペースしかないピリオドでは、行を分割しません。変数
‘sentence-end-double-space’を‘nil’にセットした場合、フィルコマンドは後に
1つのスペースしかないピリオドでも行を分割するようになり、各ピリオドの後
に1つのスペースを配すようになります。他の効果とこの方法の欠点については
、*note Sentences::を参照してください。

   変数‘colon-double-space’が非‘nil’の場合、フィルコマンドはコロンの後に
2つのスペースを配します。

   行分割を許さない場所の条件を追加で指定するには、アブノーマルフック変
数‘fill-nobreak-predicate’をカスタマイズします(*note Hooks::を参照してく
ださい)。このフックの各関数は、Emacsが行を分割すべきと判断する位置で、引
数なしで呼び出されます。関数が非‘nil’値を返した場合、Emacsはその位置で行
を分割しません。このフックに指定できる関数には、
‘fill-single-word-nobreak-p’(センテンスの最初の単語の後ろ、および最後の
単語の前では分割しません)、‘fill-single-char-nobreak-p’(1文字の単語の後
ろでは分割しません)、‘fill-french-nobreak-p’(‘(’の後ろ、および‘)’、‘:’、
‘?’の前では分割しません)が含まれます。


File: emacs-ja.info,  Node: Fill Prefix,  Next: Adaptive Fill,  Prev: Fill Commands,  Up: Filling

25.6.3 フィルプレフィクス
-------------------------

“フィルプレフィクス(fill prefix)”機能により、フィルされるパラグラフの各
行が、特別な文字列(インデントされたパラグラフの行頭につける複数のスペー
スなど)で開始されるようになります。フィルプレフィクスを明示的に指定する
ことができます。明示的に指定しない場合、Emacsは自動的にそれを推測するこ
とを試みます(*note Adaptive Fill::を参照してください)。

‘C-x .’
     フィルプレフィクスをセットします(‘set-fill-prefix’)。
‘M-q’
     現在のフィルプレフィクスで、パラグラフをフィルします
     (‘fill-paragraph’)。
‘M-x fill-individual-paragraphs’
     リージョンをフィルします。インデントの変化は、新しいパラグラフの開
     始と判断されます。
‘M-x fill-nonuniform-paragraphs’
     リージョンをフィルします。パラグラフを分割する行だけを、新しいパラ
     グラフの開始と判断します。

   カレントバッファーのフィルプレフィクスを指定するには、使用したいフィ
ルプレフィクスで開始される行に移動して、プレフィクスの最後にポイントを配
し、‘C-x .’ (‘set-fill-prefix’)とタイプします(‘C-x’の後にピリオドです)。
フィルプレフィクスをオフに切り替えるには、ポイントを行の先頭に移動して
‘C-x .’とタイプして、空のフィルプレフィクスを指定します。

   フィルプレフィクスの効果がある間、フィルコマンドはフィルを行う前にパ
ラグラフの各行のフィルプレフィクスを削除して、フィルを行った後で各行にフ
ィルプレフィクスを挿入します(パラグラフの最初の行は変更されずに残ります
。これは他の行と異なるように意図されていることがよくあるからです)。Auto
Fillモードは、新しい行を作成するときにフィルプレフィクスの自動的な挿入も
行います(*note Auto Fill::を参照してください)。‘C-o’コマンドは、行の先頭
で使用したときは、新しい行を作成してフィルプレフィクスを挿入します。コマ
ンド‘M-^’は逆に、削除する改行の後ろにフィルプレフィクスがあれば、プレフ
ィクスを削除します。

   たとえば‘fill-column’が50で、フィルプレフィクスが‘;; ’の場合、以下の
テキストにたいして‘M-q’を行うと、

     ;; This is an
     ;; example of a paragraph
     ;; inside a Lisp-style comment.

結果は以下のようになります:

     ;; This is an example of a paragraph
     ;; inside a Lisp-style comment.

   ‘M-q’およびパラグラフのコマンドは、フィルプレフィクスで開始されない行
を、パラグラフの開始と判断します。これは、最初の行を除く各行がインデント
されている形式のパラグラフにたいして、良い結果を与えます。空行、またはプ
レフィクスが削除されたインデントされた行も、パラグラフを分割または開始し
ます。これは各行にコメント区切りがある、複数パラグラフにわたるコメントを
記述するときに望ましいものです。

   ‘M-x fill-individual-paragraphs’を使用して、各パラグラフに自動的にフ
ィルプレフィクスをセットできます。このコマンドはリージョンをパラグラフに
分割して、インデントの変化を新しいパラグラフの開始として扱い、それらのパ
ラグラフをフィルします。したがって1つのパラグラフのすべての行は、同じ量
のインデントをもちます。このインデントは、そのパラグラフにたいするフィル
プレフィクスの役目を果たします。

   ‘M-x fill-nonuniform-paragraphs’も同様なコマンドですが、別の方法でリ
ージョンをパラグラフに分割します。このコマンドは、
(‘paragraph-separate’で定義される)パラグラフ開始行だけを、新しいパラグラ
フの開始と判断します。これは1つのパラグラフの各行は異なる量のインデント
をもつことを想定しており、パラグラフの中で最小のインデント量をフィルプレ
フィクスに使用します。このコマンドは最初の行のインデントが、パラグラフの
他の行より少なくても多くても、良い結果をもたらします。

   フィルプレフィクスは、変数‘fill-prefix’に保存されます。変数の値は文字
列で、フィルプレフィクスがないときは‘nil’です。これはバッファーごとの変
数です。変数の変更はカレントバッファーだけに影響しますが、変更できるデフ
ォルト値も存在します。*note Locals::を参照してください。

   テキストプロパティー‘indentation’は、パラグラフのインデント量を制御す
る別の方法を提供します。*note Enriched Indentation::を参照してください。


File: emacs-ja.info,  Node: Adaptive Fill,  Prev: Fill Prefix,  Up: Filling

25.6.4 適応型フィル
-------------------

フィルコマンドは、特定なケースでは自動的に適切なフィルプレフィクスを推測
できます。空白文字または特定の区切り文字が行の先頭にあり、それがパラグラ
フの全行に適用されている場合です。

   パラグラフに2行以上の行がある場合は、2行目からフィルプレフィクスが取
得されますが、それは1行目にもそれが存在する場合だけです。

   パラグラフに1行しかない場合、フィルコマンドは、その行からフィルプレフ
ィクスを取得する_かも_しれません。この決定は複雑です。なぜならそのような
場合に妥当な、3つの選択肢があるからです。

   • 最初の行のプレフィクスを、パラグラフのすべての行に適用します。

   • 後続の行を空白文字でインデントします。これにより最初の行のプレフィ
     クスの下にテキストが並びますが、実際には最初の行からプレフィクスを
     コピーしません。

   • 2行目以降の行に特別なことは行いません。

   これら3つの書式スタイルは一般的に使用されているものです。そのためフィ
ルコマンドは、そのメジャーモードに出現するプレフィクスにもとづいて、望ま
しいスタイルを決定しようと試みます。判断基準は以下のとおりです。

   最初の行で見つかったプレフィクスが‘adaptive-fill-first-line-regexp’に
マッチするか、それがコメント開始シーケンス(メジャーモードに依存します)の
場合、見つかったプレフィクスをパラグラフのフィルに使用しますが、それは後
続の行でそれらがパラグラフの開始として振る舞わない場合に限られます。

   上記以外の場合、見つかったプレフィクスは同じ量のスペースに変換され、
それらのスペースは残りの行のフィルプレフィクスとして使用されますが、それ
は後続の行でそれらがパラグラフの開始として振る舞わない場合に限られます。

   Textモード、および空行またはページ区切りだけがパラグラフを分割するモ
ードでは、適応型フィルにより選択されるプレフィクスは、パラグラフの開始と
して振る舞わないので、常にフィルに使用できます。

   変数‘adaptive-fill-regexp’は、どのような行開始がフィルプレフィクスの
役目を果たすかを決定します。行がこの正規表現にマッチする文字で開始される
とき、プレフィクスとして使用されます。変数‘adaptive-fill-mode’を‘nil’に
セットした場合、フィルプレフィクスは自動的に選択されません。

   変数‘adaptive-fill-function’に関数をセットすることにより、より複雑な
方法で自動的にフィルプレフィクスを選択する方法を指定できます。この関数は
行の左端の直後のポイントで呼び出され、その行にもとづいた適切なフィルプレ
フィクスを返すべきです。この関数が‘nil’を返した場合、
‘adaptive-fill-regexp’がフィルプレフィクスを見つける機会を与えられます。


File: emacs-ja.info,  Node: Case,  Next: Text Mode,  Prev: Filling,  Up: Text

25.7 大文字小文字変換コマンド
=============================

Emacsには、1つの単語または任意の範囲のテキストを、大文字または小文字に変
換するコマンドがあります。

‘M-l’
     後続の単語を小文字に変換します(‘downcase-word’)。
‘M-u’
     後続の単語を大文字に変換します(‘upcase-word’)。
‘M-c’
     後続の単語の先頭の文字を大文字に変換します(‘capitalize-word’)。
‘C-x C-l’
     リージョンを小文字に変換します(‘downcase-region’)。
‘C-x C-u’
     リージョンを大文字に変換します(‘upcase-region’)。

   ‘M-l’ (‘downcase-word’)は、ポイントの後ろの単語を小文字に変換して、そ
の先にポイントを移動します。したがって、‘M-l’を繰り返すと、単語を連続し
て変換します。‘M-c’ (‘capitalize-word’)は、単語の最初の文字を大文字にし
て残りを小文字にしますが、‘M-u’ (‘upcase-word’)はすべての文字を大文字に
変換します。これらのコマンドはすべて、引数を与えると複数の単語を変換しま
す。これらのコマンドはすべてが大文字の大きなテキストを、これらが混成され
たものに変換するとき、特に有用です、なぜなら適切に‘M-l’、‘M-u’、‘M-c’を
使い分けて単語を変換しながら移動できるからです(変換が不要なときは‘M-f’を
使ってその単語をスキップします)。

   負の引数を与えると。ポイントの前の指定した数の単語にたいして、大文字
小文字の変換を適用しますが、ポイントは移動しません。これは大文字小文字を
間違えてタイプしたとき有用です。大文字小文字の変換コマンドを実行した後、
そのまま編集を続けられるからです。

   単語の途中で単語の大文字小文字を変換するコマンドが与えられた場合、ポ
イントの後ろに続く単語の一部だけに変換が適用されます(これは‘M-d’
(‘kill-word’)と互換性があります)。負の引数の場合は、ポイントの前にある単
語の一部が変換されます。

   他の大文字小文字の変換コマンドは‘C-x C-u’ (‘upcase-region’)と‘C-x
C-l’ (‘downcase-region’)で、これらはポイントとマークの間にあるすべてのテ
キストを大文字または小文字に変換します。ポイントとマークは移動しません。

   リージョンにたいする大文字小文字の変換コマンド‘upcase-region’および
‘downcase-region’は、通常では無効になっています。これは、これらを使おう
と試みたとき、確認を求められることを意味します。確認にたいして同意すると
コマンドが有効になり、それ以降は確認を求められなくなることを意味します。
*note Disabling::を参照してください。


File: emacs-ja.info,  Node: Text Mode,  Next: Outline Mode,  Prev: Case,  Up: Text

25.8 Textモード
===============

Textモードは、人間の言語のテキストファイルを編集するためのメジャーモード
です。‘.txt’という拡張子で終わる名前のファイルは、通常はTextモードで開か
れます。明示的にTextモードに切り替えるには、‘M-x text-mode’とタイプして
ください。

   Textモードでは、改行とページ区切りだけがパラグラフを分割します。結果
として、パラグラフはインデントすることができ、適応型フィルはパラグラフを
フィルするときに、どのインデントが使用されているか決定します。*note
Adaptive Fill::を参照してください。

   Textモードでは<TAB> (‘indent-for-tab-command’)コマンドは通常、カレン
ト行をインデントするかわりに、次のタブストップまで空白文字を挿入します。
詳細については、*note Indentation::を参照してください。

   Textモードは、明示的にそれらを呼び出した場合をのぞき、コメントに間す
る機能をオフに切り替えます。これは構文テーブル(syntax table)を変更するの
で、アポストロフィーは単語の一部と判断されます(たとえば‘don't’は1つの単
語と判断されます))。しかし単語がアポストロフィーで開始される場合、それは
先頭の文字を大文字にするためのプレフィクスとして扱われます(たとえば
‘M-c’により、‘'hello'’は‘'Hello'’に変換されます)。

   パラグラフの最初の行をインデントしている場合は、Textモードではなく
Paragraph-Indent Textモード(‘M-x paragraph-indent-text-mode’)を使用する
べきでしょう。このモーででは、パラグラフの間に空行を入れる必要はありませ
ん。最初の行のインデントだけでパラグラフの開始を判断するのに充分だからで
す。しかしパラグラフのすべての行がインデントされている場合は、サポートさ
れません。メジャーモードを変更したくないとき(たとえばメール作成時など)は
、‘M-x paragraph-indent-minor-mode’を使って、等価なマイナーモードを有効
にしてください。

   Textモードでは、‘M-<TAB>’が‘ispell-complete-word’にバインドされます。
このコマンドはバッファーのポイントの前にある単語を、スペル辞書を使用して
補完します。*note Spelling::を参照してください。ウィンドウマネージャーが
‘M-<TAB>’をウィンドウの切り替えに定義している場合は、かわりに‘<ESC>
<TAB>’または‘C-M-i’とタイプすることができます。

   Textモードに入ると、モードフック‘text-mode-hook’が実行されます(*note
Major Modes::を参照してください)。

   以下のセクションでは、Textモードから“派生”したいくつかのメジャーモー
ドを説明します。派生したモードは、上記で説明したTextモードのほとんどの機
能を継承します。とくに、Textモードから派生したモードは、それら自身のモー
ドフックの前に、‘text-mode-hook’を実行します。


File: emacs-ja.info,  Node: Outline Mode,  Next: Org Mode,  Prev: Text Mode,  Up: Text

25.9 Outlineモード
==================

OutlineモードはTextモードから派生したメジャーモードで、アウトライン
(outline: 概略、概要、要綱)を編集するために特化したモードです。このモー
ドはアウトライン構造のエントリー間を操作したり、バッファーの一部を一時的
に非表示にするコマンドを提供するので、アウトライン構造をより簡単に閲覧す
ることができるでしょう。‘M-x outline-mode’とタイプすることにより、
Outlineモードに切り替わります。Outlineモードに入ることにより、フック
‘text-mode-hook’、およびそれに続けてフック‘outline-mode-hook’が実行され
ます(*note Hooks::を参照してください)。

   Outlineモードで行を非表示にするコマンド(*note Outline Visibility::を
参照してください)を使用した場合、それらの行は画面に表示されなくなります
。非表示行の前にある表示された行の後ろには省略記号(3つのピリオド)が表示
され、そこに隠れたテキストがあることを示します。連続する複数の行を非表示
にした場合も、省略記号は1つだけです。

   ‘C-n’や‘C-p’のような、複数の行にたいして操作を行う編集コマンドは、非
表示の行のテキストを、その前にある表示された行の一部として扱います。表示
された行の最後にある省略記号をkillすると、省略記号に対応する後続のすべて
の非表示テキストを実際にkillします。

   Outline minorモードは、メジャーモードであるOutlineモードと同じコマン
ドを提供する、バッファーローカルなマイナーモードで、他のメジャーモードと
合わせて使うことができます。‘M-x outline-minor-mode’とタイプして、カレン
トバッファーにたいしてOutline minorモードを切り替えることができます。フ
ァイルローカル変数のセッティングを使用して、特定のファイルにたいして有効
にすることもできます(*note File Variables::を参照してください)。

   メジャーモードのOutlineモードは、‘C-c’プレフィクスで特別なキーバイン
ディングを提供します。Outline minorモードは、‘C-c @’プレフィクスで同様な
バインディングを提供します。これは他のメジャーモードの特別なコマンドとの
競合を減らすためです(変数‘outline-minor-mode-prefix’は、使用するプレフィ
クスを制御します)。

* Menu:

* Outline Format::           アウトラインのテキストがどのように見えるか。
* Outline Motion::           アウトラインを移動するための特別なコマンド。
* Outline Visibility::       なにを表示するか制御するコマンド。
* Outline Views::            アウトラインと複数ビュー。
* Foldout::                  アウトラインをズームする折り畳み。


File: emacs-ja.info,  Node: Outline Format,  Next: Outline Motion,  Up: Outline Mode

25.9.1 アウトラインのフォーマット
---------------------------------

Outlineモードは、バッファーの行には2つのタイプがあると仮定します。それは
“ヘッダー行(heading lines)”と“ボディー行(body lines)”です。ヘッダー行は
アウトラインのトピックを表します。ヘッダー行は1つ以上のアスタリスク文字
(‘*’)で開始されます。アスタリスクの数はアウトライン構造でのヘッダーの深
さを決定します。したがって1つの‘*’がついたトピックは、メジャーなトピック
になります。このヘッダーと、次の‘*’が1つのヘッダーの間にある、‘*’が2つの
ヘッダー行は、そのヘッダーのサブトピックです。ヘッダー行ではないすべての
行はボディー行です。ボディー行は、それの前にあるヘッダー行に属します。以
下は例です:

     * Food
     This is the body,
     which says something about the topic of food.

     ** Delicious Food
     This is the body of the second-level header.

     ** Distasteful Food
     This could have
     a body too, with
     several lines.

     *** Dormitory Food

     * Shelter
     Another first-level topic with its header line.

   ヘッダー行とそれに属するすべてのボディー行を合わせて、“エントリー
(entry)”と呼びます。ヘッダー行と、その配下にあるすべてのヘッダー行、それ
らすべてのボディー行を、“サブツリー(subtree)”と呼びます。

   ヘッダー行と判別する条件は、変数‘outline-regexp’をセットすることによ
りカスタマイズできます(これを行う推奨された方法は、メジャーモードの関数
を使うか、ファイルローカル変数を使う方法です)。行の開始がこのregexpにマ
ッチする行は、ヘッダー行と判断されます。(行の左端ではなく)行の途中でのマ
ッチは勘定に入りません。

   テキストにたいするマッチの長さは、ヘッダーのレベルを決定します。長い
マッチは、より深くネストされたレベルとなります。‘@chapter’、‘@section’、
‘@subsection’というコマンドが、ドキュメントをチャプター、セクション、サ
ブセクションに分割するようなテキストフォーマッターがある場合(訳注:
texinfo形式のこと)、‘outline-regexp’に‘"@chap\\|@\\(sub\\)*section"’をセ
ットすることにより、それらの行をヘッダー行と判断させることができます。こ
こでトリックに注意してください。2つの単語‘chapter’と‘section’は同じ長さ
です。しかしregexp‘chap’だけにマッチするように定義することによって、チャ
プターのヘッダーにマッチするテキストの長さを短くすることができるので、
Outlineモードはセクションがチャプターの配下であることを知ることができま
す。これは‘@chap’で始まるコマンドが他にない場合に限り機能します。

   変数‘outline-level’をセットすることにより、ヘッダー行のレベルを計算す
るためのルールを明示できに指定できます。‘outline-level’の値には、引数を
とらないカレントヘッダーのレベルを返す関数を指定します。この変数をセット
する推奨された方法は、メジャーモードのコマンドを使うか、ファイルローカル
変数を使用する方法です。


File: emacs-ja.info,  Node: Outline Motion,  Next: Outline Visibility,  Prev: Outline Format,  Up: Outline Mode

25.9.2 アウトライン移動コマンド
-------------------------------

Outlineモードはヘッダー行を後方または前方に移動する、特別な移動コマンド
を提供します。

‘C-c C-n’
     ポイントを次の可視なヘッダー行に移動します
     (‘outline-next-visible-heading’)。
‘C-c C-p’
     ポイントを前の可視なヘッダー行に移動します
     (‘outline-previous-visible-heading’)。
‘C-c C-f’
     ポイントを同じレベルの、次の可視なヘッダー行に移動します
     (‘outline-forward-same-level’)。
‘C-c C-b’
     ポイントを同じレベルの、前の可視なヘッダー行に移動します
     (‘outline-backward-same-level’)。
‘C-c C-u’
     ポイントを、より低い(より包括的な)レベルの可視のヘッダー行に移動し
     ます(‘outline-up-heading’)。

   上記のコマンドはすべて、繰り返し回数として数引数を受け取ります。たと
えば、‘C-c C-f’に引数を与えると、その数だけ前方の可視なヘッダー行と同じ
レベルに移動し、‘C-c C-u’に引数を与えると、ネストされたレベルをその数の
レベル抜け出して移動します。


File: emacs-ja.info,  Node: Outline Visibility,  Next: Outline Views,  Prev: Outline Motion,  Up: Outline Mode

25.9.3 アウトライン表示コマンド
-------------------------------

Outlineモードには、アウトライン構造にもとづいてバッファーの一部を一時的
に非表示にしたり可視にするコマンドが、いくつかあります。これらのコマンド
はアンドゥ可能ではありません。コマンドの効果は単純にアンドゥメカニズムに
記録される訳ではありませんが、それらを実行した直後に限りアンドゥできます
(*note Undo::を参照してください)。

   これらのコマンドは、カレントのヘッダー行に作用します。ポイントがヘッ
ダー行にある場合、それがカレントのヘッダー行です。ポイントがボディー行に
ある場合、カレントヘッダー行は一番近くの前にあるヘッダー行です。

‘C-c C-c’
     カレントヘッダー行のボディーを非表示にします
     (‘outline-hide-entry’)。
‘C-c C-e’
     カレントヘッダー行のボディーを可視にします(‘outline-show-entry’)。
‘C-c C-d’
     カレントヘッダー行の配下のすべて(ヘッダー行自身は含まれません)を非
     表示にします(‘outline-hide-subtree’)。
‘C-c C-s’
     カレントヘッダー行の配下のすべて(ボディー、サブヘッダーおよびそのボ
     ディーを含む)を可視にします(‘outline-show-subtree’)。
‘C-c C-l’
     カレントヘッダー行のボディーと、すべてのサブヘッダーを非表示にしま
     す(‘outline-hide-leaves’)。
‘C-c C-k’
     カレントヘッダー行のサブヘッダーをすべてのレベルで可視にします
     (‘outline-show-branches’)。
‘C-c C-i’
     カレントヘッダー行の一番近いサブヘッダー(1レベル下)を可視にします
     (‘outline-show-children’)。
‘C-c C-t’
     バッファーのすべてのボディー行を非表示にします
     (‘outline-hide-body’)。
‘C-c C-a’
     バッファーのすべての行を可視にします(‘outline-show-all’)。
‘C-c C-q’
     上位Nレベルのヘッダー行を除き、すべてを非表示にします
     (‘outline-hide-sublevels’)。
‘C-c C-o’
     ポイントのあるヘッダー行またはボディー行と、そこから最上位までのレ
     ベルにあるヘッダーを除き、すべてを非表示にします
     (‘outline-hide-other’)。

   これらのコマンドのうち、カレントヘッダー行に直接続くボディー行を非表
示にする‘C-c C-c’ (‘outline-hide-entry’)と、それらを可視にする‘C-c C-e’
(‘outline-show-entry’)が一番簡単なコマンドです。サブヘッダーとそれらのボ
ディーは影響を受けません。

   コマンド‘C-c C-d’ (‘outline-hide-subtree’)および‘C-c C-s’
(‘outline-show-subtree’)は、より強力です。これらはカレントヘッダー行の
“サブツリー” — つまりカレントヘッダー行のボディーと、すべての直接または
間接のサブヘッダーとそのボディー — に適用されます。

   コマンド‘C-c C-l’ (‘outline-hide-leaves’)は、カレントヘッダー行のボデ
ィーと、サブツリーのボディーをすべて非表示にします(サブヘッダー自身は表
示されます)。コマンド‘C-c C-k’ (‘outline-show-branches’)は、(たとえば
‘C-c C-d’)などで)前に非表示にされたサブヘッダーを可視にします。コマンド
‘C-c C-i’ (‘outline-show-children’)はこれの穏やかなバージョンで、直接的
なサブヘッダー(たとえば1レベル下のサブヘッダー)を可視にします。

   コマンド‘C-c C-o’ (‘outline-hide-other’)は、ポイントのあるエントリー
と、その祖先(アウトライン構造上でそこから最上位レベルに至るまでのヘッダ
ー)、およびトップレベルのヘッダーを除き、すべてを非表示にします。このコ
マンドは、そのバッファーの最初のヘッダーの前のボディー行も表示します。

   残りのコマンドは、バッファー全体に作用するコマンドです。‘C-c C-t’
(‘outline-hide-body’)はすべてのボディー行を非表示にするので、アウトライ
ン構造だけを見ることができます(特別な例外として、ファイルの最初にあるヘ
ッダー行より前の行は、技術的に言うとボディー行ですが、これらは非表示にな
りません)。‘C-c C-a’ (‘outline-show-all’)はすべての行を可視にします。
‘C-c C-q’ (‘outline-hide-sublevels’)は、カレントのヘッダー行(ポイントが
ヘッダー行にないときのデフォルトは1行目)の位置、またはその上にある最上位
のヘッダーを除き、すべてを非表示にします。数引数Nを指定すると、上位Nレベ
ルのヘッダー行を除き、すべてを非表示にします。この場合、上位Nレベルと、
最初のヘッダーの前のボディー行が表示されることに注意してください。

   インクリメンタル検索が、Outlineモードにより非表示にされたテキストを検
索したとき、検索された部分のバッファーは可視になります。その位置で検索を
抜けると、テキストは可視のまま残ります。アクティブなインクリメンタル検索
が、非表示のテキストにマッチするかを切り替えるには、‘M-s i’とタイプしま
す。将来の検索にたいしてデフォルトを変更するには、オプション
‘search-invisible’をカスタマイズします(このオプションは‘query-replace’、
および関連する機能が非表示のテキストを扱う方法に影響を与えます。*note
Query Replace::を参照してください)。バッファーローカルなマイナーモード
Revealモード(‘M-x reveal-mode’)を使用して、操作にしたがって自動的にテキ
ストを可視にもできます。


File: emacs-ja.info,  Node: Outline Views,  Next: Foldout,  Prev: Outline Visibility,  Up: Outline Mode

25.9.4 複数ビューによるアウトラインの閲覧
-----------------------------------------

1つのアウトラインを同時に2つのビューで、別のウィンドウで表示することがで
きます。これを行うには、‘M-x make-indirect-buffer’を使ってインダイレクト
バッファーを作らなければなりません。このコマンドの最初の引数は既存のアウ
トラインバッファーの名前で、2番目の引数は新しくインダイレクトバッファー
として使用する名前です。*note Indirect Buffers::を参照してください。

   1度インダイレクトバッファーが作成されると、‘C-x 4 b’や他のEmacsコマン
ドで、通常のやり方でウィンドウにそれを表示できます。テキストの一部を可視
にしたり非表示にするOutlineモードのコマンドは、それぞれのバッファーで独
立したエントリーを操作し、それぞれのバッファーは独自のビューをもつことが
できます。同じアウトラインにたいして2つ以上のビューが欲しいときは、追加
でインダイレクトバッファーを作成します。


File: emacs-ja.info,  Node: Foldout,  Prev: Outline Views,  Up: Outline Mode

25.9.5 折り畳み編集
-------------------

Foldoutパッケージは、OutlineモードおよびOutline minorモードを、フォール
ディング(folding: 折り畳み)コマンドで拡張します。フォールディングのアイ
デアは、アウトラインのネストされた部分にたいして、それに関連する部分と、
より高いレベルが非表示のときに、それにズームインするというものです。

   すべてのテキストと、レベル1より下のレベルが非表示になっている
Outlineモードのバッファーを考えてください。それらのヘッダーの下に何が隠
れているか見るには、‘C-c C-e’ (‘M-x outline-show-entry’)でボディーを可視
にするか、‘C-c C-i’でその子ヘッダー(レベル2)を可視にすることができます。

   Foldoutでは、‘C-c C-z’ (‘M-x foldout-zoom-subtree’)を使います。これは
そのヘッダーのボディーと、その子サブヘッダーを可視にして、バッファーをナ
ローイングするので、レベル1にヘッダーとボディー、それにレベル2のヘッダー
だけが可視になります。そのうちの1つのレベル2ヘッダーの下を見るには、カー
ソル位置をそのヘッダーに移動して、もう一度‘C-c C-z’を使用します。これに
より、そのレベル2ヘッダーのボディーと、レベル3の子サブヘッダーが可視にな
り、バッファーが再びナローイングされます。連続して好きなだけサブヘッダー
をズームインすることができます。モードラインの文字列には、今どの深さにい
るのかが表示されます。

   ヘッダーにズームインしているときに、それらの子サブヘッダーを見るには
‘C-u C-c C-z’のように数引数を指定します。何レベル下の子かを指定すること
もできます(‘M-x outline-show-children’に相当します)。たとえば
‘M-2 C-c C-z’は2レベルの子サブヘッダーを可視にします。ボディーを指定する
には‘M-- C-c C-z’のように負の引数を指定します。‘C-c C-s’ (‘M-x
outline-show-subtree’)のようにサブツリー全体を展開するには、
‘M-0 C-c C-z’のように引数に0を指定します。

   ズームインしている時でも、Outlineモードの表示および非表示の関数は、
Foldoutに干渉せずに使用できます。バッファーがナローイングされているので
、グローバルな編集操作は、ズームインされたヘッダーのテキストだけに影響し
ます、これは特定のチャプターやセクションに変更を限定するのに便利です。

   フォールドのズームを取り消す(抜ける)には、‘C-c C-x’ (‘M-x
foldout-exit-fold’)を使用します。これは最上位レベルのヘッダーの配下のす
べてのテキストと、サブヘッダーを非表示にして、バッファーの以前のビューに
戻ります。数引数はフォールドを何レベル抜けるかを指定します。0を指定する
とすべてのフォールドを抜けます。

   テキストとサブヘッダーを非表示にせずに、フォールドのナローイングを取
り消すには、負の引数を指定します。たとえば、‘M--2 C-c C-x’は2つのフォー
ルドを抜け出し、テキストとサブヘッダーは表示されたままにします。

   Foldoutモードはフォールドへの出入りと、非表示のテキストを表示するため
のマウスコマンドも提供します:

‘C-M-mouse-1’でヘッダーをクリックするとズームインします。
          シングルクリック: ボディーを可視にします。
          ダブルクリック: サブヘッダーを可視にします。
          トリプルクリック: ボディーとサブヘッダーを可視にします。
          4連クリック: サブツリー全体を可視にします。
‘C-M-mouse-2’でヘッダーをクリックしたときは可視になります
          シングルクリック: ボディーを可視にします。
          ダブルクリック: サブヘッダーを可視にします。
          トリプルクリック: ボディーとサブヘッダーを可視にします。
          4連クリック: サブツリー全体を可視にします。
‘C-M-mouse-3’でヘッダーをクリックすると、ヘッダーの配下のテキストを非表示にするか、フォールドを抜けます
          シングルクリック: サブツリーを非表示にします。
          ダブルクリック: フォールドを抜けてテキストを非表示にします。
          トリプルクリック: テキストを非表示にせずにフォールドを抜けます
          4連クリック: すべてのフォールドを抜けてテキストを非表示にしま
          す。

   ‘foldout-mouse-modifiers’をセットすることにより、(‘<Ctrl>-<Meta>-’の
かわりに)他の修飾キーを指定できます。すでに‘foldout.el’ライブラリーがロ
ードされている場合、これが効果をもつために再ロードしなければなりません。

   Foldoutパッケージを使用するには、‘M-x load-library <RET> foldout
<RET>’とタイプするか、initファイルに以下の行を記述して自動的にこれを行う
ことができます。

     (with-eval-after-load "outline"
       (require 'foldout))


File: emacs-ja.info,  Node: Org Mode,  Next: TeX Mode,  Prev: Outline Mode,  Up: Text

25.10 Orgモード
===============

Orgモードは、Emacsをオーガナイザーおよび／またはオーサリングツールとして
使用するための、Outlineモードの変種です。名前が拡張子‘.org’で終わるファ
イルは、Orgモードで開かれます(*note Choosing Modes::を参照してください
)。明示的にOrgモードに切り替えるには、‘M-x org-mode’とタイプしてください
。

   Orgモードでは、Outlineモードのように、各エントリーは1つ以上の‘*’文字
で始まるヘッダー行をもちます。*note Outline Format::を参照してください。
それに加えて、‘#’文字で始まる行は、コメントとして扱われます。

   Orgモードは、簡単にアウトライン構造を眺めたり操作するためのコマンドを
提供します。それらのコマンドのうち、一番簡単なのは<TAB> (‘org-cycle’)で
す。ヘッダー行でこのコマンドを呼び出すと、サブツリーを — (i)ヘッダー行だ
けを表示 (ii)ヘッダー行と、(あれば)直接の子ヘッダー行だけを表示 (iii)サ
ブツリー全体を表示 — の3つの異なる視点で巡回します。ボディー行にたいして
呼び出された場合、<TAB>にグローバルにバインドされたコマンドが実行されま
す。

   Orgモードのバッファーの任意の場所で、‘S-<TAB>’ (‘org-shifttab’)とタイ
プすることにより、アウトライン構造全体を — (i) 最上位ㇾベルのヘッダー行
だけを表示 (ii)ボディー行を除いたすべてのヘッダー行を表示 (iii) すべてを
表示 — の3つの異なる視点で巡回します。

   ヘッダー行で‘M-<UP>’ (‘org-metaup’)または‘M-<DOWN>’ (‘org-metadown’)と
タイプすることにより、ボディー行と(あれば)サブツリーを含むバッファー内の
エントリー全体を、上または下に移動できます。同様に‘M-<LEFT>’
(‘org-metaleft’)および‘M-<RIGHT>’ (‘org-metaright’)で、ヘッダー行を昇格
または降格できます。ボディー行で呼び出された場合は、それらのキーにグロー
バルにバインドされたコマンドが実行されます。

   以下のサブセクションでは、オーガナイザーやオーサリングシステムとして
Orgモードを使用するための基本的な操作方法を解説します。詳細については、
*note The Org Mode Manual: (org)Top.を参照してください。

* Menu:

* Org Organizer::            TODOリストとアジェンダの管理。
* Org Authoring::            Orgバッファーをさまざまなフォーマットでエクスポートする。


File: emacs-ja.info,  Node: Org Organizer,  Next: Org Authoring,  Up: Org Mode

25.10.1 オーガナイザーとしてのOrg
---------------------------------

エントリー内のどこかで‘C-c C-t’ (‘org-todo’)とタイプすることにより、その
Orgエントリーを“TODO”アイテムとして、タグ付けすることができます。これは
ヘッダー行にキーワード‘TODO’を追加します。もう一度‘C-c C-t’をタイプする
とキーワードは‘DONE’に切り替わり、さらに‘C-c C-t’とタイプするとキーワー
ド全体を除去します。‘C-c C-t’で使用されるキーワードは、変数
‘org-todo-keywords’を通じてカスタマイズすることができます。

   エントリーをTODOとして作成する他に、エントリー内で‘C-c C-s’
(‘org-schedule’)とタイプすることにより、日付を割り当てることができます。
これはEmacs Calender(*note Calendar/Diary::を参照してください)をポップア
ップして日付の入力を求め、選択された日付と一緒に、ヘッダー行の下にタグ
‘SCHEDULED’を追加します。コマンド‘C-c C-d’ (‘org-deadline’)も、タグ
‘DEADLINE’を使う以外は同じ効果をもちます。

   1度Orgファイルに計画されたTODOアイテムをもつと、‘C-c [’
(‘org-agenda-file-to-front’)とタイプすることにより、“アジェンダファイル
(agenda files)”のリストにそのファイルを追加できます。Orgモードは、たとえ
ばあなたの生活のさまざまな側面をオーガナイズするために、複数のアジェンダ
ファイルを簡単に保守できるようにデザインされています。アジェンダファイル
のリストは、変数‘org-agenda-files’に格納されています。

   アジェンダファイルのアイテムを閲覧するには、‘M-x org-agenda’とタイプ
します。このコマンドは何を見たいのか、入力を求めます(今週に行なうすべて
の事項のリストか、特定のキーワードにマッチするTODOアイテムのリストか、な
ど)。 詳細は、*note (org)Agenda views::を参照してください。


File: emacs-ja.info,  Node: Org Authoring,  Prev: Org Organizer,  Up: Org Mode

25.10.2 オーサリングシステムとしてのOrg
---------------------------------------

Orgノートを見映えよくフォーマットしたり、エクスポートして公表したいと思
うかもしれません。カレントバッファーをエクスポートするには、Orgバッファ
ーのどこかで‘C-c C-e’ (‘org-export’)とタイプします。このコマンドはエクス
ポートするフォーマットの入力を求めます。現在サポートされているフォーマッ
トは、HTML、LaTeX、Texinfo、OpenDocument(‘.odt’)、iCalendar、Markdown、
man-page、PDFです。PDFのようないくつかのフォーマットは、システムに特定の
ツールがインストールされている必要があります。

   1度に複数のファイルを特定のディレクトリー(ローカルまたはネットワーク
越し)にエクスポートするには、変数‘org-publish-project-alist’にプロジェク
トのリストを定義しなければなりません。詳細はOrgのドキュメントを参照して
ください。

   Orgはエクスポートされたドキュメントのテキストのフォーマットに適用する
、シンプルなマークアップの仕組みをサポートします:

     - This text is /emphasized/
     - This text is *in bold*
     - This text is _underlined_
     - This text uses =a teletype font=

     #+begin_quote
     ``This is a quote.''
     #+end_quote

     #+begin_example
     This is an example.
     #+end_example

   詳細は、*note (org)Exporting::、および*note (org)Publishing::を参照し
てください。


File: emacs-ja.info,  Node: TeX Mode,  Next: HTML Mode,  Prev: Org Mode,  Up: Text

25.11 TeXモード
===============

TeXはDonald Knuthにより記述された強力なテキストフォーマッターで、GNU
Emacsと同様、フリーなソフトウェアーです。TeXフォーマットにはいくつかの変
種があります。LaTeXはTeXのための簡略化された入力フォーマットです。
DocTeXはLaTeXソースが記述された特別なファイルフォーマットであり、ソース
とドキュメントが合成されています。SliTeXは、時代遅れの特別なLaTeX形式で
す。(1)

   Emacsは、それらの変種用にTeXのメジャーモードを提供します。それはPlain
TeXモード、LaTeXモード、DocTeXモード、SliTeXモードです。Emacsはバッファ
ーの内容を調べて、適切なモードを選択します(通常これはTeX様式のファイルを
visitしたときに自動的に呼び出される‘tex-mode’コマンドにより行われる。
*note Choosing Modes::を参照されたい)。ファイル内容がこれを決定するのに
不十分な場合、Emacsは‘tex-default-mode’に指定されたモードを選択します。
デフォルト値は‘latex-mode’です。Emacsが間違った選択をしたときは、コマン
ド‘M-x plain-tex-mode’、‘M-x latex-mode’、‘M-x slitex-mode’、
‘doctex-mode’を使用して、正しいTeXモードの変種を選択できます。

   以下のセクションでは、TeXモードとその変種の機能について記述しています
。TeXに関連したモードは他にもいくつかありますが、このマニュアルには記述
されていません。

   • BibTeXモードはBibTeXファイルのためのメジャーモードで、これは一般的
     にはLaTeX文書の図書目録リファレンスを維持するのに使用されます。詳細
     については、コマンド‘bibtex-mode’のドキュメント文字列を参照してくだ
     さい。

   • RefTeXパッケージは、図書目録リファレンスを管理するLaTeXモードとして
     使用されるマイナーモードを提供します。 *note The RefTeX Manual:
     (reftex)Top.を参照してください。

   • AUCTeXパッケージは、TeXおよびそれに関連するフォーマットを編集するた
     めの。より先進的な機能を提供します。これにはEmacsバッファーでTeXを
     プレビューする機能も含まれます。BibTeXモードやRefTeXパッケージとは
     異なり、AUCTeXはデフォルトではEmacsとともには配布されません。これは
     Packageメニュー(*note Packages::を参照してください)を通じてダウンロ
     ードできます。インストールされた後に、 *note The AUCTeX Manual:
     (auctex)Top.を参照してください。

* Menu:

* TeX Editing::              TeXモードで編集するための特別なコマンド。
* LaTeX Editing::            LaTeX入力ファイルのための追加のコマンド。
* TeX Print::                ファイルの一部をTeXで印刷するコマンド。
* TeX Misc::                 TeXモードのカスタマイズと関連する機能。

   ---------- Footnotes ----------

   (1) これはLaTeX由来の‘slides’ドキュメントクラスにより置き換えられまし
た。


File: emacs-ja.info,  Node: TeX Editing,  Next: LaTeX Editing,  Up: TeX Mode

25.11.1 TeX編集コマンド
-----------------------

‘"’
     コンテキストに応じて‘``’、‘"’、‘''’のどれかを挿入します
     (‘tex-insert-quote’)。
‘C-j’
     パラグラフの区切り(2つの改行)を挿入して、前のパラグラフのバランスの
     取れていない大カッコ(braces)やドル記号をチェックします
     (‘tex-terminate-paragraph’)。
‘M-x tex-validate-region’
     リージョン内のパラグラフの、バランスのとれていない大カッコやドル記
     号をチェックします。
‘C-c {’
     ‘{}’を挿入して、ポイントをその間に配します(‘tex-insert-braces’)。
‘C-c }’
     対応が取れていない、次の閉じ大カッコの後ろに、前方に移動します
     (‘up-list’)。

   TeXでは文字‘"’は通常使用されません。かわりに‘``’で始まり‘''’で終わる
引用が使用されます。したがってTeXモードは‘"’キーを‘tex-insert-quote’コマ
ンドにバインドしています。これは空白文字または開き大カッコの後ろに‘``’、
バックスラッシュの後に‘"’、それ以外の文字の場合は‘''’を挿入します。

   特別な例外として、ポイントの前のテキストが‘``’か‘''’のときに‘"’をタイ
プすると、Emacsは前のテキストを1つの‘"’で置き換えます。したがって、必要
がある時は‘""’とタイプして‘"’を挿入できます(‘C-q "’を使用してこの文字を
挿入することもできます)。

   TeXモードでは、‘$’は特別な構文コードを持っていて、それはTeXの数式モー
ドの区切りを理解しようと試みます。数式モードを抜けるために‘$’を入力した
場合、数式モードに入るための対応する‘$’の位置が1秒間表示されます。これは
閉じ大カッコが挿入されたとき、それに対応する開き大カッコが表示されるのと
同じき機能です。しかし‘$’が数式モードに入るためなのか、それとも抜けるた
めなのかを指示する方法はありません。したがって、もし対応するものがある場
合、実際にはそれが関係なくても、前の‘$’の位置が表示されます。

   TeXは大カッコを、対応が取れていなければならない区切りとして使用します
。これを1つずつ挿入するより、つねに大カッコの対応が取られている方を好む
ユーザーもいます。‘C-c {’ (‘tex-insert-braces’)を使うと、対になった大カ
ッコを挿入します。これはポイントを2つの大カッコの間に配すので、中のテキ
ストを挿入することができます。その後でコマンド‘C-c }’ (‘up-list’)を使用
すると、前方の閉じ大カッコの先に移動します。あるテキストをマークした後に
‘C-c {’を呼び出すこともでき、その場合このコマンドはマークされたテキスト
を大カッコで括ります。

   対応の取れていない大カッコをチェックするコマンドが2つあります。‘C-j’
(‘tex-terminate-paragraph’)は、ポイントの前のパラグラフをチェックして、
新しいパラグラフを開始するための2つの改行を挿入します。対応が取れていな
いものが見つかった場合、エコーエリアにメッセージを出力します。‘M-x
tex-validate-region’はリージョンを、パラグラフごとにチェックします。エラ
ーは‘*Occur*’バッファーにリストされます。そのバッファーでは、特定のミス
マッチをvisitする‘C-c C-c’などの、通常のOccurモードのコマンドを使用でき
ます(*note Other Repeating Search::を参照してください)。

   TeXのEmacsコマンドは大カッコだけではなく、角カッコ(square brackets)や
カッコ(parentheses)などもカウントすることに注意してください。これはTeX構
文をチェックする目的としては、厳密に正しいとは言えません。しかしカッコと
角カッコはテキストの中で、同じような対応の取れた区切りとして使用され、さ
まざまな移動コマンドや、対応する区切りの表示が、それらにたいして機能する
のは便利なのです。


File: emacs-ja.info,  Node: LaTeX Editing,  Next: TeX Print,  Prev: TeX Editing,  Up: TeX Mode

25.11.2 LaTeX編集コマンド
-------------------------

LaTeXモードは、plain TeXには適用できない特別な機能をいくつか提供します:

‘C-c C-o’
     LaTeXブロックのための‘\begin’と‘\end’を挿入して、ポイントをそれらの
     間の行に配します(‘tex-latex-block’)。
‘C-c C-e’
     まだ閉じていない一番内側のLaTeXブロックを閉じます
     (‘tex-close-latex-block’)。

   LaTeX入力では、テキストをブロック化するのに‘\begin’と‘\end’のタグが使
用されます。ブロックを挿入するには‘C-c C-o’ (‘tex-latex-block’)とタイプ
します。これはブロックタイプの入力を求め、適切な対応する‘\begin’と
‘\end’を挿入し、その2行の間に空行を残してポイントをそこに移動します。

   ‘C-c C-o’にたいしてブロックタイプを入力するとき、通常の補完コマンドを
使用できます(*note Completion::を参照してください)。デフォルトの補完リス
トには、標準的なLaTeXのブロックタイプが含まれています。補完にブロックタ
イプを追加したい場合は、リスト変数‘latex-block-names’をカスタマイズして
ください。

   LaTeX入力では、‘\begin’と‘\end’のタグは対応が取れていなければなりませ
ん。‘C-c C-e’ (‘tex-close-latex-block’)により、対応が取れていない最後の
‘\begin’に対応する‘\end’を挿入することができます。これは対応する
‘\begin’に調和するように‘\end’をインデントし、ポイントが行の先頭にあると
きは‘\end’タグの後ろに改行を挿入します。マイナーモード
‘latex-electric-env-pair-mode’は、‘\end’か‘\begin’の一方をタイプしたとき
、自動的に対応する‘\end’または‘\begin’を挿入します。


File: emacs-ja.info,  Node: TeX Print,  Next: TeX Misc,  Prev: LaTeX Editing,  Up: TeX Mode

25.11.3 TeX印刷コマンド
-----------------------

バッファーの全内容、または一部(たとえば大きなドキュメントの1つのチャプタ
ー)にたいして、TeXをEmacsのサブプロセスとして呼び出すことができます。

‘C-c C-b’
     カレントバッファー全体にたいしてTeXを呼び出します(‘tex-buffer’)。

‘C-c C-r’
     バッファーのヘッダーとともに、カレントリージョンにたいしてTeXを呼び
     出します(‘tex-region’)。

‘C-c C-f’
     カレントファイルにたいしてTeXを呼び出します(‘tex-file’)。

‘C-c C-v’
     最後の‘C-c C-b’、‘C-c C-r’、‘C-c C-f’コマンドの出力をプレビューしま
     す(‘tex-view’)。

‘C-c C-p’
     最後の‘C-c C-b’、‘C-c C-r’、‘C-c C-f’コマンドの出力を印刷します
     (‘tex-print’)。

‘C-c <TAB>’
     カレントファイルにたいしてBibTeXを呼び出します(‘tex-bibtex-file’)。
‘C-c C-l’
     TeX出力を表示するウィンドウを再センタリングして、最後の行が見えるよ
     うにします(‘tex-recenter-output-buffer’)。
‘C-c C-k’
     TeXサブプロセスをkillします(‘tex-kill-job’)。
‘C-c C-c’
     カレントバッファー全体にたいして、他のコンパイルコマンドを呼び出し
     ます(‘tex-compile’)。

   カレントバッファーをTeXに渡すには、‘C-c C-b’ (‘tex-buffer’)とタイプし
ます。フォーマットされた出力は、通常‘.dvi’という一時ファイルに出力されま
す。その後で‘C-c C-v’ (‘tex-view’)とタイプして、‘xdvi’のような外部プログ
ラムを起動して、出力ファイルを閲覧することができます。‘C-c C-p’
(‘tex-print’)とタイプして出力ファイルのハードコピーを印刷することもでき
ます。

   デフォルトでは‘C-c C-b’は、カレントディレクトリーでTeXを実行します。
TeXの出力もこのディレクトリーに作成されます。TeXを違うディレクトリーで実
行するには、変数‘tex-directory’を望むディレクトリー名に変更します。環境
変数‘TEXINPUTS’に相対名が含まれていたり、ファイルに含まれる‘\input’コマ
ンドが相対ファイル名の場合、‘tex-directory’を‘"."’に_しないと_、望ましく
ない結果となるでしょう。そうでない場合は、‘"/tmp"’などの他のディレクトリ
ーを指定しても安全です。

   そのバッファーにたいするTeXの変種は、‘C-c C-b’で実際に実行されるシェ
ルコマンドを決定します。Plain TeXモードでは、これは変数
‘tex-run-command’で指定され、デフォルトは‘"tex"’です。LaTeXモードでは、
これは‘latex-run-command’で指定され、デフォルトは‘"latex"’です。‘.dvi’を
閲覧するために‘C-c C-v’で実行されるシェルコマンドは、TeXの種類に関係なく
、変数‘tex-dvi-view-command’で決定されます。出力を印刷するために‘C-c
C-p’で実行されるシェルコマンドは、変数‘tex-dvi-print-command’で決定され
ます。TeXでコンパイルされたファイルを閲覧および印刷するために要求される
ファイル拡張子は、変数‘tex-print-file-extension’でセットできます。たとえ
ば、この変数に‘.pdf’をセットして、それに合わせて‘tex-dvi-view-command’と
‘tex-dvi-print-command’を変更できます。

   Emacsは出力ファイル名に通常、前のパラグラフで説明したシェルコマンド文
字列を自動的に追加します。たとえば‘tex-dvi-view-command’が‘"xdvi"’のとき
、‘C-c C-v’は‘xdvi OUTPUT-FILE-NAME’を実行します。しかし、ファイル名がコ
マンドに埋め込まれている必要があるケース、たとえばあるコマンドの引数にフ
ァイル名を与えて、そのコマンドの出力をパイプで他のコマンドに渡さなければ
いけない場合があります。コマンド文字列の‘*’で、ファイル名をどこに置くか
指定することができます。以下は例です

     (setq tex-dvi-print-command "dvips -f * | lpr")

   エラーメッセージを含むTeXからの端末出力は、‘*tex-shell*’という名前の
バッファーに表示されます。TeXでエラーが発生した場合、このバッファーに切
り替えて、適切な入力を与えることができます(これはShellモードで機能します
。*note Interactive Shell::を参照してください)。このバッファーに切り替え
なくても、これをスクロールできるので、‘C-c C-l’とタイプして最後の行を表
示することができます。

   これ以上の出力が有用でないと判断した時は、‘C-c C-k’ (‘tex-kill-job’)と
タイプしてTeXプロセスをkillします。‘C-c C-b’および‘C-c C-r’の使用すると
きも、TeXがまだ実行中の時はkillします。

   ‘C-c C-r’ (‘tex-region’)とタイプして、任意のリージョンをTeXに渡すこと
ができます。しかし、これはトリッキーです。なぜならほとんどのTeX入力ファ
イルは、先頭にパラメーターをセットしたりマクロを定義するコマンドを含んで
いるからです。この問題を解決するために、‘C-c C-r’では、必須のマクロを含
むファイル部分を指定することができます。指定したリージョンの前にそれを含
めて、TeXの入力の一部とします。ファイルの必須と指定された部分を“ヘッダー
”と呼びます。

   Plain TeXモードでヘッダーの境界を示すには、ファイルに2つの特別な文字
列を挿入します。これはヘッダーの前に‘%**start of header’、ヘッダーの後ろ
に‘%**end of header’を記述します。これらの文字列は1行に全体を記述しなけ
ればなりませんが、文字列の前または後ろに他のテキストがあっても構いません
。この2つの文字列を含む行はヘッダーの中に含まれます。‘%**start of
header’がバッファーの先頭100行にない場合、‘C-c C-r’はヘッダーがないとみ
なします。

   LaTeXモードでは、ヘッダーは‘\documentclass’または‘\documentstyle’で始
まり、‘\begin{document}’で終わります。いかなる場合でもLaTeXがこれらを要
求するので、ヘッダーを識別するのに特別なことをする必要はありません。

   コマンド(‘tex-buffer’)および(‘tex-region’)は、すべてを一時ディレクト
リーで処理します。そしてTeXでクロスリファレンスのために必要となる補助的
なファイルは利用不可です。一般的にこれらのコマンドは、すべてのクロスリフ
ァレンスが正しい必要がある最終コピーのために実行するのには適していません
。

   クロスリファレンスのための補助的なファイルを使いたいときは、‘C-c C-f’
(‘tex-file’)を使用します。これはカレントバッファーのファイルにたいして、
そのファイルのディレクトリーでTeXを実行します。TeXを実行する前に、変更さ
れたバッファーを保存するか確認が求められます。一般的には、クロスリファレ
ンスを正しく取得するために、2回(‘tex-file’)を使用する必要があります。

   変数‘tex-start-options’の値は、TeXを実行するためのオプションを指定し
ます。

   変数‘tex-start-commands’の値は、TeXを開始するTeXコマンドを指定します
。デフォルト値はTeXをノンストップモードで実行します。対話的にTeXを実行す
るときは、変数に‘""’をセットします。

   大きなサイズのTeXドキュメントは複数のファイル — 1つはメインファイルで
、他はサブファイル — に分割されているときがあります。サブファイルにたい
してTeXを実行しても通常は動作しません。メインファイルにたいして実行する
必要があるのです。サブファイルを編集するのに‘tex-file’を使えるようにする
には、変数‘tex-main-file’にメインファイルの名前をセットします。その後は
‘tex-file’はそのファイルにたいしてTeXを実行します。

   ‘tex-main-file’を使用する一番簡単な方法は、各サブファイルのローカル変
数リストにそれを指定する方法です。*note File Variables::を参照してくださ
い。

   LaTeXファイルにたいしては、BibTeXを使用してカレントバッファーのファイ
ルのための補助的なファイルを処理できます。BibTeXはデータベースの図書目録
の引用(bibliographic citations)を探して、図書目録のセクション
(bibliography section)のための引用文献(cited references)を準備します。コ
マンド‘C-c <TAB>’ (‘tex-bibtex-file’)は、カレントバッファーのファイルに
たいする‘.bbl’ファイルを生成するためにシェルコマンド
(‘tex-bibtex-command’)を実行します。一般的に、‘.aux’ファイルを生成するた
めに一度‘C-c C-f’ (‘tex-file’)を行う必要があります。その後‘C-c <TAB>’
(‘tex-bibtex-file’)を行ってから、さらなるクロスリファレンスを正しく取得
するために‘C-c C-f’ (‘tex-file’)を2回行います。

   カレントのTeXバッファーで、他のコンパイルプログラムを呼び出すには、
‘C-c C-c’ (‘tex-compile’)をタイプします。このコマンドは‘pdflatex’、
‘yap’、‘xdvi’、‘dvips’を含む、多くの一般的なプログラムに渡す引数を知って
います。標準の補完キーを使用して望ましいコンパイルプログラムを選択できま
す(*note Completion::を参照してください)。


File: emacs-ja.info,  Node: TeX Misc,  Prev: TeX Print,  Up: TeX Mode

25.11.4 TeXモード、その
-----------------------

TeXモードの変種に入ると、フック‘text-mode-hook’および‘tex-mode-hook’を実
行します。その後、‘plain-tex-mode-hook’、‘doctex-mode-hook’、
‘latex-mode-hook’、‘slitex-mode-hook’のうち、適切なものを実行します。
TeXシェルを開始すると、フック‘tex-shell-hook’を実行します。*note
Hooks::を参照してください。

   コマンド‘M-x iso-iso2tex’、‘M-x iso-tex2iso’、‘M-x iso-iso2gtex’、
‘M-x iso-gtex2iso’はLatin-1でエンコードされたファイルと、TeXでエンコード
された等価なファイルの変換に使用できます。


File: emacs-ja.info,  Node: HTML Mode,  Next: Nroff Mode,  Prev: TeX Mode,  Up: Text

25.12 SGMLモードとHTMLモード
============================

SGMLおよびHTMLのためのメジャーモードは、インデントのサポートとタグを操作
するコマンドを提供します。

   HTMLは2つのモードから構成されます — 1つ目は‘html-mode’と呼ばれる基本
的なモードで、これは若干カスタマイズされたSGMLモードの変種です。もう１つ
はデフォルトでHTMLファイルに使用されるもので‘mhtml-mode’モードと呼ばれ、
‘<script>’要素で囲まれたJavascript、および‘<style>’要素内に埋め込まれた
CSSを正しく処理することを意図しています。

‘C-c C-n’
     対話的に特殊文字を指定して、その文字に対応するSGMLの‘&’コマンドを挿
     入します(‘sgml-name-char’)。

‘C-c C-t’
     対話的にタグとタグの属性を指定します(‘sgml-tag’)。このコマンドはタ
     グ名と属性値を尋ね、開始タグと終了タグの両方を挿入し、ポイントをそ
     の間に置きます。

     プレフィクス引数Nを指定すると、このコマンドはバッファーのポイントの
     後ろにあるN個の単語の周囲にタグを配します。リージョンがアクティブな
     ときは、タグをリージョンの周辺に配します(Transient Markモードがオフ
     のときは、引数に−1を与えることにより、これを行います)。

‘C-c C-a’
     対話的にカレントタグの属性値を挿入します(‘sgml-attributes’)。

‘C-c C-f’
     対応の取れたタグのグループ(開始タグと対応する終了タグまでの範囲)を
     スキップします(‘sgml-skip-tag-forward’)。数引数は繰り返し回数として
     振る舞います。

‘C-c C-b’
     対応の取れたタグのグループ(開始タグと対応する終了タグまでの範囲)を
     後方にスキップします(‘sgml-skip-tag-backward’)。数引数は繰り返し回
     数として振る舞います。

‘C-c C-d’
     ポイント位置またはポイントの後ろのタグを削除し、それに対応するタグ
     も削除します(‘sgml-delete-tag’)。ポイントの後のタグが開始タグの場合
     は、終了タグも削除します。終了タグの場合は、開始タグも削除します。

‘C-c ? TAG <RET>’
     タグTAGの意味の説明を表示します(‘sgml-tag-help’)。引数TAGが空のとき
     は、ポイント位置のタグを説明します。

‘C-c /’
     一番内側の終了されていないタグの終了タグを挿入します
     (‘sgml-close-tag’)。タグまたはコメントの中で呼び出されたときは、終
     了タグを挿入するかわりにそれを終了させます。

‘C-c 8’
     挿入したLatin-1文字を、その文字自身ではなく、その文字を表すSGMLコマ
     ンドを挿入するマイナーモードを切り替えます(‘sgml-name-8bit-mode’)。

‘C-c C-v’
     カレントバッファーをSGMLとして評価するシェルコマンド(要指定)を実行
     します(‘sgml-validate’)。(HTMLモードでは、このキーシーケンスは違う
     コマンドを実行する。)

‘C-c <TAB>’
     バッファーの既存のタグの可視・不可視を切り替えます。これは簡単なプ
     レビューとして使用できます(‘sgml-tags-invisible’)。

   XMLドキュメントを編集するためのメジャーモードはnXMLモードと呼ばれます
。このモードは多くの既存のXMLスキーマを認識することができ、‘M-<TAB>’を通
じてXMLエレメントの補完、同様にエラーをハイライトするオンザフライ
(on-the-fly)なXMLの妥当性検証を提供します。既存のバッファーでnXMLモード
を有効にするには、‘M-x nxml-mode’とタイプするか、‘M-x xml-mode’とタイプ
しても同じです。Emacsは‘.xml’という拡張子をもつファイルにたいしてnXMLモ
ードを使用します。‘.xhtml’という拡張子をもつXHTMLファイルにたいしては、
デフォルトでEmacsはHTMLモードを使用します。変数‘auto-mode-alist’をカスタ
マイズすることによりnXMLモードを使用させることができます(*note Choosing
Modes::を参照してください)。 nXMLモードについては、それ自身のマニュアル
で説明されています: *note nXML Mode: (nxml-mode)Top.を参照してください。

   XMLはSGMLの厳格なサブセットなので、XMLを編集するのに、それほど強力で
はないSGMLモードの使用を選択することもできます。既存のバッファーでSGMLモ
ードを有効にするには、‘M-x sgml-mode’とタイプします。SGMLを有効にすると
き、EmacsはバッファーがXMLかどうかを検証します。もしXMLの場合、変数
‘sgml-xml-mode’に非‘nil’値をセットします。これにより上述したSGMLモードの
タグ挿入コマンドは、常に明示的に終了タグを挿入するようになります。


File: emacs-ja.info,  Node: Nroff Mode,  Next: Enriched Text,  Prev: HTML Mode,  Up: Text

25.13 Nroffモード
=================

NroffモードはTextモードから派生した、nroffファイル(たとえばUnixのman)の
編集に特化したメジャーモードです。‘M-x nroff-mode’とタイプすることにより
このモードにはいります。Nroffモードに入ることにより、フック
‘text-mode-hook’、その後で‘nroff-mode-hook’が実行されます(*note Hooks::を
参照してください)。

   Nroffモードでは、nroffコマンド行はパラグラフの区切りとして扱われ、ペ
ージは‘.bp’で区切られ、コメントはバックスラッシュとダブルクォートで始ま
ります。これは以下のコマンドも定義します:

‘M-n’
     nroffコマンドではない次の行の先頭に移動します
     (‘nroff-forward-text-line’)。引数は繰り返し回数です。
‘M-p’
     ‘M-n’と同様ですが上に移動します(‘nroff-backward-text-line’)。
‘M-?’
     エコーエリアにリージョンの、(nroffコマンドではない)テキストの行数を
     表示します(‘nroff-count-text-lines’)。

   Electric Nroffモードはバッファーローカルなマイナーモードで、Nroffモー
ドとともに使うことができます。このマイナーモードを切り替えるには、‘M-x
nroff-electric-mode’とタイプします(*note Minor Modes::を参照してください
)。このモードがオンのとき、グループ化を行う種類のnroffコマンドを含む行を
<RET>をタイプして終端すると、グループ化を閉じるnroffコマンドが自動的に後
続の行に挿入されます。

   NroffモードとともにOutline minorモード(*note Outline Mode::を参照して
ください)を使用する場合、ヘッダー行は‘.H’の後に数字(ヘッダーレベル)が続
く形式の行です。


File: emacs-ja.info,  Node: Enriched Text,  Next: Text Based Tables,  Prev: Nroff Mode,  Up: Text

25.14 Enrichedテキスト
======================

Enriched(多くの刺激を含む、豊かにした)は、フォーマットされたテキストファ
イルをWYSIWYG(What You See Is What You Get)な方法で編集するためのマイナ
ーモードです。Enrichedモードが有効な場合、フォントやカラーなどのさまざま
なフォーマットプロパティーを、バッファーのテキストに適用できます。バッフ
ァーを保存するときは、それらのプロパティーはテキストとともに、MIME形式
‘text/enriched’のファイルフォーマットを使用して保存されます。

   Enrichedモードは通常、Textモードとともに使用されます(*note Text
Mode::を参照してください)。これは多くのメジャーモード(構文のハイライトの
ためにFont Lockモードを使用するほとんどのプログラミング言語関連のモード
を含む)で使用される、Font Lockモードとの互換性は_ありません_。Enrichedモ
ードとは異なり、Font Lockモードはカレントバッファーの内容にもとづいて、
テキストのプロパティーを自動的に割り当てます。これらのプロパティーはディ
スクには保存されません。

   Emacsの‘data-directory’のファイル‘enriched.txt’は、Enrichedモードの機
能例として役に立ちます。

* Menu:

* Enriched Mode::            Enrichedモードの開始と終了。
* Hard and Soft Newlines::   改行には2つの種類があります。
* Editing Format Info::      テキストプロパティーの編集方法。
* Enriched Faces::           太字、斜体、下線、など。
* Enriched Indentation::     左余白と右余白の変更。
* Enriched Justification::   テキストの中央揃え、左揃え、右揃え、など。
* Enriched Properties::      特別な“テキストプロパティー”のサブメニュー。


File: emacs-ja.info,  Node: Enriched Mode,  Next: Hard and Soft Newlines,  Up: Enriched Text

25.14.1 Enrichedモード
----------------------

Enrichedモードは、バッファーローカルなマイナーモードです(*note Minor
Modes::を参照してください)。‘text/enriched’フォーマットで保存されたファ
イルをvisitすると、Emacsは自動的にEnrichedモードを有効にし、ファイル内の
フォーマット情報をバッファーのテキストに適用します。Enrichedモードが有効
なときにバッファーを保存すると、ファイルはフォーマット情報を含む
‘text/enriched’フォーマットで保存されます。

   フォーマットされたテキストで新しいファイルを作成するには、存在しない
ファイルをvisitして‘M-x enriched-mode’とタイプします。このコマンドは実際
にEnrichedモードを切り替えます。プレフィクス引数を指定した場合、引数が正
のときはEnrichedモードを有効にし、それ以外はEnrichedモードを無効にします
。Enrichedモードを無効にすると、Emacsは‘text/enriched’フォーマットでバッ
ファーを保存しなくなります。バッファーに追加されたフォーマットプロパティ
ーはバッファーに残りますが、ディスクには保存されません。

   Enrichedモードは、すべてのEmacsのテキストプロパティーを保存しません。
変数‘enriched-translations’に指定されたものだけを保存します。これにはフ
ォント、カラー、インデント、行端揃えのプロパティーが含まれます。

   ファイルをvisitしたとき、ファイルが‘text/enriched’フォーマットだと
Emacsが認識できなかった場合は、‘M-x format-decode-buffer’とタイプします
。このコマンドはファイルフォーマットの入力を求め、そのフォーマットでファ
イルを再読み込みします。‘text/enriched’フォーマットを指定することにより
、自動的にEnrichedモードが有効になります。

   ‘text/enriched’ファイルをraw形式(フォーマットされたテキストではなく、
マークアップタグを伴う通常テキスト)として閲覧するには、‘M-x
find-file-literally’を使用します(*note Visiting::を参照してください)。

   Emacsが‘text/enriched’のようなファイルフォーマットを認識・変換する方
法については、*note Format Conversion: (elisp)Format Conversion.を参照し
てください。テキストプロパティーについての詳細は、*note (elisp)Text
Properties::を参照してください。


File: emacs-ja.info,  Node: Hard and Soft Newlines,  Next: Editing Format Info,  Prev: Enriched Mode,  Up: Enriched Text

25.14.2 ハード改行とソフト改行
------------------------------

Enrichedモードでは、Emacsは2つの異なる改行、“ハード”改行と“ソフト”改行を
区別します。‘M-x use-hard-newlines’とタイプすることにより、他のバッファ
ーにたいしてこの機能を有効または無効にできます。

   ハード改行は、パラグラフを分割したりテキストがフィルされる方法に関ら
ず行区切りが必要な場所で使用され、ソフト改行はフィルで使用されます。
<RET> (‘newline’)および‘C-o’ (‘open-line’)コマンドはハード改行を挿入しま
す。Auto Fill(*note Auto Fill::を参照してください)を含むフィルコマンドは
、ソフト改行だけを挿入し、削除もソフト改行だけでハード改行は削除せずに残
します。

   したがってEnrichedモードで編集するときは、フィルされたパラグラフの途
中で行を分けるのに<RET>や‘C-o’を使うべきではありません。かわりにAuto
Fillモード、または明示的なフィルコマンド(*note Fill Commands::を参照して
ください)を使用します。テーブルやリストのように、行区切りを常に残したい
場所で<RET>や‘C-o’を使用します。そのような行では、行端揃えスタイル
(justification style)も‘unfilled’にしたいと思うかもしれません(*note
Enriched Justification::を参照してください)。


File: emacs-ja.info,  Node: Editing Format Info,  Next: Enriched Faces,  Prev: Hard and Soft Newlines,  Up: Enriched Text

25.14.3 フォーマット情報の編集
------------------------------

プロパティーを変更する一番簡単な方法は、‘Text Properties’メニューです。
このメニューは、メニューバー(*note Menu Bar::を参照してください)の
‘Edit’メニュー、または‘C-mouse-2’(*note Menu Mouse Clicks::を参照してく
ださい)で取得することができます。‘Text Properties’メニューのコマンドのい
くつかを、以下にリストします(‘M-x’)で呼び出すこともできます):

‘Remove Face Properties’
     リージョンからフェイスプロパティーを削除します
     (‘facemenu-remove-face-props’)。

‘Remove Text Properties’
     リージョンからフェイスプロパティーを含む、すべてのテキストプロパテ
     ィーを削除します(‘facemenu-remove-all’)。

‘Describe Properties’
     ポイントの後ろにある文字の、すべてのテキストプロパティーと他の情報
     をリストします(‘describe-text-properties’)。

‘Display Faces’
     定義されたフェイスのリストを表示します(‘list-faces-display’)。*note
     Faces::を参照してください。

‘Display Colors’
     定義されたカラーのリストを表示します(‘list-colors-display’)。*note
     Colors::を参照してください。

他のメニューエントリーについては、以下のセクションで説明します。


File: emacs-ja.info,  Node: Enriched Faces,  Next: Enriched Indentation,  Prev: Editing Format Info,  Up: Enriched Text

25.14.4 Enrichedテキストのフェイス
----------------------------------

以下のコマンドは、フェイスを追加または削除するのに使用することができます
(*note Faces::を参照してください)。マークがアクティブのときは、リージョ
ンのテキストに適用され、マークが非アクティブのときは、次の自己挿入文字に
適用されます。プレフィクス引数を指定すると、これらのコマンドはリージョン
がアクティブな場合でも、次の自己挿入文字に適用されます。

‘M-o d’
     すべての‘face’プロパティーを削除します(‘facemenu-set-default’)。

‘M-o b’
     ‘bold’(太字)フェイスを適用します(‘facemenu-set-bold’)。

‘M-o i’
     ‘italic’(斜体)フェイスを適用します(‘facemenu-set-italic’)。

‘M-o l’
     ‘bold-italic’(太字斜体)フェイスを適用します
     (‘facemenu-set-bold-italic’)。

‘M-o u’
     ‘underline’(下線)フェイスを適用します(‘facemenu-set-underline’)。

‘M-o o FACE <RET>’
     フェイスFACEを適用します(‘facemenu-set-face’)。

‘M-x facemenu-set-foreground’
     カラーの入力を求め(*note Colors::)、それをフォアグラウドカラーに適
     用します。

‘M-x facemenu-set-background’
     カラーの入力を求め、それをバックグラウンドカラーに適用します。

これらのコマンドは、Text Propertiesメニューからも利用可能です。

   自己挿入文字は通常、フェイスプロパティー(および他のほとんどのテキスト
プロパティー)を、そのバッファーの前の文字から継承します。次の自己挿入文
字にたいして上記のコマンドを指定した場合、その文字は前の文字からフェイス
プロパティーは継承しませんが、他のテキストプロパティーは継承します。

   Enrichedモードは、他の追加のフェイス‘excerpt’および‘fixed’を定義しま
す。これらはtext/enrichedファイルフォーマットで使われるコードに対応しま
す。‘excerpt’フェイスは引用のために使用されることを意図されており、デフ
ォルトでは‘italic’と同じように表示されます。‘fixed’フェイスは固定幅テキ
ストを指定し、デフォルトでは‘bold’と同じように表示されます。


File: emacs-ja.info,  Node: Enriched Indentation,  Next: Enriched Justification,  Prev: Enriched Faces,  Up: Enriched Text

25.14.5 Enrichedテキストのインデント
------------------------------------

Enrichedモードでは、パラグラフまたはパラグラフの一部の、右余白または左余
白に異なる量のインデントを指定できます。これらの余白は‘M-q’ (*note
Filling::を参照してください)のようなフィルコマンドにも影響します。

   IndentationサブメニューのTextプロパティーは、インデントを指定するコマ
ンドを提供します:

‘Indent More’
     リージョンを4列ずつインデントします(‘increase-left-margin’)。
     Enrichedモードでは、このコマンドは‘C-x <TAB>’でも利用可能です。数引
     数を指定した場合、何列を余白に追加するかを指定します(負の引数は余白
     を何列縮めるかを指定します)。

‘Indent Less’
     リージョンから4列のインデントを削除します。

‘Indent Right More’
     右端から4列インデントすることにより、テキストを狭くします。

‘Indent Right Less’
     右端からのインデントを4列削除します。

   変数‘standard-indent’は、これらのコマンドがインデントを追加または減少
させる列数を指定します。デフォルトは4です。Enrichedにたいするデフォルト
の右余白は、通常のように‘fill-column’により制御されます。

   ‘C-c [’ (‘set-left-margin’)または‘C-c ]’ (‘set-right-margin’)とタイプ
しても、左余白または右余白をセットできます。数引数で余白の幅を指定できま
す。指定しない場合、これらのコマンドはミニバッファーを通じて値の入力を求
めます。

   それに加えてフィルプレフィクスがある場合は、指定されたパラグラフのイ
ンデントに使用されます。‘C-x .’は、フィルプレフィクスにたいして指定され
た、新しい値の中の空白文字は含めません。フィルコマンドは各行のインデント
の後ろにフィルプレフィクスを探します。*note Fill Prefix::を参照してくだ
さい。


File: emacs-ja.info,  Node: Enriched Justification,  Next: Enriched Properties,  Prev: Enriched Indentation,  Up: Enriched Text

25.14.6 Enrichedテキストの位置調整
----------------------------------

Enrichedモードでは、以下のコマンドを使って、フィルのためにさまざまな“行
端揃えスタイル(justification styles)”を指定できます。これらのコマンドは
。ポイントを含むパラグラフ、またはリージョンがアクティブの場合は、リージ
ョンと重なるすべてのパラグラフに適用されます。

‘M-j l’
     行を左余白に揃えます(‘set-justification-left’)。

‘M-j r’
     行を右余白に揃えます(‘set-justification-right’)。

‘M-j b’
     行の途中にスペースを挿入することにより、行を両端の余白に揃えます
     (‘set-justification-full’)。

‘M-j c’
‘M-S’
     両端の余白の間で行を中央に揃えます(‘set-justification-center’)。

‘M-j u’
     フィルを完全にオフに切り替えます(‘set-justification-none’)。このセ
     ッティングにより、フィルコマンドはテキストに何も行わなくなります。
     それでも左余白はインデントすることができます。

   Text PropertiesメニューのJustificationサブメニューを使用して、行端揃
えスタイルを指定することもできます。デフォルトの行端揃えスタイルはバッフ
ァーごとの変数‘default-justification’により指定されます。この変数の値は
シンボル‘left’、‘right’、‘full’、‘center’、または‘none’のうちの1つです。
シンボルの意味は上述したコマンドに対応します。


File: emacs-ja.info,  Node: Enriched Properties,  Prev: Enriched Justification,  Up: Enriched Text

25.14.7 その他のテキストプロパティーのセッティング
--------------------------------------------------

Text PropertiesメニューのSpecial Propertiesサブメニューには、3つのテキス
トプロパティー — ‘read-only’(テキストの変更を不可にします)、
‘invisible’(テキストを非表示にします)、‘intangible’(テキスト内でのポイン
トの移動を不可にします) — を、追加または削除するエントリーがあります。
‘Remove Special’メニューアイテムは、リージョン内のテキストにたいする、こ
れらの特別なプロパティーを削除します。

   プロパティー‘invisible’および‘intangible’は保存されません。

   Enrichedモードは‘display’プロパティ(*note (elisp)Display Property::を
参照)の保存とリストアもサポートします。このプロパティはスクリーン上でテ
キストがどのように表示されるかに影響を与え、バッファーのテキスト以外のソ
ース由来のイメージや文字列も表示することができます。‘display’プロパティ
はディスプレイにたいするプロパティ処理の一部として、任意のLispフォームの
実行もサポートします。したがって、表示時しか知ることができないコンディシ
ョンにディスプレイを動的に合わせる能力を提供します。任意のLisp実行は、そ
のenrichedテキストのソースがEmacs、あるいはシステム外からのもの(たとえば
受信した電子メールの添付ファイル)である場合は、Emacsに攻撃の可能性を開く
ので、Enrichedモードではそのような実行はデフォルトで無効になっています。
変数‘enriched-allow-eval-in-display-props’を非‘nil’値にカスタマイズする
ことにより、これを有効にすることができます。


File: emacs-ja.info,  Node: Text Based Tables,  Next: Two-Column,  Prev: Enriched Text,  Up: Text

25.15 テキストベーステーブルの編集
==================================

‘table’パッケージは、テキストベースのテーブルを簡単に編集するコマンドを
提供します。以下は、そのようなテーブルがどのように見えるかの例です:

     +-----------------+--------------------------------+-----------------+
     |     Command     |          Description           |   Key Binding   |
     +-----------------+--------------------------------+-----------------+
     |  forward-char   |Move point right N characters   |       C-f       |
     |                 |(left if N is negative).        |                 |
     |                 |                                |                 |
     +-----------------+--------------------------------+-----------------+
     |  backward-char  |Move point left N characters    |       C-b       |
     |                 |(right if N is negative).       |                 |
     |                 |                                |                 |
     +-----------------+--------------------------------+-----------------+

   このようなテキストがテーブルだとEmacsが認識した場合(*note Table
Recognition::を参照してください)、テーブルのセル内容を編集すると、内容が
大きくなってセルに収まらなくなったときは、テーブルのセルを自動的にサイズ
変更します。以下のセクションで説明されている、テーブルのレイアウトを操作
したり編集するコマンドを使用することができます。

   ‘M-x table-fixed-width-mode’とタイプすることにより、自動的なテーブル
のサイズ変更を切り替えることができます。

* Menu:

* Table Definition::         テキストベースのテーブルとは何か。
* Table Creation::           テーブルを作成する方法。
* Table Recognition::        テーブルをアクティブまたは非アクティブにする方法。
* Cell Commands::            テーブルのセル指向のコマンド。
* Cell Justification::       セル内容の位置調整。
* Table Rows and Columns::   行と列の追加と削除。
* Table Conversion::         プレーンテキストとテーブルの変換。
* Table Misc::               テーブル、その他。


File: emacs-ja.info,  Node: Table Definition,  Next: Table Creation,  Up: Text Based Tables

25.15.1 テキストベーステーブルとは?
-----------------------------------

“テーブル(table)”は矩形のテキスト領域からなり、それらは“セル(cells)”に分
割されます。セルは少なくとも1文字分の幅と高さをもち、それにボーダーライ
ンは含まれません。セルは複数のセルに分割できますが、それらは重なることは
できません。

   セルのボーダーラインは、以下の変数で指定された3つの特別な文字で描画さ
れます:

‘table-cell-vertical-char’
     垂直ラインに使用される文字です。デフォルトは‘|’です。

‘table-cell-horizontal-chars’
     水平ラインに使用される文字です。デフォルトは‘"-="’です。

‘table-cell-intersection-char’
     水平ラインと垂直ラインの交点に使用される文字です。デフォルトは‘+’で
     す。

以下は_無効_なテーブルの例です:

        +-----+       +--+    +-++--+
        |     |       |  |    | ||  |
        |     |       |  |    | ||  |
        +--+  |    +--+--+    +-++--+
        |  |  |    |  |  |    +-++--+
        |  |  |    |  |  |    | ||  |
        +--+--+    +--+--+    +-++--+
           a          b          c

左から順に説明します:

  a. 重なったセル、または非矩形のセルは許されません。
  b. ボーダーは矩形でなければなりません。
  c. セルは最小でも1文字分の幅と高さがなければなりません。


File: emacs-ja.info,  Node: Table Creation,  Next: Table Recognition,  Prev: Table Definition,  Up: Text Based Tables

25.15.2 テーブルの作成
----------------------

テキストベースのテーブルをスクラッチから作成するには、‘M-x
table-insert’とタイプします。このコマンドはテーブルの列数、テーブルの行
数、セルの幅と高さの入力を求めます。セルの幅とセルの高さに、セルのボーダ
ーは含まれません。これらは1つの整数で指定するか(これは各セルの幅と高さが
同じになることを意味します)、スペースまたはカンマで区切られた整数のシー
ケンス(これはテーブルの左から右の列、上から下の行の個別のセルにたいして
幅と高さを指定します)です。その後、指定されたテーブルはポイント位置に挿
入されます。

   ‘M-x table-insert’で挿入されたテーブルは、Emacsにそれをテキストベース
のテーブルとして特別に扱うように指示する、特別なテキストプロパティーを含
みます。そのバッファーをファイルに保存して、後で再びvisitすると、それら
のプロパティーは失われ、Emacsにとってテーブルは普通のテキストとして判断
されます。これをテーブルに変換する方法については、次のセクションを参照し
てください。


File: emacs-ja.info,  Node: Table Recognition,  Next: Cell Commands,  Prev: Table Creation,  Up: Text Based Tables

25.15.3 テーブルの認識
----------------------

バッファーに既存のテーブルがあり、そのテーブルから‘M-x table-insert’で適
用された特別なテキストプロパティーが失われているとき、それはテーブルとし
て特別に扱われなくなります。これにテキストプロパティーを適用するには、
‘M-x table-recognize’とタイプします。このコマンドはカレントバッファーを
スキャンして、有効なテーブルセルを“認識”して、適切なテキストプロパティー
を適用します。反対に、‘M-x table-unrecognize’とタイプすることにより、特
別なテキストプロパティーを削除して、テーブルをプレーンテキストに変換して
、カレントバッファーのすべてのテーブルを認識しなくなります。

   以下のコマンドを使って、選択的にテーブルを認識したり認識させなくする
こともできます:

‘M-x table-recognize-region’
     カレントリージョンのテーブルを認識します。

‘M-x table-unrecognize-region’
     カレントリージョンのテーブルを認識しなくします。

‘M-x table-recognize-table’
     ポイント位置のテーブルを認識してアクティブにします。

‘M-x table-unrecognize-table’
     ポイント位置のテーブルを非アクティブにします。

‘M-x table-recognize-cell’
     ポイント位置のセルを認識してアクティブにします。

‘M-x table-unrecognize-cell’
     ポイント位置のセルを非アクティブにします。

   テーブルを認識する他の方法については、*note Table Conversion::を参照
してください。


File: emacs-ja.info,  Node: Cell Commands,  Next: Cell Justification,  Prev: Table Recognition,  Up: Text Based Tables

25.15.4 テーブルセルにたいするコマンド
--------------------------------------

コマンド‘M-x table-forward-cell’および‘M-x table-backward-cell’は、ポイ
ントをカレントセルから隣接するセルに移動します。その順番は巡回的です。ポ
イントがテーブルの最後のセルにあるとき、‘M-x table-forward-cell’はポイン
トを最初のセルに移動します。同様に、ポイントが最初のセルにあるとき、‘M-x
table-backward-cell’はポイントを最後のセルに移動します。

   ‘M-x table-span-cell’は方向 — 右、左、上、下 — の入力を求め、カレント
セルをその方向の隣接するセルにマージします。マージした結果が不正なセルの
レイアウトになる場合、このコマンドはエラーをシグナルします。

   ‘M-x table-split-cell’は、ミニバッファーを使って分割する方向の入力を
求め、カレントセルを垂直(vertically)または水平(horizontally)に分割します
。特定の方向に分割するには、‘M-x table-split-cell-vertically’と‘M-x
table-split-cell-horizontally’を使います。垂直に分割する場合、古いセルの
内容は自動的に2つの新しいセルに分割されます。水平に分割する場合、セルが
空でない場合は、セル内容をどのように分割するか入力を求めます。オプション
は‘split’(内容をポイント位置で分割)、‘left’(すべての内容を左のセルへ)、
‘right’(すべての内容を右のセルへ)です。

   以下のコマンドは、セルを拡大または縮小します。デフォルトでは、1行また
は1列ずつサイズ変更します。数引数が与えられた場合、それはサイズ変更を何
行または何列単位で行うかを指定します。

‘M-x table-heighten-cell’
     カレントセルを垂直方向に拡大します。

‘M-x table-shorten-cell’
     カレントセルを垂直方向に縮小します。

‘M-x table-widen-cell’
     カレントセルを水平方向に拡大します。

‘M-x table-narrow-cell’
     カレントセルを水平方向に縮小します。


File: emacs-ja.info,  Node: Cell Justification,  Next: Table Rows and Columns,  Prev: Cell Commands,  Up: Text Based Tables

25.15.5 セルの位置調整
----------------------

コマンド‘M-x table-justify’は、テキストベーステーブルの1つ以上のセルにた
いして、“位置調整(justification)”を行います。位置調整は、セルのテキスト
がセルの外枠にたいして、どのように位置合わせされるかを決定します。テーブ
ルの各セルは個別に位置調整できます。

   ‘M-x table-justify’は、最初に何の位置調整をするかの入力を求めます。オ
プションは‘cell’(カレントセルのみ)、‘column’(テーブルのカレント列のすべ
てのセル)、‘row’ (テーブルのカレント行のすべてのセル)です。その後、コマ
ンドは位置調整のスタイルの入力を求めます。オプションは‘left’、‘center’、
‘right’、‘top’、‘middle’、‘bottom’、または‘none’(垂直方向の位置調整を行
わないことを意味します)です。

   水平および垂直方向の位置調整スタイルは独立して指定され、2つのタイプは
同時に適用できます。たとえば‘M-x table-justify’を2回呼び出して、1回目は
位置調整に‘right’を指定して、2回目は位置調整に‘bottom’を指定することによ
り、セルの内容を右下に位置調整することができます。

   位置調整スタイルは、テキストプロパティーとしてバッファーに格納され、
バッファーをkillするかEmacsを終了すると失われます。‘M-x
table-recognize’(*note Table Recognition::を参照してください)のようなテ
ーブルの認識コマンドは、セルの内容を確認して各セルの位置調整スタイルの決
定と再適用を試みます。この機能を無効にするには、変数
‘table-detect-cell-alignment’を‘nil’に変更してください。


File: emacs-ja.info,  Node: Table Rows and Columns,  Next: Table Conversion,  Prev: Cell Justification,  Up: Text Based Tables

25.15.6 テーブルの行と列
------------------------

‘M-x table-insert-row’は、テーブルのカレント行の前にセル行を挿入します。
カレント行とポイントは、新しい行の下になります。テーブル最下にある最後の
行の後ろに行を挿入するには、ポイントをテーブルの最下線の直下にポイントを
移動して、このコマンドを呼び出します。数引数を指定することにより2つ以上
の行を挿入できます。

   同様に、‘M-x table-insert-column’は、テーブルのカレント列の左にセル列
を挿入します。右端の最右列の右に列を挿入するには、ポイントを最右線の右
(テーブルの外)に移動して、このコマンドを呼び出します。数引数は挿入する列
の数を指定します。

   ‘M-x table-delete-column’は、ポイントがあるセルの列を削除します。同様
に、‘M-x table-delete-row’は、ポイントがあるセルの行を削除します。どちら
のコマンドも数引数により削除する列または行の数を指定します。


File: emacs-ja.info,  Node: Table Conversion,  Next: Table Misc,  Prev: Table Rows and Columns,  Up: Text Based Tables

25.15.7 プレーンテキストとテーブルの変換
----------------------------------------

コマンド‘M-x table-capture’は、プレーンテキストをリージョンにキャプチャ
ーして、それをテーブルに変換します。‘M-x table-recognize’(*note Table
Recognition::を参照してください)とは異なり、元のテキストはテーブルの体裁
をとる必要はありません。テーブル的な論理構造もつことだけが必要です。

   たとえば以下の数字があったとして、これらは3つの行と、カンマで水平方向
に分割されます:

     1, 2, 3, 4
     5, 6, 7, 8
     , 9, 10

このテキストにたいして‘M-x table-capture’を呼び出すと、以下のテーブルが
生成されます:

     +-----+-----+-----+-----+
     |1    |2    |3    |4    |
     +-----+-----+-----+-----+
     |5    |6    |7    |8    |
     +-----+-----+-----+-----+
     |     |9    |10   |     |
     +-----+-----+-----+-----+

   ‘M-x table-release’は逆のことを行います。これはテーブルを元のプレーン
テキストに戻し、セルのボーダーを削除します。

   この2つのコマンドの1つの用途としては、テキストをレイアウトで編集する
ことです。以下の3つのパラグラフを見てください:

     table-capture is a powerful command.
     Here are some things it can do:

     Parse Cell Items   Using row and column delimiter regexps,
                        it parses the specified text area and
                        extracts cell items into a table.

上記のテキストを含むリージョンに‘table-capture’を適用して、列と行を区切
るregexpsに空文字列を指定すると、以下のような1つのセルからなるテーブルが
作成されます。

     +----------------------------------------------------------+
     |table-capture is a powerful command.                      |
     |Here are some things it can do:                           |
     |                                                          |
     |Parse Cell Items   Using row and column delimiter regexps,|
     |                   it parses the specified text area and  |
     |                   extracts cell items into a table.      |
     +----------------------------------------------------------+

その後でセル分割コマンド(*note Cell Commands::を参照してください)を使っ
て、各パラグラフが1つのセルを占めるようにテーブルを分割できます。

     +----------------------------------------------------------+
     |table-capture is a powerful command.                      |
     |Here are some things it can do:                           |
     +-----------------+----------------------------------------+
     |Parse Cell Items | Using row and column delimiter regexps,|
     |                 | it parses the specified text area and  |
     |                 | extracts cell items into a table.      |
     +-----------------+----------------------------------------+

これで各セルは他のセルのレイアウトに影響を与えることなく、独立して編集す
ることができるようになりました。終了したら‘M-x table-release’を呼び出し
て、テーブルをプレーンテキストに戻します。


File: emacs-ja.info,  Node: Table Misc,  Prev: Table Conversion,  Up: Text Based Tables

25.15.8 テーブル、その他
------------------------

コマンド‘table-query-dimension’は、テーブルのレイアウトとポイント位置の
テーブルセルをレポートします。以下は出力の例です:

     Cell: (21w, 6h), Table: (67w, 16h), Dim: (2c, 3r), Total Cells: 5

これはカレントセルの幅が21文字、高さが6行で、テーブルの幅が67文字、高さ
が16行で、2列3行で5つのセルがあることを示します。

   ‘M-x table-insert-sequence’は、テキスト文字列のシーケンスを、テーブル
のセルを横断して、適切に各セルに挿入します。これは、そのシーケンスの基本
文字列(base string)を尋ねて、その基本文字列を数値的(基本文字列が数字で終
わる場合)、またはASCII順で“増加”させてシーケンスを生成します。基本文字列
に加え、このコマンドはシーケンス内の要素数、増分、セル間隔、各セル内のテ
キストの行端揃えの入力を求めます。

   ‘M-x table-generate-source’は、特定のマークアップ言語にフォーマットさ
れたテーブルを生成します。このコマンドは言語(これは‘html’、‘latex’、
‘cals’のどれか1つでなければなりません)と、結果を出力するバッファー、テー
ブルの表題を尋ね、生成されたテーブルを指定したバッファーに出力します。デ
フォルトの出力バッファーは‘table.LANG’で、LANGは指定された言語です。


File: emacs-ja.info,  Node: Two-Column,  Prev: Text Based Tables,  Up: Text

25.16 2列編集
=============

2C-two-column(2列)モードは、横に並んだテキストの列を、簡単に編集できるよ
うにします。これは横に並んだ2つのウィンドウを使って、それぞれのウィンド
ウは自身のバッファーを表示します。2Cモードに入るには3つの方法があります
。

‘<F2> 2’または‘C-x 6 2’
     カレントバッファーを左に、カレントバッファーの名前にもとづいた名前
     のバッファーを右にして、2Cモードに入ります。右側のバッファーがまだ
     存在しない場合、そのバッファーは空で開始されます。カレントバッファ
     ーの内容は変更されません。

     このコマンドは、カレントバッファーが空か1列だけしか含まなくて、それ
     に別の列を追加したいときに適しています。

‘<F2> s’または‘C-x 6 s’
     2列のテキストを含むカレントバッファーを2つのバッファーに分割して、
     それを横に並べて表示します(‘2C-split’)。カレントバッファーは左側の
     バッファーになりますが、右側の列のテキストは、右側のバッファーに移
     動します。カレント列は分割ポイントを指定します。分割はカレント行か
     らバッファーの最後まで続きます。

     このコマンドはすでに2列になったテキストを含むバッファーがあり、一時
     的にそれを列に分割したいときに適しています。

‘<F2> b BUFFER <RET>’
‘C-x 6 b BUFFER <RET>’
     カレントバッファーを左側のバッファー、バッファーBUFFERを右側のバッ
     ファーにして2Cモードに入ります(‘2C-associate-buffer’)。

   ‘<F2> s’または‘C-x 6 s’は、列の区切りを探します。区切りは各行に出現す
る2列の間にある文字列です。区切りの幅は、‘<F2> s’への数引数で指定するこ
とができます。これはポイントの前の指定した文字数文を区切り文字とします。
デフォルトでは幅が1なので、ポイントの前の文字が列区切りになります。

   行が適切な位置で分割された場合、‘<F2> s’は区切りの後ろのテキストを右
側のバッファーに移動して、区切りを削除します。適切な位置に列区切りをもた
ない行は、分割されずに残ります。分割されない行は左側のバッファーに残り、
右側のバッファーの対応する行は空になります(これは2Cモードで2列にまたがる
行を書くときの方法で、そのような行は左側のバッファーに記述して、右側のバ
ッファーは空の行にします)。

   コマンド‘<F2> <RET>’または‘C-x 6 <RET>’ (‘2C-newline’)は、2つのバッフ
ァーの対応する位置にそれぞれ改行を挿入します。これは2列のテキストを分割
されたバッファーで編集するときに、新しい行を追加する一番簡単な方法です。

   望みどおりに両方のバッファーを編集し終えたら、‘<F2> 1’または‘C-x 6 1’
(‘2C-merge’)で、それらをマージします。これは右側のバッファーからテキスト
を、もう一方のバッファーの2列目にコピーします。2列編集に戻るには、‘<F2>
s’を使用します。

   ‘<F2> d’または‘C-x 6 d’は、バッファーをそのままにして、2つのバッファ
ーを分割します。‘<F2> d’とタイプしたとき、カレントではないバッファーが空
の場合、‘<F2> d’によりそのバッファーはkillされます。


File: emacs-ja.info,  Node: Programs,  Next: Building,  Prev: Text,  Up: Top

26 プログラムの編集
*******************

このチャプターでは、プログラムの編集を容易にするEmacsの機能を説明します
。これらの機能で行えるいくつかは、以下のようなものです:

   • トップレベルの定義の検索や移動(*note Defuns::を参照してください)。
   • 言語の通常のインデント規則の適用(*note Program Indent::を参照してく
     ださい)。
   • カッコの対応をとります(*note Parentheses::を参照してください)。
   • コメントの挿入、kill、位置揃え(*note Comments::を参照してください
     )。
   • プログラム構文のハイライト(*note Font Lock::を参照してください)。

* Menu:

* Program Modes::            プログラムを編集するためのメジャーモード。
* Defuns::                   プログラムの主要なトップレベル要素を操作するためのコマンド。
* Program Indent::           ネスティングを示すためのインデントの調整。
* Parentheses::              カッコを操作するコマンド。
* Comments::                 コメントの挿入、kill、位置揃え。
* Documentation::            関数ドキュメントの取得。
* Hideshow::                 ブロックの選択的な表示。
* Symbol Completion::        プログラムまたは言語でのシンボルの補完。
* MixedCase Words::          identifiersLikeThisのような識別子の処理。
* Semantic::                 ソースコードのパースにもとづいた編集ツール。
* Misc for Programs::        その他、プログラムを編集するための便利なEmacs機能。
* C Modes::                  C、C++、Objective-C、Java、IDL、Pike、AWKモードの特別なコマンド。
* Asm Mode::                 Asmモードと特別な機能。
* Fortran:: Fortranモードと特別な機能。


File: emacs-ja.info,  Node: Program Modes,  Next: Defuns,  Up: Programs

26.1 プログラミング言語のためのメジャーモード
=============================================

Emacsには、プログラミング言語のために特化した、多くのメジャーモード
(*note Major Modes::を参照してください)があります。プログラミング言語に
関連したモードは通常、式の構文、インデントの慣習的ルール、言語の構文をハ
イライトする方法、関数定義の開始と終了を検索する方法を指定します。プログ
ラムをコンパイルしたり、デバッグするための機能をもつ場合もあります。各言
語にたいするメジャーモード名は、言語名により名づけられます。たとえばCプ
ログラミング言語にたいするメジャーモードは、‘c-mode’です。

   EmacsにはLisp、Scheme、SchemeベースのDSSSL expression言語、Ada、ASM、
AWK、C、C++、Fortran、Icon、IDL(CORBA)、IDLWAVE、Java、Javascript、M4、
Makefile、Metafont(フォント作成のためのTeXの仲間)、Modula2、Object
Pascal、Objective-C、Octave、Pascal、Perl、Pike、PostScript、Prolog、
Python、Ruby、Simula、SQL、Tcl、Verilog、VHDLなどのプログラミング言語の
ためのモードがあります。Perlのための代替モードはCPerlモードと呼ばれます
。一般的なGNUおよびUnixシェルのスクリプティング言語、MS-DOS/MS-Windowsの
‘BAT’ファイル、makefiles、DNS masterファイル、一連のさまざまな設定ファイ
ルのためのモードも利用可能です。

   理想的には、Emacsは編集したいと望むすべてのプログラミング言語のための
メジャーモードをもつべきです。しかし、もしあなたのお気に入りの言語のため
のモードがない場合、それはEmacsとともに配布されないパッケージで実装され
ているかもしれません(*note Packages::を参照してください)。または、あたた
が貢献することもできます。

   ほとんどのプログラミング言語では、インデントはプログラム構造を示すた
めに行ごとに異なります。したがって、ほとんどのプログラミング言語のモード
では、‘<TAB>’とタイプすることにより、カレント行のインデントが更新されま
す(*note Program Indent::を参照してください)。さらに‘<DEL>’は通常、タブ
をあたかも等価な数のスペースであるかのように扱って、後方に削除する
‘backward-delete-char-untabify’にバインドされているので、空白文字がスペ
ースなのかタブなのか気にせずに、インデントを1列ずつ削除できます。

   プログラミング言語のモードに入ることにより、フック変数
‘prog-mode-hook’に指定されたカスタムLisp関数と、その後でモード自身のモー
ドフックが実行されます(*note Major Modes::を参照してください)。たとえば
Cモードに入ることにより、‘prog-mode-hook’と‘c-mode-hook’が実行されます。
フックについての情報は、*note Hooks::を参照してください。

   Adaモード(*note Ada Mode: (ada-mode)Top.を参照してください)、
C/C++/Objective C/Java/Corba IDL/Pike/AWKモード(*note CC Mode:
(ccmode)Top.を参照してください)、Octaveモード、VHDLモード、IDLWAVEモード
(*note IDLWAVE: (idlwave)Top.を参照してください)のマニュアルが利用可能で
す。


File: emacs-ja.info,  Node: Defuns,  Next: Program Indent,  Prev: Program Modes,  Up: Programs

26.2 トップレベルの定義、またはdefun
====================================

Emacsでは関数などの、バッファーのトップレベルの主要な定義は、“defun”と呼
ばれます。この名前はLispが由来ですが、Emacsではすべての言語に使用します
。

* Menu:

* Left Margin Paren::        開きカッコまたは同様の開始を意味する区切りは、それが左端にある場合はdefunの開始です。
* Moving by Defuns::         主要な定義を移動したりマークするコマンド。
* Imenu::                    バッファーのインデックスをメニューにする。
* Which Function::           Which
                               Functionモードはどの関数にいるか表示します。


File: emacs-ja.info,  Node: Left Margin Paren,  Next: Moving by Defuns,  Up: Defuns

26.2.1 左端の慣習
-----------------

プログラミング言語のモードの多くは、デフォルトでは左端で見つかった開始区
切りは、トップレベル定義、またはdefunの開始とみなします。したがって、*そ
のような意味をもたない場合、開始区切りを左端に配してはいけません*。たと
えば、それがトップレベルのリストの開始でない場合は、Lispファイルの左端に
開きカッコを記述しないでください。

   この慣習に従わない場合、コードの構文を解析するために、バッファーの先
頭から再スキャンが必要ですが、慣習に従うことにより、多くのEmacs操作をス
ピードアップできます。

   この慣習にしたがわない場合、defunにより動作するコマンドを明示的に使用
する場合にトラブルが起こるだけではありません。これを使用する他の機能もト
ラブルを起こすでしょう。これにはインデントコマンド(*note Program
Indent::を参照してください)と、Font Lockモード(*note Font Lock::を参照し
てください)が含まれます。

   同様な問題ケースのほとんどは、文字列リテラルで開始区切りを行の先頭に
記述したい場合です。このトラブルを避けるには、開始区切りの前にエスケープ
文字(CおよびEmacs Lispでは‘\’、その他のLisp方言のいくつかは‘/’)を配しま
す。これは文字列の内容には影響を与えませんが、その開始区切りがdefunの開
始となるのを防ぎます。以下は例です:

       (insert "Foo:
     \(bar)
     ")

   この慣習を破ったことに気づくには、Font Lockモードが助けになります。
Font Lockモードは混乱して、(クォートする必要がある)開始区切りを赤の太字
でハイライトするからです。

   この慣習をオーバーライドする必要がある場合、変数
‘open-paren-in-column-0-is-defun-start’をセッティングすることにより、こ
れを行うことができます。このユーザーオプションが‘t’(デフォルト)にセット
されている場合、列0の開きカッコまたは大カッコ(braces)は常にdefunの開始と
なります。‘nil’の場合、defunは最外レベルのカッコまたは大カッコを検索する
ことにより発見されます。

   通常は、このオプションをデフォルト値の‘t’にしておくべきです。バッファ
ーの列0にdefunの開始でないカッコまたは大カッコが含まれていて、これらのカ
ッコまたは大カッコを削除するのが何らかの理由で現実的でない場合、このオプ
ションを‘nil’にするのが役に立つかもしれません。しかしこれは大きなバッフ
ァーのスクロールや、表示の速度を著しく低下させるかもしれないことを知って
おいてください。さらに、正しく機能させるために、バッファー全体を通じてカ
ッコまたは大カッコが、正しく対応が取れていなければなりません。


File: emacs-ja.info,  Node: Moving by Defuns,  Next: Imenu,  Prev: Left Margin Paren,  Up: Defuns

26.2.2 defunの移動
------------------

これらのコマンドはトップレベルの主要な定義、または“defuns”にもとづいてポ
イントを移動したり、リージョンをセットアップします。

‘C-M-a’
     カレントまたは直前のdefunの先頭に移動します(‘beginning-of-defun’)。
‘C-M-e’
     カレントまたは直後のdefunの最後に移動します(‘end-of-defun’)。
‘C-M-h’
     カレントまたは後続のdefun全体の周囲にリージョンを設定します
     (‘mark-defun’)。

   カレントのdefunの先頭または最後に移動するコマンドは、‘C-M-a’
(‘beginning-of-defun’)と‘C-M-e’ (‘end-of-defun’)です。これらのコマンドの
1つを繰り返すか、正の数引数を使用すると、繰り返しごとに動作方向の次の
defunに移動します。

   ‘C-M-a’で負の引数−Nを指定すると、次のdefunの開始へとN回移動します。こ
れは‘C-M-e’に引数Nを与えたときに移動する位置と、正確に同じではありません
。defunの終わりは通常、後続のdefunの開始と同じ位置ではないからです(空白
文字、コメント、もしかしたら宣言がこれらのdefunを分割するからです)。同様
に‘C-M-e’に負の引数を与えると、defunの最後に後方に移動しますが、これは
‘C-M-a’に正の引数を与えた場合とは完全に異なる位置になります。

   カレントのdefunを操作するには、‘C-M-h’ (‘mark-defun’)を使用します。こ
れはカレントのdefunの最後にマークをセットし、先頭にポイントを配します。
*note Marking Objects::を参照してください。これは、そのdefunをkillしてフ
ァイルの他の場所に移動するための、一番簡単な準備方法です。defunの直前(間
に空行を挟まない)にコメントがある場合は、そのコメントもマークされます。
ポイントがdefunの間にある場合は、後続のdefunを使用します。マークがすでに
アクティブのときにこのコマンドを使用すると、リージョンの最後が、複数の
defunを含むように拡張されます。プレフィクス引数を指定した場合は、その数
のdefunをマークするか、適切な数のdefunになるようリージョンを拡張します。
負のプレフィクス引数の場合は、反対方向のdefunをマークするとともに、以降
の‘mark-defun’使用での選択方向も変更します。

   Cモードでは、‘mark-defun’とほとんど同じな‘c-mark-function’を実行しま
す。違いは、それが引数定義、関数名、リターンデータ型を含むことで、これに
よりC関数全体にリージョンが設定されます。これは標準のキーバインディング
をメジャーモードが調整する方法の例です。これにより特定の言語によりふさわ
しい方法で標準的な作業を行うのです。この目的のために、他のメジャーモード
は、これらのキーバインディングすべてを置き換えているかもしれません。


File: emacs-ja.info,  Node: Imenu,  Next: Which Function,  Prev: Moving by Defuns,  Up: Defuns

26.2.3 Imenuとは
----------------

Imenu機能は、ファイル内の主要な定義を、名前で検索する方法を提供します。
これはチャプター、セクションなどを扱う、テキストフォーマッターのためのメ
ジャーモードでも有用です(複数ファイルを扱う、より強力な機能については、
*note Xref::を参照してください)。

   ‘M-x imenu’とタイプすると、これはミニバッファーを使用して定義の名前を
読み取り、ポイントをその定義に移動します。名前の指定に補完を使用できます
。このコマンドは常に有効な名前の全体のリストを表示します。

   かわりに、コマンド‘imenu’をマウスクリックにバインドできます。そうする
と定義名を選択するために、マウスメニューが表示されます。
‘imenu-add-menubar-index’を呼び出して、バッファーのインデックスをメニュ
ーバーに追加することもできます。特定のメジャーモードのすべてのバッファー
にたいして、このメニューバーアイテムを有効にしたい場合、モードフックに
‘imenu-add-menubar-index’を追加して、これを行うことができます。しかし、
それを行うことにより、そのモードでファイルをvisitするたびに、Emacsがその
バッファーのすべての定義を検索する間、待つ必要があります。

   バッファーの内容を変更する際、定義の追加や削除をした場合は、メニュー
の‘*Rescan*’アイテムを呼び出すことにより、新しい内容にもとづいてバッファ
ーのインデックスを更新することができます。‘imenu-auto-rescan’を非‘nil’値
にセットした場合、再スキャンは自動的に発生します。テキストを少量変更した
だけの場合、再スキャンは必要ありません。

   変数‘imenu-sort-function’をセットして、メニューがソートされる方法をカ
スタマイズすることができます。デフォルトでは、名前はバッファーで出現する
順にソートされています。アルファベット順にソートしたいときは、値にシンボ
ル‘imenu--sort-by-name’を使用します。Lispコードを記述することにより、独
自の比較関数を定義することもできます。

   ImenuはWhich Functionモードに情報を提供します (*note Which
Function::を参照してください)。 Speedbarもこれを使用します(*note
Speedbar::を参照してください)。


File: emacs-ja.info,  Node: Which Function,  Prev: Imenu,  Up: Defuns

26.2.4 Which Functionモード
---------------------------

Which Function(どの関数)モードは、グローバルなマイナーモード(*note Minor
Modes::を参照してください)で、これはカレントの関数名をモードラインに表示
して、バッファーの移動にしたがってそれを更新します。

   Which Functionモードを有効または無効にするには、コマンド‘M-x
which-function-mode’を使用します。Which Functionモードは、グローバルなマ
イナーモードです。デフォルトでは、それをサポートする方法を知っている、す
べてのメジャーモード(たとえばImenuをサポートするすべてのメジャーモード
)に影響を与えます。変数‘which-func-modes’の値を‘t’(これは利用可能なすべ
てのメジャーモードをサポートすることを意味します)から、特定のメジャーモ
ードのリストに変更することにより、これを制限することができます。


File: emacs-ja.info,  Node: Program Indent,  Next: Parentheses,  Prev: Defuns,  Up: Programs

26.3 プログラムのインデント
===========================

プログラムを正しくインデントされた状態に保つには、何か変更したらEmacsを
使って再インデントするのが一番よい方法です。Emacsには1行、指定した数の行
、1つのカッコでグループ化されたすべての行をインデントするコマンドがあり
ます。

   インデントに間する全般的な情報は、*note Indentation::を参照してくださ
い。このセクションでは、プログラミング言語のモードに特有のインデント機能
について説明します。

* Menu:

* Basic Indent::             1行のインデント。
* Multi-line Indent::        複数行を1度に再インデントするコマンド。
* Lisp Indent::              Lisp関数がどのようにインデントされるべきか指定する。
* C Indent::                 Cおよび関連するモードのインデントのための追加機能。
* Custom C Indent::          Cおよび関連するモードのインデントスタイルの制御。

   Emacsは‘pp’パッケージで、Lispのプリティープリンター(pretty-printer)も
提供します。これはLispオブジェクトを、見栄えのよいインデントで再フォーマ
ットします。*note pp: (elisp)Output Functions.を参照してください。


File: emacs-ja.info,  Node: Basic Indent,  Next: Multi-line Indent,  Up: Program Indent

26.3.1 プログラムの基本的なインデントコマンド
---------------------------------------------

‘<TAB>’
     カレント行のインデントを調整します(‘indent-for-tab-command’)。
‘<RET>’
     改行を挿入して、次の行のインデントを調整します(‘newline’)。

   基本的なインデントコマンドは‘<TAB>’ (‘indent-for-tab-command’)で、こ
れは*note Indentation::で説明されています。プログラミング言語のモードで
は、‘<TAB>’は前の行のインデントと構文的な内容にもとづき、カレント行をイ
ンデントします。リージョンがアクティブのとき、‘<TAB>’はカレント行だけで
なく、リージョン内の各行をインデントします。

   *note Inserting Text::で説明されているコマンド‘<RET>’ (‘newline’)は、
‘C-j’の後に‘<TAB>’を続けるのと同じです。これは改行を挿入してから、その行
のインデントを調整します。

   カッコによるグループ化により開始される行でインデントする場合、通常
Emacsはグループ内の前の行の開始、または、カッコの後ろのテキストの下に、
行の開始を合わせます。(たとえば美的観点により)これらの行に手動で非標準的
なインデントを与えた場合は、その下の行もそれにしたがいます。

   プログラミング言語のモードのほとんどは、左端の開きカッコ、開き大カッ
コ(open-brace)、その他の開始区切りを関数の開始とみなします。編集している
コードがこの前提に違反する場合は — それらの区切りが文字列やコメントの中
にある場合でも — インデントが正しく機能するために、
‘open-paren-in-column-0-is-defun-start’に‘nil’をセットしなければなりませ
ん。*note Left Margin Paren::を参照してください


File: emacs-ja.info,  Node: Multi-line Indent,  Next: Lisp Indent,  Prev: Basic Indent,  Up: Program Indent

26.3.2 複数行のインデント
-------------------------

複数行のコードを、1度に再インデントしたいときがあるかもしれません。これ
を行う1つの方法は、マークを使う方法です。マークがアクティブでリージョン
が空でないとき、‘<TAB>’はリージョン内の各行をインデントします。一方、コ
マンド‘C-M-\’ (‘indent-region’)は、マークがアクティブか否かにかかわらず
、リージョン内の各行をインデントします(*note Indentation Commands::を参
照してください)。

   それらに加えて、Emacsはコードの大きな断片をインデントするために、以下
のコマンドを提供します:

‘C-M-q’
     カッコでグループ化された、すべての行を再インデントします。
‘C-u <TAB>’
     カッコでグループ化されたすべてを横にシフトして、最初の行が正しくイ
     ンデントされるようにします。
‘M-x indent-code-rigidly’
     リージョン内のすべての行を横にシフトしますが、コメントや文字列内で
     開始される行は変更しません。

   1つのカッコでグループ化されたものを再インデントするには、ポイントをグ
ループ化の前に配して、‘C-M-q’とタイプします。これはグループ化されたもの
の全体的なインデント(たとえばグループ化が開始される行のインデント)は変更
せずに、相対的なインデントを変更します。‘C-M-q’で実行される関数は、
Lispモードでは‘indent-pp-sexp’、Cモードでは‘c-indent-exp’、のようにメジ
ャーモードに依存します。全体的なインデントも同様に訂正したい場合は、最初
に‘<TAB>’をタイプします。

   グループ内の相対的なインデントは好ましいが、それの最初の行のインデン
トが好ましくない場合は、その最初の行にポイントを移動して‘C-u <TAB>’とタ
イプします。Lisp、C、他のいくつかのメジャーモードでは、数引数を指定した
‘<TAB>’は通常どおりカレント行をインデントしてから、カレント行で始まる、
カッコでグループ化されたすべての行を同じ量で再インデントします。このコマ
ンドは巧妙なので、文字列内で開始される行は変更しません。Cモードのときは
Cプリプロセッサー行は変更しませんが、それらにアタッチされた継続行は再イ
ンデントします。

   コマンド‘M-x indent-code-rigidly’は、‘indent-rigidly’が行うように
(*note Indentation Commands::を参照してください)、リージョン内のすべての
行を厳格(rigidly)にシフトします。このコマンドはリージョンが文字列内で開
始される場合を除き、文字列内で開始される行のインデントは変更しません。プ
レフィクス引数は、インデントする列数です。


File: emacs-ja.info,  Node: Lisp Indent,  Next: C Indent,  Prev: Multi-line Indent,  Up: Program Indent

26.3.3 Lispのインデントのカスタマイズ
-------------------------------------

Lisp式のインデントパターンは、式により呼ばれる関数によって決定することが
できます。それぞれのLisp関数のために、事前定義された複数のインデントパタ
ーンの中から選択するか、Lispプログラムで独自のものを定義できます。

   標準的なインデントのパターンは以下のとおりです。最初の引数が式の開始
行にある場合、式の2行目は最初の引数の下にインデントされます。そうでない
場合、2行目は関数名の下にインデントされ、後続の行はネストの深さが同じな
ら前の行の下にインデントされます。

   変数‘lisp-indent-offset’が非‘nil’の場合、これは式の2行目の通常のイン
デントパターンをオーバーライドするので、常にこれを含むリストより
‘lisp-indent-offset’列余計にインデントされます。

   特定の関数は、標準のパターンをオーバーライドします。名前が‘def’で始ま
る関数は、式の開始の開きカッコより‘lisp-body-indent’列多く2行目をインデ
ントすることにより、2行目を“body”の開始として扱います。

   関数名の‘lisp-indent-function’プロパティーにより、個々の関数の標準パ
ターンを、さまざまな方法でオーバーライドできます。これは通常‘declare’構
成を使用することにより、マクロ定義のために行われます。*note
(elisp)Defining Macros::を参照してください。


File: emacs-ja.info,  Node: C Indent,  Next: Custom C Indent,  Prev: Lisp Indent,  Up: Program Indent

26.3.4 Cのインデントのためのコマンド
------------------------------------

Cおよび関連するモードのインデントのために、特別な機能があります。

‘C-c C-q’
     カレントのトップレベル関数を再インデント、または型定義を統合します
     (‘c-indent-defun’)。

‘C-M-q’
     ポイントの後ろの、対応が取れた式の中の各行を再インデントします
     (‘c-indent-exp’)。プレフィクス引数は、無効な構文についての警告メッ
     セージを抑制します。

‘<TAB>’
     カレント行の再インデントおよび／またはタブ文字を挿入する場合もあり
     ます(‘c-indent-command’)。

     ‘c-tab-always-indent’が‘t’の場合、このコマンドは常にカレント行をイ
     ンデントし、他には何もしません。これがデフォルトです。

     この変数が‘nil’の場合、このコマンドはポイントが左端か、その行のイン
     デント位置にある場合だけ、カレント行を再インデントします。そうでな
     い場合、このコマンドはタブ(‘indent-tabs-mode’が‘nil’の場合は等価な
     数のスペース)を挿入します。

     (‘nil’でも‘t’でもない)他の値の場合、常にその行をインデントし、コメ
     ントか文字列の中の場合は、タブも挿入します。

   カレントバッファー全体を再インデントするには、‘C-x h C-M-\’とタイプし
ます。これは最初にバッファー全体をリージョンとして選択し、それからリージ
ョンを再インデントします。

   カレントブロックを再インデントするには、‘C-M-u C-M-q’を使用します。こ
れはブロックの前に移動してから、ブロックのすべてを再インデントします。


File: emacs-ja.info,  Node: Custom C Indent,  Prev: C Indent,  Up: Program Indent

26.3.5 Cのインデントのカスタマイズ
----------------------------------

Cモードおよび関連するモードは、インデントをカスタマイズするために柔軟な
メカニズムを使用します。Cモードはソース行を2ステップでインデントします。
最初のステップは、行の内容とコンテキストに応じて行の構文を分類します。次
のステップで、構文コンストラクトで選択された“スタイル”により、関連付けら
れたインデントのオフセットを決定して、これを“アンカーとなる命令文(anchor
statement)”のインデントに加えます。

‘C-c . STYLE <RET>’
     事前に定義されたスタイルSTYLEを選択します(‘c-set-style’)。

   “スタイル”とは、Cモードおよび関連するモードで使用できるカスタマイズ用
の名前つきコレクションです。完全な説明は、*note (ccmode)Styles::を参照し
てください。Emacsには、‘gnu’、‘k&r’、‘bsd’、‘stroustrup’、‘linux’、
‘python’、‘java’、‘whitesmith’、‘ellemtel’、‘awk’を含む、事前に定義され
たスタイルがいくつか付属します。これらのスタイルのうちいくつかは、主に
1つの言語を意図したものですが、他のスタイルはこれらのモードをサポートす
る任意の言語で使用できます。スタイルがどのように見えるかは、何らかのコー
ドにたいしてスタイルを選択して、(たとえば関数定義の最初で‘C-M-q’とタイプ
して)再インデントしてみることです。

   カレントバッファーのスタイルを選択するには、コマンド‘C-c .’を使用しま
す。引数として、スタイル名を指定します(大文字小文字に意味はありません)。
このコマンドはカレントバッファーだけに影響し、将来のインデントコマンドの
呼び出しだけに影響します。そのバッファーにすでにあるコードの再インデント
はしません。バッファー全体を新しいスタイルで再インデントするには、‘C-x h
C-M-\’とタイプしてください。

   変数‘c-default-style’をセットして、さまざまなメジャーモードにたいして
デフォルトのスタイルを指定できます。この値は、スタイル名(文字列)、または
各要素が1つのメジャーモードと、それに使用するインデントスタイルを指定す
るalistです。たとえば、

     (setq c-default-style
           '((java-mode . "java")
             (awk-mode . "awk")
             (other . "gnu")))

これはJavaモード、AWKモードにたいして明示的に選択して、その他のC-likeな
モードにたいしては、デフォルトの‘gnu’スタイルを指定します。この変数は
C-likeなメジャーモードを選択したときに効果を表します。したがってJavaモー
ドにたいして新しいデフォルトスタイルを指定するには、既存のJavaモードのバ
ッファーで、‘M-x java-mode’とタイプすることにより効果が表れます。

   ‘gnu’スタイルは、CにたいするGNUプロジェクトで推奨されるフォーマットを
指定します。これがデフォルトで、私たちが使用を推奨するスタイルです。

   既存のスタイルのオーバーライドや、独自のスタイルを定義する方法など、
Cおよび関連するモードにたいするインデントのカスタマイズに間する情報は、
*note (ccmode)Indentation Engine Basics::、および*note
(ccmode)Customizing Indentation::を参照してください。

   スタイルを指定するかわりに、サンプルコードのバッファーで‘M-x
c-guess’とタイプすることにより、Emacsにスタイルを推測させることができま
す。その後、‘M-x c-guess-install’として、推測されたスタイルを他のバッフ
ァーに適用できます。詳細については、*note (ccmode)Guessing the Style::を
参照してください。


File: emacs-ja.info,  Node: Parentheses,  Next: Comments,  Prev: Program Indent,  Up: Programs

26.4 カッコに付随する編集のためのコマンド
=========================================

このセクションでは、プログラム内のカッコ構造を活用したり、それらを対応が
取れた状態に保つためのコマンドと機能について説明します。

   これらの機能を語るとき、用語“カッコ(parenthesis)”には、大カッコ
(braces)、角カッコ(brackets)、またはマッチするペアとして定義される区切り
も含まれます。メジャーモードはどの区切りに意味があるかを、構文テーブル
(syntax table)を通じて制御します(*note Syntax Tables: (elisp)Syntax
Tables.を参照してください)。Lispでは丸カッコ(parentheses)だけが考慮され
、Cではこれらのコマンドは大カッコや角カッコにも適用されます。

   ‘M-x check-parens’を使用して、バッファー内の対応の取れていないカッコ
と、対応が取れていない文字列のクォートを検索することができます。

* Menu:

* Expressions::              対応が取れたカッコの式。
* Moving by Parens::         カッコ構造を上、下、横断して移動するコマンド。
* Matching::                 終了区切りの挿入による、マッチする開始区切りのフラッシュ表示。


File: emacs-ja.info,  Node: Expressions,  Next: Moving by Parens,  Up: Parentheses

26.4.1 対応が取れたカッコの式
-----------------------------

プログラミング言語のモードはそれぞれ、“対応が取れた式(balanced
expression)”にたいする、独自の定義をもちます。対応が取れた式は通常、個別
のシンボル、数字、文字列定数、同様にマッチする区切りで囲まれたコードの断
片を含みます。以下のコマンドは対応が取れた式にたいするものです(Emacsでは
、内部的にそのような式は“sexp”として参照されます(1))。

‘C-M-f’
     対応が取れた式を、前方に飛び越して移動します(‘forward-sexp’)。
‘C-M-b’
     対応が取れた式を、後方に飛び越して移動します(‘backward-sexp’)。
‘C-M-k’
     対応が取れた式を、前方にkillします(‘kill-sexp’)。
‘C-M-t’
     式を入れ替えます(‘transpose-sexps’)。
‘C-M-@’
‘C-M-<SPC>’
     後続の式の後ろに、マークを配します(‘mark-sexp’)。

   対応が取れた式を前方に飛び越して移動するには、‘C-M-f’
(‘forward-sexp’)を使用します。ポイントの後ろの最初の文字が開始区切り(た
とえばCでは‘(’、‘[’、‘{’)の場合、このコマンドはそれにマッチする終了区切
りまで移動します。文字がシンボル、文字列、数字で始まる場合、このコマンド
はそれらを飛び越して移動します。

   コマンド‘C-M-b’ (‘backward-sexp’)は対応が取れた式を後方 — ‘C-M-f’と同
様ですが逆向き — に飛び越して移動します。式の前にプレフィクス文字がある
場合(Lispではシングルクォート、バッククォート、カンマ)、このコマンドはそ
れらも同様に飛び越して後方に移動します。

   ‘C-M-f’および‘C-M-b’に数引数を与えると、指定した回数繰り返し操作をし
ます。負の引数を与えると、反対の方向に移動します。ほとんどのモードでは、
これらの2つのコマンドはコメントをあたかも空白文字のように通過します。こ
れら‘C-M-f’および‘C-M-b’のキーは、文字単位で移動する‘C-f’および
‘C-b’(*note Moving Point::を参照してください)、単語単位に移動する‘M-f’お
よび‘M-b’(*note Words::を参照してください)に類似していることに注意してく
ださい。

   対応が取れた式全体をkillするには、‘C-M-k’ (‘kill-sexp’)とタイプします
。これは‘C-M-f’が飛び越すテキストをkillします。

   ‘C-M-t’ (‘transpose-sexps’)は、前にある対応の取れた式と、次の対応の取
れた式の位置をスイッチします。このコマンドは、文字を入れ替える‘C-t’コマ
ンド(*note Transpose::を参照してください)と類似しています。‘C-M-t’への引
数は繰り返し回数を意味し、前の式を、何個か先の式に移動します。負の引数は
前にある対応が取れた式を後方に、それらの式の前に移動します。引数0は何も
しないのではなく、ポイントの位置で終わる対応が取れた式、またはポイントの
後ろの式と、マークの後ろの式を入れ替えます。

   リージョンにたいして動作するコマンドで対応が取れた式を操作するには、
‘C-M-<SPC>’ (‘mark-sexp’)とタイプします。これは‘C-M-f’が移動する位置にマ
ークをセットします。マークがアクティブの間、このコマンドを連続で呼び出す
とマークが1つの式ごとにシフトしてリージョンが拡張します。正または負の引
数はマークを前方または後方に指定した数の式分のマークを移動します。エイリ
アス‘C-M-@’は、‘C-M-<SPC>’と等価です。これに関連したコマンドは、*note
Marking Objects::を参照してください。

   Cのように挿入オペレーター(infix operators)を使用する言語では、与えら
れた位置で複数の可能な解釈があるので、すべての対応が取れた式を認識するの
は不可能です。たとえば‘foo + bar’は1つのCの式ですが、Cモードはこれを1つ
の式とは扱いません。かわりに‘foo’を1つの式、‘bar’をもう1つの式、そしてそ
れらの間にある‘+’を句読点として認識します。しかしカッコがあればCモードは
‘(foo + bar)’を1つの式として認識します。

   ---------- Footnotes ----------

   (1) 単語“sexp”はLispで式を参照するのに使用されます。


File: emacs-ja.info,  Node: Moving by Parens,  Next: Matching,  Prev: Expressions,  Up: Parentheses

26.4.2 カッコ構造の移動
-----------------------

以下のコマンドはカッコ(または、あなたが使用している言語で、そのような区
切りとして使用される文字)で区切られてグループ化されたものを移動するコマ
ンドです。これらのコマンドは、カッコを含んでいたとしても文字列とコメント
を無視し、エスケープ文字でクォートされたカッコも無視します。これらのコマ
ンドは主にプログラムの編集を意図していますが、カッコを含む任意のテキスト
の編集にも有用です。これらは内部的には“リストコマンド”として参照されます
。なぜならLispではこれらのグループはリストだからです。

   これらのコマンドは、開始ポイントが文字列やコメントの中でないと仮定し
ます。これらのコマンドを文字列やコメントの中から呼び出したとき、結果は信
頼できません。

‘C-M-n’
     カッコでグループ化されたグループを飛び越えて、前方に移動します
     (‘forward-list’)。
‘C-M-p’
     カッコでグループ化されたグループを飛び越えて、後方に移動します
     (‘backward-list’)。
‘C-M-u’
     カッコによる構造を上に移動します(‘backward-up-list’)。
‘C-M-d’
     カッコによる構造を下に移動します(‘down-list’)。

   リスト(list)コマンドの‘C-M-n’ (‘forward-list’)と、‘C-M-p’
(‘backward-list’)は、グループ化されたカッコを前方または後方に、1つ(また
はN個)飛び越えて移動します。

   ‘C-M-n’と‘C-M-p’は、カッコによる構造において同じレベルに留まろうと試
みます。1レベル(またはNレベル)_上_に移動するには、‘C-M-u’
(‘backward-up-list’)を使用します。‘C-M-u’は対応が取れていない、前にある
開始区切りへ、後方に移動します。正の引数は繰り返し回数を意味します。負の
引数は移動の方向を逆転するので、このコマンドは1レベル以上を上に、前方に
移動します。

   カッコによる構造を_下_に移動するには、‘C-M-d’ (‘down-list’)を使用しま
す。Lispモードでは‘(’は開始区切りなので、これは‘(’を検索するのとほとんど
同じです。引数は何レベルしたに移動するかを指定します。


File: emacs-ja.info,  Node: Matching,  Prev: Moving by Parens,  Up: Parentheses

26.4.3 マッチするカッコ
-----------------------

Emacsには“カッコのマッチング(parenthesis matching)”機能がいくつかありま
す。これにより、どのカッコ(または他の区切り)がどのようにマッチするか簡単
に見ることができます。

   終了文字となる自己挿入文字をタイプすると、Emacsはそれがスクリーン上に
あれば、マッチする開始区切りの位置を簡単に示します。スクリーン上にない場
合、Emacsは開始区切りの近くにあるテキストをエコーエリアに表示します。ど
ちらの方法でも、どのグループを終了したのか見分けることができます。開始区
切りと終了区切りがマッチしない — ‘[x)’のような場合、エコーエリアに警告メ
ッセージが表示されます。

   3つの変数が、マッチするカッコの表示を制御します:

   • ‘blink-matching-paren’は、この機能をオンまたはオフに切り替えます。
     ‘nil’は無効にしますが、デフォルトの‘t’は有効にします。‘jump’にセッ
     トすると、マッチする開始区切りに数瞬カーソルを移動して指示します。
     ‘jump-offscreen’にセットすると、開始区切りが画面上にない場合でもカ
     ーソルをジャンプさせます。

   • ‘blink-matching-delay’は、マッチする開始区切りを何秒表示するかを指
     定します。これには整数または浮動小数点数を指定します。デフォルトは
     1です。

   • ‘blink-matching-paren-distance’には、マッチする開始区切りを後方に何
     文字検索するかを指定します。この文字数内にマッチが見つからない場合
     、Emacsは検索を中止して、何も表示しません。デフォルトは102400です。

   グローバルなマイナーモードのShow Parenモードは、より強力な自動的なマ
ッチングの類を提供します。これは開始区切りの前、または終了区切りの後ろに
ポイントを移動すると、開始区切りと終了区切り、間にあるテキスト(オプショ
ン)をハイライトします。Show Parenモードに切り替えるには、‘M-x
show-paren-mode’とタイプします。これをカスタマイズするには、‘M-x
customize-group <RET> paren-showing’とタイプします。このモードの処理を制
御するカスタマイズ可能なオプションには、以下が含まれます:

   • ‘show-paren-highlight-openparen’は、ポイントが開きカッコの直前にあ
     るとき(つまり、その位置にカーソルがにあるとき)、そのカッコをハイラ
     イトするかどうかを制御します。デフォルトは非‘nil’ (ハイライトする
     )です。

   • ‘show-paren-style’は、2つのカッコだけをハイライトするか、それともカ
     ッコの間のスペースもハイライトされるかを制御します。有効なオプショ
     ンは、‘parenthesis’ (マッチするカッコをハイライト)、‘expression’ (カ
     ッコで括られた式全体をハイライト)、‘mixed’ (カッコが表示されている
     ときはマッチするカッコ、カッコが表示されていないときは式をハイライ
     ト)です。

   • ‘show-paren-when-point-inside-paren’が非‘nil’の場合は、ポイントがカ
     ッコの内側にあるときもハイライトされます。

   • ‘show-paren-when-point-in-periphery’が非‘nil’の場合は、行の先頭が空
     白文字で開始されていて、ポイントがその空白文字範囲の中にあり、その
     行の非空白文字の最初または最後がカッコの場合は、そのカッコもハイラ
     イトします。同様に、行の末尾が空白文字で終端されていて、ポイントが
     その空白文字範囲の中にあり、その行の非空白文字の最後がカッコの場合
     は、そのカッコもハイライトします。

   グローバルなマイナーモードのElectric Pairモードは、マッチするカッコ
(parentheses)、大カッコ(braces)、角カッコ(brackets)、...などの 区切りを
簡単に挿入する方法を提供します。開始区切りを挿入すると、マッチする終了区
切りが自動的に挿入され、2つの区切りの間にポイントが置かれます。反対に終
了区切りを既存の区切りの先に挿入した場合、何の挿入もされず、その位置は単
にスキップされます。リージョンがアクティブ(*note Mark::を参照)の場合、区
切りの挿入はそのリージョンを操作します。リージョン内の文字はマッチする区
切りのペアー内に括られ、ポイントはタイプした区切りの後に置かれます。

   以下の変数は、Electric Pairモードの追加機能を制御するのに使用できます
:

   • ‘electric-pair-preserve-balance’ — 非‘nil’の場合、デフォルトのペア
     リングロジックは、開始区切りと終了区切りの数のバランスになります。

   • ‘electric-pair-delete-adjacent-pairs’ — 非‘nil’の場合、隣接する区切
     りの間でのバックスペースにより、終了区切りも自動的に削除します。

   • ‘electric-pair-open-newline-between-pairs’ — 非‘nil’の場合、2つの隣
     接するペアの間での改行の挿入は、ポイントの後ろに自動的に追加の改行
     をオープンします。

   • ‘electric-pair-skip-whitespace’ — 非‘nil’の場合、終了区切りのスキッ
     プを決定する前に、マイナーモードが空白文字を前方にスキップするよう
     にします。

   Electric Pairモードに切り替えるには、‘M-x electric-pair-mode’とタイプ
します。1つのバッファーにたいしてこのモードを切り替えるには、‘M-x
electric-pair-local-mode’を使用してください。


File: emacs-ja.info,  Node: Comments,  Next: Documentation,  Prev: Parentheses,  Up: Programs

26.5 コメントの操作
===================

コメントは、プログラミングにおいて重要なパートなので、Emacsはコメントの
編集や挿入を行う特別なコマンドを提供します。Flyspell Progモードによる、
コメントのスペルチェックも行うことができます(*note Spelling::を参照して
ください)。

   異なる種類のコメントのインデントにたいして、特別なルールをもつメジャ
ーモードがいくつかあります。たとえばLispコードでは、2つのセミコロンで始
まるコメントは、それらの行がコードであるかのようにインデントされ、3つの
セミコロンで始まるコメントは左端に揃えてインデントされ、しばしば区分けの
目的で使用されます。Emacsはこれらの慣習を理解します。たとえば、コメント
行で‘<TAB>’をタイプすると、そのコメントを適切な位置にインデントします。

     ;; This function is just an example.
     ;;; Here either two or three semicolons are appropriate.
     (defun foo (x)
     ;;;  And now, the first part of the function:
       ;; The following line adds one.
       (1+ x))           ; This line adds one.

* Menu:

* Comment Commands::         コメントの挿入、kill、位置揃え。
* Multi-Line Comments::      複数行のコメントを追加・編集するコマンド。
* Options for Comments::コメント機能のカスタマイズ。


File: emacs-ja.info,  Node: Comment Commands,  Next: Multi-Line Comments,  Up: Comments

26.5.1 コメントコマンド
-----------------------

以下のコマンドは、コメントにたいして処理を行います:

‘M-;’
     カレント行にコメントを挿入、または位置揃えします。リージョンがアク
     ティブのときは、かわりにリージョンをコメント化、または非コメント化
     します(‘comment-dwim’)。
‘C-x C-;’
     カレント行をコメント、または非コメントにします(‘comment-line’)。リ
     ージョンがアクティブの場合は、かわりにリージョンをコメント、または
     非コメントにします。
‘C-u M-;’
     カレント行のコメントをkillします(‘comment-kill’)。
‘C-x ;’
     コメント列をセットします(‘comment-set-column’)。
‘C-M-j’
‘M-j’
     ‘<RET>’の後にコメントを挿入して位置揃えします
     (‘comment-indent-new-line’)。*note Multi-Line Comments::を参照して
     ください。
‘M-x comment-region’
‘C-c C-c’ (C-likeなモードの場合)
     リージョンのすべての行にたいして、コメント区切りを追加します。

   コメントを挿入または位置揃えするコマンドは、‘M-;’ (‘comment-dwim’)で
す。単語“dwim”は、“Do What I Mean(私が言ったとおりにしてください)”の頭文
字をとったものです。このコマンドは、コメントに関係する多くの異なる作業に
使用できます。それは、このコマンドをどこで使うかという、状況に依存するこ
とを示します。

   リージョンがアクティブ(*note Mark::を参照してください)の場合、‘M-;’は
リージョンのコメント区切りの追加と削除のどちらかを行います。リージョンの
各行がすでにコメントの場合、それらのコメント区切りを削除することにより、
それらの行を非コメント化します。そうでない場合は、リージョンのテキストに
コメント区切りを追加します。

   リージョンがアクティブのときに‘M-;’に数引数を与えると、それは追加また
は削除するコメント区切りの数を指定します。正の引数NはN個の区切りを追加し
、負の引数-NはN個の区切りを削除します。

   リージョンが非アクティブで、カレント行にコメントがない場合、‘M-;’はカ
レント行に新しいコメントを追加します。ブランク行(たとえば空または空白文
字しか含まない)の場合、‘<TAB>’をタイプしたときにインデントされるのと同じ
位置に、コメントがインデントされます(*note Basic Indent::を参照)。非ブラ
ンク行の場合、コメントはその行の最後の非空白文字の後ろに配されます。
Emacsは、可能なら変数‘comment-column’と‘comment-fill-column’ (*note
Options for Comments::を参照)で指定された列の間にコメントを配そうと試み
ます。それ以外では、Emacsは別の適切な位置、通常、非コメントのテキストと
少なくとも1つのスペースを空けてコメントを配します。どちらの場合も、
Emacsはコメントの開始区切りの後にポイントを配すので、すぐにコメントのタ
イプを開始できます。

   既存のコメントの位置揃えにも‘M-;’を使用できます。行がすでにコメント開
始文字列を含む場合、‘M-;’は慣習的な位置にそれを位置揃えして、ポイントを
コメント開始区切りの後ろに移動します。例外として、列0で始まるコメントは
移動されません。既存のコメントがすでに正しく位置揃えされているときでも、
‘M-;’はコメントテキストの開始に直接移動するので有用です。

   ‘C-x C-;’ (‘comment-line’)は、行そのものをコメント化または非コメント
化します。リージョンがアクティブ(*note Mark::を参照してください)の場合は
、リージョン内の行をコメント化または非コメント化します。リージョンが非ア
クティブの場合、このコマンドはポイントがある行をコメント化または非コメン
ト化します。正のプレフィクス引数Nを与えた場合、カレント行から数えてN行を
処理します。Nが負の場合、先行するN行に作用します。負の引数を与えてこのコ
マンドを呼び出した後は、それに続けて正の引数を指定して連続して呼び出した
場合、あたかも負の引数が与えられたかのように、先行する行を処理します。

   ‘C-u M-;’ (‘comment-dwim’にプレフィクス引数を指定)は、カレント行の任
意のコメントを、それの前の空白文字と一緒にkillします。コメントはkillリン
グに保存されるので、他の行の行末に移動して‘C-y’で挿入して、‘M-;’でコメン
トの位置揃えをすることができます。‘M-x comment-kill’とタイプしても‘C-u
M-;’と同じ効果を得ることができます(‘comment-dwim’はプレフィクス引数を与
えられたとき、実際にサブルーチンとして‘comment-kill’を呼び出します)。

   コマンド‘M-x comment-region’は、アクティブなリージョンにたいして
‘M-;’を呼び出すのと等価ですが、このコマンドはマークが非アクティブのとき
でも、常にリージョンにたいして動作します。Cモードおよび関連するモードで
は、このコマンドは‘C-c C-c’にバインドされています。コマンド‘M-x
uncomment-region’は、リージョンの各行を非コメント化します。数引数は、削
除するコメント区切りの数を指定します(負の引数は、追加するコメント区切り
の数を指定します)。

   C-likeなモードにたいしては、変数‘c-indent-comment-alist’および
‘c-indent-comments-syntactically-p’をセットすることにより、‘M-;’の正確な
効果を設定できます。たとえば閉じ大カッコで終わる行では、‘M-;’は
‘comment-column’ではなく、大カッコの後ろにスペースを1つ空けてコメントを
配します。完全な詳細は、*note (ccmode)Comment Commands::を参照してくださ
い。


File: emacs-ja.info,  Node: Multi-Line Comments,  Next: Options for Comments,  Prev: Comment Commands,  Up: Comments

26.5.2 複数行のコメント
-----------------------

コメントをタイプするとき、それを次の行に継続したくなったときは、‘M-j’ま
たは‘C-M-j’ (‘comment-indent-new-line’)とタイプします。これはカレント行
を行ブレークして、コメントを継続するために必要なコメント区切りとインデン
トを挿入します。

   コメントの終了区切りをもつ言語(たとえばCの‘*/’)では、‘M-j’の正確な振
る舞いは、変数‘comment-multi-line’の値に依存します。変数の値が‘nil’の場
合、このコマンドは古い行のコメントを終了させて、新しい行で新しいコメント
を開始します。そうでない場合、カレントのコメント区切りの中で新しい行を開
きます。

   Auto Fillモードがオンの場合、コメントをタイプしているときにフィル列に
達すると、明示的に‘M-j’を呼び出したときと同じ方法で、コメントが継続され
ます。

   既存の行をコメントにするには、リージョンがアクティブのときは‘M-;’、ま
たは‘M-x comment-region’を使用します。 (*note Comment Commands::).

   複数行ブロックのコメントの行の開始で‘/’をタイプすると、コメントを終了
するようにCモードを設定できます。これを行なうには、クリーンアップ
(clean-up)で、‘comment-close-slash’を有効にします。*note
(ccmode)Clean-ups::を参照してください。


File: emacs-ja.info,  Node: Options for Comments,  Prev: Multi-Line Comments,  Up: Comments

26.5.3 コメントを制御するオプション
-----------------------------------

*note Comment Commands::で示したように、‘M-j’コマンドが行にコメントを追
加するとき、バッファーローカルな変数‘comment-column’と
‘comment-fill-column’(‘nil’の場合は‘fill-column’の値。*note Fill
Commands::を参照されたい)の間にコメントを配そうと試みます。このバッファ
ーローカルな変数のデフォルト値、またはローカルな値は、通常の方法でセット
できます(*note Locals::を参照)。かわりに‘C-x ;’ (‘comment-set-column’)と
タイプすることにより、カレントバッファーの‘comment-column’の値を、現在コ
メントがある列にセットすることができます。‘C-u C-x ;’は、コメント列をそ
のバッファーのポイントの前にある最後のコメントにセットします。その後で
‘M-;’を行うことにより、カレント行のコメントを前のコメントに揃えることが
できます。

   コメントコマンドは、変数‘comment-start-skip’の値である正規表現にもと
づいて、コメントを認識します。この正規表現がヌル文字列にマッチしないよう
に気をつけてください。単語という言葉の厳格な意味から考えると、これはコメ
ント開始区切りより長い文字列にマッチするかもしれません。たとえばCモード
での変数の値は‘"\\(//+\\|/\\*+\\)\\s *"’で、これは‘/*’自身と、その後ろの
余分なアスタリスクやスペースにマッチし、C++スタイルのコメントも許容しま
す(文字列に‘\’を含む場合、Lisp構文では‘\\’と記述する必要があることに注意
してください。これは最初のアスタリスクにたいして、正規表現においてアスタ
リスクがもつ特別な意味を打ち消すために必要です)。

   コメントコマンドが新しいコメントを作るとき、これは‘comment-start’の値
をコメント開始区切りとして挿入します。これはポイントの後ろに、コメント終
了区切りとして‘comment-end’の値も挿入します。たとえばLispモードでは
‘comment-start’が‘";"’で、‘comment-end’が‘""’(空文字列)です。Cモードでは
‘comment-start’が‘"/* "’で、‘comment-end’が‘" */"’です。

   変数‘comment-padding’は、コメントコマンドが、コメント区切りとコメント
テキストの間を区切る文字列を指定します。デフォルトでは‘" "’、つまり1つの
スペースが指定されます。かわりに数字を指定すると、これは指定した数のスペ
ースになり、‘nil’の場合、スペースは挿入されません。

   変数‘comment-multi-line’は、‘M-j’とAuto Fillモードがコメントをどのよ
うに複数行に継続するかを制御します。*note Multi-Line Comments::を参照し
てください。

   変数‘comment-indent-function’は、新しく挿入されたコメント、または既存
のコメントの位置揃え位置を計算するために呼び出される関数を指定します。こ
れはメジャーモードごとに異なります。関数は引数なしで呼び出されますが、新
しいコメントが挿入されるときはコメント開始位置のポイント、または行末のポ
イントで呼び出されます。この関数はコメントが開始されるべき列を返す必要が
あります。たとえばLispモードでは、デフォルト関数の決定は、既存のコメント
がいくつのコメント文字で始まるかにもとづきます。

   さらにEmacsは、コメントを付近の行と揃えるようとも試みます。これをオー
バーライドするには、インデントの許容できる範囲を示す、(もしかしたら等し
い)2つの整数から成るコンスを関数がしても構いません。


File: emacs-ja.info,  Node: Documentation,  Next: Hideshow,  Prev: Comments,  Up: Programs

26.6 ドキュメントの照会
=======================

Emacsは、関数やプログラムで使おうと計画している変数およびコマンドを、ド
キュメントから探すのに使用できる機能をいくつか提供します。

* Menu:

* Info Lookup::              Infoファイルからライブラリー関数やコマンドを探す。
* Man Page::                 manからライブラリー関数やコマンドを探す。
* Lisp Doc::                 Emacs関数を探す、その他。


File: emacs-ja.info,  Node: Info Lookup,  Next: Man Page,  Up: Documentation

26.6.1 Infoドキュメントの照会
-----------------------------

Infoドキュメントをもつ言語に適用されるメジャーモードでは、プログラムで使
用されるシンボルにたいして‘C-h S’ (‘info-lookup-symbol’)を使用することに
より、Infoドキュメントを閲覧できます。シンボルはミニバッファーで指定しま
す。デフォルトはバッファーのポイント位置にあるシンボルです。たとえばCモ
ードでは、シンボルをC Library Manualから探します。このコマンドは適切な
Infoファイルのマニュアルがインストールされているときだけ機能します。

   Emacsは、どのドキュメントのどこからシンボルを探すか — つまり、どの
Infoファイルを探すのか、そしてどのインデックスを検索するか — をメジャー
モードにもとづき決定します。‘M-x info-lookup-file’を使用して、ドキュメン
トのファイル名を指定することもできます。

   ‘C-h S’をサポートしないメジャーモードでこれを使用すると、これはsymbol
help modeを指定するよう求めます。ここでは‘c-mode’コマンドのように、‘C-h
S’をサポートするメジャーモードを選択します。


File: emacs-ja.info,  Node: Man Page,  Next: Lisp Doc,  Prev: Info Lookup,  Up: Documentation

26.6.2 man-pageの照会
---------------------

Unixでは、オンラインドキュメントのメインフォームは“manual page”または
“man page”です。GNUオペレーティングシステムではmanを、Infoでブラウズでき
る、より組織化されたマニュアルで置き換えることを目指しています。このプロ
セスは終了していないので、manを読むことはまだ有用です。

   オペレーティングシステムのコマンド、ライブラリー関数、システムコール
にたいするman pageを、‘M-x man’コマンドで読むことができます。このコマン
ドは補完つき(*note Completion::を参照してください)でトピック(topic)の入
力を求め、対応するman pageをフォーマットするために、‘man’コマンドを実行
します。そのシステムが許すなら、このコマンドは‘man’を非同期で実行するの
で、ページがフォーマットされる間、編集を続けることができます。フォーマッ
トされた結果は‘*Man TOPIC*’という名前のバッファーに表示されます。このバ
ッファーは、Manモードという特別なメジャーモードを使用します。これはスク
ロールや他のman pageにジャンプする機能をもちます。詳細についてはManモー
ドのバッファーで、‘C-h m’をタイプしてください。

   それぞれのman pageは、1つ以上の“セクション(sections)”に属します。セク
ションの名前は数字または数字と文字です。同じ名前のman pageが、複数のセク
ションに存在することもあります。特定のセクションのman pageを読むには、
‘M-x man’がトピックの入力を求める際、‘TOPIC(SECTION)’または‘SECTION
TOPIC’とタイプします。たとえばCのライブラリー関数‘chmod’はセクション2で
すが、同じ名前のシェルコマンドのman pageはセクション1です。前者を閲覧す
るには、‘M-x man <RET> chmod(2) <RET>’とタイプしてください。

   セクションを指定しないと、‘M-x man’は通常、最初に見つかったman pageだ
けを表示します。‘man’に、コマンドラインオプション‘-a’を指定できるシステ
ムもいくつかあります。これは指定したトピックにたいするすべてのman pageを
表示するよう指定します。これを使用するには、変数‘Man-switches’の値を
‘"-a"’に変更します。そうするとManモードのバッファーで、‘M-n’と‘M-p’で異
なるセクションのman pagfeを切り替えることができます。モードラインには、
利用可能なman pageの数が表示されます。

   man pageを読む他の方法として、‘M-x woman’コマンドがあります。‘M-x
man’とは異なり、これはman pageをフォーマットするために外部のプログラムを
実行しないので、MS-Windowsのような、‘man’プログラムが利用できないかもし
れないシステムでも機能します。このコマンドは、表示するman pageの入力を求
め、それを‘*WoMan SECTION TOPIC’という名前のバッファーに表示します。

   ‘M-x woman’は、コマンドを最初に呼び出したとき、man pageの補完リストを
計算します。数引数を指定すると、このリストを再計算します。これはman
pageを追加・削除したとき有用です。

   man pageの名前を入力して、‘M-x woman’が複数のセクションで同じ名前の
man pageを見つけた場合、これはウィンドウをポップアップして利用可能な候補
を示し、それらから1つを選択するよう求めます。

   ‘M-x woman’はモダンなman-pagesの最新機能をまだサポートしていないので
、システムで利用可能なら‘M-x man’の使用をわたしたちが推奨していることに
注意してください。

   ‘M-x woman’のセットアップと使用についての情報は、 *note WoMan:
(woman)Top.を参照してください。


File: emacs-ja.info,  Node: Lisp Doc,  Prev: Man Page,  Up: Documentation

26.6.3 Emacs Lispドキュメントの照会
-----------------------------------

Emacs Lispコードを編集するとき、コマンド‘C-h f’ (‘describe-function’)お
よび‘C-h v’ (‘describe-variable’)で、使用したい関数または変数のビルトイ
ンドキュメントを閲覧できます。*note Name Help::を参照してください。

   Eldocモードは、Lispドキュメントを検索するのに助けとなる、バッファーロ
ーカルなマイナーモードです。これが有効な場合、ポイントがLisp関数または変
数にあるときは、有用な情報がエコーエリアに表示されます。関数の場合は引数
リスト、変数の場合は変数のドキュメントストリングの最初の行が表示されます
。Eldocモードに切り替えるには、‘M-x eldoc-mode’とタイプします。Global
Eldocモードもあり、これはデフォルトでオンであり、バッファーにたいするメ
ジャーモードがEmacs LispモードやLisp Interactionモードである、
‘*scratch*’のようなバッファーに影響します(‘M-x global-eldoc-mode’でグロ
ーバルでオフに切り替えられます)。


File: emacs-ja.info,  Node: Hideshow,  Next: Symbol Completion,  Prev: Documentation,  Up: Programs

26.7 Hideshowマイナーモード
===========================

Hideshowモードは、バッファーローカルなマイナーモードで、“ブロック”と呼ば
れるプログラムの一部を、選択的に表示させることができます。このマイナーモ
ードに切り替えるには、‘M-x hs-minor-mode’とタイプします(*note Minor
Modes::を参照してください)。

   ブロックを非表示にするためにHideshowモードを使用したとき、そのブロッ
クはスクリーンに表示されなくなり、かわりに省略記号(3つのピリオド)に置き
換えられます。何をブロックと定めるかは、メジャーモードに依存します。Cモ
ード、および関連するモードでは、ブロックは大カッコ(braces)で区切られ、
Lispモードでは丸カッコ(parentheses)で区切られます。複数行のコメントもブ
ロックとみなされます。

   Hideshowモードは以下のコマンドを提供します:

‘C-c @ C-h’
‘C-c @ C-d’
     カレントブロックを隠します(‘hs-hide-block’)。
‘C-c @ C-s’
     カレントブロックを表示します(‘hs-show-block’)。
‘C-c @ C-c’
‘C-x @ C-e’
     カレントブロックを表示、または非表示にします(‘hs-toggle-hiding’)。
‘S-mouse-2’
     クリックしたブロックの表示・非表示を切り替えます
     (‘hs-mouse-toggle-hiding’)。
‘C-c @ C-M-h’
‘C-c @ C-t’
     トップレベルのすべてのブロックを隠します(‘hs-hide-all’)。
‘C-c @ C-M-s’
‘C-c @ C-a’
     バッファーのすべてのブロックを表示します(‘hs-show-all’)。
‘C-u N C-c @ C-l’
     現在のブロックの、Nレベル下のすべてのブロックを隠します
     (‘hs-hide-level’)。

   以下の変数はHideshowモードをカスタマイズするのに使用されます:

‘hs-hide-comments-when-hiding-all’
     非‘nil’の場合、‘C-c @ C-M-h’ (‘hs-hide-all’)はコメントも隠します。

‘hs-isearch-open’
     この変数は、インクリメンタル検索でマッチするテキストが隠されたブロ
     ックにあるとき、それを表示すべき条件を指定します。変数の値は、
     ‘code’(コードブロックだけを表示)、‘comment’(コメントだけを表示)、
     ‘t’(コードブロックとコメントの両方を表示)、‘nil’(どちらも表示しない
     )のいずれかです。デフォルト値は‘code’です。


File: emacs-ja.info,  Node: Symbol Completion,  Next: MixedCase Words,  Prev: Hideshow,  Up: Programs

26.8 シンボル名の補完
=====================

補完は通常ミニバッファーで行われますが(*note Completion::を参照してくだ
さい)、シンボル名の補完を、普通のEmacsバッファーで行うこともできます。

   プログラミング言語のモードでは、‘C-M-i’または‘M-<TAB>’とタイプするこ
とにより、ポイントの前のシンボル名の一部にたいして補完を行うことができま
す。グラフィカルなディスプレーでは、‘M-<TAB>’キーは通常、グラフィカルな
ウィンドウの切り替え用にウィンドウマネージャーに予約されているので、かわ
りに‘C-M-i’または‘<ESC> <TAB>’とタイプする必要があります。

   ほとんどのプログラミング言語のモードでは、‘C-M-i’ (または‘M-<TAB>’)は
、コマンド‘completion-at-point’を呼び出します。これは柔軟な方法で補完リ
ストを生成します。Semanticモードが有効な場合は、補完にSemanticパーサーの
データを使用することを試みます(*note Semantic::を参照してください)。
Semanticモードが無効、または補完の処理に失敗した場合、選択されたtagsテー
ブル(*note Tags Tables::を参照してください)を使用して補完を試みます。
Emacs Lispモードの場合、カレントのEmacsセッションで定義された関数、変数
、プロパティー名を使用して補完を行います。

   他の点では、バッファーでのシンボル補完はミニバッファーでの補完と同様
に振る舞います。たとえば、Emacsが一意なシンボルを補完できない場合、他の
ウィンドウに補完候補のリストを表示します。*note Completion::を参照してく
ださい。

   Textモード、および関連するモードでは、‘M-<TAB>’はスペルチェッカーの辞
書にもとづいて単語を補完します。*note Spelling::を参照してください。


File: emacs-ja.info,  Node: MixedCase Words,  Next: Semantic,  Prev: Symbol Completion,  Up: Programs

26.9 大文字小文字の混ざった単語
===============================

いくつかのプログラミングスタイルでは、‘unReadableSymbol’のような大文字小
文字が混ざった(“CamelCase”の)シンボルを使います(GNUプロジェクトでは、識
別子の単語の区切りに、大文字小文字の違いではなく、アンダースコアを使用す
ることを推奨しています)。Emacsには、そのようなシンボルに簡単に対処するた
めの、さまざまな機能があります。

   バッファーローカルなマイナーモードのGlassesモードは、そのようなシンボ
ルが表示される方法を変更することにより、それらを読みやすくします。デフォ
ルトでは、小文字とそれに続く大文字の間に余分なアンダースコアを表示します
。これはバッファーのテキストを変更するわけではなく、表示の仕方だけを変更
します。

   Glassesモードに切り替えるには、‘M-x glasses-mode’とタイプします(*note
Minor Modes::を参照してください)。Glassesモードが有効な場合、モードライ
ンのマイナーモードインジケーターには‘o^o’が表示されます。Glassesモードに
間する情報を得るには、‘C-h P glasses <RET>’とタイプしてください。

   Subwordモードは、バッファーローカルなマイナーモードです。Subwordモー
ドでは、Emacsの単語コマンドは、‘StudlyCapsIdentifiers’のような、単語の中
の大文字を単語境界と認識します。Subwordモードが有効なときは、モードライ
ンのマイナーモードインジケーターに‘,’が表示されます。同様なモード
‘superword-mode’も参照してください(*note Misc for Programs::を参照してく
ださい)。


File: emacs-ja.info,  Node: Semantic,  Next: Misc for Programs,  Prev: MixedCase Words,  Up: Programs

26.10 Semanticとは
==================

Semanticは、‘ソースコードパーサー(source code parsers)’にもとづく、言語
認識(language-aware)による編集のためのコマンドを提供します。このセクショ
ンは、Semanticについての簡単な説明を提供します。完全な詳細については、
*note Semantic: (semantic)Top.を参照してください。

   Font Lockモード(*note Font Lock::を参照してください)のような、Emacsの
言語認識機能(language aware features)のほとんどは、rules of thumb(1)にも
とづいています。これは大抵の場合においてよい結果を得られますが、完全に正
しい結果は決して得られない、ということを意味します。対照的に、Semanticで
使用されるパーサーは、プログラミング言語の構文を正確に理解します。これに
よりSemanticは、より強力で正確な検索、操作、補完コマンドが提供できるので
す。

   Semanticの使用を開始するには、‘M-x semantic-mode’をタイプするか、
‘Tools’メニューの、‘Source Code Parsers (Semantic)’という名前のメニュー
をクリックします。これはグローバルなマイナーモードのSemanticモードを有効
にします。

   Semanticモードが有効な場合、Emacsはファイルをvisitするたびに自動的に
パースを試みます。現在のところ、SemanticはC、C++、HTML、Scheme、Java、
Javascript、Make、Python、Scheme、SRecord、Texinfoを理解します。パースさ
れたバッファーでは以下のコマンドが利用可能です:

‘C-c , j’
     カレントファイルで定義された関数名の入力を求め、ポイントをそこに移
     動します(‘semantic-complete-jump-local’)。

‘C-c , J’
     Emacsがパースした任意のファイルで定義された関数名の入力を求め、ポイ
     ントをそこに移動します(‘semantic-complete-jump’)。

‘C-c , <SPC>’
     ポイント位置のシンボルにたいして可能な補完候補のリストを表示します
     (‘semantic-complete-analyze-inline’)。これは補完候補を選択するため
     の特別なキーバインドのセットをアクティブにします。‘<RET>’はカレント
     の補完候補を選択し、‘M-n’と‘M-p’は可能な補完候補を巡回、‘<TAB>’は可
     能なところまで補完を行ってから巡回、そして、‘C-g’または他のキーは補
     完を中止します。

‘C-c , l’
     ポイント位置のシンボルにたいして可能な補完候補のリストを、他のウィ
     ンドウに表示します(‘semantic-analyze-possible-completions’)。

上記のコマンドに加えて、Semanticパッケージは、パーサー情報を使用する他の
さまざまな方法を提供します。たとえば、Emacsがアイドルのとき、補完候補の
リストを表示するために、それを使用することができます。 詳細は、*note
Semantic: (semantic)Top.を参照してください。

   ---------- Footnotes ----------

   (1) 正規表現と構文テーブル。


File: emacs-ja.info,  Node: Misc for Programs,  Next: C Modes,  Prev: Semantic,  Up: Programs

26.11 プログラムを編集するための他の便利な機能
==============================================

プログラムを編集するためにデザインされているわけではありませんが、有用な
Emacsコマンドもいくつかあります

   単語、センテンス、パラグラフを操作するEmacsコマンドは、コードを編集す
るのに有用です。ほとんどのシンボル名は単語(*note Words::を参照してくださ
い)を含んでおり、文字列やコメントの中でセンテンス(*note Sentences::を参
照してください)を見つけることができます。パラグラフについては、ほとんど
のプログラミング言語のモードは空行をパラグラフの開始および終了に定義して
います。したがって空行を注意深く使用してプログラムをクリアーにすることに
より、パラグラフコマンドが機能できる、有意なテキストの集合を提供すること
ができます。プログラミング言語のモードでAuto Fillモードが有効な場合、新
しい行の作成でインデントされるようになります。

   Superwordはバッファーローカルなマイナーモードで、編集および移動コマン
ドがシンボル(たとえば‘this_is_a_symbol’)を単語として扱うようになります。
Superwordモードが有効な場合、モードラインのマイナーモードインジケーター
に、 ‘²’ が表示されます。同様なモード‘subword-mode’も参照してください
(*note MixedCase Words::を参照してください)。

   Electric Layoutモード(‘M-x electric-layout-mode’)はグローバルなマイナ
ーモードで、特定の文字をタイプしたときに自動的に改行を挿入します。たとえ
ばJavascriptモードでは‘{’、‘}’、‘;’などです。

   Hideshowモード(*note Hideshow::を参照してください)は別として、プログ
ラムの一部を選択的に表示するには、選択的な表示機能(*note Selective
Display::を参照してください)を使う方法があります。プログラミングのモード
には、Foldoutパッケージ(*note Foldout::を参照してください)とともに使用で
きる、Outline minorマイナーモード(*note Outline Mode::を参照してください
)をサポートするものもあります。

   プログラムを記述するためにはautomatic typing機能が有用でしょう。*note
Autotyping: (autotype)Top.を参照してください。

   Prettify Symbolsモードはバッファーローカルなマイナーモードで、特定の
文字の表示をよりアトラクティブ(attractive: 見栄えのする)なバージョンに置
き換えます。たとえばEmacs Lispモードでは、文字列‘lambda’を、ギリシャ文字
のラムダ‘λ’に置き換えます。TeXバッファーでは‘\alpha’ ...  ‘\omega’、およ
び他の数学マクロ(math macros)を、対応するUnicode文字に置き換えます。この
モードを、プログラミングとは関係のないモードで使いたいと思うかもしれませ
ん。‘prettify-symbols-alist’にエントリーを追加することにより、このモード
をカスタマイズできます。デフォルト値である
‘prettify-symbols-default-compose-p’の値が適切でない場合、
‘prettify-symbols-compose-predicate’をカスタマイズすることで、より入念な
カスタマイズが可能です。グローバルなバージョン
‘global-prettify-symbols-mode’は、サポートするすべてのモードでこれを有効
にします。

   ポイント位置のシンボルを、元の形式で表示することもできます。これは変
数‘prettify-symbols-unprettify-at-point’により制御されます。非‘nil’の、
ポイントがシンボル位置にある限り、そのシンボルの元の形式が復元されます。


File: emacs-ja.info,  Node: C Modes,  Next: Asm Mode,  Prev: Misc for Programs,  Up: Programs

26.12 Cおよび関連するモード
===========================

このセクションではC、C++、Objective-C、Java、CORBA IDL、Pike、AWKのため
のモード(これらは“Cモードおよび関連するモード”と呼ばれます)で利用できる
、特別な機能を簡単に説明します。 詳細は、*note CC Mode: (ccmode)Top.を参
照してください。

* Menu:

* Motion in C::              Cステートメント単位での移動、その他。
* Electric C::               コロンおよび他の文字による、自動的な再インデント。
* Hungry Delete::            より強力なDELコマンド。
* Other C Commands::         コメントのフィル、マクロ展開の閲覧、その他のクールな機能。


File: emacs-ja.info,  Node: Motion in C,  Next: Electric C,  Up: C Modes

26.12.1 Cモードの移動コマンド
-----------------------------

このセクションでは、Cモードおよび関連するモードで、ポイントを移動するコ
マンドを説明します。

‘C-M-a’
‘C-M-e’
     カレント関数またはトップレベルの定義の、先頭または最後にポイントを
     移動します。スコープによる囲い(C++のclassなど)をもつ言語では、“カレ
     ント関数(current function)”はスコープ内の隣接する関数です。そうでな
     い場合、それは大カッコ(braces)で囲まれることにより定義されます。
     *note Moving by Defuns::を参照してください。

‘C-c C-u’
     マークを置いたまま、ポイントを含むプリプロセッサー条件を後方に移動
     します。プレフィクス引数は、繰り返し回数として振る舞います。負の引
     数を指定すると、ポイントを含むプリプロセッサー条件の最後に、前方へ
     ポイントを移動します。

     ‘#elif’は、‘#else’の後に‘#if’を続けたのと同じなので、この関数は後方
     に移動するときは‘#elif’で止まりますが、前方に移動するときは止まりま
     せん。

‘C-c C-p’
     マークを置いたまま、プリプロセッサー条件を越えてポイントを後方に移
     動します。プレフィクス引数は、繰り返し回数として振る舞います。負の
     引数の場合は前方に移動します。

‘C-c C-n’
     マークを置いたまま、プリプロセッサー条件を越えて、ポイントを前方に
     移動します。プレフィクス引数は、繰り返し回数として振る舞います。負
     の引数の場合は後方に移動します。

‘M-a’
     一番内側のCステートメントの先頭に、ポイントを移動します
     (‘c-beginning-of-statement’)。すでにポイントがステートメントの先頭
     にある場合は、その前のステートメントの先頭に移動します。プレフィク
     ス引数Nを指定した場合、N − 1個前のステートメントに、後方へ移動しま
     す。

     2行以上のコメントまたは文字列の場合、このコマンドはステートメントで
     はなくセンテンス単位で移動します。

‘M-e’
     Cステートメントまたはセンテンスの最後に、ポイントを移動します。
     ‘M-a’と同様ですが、これは逆の方向に移動します
     (‘c-end-of-statement’)。


File: emacs-ja.info,  Node: Electric C,  Next: Hungry Delete,  Prev: Motion in C,  Up: C Modes

26.12.2 エレクトリックC文字
---------------------------

Cモードおよび関連するモードでは、特定の文字は“エレクトリック(electric)”
— つまり自分自身を挿入するのに加えて、カレント行を再インデントしたり、オ
プションで改行を挿入します。エレクトリックな文字は、‘{’、‘}’、‘:’、‘#’、
‘;’、‘,’、‘<’、‘>’、‘/’、‘*’、‘(’、‘)’です。

   混乱したインデントのコードを編集している場合には、エレクトリックなイ
ンデントを不便だと感じるかもしれません。CCモードになれていない場合、それ
はあなたを当惑させるかもしれません。エレクトリックな動作は、コマンド‘C-c
C-l’で切り替えることができます。有効な場合には、モードラインのモード名の
後ろに‘/Cl’が表示されます(Cが表示される場合、それはコメントスタイルがブ
ロックスタイルかラインスタイルかに応じて‘*’か‘/’が表示される)。

‘C-c C-l’
     エレクトリックな動作を切り替えます(‘c-toggle-electric-state’)。正の
     プレフィクス引数を指定した場合、、このコマンドはエレクトリックな動
     作を有効にし、負の引数の場合は無効にします。

   エレクトリックな文字は、エレクトリックな状態に加えて、“自動改行
(auto-newline)”の機能が有効な場合(モードラインのモード名の後ろに‘/Cla’が
表示されている状態のとき)だけ、改行を挿入します。この機能は‘C-c C-a’で、
オンまたはオフに切り替えることができます。

‘C-c C-a’
     自動改行機能を切り替えます(‘c-toggle-auto-newline’)。このコマンドに
     プレフィクス引数を指定した場合、引数が正のときは自動改行機能をオン
     、負のときはオフに切り替えます。

   CCモードのスタイルは通常、Emacsが自動改行する正確な状況を設定します。
これを直接設定することもできます。*note (ccmode)Custom Auto-newlines::を
参照してください。


File: emacs-ja.info,  Node: Hungry Delete,  Next: Other C Commands,  Prev: Electric C,  Up: C Modes

26.12.3 Cの欲張りな削除機能
---------------------------

ポイント位置の空白文字のブロック全体を削除したい場合は、“hungry
deletion(欲張りな削除)”を使うことができます。これはポイントの前後の、一
連の空白文字を1回の操作で削除します。“空白文字(whitespace)”にはタブと改
行が含まれますが、コメントとプリプロセッサーコマンドは含まれません。

‘C-c C-<DEL>’
‘C-c <DEL>’
     ポイントの前の空白文字のブロック全体を削除します
     (‘c-hungry-delete-backwards’)。

‘C-c C-d’
‘C-c C-<Delete>’
‘C-c <Delete>’
     ポイントの後の空白文字のブロック全体を削除します
     (‘c-hungry-delete-forward’)。

   上記のコマンドのかわりに、“hungry deleteモード”を有効にすることができ
ます。この機能が有効な場合(モードラインのモード名の後に‘/’と‘h’が示され
ます)、1回の‘<DEL>’で1つのスペースではなくポイントの前に続くすべての空白
文字を削除し、‘C-d’(‘<Delete>’では_ありません_)でポイントの後に続くすべ
ての空白文字を削除します。

‘M-x c-toggle-hungry-state’
     hungry-delete機能を切り替えます(‘c-toggle-hungry-state’)。このコマ
     ンドにプレフィクス引数を指定した場合、正の場合はhungry-delete機能を
     オン、負の場合はオフにします。

   変数‘c-hungry-delete-key’は、hungry-delete機能を有効にするかを制御し
ます。


File: emacs-ja.info,  Node: Other C Commands,  Prev: Hungry Delete,  Up: C Modes

26.12.4 Cモードのその他のコマンド
---------------------------------

‘M-x c-context-line-break’
     このコマンドは、コンテキストに応じたマナーで、行ブレークの挿入と新
     しい行のインデントを行います。通常のコードの中では、‘<RET>’
     (‘newline’)の働きをしますが、Cプリプロセッサー行の中では、行ブレー
     クに追加で‘\’を挿入し、コメントの中では‘M-j’
     (‘c-indent-new-comment-line’)のように動作します。

     デフォルトでは、‘c-context-line-break’はキーにバインドされていませ
     んが、便利に使うためには、キーにバインドする必要があります。以下の
     コードは、このコマンドを‘<RET>’にバインドします。この例ではキーマッ
     プを変更する前に、それがロードされていることを確実にするために
     ‘c-initialization-hook’を使用しています。

          (defun my-bind-clb ()
            (define-key c-mode-base-map "\C-m"
                        'c-context-line-break))
          (add-hook 'c-initialization-hook 'my-bind-clb)

‘C-M-h’
     マークを関数定義の最後に配し、ポイントを先頭に配します
     (‘c-mark-function’)。

‘M-q’
     CおよびC++のコメントに対応した、パラグラフのフィルを行います
     (‘c-fill-paragraph’)。カレント行がコメントを含む、またはカレント行
     がコメントの場合、このコマンドはコメントのインデントとコメント区切
     りを保ちながら、コメントまたはポイントがあるパラグラフをフィルしま
     す。

‘C-c C-e’
     リージョンのテキストにたいして、Cプリプロセッサーを実行して、すべて
     のマクロ呼び出しの展開を含めて、結果を表示します。リージョンの前に
     あるバッファーのテキストも、マクロ定義がそこにあるためにプリプロセ
     スされますが、この部分は出力には表示されません。

     マクロを使用するCコードをデバッグするとき、マクロがどのように展開さ
     れるか正確に解明するのが難しいときがあります。このコマンドにより、
     展開結果を見ることができるので、わざわざ解明する必要がなくなります
     。

‘C-c C-\’
     リージョン内の各行末に、‘\’文字を挿入、または位置揃えします
     (‘c-backslash-region’)。これはCマクロ定義を、記述または編集した後に
     便利です。

     行がすでに(‘c-backslash-region’)で終了されている場合、このコマンド
     はそれの前の空白文字の数を調整します。そうでない場合は、新規に‘\’を
     挿入します。しかしリージョンの最後の行は特別に扱われます。この行に
     は‘\’は挿入されず、もし‘\’がある場合は削除します。

‘M-x cpp-highlight-buffer’
     プリプロセッサー条件に対応するテキスト部分を、ハイライトします。こ
     のコマンドは‘*CPP Edit*’という名前の別のバッファーを表示します。こ
     れは特定の条件とその内容をどのように表示するかを選択するための、グ
     ラフィックメニューを供します。さまざまなセッティングを変更した後に
     、‘[A]pply these settings’をクリック(またはそのバッファーで‘a’をタ
     イプ)すると、それに応じてCモードのバッファーが再ハイライトされます
     。

‘C-c C-s’
     カレントソース行の構文的な情報を表示します
     (‘c-show-syntactic-information’)。この情報は、その行がどのようにイ
     ンデントされるべきか決定するために使用されます。

‘M-x cwarn-mode’
‘M-x global-cwarn-mode’
     CWarnマイナーモードは、ある種の疑わしいCおよびC++の構文をハイライト
     します。

        • 式の中での値の割り当て。
        • ‘if’、‘for’、‘while’(‘do ... while’命令は除く)の直後のセミコロ
          ン。
        • 参照パラメーターをともなうC++関数。

     このモードを1つのバッファーにたいして有効にするにはコマンド‘M-x
     cwarn-mode’、すべての適合するバッファーにたいして有効にするにはコマ
     ンド‘M-x global-cwarn-mode’、または変数‘global-cwarn-mode’をカスタ
     マイズします。これが機能するためには、Font Lockモードも有効にしなけ
     ればなりません。

‘M-x hide-ifdef-mode’
     Hide-ifdefマイナーモードは、プリプロセッサーブロック‘#if’および
     ‘#ifdef’の中の選択されたコードを隠します。変数‘hide-ifdef-shadow’を
     ‘t’に変更した場合、Hide-ifdefマイナーモードははプリプロセッサーブロ
     ックを隠すかわりに、より目立たないフェイスでそれらのブロックを
     shadowします。詳細は、‘hide-ifdef-mode’のドキュメント文字列を参照し
     てください。

‘M-x ff-find-related-file’
     カレントバッファーでvisitされたファイルに関連するファイルを、特別な
     方法で検索します。通常これはC/C++ソースファイルにたいするヘッダーフ
     ァイル、またはその逆です。変数‘ff-related-file-alist’は、関連するフ
     ァイル名をどのように計算するかを指定します。


File: emacs-ja.info,  Node: Asm Mode,  Next: Fortran,  Prev: C Modes,  Up: Programs

26.13 Asmモード
===============

Asmモードは、アセンブラーコードのファイルを編集するためのメジャーモード
です。このモードは、以下の3つのコマンドを定義します:

‘<TAB>’
     ‘tab-to-tab-stop’.

‘C-j’
     改行を挿入してから、‘tab-to-tab-stop’を使ってインデントします。

‘:’
     コロンを挿入してから、コロンの前のラベルからインデントを削除します
     。その後、‘tab-to-tab-stop’を実行します。

‘;’
     コメントの挿入または位置揃えをします。

   変数‘asm-comment-char’はアセンブラー構文でコメントを開始する文字を指
定します。


File: emacs-ja.info,  Node: Fortran,  Prev: Asm Mode,  Up: Programs

26.14 Fortranモード
===================

Fortranモードは、固定形式(fixed form)(またはタブ形式(tab format))のソー
スコードを編集するためのモードです(通常はFortran 77)。よりモダンな自由形
式(free form)のソースコードを編集するためには、F90モード(‘f90-mode’)を使
用します。Emacsは通常、拡張子が‘.f’、‘.F’、‘.for’のファイルにたいしては
Fortranモードを使用し、拡張子が‘.f90’、‘.f95’、‘.f03’、‘.f08’のファイル
にたいしてはF90モードを使用します。‘auto-mode-alist’をカスタマイズして、
拡張子を追加することができます。GNU Fortranは、これら自由形式と固定形式
の両方をサポートします。このマニュアルでは主にFortranモードを記述します
が、対応するF90モードの機能については、その都度言及します。

   Fortranモードは、Fortran命令文およびサブプログラムにたいする特別な移
動コマンドと、Fortranのネスト規則、行番号、行継続された命令文を理解する
、インデントコマンドを提供します。Fortranモードは、長い行を適正な
Fortranの継続行にブレークする、Auto Fillモードをサポートします。
FortranモードはHideshowマイナーモード (*note Hideshow::を参照してくださ
い)、 、およびImenu (*note Imenu::を参照してください)もサポートします。

   Fortranのコメントは他の言語とは異なるので、コメントのための特別なコマ
ンドも提供されています。ビルトインのabbrev(省略形)は、Fortranキーワード
をタイプする手間を削減します。

   ‘M-x fortran-mode’を使用して、このメジャーモードに切り替えます。この
コマンドはフック‘fortran-mode-hook’を実行します。 *note Hooks::を参照し
てください。

* Menu:

* Motion: Fortran Motion.    命令文またはサブプログラムごとにポイントを移動する。
* Indent: Fortran Indent.    Fortranのためのインデントコマンド。
* Comments: Fortran Comments.  コメントの挿入と位置揃え。
* Autofill: Fortran Autofill.  FortranをサポートするAuto Fill。
* Columns: Fortran Columns.  有効なFortranのための列の計算。
* Abbrev: Fortran Abbrev.    Fortranキーワードのためのビルトインのabbrev。


File: emacs-ja.info,  Node: Fortran Motion,  Next: Fortran Indent,  Up: Fortran

26.14.1 移動コマンド
--------------------

defun(Fortranのサブプログラム — 関数、サブルーチン、同様にF90モードのモ
ジュールには、コマンド‘fortran-end-of-subprogram’および
‘fortran-beginning-of-subprogram’を使用します)を単位に移動、操作する通常
コマンドに加えて、Fortranモードは命令文や他のプログラム単位に移動する、
特別なコマンドを提供します。

‘C-c C-n’
     次の命令文の先頭に移動します
     (‘fortran-next-statement’/‘f90-next-statement’)。

‘C-c C-p’
     前の命令文の先頭に移動します
     (‘fortran-previous-statement’/‘f90-previous-statement’)。前の命令文
     が存在しない場合(たとえばバッファーの最初の命令文で呼び出された場合
     )、バッファーの先頭に移動します。

‘C-c C-e’
     次のコードブロックの先頭、またはカレントのコードブロックの最後に移
     動します(‘f90-next-block’)。コードブロックとは、サブルーチン、
     ‘if’–‘endif’命令文などです。これはF90モードだけのコマンドで、
     Fortranモードにはありません。数引数を指定すると、複数ブロックを前方
     に移動します。

‘C-c C-a’
     前のブロックに、後方にポイントを移動します(‘f90-previous-block’)。
     これは‘f90-next-block’と似ていますが、後方に移動します。

‘C-M-n’
     カレントのコードブロックの最後にポイントを移動します
     (‘fortran-end-of-block’/‘f90-end-of-block’)。数引数を指定した場合、
     指定した数のブロックを前方に移動します。ポイントを移動する前にマー
     クがセットされます。このコマンドのF90モードのバージョンでは、ブロッ
     クタイプと、(もしあれば)ラベルの整合性をチェックしますが、最外のブ
     ロックは不完全かもしれないのでチェックしません。

‘C-M-p’
     カレントコードブロックの先頭にポイントを移動します
     (‘fortran-beginning-of-block’/‘f90-beginning-of-block’)。これは
     ‘fortran-end-of-block’と似ていますが、後方に移動します。

   コマンド‘fortran-beginning-of-subprogram’および
‘fortran-end-of-subprogram’は、カレントサブプログラムの先頭または後方に
移動します。コマンド‘fortran-mark-do’および‘fortran-mark-if’は、カレント
の‘do’ブロック、または‘if’ブロックの最後にマークをセットして、ポイントを
ブロックの先頭に移動します。


File: emacs-ja.info,  Node: Fortran Indent,  Next: Fortran Comments,  Prev: Fortran Motion,  Up: Fortran

26.14.2 Fortranのインデント
---------------------------

固定形式(またはタブ形式)のFortranコードにたいしては、さまざまな構文エン
トリー(行番号、行インジケーター、継続行フラグ)が、要求される列に表示され
るようにするために、特別なコマンドと機能が必要です。

* Menu:

* Commands: ForIndent Commands.  Fortranをインデントおよびフィルするコマンド。
* Contline: ForIndent Cont.  継続行がインデントされる方法。
* Numbers: ForIndent Num.    行番号が自動インデントされる方法。
* Conv: ForIndent Conv.      トラブル防止のために、したがわなければならない慣習。
* Vars: ForIndent Vars.      Fortranのインデントスタイルを制御する変数。


File: emacs-ja.info,  Node: ForIndent Commands,  Next: ForIndent Cont,  Up: Fortran Indent

26.14.2.1 Fortranのインデントおよびフィルコマンド
.................................................

‘C-M-j’
     ポイント位置でカレント行をブレークして、継続行をセットアップします
     (‘fortran-split-line’)。

‘M-^’
     その行を前の行と結合します(‘fortran-join-line’)。

‘C-M-q’
     ポイントのあるサブプログラムの、すべての行をインデントします
     (‘fortran-indent-subprogram’)。

‘M-q’
     コメントブロックまたは命令文をフィルします
     (‘fortran-fill-paragraph’または‘fortran-fill-statement’を使用します
     )。

   キー‘C-M-q’は、‘fortran-indent-subprogram’を実行します、これはポイン
トを含むFortranサブプログラム(関数またはサブルーチン)の、すべての行を再
インデントします。

   キー‘C-M-j’は、‘fortran-split-line’を実行します、これはFortranの流儀
にあった方法で行を分割します。非コメント行では、後半は継続行になり、それ
にしたがったインデントになります。コメント行の場合、両方とも別のコメント
行になります。

   ‘M-^’または‘C-c C-d’は、コマンド‘fortran-join-line’を実行します。これ
は継続行を前の行に結合します。大雑把にいうと、‘fortran-split-line’の逆で
す。このコマンドを呼び出すとき、ポイントは継続行になければなりません。

   Fortranモードでの‘M-q’は、ポイントのあるコメントブロックまたは命令文
ブロックをフィルします。これは余分な命令文の継続を削除します。


File: emacs-ja.info,  Node: ForIndent Cont,  Next: ForIndent Num,  Prev: ForIndent Commands,  Up: Fortran Indent

26.14.2.2 継続行
................

ほとんどのFortran77コンパイラーは、2つの方法で継続行を記述します。ある行
の最初の非スペース文字が列5の場合、その行は前の行の継続行です。これを“固
定形式(fixed form)”と呼びます。(GNU Emacsでは常に列は0から数えますが、
Fortran標準では列1から数えることに注意。列をFortran様式で表示するよう、
変数‘column-number-indicator-zero-based’をカスタマイズできる。 *note
Optional Mode Line::を参照されたい) 変数‘fortran-continuation-string’は
、列5に配す文字を指定します。タブ文字で開始され、その後‘0’以外の任意の数
字後に続くTAB文字も継続行です。この継続スタイルを“タブ形式(tab format)”と
呼びます(Fortran 90では、自由形式(free form)という継続行スタイルが導入さ
れた)。

   Fortranモードは、どちらの継続行スタイルも使用できます。Fortranモード
に入ったとき、バッファー内容から、自動的に適切な継続行スタイルを推論しよ
うと試みます。これはバッファーの開始から、‘fortran-analyze-depth’行(デフ
ォルトは100)をスキャンすることにより行われます。最初の行の開始がタブ文字
か、6個のスペースかで選択が決定されます。スキャンが失敗した場合(たとえば
、新しいバッファーで中身が空の場合)、‘fortran-tab-mode-default’の値
(‘nil’の場合は固定形式で、非‘nil’の場合はタブ形式)が使用されます。モード
ラインに‘/t’ (‘fortran-tab-mode-string’)が表示されている場合、タブ形式が
選択されていることを示します。それに応じてFortranモードは
‘indent-tabs-mode’の値をセットします。

   行のテキストがFortranの継続マーカー‘$’で始まるか、列5の非空白文字で始
まる場合、Fortranモードはそれを継続行として扱います。継続行を‘<TAB>’でイ
ンデントした場合、その行をカレントの継続スタイルに変換します。Fortran命
令文を‘C-M-j’で分割した場合、継続スタイルに応じた継続マーカーがある新し
い行が作成されます。

   継続スタイルのセッティングは、Fortranモードでの編集の他の側面に影響し
ます。固定形式の場合、命令文の最小列は6になります。Fortranブロック内でそ
れより大きい列にインデントされる行には、空白文字としてスペース文字だけを
使用しなければなりません。タブ形式では、命令文の最小列は8で、列8より前の
空白文字は1つのタブ文字でなければなりません。


File: emacs-ja.info,  Node: ForIndent Num,  Next: ForIndent Conv,  Prev: ForIndent Cont,  Up: Fortran Indent

26.14.2.3 行番号
................

その行の最初の非空白文字が数字の場合、Fortranのインデントはそれを行番号
と判断して、列0から列4に移動します(Emacsでは列を常に0から数えるが、
‘column-number-indicator-zero-based’を‘nil’にセットすることによりこれを
変更できる。 *note Optional Mode Line::を参照されたい)

   4桁以下の行番号は、通常1つのスペースでインデントされます。変数
‘fortran-line-number-indent’はこれを制御します。これは行番号がもてる最大
のインデントを指定します。この変数のデフォルト値は1です。Fortranモードは
、必要なら指定した最大列以下にインデントを減らして、行番号が列4を超える
のを防ごうと試みます。‘fortran-line-number-indent’が5の場合、行番号は列
4で終わるように右端に揃えられます。

   これらのルールに応じたインデントをするには、単純に行番号を挿入するだ
けで充分です。各桁が挿入されるたびに、インデントは再計算されます。この機
能をオフに切り替えるには、変数‘fortran-electric-line-number’を‘nil’にセ
ットしてください。


File: emacs-ja.info,  Node: ForIndent Conv,  Next: ForIndent Vars,  Prev: ForIndent Num,  Up: Fortran Indent

26.14.2.4 構文的な慣習
......................

Fortranモードは正しくインデントを行うために、あなたが、Fortranプログラム
解読を単純化する特定の慣習にしたがうと仮定します：

   • ネストされた2つの‘do’ループは、‘continue’命令を共有しない。

   • ‘if’、‘else’、‘then’、‘do’、その他のFortranキーワードは、空白文字や
     行ブレークを含まずに記述される。

     Fortranコンパイラーは一般的に文字列定数の外の空白文字を無視しますが
     、Fortranモードはこれらのキーワードが隣接していない場合、それらを認
     識しません。‘else if’や‘end do’のような構成は許されますが、2つ目の
     単語は継続行ではなく、1つ目の単語と同じ行にあるべきです。

これらの慣習にしたがわない場合、インデントコマンドは醜いインデントをする
かもしれません。しかし正しいFortranプログラムなら、慣習にしたがわずにイ
ンデントされたものでも、その意味は変わりません。


File: emacs-ja.info,  Node: ForIndent Vars,  Prev: ForIndent Conv,  Up: Fortran Indent

26.14.2.5 Fortranのインデントのための変数
.........................................

Fortranのインデントがどのように機能するかを制御する、追加の変数がいくつ
かあります:

‘fortran-do-indent’
     ‘do’命令の各レベルにたいする、追加のインデントです(デフォルトは3)。

‘fortran-if-indent’
     ‘if’、‘select case’、‘where’命令の各レベルにたいする、追加のインデ
     ントです(デフォルトは3)。

‘fortran-structure-indent’
     ‘structure’、‘union’、‘map’、‘interface’命令の各レベルにたいする、
     追加のインデントです(デフォルトは3)。

‘fortran-continuation-indent’
     継続行の本文にたいする、追加のインデントです(デフォルトは3)。

‘fortran-check-all-num-for-matching-do’
     Fortran 77では、番号つきの‘do’命令は、それにマッチする行番号をもつ
     任意の命令で終了します。この目的のためには‘continue’命令を使うのが
     一般的です(が、強制ではありません)。この変数が非‘nil’値の場合、番号
     が付与された命令をインデントするとき、そこで終了する‘do’をチェック
     しなければなりません。‘do’命令を常に‘continue’(またはよりモダンな
     ‘enddo’)で終了する場合は、この変数を‘nil’(デフォルト)にセットするこ
     とにより、インデントの速度を上げることができます。

‘fortran-blink-matching-if’
     この変数が‘t’の場合、‘endif’(または‘enddo’)命令のインデントにより、
     マッチする‘if’(または‘do’)命令にカーソルが数瞬移動します。デフォル
     トは‘nil’です。

‘fortran-minimum-statement-indent-fixed’
     固定形式の継続行スタイルを使用する場合の、Fortran命令にたいする最小
     のインデントです。命令本体はこれより小さい値でインデントされること
     はありません。デフォルトは6です。

‘fortran-minimum-statement-indent-tab’
     タブ形式の継続行スタイルを使用する場合の、Fortran命令にたいする最小
     のインデントです。命令本体はこれより小さい値でインデントされること
     はありません。デフォルトは8です。

   以下のセクションでは、コメントのインデントを制御する変数を説明します
。


File: emacs-ja.info,  Node: Fortran Comments,  Next: Fortran Autofill,  Prev: Fortran Indent,  Up: Fortran

26.14.3 Fortranのコメント
-------------------------

通常のEmacsのコメントコマンドは、コード行の後にコメントを記述できると仮
定します。Fortran 77では、標準のコメント構文はコメント行に行全体を要求し
ます。したがってFortranモードは、標準のEmacsコメントコマンドを置き換え、
新しい変数も定義します。

   Fortranモードは、‘!’で始まり、他のテキストの後に記述することができる
、Fortran 90のコメント構文も処理できます。この構文を許すFortran 77コンパ
イラーは限られているので、Fortranモードは、あらかじめそれを行うように指
示しない限り、そのようなコメントを挿入しません。これを行うには、変数
‘fortran-comment-line-start’に‘"!"’をセットします。通常とは異なる値を使
う場合、‘fortran-comment-line-start-skip’も変更する必要があるでしょう。

‘M-;’
     コメントの位置揃え、または新しいコメントを挿入します
     (‘comment-dwim’)。

‘C-x ;’
     非標準の‘!’だけを適用します(‘comment-set-column’)。

‘C-c ;’
     リージョンのすべての行をコメントにします。または(引数を指定した場合
     は)コメントを実際のコードに戻します(‘fortran-comment-region’)。

   Fortranモードで実行すると、これは標準の‘comment-dwim’を実行します。こ
れは任意の種類の既存のコメントを認識して、それらのテキストの位置揃えをし
ます。既存のコメントがない場合は、コメントの挿入・位置揃えをします。
Fortranモードでのコメントの挿入および位置揃えは、他のモードとは異なりま
す。

   新しいコメントが挿入されなければならない場合、カレント行が空のときは
、行全体をコメントとして挿入します。その行が空でない場合、もしそれを使う
ことを指示していれば、非標準の‘!’コメントが挿入されます。そうでない場合
はカレント行の前に新しい行を挿入して、その行全体をコメントにします。

   非標準の‘!’コメントは、他の言語のコメントと同じように位置揃えされます
が、行全体のコメントは異なります。標準の行全体のコメントは、コメント区切
り自体は常に列0に出現しなければなりません。位置揃えできるのは、コメント
の中のテキストです。変数‘fortran-comment-indent-style’に、以下の3つの値
のうち1つをセットすることにより、3つのスタイルの位置揃えを選択できます。

‘fixed’
     テキストを固定列に位置揃えします。これは
     ‘fortran-comment-line-extra-indent’と命令文の最小のインデントとの和
     です。これがデフォルトです。

     最小のインデントは、タブ形式の継続行スタイルの場合は
     ‘fortran-minimum-statement-indent-tab’で、固定形式スタイルの場合は
     ‘fortran-minimum-statement-indent-fixed’です。

‘relative’
     そのテキストがコード行であるかのように位置揃えしますが、
     ‘fortran-comment-line-extra-indent’に指定した列のインデントが追加さ
     れます。

‘nil’
     行全体のコメントを自動的に移動しません。

   これらに加えて、変数‘fortran-comment-indent-char’に、使用したい1文字
をセットすることにより、行全体のコメントのインデントに使用する文字を指定
することができます

   コンパイラーにたいする命令行や、プリプロセッサー行は、コメント行と同
じ外観をもっています。しかし、‘fortran-comment-indent-style’の値に関わら
ず、そのような行が決してインデントされないことが重要です。変数
‘fortran-directive-re’は、どのような行がそのような命令なのかを指定する正
規表現です。これにマッチする行はインデントされず、特別な外観のフォントが
適用されます。

   Emacsの通常のコメントコマンド‘C-x ;’ (‘comment-set-column’)は再定義さ
れません。‘!’コメントを使用している場合、このコマンドをそれらに使用でき
ます。そうでない場合、これはFortranモードでは役に立ちません。

   コマンド‘C-c ;’ (‘fortran-comment-region’)は、リージョンのすべての行
の行頭に文字列‘c$$$’を挿入することにより、これらをコメントにします。数引
数を指定した場合、各行の行頭から‘c$$$’を削除することにより、リージョンを
コードに戻します。これらのコメントに使用する文字列は、変数
‘fortran-comment-region’をセットすることにより制御できます。これはコマン
ドと変数が同じ名前をもつ例であることに注意してください。同じ名前を2つの
用途で使用することによる衝突はありません。なぜならLispおよびEmacsではそ
れが意味するものは、コンテキストにより明らかだからです。


File: emacs-ja.info,  Node: Fortran Autofill,  Next: Fortran Columns,  Prev: Fortran Comments,  Up: Fortran

26.14.4 FortranモードでのAuto Fill
----------------------------------

Fortranモードは、Auto Fillモードにたいする特別なサポートをもっています。
これは命令文を挿入するとき、それが長くなりすぎた場合は自動的に分割するマ
イナーモードです。命令文の分割は、‘fortran-continuation-string’を使用し
た継続行により行われます(*note ForIndent Cont::を参照してください)。この
分割は‘<SPC>’、‘<RET>’、‘<TAB>’、およびFortranのインデントコマンドにより
発生します。FortranモードでのAuto Fillの有効化は、通常の方法で行うことが
できます。 *note Auto Fill::を参照してください。

   Auto Fillは、その行が望ましい幅(‘fill-column’の値)より長くなった場合
は、スペースおよび区切り文字で行をブレークします。Auto Fillが行をブレー
クする(空白文字以外の)区切り文字は‘+’、‘-’、‘/’、‘*’、‘=’、‘<’、‘>’、
‘,’です。‘fortran-break-before-delimiters’が‘nil’の場合、区切り文字の後
ろで行ブレークします。そうでない場合(デフォルト)、区切り文字の前で行ブレ
ークします。

   すべてのFortranバッファーでAuto Fillを有効にするには、
‘fortran-mode-hook’に‘auto-fill-mode’を追加します。 *note Hooks::を参照
してください。


File: emacs-ja.info,  Node: Fortran Columns,  Next: Fortran Abbrev,  Prev: Fortran Autofill,  Up: Fortran

26.14.5 Fortranでの列のチェック
-------------------------------

標準のFortran 77では、72列目以降は無視されます。ほとんどのコンパイラーは
これを変更するオプションを提供します(たとえばgfortranの
‘-ffixed-line-length-N’)。変数‘fortran-line-length’をカスタマイズするこ
とにより、Fortranモードでの行の長さを変更できます。このポイント以降はコ
メントにfont-lockされます(ただし文字列内の場合は除きます。
‘fortran-line-length’を超える文字列は、font-lockを混乱させるでしょう)。

‘C-c C-r’
     カレント行の上に、列目盛(column ruler)を一時的に表示します。

‘C-c C-w’
     ‘fortran-line-length’列の幅になるように、カレントウィンドウを水平に
     分割します(‘fortran-window-create-momentarily’)。これは、Fortranコ
     ンパイラーにより課せられた制限を超えないようにする助けになるでしょ
     う。

‘C-u C-c C-w’
     (‘fortran-window-create’)列の幅になるように、カレントウィンドウを水
     平に分割します。その後は編集を続行できます。

‘M-x fortran-strip-sequence-nos’
     列‘fortran-line-length’以上のすべてのテキストを削除します。

   コマンド‘C-c C-r’ (‘fortran-column-ruler’)は、カレント行の上に列目盛
を一時的に表示します。列目盛は2行のテキストで、Fortranプログラムにおいて
特別な意味をもつ列の位置を表示します。角カッコ(square brackets)は行番号
の範囲を示し、中カッコ(curly brackets)は命令文本体の範囲を示します。列番
号がその上に表示されます。

   GNU Emacsで常にそうであるように、列番号は0からカウントされることに注
意してください(ただしF‘column-number-indicator-zero-based’oをカスタマイ
ズして、rtranにマッチするよう列表示を変更することができる)。 *note
Optional Mode Line::を参照されたい) 結果として、この番号はあなたが親しん
でいる番号より1小さくなるかもしれません。しかしこの行で示される位置は、
Fortranの標準です。

   列目盛を表示するのに使用されるテキストは、変数‘indent-tabs-mode’の値
に依存します。‘indent-tabs-mode’が‘nil’の場合、変数
‘fortran-column-ruler-fixed’の値が列目盛として使用されます。それ以外は、
変数‘fortran-column-ruler-tab’の値が表示されます。これらの値を変更するこ
とにより、表示される列目盛を変更できます。

   ‘C-c C-w’ (‘fortran-window-create-momentarily’)で、一時的にカレントウ
ィンドウを水平方向に分割して、ウィンドウの幅を‘fortran-line-length’列に
することにより、長くなりすぎた行を見つけることができます。スペースをタイ
プすると元の幅に戻ります。

   適切な位置でウィンドウを水平方向に分割して、編集を継続することもでき
ます。これを行うには、‘C-u C-c C-w’ (‘M-x fortran-window-create’)を使用
します。このウィンドウで編集することより、Fortranでの正しい長さを超える
行をすぐに見つけることができます。

   コマンド‘M-x fortran-strip-sequence-nos’は、カレントバッファーのすべ
ての行にたいして、列‘fortran-line-length’以上のテキストすべてを削除しま
す。これは古いシーケンス番号を削除する一番簡単な方法です。


File: emacs-ja.info,  Node: Fortran Abbrev,  Prev: Fortran Columns,  Up: Fortran

26.14.6 FortranキーワードのAbbrev
---------------------------------

Fortranモードは、一般的なキーワードや定義にたいするabbrev(abbreviation:
省略形)を提供します。あなたが定義できるabbrevと同様なものがあります。こ
れらを使用するには、Abbrevモードをオンに切り替えなければなりません。
*note Abbrevs::を参照してください。

   ビルトインのabbrevは、1つの点で特異です。これらはすべてセミコロンから
始まります。たとえばFortranのビルトインのabbrevである‘;c’は、
‘continue’にたいする省略形です。‘;c’を挿入してから、スペースや改行のよう
な区切りとなる文字を挿入すると、Abbrevモードが有効な場合、‘;c’は自動的に
‘continue’に展開されます。

   ‘;?’または‘;C-h’とタイプすると、すべてのビルトインのFortranのabbrevの
リストと、それが何を意味するかが表示されます。


File: emacs-ja.info,  Node: Building,  Next: Maintaining,  Prev: Programs,  Up: Top

27 プログラムのコンパイルとテスト
*********************************

前のチャプターでは、プログラムを変更するのに便利なEmacsコマンドについて
議論しました。このチャプターでは、プログラムのコンパイルとテストに役立つ
コマンドを扱います。

* Menu:

* Compilation::              Lisp以外の言語(C、Pascal、など)のプログラムのコンパイル。
* Compilation Mode::         コンパイラーのエラーをvisitするモード。
* Compilation Shell::        compilationバッファーで使えるように、シェルを適切にカスタマイズする。
* Grep Searching::           grepによる検索。
* Flymake::                  オンザフライでの構文エラーの検索。
* Debuggers::                非Lispプログラムのための、シンボルデバッガーの実行。
* Executing Lisp::           Lispプログラムを編集するためのさまざまなモードと、Lispプログラムを実行する異なる機能。
* Libraries: Lisp Libraries.  LispプログラムがEmacsにロードされる方法。
* Eval: Lisp Eval.           Emacsで1つのLisp式を実行する。
* Interaction: Lisp Interaction.  EmacsバッファーでLispを実行する。
* External Lisp::            Emacsを通じて別のLispと通信する。


File: emacs-ja.info,  Node: Compilation,  Next: Compilation Mode,  Up: Building

27.1 Emacs下でのコンパイルの実行
================================

Emacsは、CやFortranのような言語のためのコンパイラーを実行でき、コンパイ
ルログをEmacsのバッファーに取り込むことができます。エラーメッセージを解
析して、エラーが発生した場所を示すこともできます。

‘M-x compile’
     Emacs下で非同期にコンパイラーを実行し、エラーメッセージは
     ‘*compilation*’バッファーに送られます。

‘M-x recompile’
‘g (Compilation mode)’
     最後に呼び出した‘M-x compile’と同じコマンドで、コンパイラーを呼び出
     します。

‘M-x kill-compilation’
     サブプロセスで実行されているコンパイルをkillします。

   ‘make’、または他のコンパイルコマンドを実行するには、‘M-x compile’とタ
イプします。これはミニバッファーを使用してシェルのコマンドラインを読み取
り、シェルをEmacsのサブプロセス(または“下位プロセス(inferior process)”)と
して、そのコマンドを実行します。出力は‘*compilation*’という名前のバッフ
ァーに挿入されます。カレントバッファーのデフォルトディレクトリーが、コマ
ンドを実行する作業ディレクトリーとして使用されます。したがって、通常はそ
のディレクトリーでコンパイルが行われます。

   デフォルトのコンパイルコマンドは‘make -k’で、これは‘make’ユーティリテ
ィーを使ってコンパイルするプログラムにたいして通常正しいコマンドです
(‘-k’フラグは‘make’に、エラー後も可能な限りコンパイルを継続するよう指示
します)。*note Make: (make)Top.を参照してください。前に‘M-x compile’を実
行している場合、それに指定したコマンドは自動的に変数‘compile-command’に
格納されます。これは、次に‘M-x compile’とタイプしたときのデフォルトとな
ります。ファイルのファイルローカルな値で‘compile-command’を指定すること
もできます(*note File Variables::を参照してください)。

   コンパイルを開始すると、他のウィンドウで‘*compilation*’バッファーが表
示されますが、そのウィンドウは選択されません。コンパイルが実行中は、
‘*compilation*’バッファーのメジャーモードインジケーターに‘run’という単語
が表示され、単語‘Compiling’がすべてのモードラインに表示されます。コンパ
イル実行中、常に‘*compilation*’バッファーを表示している必要はありません
。表示されていなくてもコンパイルは継続します。何らかの理由によりコンパイ
ルが終了したときは、‘*compilation*’バッファーのモードラインが‘exit’(その
後に終了コード。‘[0]’の場合は通常終了)、または‘signal’(何らかのシグナル
がプロセスを終了させた場合)に変化します。

   コンパイルの経過を見たいときは、バッファー‘*compilation*’に切り替えて
、ポイントをバッファーの最後に移動します。ポイントが最後にある場合、コン
パイル出力はポイント位置に挿入されるので、ポイントは最後に留まります。そ
うでない場合は、バッファーの最後にコンパイル出力が追加される間も、ポイン
ト位置は固定されたままです。

   コンパイル処理中、モードラインにはその時点までのエラー、警告の数と、
コンパイラーからの情報が表示されます。

   変数‘compilation-scroll-output’を非‘nil’値に変更した場合、
‘*compilation*’バッファーは出力に追随して自動的にスクロールします。値が
‘first-error’の場合は、最初のエラーが出現した箇所でスクロールがストップ
し、ポイントはエラー箇所に留まります。その他の任意の非‘nil’値の場合は、
出力がなくなるまでスクロールが継続されます。

   最後にコンパイルしたのと同じコマンドで再実行するには、‘M-x
recompile’とタイプします。これは最後に呼び出した‘M-x compile’からコンパ
イルコマンドを再利用します。これは‘*compilation*’バッファーも再利用し、
コンパイルもそのバッファーのデフォルトディレクトリー、つまり前にコンパイ
ルが開始されたのと同じディレクトリーで行われます。‘*compilation*’バッフ
ァーでは、このコマンドは‘g’にバインドされています。

   新しいコンパイルの開始は、すでに‘*compilation*’で実行中のコンパイルを
killします。これは、そのバッファーが1度に1つのコンパイルしか処理できない
からです。しかし実行中のコマンドを実際にkillする前に、‘M-x compile’、お
よび‘M-x recompile’は確認を求めます。常に確認なしで自動的にコンパイルを
killするには、変数‘compilation-always-kill’を‘t’に変更します。コマンド
‘M-x kill-compilation’で、コンパイルプロセスをkillすることもできます。

   1度に2つのコンパイルを実行するには、最初に1つを開始してから(多分
‘rename-uniquely’を使用して。*note Misc Buffer::を参照してください
)‘*compilation*’、バッファーをリネームして、それからバッファーを切り替え
て他のコンパイルを開始します。これにより新しい‘*compilation*’バッファー
が作成されます。

   コンパイルコマンドに渡される環境は、変数‘compilation-environment’で制
御できます。この変数の値は環境変数のセッティングのリストで、各要素は文字
列‘"ENVVARNAME=VALUE"’の形式です。これらの環境変数のセッティングは、通常
の値をオーバーライドします。


File: emacs-ja.info,  Node: Compilation Mode,  Next: Compilation Shell,  Prev: Compilation,  Up: Building

27.2 Compilationモード
======================

‘*compilation*’バッファーは、Compilationモードと呼ばれるメジャーモードを
使用します。Compilationモードは、バッファーのエラーメッセージをハイパー
リンクに変換します。ポイントをそこに移動して<RET>をタイプするか、マウス
でクリック(*note Mouse References::を参照してください)すると、別のウィン
ドウでエラーメッセージの“locus”をvisitします。locusとは、エラーが発生し
たファイルの特定の位置を意味します。

   変数‘compilation-auto-jump-to-first-error’を非‘nil’値に変更した場合、
Emacsは、‘*compilation*’バッファーに表れる最初のエラーメッセージの
locusを自動的にvisitします。

   Compilationモードは、以下の追加のコマンドを提供します。これらのコマン
ドは‘*grep*’バッファーでも使用できます。このバッファーではエラーメッセー
ジのかわりに、検索にたいするマッチにハイパーリンクが設定されます(*note
Grep Searching::を参照してください)。

‘M-g M-n’
‘M-g n’
‘C-x `’
     次のエラーメッセージ(またはマッチ)のlocusをvisitします
     (‘next-error’)。
‘M-g M-p’
‘M-g p’
     前のエラーメッセージ(またはマッチ)のlocusをvisitします
     (‘previous-error’)。
‘M-n’
     locusをvisitせずに、ポイントを次のエラーメッセージ(またはマッチ)に
     移動します(‘compilation-next-error’)。
‘M-p’
     locusをvisitせずに、ポイントを前のエラーメッセージ(またはマッチ)に
     移動します(‘compilation-previous-error’)。
‘M-}’
     他のファイルで発生した次のエラーメッセージ(またはマッチ)にポイント
     を移動します(‘compilation-next-file’)。
‘M-{’
     他のファイルで発生した前のエラーメッセージ(またはマッチ)にポイント
     を移動します(‘compilation-previous-file’)。
‘C-c C-f’
     Next Error Followマイナーモードに切り替えます。これはcompilationバ
     ッファーでのカーソル移動にしたがって、ソースを自動的に表示するモー
     ドです。
‘g’
     出力が‘*compilation*’バッファー内に表示されている、最後のコマンドを
     再実行します。

   順番にエラーをvisitするには、‘C-x `’ (‘next-error’)とタイプするか、こ
れと等価な‘M-g M-n’または‘M-g n’とタイプします。このコマンドは
Compilationモードのバッファーだけでなく、任意のバッファーから呼び出すこ
とができます。コンパイル後に最初に呼び出すときは、最初のエラーメッセージ
のlocusをvisitします。連続した‘C-x `’は、同じ方法で次のエラーをvisitしま
す。‘*compilation*’バッファーから<RET>またはマウスクリックで特定のエラー
をvisitした場合、‘C-x `’はそのエラーの次のエラーからvisitしていきます。
これ以上visitするエラーメッセージがない場合、‘C-x `’はエラーをシグナルし
ます。‘C-u C-x `’はcompilationバッファーの先頭から再開して、最初の
locusをvisitします。

   ‘M-g M-p’または‘M-g p’ (‘previous-error’)は、反対方向にエラーを巡回し
ます。

   コマンド‘next-error’および‘previous-error’は、バッファー
‘*compilation*’または‘*grep*’にリストされたエラー(またはマッチ)だけに作
用されるわけではありません。これらのコマンドは‘M-x occur’ (*note Other
Repeating Search::を参照のようなコマンドで生成されたエラー(またはマッチ
)を巡回する方法も知っています。カレントバッファーがエラーメッセージ、ま
たはマッチを含む場合、これらのコマンドは、それらを巡回するでしょう。そう
でない場合、Emacsは選択されたフレームのウィンドウの中から、エラーメッセ
ージ(またはマッチ)を含むバッファーを探し、次に‘next-error’または
‘previous-error’が最後にvisitしたバッファー、最後にその他のすべてのバッ
ファーを探します。これらのコマンドが巡回するために選択されたバッファーが
、カレントでウィンドウに表示されていなければ、そのバッファーが表示される
でしょう。

   デフォルトでは、コマンド‘next-error’および‘previous-error’は、重要で
ないメッセージはスキップします。変数‘compilation-skip-threshold’が、これ
を制御します。デフォルト値は1で、これは警告(warning)より重要でないメッセ
ージをスキップします。2の場合、エラー(error)より重要でないものをスキップ
し、0はメッセージをスキップしません。

   Emacsがエラーメッセージのlocusをvisitしているとき、関連するソース行が
一時的にハイライトされます。このハイライトの持続時間は、変数
‘next-error-highlight’により決定されます。

   ‘*compilation*’バッファーが左フリンジ(*note Fringes::を参照してくださ
い)のあるウィンドウで表示されている場合、locusをvisitするコマンドはカレ
ントエラーメッセージを指す矢印をフリンジに配します。テキスト端末のように
、左フリンジがないウィンドウの場合、これらのコマンドは、カレントメッセー
ジがウィンドウの一番上にくるようにウィンドウをスクロールします。変数
‘compilation-context-lines’を整数値Nに変更した場合、これらのコマンドは、
フリンジの有無に関わらずメッセージがウィンドウの上からN行目にくるように
ウィンドウをスクロールします。デフォルト値の‘nil’では上述したように振る
舞います。

   コンパイラーからのメッセージを解析するために、Compilationモードは変数
‘compilation-error-regexp-alist’を使用します。これはさまざまなエラーメッ
セージのフォーマットをリストし、それらからlocusを抽出する方法をEmacsに指
示します。同じような変数‘grep-regexp-alist’は、‘grep’コマンド(*note Grep
Searching::を参照してください)の出力を解析する方法を指示します。

   Compilationモードは、スクリーン単位でスクロールを行うために、キー
<SPC>および<DEL>も定義します。‘M-n’ (‘compilation-next-error’)および
‘M-p’ (‘compilation-previous-error’)は、次または前のエラーメッセージに移
動します。‘M-{’ (‘compilation-next-file’)および‘M-}’
(‘compilation-previous-file’)は、違うソースファイルの、次または前のエラ
ーメッセージに移動します。

   ‘C-c C-f’とタイプして、Next Error Followモードに切り替えることができ
ます。このマイナーモードでは、compilationバッファーでの通常のカーソル移
動により、自動的にソースを表示するバッファーが更新されます。たとえばカー
ソルをエラーメッセージに移動すると、そのエラーにたいするlocusが表示され
ます。

   Compilationモードの機能は、Compilation Minorモード呼ばれるマイナーモ
ードでも利用可能です。これは通常のコンパイル出力のバッファーだけでなく、
任意のバッファーのエラーメッセージを解析します。‘M-x
compilation-minor-mode’とタイプすることにより、このマイナーモードが有効
になります。たとえばRloginバッファー(*note Remote Host::を参照してくださ
い)では、Compilation minorモードはリモートのソースファイルに、FTPを通じ
て自動的にアクセスします(*note File Names::を参照してください)。


File: emacs-ja.info,  Node: Compilation Shell,  Next: Grep Searching,  Prev: Compilation Mode,  Up: Building

27.3 コンパイルのためのサブシェル
=================================

このセクションには、compilationバッファー内で、シェルやその機能を使用す
るための、さまざまなテクニックとアドバイスが含まれています。ローカルでの
コンパイルに特有なトピックを扱うので、デフォルトディレクトリーがリモート
ホスト上であるようなcompilationバッファーでは、おそらくほとんどは機能し
ない(または無関係)でしょう。

   ‘M-x compile’コマンドは、コンパイルコマンドを実行するためにシェルを使
いますが、オプションで非対話的なシェルを指定します。これは、シェルがプロ
ンプトなしで開始されることを意味します。‘*compilation*’バッファーで、通
常のシェルプロンプトの見映えがよくない場合、それはシェルの初期化ファイル
で、無条件にプロンプトをセットするという間違いを犯していることを意味しま
す(この初期化ファイルは使用しているシェルに応じて‘.bashrc’、‘.profile’、
‘.cshrc’、‘.shrc’などの名前がついています)。シェルの初期化ファイルでは、
プロンプトがすでにあるときだけプロンプトをセットするべきです。これを
bashで行うには、以下のようにします:

     if [ "${PS1+set}" = set ]
     then PS1=...
     fi

cshで行うには以下のようにします:

     if ($?prompt) set prompt = ...

   compilationのサブシェルに渡す環境変数‘TERM’の値をカスタマイズしたい場
合は、変数‘comint-terminfo-terminal’の値をカスタマイズしてください(*note
Shell Options::を参照)。

   Emacsは、コンパイラープロセスが非同期なサブプロセスで実行されることを
要求しません。もしこれを行う場合、メインのコンパイラープロセスが終了した
後で、サブプロセスがまだ実行中のときは、Emacsはこれらをkillするか、それ
らの出力はEmacsには到達しません。この問題を避けるには、メインのコンパイ
ルプロセスが、それのサブプロセスの終了までwaitするようにします。シェルス
クリプトでは、以下のように‘$!’と‘wait’を使用して、これを行うことができま
す:

     (sleep 10; echo 2nd)& pid=$!  # サブプロセスのpidを記録
     echo first message
     wait $pid                     # サブプロセスのwait

バックグラウンドのプロセスがcompilationバッファーに何も出力せず、メイン
のコンパイルプロセスが終了したときに、これらがkillされるのを防ぐことだけ
が必要な場合は、以下で充分です:

     nohup COMMAND; sleep 1

   MS-DOSオペレーティングシステムでは、非同期なサブプロセスはサポートさ
れていないので、‘M-x compile’はコンパイルコマンドを同期実行します(たとえ
ばEmacsで他のことを行うには、コマンドが終了するまで待たなければなりませ
ん)。*note MS-DOS::を参照してください。


File: emacs-ja.info,  Node: Grep Searching,  Next: Flymake,  Prev: Compilation Shell,  Up: Building

27.4 Emacs下でのGrepによる検索
==============================

Emacsからコンパイラーを実行して、コンパイルエラーの行をvisitできるように
、‘grep’を実行して見つかったマッチの行をvisitすることもできます。これは
‘grep’が報告するマッチを、エラーのように扱うことで機能します。出力バッフ
ァーはGrepモードを使用します。これはCompilationモードの変種です(*note
Compilation Mode::を参照してください)。

‘M-x grep’
‘M-x lgrep’
     Emacs下で‘grep’を非同期で実行し、‘*grep*’という名前のバッファーにマ
     ッチした行をリストします。
‘M-x grep-find’
‘M-x find-grep’
‘M-x rgrep’
     ‘find’を通じて‘grep’を実行し、出力を‘*grep*’バッファーに収集します
     。
‘M-x zrgrep’
     ‘zgrep’を実行して、出力を‘*grep*’バッファーに収集します。
‘M-x kill-grep’
     実行中の‘grep’サブプロセスをkillします。

   ‘grep’を実行するには、‘M-x grep’とタイプしてから、どのように‘grep’を
実行するかを指定するコマンドラインを入力します。これは通常、‘grep’を実行
するとき与える引数と同じです。‘grep’スタイルのregexp(通常、シェルのスペ
シャル文字をクォートするためシングルクォートで囲む)の後に、ファイル名(ワ
イルドカードも使用できる)を続けます。‘M-x grep’にプレフィクス引数を指定
した場合、バッファーのポイント位置周辺の識別子(*note Xref::を参照してく
ださい)を探して、それを‘grep’コマンドのデフォルトにします。

   指定するコマンドは、単純に‘grep’を実行するものである必要はありません
。同じフォーマットで出力を生成するシェルコマンドを使用することができます
。たとえば、以下のように、‘grep’コマンドを連結することができます:

     grep -nH -e foo *.el | grep bar | grep toto

   ‘grep’コマンドの出力は、‘*grep*’バッファーに送られます。オリジナルの
ファイルの対応する行は、コンパイルエラーと同様、‘C-x `’、<RET>などで見つ
けることができます。コマンドのより詳細な説明と、‘*grep*’バッファー内で利
用可能なキーバインディングについては、*note Compilation Mode::を参照して
ください。

   マッチをハイライトするために、その周囲に特別なマーカーを出力する
‘--color’オプションを指定できるgrepプログラムもあります。この機能を使う
には、‘grep-highlight-matches’を‘t’にセットします。これによりソースバッ
ファーのマッチを表示するとき、ソース行全体ではなく、正確なマッチだけがハ
イライトされます。

   コンパイルコマンド(*note Compilation::を参照)のときと同様、grepコマン
ド実行中には、モードラインにはそれまでに見つかったマッチ数が表示されて、
ハイライトされます。

   ‘grep’コマンドは、実行前にバッファーの保存を提案するでしょう。これは
、変数‘grep-save-buffers’により制御されます。利用できる値は‘nil’(保存し
ない)、‘ask’(保存前に尋ねる)、または述語として使用される関数(ファイル名
をパラメーターとして呼び出され、バッファーを保存する場合は非‘nil’をリタ
ーンすべきである)のいずれかである。その他の非‘nil’値は、すべてのバッファ
ーが確認なしで保存されるべきであることを意味します。デフォルト値は
‘ask’です。

   コマンド‘M-x grep-find’(‘M-x find-grep’でも利用可能)は、‘M-x grep’と
似ていますが、コマンドにたいして提供される初期のデフォルトが異なります —
このデフォルトは‘find’と‘grep’の両方を実行するもので、これによりディレク
トリーツリーの各ファイルを検索できます。*note Dired and Find::の
‘find-grep-dired’コマンドも参照してください。

   コマンド‘M-x lgrep’ (local grep)および‘M-x rgrep’ (recursive grep)は
、‘grep’および‘grep-find’のユーザーフレンドリーなバージョンで、これらは
マッチにたいする正規表現、検索するファイル、検索の基準となるディレクトリ
ーを個別に尋ねます。検索での大文字小文字の区別は、‘case-fold-search’の値
で制御されます。コマンド‘M-x zrgrep’は‘M-x rgrep’と似ていますが、これは
‘grep’のかわりに‘zgrep’を呼び出し、gzipされたファイルの内容を検索します
。

   これらのコマンドは、変数‘grep-template’(‘lgrep’用)、および
‘grep-find-template’(‘rgrep’用)にもとづいてシェルコマンドを構築します。
検索するファイルには、変数‘grep-files-aliases’で定義されたエイリアスを使
用できます。

   変数‘grep-find-ignored-directories’にリストされたディレクトリーは、
‘M-x rgrep’の検索で自動的にスキップされます。デフォルト値には、さまざま
なバージョンコントロールシステムで使用されるデータディレクトリーが含まれ
ます。


File: emacs-ja.info,  Node: Flymake,  Next: Debuggers,  Prev: Grep Searching,  Up: Building

27.5 オンザフライで構文エラーを見つける
=======================================

FlymakeモードはC、C++、Perl、HTML、TeX/LaTeXを含む、多くのプログラミング
言語およびマークアップ言語の構文チェックを、オンザフライ(on-the-fly)で処
理するマイナーモードです。これは通常の人間の言語にたいしてスペルチェック
を処理する、Flyspellモード(*note Spelling::を参照してください)と、その方
法において類似しています。Flymakeモードはファイルの編集にしたがい、その
バッファーの一時的なコピーを使用して、適切な構文チェックツールをバックグ
ラウンドで実行します。それからエラーメッセージと警告メッセージを解析して
、そのバッファーの間違った行をハイライトします。使用される構文チェックツ
ールは、言語に依存します。たとえば通常、C/C++ファイルの場合は、Cコンパイ
ラーです。Flymakeは、複雑なプロジェクトにたいしてのチェックでは、
‘make’のようなビルドツールを使うこともできます。

   Flymakeモードを有効にするには、‘M-x flymake-mode’とタイプします。‘M-x
flymake-goto-next-error’および‘M-x flymake-goto-prev-error’を使用して、
これが見つけたエラーにジャンプすることができます。カレント行に関連するエ
ラーメッセージを表示するには、‘M-x
flymake-display-err-menu-for-current-line’とタイプしてください。

   Flymakeの使用についての詳細は、 *note Flymake: (flymake)Top.を参照し
てください。


File: emacs-ja.info,  Node: Debuggers,  Next: Executing Lisp,  Prev: Flymake,  Up: Building

27.6 Emacs下でのデバッガーの実行
================================

GUD(Grand Unified Debugger)ライブラリーは、広範なシンボリックデバッガー
にたいするEmacsのインターフェースを提供します。これはGNUデバッガー
(GDB)、同様にDBX、SDB、XDB、GuileのREPLのデバッグコマンド、Paerlのデバッ
グモード、PythonデバッガーのPDB、JavaデバッガーのJDBを実行することができ
ます。

   EmacsはGDBにたいする特別なインターフェースを提供します。これはデバッ
グされているプログラムの状態を表示する追加のEmacsウィンドウを使用します
。*note GDB Graphical Interface::を参照してください。

   Emacsは、Emacs Lispプログラムにたいするビルトインのデバッガーももって
います。*note The Lisp Debugger: (elisp)Debugging.を参照してください。

* Menu:

* Starting GUD::             デバッガーサブプロセスを開始する方法。
* Debugger Operation::       デバッガーとソースバッファーの関係。
* Commands of GUD::          一般的なコマンドのキーバインディング。
* GUD Customization::        GUDにたいして独自のコマンドを定義する。
* GDB Graphical Interface::  GDB機能を使用して、グラフィカルなデバッグ環境を実装する拡張モード。


File: emacs-ja.info,  Node: Starting GUD,  Next: Debugger Operation,  Up: Debuggers

27.6.1 GUDの開始
----------------

デバッガーサブプロセスを開始する複数のコマンドがあり、それらは特定のデバ
ッガープログラムに対応しています。

‘M-x gdb’
     GDBをサブプロセスとして実行し、IDE-likeなEmacsインターフェースを通
     じてやりとりをします。このコマンドに間する詳細は、*note GDB
     Graphical Interface::を参照してください。

‘M-x gud-gdb’
     GDBサブプロセスとの入出力に、GUD interactionバッファーを使用して
     GDBを実行します((*note Debugger Operation::を参照してください))。そ
     のようなバッファーがすでに存在している場合はそのバッファーに切り替
     え、存在しない場合はバッファーを作成して切り替えます。

     ここにリストされている他のコマンドは、他のデバッガープログラムにた
     いして同じことを行います。

‘M-x perldb’
     Perlインタープリターをデバッグモードで実行します。

‘M-x jdb’
     Javaデバッガーを実行します。

‘M-x pdb’
     Pythonデバッガーを実行します。

‘M-x guiler’
     Guile Schemeプログラムをデバッグするために、Guile REPLを実行します
     。

‘M-x dbx’
     DBXデバッガーを実行します。

‘M-x xdb’
     XDBデバッガーを実行します。

‘M-x sdb’
     SDBデバッガーを実行します。

   これらの各コマンドは、ミニバッファーを使ってデバッガーを呼び出すコマ
ンドラインを読み取ります。ミニバッファーの初期内容は、デバッガーの標準的
な実行ファイル名とオプションで、デバッグしたいと推測される実行ファイル名
の場合もあります。シェルのワイルドカードと変数は、このコマンドラインでは
使用できません。Emacsは‘-’で始まらない最初のコマンド引数を、実行ファイル
名とみなします。

   Trampは、同じリモートホスト上のデバッガーとプログラムによる、リモート
デバッグ機能を提供します。詳細については、*note (tramp)Running a
debugger on a remote host::を参照してください。これはGDBのリモートデバッ
グ機能とは別の物です、なぜなら、プログラムとデバッガーは違うマシンで実行
されるからです(*note Debugging Remote Programs: (gdb)Remote Debugging.を
参照してください)。


File: emacs-ja.info,  Node: Debugger Operation,  Next: Commands of GUD,  Prev: Starting GUD,  Up: Debuggers

27.6.2 デバッガーの操作
-----------------------

“GUD interactionバッファー”は、デバッガーサブプロセスにテキストコマンド
を送ったり、それの出力を記録するのに使用されるEmacsバッファーです。これ
は‘M-x gud-gdb’や、 *note Starting GUD::にリストされた他のコマンドで使用
される、デバッガーとやりとりするための基本的なインターフェースです。
‘M-x gdb’コマンドは、ブレークポイント、スタックフレーム、その他のデバッ
ガーの状態の様相を制御する、追加の特別なバッファーにより、この機能を拡張
します(*note GDB Graphical Interface::を参照してください)。

   GUD interactionはShellモードの変種を使用するので、Shellモードで定義さ
れたEmacsコマンドが利用可能です(*note Shell Mode::を参照してください)。
ほとんどのデバッガーコマンドにたいして補完(*note Completion::を参照して
ください)が利用可能で、それらを繰り返すのに、通常のShellモードのヒストリ
ーコマンドを使うことができます。 GUD interactionバッファーで使用できる特
別なコマンドについては、*note Commands of GUD:: を参照してください。

   プログラムをデバッグすると、Emacsは関連するソースファイルをEmacsバッ
ファーにvisitして、カレント実行行には左フリンジに矢印が表示されます(テキ
スト端末では最初の2列に‘=>’の矢印が表示されます)。そのようなバッファーで
のポイントの移動は、矢印を移動しません。これらのソースファイルの編集はで
きますが、行の挿入や削除により矢印の位置は失われることに注意してください
。なぜならEmacsには編集されたソース行が、デバッガーサブプロセスから報告
されるどの行に対応するか、知る手立てがないからです。この情報を更新するに
は通常、プログラムのリコンパイルと再実行が必要です。

   GUD Tooltipモードは、GUDにツールチップサポートを追加するグローバルな
マイナーモードです。このモードに切り替えるには、‘M-x gud-tooltip-mode’と
タイプします。このモードはデフォルトで無効になっています。有効にした場合
、変数、関数、マクロ(“識別子”として総称される)にマウスポインターを移動す
ると、それらの値がツールチップで表示されます(*note Tooltips::を参照)。値
を表示したい式の上にマウスポインターを置くだけでは値が表示されない場合は
、マウスでその式をドラッグしてマークし、マウスポインターをそのマークされ
た領域内に置いたままにすることにより、より明示的にEmacsに指示することが
できます。かわりにマウスをドラッグして識別子または式をマークしてから、マ
ウスをマークした領域から離すと、式の値がツールチップに表示されます。GUD
Tooltipモードは、GUD interactionバッファー、および‘gud-tooltip-modes’に
リストされたメジャーモードの、すべてのソースバッファーで効果があります。
変数‘gud-tooltip-echo-area’が非‘nil’の場合、またはツールチップモードがオ
フの場合は、ツールチップではなくエコーエリアに値が表示されます。

   ‘M-x gud-gdb’でGUD Tooltipモードを使用する場合、GDBにより表示される式
の値は、マクロを展開する場合があり、これはデバッグされているプログラムに
副作用をもたらすかもしれません。この理由により、‘gud-gdb’ではツールチッ
プの使用は無効になっています。‘M-x gdb’インターフェースを使用する場合、
この問題は発生しません。なぜなら副作用を避ける特別なコードがあるからです
。さらにプログラムが実行されていないときに、識別子に関連付けられたマクロ
の定義を表示することもできます。


File: emacs-ja.info,  Node: Commands of GUD,  Next: GUD Customization,  Prev: Debugger Operation,  Up: Debuggers

27.6.3 GUDのコマンド
--------------------

GUDはブレークポイントのセットとクリアー、スタックフレームの選択、プログ
ラムのステップ実行のためのコマンドを提供します。

‘C-x C-a C-b’
     ポイントのあるソース行にブレークポイントをセットします。

   ソースバッファーから‘C-x C-a C-b’ (‘gud-break’)が呼び出された場合、カ
レントソース行にデバッガーのブレークポイントをセットします。このコマンド
はGUDを開始した後だけ利用可能です。デバッガーサブプロセスに関連付けられ
ていないバッファーで呼び出すと、エラーをシグナルします。

   以下のコマンドは、GUD interactionバッファーとグローバルの両方で利用可
能ですが、キーバインドが異なります。キーが‘C-c’で始まるものはGUD
interactionバッファーだけで利用可能で、‘C-x C-a’で始まるものはグローバル
に利用可能です。コマンドのいくつかはツールバーを通じても利用可能です。ま
た、特定のデバッガーではサポートされないものもあります。

‘C-c C-l’
‘C-x C-a C-l’
     GUD interactionバッファーで参照される最後のソース行を、別のウィンド
     ウに表示します(‘gud-refresh’)。

‘C-c C-s’
‘C-x C-a C-s’
     次の1行を実行します(‘gud-step’)。その行が関数呼び出しを含む場合、関
     数呼び出しに入った後に実行をストップします。

‘C-c C-n’
‘C-x C-a C-n’
     次の1行を実行します(‘gud-next’)。その行が関数呼び出しを含む場合、関
     数の中でストップせずに関数をステップオーバーします。

‘C-c C-i’
‘C-x C-a C-i’
     機械語の1命令を実行します(‘gud-stepi’)。

‘C-c C-p’
‘C-x C-a C-p’
     ポイント位置の式を評価します(‘gud-print’)。表示したい正確な式を
     Emacsが表示しない場合、最初に式をリージョンとしてマークします。

‘C-c C-r’
‘C-x C-a C-r’
     停止位置を指定せずに実行を継続します。プログラムは、ブレークポイン
     トに達する、プログラム終了、またはデバッガーがチェックしているシグ
     ナルを受けとるまで実行を続けます。

‘C-c C-d’
‘C-x C-a C-d’
     カレントソース行にブレークポイントがある場合、ブレークポイントを削
     除します。GUD interactionバッファーでこのコマンドを使用する場合、プ
     ログラムが最後に停止した位置に適用されます。

‘C-c C-t’
‘C-x C-a C-t’
     カレントソース行に、一時的なブレークポイントをセットします
     (‘gud-tbreak’)。GUD interactionバッファーでこのコマンドを使用した場
     合、プログラムが最後に停止した位置に適用されます。

‘C-c <’
‘C-x C-a <’
     次の外側のスタックフレームを選択します(‘gud-up’)。これはGDBコマンド
     の‘up’と等価です。

‘C-c >’
‘C-x C-a >’
     次の内側のスタックフレームを選択します(‘gud-down’)。これはGDBコマン
     ドの‘down’と等価です。

‘C-c C-u’
‘C-x C-a C-u’
     カレント行まで実行を継続します(‘gud-until’)。プログラムは、ブレーク
     ポイントに達する、プログラム終了、またはデバッガーがチェックしてい
     るシグナルを受けとる、またはカーソルがある行に到達するまで実行を続
     けます。

‘C-c C-f’
‘C-x C-a C-f’
     選択されたフレームがリターンするか、他の理由により停止するまでプロ
     グラムを実行します(‘gud-finish’)。

   GDBを使用している場合、追加のキーバインディングが利用可能です:

‘C-x C-a C-j’
     ソースバッファーだけで有用です。‘gud-jump’はプログラムの実行箇所を
     カレント行に転送します。別の言い方をすると、プログラムが次に実行す
     るのは、このコマンドを与えた位置になります。新しく実行される行が前
     の関数とは異なる場合、多分奇妙な結果になるので、GDBは確認を求めます
     。詳細は、GDBマニュアルのエントリー‘jump’を参照してください。

‘<TAB>’
     GDBの場合、シンボル名を補完します(‘gud-gdb-complete-command’)。この
     キーはGUD interactionバッファーだけで利用可能です。

   これらのコマンドは、それが意味がある場合には、数引数を繰り返し回数と
解釈します。

   <TAB>は補完コマンドに割り当てられているので、GDBでデバッグしているプ
ログラムへのタブの入力には使えません。タブの入力には‘C-q <TAB>’とタイプ
してください。


File: emacs-ja.info,  Node: GUD Customization,  Next: GDB Graphical Interface,  Prev: Commands of GUD,  Up: Debuggers

27.6.4 GUDのカスタマイズ
------------------------

起動時にGUDは以下のフックの1つを実行します:
GDBを使用している場合は‘gdb-mode-hook’、
DBXを使用している場合は‘dbx-mode-hook’、
SDBを使用している場合は‘sdb-mode-hook’、
XDBを使用している場合は‘xdb-mode-hook’、Guile REPLのデバッグには
‘guiler-mode-hook’、
Perlのデバッグモードを使用している場合は‘perldb-mode-hook’、
PDBを使用している場合は‘pdb-mode-hook’、
JDBを使用している場合は‘jdb-mode-hook’を実行します。
*note Hooks::を参照してください。

   Lispマクロ‘gud-def’(*note (elisp)Defining Macros::を参照してください
)は、デバッガーに特定のコマンド文字列を送るEmacsコマンドを定義して、GUD
interactionバッファーで、それにたいするキーバインドをセットアップする便
利な方法を提供します:

     (gud-def FUNCTION CMDSTRING BINDING DOCSTRING)

   これはデバッガープロセスにCMDSTRINGを送る、ドキュメント文字列が
DOCSTRINGの、FUNCTIONという名前のコマンドを定義します。コマンド
FUNCTIONを、任意のバッファーで使用できます。BINDINGが非‘nil’の場合、
‘gud-def’はそのコマンドを、GUDバッファーのモードでは‘C-c BINDING’、グロ
ーバルには‘C-x C-a BINDING’にバインドします。

   コマンド文字列CMDSTRINGには、FUNCTIONが呼び出されたときに書き込まれる
データのための、特定の‘%’シーケンスを含めることができます:

‘%f’
     カレントソースファイルの名前です。カレントバッファーがGUDバッファー
     の場合、カレントソースファイルはプログラムがストップしているファイ
     ルです。

‘%l’
     カレントソース行の番号です。カレントバッファーがGUDバッファーの場合
     、カレントソース行はプログラムがストップしている行です。

‘%e’
     transient-mark-modeでは、リージョンがアクティブの場合はリージョンの
     テキストです。そうでない場合、ポイント位置またはそれに隣接する位置
     にあるCのlvalue(左辺値)、または関数呼び出し式です。

‘%a’
     ポイント位置またはそれに隣接する位置にある、16進アドレスのテキスト
     です。

‘%p’
     呼び出された関数の数引数の10進数です。コマンドに数引数が指定されな
     かった場合、‘%p’は空文字列になります。

     コマンド文字列に‘%p’を使用しない場合、定義したコマンドは数引数を無
     視します。

‘%d’
     カレントソースファイルのディレクトリー名です。

‘%c’
     ポイントを取り囲む式から派生された、完全に記述されたされたclass名
     (fully qualified class name)です(jdbのみ)。


File: emacs-ja.info,  Node: GDB Graphical Interface,  Prev: GUD Customization,  Up: Debuggers

27.6.5 GDBのグラフィカルインターフェース
----------------------------------------

コマンド‘M-x gdb’はブレークポイント、スタックフレーム、その他のデバッグ
状態の様相を制御するために特化したバッファーで、IDE-likeなインターフェー
スでGDBを開始します。これは、たとえばマウスソースバッファーのフリンジを
クリックすることにより、そこにブレークポイントをセットするなどの、マウス
によりデバッグセッションを制御する追加の方法も提供します。

   これらの追加機能を使わずにGUD interactionバッファーのインターフェース
だけを使ってGDBを実行するには、‘M-x gud-gdb’ (*note Starting GUD::を参照
してください)を使用します。これは、(現在のところ‘M-x gdb’ではサポートさ
れていない)1つのEmacsセッションで複数のプログラムをデバッグしたいときだ
け使用しなければなりません。

   内部的には、‘M-x gdb’はGDBにたいしてスクリーンサイズに制限がないと告
げます。正しい操作のために、デバッグセッションの間はGDBのスクリーンの高
さと幅の値を変更してはいけません。

* Menu:

* GDB User Interface Layout::  複数表示されたバッファーの制御。
* Source Buffers::           プログラムを制御するためにフリンジ・余白でマウスを使う。
* Breakpoints Buffer::       ブレークポイントのコントロールパネル。
* Threads Buffer::           スレッドの表示。
* Stack Buffer::             callスタックからのフレームの選択。
* Other GDB Buffers::        GDBの状態を制御するその他のバッファー。
* Watch Expressions::        speedbarで変数の値をモニターする。
* Multithreaded Debugging::  複数スレッドのプログラムのデバッグ。


File: emacs-ja.info,  Node: GDB User Interface Layout,  Next: Source Buffers,  Up: GDB Graphical Interface

27.6.5.1 GDBのユーザーインターフェースのレイアウト
..................................................

変数‘gdb-many-windows’が‘nil’(デフォルト)の場合、‘M-x gdb’は通常GUD
interactionバッファーだけを表示します。しかし‘gdb-show-main’が非‘nil’の
場合、2つのウィンドウで開始します。その場合、1つはGUD interactionバッフ
ァーを表示して、もう一方はデバッグするプログラムの‘main’関数のソースを表
示します。

   ‘gdb-many-windows’が非‘nil’の場合、‘M-x gdb’は以下のフレームレイアウ
トを表示します。

     +--------------------------------+--------------------------------+
     |   GUD interaction buffer       |   Locals/Registers buffer      |
     |--------------------------------+--------------------------------+
     |   Primary Source buffer        |   I/O buffer for debugged pgm  |
     |--------------------------------+--------------------------------+
     |   Stack buffer                 |   Breakpoints/Threads buffer   |
     +--------------------------------+--------------------------------+

   ウィンドウのレイアウトを変更した場合、‘M-x gdb-restore-windows’とタイ
プして、複数ウィンドウのレイアウトをリストアできます。複数ウィンドウレイ
アウトと、GUD interactionバッファーとソースファイルだけの単純なレイアウ
トを切り替えるには、‘M-x gdb-many-windows’とタイプしてください。

   ウィンドウを複雑にセットアップをしていて、‘gdb-many-windows’がそれを
混乱させるのを望まない場合は、別のフレーム内で‘M-x gdb’を呼び出すほうが
よいでしょう。その場合は、元のフレームのウィンドウのアレンジに影響はあり
ません。テキスト端末で作業する場合は、GDBセッションに別のフレームを使用
すれば、各ウィンドウにたいするスクリーン資源が最活用される可能性があるの
で、特に便利になり得ます。

   同じフレームまたは異なるフレームに、GDBに関連した追加のバッファーを表
示するように指定できます。‘M-x gdb-display-BUFFERTYPE-buffer’または‘M-x
gdb-frame-BUFFERTYPE-buffer’とタイプして、望むバッファーを選択します。こ
こでBUFFERTYPEは‘breakpoints’のような、該当するバッファータイプです。
‘GUD’メニューの、サブメニュー‘GDB-Windows’または‘GDB-Frames’により、メニ
ューバーから同じことができます。

   デバッグを終えたら‘C-x k’でGUD interactionバッファーをkillすれば、こ
のセッションでの関連するすべてのバッファーをkillできます。しかしEmacsで
ソースコードの編集とリコンパイル終えて、さらにデバッグを続けたいときは、
これを行う必要はありません。実行を再開すると、GDBは自動的に新しい実行フ
ァイルを見つけます。GUD interactionバッファーを残しておけば、シェルヒス
トリー、同様にGDBブレークポイントを残すことができる利点があります。最近
編集したソースファイルのブレークポイントが、正しい場所にあるかチェックす
る必要があります。


File: emacs-ja.info,  Node: Source Buffers,  Next: Breakpoints Buffer,  Prev: GDB User Interface Layout,  Up: GDB Graphical Interface

27.6.5.2 Sourceバッファー
.........................

‘mouse-1’ (in fringe)
     その行のカレントブレークポイントをセット、またはクリアーします
     (‘gdb-mouse-set-clear-breakpoint’)。

‘C-mouse-1’ (in fringe)
     その行のブレークポイントを有効または無効にします
     (‘gdb-mouse-toggle-breakpoint-margin’)。

‘mouse-3’ (in fringe)
     その行まで実行を継続します(‘gdb-mouse-until’)。

‘C-mouse-3’ (in fringe)
     その行にジャンプします(‘gdb-mouse-jump’)。

   グラフィカルなディスプレーでは、sourceバッファーのフリンジを
‘mouse-1’でクリックして、その行にブレークポイントをセットできます(*note
Fringes::を参照してください)。クリックした場所に赤いドットが表示されます
。すでにそこにブレークポイントが存在する場合、クリックでそれを削除します
。既存のブレークポイントを‘C-mouse-1’でクリックすることにより、有効また
は無効にします。クリアーされておらず無効になったブレークポイントは、グレ
イのドットで示されます。

   テキスト端末またはフリンジが無効な場合、有効なブレークポイントはウィ
ンドウの左端に、‘B’という文字で示されます。無効なブレークポイントは‘b’で
示されます(余白はブレークポイントがあるときだけ表示されます)。

   sourceバッファーの左フリンジの塗りつぶされた矢印は、デバッグされてい
るプログラムがストップした最内フレームの行を示します。中抜きの矢印はより
高いレベルのフレームの現在実行されている行を示します。フリンジの矢印を
‘mouse-1’でドラッグすると、ボタンを離した行まで実行が進みます。かわりに
フリンジを‘mouse-3’でクリックすることにより、その行まで実行を進めること
ができます。フリンジを‘C-mouse-3’でクリックすることにより、間にある行を
実行せずに、その行にジャンプできます。このコマンドは後方へもジャンプでき
るので、すでに実行中のコードの実行の詳細を調べるのに便利です。


File: emacs-ja.info,  Node: Breakpoints Buffer,  Next: Threads Buffer,  Prev: Source Buffers,  Up: GDB Graphical Interface

27.6.5.3 Breakpointsバッファー
..............................

GDB Breakpointsバッファーは、デバッガーセッションのブレークポイント
(breakpoint)、ウォッチポイント(watchpoint)、キャッチポイント
(catchpoint)を表示します。*note (gdb)Breakpoints::を参照してください。こ
れは以下のコマンドを提供します。これらのコマンドのほとんどは“カレントブ
レークポイント”(ポイントのあるブレークポイント)に適用されます。

‘<SPC>’
     カレントブレークポイントを有効または無効にします
     (‘gdb-toggle-breakpoint’)。グラフィカルなディスプレーでは、これは
     sourceバッファーのフリンジのドットのカラーを変更します。ドットのカ
     ラーは、ブレークポイントが有効なときは赤、無効なときはグレーです。

‘D’
     カレントブレークポイントを削除します(‘gdb-delete-breakpoint’)。

‘<RET>’
     カレントブレークポイントのソース行をvisitします
     (‘gdb-goto-breakpoint’)。

‘mouse-2’
     クリックしたブレークポイントのソース行をvisitします
     (‘gdb-goto-breakpoint’)。

   ‘gdb-many-windows’が非‘nil’の場合、GDB Breakpointsバッファーは、GDB
Threadsバッファーとウィンドウを共有します。一方から他方へ切り替えるには
、ヘッダー行の関連するボタンを‘mouse-1’でクリックします。
‘gdb-show-threads-by-default’が非‘nil’の場合、GDB Threadsバッファーがデ
フォルトとして表示されます。


File: emacs-ja.info,  Node: Threads Buffer,  Next: Stack Buffer,  Prev: Breakpoints Buffer,  Up: GDB Graphical Interface

27.6.5.4 Threadsバッファー
..........................

GDB Threadsバッファーは、デバッグされているプログラムのスレッドのサマリ
ーを表示します。*note Threads: (gdb)Threads.を参照してください。スレッド
を選択するには、ポイントをそこに移動して<RET> (‘gdb-select-thread’)を押
すか、それを‘mouse-2’でクリックします。これにより、それに関連する
sourceバッファーが表示され、他のGDBバッファーの内容も更新されます。

   GDB Threadsバッファー内に含まれる項目を選択するために、
‘gdb-buffers’グループ配下の変数をカスタマイズできます。

‘gdb-thread-buffer-verbose-names’
     ‘Thread 0x4e2ab70 (LWP 1983)’のような長いスレッド名を表示します。

‘gdb-thread-buffer-arguments’
     スレッドのトップフレームの引数を表示します。

‘gdb-thread-buffer-locations’
     ファイル情報またはライブラリー名を表示します。

‘gdb-thread-buffer-addresses’
     threadバッファーのスレッドフレームのアドレスを表示します。

   複数のスレッドの情報を同時に閲覧するには、GDB Threadsバッファーの以下
のコマンドを使用します。

‘d’
     カレント行のスレッドのdisassemblyバッファーを表示します
     (‘gdb-display-disassembly-for-thread’)。

‘f’
     カレント行のスレッドのGDB Stackバッファーを表示します
     (‘gdb-display-stack-for-thread’)。

‘l’
     カレント行のスレッドのGDB Localsバッファーを表示します
     (‘gdb-display-locals-for-thread’)。

‘r’
     カレント行のスレッドのGDB Registersバッファーを表示します
     (‘gdb-display-registers-for-thread’)。

これらのコマンドの大文字‘D’、‘F’、‘L’、‘R’は、対応するバッファーを新しい
フレームに表示します。

   特定のスレッドについての情報を表示するバッファーを作成した場合、それ
はそのスレッドにバインドされて、プログラムをデバッグする間、情報を表示し
続けます。各GDBバッファーのモードインジケーターには、バッファーに情報が
表示されているスレッドの番号が表示されます。スレッドの番号はバインドされ
たバッファーのバッファー名にも含まれます。

   GDB Threadsバッファーでは、さらに他のコマンドも利用可能で、それはプロ
グラムの実行を制御するのに使われるGDBのモードに依存します。*note
Multithreaded Debugging::を参照してください。


File: emacs-ja.info,  Node: Stack Buffer,  Next: Other GDB Buffers,  Prev: Threads Buffer,  Up: GDB Graphical Interface

27.6.5.5 Stackバッファー
........................

GDB Stackバッファーは、“コールスタック(call stack)”を表示します。これは
、1行がデバッガーセッションでのネストされたサブルーチン呼び出し(“stack
frames: スタックフレーム”)にそれぞれ対応します。*note Backtraces:
(gdb)Backtrace.を参照してください。

   グラフィカルなディスプレーでは、選択されたスタックフレームは、フリン
ジの矢印で示されます。テキスト端末、またはフリンジが無効な場合、選択され
たスタックフレームは反転して表示されます。スタックフレームを選択するには
、ポイントをその行に移動して<RET> (‘gdb-frames-select’)とタイプするか、
それを‘mouse-2’でクリックします。これを行うことにより、Localsバッファー
も更新されます (*note Other GDB Buffers::を参照してください)。


File: emacs-ja.info,  Node: Other GDB Buffers,  Next: Watch Expressions,  Prev: Stack Buffer,  Up: GDB Graphical Interface

27.6.5.6 その他のGDBバッファー
..............................

Localsバッファー
     このバッファーは、カレントフレームのローカル変数の値を、簡単なデー
     タ型で表示します(*note Frame Info: (gdb)Frame Info.を参照してくださ
     い)。値を編集したいときは、そこで<RET>を押すか、‘mouse-2’でクリック
     してください。

     配列と構造体については、その型だけが表示されます。GDB 6.4以降では、
     ポイント位置で<RET>をタイプ、または‘mouse-2’でクリックすることによ
     り、ローカル変数の値を調べることができます。それより前のバージョン
     のGDBでは、型の説明(‘[struct/union]’または‘[array]’)にたいして、
     <RET>または‘mouse-2’を使用します。*note Watch Expressions::を参照し
     てください。

Registersバッファー
     このバッファーは、レジスターに保持されている値を表示します(*note
     (gdb)Registers::を参照してください)。値を編集したいときは、そのレジ
     スターで<RET>を押すか、‘mouse-2’をクリックします。GDB6.4以降では、
     最近変化したレジスター値は、‘font-lock-warning-face’で表示されます
     。

Assemblerバッファー
     assemblerバッファーは、カレントフレームをマシン語コードで表示します
     。矢印はカレント命令を指し、sourceバッファーのようにブレークポイン
     トのセットと削除ができます。ブレークポイントのアイコンも、フリンジ
     または余白に表示されます。

Memoryバッファー
     memoryバッファーは、プログラムのメモリーセクションを調べるためのバ
     ッファーです(*note Memory: (gdb)Memory.を参照してください)。ヘッダ
     ー行の適切な箇所を‘mouse-1’でクリックすることにより、そのバッファー
     が表示するメモリーの開始アドレス、またはデータアイテムの数が変化し
     ます(または‘S’および‘N’を使用)。ヘッダー行を‘mouse-3’でクリックする
     ことにより、データアイテムのフォーマット、またはユニットサイズのど
     ちらを表示するか選択します。

   ‘gdb-many-windows’が非‘nil’の場合、breakpointsバッファーとthreadsバッ
ファーがウィンドウを共有するように、localsバッファーとregistersバッファ
ーもウィンドウを共有します。一方から他方へ切り替えるには、ヘッダー行の関
連するボタンを‘mouse-1’でクリックしてください。


File: emacs-ja.info,  Node: Watch Expressions,  Next: Multithreaded Debugging,  Prev: Other GDB Buffers,  Up: GDB Graphical Interface

27.6.5.7 ウォッチ式
...................

プログラムを停止するたびに、変数がどのように変化するか見たいときは、ポイ
ントを変数名に移動して、ツールバーのウォッチアイコンをクリック
(‘gud-watch’)するか、‘C-x C-a C-w’とタイプします。プレフィクス引数を指定
した場合、変数名をミニバッファーで入力することができます。

   各ウォッチ式は、speedbarに表示されます(*note Speedbar::を参照してくだ
さい)。配列や、構造体、共有体のような複雑なデータ型はツリー形式で表示さ
れます。ツリーの子ノード、および単純なデータ型では、式の名前とその値が表
示され、speedbarフレームが選択されたときは型がツールチップで表示されます
。それより高いレベルでは名前、型、ポインターのアドレス値、そうでない場合
は名前と型だけが表示されます。ルート式では、それらがどこで定義されている
かを識別するために、ツールチップでフレームアドレスも表示されます

   複雑なデータ型を展開または折り畳むには、式の左のタグを‘mouse-2’をクリ
ックするか<SPC>を押します。式の子にあたるデータの数が、変数
‘gdb-max-children’の値を超える場合、Emacsは式を展開する前に確認を求めま
す。

   複雑なウォッチ式を削除するには、speedbarのルート式にポイントを移動し
て、‘D’ (‘gdb-var-delete’)とタイプしてください。

   単純なデータ型の変数、または複雑なデータ型の単純な要素を編集するには
、speedbarのその箇所にポイントを移動して、<RET> (‘gdb-edit-value’)とタイ
プするか、値を‘mouse-2’でクリックして、それを編集します。どちらの方法も
、ミニバッファーを使って新しい値を読み取ります。

   変数‘gdb-show-changed-values’を非‘nil’値(デフォルト)にセットした場合
、Emacsは最近変化した値を‘font-lock-warning-face’でハイライトし、スコー
プから外れた変数は目立たない‘shadow’フェイスで表示します。変数がスコープ
から外れた場合、値を変更することはできません。

   変数‘gdb-delete-out-of-scope’が非‘nil’(デフォルト)の場合、Emacsはスコ
ープから外れたときウォッチ式を自動的に削除します。この変数を‘nil’にして
おけば、プログラムが同じ関数に複数回再入したとき、新たにウォッチ式を作成
しなくてよいので便利かもしれません。

   変数‘gdb-use-colon-colon-notation’が非‘nil’の場合、Emacsは
‘FUNCTION::VARIABLE’というフォーマットを使います。これにより同じ変数名を
共有するウォッチ式を表示することができます。デフォルト値は‘nil’です。

   ウォッチ式の表示が更新されるたびに、自動的にspeedbarを前に表示するに
は、‘gdb-speedbar-auto-raise’を非‘nil’にセットします。これはEmacsフレー
ムを全画面表示にしてデバッグしているとき便利です。


File: emacs-ja.info,  Node: Multithreaded Debugging,  Prev: Watch Expressions,  Up: GDB Graphical Interface

27.6.5.8 マルチスレッドのデバッグ
.................................

GDBの“all-stop mode”では、プログラムが停止すると、すべてのスレッドの実行
が停止します。同様に、プログラムを再開すると、すべてのスレッドが実行を開
始します。*note All-Stop Mode: (gdb)All-Stop Mode.を参照してください。マ
ルチスレッド化されたいくつかのターゲットにたいして、GDBはこれを超える操
作のためのモードをサポートします。これは“non-stop mode”と呼ばれ、他のス
レッドが自由に実行を継続している間に、デバッガーで停止したプログラムのス
レッドを調べることができます。*note Non-Stop Mode: (gdb)Non-Stop Mode.を
参照してください。GDBのバージョン7.0以前では、non-stop modeはサポートさ
れておらず、すべてのターゲットにたいしては機能しません。

   変数‘gdb-non-stop-setting’は、EmacsがGDBをall-stop modeとnon-stop
modeのどちらで実行するかを決定します。デフォルトは‘t’で、これは利用可能
な場合はnon-stop modeを使うことを意味します。値を‘nil’に変更した場合、ま
たはnon-stop modeが利用不可の場合、EmacsはGDBをall-stop modeで実行します
。この変数はEmacsがデバッグセッションを開始したときに効果をもちます。値
を変更した場合、アクティブなデバッグセッションを再起動する必要があります
。

   non-stop modeモードでスレッドが停止すると、通常Emacsはそのスレッドに
切り替えます。すでに選択したスレッドから停止した他のスレッドへの切り替え
を行わないようにするには、変数‘gdb-switch-when-another-stopped’を‘nil’に
変更してください。

   Emacsが停止したスレッドに切り替えるかどうかの決定は、そのスレッドが停
止した理由に依存します。変数‘gdb-switch-reasons’をカスタマイズすることに
より、スレッドの切り替えを行う停止理由を選択できます。

   変数‘gdb-stopped-functions’には、あるスレッドが停止したときに実行する
関数を指定できます。

   non-stop modeでは、GUDの実行制御コマンドのための異なるモードを切り替
えることができます。

“Non-stop/A”

     ‘gdb-gud-control-all-threads’が‘t’(デフォルト)の場合、中断および継
     続のためのコマンドはすべてのスレッドに適用されるので、
     ‘gud-stop-subjob’または‘gud-cont’の1コマンドで、すべてのスレッドを
     停止または継続できます。少なくとも1つのスレッドが停止している場合、
     ツールバーに‘Go’ボタンが表示されます。また、少なくとも1つのスレッド
     が実行中の場合、‘Stop’ボタンが表示されます。

“Non-stop/T”

     ‘gdb-gud-control-all-threads’が‘nil’の場合、カレントスレッドだけを
     停止または継続します。GUDツールバーの‘Go’および‘Stop’のボタンの表示
     は、カレントスレッドの状態に依存します。

   ‘gdb-gud-control-all-threads’のカレント値は、ツールバーまたは
‘GUD->GDB-MI’メニューで変更できます。

   ステップコマンドは常にカレントスレッドに適用されます。

   non-stop modeでは、スレッドを選択せずにスレッドを中断または継続できま
す。threadsバッファーで、ポイント位置のスレッドにたいして‘i’をタイプする
と中断、‘c’で継続、‘s’でステップ実行します。今後さらにそのようなコマンド
が追加されるかもしれません。

   スレッドを中断した場合、停止理由は‘signal received’になることに注意し
てください。この理由が‘gdb-switch-reasons’に含まれている場合(デフォルト
では含まれています)、Emacsはそのスレッドに切り替えます。


File: emacs-ja.info,  Node: Executing Lisp,  Next: Lisp Libraries,  Prev: Debuggers,  Up: Building

27.7 Lisp式の実行
=================

Emacsには、Lispのいくつかの変種のためのメジャーモードがあります。これら
は他のプログラミング言語のモードと同じ編集コマンドを使用します(*note
Programs::を参照してください)。それに加えて、Lisp式を実行するための特別
なコマンドを提供します。

Emacs Lispモード
     Emacs Lispのソースファイルを編集するためのモードです。このモードは
     カレントのトップレベルのLisp式を評価する‘C-M-x’を定義します。*note
     Lisp Eval::を参照してください。

Lisp Interactionモード
     Emacs Lispとの対話的なセッションのためのモードです。このモードはポ
     イントの前の式を評価して、その値をバッファーに挿入する‘C-j’を定義し
     ます。*note Lisp Interaction::を参照してください。

Lispモード
     Emacs Lispではない、他のLispを実行するプログラムのソースファイルを
     編集するためのモードです。このモードは、カレントのトップレベルの式
     を外部のLispで評価する‘C-M-x’を定義します。*note External Lisp::を
     参照してください。

Inferior Lispモード
     Emacsのサブプロセス(または“inferior process: 下位プロセス”)として実
     行される外部Lispと、対話的にセッションするためのモードです。 *note
     External Lisp::を参照してください。

Schemeモード
     Lispモードと同様ですが、Schemeプログラムのためのモードです。

Inferior Schemeモード
     Inferior Lispモードと同様ですが、Schemeのためのモードです。


File: emacs-ja.info,  Node: Lisp Libraries,  Next: Lisp Eval,  Prev: Executing Lisp,  Up: Building

27.8 EmacsのためのLispコードによるライブラリー
==============================================

Emacs Lispのコードは、慣習として‘.el’で終わる名前のファイルに保存されま
す。このようなファイルは、自動的にEmacs Lispモードでvisitされます。

   Emacs Lispのコードは、loadが速く省スペースで、実行も速いバイトコード
にコンパイルできます。慣習により、コンパイルされたEmacs Lispのコードは
‘.elc’で終わる名前の別のファイルに保存されます。たとえば、‘foo.el’をコン
パイルしたコードは‘foo.elc’になります。*note Byte Compilation:
(elisp)Byte Compilation.を参照してください。

   Emacs Lispファイルを“ロード(load)”するには、‘M-x load-file’とタイプし
ます。このコマンドはミニバッファーを使ってファイル名を読み取り、そのファ
イル内容をEmacs Lispコードとして実行します。最初にファイルをvisitしてお
く必要はありません。このコマンドは、既存のEmacsバッファーからではなく、
ディスクからファイルを直接読み込みます。

   Emacs Lispファイルが、Emacs Lispの“ロードパス(load path: 以下で定義
)”にインストールされている場合、‘M-x load-file’ではなく‘M-x
load-library’とタイプしてロードできます。‘M-x load-library’コマンドは、
ファイル名ではなく“ライブラリー名(library name)”の入力を求めます。これは
Emacs Lispのロードパスの各ディレクトリーを検索して、そのライブラリー名に
マッチするファイルを見つけようと試みます。ライブラリー名が‘FOO’の場合、
ファイル名‘FOO.elc’、‘FOO.el’、‘FOO’を見つけようと試みます。デフォルトの
動作では、最初に見つかったファイルをロードします。このコマンドは‘.el’よ
り‘.elc’を優先します。それはコンパイルされたファイルの方が、ロードと実行
が速いからです。‘LIB.el’が‘LIB.elc’より新しい場合、警告を発します。この
場合、誰かが‘.el’を変更したもののリコンパイルを忘れたようだが、ともかく
‘.elc’をロードする、という警告です(この振る舞いにより、編集が終わってお
らず、まだリコンパイルする準備ができていないEmacs Lispのソースファイルを
保存することができます)。しかしオプション‘load-prefer-newer’を非‘nil’値
にセットした場合、上記の手順ではなく、Emacsは新しいファイルのバージョン
をロードします。

   Emacs Lispプログラムは通常、‘load’関数を使用してEmacs Lispファイルを
ロードします。これは‘load-library’と似ていますが、より低レベルで追加の引
数を指定できます。*note (elisp)How Programs Do Loading::を参照してくださ
い。

   Emacs Lispのロードパスは、変数‘load-path’により指定されます。この変数
の値は、ディレクトリー(文字列)のリストです。これらのディレクトリーは、
‘M-x load-library’コマンド、低レベルの‘load’関数、その他のEmacs Lispライ
ブラリーを探すEmacs関数により、指定された順に検索されます。‘load-path’の
リストの要素には、特別な値‘nil’も指定できます。これはカレントのデフォル
トディレクトリーを意味しますが、その意味するところはEmacsが‘load-path’を
使用する際のカレントディレクトリーに依存するはずなので、これを使うのは大
抵間違っています(リストに‘nil’を含めたいと思うとき、大抵の場合は、本当に
望んでいるのは‘M-x load-file’を使用することです)。

   ‘load-path’のデフォルト値は、Emacs自身がLispコードを格納するディレク
トリーのリストです。他のディレクトリーに独自のライブラリーがある場合、ロ
ードパスにそのディレクトリーを追加できます。このマニュアルで説明されてい
る他の大半の変数とは異なり、‘load-path’はCustomizeインターフェース(*note
Easy Customization::を参照してください)を通じての変更はできません。しか
しinitファイルに以下のような行を記述して、ディレクトリーを追加できます
(*note Init File::を参照してください):

     (add-to-list 'load-path "/path/to/my/lisp/library")

   いくつかのコマンドは、“自動ロード(autoload)”されます。これらを実行す
るとき、Emacsは最初に関連するライブラリーを自動的にロードします。たとえ
ば‘M-x compile’コマンド(*note Compilation::を参照してください)は、自動ロ
ードされます。これを呼び出した場合、Emacsは最初に、自動的に‘compile’ライ
ブラリーをロードします。対照的にコマンド‘M-x recompile’は、自動ロードさ
れません。そのため、このコマンドは‘compile’ライブラリーをロードするまで
利用できません。

   自動的なロードは、自動ロードされたコマンドのドキュメントを探すとき
(*note Name Help::を参照してください)にも発生します。それは、ドキュメン
トがライブラリーの他の関数や変数を参照する場合です(ライブラリーのロード
により‘*Help*’バッファーのハイパーリンクが適切にセットアップされます)。
この機能を無効にするには、変数‘help-enable-auto-load’を‘nil’に変更してく
ださい。

   デフォルトではEmacsは、XEmacs —Emacsの変更されたバージョン — でコンパ
イルされたコンパイル済みのLispファイルのロードを拒絶します。なぜならそれ
はEmacsのクラッシュをさせるからです。これらのロードを試みる場合は、変数
‘load-dangerous-libraries’に‘t’をセットしてください。


File: emacs-ja.info,  Node: Lisp Eval,  Next: Lisp Interaction,  Prev: Lisp Libraries,  Up: Building

27.9 Emacs Lisp式の評価
=======================

Emacs LispモードはEmacs Lispを編集するためのメジャーモードです。これのモ
ードコマンドは‘M-x emacs-lisp-mode’です。

   Emacsは、Emacs Lisp式を評価するためのコマンドをいくつか提供します。記
述しているEmacs Lispコードをテストするために、これらのコマンドをEmacs
Lispモードで使用できます。たとえば、関数を書き換えた後、以降の関数呼び出
しでそれを有効にするために、関数定義を評価します。これらのコマンドはグロ
ーバルに利用可能で、Emacs Lispモード以外でも使用できます。

‘M-:’
     1つのEmacs Lisp式をミニバッファーで読み取り、それを評価して、値をエ
     コーエリアに出力します(‘eval-expression’)。
‘C-x C-e’
     ポイントの前のEmacs Lisp式を評価して、値をエコーエリアに出力します
     (‘eval-last-sexp’)。
‘C-M-x’ (Emacs Lispモード)
‘M-x eval-defun’
     ポイントの後またはポイントを含むdefunを評価して、値をエコーエリアに
     出力します(‘eval-defun’)。
‘M-x eval-region’
     リージョンのすべてのEmacs Lisp式を評価します。
‘M-x eval-buffer’
     バッファーのすべてのEmacs Lisp式を評価します。

   ‘M-:’ (‘eval-expression’)は、ミニバッファーを使って式を読み取り、それ
を評価します(式を評価する前に、カレントバッファーは、式をタイプするため
のミニバッファーではなく、‘M-:’をタイプしたときカレントだったバッファー
に切り替わります)。

   コマンド‘C-x C-e’ (‘eval-last-sexp’)は、そのバッファーのポイントの前
にあるEmacs Lisp式を評価して、その値をエコーエリアに表示します。評価した
結果が整数のときは、他のフォーマット(8進、16進、
‘eval-expression-print-maximum-character’の制限を超えなければ文字)ととも
に値を表示します。

   ‘M-:’および‘C-x C-e’にプレフィクス引数を与えた場合、値をエコーエリア
に表示するのではなく、カレントバッファーのポイント位置に値を挿入します。
プレフィクス引数が0の場合、整数出力は他のフォーマット(8進、16進、文字)と
一緒に挿入されます。プレフィクス引数は、‘eval-expression-print-level’お
よび‘eval-expression-print-length’にしたがった出力の省略も防ぎます(以下
参照)。同様にプレフィックス引数‘-1’は、‘eval-expression-print-length’の
効果をオーバーライドします。

   ‘eval-defun’コマンドは、Emacs Lispモードでは‘C-M-x’にバインドされてい
ます。これはポイントを含む、またはポイントの後ろのトップレベルのLisp式を
評価して、値をエコーエリアに出力します。このコンテキストでは、トップレベ
ルの式は“defun”として参照されますが、実際の‘defun’(関数定義)である必要は
ありません。このコマンドは‘defvar’式を特別に扱います。通常、‘defvar’式を
評価しても、それが定義する変数がすでに値をもっている場合は、何も起こりま
せん。しかし、このコマンドは無条件に‘defvar’で指定された初期値に変数をリ
セットします。これはEmacs Lispプログラムをデバッグするとき便利です。式
‘defcustom’および‘defface’も同様に扱われます。このセクションで説明してい
る他のコマンドは、この特別な機能をもっていません。

   プレフィクス引数を指定すると、‘C-M-x’はEmacs LispデバッガーのEdebugの
ために関数定義をインストルメント(instrument: 処置)します。*note
Instrumenting for Edebug: (elisp)Instrumenting.を参照してください。

   コマンド‘M-x eval-region’は、リージョンのテキストを1つ以上のLisp式と
して解析して、それらを1つずつ評価します。‘M-x eval-buffer’も同様ですが、
これはバッファー全体を評価します。

   オプション‘eval-expression-print-level’および
‘eval-expression-print-length’は、評価コマンドが結果を出力する前に省略す
る、リストの最大の深さと長さを制御します。‘eval-expression’または
‘eval-last-sexp’にプレフィクス引数0を指定すると、リストはすべて出力され
ます。‘eval-expression-debug-on-error’は、これらのコマンドが使用されると
き、評価エラーによりデバッガーを呼び出すかを制御します、デフォルトは
‘t’です。‘eval-expression-print-maximum-character’は、文字として表示され
る最大の整数を超える値を抑制します。


File: emacs-ja.info,  Node: Lisp Interaction,  Next: External Lisp,  Prev: Lisp Eval,  Up: Building

27.10 Lisp Interactionバッファー
================================

Emacsを開始したとき、‘*scratch*’という名前のバッファーが含まれます、これ
はEmacs Lisp式の対話的な評価を提供します。このバッファーのメジャーモード
は、Lisp Interactionモードです。‘M-x lisp-interaction-mode’とタイプして
も、Lisp Interactionモードを有効にできます。

   ‘*scratch*’バッファー、およびその他のLisp Interactionモードのバッファ
ーでは、‘C-j’ (‘eval-print-last-sexp’)はポイントの前のLisp式を評価して、
値をポイント位置に挿入します。したがってバッファーに式をタイプするたび、
その後ろで‘C-j’をタイプすることにより、そのバッファーは式の評価とその値
を記録した写しになります。その他すべてのLisp Interactionモードのコマンド
は、Emacs Lispモードと同じです。

   起動時には、‘*scratch*’バッファーは、それが何かを説明するLispコメント
形式の短いメッセージを含んでいます。このメッセージは変数
‘initial-scratch-message’により制御され、値にはドキュメント文字列または
‘nil’(メッセージを抑止するという意味)を指定します。

   Emacs Lisp式を対話的に評価する別の方法は、Inferior Emacs Lispモードを
使う方法です。これはEmacs Lisp式の評価にShellモード(*note Shell Mode::を
参照してください)に似たインターフェースを提供します。‘M-x ielm’とタイプ
することにより、このモードを使用する‘*ielm*’というバッファーが作成されま
す。詳細は、コマンドのドキュメントを参照してください。


File: emacs-ja.info,  Node: External Lisp,  Prev: Lisp Interaction,  Up: Building

27.11 外部Lispの実行
====================

Lispモードは、Common Lispのような一般用途のためのLisp方言で記述されたプ
ログラムを記述するためのメジャーモードです。これのモードコマンドは‘M-x
lisp-mode’です。Emacsは名前が‘.l’、‘.lsp’、‘.lisp’で終わるファイルにたい
して、自動的にLispモードを使用します。

   外部LispセッションをEmacsのサブプロセス、または“下位プロセス(inferior
process)”として実行して、式を評価するために渡すことができます。外部
Lispセッションを開始するには、‘M-x run-lisp’とタイプします。これは
‘lisp’という名前のプログラムを実行して、‘*inferior-lisp*’という名前の
Emacsバッファーを通じて入出力を行うようにセットアップします。‘M-x
run-lisp’で実行されるLispプログラムの名前を変更するには、変数
‘inferior-lisp-program’を変更してください。

   ‘*lisp*’バッファーのためのメジャーモードはInferior Lispモードで、これ
はLispモードの性質とShellモード(*note Shell Mode::を参照してください)の
性質をあわせ持っています。Lispセッションに入力を送るには、‘*lisp*’バッフ
ァーの最後に移動して、入力をタイプしてから<RET>をタイプします。Lispセッ
ションからの端末出力は、自動的にそのバッファーに挿入されます。

   LispプログラムをLispモードで編集する場合、‘C-M-x’
(‘lisp-eval-defun’)とタイプして、Lispモードのバッファーから、‘M-x
run-lisp’で開始したLispセッションに式を送ることができます。送信される式
はポイント位置、またはポイントの後ろのトップレベルのLisp式です。結果とな
る値は通常どおり、‘*inferior-lisp*’バッファーに送られます。Lispモードで
の‘C-M-x’の効果は、それが評価されるEmacsに送られるのではなく、異なる
Lisp環境に送られる点を除けば、Emacs Lispモード(*note Lisp Eval::を参照し
てください)での効果とよく似ていることに注意してください。

   Schemeコードを編集して、式をSchemeサブプロセスに送る機能は、よく似て
います。Schemeソースファイルは、Schemeモードで編集されます。このモードは
‘M-x scheme-mode’で明示的に有効にできます。‘M-x run-scheme’とタイプする
ことにより、Schemeセッションを開始し、‘C-M-x’とタイプして式の送ることが
できます(Schemeと対話するためのバッファーは、‘*scheme*’という名前です)。


File: emacs-ja.info,  Node: Maintaining,  Next: Abbrevs,  Prev: Building,  Up: Top

28 大きなプログラムの保守
*************************

このチャプターでは、中規模から大規模のプログラムやパッケージを保守するた
めのEmacsの機能を説明します。これらの機能には、以下が含まれます:

   − ソースファイルにたいする変更履歴を記録するバージョンコントロールシ
     ステム(VCS: Version Control Systems)にたいする、統一されたインター
     フェースのサポート。

   − プログラムの変更にたいして日時順のログを提供する、‘ChangeLog’の保守
     に特化したモード。

   − シンボル定義(“識別子(identifiers)”とも言います)を表示する一連のコマ
     ンドである、Xref。

   − Emacs自身のIDEである、EDE。

   − 開発の別ブランチで行なわれたプログラム変更をマージするためのモード
     。

   Lispの大きなプログラムをメンテナンスしている場合は、ここで説明してい
る機能に加え、ERT(Emacs Lisp Regression Testing)ライブラリーも便利だと思
うかもしれません(*note ERT: (ert)Top.を参照してください)。

* Menu:

* Version Control::          バージョンコントロールシステムの使用。
* Change Log::               プログラムの変更履歴をメンテナンスする。
* Xref::                     プログラム内の関数、メソッド、構造体、マクロ、...にたいする定義の検索と参照。
* EDE::                      Emacsのための統合開発環境。
* Emerge:: 2つのバージョンのプログラムをマージする便利な方法。


File: emacs-ja.info,  Node: Version Control,  Next: Change Log,  Up: Maintaining

28.1 バージョンコントロール
===========================

“バージョンコントロールシステム(version control system)”は、ソースファイ
ルの複数のバージョンを記録したり、それらのバージョンの作成日時などや、誰
が作成したか、何が変更されたかの説明などを記録できるプログラムのことです
。

   Emacsのバージョンコントロールのためのインターフェースは、“VC”と呼ばれ
ます。VCコマンドは、複数の異なるバージョンコントロールシステムで機能しま
す。現在のところ、Bazaar、CVS、Git、Mercurial、Monotone、RCS、SRC、
SCCS/CSSC、Subversionがサポートされます。これらの中で、GNUプロジェクトの
ディストリビューションはCVS、RCS、Bazaarです。

   バージョン管理システムで生成されたファイルをvisitすると、自動的にVCが
有効になります。VCを無効にするには、カスタマイズ可能な変数
‘vc-handled-backends’を‘nil’をセットします (*note Customizing VC::を参照
してください)。

   カレントバッファーでvisitされているファイルにたいするVC状態の情報を更
新するには、コマンド‘vc-refresh-state’を使用します。Emacsの外(たとえばシ
ェルプロンプト)でバージョンコントロールコマンドを実行したときや、そのバ
ッファーのファイルを別のバージョンコントロールシステム下に置いたとき、バ
ージョンコントロールからそのファイルを完全に削除したときに、このコマンド
は有用です。

* Menu:

* Introduction to VC::       バージョンコントロールが機能する一般的な方法。
* VC Mode Line::             モードラインがバージョンコントロールの状態を表示する方法。
* Basic VC Editing::         バージョンコントロール下のファイルの編集方法。
* Log Buffer::               logエントリーバッファーで利用可能な機能。
* Registering::              バージョンコントロール下にファイルを置く。
* Old Revisions::            古いバージョンの調査と比較。
* VC Change Log::            VC Change Logの閲覧。
* VC Undo::                  コミット前後の変更の取り消し。
* VC Ignore::                バージョンコントロール下のファイルの無視。
* VC Directory Mode::        バージョンコントロールで管理されたファイルの一覧。
* Branches::                 開発における複数行。
* Miscellaneous VC:: その他のVCのさまざまなコマンドと機能。
* Customizing VC:: VCの動作を変更する変数。


File: emacs-ja.info,  Node: Introduction to VC,  Next: VC Mode Line,  Up: Version Control

28.1.1 バージョンコントロールの紹介
-----------------------------------

VCは、Emacsからのバージョンコントロールシステムの使用、およびバージョン
コントロールの操作と編集をスムーズに統合します。VCは、多くのバージョンコ
ントロールシステムでの一般的な操作にたいする、統一されたインターフェース
を提供します。

   リポジトリー設定の変更など、非一般的または複雑なバージョンコントロー
ルの操作は、VCではサポートされません。そのようなタスクは、VCの外(たとえ
ばコマンドライン)で処理する必要があります。

   このセクションは、バージョンコントロールの一般的な概観を提供し、VCが
サポートするバージョンコントロールを説明します。すでに使いたいバージョン
コントロールシステムをよく知っている場合、このセクションはスキップできま
す。

* Menu:

* Why Version Control?::     問題が示すところを理解するには。
* Version Control Systems::  バックエンドシステムとしてサポートされるバージョンコントロール。
* VCS Concepts::             バージョンコントロールに関連する単語と概念。
* VCS Merging::              ファイルの衝突を処理する方法。
* VCS Changesets::           変更がグループ化される方法。
* VCS Repositories::         バージョンコントロールのリポジトリーが格納される場所。
* Types of Log File::        VCS logとChangeLogの違い。


File: emacs-ja.info,  Node: Why Version Control?,  Next: Version Control Systems,  Up: Introduction to VC

28.1.1.1 問題の背景を理解する
.............................

バージョンコントロールシステムは、3つの重要な能力を提供します。

   • “Reversibility(可逆性)”: ある変更が間違い、または間違えた考えにもと
     づくものだと気づいたときに、前の状態に戻す能力です。

   • “Concurrency(並列性)”: 多くの人が同じファイルコレクションを変更する
     とき、変更の衝突を検知して解決する能力です。

   • “History(履歴)”: それを変更した背後の意図を説明するコメントなど、履
     歴データをデータに付す能力です。1人で作業するプログラマーでさえ、変
     更履歴は記憶を助けるのに重要です。複数人のプロジェクトでは、開発者
     間のコミュニケーション形式として、とても重要です。


File: emacs-ja.info,  Node: Version Control Systems,  Next: VCS Concepts,  Prev: Why Version Control?,  Up: Introduction to VC

28.1.1.2 サポートされるバージョンコントロールシステム
.....................................................

VCは現在のところ、多くの異なるバージョンコントロールで機能し、それらを
“バックエンド(back ends)”として参照します:

   • SCCSは、これまでに構築された一番最初のバージョンコントロールシステ
     ムで、ずっと以前に、もっと進んだものに取って代わられました。SCCSに
     ない特定の機能のためのVCコンポーネントは、それら自身により実装され
     ています。複数ブランチなど、その他のVC機能は単に利用不可です。
     SCCSはフリーではないので、これを避けることを推奨します。

   • CSSCはSCCSのフリーな置き換えです。何らかの理由により、もっと新しい
     、より良いデザインのバージョンコントロールシステムを使うことができ
     ないときだけ、CSSCを使うべきです。

   • RCSは、VCが最初に構築された頃の、フリーなバージョンコントロールシス
     テムです。これは比較的に初期のものです。これはネットワークを超えて
     使うことはできず、ファイルに個別のレベルで機能します。RCSでできるほ
     とんどのことは、VCを通じて行うことができます。

   • CVSは、フリーなバージョンコントロールシステムであり、2008年y頃まで
     はフリーソフトウェアプロジェクトの大半で使われていました。それ以降
     は、新しいシステムに徐々に置き換えらました。CVSではローカルまたはネ
     ットワーク越しの、複数ユーザーによる並列開発が可能です。新しいシス
     テムとは異なり、アトミックなコミットとファイルの移動・リネームにた
     いするサポートがありません。VCはCVS下での基本的な編集操作をサポート
     します。

   • Subversion(svn)は、CVSと同じようにデザインされた、フリーなバージョ
     ンコントロールシステムですが、CVSのもつ問題はありません(たとえば、
     これはファイルセットのアトミックなコミット、ディレクトリーのバージ
     ョニング、シンボリックリンク、メタデータ、リネーム、コピー、削除を
     サポートします)。

   • Gitは、最初にLinus TorvaldsによりLinux(彼のkernel)の開発をサポート
     するために考案されました。VCは多くのGit操作をサポートしますが、その
     他のリポジトリーの同期などはコマンドラインを使わなければなりません
     。

   • Mercurial(hg)は、Gitに酷似した分散化されたバージョンコントロールシ
     ステムです。VCは、リポジトリーの同期操作を除いて、ほとんどの
     Mercurialコマンドをサポートします。

   • Bazaar(bzr)は、リポジトリーベースと分散化されたバージョニングの両方
     をサポートする、分散化されたバージョンコントロールシステムです。
     VCはBazaar下でのほとんどの基本的な編集操作をサポートします。

   • SRC (src)はRCSの再実装で、1人による単一ファイルのプロジェクトために
     特化してデザインされたバージョンコントロールシステムです。これは1つ
     のディレクトリーの中に、独立したバージョンコントロール履歴をもつ複
     数ファイルを許容します。したがって、これは小さなドキュメントやスク
     リプト、ドットファイルを保守するのに適しています。これはRCSのリビジ
     ョンストレージを使用するので、非lock操作(lockless operation)や、シ
     ーケンシャルな整数リビジョン番号をもつ、現代的なユーザーインターフ
     ェースを提供します。


File: emacs-ja.info,  Node: VCS Concepts,  Next: VCS Merging,  Prev: Version Control Systems,  Up: Introduction to VC

28.1.1.3 バージョンコントロールの概念
.....................................

ファイルがバージョンコントロールの配下にある時、それがバージョンコントロ
ールシステムに“登録されている(registered)”と言います。バージョンコントロ
ールシステムは、“リポジトリー(repository)”をもちます。これはファイルの現
在の状態、および古いバージョンから現在のバージョンを再構成するのに充分な
変更履歴の、両方を保存します。リポジトリーには、各ファイルに行われた変更
の説明である“ログエントリー(log entries)”など、その他の情報も含まれます
。

   実際に編集する、バージョンコントロールされたファイルのコピーのことを
、“作業ファイル(work file)”と呼びます。作業ファイルは、通常のファイルを
同じように変更できます。一連の変更を終えた後、その変更を“コミット
(commit)”または“チェックイン(check in)”します。これにより、その変更はロ
グエントリーの記述とともに、リポジトリーに記録されます。

   作業ファイルのディレクトリツリーを、“作業ツリー(working tree)”と呼び
ます。

   commitするたびに、リポジトリーに新しい“リビジョン(revision)”が作成さ
れます。バージョンコントロールシステムは、過去のすべてのリビジョンと、各
リビジョンで行われた変更を記録します。各リビジョンには、“リビジョン
ID(revision ID)”により名前がつけられます。リビジョンIDのフォーマットは、
バージョンコントロールシステムに依存します。もっとも簡単なケースでは、リ
ビジョンIDは単なる整数です。

   これらの基本的な概念を超えるにつれ、各バージョンコントロールシステム
の違いの、3つの様相を理解する必要がでてくるでしょう。以降の3つのセクショ
ンで説明するように、各バージョンコントロールシステムには、ロックベース
(lock-based)とマージベース(merge-based)、ファイルベース(file-based)と変
更セットベース(changeset-based)、集中型(centralized)と分散型
(decentralized)の違いがあります。VCはこれらすべてのモードの操作を処理し
ますが、それらの違いを隠蔽することはできません。


File: emacs-ja.info,  Node: VCS Merging,  Next: VCS Changesets,  Prev: VCS Concepts,  Up: Introduction to VC

28.1.1.4 バージョンコントロールにおけるマージベースとロックベース
.................................................................

バージョンコントロールシステムは通常、同じファイルを変更したい複数ユーザ
ーを調整するために、何らかのメカニズムをもちます。これを行うには2つの方
法 — マージとロック — があります。

   マージを使うバージョンコントロールシステムでは、各ユーザーはいつでも
作業ファイルを変更します。バージョンコントロールシステムは、コミットされ
ていない変更を含むユーザーの作業ファイルを、他のユーザーによりコミットさ
れた最新の変更とマージします。

   古いバージョンコントロールシステムは、かわりに“ロック(locking)”を使い
ます。この場合、作業ファイルは通常は読み取り専用です。ファイルを編集する
には、それを“ロック”することにより書き込み可能にできるか、バージョンコン
トロールシステムに尋ねます。ある時点で、そのファイルをロックできるユーザ
ーは1人だけです。この手順は、通常のファイルの同時編集をEmacsが検知する方
法と類似しているようですが、異なります(*note Interlocking::を参照してく
ださい)。変更をコミットすると、ファイルはアンロック(unlocks)され、作業フ
ァイルは再び読み取り専用になります。他のユーザーは、変更するためにそのフ
ァイルをロックすることができます。

   ロックおよびマージの両方のシステムは、複数ユーザーが同じときに同じフ
ァイルの変更を試みたときに問題が発生し得ます。ロックを使うシステムには、
“ロックの衝突(lock conflicts)”があります。あるユーザーはファイルのチェッ
クアウトを試みますが、それがすでにロックされている場合はロックできません
。マージを使うシステムには、“マージの衝突(merge conflicts)”があります。
これはファイルに行った変更をコミットするとき、それが後からチェックアウト
した他の誰かによる変更のコミットと衝突するときに発生します。どちらの衝突
も、人間の判断と意思疎通により解決する必要があります。経験から、開発者に
取っての利便性と、実際に発生する衝突の重大性と数を最小にするという両方の
点で、マージはロックに優ります。

   SCCSは常にロックを使います。RCSはデフォルトではロックベースですが、マ
ージスタイルで処理するように指示できます。CVSとSubversionはデフォルトで
はマージベースですが、ロックモードで処理するように指示できます。Git、
Mercurialのような分散型のバージョンコントロールシステムは、マージベース
だけです。

   VCはロックとマージの両方のバージョンコントロールをサポートします。
“commit(コミット)”と“update(更新)”という用語は、新しいバージョンコントロ
ールシステムで使用されます。古いロックベースのシステムでは、“check in(チ
ェックイン)”と“check out(チェックアウト)”という用語が使用されます。VCは
これらの違いをできる限り隠蔽します。


File: emacs-ja.info,  Node: VCS Changesets,  Next: VCS Repositories,  Prev: VCS Merging,  Up: Introduction to VC

28.1.1.5 バージョンコントロールに置ける変更セットベースとファイルベース
.......................................................................

SCCS、RCS、CVS、およびその他の初期のバージョンコントロールシステム(SRCも
含む)では、バージョンコントロールの操作は“ファイルベース(file-based)”で
す。各ファイルは、他のすべてのファイルとは別に、ファイル自身のコメントと
リビジョン履歴をもちます。Subversionで始まる新しいシステムは、“変更セッ
トベース(changeset-based)”です。コミットは複数ファイルにたいする変更を含
むときがあり、一連の変更全体を1つの単位として扱います。変更にたいするコ
メントは1つのファイルではなく、変更セットに属します。

   変更セットベースのバージョンコントロールは、ファイルベースのバージョ
ンコントロールより、柔軟で強力です。通常、複数ファイルの変更を元に戻す必
要がある時、それを簡単に識別してすべてを削除できます。


File: emacs-ja.info,  Node: VCS Repositories,  Next: Types of Log File,  Prev: VCS Changesets,  Up: Introduction to VC

28.1.1.6 リポジトリーにおける分散型と集中型
...........................................

初期のバージョンコントロールシステムは、“集中型(centralized)”モデルでデ
ザインされていて、各プロジェクトはすべての開発者が使用するただ1つのリポ
ジトリーをもちます。SCCS、RCS、CVS、Subversion、SRCはこの種のモデルを共
有します。このモデルの欠点の1つは、リポジトリーが信頼性と効率の要衝とな
ることです。

   GNU Archは、“分配型(distributed)”または“分散型(decentralized)”のバー
ジョンコントロールの先駆で、後にGit、Mercurial、Bazaarで実装されました。
プロジェクトは複数の異なるリポジトリーをもつことができ、これらのシステム
はリポジトリー間で変更履歴を調停する、ある種のスーパーマージをサポートし
ます。開発者ごとに1つのリポジトリーがあり、リポジトリーのマージがコミッ
ト操作を代行します。

   VCは個人の作業ファイルと、リポジトリーとの間で行われる通信を管理する
手助けをします。VCは、リポジトリーが唯一のマスターなのか、それともネット
ワークのピアーのリポジトリーの1つなのかは関知しません。


File: emacs-ja.info,  Node: Types of Log File,  Prev: VCS Repositories,  Up: Introduction to VC

28.1.1.7 ログファイルのタイプ
.............................

バージョンコントロールシステムを使うプロジェクトは、変更にたいする2つの
タイプのログをもつことができます。1つはバージョンコントロールシステムで
保守されるログです。変更をコミットするたびに、変更にたいする“ログエント
リー(log entry)”を入力します(*note Log Buffer::を参照してください)。これ
は“バージョンコントロールログ(version control log)”と呼ばれます。

   もう1つの種類のログは、‘ChangeLog’です(*note Change Log::を参照してく
ださい)。これはプログラムの大きな部分(通常は1つのディレクトリーと、その
サブディレクトリー)にたいする変更の記録を、年代順に記録します。小さなプ
ログラムは、1つの‘ChangeLog’を使用するでしょう。大きなプログラムは、主要
なディレクトリーごとに‘ChangeLog’をもつかもしれません。*note Change
Log::を参照してください。プログラマーは、バージョンコントロールシステム
のずっと前からChangeLogを使ってきました。

   変更セットベースのバージョンシステムは、通常システム全体にたいして変
更セットベースの修正ログを保守します。これはChangeLogを冗長なものにしま
す。ChangeLogを残す利点の1つは、他のディレクトリーとは別に、1つのディレ
クトリーの履歴トランザクションが見れるのは便利なときがあるからです。他の
利点として、多くのバージョンコントロールシステムはコミットログを特定でき
ないからです。

   バージョンコントロールで管理されるプロジェクトは、バージョンコントロ
ールログだけを使用するか、両方の種類のログを使用します。あるファイルにた
いしては1つのログを使い、他のファイルにたいしては別の方法を使うこともで
きます。プロジェクトごとに、したがうべきポリシーがあります。

   両方を使うというポリシーの場合は通常、変更にたいして1度だけエントリー
を書いて、それを両方のログに書き込みたいと思うでしょう。‘ChangeLog’にエ
ントリーを記述して、変更をコミットするとき‘C-c C-a’でログバッファーにコ
ピーできます。または変更をコミットするときログバッファーにエントリーを記
述して、後で‘C-x v a’コマンドでそれを‘ChangeLog’にコピーできます (*note
Change Logs and VC::を参照してください)。


File: emacs-ja.info,  Node: VC Mode Line,  Next: Basic VC Editing,  Prev: Introduction to VC,  Up: Version Control

28.1.2 バージョンコントロールとモードライン
-------------------------------------------

バージョンコントロール配下のファイルをvisitしたとき、Emacsはモードライン
にそれを示します。たとえば‘Bzr-1223’と表示された場合、そのファイルに
Bazaarが使用され、カレントのリビジョンIDが1223であることを示します。

   バックエンド名とリビジョンIDの間の文字は、作業ファイルの“バージョンコ
ントロール状態(version control status)”を示します。マージベースのバージ
ョンコントロールシステムでは、文字‘-’は作業ファイルが変更されていないこ
とを示し、文字‘:’は作業ファイルが変更されていることを示します。文字‘!’は
最新のマージ処理の結果により、そのファイルに衝突が含まれていることを示す
か(*note Merging::を参照してください)、そのファイルがバージョンコントロ
ールから削除されたことを示します。最後に、文字‘?’は、そのファイルがバー
ジョンコントロールの配下にあるが、作業ツリーにないことを示します。

   ロックベースのシステムでは、‘-’はファイルがロックされていないことを示
し、‘:’はファイルが他のユーザー(たとえば‘jim’)にロックされていることを示
し、‘RCS:jim:1.3’のように表示されます。‘@’は、そのファイルがローカルに追
加されたが、まだマスターリポジトリーにコミットされていないことを示します
。

   グラフィカルなディスプレーでは、モードラインのインジケーターの上にマ
ウスを移動すると、ツールチップが表示され、それにはバージョンコントロール
状態の、より多くの説明が表示されます。インジケーターを‘mouse-1’でクリッ
クすると、メニューバーの‘Tools / Version Control’と同じVCコマンドがのメ
ニューがポップアップします。

   Auto Revertモード(*note Reverting::を参照してください)がバージョンコ
ントロール配下のバッファーをリバートするとき、これはモードラインのバージ
ョンコントロール情報を更新します。しかし、Auto Revertモードは、作業ファ
イルの変更をともなわない、カレントのEmacsセッションの外でのバージョンコ
ントロール状態の変化の情報は、正しく更新しないかもしれません。
‘auto-revert-check-vc-info’を‘t’にセットすると、Auto Revertモードは、作
業ファイル自身を変更していなくても、‘auto-revert-interval’秒ごとにバージ
ョンコントロール状態の情報を更新します。CPU使用率はバージョンコントロー
ルシステムに依存しますが、通常はそれほど高価な処理ではありません。


File: emacs-ja.info,  Node: Basic VC Editing,  Next: Log Buffer,  Prev: VC Mode Line,  Up: Version Control

28.1.3 バージョンコントロール下での基本的な編集
-----------------------------------------------

ほとんどのVCコマンドは、“VCファイルセット(VC filesets)”にたいして処理を
行います。VCファイルセットは、VC操作が機能する1つ以上のファイルのコレク
ションです。バージョンコントロールされたファイルをvisitしているバッファ
ーでVCコマンドをタイプすると、VCファイルセットは単にそのファイル1つだけ
になります。VC Directoryバッファーで、いくつかのファイルをマークしている
ときにVCコマンドをタイプしたときは、VCファイルセットはマークされたファイ
ルです(*note VC Directory Mode::を参照してください)。

   現代的な変更セットベースのバージョンコントロールシステム(*note VCS
Changesets::を参照してください)では、VCコマンドは複数ファイルからなる
VCファイルセットを1つのグループとして扱います。たとえば複数ファイルから
なるVCファイルセットをコミットすると、それらすべてのファイルにたいする変
更を含む、1つのリビジョンが生成されます。CVSのような古いファイルベースの
バージョンコントロールシステムでは、複数ファイルからなるVCファイルセット
の各ファイルは個別に処理されます。たとえば、コミットにより、変更されたフ
ァイル後とに1つのリビジョンが生成されます。

‘C-x v v’
     カレントVCファイルセットにたいして、次の適切なバージョンコントロー
     ル操作を処理します。

   重要なVCコマンド‘C-x v v’ (‘vc-next-action’)は多目的なもので、カレン
トのVCファイルセットにたいして、もっとも適切な操作を処理します。このコマ
ンドは、それをバージョンコントロールシステムに登録するか、コミットするか
、ロックを外すか、変更をマージします。正確な動作の詳細は、以下のサブセク
ションで説明します。‘C-x v v’は、ファイルをvisitしているバッファーと、VC
Directoryバッファーの両方で使うことができます。

   VCファイルセットは、ファイルを閲覧したりvisitするためのグループ機能と
して使用される、名前つきファイルセット(named filesets)とは別の物だという
ことに注意してください(*note Filesets::を参照してください)。名前つきファ
イルセットとは異なり、VCファイルセットは名前をもたず、セッションをまたい
で持続しません。

* Menu:

* VC With A Merging VCS::    ロックしない:
                               CVSのデフォルトモード。
* VC With A Locking VCS::    RCSのデフォルトモード、SCCS、オプションでCVS。
* Advanced C-x v v::         プレフィクス引数で利用可能な上級機能。


File: emacs-ja.info,  Node: VC With A Merging VCS,  Next: VC With A Locking VCS,  Up: Basic VC Editing

28.1.3.1 マージでの基本的なバージョンコントロール
.................................................

マージベースのバージョンコントロールシステム(たとえばもっとも現代的な方
法の1つ。*note VCS Merging::を参照してください)では、‘C-x v v’は以下のこ
とを行います:

   • VCファイルセットに1つ以上のファイルがあり、そのファイルがバージョン
     コントロール状態と矛盾する場合、エラーをシグナルします(しかしファイ
     ルセットには、新しく追加されたファイルと、変更されたファイルを含む
     ことができることに注意してください。*note Registering::を参照してく
     ださい)。

   • VCファイルセットに、バージョンコントロールシステムに登録されたファ
     イルがない場合、VCファイルセットを登録(たとえばバージョンコントロー
     ルの配下に置く)します。*note Registering::を参照してください。
     Emacsが登録すべきシステムを見つけられない場合、リポジトリータイプの
     入力を求め、新しいリポジトリーを作成して、VCファイルセットをそれに
     登録します。

   • VCファイルセットの、すべての作業ファイルが変更されていない場合は、
     何もしません。

   • VCファイルセットの各作業ファイルが変更されている場合、変更をコミッ
     トします。これを行うには、Emacsが‘*vc-log*’バッファーをポップアップ
     するので、新しいリビジョンのログエントリーをタイプしてから、‘C-c
     C-c’でコミットします。*note Log Buffer::を参照してください。

     共有リポジトリーにコミットする場合、最後に更新したときからリポジト
     リーが変更されているときは、コミットが失敗するでしょう。このような
     場合、再試行する前に更新をしなければなりません。分散型のバージョン
     コントロールシステムでは、‘C-x v +’(*note Pulling / Pushing::を参照
     してください)、またh‘C-x v m’を使用します(*note Merging::を参照して
     ください)。集中型のバージョンコントロールシステムでは、リポジトリー
     に変更をマージするために、再度‘C-x v v’とタイプしてください。

   • 最後に、集中型のバージョンコントロールシステムでは、VCファイルセッ
     トの各ファイルが最新かチェックします。リポジトリーで変更されたファ
     イルがある場合、更新を提案します。

   これらのルールは、変更はリポジトリーから自動的にマージされない点をの
ぞき、RCSを非ロックモードで使用している場合も適用されます。あなたがファ
イルの編集を始めた後に、他のユーザーが同じファイルをコミットした場合、何
の情報も与えられません。あなたのリビジョンをコミットしたとき、他のユーザ
ーの変更は失われます(しかし、それはリポジトリーには残るので、決定的に失
われるわけではありません)。したがって、変更をコミットする前に、カレント
リビジョンが変更されていないことを調べなければなりません。それに加えて、
このモードでもRCSでロックすることが可能です。変更されていないファイルで
の‘C-x v v’は、RCSの通常のロックモードのようにそのファイルをロックします
。(*note VC With A Locking VCS::を参照してください)。


File: emacs-ja.info,  Node: VC With A Locking VCS,  Next: Advanced C-x v v,  Prev: VC With A Merging VCS,  Up: Basic VC Editing

28.1.3.2 ロックでの基本的なバージョンコントロール
.................................................

ロックベースのバージョンコントロールシステム(SCCSやRCSのデフォルトモード
など)では、‘C-x v v’は以下のことを行います:

   • VCファイルセットに1つ以上のファイルがあり、そのファイルがバージョン
     コントロール状態と矛盾する場合、エラーをシグナルします。

   • VCファイルセットに、バージョンコントロールシステムに登録されたファ
     イルがない場合、VCファイルセットを登録します。*note Registering::を
     参照してください。Emacsが登録すべきシステムを見つけられない場合、リ
     ポジトリータイプの入力を求め、新しいリポジトリーを作成して、VCファ
     イルセットをそれに登録します。

   • 各ファイルが登録されていてロックされていなければ、それを書き込み可
     能にするためにロックして、編集を開始できるようにします。

   • 各ファイルのロックを獲得していて、それらが変更を含む場合、その変更
     をコミットします。これを行うことにより、Emacsは‘*vc-log*’バッファー
     をポップアップするので、新しいリビジョンのログエントリーをタイプし
     てから、C-c C-cでコミットします(*note Log Buffer::を参照してくださ
     い)。

   • 各ファイルのロックをすでに獲得していて、変更がない場合、ファイルを
     再び読み取り専用にするために、ロックを開放します。

   • 各ファイルが他のユーザーによりロックされている場合、ロックを横取り
     する(steal the lock)か、確認を求めます。これにyesと応えると、あなた
     がロックを獲得して、その前にファイルをロックしていたユーザーに、警
     告メッセージが送られます。

   このルールは、CVSがロックの横取りをサポートしない点をのぞき、CVSをロ
ックモードで使用している場合も適用されます。


File: emacs-ja.info,  Node: Advanced C-x v v,  Prev: VC With A Locking VCS,  Up: Basic VC Editing

28.1.3.3 ‘C-x v v’の高度な制御
..............................

‘vc-next-action’にプレフィクス引数を与えた場合(‘C-u C-x v v’)、論理的に
次のバージョンコントロール操作を処理する点に変わりはありませんが、どのよ
うに操作を行うかを正確に指定するために、追加の引数を指定できるようになり
ます。

   • バージョンコントロールシステムの名前を指定できます。これは、ファイ
     ルセットが複数のバージョンコントロールシステムで管理されていて、
     Emacsが正しいものを検知するのに失敗するとき便利です。

   • そうでない場合で、CVS、RCS、SRCを使用しているときは、リビジョンIDを
     指定できます。

     ファイルセットが変更(またはロック)されている場合、Emacsは指定したリ
     ビジョンIDでそれをコミットします。適切なリビジョンIDを与えることに
     より、新しいブランチを作成できます(*note Branches::を参照してくださ
     い)。

     ファイルセットが変更(またはロック)されていない場合、これは指定した
     リビジョンを作業ツリーにチェックインします。リビジョンIDまたはブラ
     ンチIDを与えることにより、他のブランチのリビジョンを指定できます
     (*note Switching Branches::を参照してください)。空の引数(例: ‘C-u
     C-x v v <RET>’)は、カレントブランチの最新のリビジョン(head)をチェッ
     クアウトします。

     これは、分散型のバージョンコントロールシステムでは単に無視されます
     。これらのシステムでは、独自のリビジョンIDは指定できず、個別のファ
     イルを“チェックアウト”するという概念も使いません。


File: emacs-ja.info,  Node: Log Buffer,  Next: Registering,  Prev: Basic VC Editing,  Up: Version Control

28.1.4 Log Entryバッファーの機能
--------------------------------

VCに変更のコミットを指示したとき、‘*vc-log*’という名前のバッファーがポッ
プアップします。このバッファーには、行った変更を説明する“ログエントリー
(log entry)”を書き込みます。書き込んだら‘C-c C-c’ (‘log-edit-done’)とタ
イプして, そのバッファーを抜けて、ログエントリーとともに変更をコミットし
ます。

   ‘*vc-log*’バッファーのためのメジャーモードはLog Editモードで、これは
Textモードの変種です(*note Text Mode::を参照してください)。Log Editモー
ドに入ると、Emacsはフック‘text-mode-hook’および‘vc-log-mode-hook’を実行
します(*note Hooks::を参照してください)。

   ‘*vc-log*’バッファーでは、１行以上の“ヘッダー行(header lines)”を記入
できます。これにはバージョンコントロールシステムにより提供される、追加の
情報を指定します。各ヘッダー行は、そのバッファーの最初の1行を占めなけれ
ばなりません。ヘッダー行でない最初の行は、ログエントリーの開始として扱わ
れます。たとえば以下のヘッダー行は、その変更が他の開発者によるものだとい
うことを示します:

     Author: J. R. Hacker <jrh@example.com>

‘Author’ヘッダーとは別に、Emacsは‘Summary’ヘッダー(changesetの1行要約)、
‘Date’ヘッダー(手入力で指定されたコミット日時)、‘Fixes’ヘッダー(変更によ
るバグフィクスへの参照)を認識します。すべてのバージョンコントロールシス
テムが、すべてのヘッダーを認識するわけではありません。そのシステムでサポ
ートされていないヘッダーを指定した場合、それはログエントリーの一部として
扱われます。

   ‘*vc-log*’バッファーにいる間は、カレントVCファイルセット(current VC
fileset)とは、‘C-c C-c’とタイプすることによりコミットされるファイルセッ
トだと考えられます。そのVCファイルセットのファイル一覧を閲覧するには、
‘C-c C-f’ (‘log-edit-show-files’)とタイプします。そのVCファイルセットと
、編集を開始したバージョンとのdiffを閲覧するには、‘C-c C-d’
(‘log-edit-show-diff’)とタイプしてください。

   VCファイルセットが1つ以上の‘ChangeLog’(*note Change Log::を参照してく
ださい)ファイルを含む場合、‘C-c C-a’ (‘log-edit-insert-changelog’)とタイ
プすると、関連するエントリーを、‘*vc-log*’バッファーに引用します。各
‘ChangeLog’ファイルの一番上のアイテムが、今日の日付でユーザー名があなた
の場合、このコマンドはコミットされるファイルにマッチするエントリーのアイ
テムを検索して、それを挿入します。 CVSまたはRCSを使用している場合は、反
対のこと — Log EditバッファーからChangeLogエントリーを生成 — を行います
。*note Change Logs and VC::を参照してください。

   コミットを中止するには、そのバッファーで単に‘C-c C-c’を_タイプしない
_で、バッファーを切り替えて他の編集を行うことができます。他のコミットを
試みなければ、編集していたエントリーは‘*vc-log*’に残っているので、後でそ
のバッファーに戻ってコミットを完了できます。

   コミットコメントをコピーするために、以前のログエントリーの履歴を閲覧
することもできます。これは、似たようなコメントで複数のコミットを行いたい
とき便利です。これを行うコマンド‘M-n’、‘M-p’、‘M-s’、‘M-r’は、これらがミ
ニバッファーの外で使用される点を除けば、ミニバッファーのヒストリーコマン
ド(*note Minibuffer History::を参照してください)と同様です。


File: emacs-ja.info,  Node: Registering,  Next: Old Revisions,  Prev: Log Buffer,  Up: Version Control

28.1.5 バージョンコントロールへのファイルの登録
-----------------------------------------------

‘C-x v i’
     visitしているファイルを、バージョンコントロールに登録します。

   コマンド‘C-x v i’ (‘vc-register’)は、カレントVCファイルセットの各ファ
イルを、バージョンコントロールの配下に置きます。これは登録されていない
VCファイルセットにたいして、‘C-x v v’が行う動作と基本的に同じですが、
VCファイルセットがすでに登録されているとき(*note Basic VC Editing::を参
照してください)、‘C-x v v’は他の操作を処理しますが、‘C-x v i’はエラーを
シグナルする、という点が異なります。

   ファイルを登録するために、Emacsはバージョンコントロールシステムを選択
しなければなりません。複数ファイルのVCファイルセットにたいしては、VC
Directoryバッファーが使用するシステムを指定します(*note VC Directory
Mode::を参照してください)。VCファイルセットのファイルが1つで、そのファイ
ルのディレクトリーがすでにバージョンコントロールシステムに登録されたファ
イルを含むか、そのディレクトリーがバージョンコントロールシステムにより制
御される作業ツリーの一部の場合、Emacsはそのシステムを選択します。複数の
バージョンコントロールシステムが当てはまる場合、Emacsは変数
‘vc-handled-backends’に最初に表れるシステムを使用します(*note
Customizing VC::)。 Emacsがファイルを登録するバージョンコントロールシス
テムを見つけられなかった場合、リポジトリータイプの入力を求め、新しいリポ
ジトリーを作成して、そのリポジトリーにファイルを登録します。

   ほとんどのバージョンコントロールシステムでは、‘C-x v i’または‘C-x v
v’でファイルを登録することにより、それを作業ツリー(working tree)に追加し
ますが、リポジトリーには追加しません。そのようなファイルは、VC
Directoryバッファーでは‘added’とラベル付けされ、モードラインのリビジョン
IDには‘@@’が表示されます。リポジトリーにたいして登録を有効にするには、コ
ミットを行わなければなりません(*note Basic VC Editing::を参照してくださ
い)。1つのコミットに、ファイルの追加と、既存ファイルの編集の両方を含むこ
とができるのに注意してください。

   ロックベースのバージョンコントロールシステム(*note VCS Merging::を参
照してください)では、ファイルの登録により、ファイルはロックされていない
読み取り専用の状態に留まります。編集を開始するには、‘C-x v v’とタイプし
ます。


File: emacs-ja.info,  Node: Old Revisions,  Next: VC Change Log,  Prev: Registering,  Up: Version Control

28.1.6 古いリビジョンの調査と比較
---------------------------------

‘C-x v =’
     カレントVCファイルセットの作業ファイルと、編集を開始したバージョン
     を比較します(‘vc-diff’)。プレフィクス引数を指定した場合、カレント
     VCファイルセットの2つのリビジョンの入力を求め、それらを比較します。
     このコマンドをDiredバッファーから呼び出すこともできます(*note
     Dired::を参照してください)。

‘M-x vc-ediff’
     ‘C-x v =’と同様ですが、Ediffを使用します。*note Ediff: (ediff)Top.を
     参照してください。

‘C-x v D’
     編集を開始したリビジョンの、作業ツリー全体を比較します
     (‘vc-root-diff’)。プレフィクス引数を指定した場合、2つのリビジョンの
     入力を求め、それらのツリーを比較します。

‘C-x v ~’
     カレントファイルのリビジョンの入力を求め、それを別のバッファーで
     visitします(‘vc-revision-other-window’)。

‘C-x v g’
     カレントファイルの、注釈付きのバージョンを表示します。各行には、そ
     の行が変更された最新のリビジョンが表示されます(‘vc-annotate’)。

   ‘C-x v =’ (‘vc-diff’)は、“diff”を表示します。これはカレントVCファイル
セットの各作業ファイルを、編集を開始したときのバージョンと比較します。
diffは別のウィンドウに、‘*vc-diff*’という名前のDiff modeモードのバッファ
ー(*note Diff Mode::を参照してください)で表示されます。このバッファーで
は、通常のDiffモードコマンドが利用可能です。特に‘g’ (‘revert-buffer’)コ
マンドは、ファイル比較を再び行い、新しいdiffを生成します。

   カレントVCファイルセットの、任意の2つのリビジョンを比較するには、‘C-u
C-x v =’のようにプレフィクス引数を指定して、‘vc-diff’を呼び出します。こ
れは2つのリビジョンID(*note VCS Concepts::を参照してください)の入力を求
め、ファイルセットのそれらのバージョンの間のdiffを表示します。このコマン
ドは、バージョンコントロールシステムが変更セットベースではなくファイルベ
ースの場合(たとえばCVS)に、複数ファイルのVCファイルセットにたいして確実
に動作しません。なぜなら同じリビジョンIDをもつ異なるファイル同士を、意味
のある方法で関連させることができないからです。

   リビジョンIDではなく、他のフォーマットでリビジョンを指定するバージョ
ンコントロールシステムもいくつかあります。たとえばBazaarでは、‘C-u C-x v
=’(および関連するコマンド)に‘date:yesterday’と入力でき、これは昨日以降コ
ミットされた最初のリビジョンを指定します。詳細については、バージョンコン
トロールシステムのドキュメントを参照してください。

   Diredバッファー(*note Dired::を参照してください)で‘C-x v =’または‘C-u
C-x v =’を呼び出すと、カレント行にリストされたファイルが、カレントVCファ
イルセットとして扱われます。

   ‘M-x vc-ediff’は、‘C-x v =’と同じように機能しますが、Ediffセッション
を使用します。*note Ediff: (ediff)Top.を参照してください。

   ‘C-x v D’ (‘vc-root-diff’)は、‘C-x v =’と似ていますが、カレント作業ツ
リー全体の変更を表示します(たとえばカレントVCファイルセットを含む作業ツ
リー)。このコマンドをDiredバッファーから呼び出すと、そのディレクトリーを
含む作業ツリーに適用されます。

   ‘C-x v =’および‘C-x v D’が、diffを生成するために使用する‘diff’オプシ
ョンをカスタマイズできます。オプションには、変数
‘vc-BACKEND-diff-switches’、‘vc-diff-switches’、‘diff-switches’(*note
Comparing Files::)の順に、最初の非‘nil’の値が使用されます。ここで
BACKENDは、関連するバージョンコントロールシステムで、たとえばBazaarの場
合は‘bzr’です。‘nil’は順番に次の変数をチェックすることを意味するので、ス
イッチを指定しない場合は最初の2つの値を‘t’にします。ほとんどの
‘vc-BACKEND-diff-switches’変数のデフォルトは‘nil’ですが、いくつかの
backendのデフォルトは‘t’です。Subversionのように、これらのバージョンコン
トロールシステムの‘diff’実装は、一般的なdiffオプションを受け付けません。

   ファイルの古いバージョンを直接調べるには、作業ファイルをvisitして、
‘C-x v ~ REVISION <RET>’ (‘vc-revision-other-window’)とタイプします。こ
れはREVISIONに対応するバージョンのファイルを取得して、それを
‘FILENAME.~REVISION~’に保存してから、別のウィンドウでvisitします。

   多くのバージョンコントロールシステムでは、‘C-x v g’ (‘vc-annotate’)と
タイプして、行ごとにリビジョン情報の“注釈付き(annotated)”でファイルを閲
覧できます。これは新しい“annotate”バッファーを作成して、各行に古さを示す
カラーをつけて、ファイルのテキストを表示します。赤いテキストは新しく、古
いものは青、その中間色は中間のバージョンを示します。デフォルトでは、一番
古い変更を青、一番新しい変更を赤で、すべてのバージョンレンジにカラーをス
ケーリングします。変数‘vc-annotate-background-mode’が非‘nil’の場合、各行
の世代を表すカラーはバックグラウンドカラーに適用され、フォアグラウンドカ
ラーはデフォルトのカラーのままです。

   このコマンドにプレフィクス引数を指定した場合、Emacsはミニバッファーを
使って、表示および注釈つけする(カレントファイル内容のかわりの)リビジョン
と、カラーレンジがカバーすべきタイムスパンの、2つの引数を読み取ります。

   “annotate”バッファーでは、‘VC-Annotate’メニューから、これら、または他
のカラースケールオプションが利用可能です。このバッファーでは、過去のリビ
ジョンの注釈の表示、diffの閲覧、ログエントリーの閲覧を行うために、以下の
キーを使うこともできます:

‘p’
     前のリビジョン(たとえば現在の注釈付きのリビジョンの1つ前のリビジョ
     ン)に注釈を付けます。数引数は繰り返し回数となるので、‘C-u 10 p’は
     10個前のリビジョンに注釈を付けます。

‘n’
     次のリビジョン(たとえば現在の注釈付きのリビジョンの1つ後のリビジョ
     ン)に注釈を付けます。数引数は繰り返し回数です。

‘j’
     カレント行に示されたリビジョンに解釈を付けます。

‘a’
     カレント行に示されたリビジョンの、1つ前のリビジョンに注釈を付けます
     。これはカレント行が変更される前の状態のファイルを見るとき便利です
     。

‘f’
     カレント行に示されたリビジョンのファイルを、バッファーに表示します
     。

‘d’
     カレント行のリビジョンと、その前のリビジョンの間のdiffを表示します
     。これはカレント行のリビジョンが実際にどのように変更されたか、ファ
     イルを見るとき便利です。

‘D’
     カレント行のリビジョンと、その前のリビジョンの間で、(変更セットをサ
     ポートするバージョンコントロールシステムの)変更セットのすべてのファ
     イルのdiffを表示します。これはカレント行のリビジョンが、実際にどの
     ように変更されたかツリー内を見るとき便利です。

‘l’
     カレント行のリビジョンのログを表示します。これはカレント行のリビジ
     ョンの変更にたいする執筆者(author)の説明を見るのに便利です。

‘w’
     作業中のリビジョン(編集中のもの)に注釈を付けます。‘p’や‘n’を使って
     他のリビジョンを表示している場合、このキーで作業中のリビジョンに戻
     ることができます。

‘v’
     注釈の表示・非表示を切り替えます。これは邪魔になる注釈抜きでファイ
     ル内容だけを見たいとき便利です。


File: emacs-ja.info,  Node: VC Change Log,  Next: VC Undo,  Prev: Old Revisions,  Up: Version Control

28.1.7 VC Change Log
--------------------

‘C-x v l’
     カレントファイルセットの変更履歴を表示します(‘vc-print-log’)。

‘C-x v L’
     カレントリポジトリーの変更履歴を表示します(‘vc-print-root-log’)。

‘C-x v I’
     pull操作が取り込む変更を表示します(‘vc-log-incoming’)。

‘C-x v O’
     push操作が送信する変更を表示します(‘vc-log-outgoing’)。

   ‘C-x v l’ (‘vc-print-log’)は、‘*vc-change-log*’という名前のバッファー
を表示して、誰が変更したのか、その日時、各変更のログエントリー(これらは
‘*vc-log*’バッファーを通じて入力したログエントリーと同じです。*note Log
Buffer::を参照してください)を含む、カレントファイルに行われた変更の履歴
を表示します。現在visitしているファイルのリビジョンに、ポイントが配され
ます。プレフィクス引数を指定した場合、このコマンドはポイントが配されるリ
ビジョンと、表示するリビジョンの最大数の入力を求めます。

   VC Directoryバッファー(*note VC Directory Mode::を参照してください)、
またはDiredバッファー(*note Dired::を参照してください)から‘C-x v l’を呼
び出した場合、カレント行にリストされたファイルにたいして適用されます。

   ‘C-x v L’ (‘vc-print-root-log’)は、‘*vc-change-log*’バッファーを表示
して、バージョンコントロールされたディレクトリーツリー全体を表示します
(RCS、SCCS、CVS、SRCはこの機能をサポートしない)。このコマンドはプレフィ
クス引数を指定した場合、表示するリビジョンの最大数の入力を求めます。

   ‘C-x v L’では履歴は簡略化された形式で表示され、通常は各ログエントリー
の最初の行だけが表示されます。しかし‘*vc-change-log*’バッファーで<RET>
(‘log-view-toggle-entry-display’)とタイプすると、ポイント位置のリビジョ
ンのログエントリー全体を表示します。2回目の<RET>で、再びそれを隠します。

   分散型のバージョンコントロールシステムでは、‘C-x v I’
(‘vc-log-incoming’)コマンドは、次回にバージョンコントロールのpullコマン
ドを実行するときに、他のリポジトリーから受け取る新しいリビジョンにより適
用される変更を、ログバッファーに表示します(*note Pulling / Pushing::を参
照してください)。ここで他のリポジトリーとは、バージョンコントロールシス
テムで定義される、変更がpullされるリポジトリーのことです。プレフィクス引
数を指定すると、‘vc-log-incoming’は特定のリポジトリーの入力を求めます。
同様に、‘C-x v O’ (‘vc-log-outgoing’)は、次回にpushコマンドを実行すると
きに、他のリポジトリーに送る変更を表示します。プレフィクス引数を指定する
と、特定の送信先リポジトリーの入力を求めます。

   ‘*vc-change-log*’バッファーでは、リビジョンのログまたはファイル間の移
動や、過去のリビジョン(*note Old Revisions::を参照してください)を調べた
り比較するために、以下のキーを使うことができます:

‘p’
     前のリビジョンエントリーに移動します(logバッファーのリビジョンエン
     トリーは通常、日時の降順になっているので、前のリビジョンアイテムは
     通常、もっと新しいリビジョンに対応します)。数引数は繰り返し回数です
     。

‘n’
     次のリビジョンエントリーに移動します。数引数は繰り返し回数です。

‘P’
     複数ファイルのVCファイルセットのログを表示している場合は、前のファ
     イルのログに移動します。そうでない場合は、単にログの先頭に移動しま
     す。数引数は繰り返し回数です。

‘N’
     複数ファイルのVCファイルセットのログを表示している場合は、次のファ
     イルのログに移動します。数引数は繰り返し回数です。

‘a’
     カレント行のリビジョンに注釈を付けます(*note Old Revisions::を参照
     してください)。

‘e’
     ポイント位置に表示された変更コメントを修正します。すべてのバージョ
     ンコントロールシステムが、変更コメントの修正をサポートするわけでは
     ないことに注意してください。

‘f’
     カレント行に示されたリビジョンをvisitします。

‘d’
     ポイント位置のリビジョンと、次に古いリビジョンとの間で、特定のファ
     イルにたいするdiffを表示します。

‘D’
     ポイント位置のリビジョンと、次に古いリビジョンとの間で、変更セット
     のdiffを表示します。これは、そのリビジョンですべてのファイルにたい
     して行われた変更を表示します。

‘<RET>’
     簡略形式のlogバッファー(たとえば‘C-x v L’で作成されたバッファー)で
     、ポイント位置のログエントリーにたいして、完全なログエントリーの表
     示・非表示を切り替えます。

   多くのログエントリーを取得するには時間がかかるので、
‘*vc-change-log*’バッファーは、デフォルトで2000を超えるリビジョンは表示
しません。変数‘vc-log-show-limit’はこの制限を指定します。この値を0にセッ
トすると、制限が削除されます。既存の‘*vc-change-log*’で、バッファーの最
後のボタン‘Show 2X entries’または‘Show unlimited entries’をクリックして
、表示するリビジョン数を増やすこともできます。しかしRCS、SCCS、CVS、
SRCはこの機能をサポートしません。

   変更を確認する有用な変種は、コマンド‘vc-region-history’ (デフォルトで
は‘C-x v h’にバインド)により提供され、これはカレントファイルのポイントと
マーク(*note Mark::を参照してください)の間にあるリージョンの変更履歴を、
‘*VC-history*’バッファーに表示します。変更履歴にはコミットログメッセージ
(commit log messages)と、その変更自体のDiff形式も含まれます。

   カレントファイルの興味がある変更にたいしてリージョンをマークした後に
、このコマンドを呼び出します。このコマンドがポップアップする
‘*VC-history*’バッファーでは、上述した‘*vc-change-log*’バッファーで利用
可能なコマンドすべてと、Diffモード(*note Diff Mode::を参照してください
)で定義されたコマンドも使用できます。

   このコマンドは現在のところGitだけで利用可能です。


File: emacs-ja.info,  Node: VC Undo,  Next: VC Ignore,  Prev: VC Change Log,  Up: Version Control

28.1.8 バージョンコントロール操作のアンドゥ
-------------------------------------------

‘C-x v u’
     カレントVCファイルセットの作業ファイルを、最後のリビジョンにリバー
     トします(‘vc-revert’)。

   カレントVCファイルセットにたいするすべての変更を破棄したい場合、‘C-x
v u’ (‘vc-revert’)とタイプします。これは作業ファイルと、編集を開始したと
きのリビジョンのdiffを表示して、変更を破棄するか確認を求めます。これに同
意するとファイルセットはリバートされます。‘C-x v u’でdiffを表示させたく
ない場合は、変数‘vc-revert-show-diff’に‘nil’をセットします(この設定をし
ても‘C-x v =’で直接diffを表示できます。*note Old Revisions::を参照してく
ださい)。‘C-x v u’は通常のアンドゥコマンドでは戻せないので、注意して使用
してください(*note Undo::を参照してください)。

   ロックベースのバージョンコントロールシステムでは、‘C-x v u’はファイル
をロックしないまま残します。編集を再開するには、再度ロックしなければなり
ません。ファイルをロックしてから、やはりそれを変更しないと決めたときも、
‘C-x v u’でファイルのロックを開放できます。


File: emacs-ja.info,  Node: VC Ignore,  Next: VC Directory Mode,  Prev: VC Undo,  Up: Version Control

28.1.9 バージョンコントロールファイルを無視する
-----------------------------------------------

‘C-x v G’
     カレントのバージョンコントロールシステム配下のファイルを無視します
     (‘vc-ignore’)。

   ソースツリーの多くは、エディターのバックアップや、オブジェクトファイ
ル、バイトコードファイル、ビルドされるプログラムなどの、バージョン管理す
る必要のないファイルを含みます。これらは単に追加しないだけでも構いません
が、常に不明なファイルとして現れるでしょう。ツリーのトップの、無視するフ
ァイルのリストにこれらのファイルを追加して、それらを無視するようにバージ
ョンコントロールシステムに指示することもできます。これを行うには‘C-x v
G’ (‘vc-ignore’)が助けとなるでしょう。プレフィクス引数を指定すると、無視
するファイルリストからファイルを削除できます。


File: emacs-ja.info,  Node: VC Directory Mode,  Next: Branches,  Prev: VC Ignore,  Up: Version Control

28.1.10 VC Directoryモード
--------------------------

“VC Directoryバッファー”は、ディレクトリーツリーにあるファイルのバージョ
ンコントロール状態を見て、それらのファイルにバージョンコントロール操作を
実行するために特化したバッファーです。特に複数ファイルのVCファイルセット
にたいして、‘C-x v v’のようなコマンドを適用するのに使用されます(*note VC
Directory Commands::を参照してください)。

   VC Directoryバッファーを使用するには、‘C-x v d’ (‘vc-dir’)とタイプし
ます。これはミニバッファーを使用してディレクトリーの名前を読み取り、その
ディレクトリーにたいするVC Directoryバッファーに切り替えます。デフォルト
では、バッファーの名前は‘*vc-dir*’です。その内容については、 *note VC
Directory Buffer::で説明します。

   ‘vc-dir’コマンドは、指定したディレクトリーで使用されているバージョン
コントロールシステムを自動的に検知します。そのディレクトリーにたいして複
数のバージョンコントロールシステムが使用されている場合、‘C-u C-x v d’の
ようにプレフィクス引数を指定して、このコマンドを呼び出す必要があるでしょ
う。これはVC Directoryバッファーが使用すべきバージョンコントロールシステ
ムの入力を求めます。

   VC Directoryバッファーに加えて、EmacsにはCVSに特化したPCL-CVSと呼ばれ
る似た機能があります。*note About PCL-CVS: (pcl-cvs)Top.を参照してくださ
い。

* Menu:

* Buffer: VC Directory Buffer.  バッファーの外観と意味。
* Commands: VC Directory Commands.  VC
                                      directoryバッファーで使用するコマンド。


File: emacs-ja.info,  Node: VC Directory Buffer,  Next: VC Directory Commands,  Up: VC Directory Mode

28.1.10.1 VC Directoryバッファー
................................

VC Directoryバッファーは、バージョンコントロールされたファイルと、それら
のバージョンコントロール状態を含みます。これは、(‘C-x v d’を呼び出すこと
により指定される)カレントディレクトリーの、注目すべき状態のファイルとサ
ブディレクトリーをだけリストします。最新のファイル(リポジトリーのものと
同じ)は省略されます。サブディレクトリーのファイルがすべて最新の場合、そ
のサブディレクトリーもリストされません。例外として、VCコマンドの直接の結
果として最新になったファイルはリストされます。

   以下はVC Directoryバッファーのリストの例です:

                          ./
         edited           configure.ac
     *   added            README
         unregistered     temp.txt
                          src/
     *   edited           src/main.c

2つの作業ファイル、カレントディレクトリーの‘configure.ac’と、サブディレ
クトリー‘src/’の‘main.c’は、変更されていますがコミットされていません。
‘README’という名前のファイルは追加されましたが、まだコミットされていませ
ん。そして‘temp.txt’はバージョンコントロールの配下にありません(*note
Registering::を参照してください)。

   エントリー‘README’および‘src/main.c’の隣の‘*’という文字は、ユーザーが
それらのファイルをカレントVCファイルセットとしてマークしたことを示します
(*note VC Directory Commands::を参照してください)。

   上記は、Bazaar、Git、Mercurialのような分散型のバージョンコントロール
システムでの典型的な例です。他のシステムでは、他の状態も見られます。たと
えばCVSは、リポジトリーが変更されていて、それがまだ作業ファイルに適用さ
れていないときは、‘needs-update’という状態を表示します。RCSとSCCSは、ロ
ックされているファイルの状態に、ロックしているユーザーの名前を表示します
。

   CVSでは通常、‘vc-dir’コマンドは更新のチェックのために、おそらくはリモ
ートマシン上にあるであろうリポジトリーにアクセスします。変数
‘vc-cvs-stay-local’を‘nil’ (*note CVS Options::を参照)に変更すると、
EmacsはVC Directoryバッファーが生成されるときのリモートのリポジトリーへ
のアクセスを避けます(コミットを行うときなど、必要なときはアクセスします
)。これは、オフラインで作業していたり、ネットワークが遅いときは望ましい
でしょう。

   VC Directoryバッファーは、変数‘vc-directory-exclusion-list’にリストさ
れているサブディレクトリーを省略します。この変数のデフォルト値には、バー
ジョンコントロールシステムにより内部的に使用されるディレクトリーが含まれ
ています。


File: emacs-ja.info,  Node: VC Directory Commands,  Prev: VC Directory Buffer,  Up: VC Directory Mode

28.1.10.2 VC Directoryコマンド
..............................

EmacsはVC Directoryバッファーの操作と、カレントVCファイルセットに属させ
るために、ファイルをマークするためのコマンドをいくつか提供します。

‘n’
‘<SPC>’
     次のエントリーにポイントを移動します(‘vc-dir-next-line’)。

‘p’
     前のエントリーにポイントを移動します(‘vc-dir-previous-line’)。

‘<TAB>’
     次のディレクトリーエントリーに移動します(‘vc-dir-next-directory’)。

‘S-<TAB>’
     前のディレクトリーエントリーに移動します
     (‘vc-dir-previous-directory’)。

‘<RET>’
‘f’
     カレント行にリストされたファイル、またはディレクトリーをvisitします
     (‘vc-dir-find-file’)。

‘o’
     カレント行にリストされたファイル、またはディレクトリーを別のウィン
     ドウでvisitします(‘vc-dir-find-file-other-window’)。

‘m’
     カレント行のファイルまたはディレクトリーをマークして、それをカレン
     トVCファイルセットに加えます(‘vc-dir-mark’)。リージョンがアクティブ
     のときは、リージョンの中のすべてのファイルをマークします。

     すでにマークされたディレクトリーの中のファイル、またはそのサブディ
     レクトリーは、このコマンドではマークされません。同様に、ツリーの中
     のいくつかのファイルがマークされているディレクトリーは、このコマン
     ドではマークされません。

‘M’
     ポイントがファイルエントリーにあるときは、同じ状態のすべてのファイ
     ルをマークします。ポイントがディレクトリーエントリーにあるときは、
     そのディレクトリーツリーのすべてのファイルをマークします
     (‘vc-dir-mark-all-files’)。プレフィクス引数を指定した場合、リストさ
     れたファイルとディレクトリーのすべてをマークします。

‘q’
     VC Directoryバッファーを終了して、隠します(‘quit-window’)。

‘u’
     カレント行のファイル、またはディレクトリーのマークを外します
     (‘vc-dir-unmark’)。リージョンがアクティブのときは、リージョンの中の
     すべてのファイルのマークを外します。

‘U’
     ポイントがファイルエントリーにあるときは。同じ状態のすべてのファイ
     ルのマークを外し、ポイントがディレクトリーエントリーにあるときは、
     そのディレクトリーツリーのすべてのファイルのマークを外します
     (‘vc-dir-unmark-all-files’)。プレフィクス引数を指定した場合、すべて
     のファイルおよびディレクトリーのマークを外します。

‘x’
     状態が‘up-to-date’、または‘ignored’のファイルを隠します
     (‘vc-dir-hide-up-to-date’)。プレフィクス引数を指定した場合、状態が
     ポイント位置のアイテムと同じアイテムを隠します。

   VC Directoryバッファーでは、‘m’ (‘vc-dir-mark’)または‘M’
(‘vc-dir-mark-all-files’)でマークしたすべてのファイルが、カレントVCファ
イルセットになります。ディレクトリーエントリーを‘m’でマークした場合、そ
のディレクトリーツリーにリストされたすべてのファイルが、カレントVCファイ
ルセットになります。カレントVCファイルセットに属するファイルとディレクト
リーは、VC Directoryではバージョンコントロール状態の隣に、文字‘*’が示さ
れます。この方法により‘C-x v v’ (*note Basic VC Editing::を参照してくだ
さい)、‘C-x v =’ (*note Old Revisions::を参照してください)、‘C-x v u’
(*note VC Undo::を参照してください)のようなVCコマンドが作用する、複数フ
ァイルのVCファイルセットをセットアップできます。

   VC Directoryバッファーは、‘C-x v’というプレフィクスをもつコマンドを、
1キーで入力するショートカット(‘=’、‘+’、‘l’、‘i’、‘D’、‘L’、‘G’、‘I’、
‘O’、‘v’)を定義します。

   たとえば、VC Directoryバッファーで開いて編集された一連のファイルは、
‘edited’という状態でリストされ、それらのファイルをマークして、‘v’または
‘C-x v v’ (‘vc-next-action’)でコミットできます。バージョンコントロールシ
ステムが変更セットベースの場合、Emacsはそれらのファイルを1つのリビジョン
としてコミットします。

   VC Directoryバッファーでは、以下のコマンドによりカレントVCファイルセ
ットの検索と置換を処理することもできます:

‘S’
     ファイルセットを検索します(‘vc-dir-search’)。

‘Q’
     ファイルセットにたいして、正規表現による問い合わせ置換を行います
     (‘vc-dir-query-replace-regexp’)。

‘M-s a C-s’
     ファイルセットにたいして、インクリメンタル検索を行います
     (‘vc-dir-isearch’)。

‘M-s a C-M-s’
     ファイルセットにたいして、インクリメンタルな正規表現検索を行います
     (‘vc-dir-isearch-regexp’)。

複数ファイルに作用する点を除けば、これらのコマンドは1つのバッファーに作
用する同等のコマンドに似ています(*note Search::を参照してください)。

   VC Directoryバッファーは、追加でブランチ関連のコマンドを定義し、それ
らはプレフィックス‘B’で始まります:

‘B c’
     新たなブランチを作成します(‘vc-create-tag’)。

‘B l’
     ブランチ名の入力を求め、そのブランチの変更履歴を表示します
     (‘vc-print-branch-log’)。

‘B s’
     ブランチを切り替えます(‘vc-retrieve-tag’)。*note Switching
     Branches::を参照してください。

   上記のコマンドは、メニューバーおよび‘mouse-2’によるコンテキストメニュ
ーを通じても利用可能です。さらにVCのバックエンドのいくつかは、そのバック
エンド特有のコマンドを提供するメニューを使用します。たとえばGitと
Bazaarでは、“stashes(隠してあるもの)”と“shelves(棚)”(コミットされていな
い変更を一時的に除外して、後でそれを戻すコマンド)を操作できます。


File: emacs-ja.info,  Node: Branches,  Next: Miscellaneous VC,  Prev: VC Directory Mode,  Up: Version Control

28.1.11 バージョンコントロールのブランチ
----------------------------------------

バージョンコントロールの活用法の1つとして、“ブランチ(branches)”と呼ばれ
る複数の独立した開発ラインのサポートがあります。中でもとりわけブランチは
、プログラムの安定版(stable)と開発版(development)を個別に保守したり、関
係のない機能を他の版から隔離して開発するのに使用されます。

   現在のところVCのブランチ操作にたいするサポートは、かなり制限されてい
ます。分散型のバージョンコントロールシステムにたいしては、あるブランチを
他のブランチのコンテンツで“更新”するコマンドと、2つの異なるブランチの変
更を“マージ”するコマンドを提供します。集中型のバージョンコントロールシス
テムにたいしては、異なるブランチからチェックアウトして、新規または異なる
ブランチにコミットするコマンドを提供します。

* Menu:

* Switching Branches::       既存のブランチを取得する方法。
* Pulling / Pushing::        他の場所からの変更を受信、変更の送信。
* Merging::                  ブランチ間での変更の転送。
* Creating Branches::        新しいブランチを開始する方法。


File: emacs-ja.info,  Node: Switching Branches,  Next: Pulling / Pushing,  Up: Branches

28.1.11.1 ブランチ間の切り替え
..............................

さまざまなバージョンコントロールシステムにおいて、ブランチが実装される方
法は異なり、VCはこれらの違いを完全に隠蔽することはできません。

   BazaarとMercurialを含む分散型バージョンコントロールシステムのいくつか
は、ノーマルモードの操作では、各ブランチは自身の作業ディレクトリーツリー
をもつので、ブランチの切り替えは単にディレクトリーを切り替えるだけです。
Gitでは、ブランチは通常、同じディレクトリーの“共通ロケーション
(co-located)”を使用し、ブランチの切り替えは、作業ツリーの内容をそのブラ
ンチに一致するように変更する、‘git checkout’を使用して行われます。
Bazaarも共通ロケーションをサポートし、この場合は‘bzr switch’コマンドによ
りカレントディレクトリーでブランチを切り替えます。Subversionでは他のブラ
ンチに切り替えるのに、‘svn switch’コマンドを使用します。

   カレントディレクトリーの他のブランチに切り替えるVCコマンドは、‘C-x v
r BRANCH-NAME <RET>’ (‘vc-retrieve-tag’)です。

   集中型のバージョンコントロールシステムでは、最新の作業ファイルで‘C-u
C-x v v’とタイプして(*note Advanced C-x v v::を参照してください)、他のブ
ランチのリビジョンIDを入力することにより、ブランチ間を切り替えることもで
きます。たとえばCVSでは、“trunk(幹の意。開発の主要ラインを示します)”のリ
ビジョンは通常、1.1、1.2、1.3、...という形式をもち、最初のブランチがリビ
ジョン1.2から作成された場合、リビジョン1.2は1.2.1.1、1.2.1.2、...という
リビジョンIDをもち、さらに2番目のブランチが同じくリビジョン1.2から作成さ
れた場合、それは1.2.2.1、1.2.2.2、...という形式になります。ブランチのリ
ビジョンIDから最後の部分を除いた(たとえば1.2.1)、“ブランチID(branch
ID)”を指定して、そのブランチの最新のリビジョンに切り替えることもできます
。

   ロックベースのシステムでは、他のブランチに切り替えることにより、作業
ツリーのロックが解除(書き込み禁止)になります。

   1度ブランチを切り替えると、そのブランチを他に切り替えるまで、VCコマン
ドはそのブランチに適用されます。たとえば任意のVCファイルセットをコミット
すると、そのブランチにコミットされるようになります。


File: emacs-ja.info,  Node: Pulling / Pushing,  Next: Merging,  Prev: Switching Branches,  Up: Branches

28.1.11.2 ブランチへ/からの変更のpull/push
..........................................

‘C-x v P’
     分散型のバージョンコントロールシステムでは、カレントブランチからの
     変更により、その変更で他のロケーションを更新(変更を“push”する、とも
     言います)します。この概念は集中型のバージョンコントロールシステムに
     は存在しません。

‘C-x v +’
     分散型のバージョンコントロールシステムでは、他のロケーションから変
     更を“pull”することにより、カレントのブランチを更新します。

     集中型のバージョンコントロールシステムでは、カレントVCファイルセッ
     トを更新します。

   分散型のバージョンコントロールシステムでは、コマンド‘C-x v P’
(‘vc-push’)は、カレントブランチからの変更により他のロケーションを更新し
ます。プレフィクス引数を与えた場合、このコマンドは実行する正確なバージョ
ンコントロールコマンドの入力をもとめます。これにより変更をどこにpushする
か指定できます。デフォルトは、Bazaarでは‘bzr push’、Gitでは‘git push’、
Mercurialでは‘hg push’です。デフォルトのコマンドは常に、ブランチ設定から
バージョンコントロールシステムにより決定されるデフォルトのロケーションに
pushします。

   pullする前に‘C-x v O’ (‘vc-log-outgoing’)を使用して、送信される変更の
logバッファーを閲覧できます。*note VC Change Log::を参照してください。

   現在のところ、このコマンドはBazaar、Git、Mercurialだけでサポートされ
ます。“push”という概念は集中型のバージョンコントロールシステムには存在し
ません。なぜなら、この操作は変更セットのコミットの一部なので、集中型の
VCSでこのコマンドを呼び出すと、エラーをシグナルします。Bazaarの“bound
branch”でこのコマンドを試みたときもエラーをシグナルします。変更セットの
コミットは、自動的に変更を(ローカルのブランチがバインドされている)リモー
トのリポジトリーにpushするからです。

   分散型のバージョンコントロールシステムでは、コマンド‘C-x v +’
(‘vc-pull’)は、カレントブランチと作業ツリーを更新します。これは通常、リ
モートのブランチのコピーを更新するのに使用されます。プレフィクス引数を与
えた場合、このコマンドは使用する正確なバージョンコントロールコマンドの入
力をもとめます。これにより変更をどこからpullするか指定できます。プレフィ
クス引数を指定しない場合は、バージョンコントロールシステムにより決定され
る、デフォルトのロケーションからpullします。

   分散型のバージョンコントロールシステムの中で、現在‘C-x v +’がサポート
するのはBazaar、Git、Mercurialだけです。Bazaarでは、これは通常のブランチ
にたいしては、(マスターブランチをミラーリングされたブランチにpullするた
めに)‘bzr pull’を呼び出し、バインドされたブランチにたいしては、(中心とな
るリポジトリーからpullするために)‘bzr update’を呼び出します。Gitでは、こ
れはリモートのリポジトリーから変更を取得して、それをカレントブランチにマ
ージするために、‘git pull’を呼び出します。Mercurialでは、デフォルトのリ
モートリポジトリーから変更を取得して、作業ディレクトリーを更新するために
‘hg pull -u’を呼び出します。

   pullする前に‘C-x v I’ (‘vc-log-incoming’)を使用して、適用される変更の
logバッファーを閲覧できます。*note VC Change Log::を参照してください。

   CVSのような集中型のバージョンコントロールシステムでは、‘C-x v +’はリ
ポジトリーからカレントVCファイルセットを更新します。


File: emacs-ja.info,  Node: Merging,  Next: Creating Branches,  Prev: Pulling / Pushing,  Up: Branches

28.1.11.3 ブランチのマージ
..........................

‘C-x v m’
     分散型のバージョンコントロールシステムでは、カレントのブランチに他
     のブランチの変更をマージします。

     集中型のバージョンコントロールシステムでは、カレントVCファイルセッ
     トに他のブランチの変更をマージします。

   ブランチで開発している場合、すでに他のブランチで行われた変更を“マージ
(merge)”する必要があるときがあります。これは2つのブランチでの変更が重な
る場合もあるため、些細な操作とはいえません。

   分散型のバージョンコントロールシステムでは、マージはコマンド‘C-x v m’
(‘vc-merge’)により行われます。Bazaarでは、これは‘bzr merge’に渡す正確な
引数の入力を求めます。そのとき、可能であれば目的にかなったデフォルトを提
示します。Gitでは、これはマージするブランチ名の入力を求めます。このとき
、(カレントリポジトリーが知っているブランチ名にもとづく)補完を行います。
マージコマンドの実行による出力は、他のバッファーに表示されます。

   CVSのような集中型のバージョンコントロールシステムでは、‘C-x v m’はブ
ランチID、または2つのリビジョンIDの入力を求めます。コマンドはそのブラン
チからの変更点、または指定した2つのリビジョン間の差分を探して、それらの
変更をカレントVCファイルセットにマージします。‘<RET>’だけをタイプした場
合、Emacsは単にそのファイルをチェックアウトしたブランチに行われた変更を
マージします。

   マージを処理した直後は、作業ツリーだけが変更されており、‘C-x v D’およ
び関連するコマンドで、マージにより生成された変更をレビューできます(*note
Old Revisions::を参照してください)。2つのブランチが重なった変更をもつ場
合、マージは“衝突(conflict)”を生成します。その場合、マージコマンドの出力
には警告が現れ。影響のある作業ファイルの、衝突する2つの変更の周囲に、“衝
突マーカー(conflict markers)”が挿入されます。衝突を解決するには、衝突す
るファイルを編集しなければなりません。編集が終わったら、マージが効果を発
揮するように、通常の方法により変更したファイルをコミットしなければなりま
せん(*note Basic VC Editing::を参照してください)。


File: emacs-ja.info,  Node: Creating Branches,  Prev: Merging,  Up: Branches

28.1.11.4 新しいブランチの作成
..............................

CVSのような集中型のバージョンコントロールシステムでは、Emacsはコミット操
作の一部として、新しいブランチの作成をサポートします。変更されたVCファイ
ルセットをコミットするとき、‘C-u C-x v v’ (‘vc-next-action’のようにプレ
フィクス引数を指定します。*note Advanced C-x v v::を参照してください).す
ると、Emacsは新しいリビジョンのリビジョンIDの入力を求めます。ここでカレ
ントリビジョンから開始するブランチの。適切なブランチIDを指定する必要があ
ります。たとえば、カレントリビジョンIDが2.5の場合、ブランチIDは2.5.1、
2.5.2、...となるべきでしょう。ブランチIDは、その時点での既存のブランチの
番号に依存します。

   (すでにブランチのヘッドではない)古いリビジョンに新しいブランチを作成
するには、最初にそのリビジョンを選択します(*note Switching Branches::を
参照してください)。その後の手順は、ロックベースのバージョンコントロール
システムを使っているか、マージベースのものを使っているかで異なります。

   ロックベースのバージョンコントロールシステムでは、‘C-x v v’で古いリビ
ジョンのブランチを選択します。古いリビジョンを選択する場合、本当に新しい
ブランチを作成したいのか確認を求めます。これにnoと応えた場合、かわりに最
新のリビジョンをロックする機会が与えられます。マージベースのバージョンコ
ントロールシステムでは、このステップはスキップします。

   変更を行なってから、再び‘C-x v v’とタイプして、新しいリビジョンをコミ
ットします。これは選択されたリビジョンから始まる、新しいブランチを作成し
ます。

   ブランチが作成された後は、それ以降のコミットは、そのブランチに新しい
リビジョンを作成します。ブランチを離れるには、‘C-u C-x v v’で明示的に異
なるリビジョンを選択しなければなりません。


File: emacs-ja.info,  Node: Miscellaneous VC,  Next: Customizing VC,  Prev: Branches,  Up: Version Control

28.1.12 VCのその他のコマンドと機能
----------------------------------

このセクションでは、それほど頻繁には使用されないVCの機能を説明します。

* Menu:

* Change Logs and VC::       logエントリーからChangeLogファイルを生成する。
* VC Delete/Rename::         バージョンコントロールされたファイルの削除とリネームについて。
* Revision Tags::            リビジョンにたいするシンボリック名。
* Version Headers::          作業ファイルへのバージョンコントロールヘッダーの挿入。


File: emacs-ja.info,  Node: Change Logs and VC,  Next: VC Delete/Rename,  Up: Miscellaneous VC

28.1.12.1 変更ログとVC
......................

‘ChangeLog’ファイル (*note Change Log::を参照してください)をもつプロググ
ラムにたいしてRCSやCVSを使用する場合、 バージョンコントロールの以前のコ
ミットのログエントリーから、ChangeLogのエントリーを生成することができま
す。

   これはRCSとCVSだけで機能することに注意してください。この手段は特に、
現代的な変更セットベースのバージョンコントロールシステムには不適切です。
なぜなら、‘ChangeLog’ファイルへの変更自体が、通常は変更セットの一部とし
てコミットされるからです。この場合、最初にChangeLogエントリーを記述して
、コミットするときにそれを‘*vc-log*’バッファーに引用します (*note Log
Buffer::を参照してください)。

‘C-x v a’
     カレントディレクトリーの‘ChangeLog’ファイルをvisitして、そのディレ
     クトリーの登録されたファイルにたいして、最新のChangeLogエントリー以
     降にコミットされたバージョンにたいする、新しいエントリーを作成しま
     す。(‘vc-update-change-log’)。

‘C-u C-x v a’
     上記と同様ですが、カレントバッファーのファイルにたいするエントリー
     だけを探します。

   たとえば、‘ChangeLog’の最初の行の日付が1999-04-10で、それ以降のチェッ
クインは1999-05-22のNathaniel Bowditchによる‘rcs2log’だけで、それのログ
エントリーが‘Ignore log messages that start with '#'.’だったとします。そ
の場合、‘C-x v a’は‘ChangeLog’エントリーとして、以下を挿入します:

     1999-05-22  Nathaniel Bowditch  <nat@apn.org>

             * rcs2log: Ignore log messages that start with '#'.

バージョンコントロールのログエントリーが、(行頭にカッコで括られて記述さ
れる)関数名を指定する場合、それは‘ChangeLog’のエントリーに反映されます。
たとえば‘vc.el’にたいするログエントリーが‘(vc-do-command): Check
call-process status.’の場合、‘ChangeLog’のエントリーは以下のようになりま
す:

     1999-05-06  Nathaniel Bowditch  <nat@apn.org>

             * vc.el (vc-do-command): Check call-process status.

   ‘C-x v a’が複数のChangeLogエントリーを1度に追加するとき、それらがすべ
て同じ作者に、ほぼ同じ日時にチェックインされている場合、関連するログエン
トリーとしてそれらをグループ化します。複数のファイルにたいするログエント
リーがすべての同じテキストの場合、それらを1つのエントリーにまとめます。


File: emacs-ja.info,  Node: VC Delete/Rename,  Next: Revision Tags,  Prev: Change Logs and VC,  Up: Miscellaneous VC

28.1.12.2 バージョンコントロールされたファイルの削除とリネーム
..............................................................

‘M-x vc-delete-file’
     ファイル名の入力を求め、そのファイルを作業ツリーから削除して、コミ
     ット時に削除するようスケジュールします。

‘M-x vc-rename-file’
     2つのファイル名OLDおよびNEWの入力を求め、作業ツリーのファイルをリネ
     ームし、コミット時にリネームを行うようスケジュールします。カレント
     バッファーのファイルがVC配下にある場合は、そのファイルがOLDのデフォ
     ルトファイルになります。

   バージョンコントロールされたファイルを削除したい場合、コマンド‘M-x
vc-delete-file’を使用します。これはファイル名の入力を求め、バージョンコ
ントロールシステムを通じてそれを削除します。ファイルは作業ツリーから削除
され、VC Directoryバッファー (*note VC Directory Mode::を参照してくださ
い) では、状態に‘removed’が表示されます。それをコミットするとき、リポジ
トリー内で削除が実行されます。

   バージョンコントロールされたファイルをリネームするには、‘M-x
vc-rename-file’とタイプします。これは2つの引数の入力を求めます。それはリ
ネームしたいファイルの名前を、それの新しい名前です。そしてバージョンコン
トロールシステムを通じてリネームを処理します。作業ツリーではリネームは即
座に行われます。リネームされたファイルをコミットするとき、リポジトリーに
反映されます。

   現代的なバージョンコントロールシステムは、リネームにたいするビルトイ
ンのサポートがあり、リネームされたファイルは元のファイルのすべての変更履
歴を保持します。CVSおよび古いバージョンコントロールシステムでは、
‘vc-rename-file’コマンドは、実際には古いファイルを新しい名前にコピーして
、それを登録してから古いファイルを削除することにより機能します。この場合
、変更履歴は保存されません。


File: emacs-ja.info,  Node: Revision Tags,  Next: Version Headers,  Prev: VC Delete/Rename,  Up: Miscellaneous VC

28.1.12.3 リビジョンタグ
........................

ほとんどのバージョンコントロールシステムは、バージョンコントロールされた
ツリーの特定のバージョンにたいして、“リビジョンタグ(revision tag)”を適用
できます。現代的な変更セットベースのバージョンコントロールシステムでは、
リビジョンタグは単に特定のリビジョンにたいするシンボリック名です。CVSの
ようなファイルベースの古いシステムで、各タグははバージョンコントロールさ
れた一連のファイル全体に追加され、それらを1つの単位として処理できるよう
にします。リビジョンタグは一般的にユーザーに配布されるリリースを識別する
のに使用されます。

   タグにたいする2つの基本的なコマンドがあります。1つは与えられた名前で
タグを作成し、もう1つは名前がつけられたタグを取得するコマンドです。

‘C-x v s NAME <RET>’
     カレントディレクトリーまたはその配下のディレクトリーの、すべての登
     録されたファイルの作業リビジョンにたいする、NAMEという名前のタグを
     定義します(‘vc-create-tag’)。

‘C-x v r NAME <RET>’
     カレントディレクトリーまたはその配下のディレクトリーの、すべての登
     録されたファイルにたいして、リビジョンのタグがNAMEのものを取得しま
     す。NAMEがブランチ名で、バージョンコントロールシステムがタグからブ
     ランチを区別する場合、このコマンドはブランチを切り替えます。
     (‘vc-retrieve-tag’).

     カレントディレクトリーまたは配下のディレクトリーのファイルがロック
     されている場合、このコマンドは何もせずにエラーを報告します。これは
     作業中の上書きを避けるためです。

   ‘C-x v =’または‘C-x v ~’の引数として、タグまたはブランチ名を与えるこ
とができます (*note Old Revisions::を参照してください)。 したがって、カ
レントファイルとタグ付けされたバージョンを比較したり、タグ付けされたバー
ジョン同士を比較することができます。

   SCCSでは、VC自身がタグを実装しているので、VCを通じてのみタグを見るこ
とができます。それより新しいほとんどのシステム(CVS、Subversion、bzr、
git、hgを含む)は、ネイティブのタグ機能をもっており、利用可能な場合、VCは
それを使用します。これらのタグは、VCを通さなくても見ることができます。

   ファイルベースのバージョンコントロールシステムでは、登録されたファイ
ルをリネームするとき、それのマスターもリネームする必要があります。コマン
ド‘vc-rename-file’は、これを自動的に行います (*note VC Delete/Rename::を
参照してください)。 SCCSを使用している場合、、そのファイルが新しい名前に
なったことを告げるために、タグの記録も更新しなければなりません
(‘vc-rename-file’もこれを行います)。記録された名前では、すでに存在しない
マスターファイルを参照する古いタグは無効になります。VCはそれを取得しませ
ん。RCSおよびSCCSでのタグの手修正は、このマニュアルの範囲を超えるでしょ
う。‘vc-rename-file’を使用することにより、ファイルを取得できる有効なタグ
を作成できますが、それですべての問題が解決されるわけではありません。たと
えば、プログラムのいくつかのファイルは、他のファイルを名前で参照するかも
しれません。少なくともmakefileはリネームしたファイルを参照するでしょう。
古いタグを取得した場合、リネームされたファイルは、makefileが期待しない新
しい名前で取得されます。そのため、プログラムはうまく機能しないでしょう。


File: emacs-ja.info,  Node: Version Headers,  Prev: Revision Tags,  Up: Miscellaneous VC

28.1.12.4 バージョンコントロールヘッダーの挿入
..............................................

Subversion、CVS、RCS、SCCSでは、“バージョンヘッダー(version headers)”と
呼ばれる文字列を、ファイル内に置くことができます。そのファイルがコミット
されたとき、バージョンコントロールシステムは自動的にリビジョン番号、コミ
ットしたユーザーの名前、その他関連する情報をバージョンヘッダーに挿入しま
す。

   VCは通常、バージョンヘッダーの情報を使用しません。例外として、RCSを使
用している場合、EmacsはRCSのマスターファイルより信頼できる場合が多いとい
う理由で、ファイルのバージョンを決定するためにバージョンヘッダーを使用し
ます。この方法でバージョンヘッダーを使用するのを禁ずるには、変数
‘vc-consult-headers’を‘nil’に変更します。その場合、VCは常に(それが信用で
きると推測されれば)ファイルパーミッションを使用し、それ以外はマスターフ
ァイルをチェックします。

   カレントバッファーに適切なヘッダー文字列を挿入するには、コマンド‘M-x
vc-insert-headers’を使用します。このコマンドはSubversion、CVS、RCS、
SCCSだけで機能します。変数‘vc-BACKEND-header’には、バージョンヘッダーに
挿入されるキーワードのリストが含まれます。たとえばCVSは‘vc-cvs-header’を
使用し、これのデフォルト値は‘'("\$Id\$")’です(余分なバックスラッシュは、
もしEmacs Lispファイルがバージョンコントロールにより保守されるときに、文
字列定数がヘッダーと解釈されるのを防ぐためのものです)。
‘vc-insert-headers’コマンドは。ポイント位置の新しい行にリストのタブで囲
まれた各キーワードを挿入し、必要ならばコメント区切りで囲みます。

   変数‘vc-static-header-alist’は、バッファー名にもとづき追加する文字列
を指定します。これの値は、‘(REGEXP . FORMAT)’という形式の要素からなるリ
ストです。REGEXPがバッファー名にマッチした場合、バージョンヘッダーの一部
としてFORMATも挿入されます。FORMATの中の‘%s’は、そのファイルのバージョン
コントロールのタイプに置換されます。


File: emacs-ja.info,  Node: Customizing VC,  Prev: Miscellaneous VC,  Up: Version Control

28.1.13 VCのカスタマイズ
------------------------

変数‘vc-handled-backends’は、どのバージョンコントロールシステムが処理す
るかを決定します。デフォルト値は‘(RCS CVS SVN SCCS SRC Bzr Git Hg Mtn
Arch)’で、これには、現在サポートされている、すべてのバージョンコントロー
ルが含まれています。VCにこれらのシステムの1つ以上を無視させたい場合、リ
ストからそのシステムの名前を除外します。VC全体を無効にするには、変数に
‘nil’をセットしてください。

   リストのシステム順序には意味があります。これらのシステムの1つ以上に登
録されているファイルをvisitした場合、デフォルトではVCは
‘vc-handled-backends’で最初にくるシステムを使用します。ファイルを最初に
登録するときも、この順序が意味をもちます (*note Registering::を参照して
ください)。

* Menu:

* General VC Options::       複数のバックエンドに適用されるオプション。
* RCS and SCCS::             RCSとSCCSのためのオプションについて。
* CVS Options::              CVSにたいするオプションについて


File: emacs-ja.info,  Node: General VC Options,  Next: RCS and SCCS,  Up: Customizing VC

28.1.13.1 一般的なオプション
............................

Emacsは通常、バージョンコントロールにより保守されるソースファイルのバッ
クアップファイルを保存しません。バージョンコントロールを使用したファイル
にもバックアップファイルを作成したいときは、変数‘vc-make-backup-files’に
非‘nil’値をセットしてください。

   そのファイルがバージョンコントロールされていると知らずに、シンボリッ
クリンクを通じてバージョンコントロールされたファイルを編集すると、予期せ
ぬ結果を招くことがあります。変数‘vc-follow-symlinks’は、バージョンコント
ロールされたファイルを指すシンボリックリンクをvisitしようと試みたときの
、Emacsの振る舞いを制御します。値が‘ask’(デフォルト)の場合、Emacsは確認
を求めます。値が‘nil’の場合、Emacsは警告メッセージを表示するだけです。値
が‘t’の場合、Emacsは自動的にリンクをたどって、かわりに実際のファイルを
visitします。

   ‘vc-suppress-confirm’が非‘nil’の場合、‘C-x v v’および‘C-x v i’は確認
を求めずにカレントバッファーを保存し、‘C-x v u’も確認を求めず処理を行い
ます。

   VCモードは多くの処理を、バージョンコントロールシステムにたいする適切
なシェルコマンドを実行することにより行います。‘vc-command-messages’が非
‘nil’の場合、VCはそれが実行するシェルコマンドを示すメッセージと、コマン
ドが終了したときの追加のメッセージを表示します。


File: emacs-ja.info,  Node: RCS and SCCS,  Next: CVS Options,  Prev: General VC Options,  Up: Customizing VC

28.1.13.2 RCSとSCCSにたいするオプション
.......................................

デフォルトでは、複数ユーザーの活動を調停するためにRCSはロックを使用しま
すが、最初にファイルをロックしなくても変更をチェックインできる、“厳密で
ないロック(non-strict locking)”と呼ばれるモードもあります。特定のファイ
ルにたいして厳密でないロックに切り替えるには、‘rcs -U’を使用します。詳細
については、‘rcs’のman-pageを参照してください。

   RCSファイルのバージョンコントロール状態を推論するとき、VCは最初にその
ファイルのRCSバージョンヘッダー文字列を調べます(*note Version Headers::を
参照してください)。ヘッダー文字列がない場合、VCは通常、作業ファイルのパ
ーミッションを調べます。これは速い処理です。ファイルのパーミッションが信
頼できない状況もあるかもしれません。そのような場合はマスターファイルが調
べられます。これはより高価な処理です。マスターファイルから判るのは、_も
し_そのファイルにたいして何らかのロックがある場合、作業ファイルが実際に
ロックされたバージョンを含むかどうか、だけです。

   ‘vc-consult-headers’を‘nil’にセットすることにより、VCがファイル状態を
決定するのにバージョンヘッダーを使用しないように指定できます。その場合、
VCは常に、(それが信用できると思われる場合は)ファイルのパーミッションを使
うか、マスターファイルをチェックします。

   VCがSCCSの配下にあるファイルのバージョンコントロール状態を決定する方
法は、RCSとほぼ同じです。しかしSCCSのバージョンヘッダーは考慮しません。
したがって、‘vc-consult-headers’はSCCSの使用に影響しません。


File: emacs-ja.info,  Node: CVS Options,  Prev: RCS and SCCS,  Up: Customizing VC

28.1.13.3 CVSに特有のオプション
...............................

変数‘vc-cvs-global-switches’で、すべてのCVS操作に渡す追加のコマンドライ
ンオプションを指定できます。これらのスイッチは‘cvs’コマンドの直後、呼び
出す操作名の前に挿入されます。

   リモートマシン上でCVSリポジトリを使用する際は、ネットワーク通信を最小
に維持するようVCに試行させることができます。これは、変数
‘vc-cvs-stay-local’により制御されます。‘vc-cvs-stay-local’が
‘only-file’(デフォルト)の場合、VCはローカルのCVSサブディレクトリーのエン
トリーと、前のCVSコマンドから戻された情報だけを使って、各ファイルのバー
ジョンコントロール状態を決定します。結果として、あなたがファイルを変更し
ているとき、他の誰かが他の変更をチェックインした場合、それのコミットを試
みるまで衝突は通知されません。

   ‘vc-cvs-stay-local’を‘nil’に変更した場合、ローカルのリポジトリーと同
じように、‘vc-next-action’ (‘C-x v v’)が何を行うか決定する_前_に、VCはリ
モートのリポジトリーに問い合わせを行います。

   ‘vc-cvs-stay-local’に、リポジトリーのあるホスト名にマッチする正規表現
を指定することもできます。この場合、ホスト名がパターンにマッチしたときは
、VCはローカルに留まります。

   リモートのリポジトリーを使用する場合、Emacsは通常、編集された各ファイ
ルのオリジナルバージョンである、“自動バージョンバックアップ(automatic
version backups)”を作成します。これらのローカルのバックアップは、変更を
最初にファイルに保存したときに作成され、リポジトリーに変更をコミットした
後で削除されます(これらは通常のEmacsのバックアップファイルとは異なること
に注意してください。 *note Backup::を参照してください)。 ‘C-x v =’や‘C-x
v u’のようなコマンドは、ネットワークへのアクセスを避けるため、可能な場合
は自動バージョンバックアップを使用します。

   ‘vc-cvs-stay-local’を‘nil’にセットすることにより、自動バージョンバッ
クアップの作成を無効にできます。

   自動バージョンバックアップは、‘FILE.~VERSION.~’という形式の名前をもち
ます。これは‘C-x v ~’が古いバージョンを保存するときの名前と似ています
(*note Old Revisions::を参照してください)。 例外は、バージョンの後ろにあ
る追加のドット(‘.’)です。関連するVCコマンドは、これら両方の種類のバージ
ョンバックアップを使用できます。主な違いは、‘C-x v ~’により手動で作成さ
れたバージョンバックアップは、コミットしたとき自動的に削除されないことで
す。

   デフォルトでCVSはロックを使用しませんが、‘CVSREAD’または“watch”の機能
を使用して、ロックのような振る舞いを有効にする方法があります。詳細につい
ては、CVSのドキュメントを参照してください。そのような場合、ロックベース
のバージョンコントロールシステムで行うように、Emacsで‘C-x v v’を使用して
、ロックを切り替えることができます (*note VC With A Locking VCS::を参照
してください)


File: emacs-ja.info,  Node: Change Log,  Next: Xref,  Prev: Version Control,  Up: Maintaining

28.2 変更ログ
=============

多くのソフトウェアプロジェクトでは、“変更ログ(change log)”を管理します。
これは通常、いつどのようにして、そのプログラムが変更されたかの日付順の記
録を含む、‘ChangeLog’という名前のファイルです。これらのファイルは、バー
ジョンコントロールシステムに保存された変更ログエントリーから自動的に生成
されたり、それらの変更ログエントリーを自動的に生成するのに使われる場合も
あります。複数の変更ログファイルがあり、それぞれが1つのディレクトリー、
またはディレクトリーツリーに対応する場合もあります。

* Menu:

* Change Log Commands::      変更ログファイルを編集するためのコマンド。
* Format of ChangeLog::      変更ログファイルがどのように見えるか。


File: emacs-ja.info,  Node: Change Log Commands,  Next: Format of ChangeLog,  Up: Change Log

28.2.1 変更ログコマンド
-----------------------

Emacsコマンド‘C-x 4 a’は、編集しているファイルにたいする新しいエントリー
を、変更ログファイルに追加します(‘add-change-log-entry-other-window’)。
そのファイルが実際にはバックアップファイルの場合、このコマンドはそのファ
イルの元のファイルのエントリーを適切に作成します — これはカレントバージ
ョンから削除された関数のログエントリーを作成するとき便利です。

   ‘C-x 4 a’は変更ログファイルをvisitして、一番最近のエントリーが今日の
日付であなたの名前でない場合は、新しいエントリーを作成します。これはカレ
ントファイルにたいする、新しいアイテムも作成します。このコマンドは多くの
言語にたいして、変更された関数またはその他のオブジェクトを推測することす
らできます。

   変更ログファイルを探すために、Emacsは編集中ファイルのディレクトリーか
らディレクトリー構造を上方に検索します。デフォルトでは、バージョンコント
ロールディレクトリーのルートと思われるディレクトリーが見つかると、検索は
ストップします。これを変更するには、‘change-log-directory-files’をカスタ
マイズしてください。

   変数‘add-log-keep-changes-together’が非‘nil’の場合、‘C-x 4 a’は新しい
アイテムを開始せず、そのファイルにたいする既存のアイテムに追加します。

   同じ性質の複数の変更を1つにまとめることができます。最初の‘C-x 4 a’の
後にテキストを何も入力せずに、続けて‘C-x 4 a’をタイプしていくと、他のシ
ンボルが変更ログエントリーに追加されます。

   ‘add-log-always-start-new-record’が非‘nil’の場合、最後のエントリーが
同じ日付のあなたによる変更だったときでも、‘C-x 4 a’は常に新しいエントリ
ーを作成します。

   変数‘change-log-version-info-enabled’の値が非‘nil’の場合、‘C-x 4 a’は
、ファイルのバージョン番号を変更ログのエントリーに追加します。これは変数
‘change-log-version-number-regexp-list’の正規表現を使用して、ファイルの
最初の10%から、バージョン番号を探します。

   変更ログファイルは、Change Logモードでvisitされます。このメジャーモー
ドでは、グループ化されたアイテムの集まりは1つのパラグラフと扱われ。各エ
ントリーはページとみなされます。これはエントリーの編集を容易にします。
‘C-j’およびauto-fillは、新しい行を前の行と同様にインデントします。これは
エントリーの内容を入力するとき便利です。

   Change Logモードがオンの場合、‘next-error’コマンド(デフォルトでは‘C-x
`’にバインドされています)を使用して、変更ログのエントリー間を移動するこ
とができます。次の変更ログエントリーだけでなく、そのファイルが変更された
実際の場所にジャンプすることもあるでしょう。同じリストを戻って移動するの
に、‘previous-error’を使うこともできます。

   コマンド‘M-x change-log-merge’を使用して、他のログファイルを、エント
リーの日付順を保持したまま、Change Logモードのバッファーにマージできます
。

   プログラムの変更を追跡して変更ログを維持する他の方法として、バージョ
ンコントロールシステムがあります。VC logバッファーでは、‘C-c C-a’
(‘log-edit-insert-changelog’)とタイプすると、変更ログが存在する場合は、
関連する変更ログのエントリーを追加します。


File: emacs-ja.info,  Node: Format of ChangeLog,  Prev: Change Log Commands,  Up: Change Log

28.2.2 ChangeLogの書式
----------------------

変更ログエントリーは、現在の日付、名前(変数‘add-log-full-name’より取得
)、電子メールアドレス(変数‘add-log-mailing-address’より取得)を含むヘッダ
ー行から開始されます。ヘッダー行を除いた変更ログの各行は、スペースまたは
タブで開始されます。エントリーの大部分は、空白文字とアスタリスクで行が開
始される、“アイテム(items)”から構成されます。以下は2つのアイテムおよび
1つのアイテムをもつ、日付が1993年5月の、2つのエントリーの例です。

     1993-05-25  Richard Stallman  <rms@gnu.org>

             * man.el: Rename symbols 'man-*' to 'Man-*'.
             (manual-entry): Make prompt string clearer.

             * simple.el (blink-matching-paren-distance):
             Change default to 12,000.

     1993-05-24  Richard Stallman  <rms@gnu.org>

             * vc.el (minor-mode-map-alist): Don't use it if it's void.
             (vc-cancel-version): Doc fix.

   1つのエントリーで複数の変更を記述できます。変更はそれぞれアイテム、ま
たはアイテムの中の行を占めます。アイテムの間には通常、空行があります。ア
イテムが関連している場合(異なる場所での同じ変更など)、それらの間に空行を
置かずにそれらをグループ化します。

   変更ログファイルの最後には、著作権表示と使用許諾を配すべきです。以下
は例です:

     Copyright 1997, 1998 Free Software Foundation, Inc.
     Copying and distribution of this file, with or without modification, are
     permitted provided the copyright notice and this notice are preserved.

これはもちろん、正しい年と版権所有者に置き換えて使う必要があります。


File: emacs-ja.info,  Node: Xref,  Next: EDE,  Prev: Change Log,  Up: Maintaining

28.3 識別子のリファレンスを探す
===============================

“識別子(identifier)”とは、プログラムの構文的なサブユニットの名前であり、
関数(function)、サブルーチン(subroutine)、メソッド(method)、クラス
(class)、データ型(data type)、マクロ(macro)などが該当します。プログラミ
ング言語では、識別子はその言語の構文をもつシンボルです。そのプログラムの
開発と保守では、プロジェクト全体を横断して識別子をリネームする等から、識
別子がどこで定義されているか(defined)、どこから参照されているか
(referenced)を素早く見つける能力が求められます。

   これらの能力は、プログラミング言語をサポートするよう定義されたモード
以外のメジャーモードでも、リファレンスを見つけるために有用です。たとえば
テキストやTeXドキュメントのチャプター(chapters)、セクション(sections)、
アペンディクス(appendices)も同様にサブユニットとなり得るし、それらの名前
も識別子として使用できます。このチャプターでは、プログラムのソース、同様
に他の種類のテキストの中の、任意の種類のサブユニットの名前を正確に参照す
るために、“識別子(identifiers)”という用語を使用します。

   これらの能力のために、Emacsは‘xref’と呼ばれる統一されたインターフェー
スを提供します。

   ‘xref’が処理を行なうには、そのメジャーモード特有の情報とメソッドを使
用する必要があります。どのファイルから識別子を検索するか、識別子にたいす
るリファレンス(references: 参照)を探す方法、識別子を補完する方法、これら
(およびそれ以上のこと)は、モード固有の知識です。‘xref’は処理のモード固有
な部分を、そのモードにより提供される“バックエンド(backend)”に委託します
。これには、いくつかのコマンドにたいするデフォルトや、そのモード自体が提
供しないモードにたいするデフォルトも含まれます。

   バックエンドはこれらの能力をさまざまな方法で実装できます。いくつかの
例を示します:

  a. その言語のシンボルを探すために、ビルトインの方法を提供するモードが
     いくつかあります。たとえばEmacs Lispのシンボルは、パッケージのロー
     ド履歴からの検索から識別され、Emacs Lispインタープリターにより保守
     され、ビルトインのドキュメント文字列(built-in documentation
     strings)で調べます。シンボル定義を探すために、Emacs Lispモードは、
     モードのバックエンドの中の、これらの機能を使用します(この種のバック
     エンドの不利な点の1つは、インタープリターにロードされたサブユニット
     しか認識しないことです)。

  b. 外部プログラムは関連するファイルをスキャンしてリファレンスを抽出し
     て、これらにたいするデータベースをビルドすることができます。リファ
     レンスをリストしたり調べるために、バックエンドは必要なときにこのデ
     ータベースにアクセスできます。Emacsのディストリビューションには
     ‘etags’が含まれています。これはプログラム中の識別子の定義にタグ付け
     するコマンドで、リファレンスを“タグテーブル(tags tables)”に抽出する
     ことにより、多くのプログラミング言語、およびHTMLのようなその他のモ
     ードをサポートします。*note Create Tags Table::を参照してください。
     ‘etags’によりサポートされた言語にたいするメジャーモードは、そのバッ
     クエンドの基準でタグテーブルを使用できます(この種のバックエンドの不
     利な点の1つは、タグテーブルは有効性を維持するために最新である必要が
     あり、度々リビルドしなければならないことです)。

* Menu:

* Find Identifiers::         識別子のリスト等のために、識別子がどこで定義されているか、どこから参照されているかを探すコマンド。
* Tags Tables::              タグテーブルはシンボルがどのファイルで定義されているかを記録します。
* Select Tags Table::        特定のタグテーブルをvisitする方法。


File: emacs-ja.info,  Node: Find Identifiers,  Next: Tags Tables,  Up: Xref

28.3.1 識別子を探す
-------------------

このサブセクションでは識別子にたいするリファレンスを探したり、識別子にた
いしてさまざまな問い合わせを行なうコマンドを説明します。リファレンスは識
別子を_定義(define)_するかもしれません(プログラム内のサブユニットを実装
、ドキュメントのセクションのテキストなど)。あるいは識別子を_使用(use)_す
るかもしれません(関数やメソッドの呼び出し、変数への値の割り当て、クロス
リファレンスで引用されるチャプターなど)。

* Menu:

* Looking Up Identifiers::   識別子の定義を見つけるコマンド。
* Xref Commands::            ‘*xref*’バッファーでのコマンド。
* Identifier Search::        識別子の検索と置換。
* List Identifiers::         識別子をリストして、それらを補完する。


File: emacs-ja.info,  Node: Looking Up Identifiers,  Next: Xref Commands,  Up: Find Identifiers

28.3.1.1 識別子のルックアップ
.............................

‘xref’が可能にすることの中で一番重要なのは、指定した識別子の定義を探すこ
とです。

‘M-.’
     識別子の最初の定義を探します(‘xref-find-definitions’)。
‘C-M-. PATTERN <RET>’
     PATTERNにマッチする名前の識別子を探します(‘xref-find-apropos’)。
‘C-x 4 . <RET>’
     識別子の最初の定義を探して、他のウィンドウに表示します
     (‘xref-find-definitions-other-window’)。
‘C-x 5 . <RET>’
     識別子の定義を探して、それを新しいフレームに表示します
     (‘xref-find-definitions-other-frame’)。
‘M-,’
     前に‘M-.’または同種のコマンドを呼び出した場所に戻ります
     (‘xref-pop-marker-stack’)。
‘M-x xref-etags-mode’
     ‘etags’バックエンドを使用するように、‘xref’を切り替えます。

   ‘M-.’ (‘xref-find-definitions’)は、ポイント位置の識別子の定義を表示し
ます。プレフィックス引数を与えた、またはポイント位置に識別子がない場合は
、識別子の入力を求めます(常に識別子を尋ねるようにしたい場合は、
‘xref-prompt-for-identifier’を‘t’にカスタマイズする)。

   指定された識別子の定義が1つだけの場合は、その定義にジャンプします。識
別子に該当する定義が複数ある場合(たとえばオブジェクト指向言語や、同じな
前の関数や変数がある場合)、‘*xref*’バッファーに定義の候補と、その定義が
見つかったファイルを表示します。候補の選択は、定義の候補で‘<RET>’をタイ
プするか‘mouse-2’をクリックして行い、これにより対応する定義を表示するバ
ッファーがポップアップします。

   ‘M-.’の引数に識別子を入力するとき、通常のミニバッファーの補完コマンド
を使用できます(*note Completion::を参照してください)。補完では、既知の識
別子の名前が補完候補になります。

   バッファーを切り替えるほとんどのコマンドと同様に、
‘xref-find-definitions’は新しいバッファーを他のウィンドウ、または新しい
バッファーのために新しいフレームを作成する変種をもっています。前者は
‘C-x 4 .’ (‘xref-find-definitions-other-window’)、後者は‘C-x 5 .’
(‘xref-find-definitions-other-frame’)です。

   コマンド‘C-M-.’ (‘xref-find-apropos’)は、指定した正規表現にマッチする
１つ以上の識別子を探します。これは‘M-.’と同じですが、固定長文字列として
評価されたシンボル名にたいするマッチではなく、regexpにマッチする識別子で
す。

   上記コマンドにより複数の定義が見つかった場合は、候補となる定義を
‘*xref*’バッファーに表示します。このバッファーでは、*note Xref
Commands::で説明されている、複数の特化されたコマンドが使用できます。

   定義の検索を_開始した場所_に戻るには、‘M-,’
(‘xref-pop-marker-stack’)を使用します。これは最後に‘M-.’を呼び出したポイ
ントにジャンプします。したがって、‘M-.’により何らかの定義を見つけて確認
したら、‘M-,’で戻ることができます。‘M-,’は変数
‘xref-marker-ring-length’により決定される深さ(デフォルトは16)で、ステッ
プを再トレースできます。

   いくつかのメジャーモードは、特定の識別子の検索に失敗するかもしれない
‘xref’サポート機能をインストールするかもしれません。たとえば、Emacs
Lispモード(*note Lisp Eval::を参照)では、デフォルトでは‘M-.’はカレント
Emacsセッションにロードされた、あるいは自動ロード(*note
(elisp)Autoload::を参照)されるLispパッケージの関数と変数だけを検索します
。‘M-.’が何らかの識別子の検索に失敗する場合は、‘xref’に‘etags’バックエン
ド(*note Xref::を参照)の使用を強制することができます。これを行うには、
‘M-x xref-etags-mode’を呼び出してXref Etagsマイナーモードをオンに切り替
えて、再度‘M-.’を呼び出します(これが機能するためには、ソースファイルのデ
ィレクトリーツリー内でtagテーブルを作成するために、必ず‘etags’を実行する
こと。*note Create Tags Table::を参照されたい)。


File: emacs-ja.info,  Node: Xref Commands,  Next: Identifier Search,  Prev: Looking Up Identifiers,  Up: Find Identifiers

28.3.1.2 ‘*xref*’バッファーで利用可能なコマンド
...............................................

以下のコマンドは‘*xref*’バッファーのXREFモードにより提供されるコマンドで
す:

‘<RET>’
‘mouse-2’
     カレント行のリファレンスを表示します。

‘n’
‘.’
     次のリファレンスに移動して、それを別のウィンドウに表示します
     (‘xref-next-line’)。

‘p’
‘,’
     前のリファレンスに移動して、それを別のウィンドウに表示します
     (‘xref-prev-line’)。

‘C-o’
     カレント行のリファレンスを別のウィンドウに表示します
     (‘xref-show-location-at-point’)。

‘<TAB>’
     カレント行のリファレンスを表示して、‘*xref*’バッファーを隠し
     (bury)ます(‘xref-quit-and-goto-xref’)。

‘r PATTERN <RET> REPLACEMENT <RET>’
     PATTERNにマッチするリファレンスにたいしてインタラクティブな問い合わ
     せつき置換(query-replace)を行ない、マッチをREPLACEMENTに置換します
     。*note Identifier Search::を参照してください。

‘q’
     ‘*xref*’バッファーを表示しているウィンドウをquitします
     (‘xref-quit’)。

   これらに加えて、リファレンスを表示せずにバッファー内を移動するために
、‘C-n’や‘C-p’のような、通常のナビゲーションコマンドも利用可能です。


File: emacs-ja.info,  Node: Identifier Search,  Next: List Identifiers,  Prev: Xref Commands,  Up: Find Identifiers

28.3.1.3 識別子の検索と置換
...........................

このセクションのコマンドは、識別子自身、またはファイル内の識別子にたいす
るリファレンスにたいして、様々な検索と置換を行ないます。

‘M-?’
     ポイント位置の識別子にたいする、すべてのリファレンスを探します。

‘M-x xref-query-replace-in-results <RET> REGEXP <RET> REPLACEMENT <RET>’
     ‘*xref*’バッファーに表示されているすべての識別子の名前にたいして、
     REGEXPをREPLACEMENTにインタラクティブに置換します。

‘M-x tags-search <RET> REGEXP <RET>’
     選択されたタグテーブルのファイルから、REGEXPを検索します。

‘M-x tags-query-replace <RET> REGEXP <RET> REPLACEMENT <RET>’
     選択されたタグテーブルの各ファイルにたいして、
     ‘query-replace-regexp’を実行します。

‘M-x tags-loop-continue’
     ポイントのカレント位置から、上記コマンドの最後の2つを再開します。

   ‘M-?’は、ポイント位置の識別子にたいして、すべてのリファレンスを探しま
す。ポイント位置に識別子がない場合、またはプレフィクス引数が指定された場
合、このコマンドは補完つきで識別子の入力を求めます。それから、その識別子
にたいするすべてのリファレンスについて、ファイル名と識別子が参照されてい
る行を、‘*xref*’バッファーに表示します。このバッファーではXREFモードのコ
マンドが利用可能です。*note Xref Commands::を参照してください。

   ‘M-x xref-query-replace-in-results’は、通常の‘M-x
query-replace-regexp’と同様に、識別子の名前にマッチするregexpと、置換す
る文字列を読み取ります。それから、その識別子が参照されている、すべてのフ
ァイルのすべての場所で、マッチする識別子の名前にたいして指定された置換を
行ないます。これはリファクタリングの一部として、識別子のリネームを行なう
ときに有用です。このコマンドは‘M-?’により生成された‘*xref*’バッファーで
呼び出されるべきです。

   ‘M-x tags-search’は、ミニバッファーを使用してregexpを読み取り、選択さ
れたタグテーブルのすべてのファイルから、1ファイルずつマッチを検索します
。これは検索しているファイル名を表示するので、進行状況を確認することがで
きます。マッチが見つかった場合、‘tags-search’はリターンします。このコマ
ンドには利用可能なタグテーブル(*note Tags Tables::を参照してください)が
必要です。

   ‘tags-search’で1つのマッチが見つかったら、おそらく残りのすべてについ
ても検索したいと思うでしょう。‘M-x tags-loop-continue’は、多くのマッチを
探すために‘tags-search’を再開します。これはカレントバッファーの残りの部
分を検索して、その後タグテーブルの残りのファイルを検索します。

   ‘M-x tags-query-replace’は、タグテーブルのすべてのファイルにたいして
、1つの‘query-replace-regexp’を実行します。これは、通常の‘M-x
query-replace-regexp’と同様、検索するregexpと、それを置換する文字列を読
み取ります。この検索はむしろ‘M-x tags-search’に似ていますが、入力へのマ
ッチを繰り返し処理します。問い合わせ付き置換については、*note Query
Replace::を参照してください。

   変数‘tags-case-fold-search’の値をカスタマイズすることにより、タグ検索
コマンドの大文字小文字の扱いを制御できます。デフォルトには、
‘case-fold-search’の値と同じ設定が使用されます(*note Lax Search::を参照
してください)。

   1回の‘M-x tags-query-replace’の呼び出しで、タグテーブルのすべてのファ
イルを検索することが可能です。しかし、一時的に検索を抜けられると便利なと
きもあります。これは、問い合わせ付き置換として特別な意味をもたない入力イ
ベントで行うことができます。つづけて問い合わせ付き置換を再開するには、
‘M-x tags-loop-continue’とタイプします。このコマンドは、最後のタグ検索ま
たは置換コマンドを再開します。たとえばカレントファイルの残りをスキップす
るには、‘M-> M-x tags-loop-continue’とタイプします。

   上記で説明したコマンドは、‘xref-find-definitions’系の検索より広範な検
索を行うことに注意してください。‘xref-find-definitions’コマンドは、部分
文字列または正規表現にマッチする識別子の定義だけを検索します。コマンド
‘xref-find-references’、‘tags-search’、‘tags-query-replace’は、通常の検
索および置換コマンドがカレントバッファーにたいして行うように、識別子また
はregexpにたいするマッチを検索します。

   ‘xref-find-references’や‘tags-search’のかわりに、サブプロセスとして
‘grep’を実行して、Emacsにマッチした行を1つずつ表示させることができます。
*note Grep Searching::を参照してください。


File: emacs-ja.info,  Node: List Identifiers,  Prev: Identifier Search,  Up: Find Identifiers

28.3.1.4 識別子の照会
.....................

‘C-M-i’
‘M-<TAB>’
     タグテーブルがロードされているときは、できるだけ選択されたタグテー
     ブルを使って、ポイント周囲のテキストの置換を行います
     (‘completion-at-point’)。

‘M-x xref-find-apropos <RET> REGEXP <RET>’
     REGEXPにマッチする、既知のすべての識別子のリストを表示します。

‘M-x list-tags <RET> FILE <RET>’
     プログラムファイルFILEで定義されている識別子のリストを表示します。

‘M-x next-file’
     選択されたタグテーブルに記録されているファイルをvisitします。

   プログラミング言語のモードのほとんどでは、‘C-M-i’または‘M-<TAB>’
(‘completion-at-point’)とタイプして、ポイント位置のシンボルを補完できま
す。このコマンドのために、モードに特化した補完候補を提供するモードもあり
ます。補完候補を提供しないモードでは、選択されたタグテーブルがある場合、
補完候補を生成するためにこのコマンドを使用することができます。*note
Symbol Completion::を参照してください。

   ‘M-x list-tags’は、選択されたタグテーブルでカバーされたファイルの名前
を1つ読み取り、そのファイルで定義されたタグのリストを表示します。タグテ
ーブルに記録されたファイル名にディレクトリーが含まれない場合は、ファイル
名にディレクトリーを含めないでください。このコマンドはバックエンドが
etagsのときだけ機能し、そのプロジェクトのために利用可能なタグテーブルが
必要です。*note Tags Tables::を参照してください。

   ‘M-x next-file’は、選択されたタグテーブルでカバーされるファイルを
visitします。最初に呼び出したとき、テーブルでカバーされた最初のファイル
をvisitします。続けて呼び出すことにより、次のカバーされたファイルを
visitしていきます。プレフィクス引数を指定した場合、最初のファイルに戻り
ます。このコマンドには、選択されたタグテーブルが必要です。


File: emacs-ja.info,  Node: Tags Tables,  Next: Select Tags Table,  Prev: Find Identifiers,  Up: Xref

28.3.2 タグテーブル
-------------------

“タグテーブル(tags table)”は、特定のプログラムまたはドキュメントのソース
コードをスキャンすることにより抽出されたタグ(1)を記録します。生成された
ファイルから抽出されたタグは、タグ抽出の際にスキャンされる生成されたファ
イルではなく、その元になるファイルを参照します。生成されたファイルの例と
して、Cwebソース、Yaccパーサー、Lexスキャナー定義から生成されたCファイル
や、プリプロセスされたCファイルの‘.i’、‘.fpp’ソースファイルをプリプロセ
スすることにより生成されるFortranファイルがあります。

   タグテーブルを生成するには、ドキュメントまたはソースコードファイルに
たいして、シェルコマンド‘etags’を実行します。‘etags’プログラムは、“タグ
テーブルファイル(tags table file)”、または略記して“タグファイル(tags
file)”にタグを書き込みます。タグファイルは慣習的に‘TAGS’という名前です。
*note Create Tags Table::を参照してください(同じフォーマットでこのような
テーブルを生成できる他のコマンドを使用して、タグテーブルを作成することも
可能です)。

   Emacsは、‘xref’にたいするサポートされたバックエンドとして、‘etags’パ
ッケージを通じてタグテーブルを使用します。タグテーブルはEmacsディストリ
ビューションの一部である‘etags’コマンドにより生成されるので、ここではタ
グテーブルについて、より詳細に説明します。

   Ebrowse機能は‘etags’に似ていますが、C++に特化したものです。*note
Ebrowse: (ebrowse)Top.を参照してください。 Semanticパッケージは、
‘etags’機能とは別の、タグを生成して使用する他の方法を提供します。*note
Semantic::を参照してください。

* Menu:

* Tag Syntax::               さまざまなタイプのコードおよびテキストファイルにたいするタグ構文。
* Create Tags Table::        ‘etags’によるタグテーブルの作成。
* Etags Regexps::            正規表現を使用した任意タグの作成。

   ---------- Footnotes ----------

   (1) “tag”は、識別子リファレンスの同義語です。‘etags’パッケージにもと
づいたコマンドおよび機能では、伝統的に“tag”という用語をこの意味に使用し
ます。以下のサブセクションでは、この伝統にしたがいます。


File: emacs-ja.info,  Node: Tag Syntax,  Next: Create Tags Table,  Up: Tags Tables

28.3.2.1 ソースファイルタグの構文
.................................

以下は、もっともポピュラーな言語でタグ構文が定義される方法です:

   • Cコードでは、Cの関数やtypedefはタグなので、‘struct’、‘union’、
     ‘enum’の定義もタグです。タグテーブルを作成するとき、
     ‘--no-defines’を指定しなければ、‘#define’マクロ定義、‘#undef’および
     ‘enum’定数もタグになります。同様に、‘--no-globals’を指定しなければ
     グローバル変数もタグで、‘--no-members’を指定していなければ構造体の
     メンバーもタグです。‘--no-globals’、‘--no-defines’、
     ‘--no-members’を使用することにより、タグテーブルを小さくすることが
     できます。

     ‘etags’に‘--declarations’オプションを与えることにより、関数定義
     (function definitions)に加えて、関数宣言(function declarations)と外
     部変数(external variables)もタグ付けできます。

   • C++コードでは、Cコードのすべてのタグ構成に加えて、メンバー関数も認
     識されます。‘--no-members’オプションを使用しなければ、メンバー変数
     も認識されます。‘operator’定義は、‘operator+’のような名前をもちます
     。‘--class-qualify’オプションを指定した場合、クラスの変数および関数
     にたいするタグは、‘CLASS::VARIABLE’および‘CLASS::FUNCTION’という名
     前になります。デフォルトでは、クラスのメソッドとメンバーはクラス修
     飾されていません。これにより、ソース内でより正確に、それらの名前が
     識別可能になります。

   • Javaコードでは、C++で認識されるのすべてのタグ構成に加えて、
     ‘interface’、‘extends’、‘implements’もタグとして認識されます。クラ
     スの変数および関数にたいするタグは、‘CLASS.VARIABLE’および
     ‘CLASS.FUNCTION’という名前になります。

   • LaTeXドキュメントでは、‘\chapter’、‘\section’、‘\subsection’、
     ‘\subsubsection’、‘\eqno’、‘\label’、‘\ref’、‘\cite’、‘\bibitem’、
     ‘\part’、‘\appendix’、‘\entry’、‘\index’、‘\def’、‘\newcommand’、
     ‘\renewcommand’、‘\newenvironment’、‘\renewenvironment’にたいする引
     数がタグになります。

     ‘etags’を呼び出す前に、環境変数‘TEXTAGS’で指定することにより、他の
     コマンドも同様にタグにできます。この環境変数の値には、コロンで区切
     られたコマンド名のリストを指定します。たとえば、

          TEXTAGS="mycommand:myothercommand"
          export TEXTAGS

     これは、(Bourneシェルの構文の使用して)コマンド‘\mycommand’と
     ‘\myothercommand’もタグとして定義します。

   • Lispコードでは、‘defun’で定義された任意の関数、‘defvar’および
     ‘defconst’で定義された任意の変数、および一般的に列0から‘(def’で始ま
     る任意の式の最初の引数はタグです。例外として‘(defvar FOO)’という形
     式の式は、宣言として扱われ、‘--declarations’オプションが与えられた
     ときだけタグになります。

   • Schemeコードでは、‘def’で定義されたすべて、または名前が‘def’で始ま
     る構成がタグに含まれます。これらは、ファイルのトップレベルで
     ‘set!’でセットされる変数も含まれます。

   他の言語もいくつかサポートされます:

   • Adaコードでは、関数(functions)、プロシージャー(procedures)、パッケ
     ージ(packages)、タスク(tasks)、タイプ(types)がタグです。
     ‘--packages-only’オプションを使用することにより、タグをパッケージに
     たいしてだけ作成できます。

     Adaでは、異なる種類のエンティティー(たとえば関数とプロシージャー)に
     、同じ名前を使うことができます。またパッケージ、プロシージャー、関
     数と似たものに、スペック(spec、たとえばinterface)およびボディー
     (body、たとえばimplementation)があります。欲しい定義を簡単に取り出
     すために、Adaのタグ名にはエンティティーのタイプを示す接尾辞がつきま
     す:

     ‘/b’
          パッケージのボディー(package body)。
     ‘/f’
          関数(function)
     ‘/k’
          タスク(task)。
     ‘/p’
          プロシージャー(procedure)。
     ‘/s’
          パッケージのスペック(package spec)。
     ‘/t’
          タイプ(type)。

     したがって、‘M-x find-tag <RET> bidule <RET>’は単に‘bidule’という任
     意のタグを検索しますが、‘M-x find-tag <RET> bidule/b <RET>’は直接パ
     ッケージ‘bidule’のボディーに移動します。

   • アセンブラーコードでは、行の開始に現れ、後にコロンが続くラベルがタ
     グです。

   • BisonまたはYaccの入力ファイルでは、各構文規則で定義する非終端記号が
     タグです。ファイル内に含まれるCコードの部分は、Cコードとして解析し
     ます。

   • Cobolコードでは、タグはパラグラフ名なので、列8から始まり、後にピリ
     オドが続く任意の単語がタグです。

   • Erlangコードでは、ファイルで定義された関数(functions)、レコード
     (records)、マクロ(macros)がタグです。

   • Fortranコードでは、サブルーチン(subroutines)およびブロックデータ
     (block data)がタグです。

   • Goコードでは、関数(functions)、タイプ(types)がタグです。

   • HTML入力ファイルでは、‘title’、および‘h1’、‘h2’、‘h3’ヘッダーがタグ
     です。アンカー内の‘name=’、およびすべての‘id=’もタグです。

   • Lua入力ファイルでは、すべての関数(functions)がタグです。

   • makefileでは、ターゲット(targets)がタグで、‘--no-globals’を指定しな
     ければ変数(variables)もタグです。

   • Objective Cコードでは、クラスにたいするObjective C定義、クラスカテ
     ゴリー(class categories)、メソッド(methods)、プロトコル
     (protocols)が含まれます。クラスの変数および関数にたいするタグの名前
     は、‘CLASS::VARIABLE’および‘CLASS::FUNCTION’になります。

   • Pascalコードでは、ファイル内で定義された関数およびプロシージャーが
     タグです。

   • Perlコードでは、パッケージ、サブルーチン、変数がタグで、キーワード
     ‘package’、‘sub’、‘use constant’、‘my’、‘local’で定義されます。グロ
     ーバル変数をタグ付けしたい場合、‘--globals’を使用します。サブルーチ
     ンにたいするタグの名前は、‘PACKAGE::SUB’になります。デフォルトのパ
     ッケージで定義されたサブルーチンの名前は、‘main::SUB’になります。

   • PHPコードでは、関数(functions)、クラス(classes)、定義(defines)がタ
     グです。‘--no-members’オプションを使用しなければ、変数(vars)もタグ
     です。

   • PostScriptコードでは、関数がタグです。

   • Prologコードでは、行頭の述語(predicates)とルール(rules)がタグです。

   • Pythonコードでは、行頭の‘def’および‘class’はタグを生成します。

   • Rubyコードでは、行の先頭にある‘def’、‘class’、‘module’はタグを生成
     します。定数もタグを生成します。

   他の書式や言語を扱うために、regexpにたいするマッチにもとづいてタグを
生成することもできます(*note Etags Regexps::を参照してください)。


File: emacs-ja.info,  Node: Create Tags Table,  Next: Etags Regexps,  Prev: Tag Syntax,  Up: Tags Tables

28.3.2.2 タグテーブルの作成
...........................

‘etags’プログラムは、タグテーブルファイルを作成するために使用されます。
このコマンドは、 *note Tag Syntax::で説明している複数の構文を理解します
。 以下は‘etags’を実行する方法です:

     etags INPUTFILES...

‘etags’プログラムは、指定されたファイルを読み込んで、カレント作業ディレ
クトリーの‘TAGS’という名前のファイルに、タグテーブルを書き込みます。
‘--output=FILE’オプションを使用して、タグテーブルに異なる名前のファイル
名を指定することもできます。ファイル名に‘-’を指定すると、タグテーブルを
標準出力に出力します。‘--append’オプションを使用して、既存のファイルに新
たに作成したtagテーブルを追加することもできます。

   指定されたファイルが見つからない場合、‘etags’はそれらの圧縮されたバー
ジョンを探して、それらを解凍して読み込みます。MS-DOSでは、コマンドライン
に‘mycode.c’が与えられ、‘mycode.c’が存在しないとき、‘etags’は
‘mycode.cgz’のような名前のファイルを探します。

   ファイルの内容が変更されてタグテーブルが古くなったときは、‘etags’を再
び実行することにより、タグテーブルを更新できます。タグテーブルにタグが記
録されていなかったり、間違ったファイルにたいして記録している場合、タグテ
ーブルを更新するまで、Emacsはそれの定義を見つけることができません。しか
しタグに記録されている位置が、(編集により)少し間違っているようなときは、
少しの遅れは生じますがEmacsは正しい位置を見つけることができます。

   したがって、編集するたびにタグテーブルを更新する必要はありません。リ
ストしたい新しいタグを定義したときや、タグ定義をあるファイルから他のファ
イルへ移動したとき、または大幅な変更を施したときは、タグテーブルを更新す
るべきです。

   ‘etags’に‘--include=FILE’オプションを渡すことにより、タグテーブルに他
のタグテーブルを“インクルード(include)”できます。これによりインクルード
されたタグファイルでカバーされる、すべてのファイルをカバーできます。

   ‘etags’を実行するとき、ソースファイルを相対ファイル名で指定した場合、
タグファイルには、そのタグファイルが最初に書き込まれたディレクトリーにた
いする相対ファイル名が含まれます。この方法を使えば、ディレクトリーツリー
全体を移動しても、タグファイルは正しくソースファイルを参照します。しかし
タグファイルが‘-’または‘/dev’のときは、ファイル名はカレント作業ディレク
トリーにたいする相対ファイル名になります。これはタグを標準出力に書き込む
ときに便利です。

   相対ファイル名を使う場合、違うディレクトリーにあるタグファイルを指す
シンボリックリンクを指定するべきではありません。なぜならこれは一般的にフ
ァイル名を無効にするからです。

   ‘etags’の引数に絶対ファイル名を指定した場合、タグファイルには絶対ファ
イル名が含まれます。この方法では、ソースファイルが同じ場所にある限り、タ
グファイルを移動してもタグファイルは同じ名前を参照します。絶対ファイル名
は‘/’で開始されるか、MS-DOSおよびMS-Windowsでは‘DEVICE:/’で開始されます
。

   非常に大きな数のファイルからタグテーブルを作成したい場合、それをコマ
ンドラインに指定すると問題が発生するかもしれません。なぜならコマンドライ
ン引数の長さに制限のあるシステムもあるからです。この制限は、以下のように
ファイル名の場所にダッシュを指定して、‘etags’にファイル名を標準入力から
読み込むように指示して回避することができます。

     find . -name "*.[chCH]" -print | etags -

   ‘etags’はファイル名とファイル内容にもとづいて、入力ファイルで使用され
ている言語を認識します。これは最初に、特定の言語にたいして一般的に使用さ
れるファイル名と拡張子にたいするマッチを試みます。いくつかの言語には、既
知の名前のインタープリター(Perlの‘perl’、Prologの‘pl’など)があるので、
‘etags’は次に入力ファイルの最初の行でインタープリター指定‘#!INTERP’を調
べて、既知のインタープリターとのマッチを行います。これが失敗、または言語
の自動検知をオーバーライドしたい場合は、‘--language=NAME’オプションで、
明示的に言語を指定できます。このオプションはファイル名に混ぜることができ
ます。各指定はその後に続くファイル名に適用されます。‘--language=auto’の
指定は、ファイル名とファイル内容から言語を推測するよう‘etags’に指示しま
す。‘--language=none’を指定すると、言語に特有の処理を完全にオフに切り替
えます。この場合、‘etags’はregexpのマッチングだけでタグを認識します
(*note Etags Regexps::を参照してください)。これは、‘etags’がまだサポート
していない言語を使用するファイルが入力の際に、‘etags’がデフォルト言語と
してFortranおよびCにフォールバックするのを抑止します。

   オプション‘--parse-stdin=FILE’は、‘etags’をプログラムから呼び出すとき
に便利です。これは、(1回だけ)コマンドラインからファイル名を読み取るとき
使用できます。‘etags’は標準入力から読み取り、生成されたタグがファイル
FILEに属するとマークします。

   ‘etags --help’オプションは‘etags’が認識する言語と、言語を推測するため
のファイル名ルールのリストを出力します。これは利用可能な‘etags’オプショ
ンと、簡単な説明のリストも出力します。このオプションの後に、1つ以上の
‘--language=LANG’を指定すると、LANGにたいするタグの生成方法の詳細を出力
します。


File: emacs-ja.info,  Node: Etags Regexps,  Prev: Create Tags Table,  Up: Tags Tables

28.3.2.3 EtagsのRegexps
.......................

‘--regex’オプションは、正規表現のマッチにもとづいて‘etags’がタグを認識で
きるようにします。このオプションはファイル名と混ぜることができます。オプ
ションは、それぞれのオプション後に続くソースファイルに適用されます。複数
の‘--regex’を指定した場合、それらすべては並列に使用されます。構文は以下
のとおりです:

     --regex=[{LANGUAGE}]/TAGREGEXP/[NAMEREGEXP/]MODIFIERS

オプション値の肝心な部分はTAGREGEXPで、これはタグにマッチするregexpです
。これは常に位置が固定されており、行の開始だけにマッチします。インデント
されたタグの場合、最初の空白文字にマッチさせるために、‘[ \t]*’で始まる
regexpを使用します。

   これらの正規表現では、‘\’は次の文字をクォートします。またCのエスケー
プ文字シーケンスのすべて、すなわち‘\a’(bell)、‘\b’(back space)、
‘\e’(escape)、‘\f’(formfeed)、‘\n’(newline)、‘\r’(carriage return)、
‘\t’(tab)、and ‘\v’(vertical tab)がサポートされます。これらに加えて、
‘\\d’は‘DEL’文字を意味します。

   理想的には、TAGREGEXPはタグとして認識させるのに必要な文字以上にマッチ
させるべきではありません。構文がそれを求める場合、タグより多くの文字にマ
ッチするTAGREGEXPを記述して、そのマッチからタグだけをピックアップするた
めに、NAMEREGEXPを追加するべきです。これはEmacsがより正しくタグを見つけ
て、タグ名の補完をより確実にすることを可能にします。NAMEREGEXP内において
はこれは、TAGREGEXP内でのカッコによるグループ化にたいする“後方参照(back
references)” (*note Regexp Backslash::を参照)として有用であり、頻繁に使
用されます。たとえば、‘\\1’はそのようなカッコによる最初のグループを参照
します。以下でいくつかの例を見つけることができるでしょう。

   MODIFIERS(修飾子)は、‘etags’がマッチングを行う方法を変更するための0文
字以上の文字シーケンスです。修飾子がないregexpは、大文字小文字を区別する
方法で、入力ファイルの各行にたいして順番に適用されます。修飾子とその意味
は以下のとおりです:

‘i’
     このregexpのマッチングで、大文字小文字を無視します。
‘m’
     この正規表現はファイル全体にマッチするので、複数行のマッチが可能で
     す。
‘s’
     この正規表現はファイル全体にマッチし、TAGREGEXP内の‘.’は改行にマッ
     チします。

   ‘-R’オプションは、それの前に‘--regex’で定義されたregexpをすべて取り消
します。これは後に続くファイル名にも適用されます。以下は例です:

     etags --regex=/REG1/i voo.doo --regex=/REG2/m \
         bar.ber -R --lang=lisp los.er

この例では、‘etags’は‘voo.doo’と‘bar.ber’にたいして。ファイル内容に一致
する解析用の言語を選択します。‘etags’は、‘voo.doo’内の追加のタグを認識す
るためにREG1も使用し、‘bar.ber’内の追加のタグを認識するためにREG1と
REG2の両方を使用します。‘voo.doo’と‘bar.ber’の各行にたいして大文字小文字
を区別せずにREG1がチェックされ、‘bar.ber’のファイル全体にたいして大文字
小文字を区別してREG2がチェックされ、これは複数行へのマッチが許されます。
‘los.er’のタグの認識にはユーザー指定のregexpマッチは行わず、Lispのタグル
ールだけが使用されます。

   オプションのプレフィクス{LANGUAGE}を使用して、与えられた言語だけに
‘--regex’オプションを制限できます(‘etags --help’で‘etags’が認識する言語
のリストが表示されます)。これはファイルに、‘etags’にたいして事前に定義さ
れた多くの正規表現が含まれている場合に便利です。以下の例は、EmacsのC言語
のソースファイルの‘DEFVAR’マクロにたいするタグです:

     --regex='{c}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/\1/'

正規表現が複雑な場合、そのリストをファイルに保存することができます。以下
のオプション構文は、‘etags’に正規表現が保存された2つのファイルを指示しま
す。2つ目のファイルに含まれる正規表現は、大文字小文字を区別せずにマッチ
します。

     --regex=@CASE-SENSITIVE-FILE --ignore-case-regex=@IGNORE-CASE-FILE

‘etags’にたいするregexファイルは、行ごとに1つの正規表現を含みます。空行
およびスペースかタブで始まる行は無視されます。表の開始が‘@’の場合、
‘etags’はその行の残りを他の正規表現ファイルとみなすので、そのようなファ
イルを他のファイルをインクルードできます。他のすべての行は正規表現です。
最初の非空白文字が‘--’の場合、その行はコメントです。

   たとえば、以下の内容の‘emacs.tags’という名前のファイルを作成できます:

             -- This is for GNU Emacs C source files
     {c}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/\1/

これは以下のように使用します:

     etags --regex=@emacs.tags *.[ch] */*.[ch]

   さらに例を示しましょう。regexpはシェルから解釈され内容にクォートされ
ています。

   • Octaveファイルのタグ:

          etags --language=none \
                --regex='/[ \t]*function.*=[ \t]*\([^ \t]*\)[ \t]*(/\1/' \
                --regex='/###key \(.*\)/\1/' \
                --regex='/[ \t]*global[ \t].*/' \
                *.m

     タグはスクリプトにたいして生成されるので、そのスクリプトにジャンプ
     したいときは、あなた自身で‘###key SCRIPTNAME’という形式の行を追加す
     る必要があることに注意してください。

   • Tclファイルのタグ:

          etags --language=none --regex='/proc[ \t]+\([^ \t]+\)/\1/' *.tcl

   • VHDLファイルのタグ:

          etags --language=none \
            --regex='/[ \t]*\(ARCHITECTURE\|CONFIGURATION\) +[^ ]* +OF/' \
            --regex='/[ \t]*\(ATTRIBUTE\|ENTITY\|FUNCTION\|PACKAGE\
            \( BODY\)?\|PROCEDURE\|PROCESS\|TYPE\)[ \t]+\([^ \t(]+\)/\3/'


File: emacs-ja.info,  Node: Select Tags Table,  Prev: Tags Tables,  Up: Xref

28.3.3 タグテーブルの選択
-------------------------

Emacsは常に、“選択された”タグテーブルを最大で1つもちます。タグテーブルに
たいして機能するすべてのコマンドは、選択されたタグテーブルを使用します。
タグテーブルを選択するには、‘M-x visit-tags-table’とタイプします。これは
、引数としてタグテーブルファイル名を読み取ります。デフォルトディレクトリ
ーの‘TAGS’がデフォルトです。

   Emacsは、タグテーブルを使用するまでは実際にタグテーブルの内容を読み込
みません。‘visit-tags-table’が行うのは、ファイル名を変数
‘tags-file-name’に格納することだけです。この変数の初期値は‘nil’です。こ
の変数の値は、タグテーブルにたいして機能するすべてのコマンドに、使用する
タグテーブルファイル名を知らせます。

   タグテーブルがすでにロードされているときに‘visit-tags-table’を使用す
ると、2つの選択肢が与えられます。つまり、タグテーブルのカレントリストに
新しいタグを追加するか、あるいは新しいリストを開始することもできます。タ
グコマンドは、カレントリストのすべてのタグテーブルを使用します。新しいリ
ストを開始した場合、他のものの_かわりに_、新しいタグテーブルが使用されま
す。カレントリストに新しいタグテーブルを追加した場合、それは他のものと
_同じように_使用されます。

   以下のようにして、変数‘tags-table-list’に文字列のリストをセットするこ
とにより、タグテーブルのリストを正確に指定できます:

     (setq tags-table-list
           '("~/.emacs.d" "/usr/local/lib/emacs/src"))

This tells the tags commands to look at the ‘TAGS’ files in your
‘~/.emacs.d’ directory and in the ‘/usr/local/lib/emacs/src’ directory.
The order depends on which file you are in and which tags table mentions
that file.

   ‘tags-file-name’と‘tags-table-list’の両方をセットしてはいけません。


File: emacs-ja.info,  Node: EDE,  Next: Emerge,  Prev: Xref,  Up: Maintaining

28.4 Emacs開発環境
==================

EDE(“Emacs Development Environment: Emacs開発環境”)は、Emacsでの大きなプ
ログラムの作成、ビルド、デバッグなどのタスクを単純化するパッケージです。
これはEmacsにおいて、IDE(“Integrated Development Environment: 統合開発環
境”)の機能をいくつか提供します。

   このセクションは、EDEの簡単な説明を提供します。 完全な詳細については
、*note EDE: (ede)Top.を参照してください。

   EDEは、グローバルなマイナーモードとして実装されています(*note Minor
Modes::を参照してください)。有効にするには‘M-x global-ede-mode’とタイプ
するか、‘Tools’メニューの‘Project Support (EDE)’アイテムをクリックします
。以下の行をinitファイルに追加することにより、Emacs開始時にEDEを有効にす
ることもできます。

     (global-ede-mode t)

EDEを有効にすることにより、メニューバーに‘Development’という名前のメニュ
ーが追加されます。以下で説明するコマンドを含めて、多くのEDEコマンドをこ
のメニューから呼び出すことができます。

   EDEは、ファイルを“プロジェクト(projects)”に編成します。プロジェクトは
ディレクトリーに対応します。“プロジェクトルート(project root)”は、プロジ
ェクトの最上層のディレクトリーです。新しいプロジェクトを定義するには、プ
ロジェクトルートのファイルをvisitして、‘M-x ede-new’とタイプします。この
コマンドは“プロジェクトタイプ(project type)”の入力を求めます。これは
EDEがプロジェクトを背後で管理する方式です(*note EDE: (ede)Creating a
project.を参照してください)。もっとも一般的なプロジェクトタイプは、
Makefilesを使用する‘Make’、およびGNU Automake(*note Automake:
(automake)Top.を参照してください)を使用する‘Automake’です。どちらの場合
も、EDEはプロジェクトに関する情報を格納する、‘Project.ede’という名前のフ
ァイルを作成します。

   プロジェクトには、1つ以上の“ターゲット(targets)”を含めることができま
す。ターゲットとは、プロジェクトの1つ以上のファイルからビルドされるオブ
ジェクトファイル、実行ファイル、またはその他の種類のファイルです。

   プロジェクトに新しい“ターゲット(target)”を追加するには、‘C-c . t’
(‘M-x ede-new-target’)とタイプします。このコマンドは、カレントファイルを
そのターゲットに追加するか尋ねます。これはターゲットがそのファイルからビ
ルドされることを意味します。ターゲットを定義した後は、‘C-c . a’
(‘ede-add-file’)とタイプすることにより、ターゲットにファイルを追加するこ
とができます。

   ターゲットをビルドするには、‘C-c . c’ (‘ede-compile-target’)とタイプ
します。プロジェクトのすべてのターゲットをビルドするには、‘C-c . C’
(‘ede-compile-project’)とタイプします。EDEはターゲットがどのようにビルド
されるべきか推測するために、ファイルタイプを使用します。


File: emacs-ja.info,  Node: Emerge,  Prev: EDE,  Up: Maintaining

28.5 Emergeでのファイルのマージ
===============================

行き違いの指示を受けて、同じプログラムを異なる2つの方向に修正してしまう
のは、プログラマーにとって珍しいことではありません。この混乱を正常な状態
に戻すには、2つのバージョンをマージする必要があります。Emergeはこれを簡
単にします。ファイルを比較する他の方法については、 *note Comparing
Files::、 および*note Ediff: (ediff)Top.を参照してください。

* Menu:

* Overview of Emerge::       Emergeを開始する方法と、基本的な概念。
* Submodes of Emerge::       Fastモード vs. Editモード。Skip
                               PrefersモードとAuto Advanceモード。
* State of Difference::      各相違にたいして、AまたはBの状態を指定することによりマージを行う。
* Merge Commands::           相違を選択したり、相違の状態を変更するコマンドなど。
* Exiting Emerge::           マージを終えた後に行うこと。
* Combining in Emerge::      相違にたいする両方の候補を維持する方法。
* Fine Points of Emerge::    その他の問題。


File: emacs-ja.info,  Node: Overview of Emerge,  Next: Submodes of Emerge,  Up: Emerge

28.5.1 Emergeの概要
-------------------

Emergeを開始するには、以下の4つのコマンドの1つを実行します:

‘M-x emerge-files’
     指定した2つのファイルをマージします。

‘M-x emerge-files-with-ancestor’
     共通の祖先(ancestor)を参照して、指定した2つのファイルをマージします
     。

‘M-x emerge-buffers’
     2つのバッファーをマージします。

‘M-x emerge-buffers-with-ancestor’
     第3のバッファーにある共通の祖先を参照して、2つのバッファーをマージ
     します。

   Emergeコマンドは2つのファイルまたはバッファーを比較して、3つのバッフ
ァーにそれ表示します。最初の2つは入力テキスト(“Aバッファー”と“Bバッファ
ー”)で、残りの1つ(“マージバッファー”)はどこにマージが行われたかを表示し
ます。マージバッファーは相違だけではなく、マージされたテキストをすべて表
示します。2つの入力テキストが異なる場所では、どちらをマージバッファーに
含めるか選択できます。

   既存のバッファーから入力を得るEmergeコマンドは、そのバッファーがナロ
ーされている場合は、バッファーのアクセス可能な部分だけを使用します。
*note Narrowing::を参照してください。

   2つのマージされるテキストの元となる、共通の祖先となるバージョンが利用
可能な場合は、Emergeはどちらが正しい候補かを推測するために、それを使用す
ることができます。一方のカレントバージョンが祖先に一致する場合、Emergeは
もう一方のカレントバージョンが、マージされたバージョンに残すべき、意図し
た変更であると仮定します。共通の祖先となるテキストを指定したい場合は、
‘with-ancestor’がつくコマンドを使用します。これらのコマンドは3つのファイ
ルまたはバッファーの名前 — バージョンA、バージョンB、そして共通の祖先の
名前を読み取ります。

   比較が終了してバッファーの準備ができた後、対話的なマージが開始されま
す。マージバッファーで特別な“マージコマンド”をタイプすることにより、マー
ジを制御できます(*note Merge Commands::を参照してください)。入力テキスト
の相違それぞれにたいして、どちらを残すか、または両方編集するか選択するこ
とができます。

   マージバッファーはこれらの選択を行うために、Emergeモードという特別な
メジャーモードを使用します。しかし、そのバッファーでは通常のEmacsコマン
ドで編集することもできます。

   常にEmergeの注目は、“選択された”相違と呼ばれる、特定の相違に焦点を置
きます。この相違は、3つのバッファーで以下のようにマークされます:

     vvvvvvvvvvvvvvvvvvvv
     TEXT THAT DIFFERS
     ^^^^^^^^^^^^^^^^^^^^

Emergeはすべての相違に順番に番号をふり、モードラインには選択された相違の
番号が常に表示されます。

   マージバッファーは通常、バージョンAのテキストで開始されます。しかしバ
ージョンAの相違が共通の祖先と一致する場合、その相違の初期値にはバージョ
ンBが優先されます。

   マージバッファーを抜けるとき、Emergeはマージされたテキストを残します
。このとき、‘C-x C-w’で、それをファイルに保存できます。‘emerge-files’ま
たは‘emerge-files-with-ancestor’に数引数を与えた場合、ミニバッファーを使
用して、出力するファイル名を読み取ります(これは、このコマンドが読み取る
ファイル名の最後のファイル名です)。その後Emergeから抜けると、マージされ
たテキストを出力ファイルに保存します。

   通常、Emergeコマンドは終了するとき出力バッファーを、そのバッファーの
ファイルに保存します。Emergeを‘C-]’で中断した場合、Emergeコマンドは出力
バッファーを保存しませんが、もし保存したいときは自分で保存することができ
ます。


File: emacs-ja.info,  Node: Submodes of Emerge,  Next: State of Difference,  Prev: Overview of Emerge,  Up: Emerge

28.5.2 Emergeのサブモード
-------------------------

マージコマンドに与える2つのモード — FastモードとEditモードを選択すること
ができます。Fastモードでは、基本的なマージコマンドは1文字ですが、通常の
Emacsコマンドは利用不可です。これはマージコマンドだけを使いたいときは便
利です。Editモードでは、すべてのマージコマンドはプレフィクスキー‘C-c
C-c’で始まり、通常のEmacsコマンドも利用可能です。これによりマージバッフ
ァーで編集することができますが、Emerge操作は遅くなります。

   ‘e’でEditモード、‘C-c C-c f’でFastモードに切り替わります。モードライ
ンにはEditモードおよびFastモードは、‘E’と‘F’で示されます。

   Emergeは、特定のマージコマンドがどのように機能するかに影響を与える、
2つの追加的なサブモード — Auto AdvanceモードとSkip Prefersモードがありま
す。

   Auto Advanceモードが効力をもつ場合、‘a’または‘b’コマンドで次の相違に
移動します。これは候補を単に選んでいくだけで、素早くマージすることができ
ます。Auto Advanceモードの場合、モードラインに‘A’が示されます。

   Skip Prefersモードが効力をもつ場合、‘n’および‘p’コマンドは、状態が
“prefer-A”と“prefer-B”の相違をスキップします(*note State of
Difference::を参照してください)。したがって、どちらのバージョンも正しい
と推定できない相違だけを見ていくことができます。Skip Prefersモードの場合
、モードラインに‘S’が示されます。このモードは祖先がある場合にだけ適して
います。

   Auto Advanceをセットまたはクリアーするには、コマンド‘s a’
(‘emerge-auto-advance’)を使用します。Skip Prefersモードをセットまたはク
リアーするには、‘s s’ (‘emerge-skip-prefers’)を使用します。これらのコマ
ンドは、正の引数の場合はモードをオンにして、負または0の引数のときはモー
ドをオフにし、引数がないときはモードのオン・オフを切り替えます。


File: emacs-ja.info,  Node: State of Difference,  Next: Merge Commands,  Prev: Submodes of Emerge,  Up: Emerge

28.5.3 相違の状態
-----------------

マージバッファーでは、相違は文字‘v’および‘^’のラインでマークされます。各
相違は、以下の7つの状態のうち1つをもちます:

A
     相違にはバージョンAが表示されています。‘a’コマンドは常にこの状態を
     生成します。モードラインには‘A’が示されます。

B
     相違にはバージョンBが表示されています。‘b’コマンドは常にこの状態を
     生成します。モードラインには‘B’が示されます。

default-A
default-B
     選択を行っていないので、相違にはデフォルトとしてAまたはBの状態が表
     示されています。すべての相違はdefault-A状態で開始されます(したがっ
     てマージバッファーはAバッファーのコピーとなります)が、例外として、
     もう一方のほうがpreferred(好ましい)な場合を除きます(以下参照)。

     相違を選択したときに、状態はdefault-Aまたはdefault-Bから、Aまたは
     Bに遷移します。したがって、選択された相違が状態default-Aまたは
     default-Bをもつことはなく、これらの状態がモードラインに表示されるこ
     とはありません。

     コマンド‘d a’は、デフォルトの状態にdefault-Aを選択し、‘d b’は
     default-Bを選択します。これらで選択されるデフォルトは、まだ1度も選
     択していないか、好ましい候補をもたないすべての相違に適用されます。
     順番に移動しながらマージを行っている場合、一度も選択されていない相
     違とは、選択された相違の後のすべての相違です。したがって順番に移動
     しながら、セクションの間で‘d a’と‘d b’を使い分けることにより、マー
     ジバッファーのあるセクションにたいしてはバージョンAをデフォルトに、
     他のセクションにはバージョンBを効果的に選択できます。

prefer-A
prefer-B
     相違には、状態Aまたは状態Bが表示されています。なぜなら、それが
     “preferred(好ましい)”からです。これはまだ明示的な選択を行なっていな
     いが、一方の候補は共通の祖先と同じなので、もう一方の候補の方が正し
     く見えることを意味します。したがってAバッファーが共通の祖先と同じ場
     合、バージョンBの方が好ましいといえます。なぜなら、それは実際に変更
     されているからです。

     これら2つの状態は、モードラインに‘A*’と‘B*’で表示されます。

combined
     ‘x c’または‘x C’コマンドの結果として、相違は状態Aおよび状態Bが混合
     されたものを表示しています。

     相違が1度この状態になると、‘a’コマンドと‘b’コマンドは、数引数を与え
     ないかぎり何もしません。

     モードラインには状態‘comb’が表示されます。


File: emacs-ja.info,  Node: Merge Commands,  Next: Exiting Emerge,  Prev: State of Difference,  Up: Emerge

28.5.4 マージコマンド
---------------------

以下はFastモードのマージコマンドです。Editモードでは前に‘C-c C-c’をつけ
てください:

‘p’
     前の相違を選択します。

‘n’
     次の相違を選択します。

‘a’
     この相違にバージョンAを選択します。

‘b’
     この相違にバージョンBを選択します。

‘C-u N j’
     番号Nの相違を選択します。

‘.’
     ポイントを含む相違を選択します。

‘q’
     終了 — マージを終了します。

‘C-]’
     中断 — マージをexitして出力を保存しません。

‘f’
     Fastモードに移行します(Editモードでは実際には‘C-c C-c f’です)。

‘e’
     Editモードに移行します。

‘l’
     3つのウィンドウにたいして、(‘C-l’のように)再センタリングをします。
     引数を指定すると、デフォルトの3ウィンドウ表示を再構築します。

‘-’
     数引数の一部を指定します。

‘DIGIT’
     これも数引数の一部を指定します。

‘d a’
     ポイント位置からマージバッファーの下方へ、バージョンAをデフォルトと
     して選択します。

‘d b’
     ポイント位置からマージバッファーの下方へ、バージョンBをデフォルトと
     して選択します。

‘c a’
     この相違のバージョンAを、killリングにコピーします。

‘c b’
     この相違のバージョンBを、killリングにコピーします。

‘i a’
     この相違のバージョンAを、ポイント位置に挿入します。

‘i b’
     この相違のバージョンBを、ポイント位置に挿入します。

‘m’
     相違の周囲に、ポイントとマークを配します。

‘^’
     3つのウィンドウすべてを、(‘M-v’のように)下にスクロールします。

‘v’
     3つのウィンドウすべてを、(‘C-v’のように)上にスクロールします。

‘<’
     3つのウィンドウすべてを、(‘C-x <’のように)左にスクロールします。

‘>’
     3つのウィンドウすべてを、(‘C-x >’のように)右にスクロールします。

‘|’
     3つのウィンドウすべての水平スクロールをリセットします。

‘x 1’
     マージウィンドウを1行に縮めます(フルサイズに復元するには‘C-u l’を使
     用します)。

‘x c’
     この相違の2つのバージョンを合成します(*note Combining in Emerge::を
     参照してください)。

‘x f’
     Emergeが操作しているファイルまたはバッファーの名前を、Helpウィンド
     ウに表示します(ウィンドウを復元するには‘C-u l’を使用します)。

‘x j’
     この相違を次の相違に結合します(‘C-u x j’は前の相違に結合します)。

‘x s’
     この相違を2つの相違に分割します。このコマンドを使う前に、3つのバッ
     ファーで、相違を分割したい位置にポイントを配してください。

‘x t’
     相違の上部と下部にある、同じ行を取り除きます。このような行は、バー
     ジョンAとバージョンBが同じでも、それらが祖先となるバージョンと異な
     る場合に発生します。


File: emacs-ja.info,  Node: Exiting Emerge,  Next: Combining in Emerge,  Prev: Merge Commands,  Up: Emerge

28.5.5 Emergeの終了
-------------------

‘q’コマンド(‘emerge-quit’)はマージを終了して、指定されている場合は結果を
出力ファイルに保存します。これはバッファーAおよびBの内容を正しいものに復
元するか、もしそれらがEmergeにより作成され、何も変更されていないときは
killします。これによりマージバッファーでEmergeコマンドは使えなくなります
。なぜならそれらを実行することにより、さまざまなバッファーの内容にダメー
ジを与えるからです。

   ‘C-]’はマージを中断します。これは出力ファイルに書き込まずに終了するこ
とを意味します。出力ファイルを指定していない場合、マージの終了と中断に実
際の違いはありません。

   Emergeコマンドが他のLispプログラムから呼び出された場合、正常終了の戻
り値は‘t’で、中断(abort)のときは‘nil’です。


File: emacs-ja.info,  Node: Combining in Emerge,  Next: Fine Points of Emerge,  Prev: Exiting Emerge,  Up: Emerge

28.5.6 2つのバージョンの合成
----------------------------

特定の相違にたいして両方の候補を使いたいときがあります。これを行なうには
マージバッファーを以下のように編集する‘x c’を使用します:

     #ifdef NEW
     VERSION FROM B BUFFER
     #else /* not NEW */
     VERSION FROM A BUFFER
     #endif /* not NEW */

この例はCプリプロセッサー条件が2つのバージョン候補を区切っていますが、区
切りに使う文字列は、変数‘emerge-combine-versions-template’に選択した文字
列をセットすることにより、指定することができます。この文字列で‘%a’はバー
ジョンA、‘%b’はバージョンBです。上記の結果を生成するデフォルトのセッティ
ングは、以下のようなものです:

     "#ifdef NEW\n%b#else /* not NEW */\n%a#endif /* not NEW */\n"


File: emacs-ja.info,  Node: Fine Points of Emerge,  Prev: Combining in Emerge,  Up: Emerge

28.5.7 Emergeの細かい注意点
---------------------------

マージの間、AおよびBバッファーを自分で編集してはいけません。Emergeは一時
的にこれらを変更しますが、最終的には元の内容に戻します。

   複数のマージを一度に行うことができます — ただし、ある1つのバッファー
を複数のマージの入力として使用しないでください。なぜなら、これらのバッフ
ァーに加えられる一時的な変更が、1つのバッファーに加えられてしまうからで
す。

   ファイル全体を比較する必要があるため、Emergeの開始には時間がかかるこ
ともあります。Emacsは、‘diff’が終了するまで他のことを行なえません。入力
ファイルが大きいときはバックグラウンドで比較を行なうように、誰かが
Emergeを変更するかもしれません — そうなればEmergeがコマンドを受け付けら
れるようになるまでの間、Emacsで他の作業を続けることができるでしょう。

   マージをセットアップした後、Emergeはフック‘emerge-startup-hook’を実行
します。 *note Hooks::を参照してください。


File: emacs-ja.info,  Node: Abbrevs,  Next: Dired,  Prev: Maintaining,  Up: Top

29 abbrev(略語)
***************

定義された“abbrev(abbreviation: 略語の意)”とは、挿入したとき他のテキスト
に“展開”される単語のことです。abbrevは、特別な方法で展開されるようにユー
ザーにより定義されます。たとえば‘foo’を、‘find outer otter’に展開される
ように定義したとします。その後、‘f o o <SPC>’とタイプすることにより、バ
ッファーに‘find outer otter ’を挿入できます。

   略語機能の2番目の種類は、“動的abbrev展開(dynamic abbrev expansion)”と
呼ばれます。ポイントの前の文字で始まる単語をバッファーから探して、その文
字を展開するために、明示的なコマンドで動的abbrev展開を使用します。*note
Dynamic Abbrevs::を参照してください。

   3番目の種類の“hippie expansion(ヒッピー展開)”は、略語展開を一般化した
ものです。*note Hippie Expansion: (autotype)Hippie Expand.を参照してくだ
さい。

* Menu:

* Abbrev Concepts::          定義されたabbrevの基本。
* Defining Abbrevs::         abbrevを定義することにより、タイプしたとき展開されるようになります。
* Expanding Abbrevs::        展開の制御 —
                               プレフィクス、展開の取り消し。
* Editing Abbrevs::          定義されたabbrevのリスト全体の閲覧と編集。
* Saving Abbrevs::           他のセッションのためにabbrevのリスト全体を保存する。
* Dynamic Abbrevs::          すでにバッファーにある単語にたいする略語。
* Dabbrev Customization::    動的abbrevのための単語とは何か。ケースごとの処理。


File: emacs-ja.info,  Node: Abbrev Concepts,  Next: Defining Abbrevs,  Up: Abbrevs

29.1 abbrevの概念
=================

“abbrev”とは、特定の“展開結果”に“展開”されるために定義された単語のことで
す。abbrevの後ろに単語の区切りとなる文字を挿入したとき、それはabbrevを展
開し、abbrevを展開結果に置き換えます。たとえば‘foo’が‘find outer otter’に
展開されるabbrevとして定義された場合、‘f o o .’とタイプすると‘find outer
otter.’が挿入されます。

   abbrevは、バッファーローカルなマイナーモードのAbbrevモードが有効なと
きだけ展開されます。Abbrevモードを無効にすると、定義したabbrevは忘れられ
ますが、再びAbbrevモードを有効にすると展開されます。コマンド‘M-x
abbrev-mode’は、Abbrevモードを切り替えます。数引数を指定した場合、引数が
正のときはAbbrevモードをオン、他の場合はオフに切り替えます。*note Minor
Modes::を参照してください。

   abbrevは、あるメジャーモードのときだけアクティブになる、“モード特有
(mode-specific)”な定義をもつことができます。abbrevは、すべてのメジャーモ
ードでアクティブになる、“グローバル(global)”な定義をもつこともできます。
同じabbrevが、グローバルな定義と、異なるメジャーモードのための、さまざま
なモード特有の定義をもつことができます。カレントのメジャーモードにたいす
るモード特有の定義は、グローバルな定義をオーバーライドします。

   Abbrevモードが有効かにかかわらず、編集セッションの間に対話的に
abbrevを定義できます。それ以降のセッションでリロードして使用するために、
ファイルにabbrev定義のリストを保存することもできます。


File: emacs-ja.info,  Node: Defining Abbrevs,  Next: Expanding Abbrevs,  Prev: Abbrev Concepts,  Up: Abbrevs

29.2 abbrevの定義
=================

‘C-x a g’
     ポイントの前の1つ以上の単語を使用して、それが展開結果となるabbrevを
     定義します(‘add-global-abbrev’)。

‘C-x a l’
     同じですが、カレントメジャーモードに特有のabbrevを定義します
     (‘add-mode-abbrev’)。

‘C-x a i g’
     バッファーの単語をabbrevとして定義します
     (‘inverse-add-global-abbrev’)。

‘C-x a i l’
     バッファーの単語を、モード特有のabbrevとして定義します
     (‘inverse-add-mode-abbrev’)。

‘M-x define-global-abbrev <RET> ABBREV <RET> EXP <RET>’
     ABBREVを、EXPに展開されるabbrevとして定義します。

‘M-x define-mode-abbrev <RET> ABBREV <RET> EXP <RET>’
     ABBREVを、EXPに展開されるモード特有のabbrevとして定義します。

‘M-x kill-all-abbrevs’
     すべてのabbrev定義を削除して、白紙状態にします。

   abbrevを定義する通常の方法は、abbrevに展開させたいテキストを入力して
、ポイントをその後ろに配し、‘C-x a g’ (‘add-global-abbrev’)とタイプしま
す。これはミニバッファーを使ってabbrev自身を読み取り、ポイントの前の1つ
以上の単語にたいするabbrevとして定義します。数引数を使用してポイントの前
のいくつの単語が展開結果となるかを指定します。たとえば、上述したabbrevの
‘foo’を定義するには、‘find outer otter’とテキストをタイプしてから、‘C-u
3 C-x a g f o o <RET>’とタイプします。

   ‘C-x a g’の引数に0を指定すると、それは定義するabbrevの展開結果として
、リージョンの内容を使用することを意味します。

   ‘C-x a l’ (‘add-mode-abbrev’)は似ていますが、これはカレントのメジャー
モードにたいする、モード特有のabbrevを定義します。引数の機能は‘C-x a g’と
同じです。

   ‘C-x a i g’ (‘inverse-add-global-abbrev’)と‘C-x a i l’
(‘inverse-add-mode-abbrev’)は、逆のことを行ないます。abbrevとなるテキス
トがすでにバッファーに存在する場合、これらのコマンドはミニバッファーに展
開結果を指定することにより、abbrevを定義します。これらのコマンドは、この
定義を使ってabbrevテキストを展開します。

   abbrevまたは展開結果をバッファーに入力せずに、コマンド
‘define-global-abbrev’で定義することができます。これは2つの引数 —
abbrevと展開結果を読み取ります。コマンド‘define-mode-abbrev’は、モード特
有のabbrevにたいして同様のことを行います。

   abbrevの定義を変更するには、単に新しい定義を作成するだけです。
abbrevがすでに定義をもつ場合、abbrev定義コマンドはそれを置換する前に確認
を求めます。

   abbrev定義を削除するには、‘C-u - C-x a g’や‘C-u - C-x a l’のように、
abbrev定義コマンドに負の引数を与えます。前者はグローバルな定義を削除し、
後者はモード特有の定義を削除します。‘M-x kill-all-abbrevs’は、すべての
abbrevにたいしてグローバルとローカルの両方の定義を削除します。


File: emacs-ja.info,  Node: Expanding Abbrevs,  Next: Editing Abbrevs,  Prev: Defining Abbrevs,  Up: Abbrevs

29.3 abbrev展開の制御
=====================

Abbrevモードが有効な場合、バッファーのポイントの前にabbrevがあり、そこで
自己挿入文字として空白文字か区切り文字(<SPC>やカンマなど)を挿入したとき
は、常にabbrevが展開されます。より正確には、単語を構成しない任意の文字は
abbrevを展開し、単語を構成する任意の文字はabbrevの一部となります。もっと
も一般的なabbrevの使用法は、まずabbrevを挿入し、それから区切り文字か空白
文字を挿入してabbrevを展開する方法です。

   abbrevの展開は、大文字小文字を維持します。つまり‘foo’は‘find outer
otter’に、‘Foo’は‘Find outer otter’に展開されます。デフォルトでは‘FOO’は
‘Find Outer Otter’に展開されますが、変数‘abbrev-all-caps’を非‘nil’値に変
更した場合は、‘FIND OUTER OTTER’に展開されます。

   以下はabbrevの展開を制御するコマンドです:

‘M-'’
     プレフィクスと、その後の展開されるabbrevを分割します
     (‘abbrev-prefix-mark’)。

‘C-x a e’
     ポイントの前のabbrevを展開します。(‘expand-abbrev’)。これはAッbレ
     vモードが有効でなくても効果があります。

‘M-x unexpand-abbrev’
     最後に展開したabbrevをアンドゥします。

‘M-x expand-region-abbrevs’
     リージョンで見つかったいくつか、またはすべてのabbrevを展開します。

   abbrevを展開して、その展開結果にプレフィクスをつけたい場合があるかも
しれません。たとえば、‘cnst’が‘construction’に展開されるとき、これを使っ
て‘reconstruction’を入力したいと思うかもしれません。しかし、‘recnst’とタ
イプしてもうまくいきません。なぜなら、それがabbrevとして定義される必要が
あるからです。これは、プレフィクス‘re’とabbrevの‘cnst’の間で、コマンド
‘M-'’ (‘abbrev-prefix-mark’)を使うことにより行なうことができます。最初に
まず‘re’を挿入します。そこで‘M-'’をタイプします。これにより、コマンドが
機能していることを示すためバッファーにハイフンが挿入されます。その後、
abbrevの‘cnst’を入力します。このときバッファーには‘re-cnst’が含まれます
。そこで単語を構成しない文字を挿入すると、abbrevの‘cnst’が
‘construction’に展開されます。この展開ステップでは、‘M-'’が使用中である
ことを示していたハイフンも削除されます。結果は期待した通り
‘reconstruction’となります。

   abbrevを展開せずにabbrevのテキストをバッファーに残したい場合、
abbrevの後ろの区切り文字を‘C-q’で挿入して、これを行なうことができます。
したがって‘foo C-q ,’とタイプすると、それは展開されず、バッファーには
‘foo,’が残ります。

   間違ってabbrevを展開した場合、‘C-/’ (‘undo’)で展開をアンドゥできます
。これはabbrev展開による挿入をアンドゥし、それをabbrevテキストに戻します
。期待する結果が展開されないabbrevと終端となる非単語文字の場合、‘C-q’で
クォートして終端文字を再挿入しなければなりません。‘M-x unexpand-abbrev’を
使えば終端文字を削除せずに、最後の展開を取り消すことができます。

   ‘M-x expand-region-abbrevs’は、リージョン内の定義されたabbrevを検索し
、見つかったabbrevそれぞれにたいして、abbrevを展開結果に置き換えるか尋ね
ます。このコマンドはabbrevを使ってテキストを挿入したが、最初にAbbrevモー
ドをオンにするのを忘れたときに便利です。これは特別なabbrev定義のセットで
、複数のグローバルな置き換えを一度に行なうときにも便利です。このコマンド
は、Abbrevモードが有効でなくても効果があります。

   関数‘expand-abbrev’は、‘abbrev-expand-function’が指定する関数を呼び出
すことにより展開を行ないます。この関数を変更することにより、abbrevの展開
を自由に変更できます。*note (elisp)Abbrev Expansion::を参照してください
。


File: emacs-ja.info,  Node: Editing Abbrevs,  Next: Saving Abbrevs,  Prev: Expanding Abbrevs,  Up: Abbrevs

29.4 abbrevのテストと編集
=========================

‘M-x list-abbrevs’
     すべてのabbrev定義のリストを表示します。数引数を指定した場合は、ロ
     ーカルなabbrevのリストだけを表示します。

‘M-x edit-abbrevs’
     abbrevのリストを編集します。定義の追加、変更、削除ができます。

   ‘M-x list-abbrevs’の出力は以下のようなものです:

     他のさまざまなテーブル...
     (lisp-mode-abbrev-table)
     "dk"          0    "define-key"
     (global-abbrev-table)
     "dfn"         0    "definition"

(空行に意味はありません。また他のabbrevテーブルは省略しています。)

   カッコで括られた名前を含む行は、特定のabbrevテーブルのabbrevにたいす
るヘッダーです。‘global-abbrev-table’はすべてのグローバルなabbrevを含み
、その他のメジャーモードの後ろについたabbrevテーブルは、モード特有の
abbrevを含みます。

   それぞれのabbrevテーブルで、空行でない行は1つのabbrevの定義です。行の
先頭の単語はabbrevです。その後ろの数字は、そのabbrevが展開された回数です
。Emacsはこれを追跡することにより、実際に使用されているabbrevを調べて、
ときどきしか使わないものを削除するのを助けます。行の最後の文字列は
abbrevの展開結果です。

   ‘(sys)’とマークされているabbrevもいくつかあります。これらは“system
abbrevs(システムの略語)”で、さまざまなモードにたいして事前に定義されてお
り、ユーザーのabbrevファイルには保存されません(*note (elisp)Abbrevs::を
参照してください)。systemのabbrevを無効にするには、同じ名前で展開結果が
abbrev自身と同じになるabbrevを定義し、それをabbrevファイルに保存してくだ
さい。

   ‘M-x edit-abbrevs’を使うと、Emacsバッファーでabbrevのリストを編集する
ことにより、abbrev定義の追加、変更、killができます。リストの書式は、上記
で説明した書式を同じです。abbrevのバッファーは‘*Abbrevs*’と呼ばれ、モー
ドはEdit-Abbrevsモードです。このバッファーで‘C-c C-c’をタイプすると、そ
のバッファーで指定されたabbrev定義がインストールされ、リストに定義されて
いないabbrevは削除されます。

   コマンド‘edit-abbrevs’は、実際には‘list-abbrevs’と同じですが、
‘list-abbrevs’が単に‘*Abbrevs*’を他のウィンドウに表示するのに比べ、この
コマンドはそのバッファーを選択する点が異なります。


File: emacs-ja.info,  Node: Saving Abbrevs,  Next: Dynamic Abbrevs,  Prev: Editing Abbrevs,  Up: Abbrevs

29.5 abbrevの保存
=================

以下のコマンドにより、編集セッション間でabbrev定義を維持できます。

‘M-x write-abbrev-file <RET> FILE <RET>’
     すべてのabbrev定義の記述を、ファイルFILEに書き込みます。

‘M-x read-abbrev-file <RET> FILE <RET>’
     ファイルFILEを読み込み、そこで指定されているabbrevを定義します。

‘M-x define-abbrevs’
     カレントバッファーの定義からabbrevを定義します。

‘M-x insert-abbrevs’
     すべてのabbrevとそれらの展開結果を、カレントバッファーに挿入します
     。

   ‘M-x write-abbrev-file’は、ミニバッファーを使用してファイル名を読み取
り、すべてのカレントのabbrev定義の記述を、そのファイルに書き込みます。こ
れは後のセッションで使用するために、abbrev定義を保存するのに使われます。
ファイルに保存されるテキストは一連のLisp式で、それが実行されると保存した
ときと同じabbrevを定義します。

   ‘M-x read-abbrev-file’は、ミニバッファーを使用してファイル名を読み取
り、ファイル内容に対応するabbrevを定義します。関数
‘quietly-read-abbrev-file’も同様ですが、これはエコーエリアにメッセージを
表示しません。これを対話的に呼び出すことはできず、主にinitファイル(*note
Init File::を参照してください)で使用されます。どちらの関数も引数に
‘nil’が指定されると、変数‘abbrev-file-name’で与えられるファイルを使用し
ます。この変数のデフォルトは‘~/.emacs.d/abbrev_defs’です。これは標準の
abbrev定義ファイルで、Emacsは起動時にこのファイルから自動的にabbrevをロ
ードします(例外としてEmacsがバッチモードで開始されたときはabbrevファイル
をロードしません。バッチモードについての説明は、*note Initial Options::を
参照してください)。

   abbrevのどれかを変更した場合、Emacsは((‘C-x s’や‘C-x C-c’などで)、す
べてのファイルの保存するか尋ねるときにabbrevについても尋ねます。これは
‘abbrev-file-name’で指定したファイルに、それらを保存します。この機能は変
数‘save-abbrevs’を‘nil’にセットすることにより抑止できます。‘silently’に
セットすることにより、確認なしでabbrevが保存されるようになります。

   コマンド‘M-x insert-abbrevs’および‘M-x define-abbrevs’は、前のコマン
ドと似ていますが、Emacsバッファーのテキストにたいして機能します。‘M-x
insert-abbrevs’は、カレントのabbrev定義の記述をカレントバッファーのポイ
ントの後ろにテキストとして挿入します。‘M-x define-abbrevs’は、カレントバ
ッファー全体を解析して、対応するabbrevを定義します。


File: emacs-ja.info,  Node: Dynamic Abbrevs,  Next: Dabbrev Customization,  Prev: Saving Abbrevs,  Up: Abbrevs

29.6 動的abbrev展開
===================

上記で説明したabbrev機能は、テキストの挿入にしたがい自動的に処理されます
が、すべてのabbrevを明示的に定義しなければなりません。対照的に、“動的
abbrev(dynamic abbrevs)”は、バッファーの内容から略語の展開結果を自動的に
決定することができます、しかし動的abbrevの展開は、明示的に要求したときだ
け行なわれます。

‘M-/’
     バッファーのポイントの前の単語を“動的abbrev”として、その略語で始ま
     る単語を検索することにより展開します(‘dabbrev-expand’)。

‘C-M-/’
     ポイントの前の単語を動的abbrevとして補完します
     (‘dabbrev-completion’)。

   たとえばバッファーが‘does this follow ’が含んでいて、‘f o M-/’とタイ
プすると、これは‘follow’を挿入します。なぜならそれが‘fo’で始まる、そのバ
ッファーの最後の単語だからです。‘M-/’に数引数を指定すると、それはポイン
トから後方に検索して2番目、3番目、...の異なる展開結果を検索します。
‘M-/’を繰り返すと他の展開結果を後方に検索します。ポイントの前のテキスト
をすべて検索した後は、ポイントの後のテキストを検索します。変数
‘dabbrev-limit’が非‘nil’の場合、それはバッファーの中で展開結果を探す範囲
を指定します。

   カレントバッファーを検索した後、通常‘M-/’は他のバッファーを検索します
。‘dabbrev-check-all-buffers’と‘dabbrev-check-other-buffers’は、他のバッ
ファー(もし存在するなら)のどれが検索されたか決定するのに使用できます。

   どのバッファーを検索するかを制御するには、変数
‘dabbrev-ignored-buffer-names’および‘dabbrev-ignored-buffer-regexps’をカ
スタマイズします。前者の値は、スキップするバッファー名のリストです。後者
の値は正規表現のリストで、バッファー名がこれらの正規表現のどれかにマッチ
した場合、動的abbrev展開はそのバッファーをスキップします。

   ‘C-u - M-/’のように‘M-/’に負の引数を指定すると、これは最初にポイント
の後ろの展開結果を検索し、その後は他のバッファーを検索し、ポイントの前の
展開結果は最後に報告します。他の展開結果を探すために‘M-/’を繰り返す場合
は、引数に何もしていしないでください。‘M-/’を繰り返すことにより、ポイン
トの後、その後はポイントの前の展開結果を巡回します。

   動的abbrevを展開した後、その展開結果の元のコンテキストで展開結果の後
ろに続く、追加の単語をコピーすることができます。コピーしたい追加の単語ご
とに、単に‘<SPC> M-/’とタイプします。単語間のスペースおよび区切り文字は
、単語とともにコピーされます。

   ‘M-/’が展開する単語を決定する方法と、それを展開する方法を制御できます
。*note Dabbrev Customization::を参照してください。

   コマンド‘C-M-/’ (‘dabbrev-completion’)は、動的abbrevの補完を行ないま
す。利用可能な展開結果を1つずつ試すかわりに、これはすべてを検索して、そ
れらがもつ共通のテキストを挿入します。共通部分がない場合、‘C-M-/’は、通
常の方法で選択することができる補完リストを表示します。*note
Completion::を参照してください。

   動的abbrev展開は、Abbrevモードとは完全に独立しています。‘M-/’での単語
の展開は、その単語が通常のabbrevとして定義されていることとは無関係です。


File: emacs-ja.info,  Node: Dabbrev Customization,  Prev: Dynamic Abbrevs,  Up: Abbrevs

29.7 動的abbrevのカスタマイズ
=============================

動的abbrev展開は通常、展開結果の検索で大文字小文字を無視します。したがっ
て、展開結果と展開する単語は、大文字小文字が一致する必要はありません。

   この機能は変数‘dabbrev-case-fold-search’により制御されます。この値が
‘t’の場合、検索で大文字小文字は無視されます。‘nil’の場合、単語と展開結果
は大文字小文字が一致していなければなりません。値が‘case-fold-search’(デ
フォルト)の場合、変数‘case-fold-search’が展開結果の検索で、大文字小文字
を無視するかどうかを制御します(*note Lax Search::を参照してください)。

   動的abbrev展開は通常、大文字小文字のパターンにしたがって展開結果を変
換することにより、_展開する動的abbrev_の大文字小文字のパターンを維持しま
す。

   変数‘dabbrev-case-replace’は、動的abbrevの大文字小文字のパターンを維
持するかどうかを制御します。この値が‘t’の場合、動的abbrevの大文字小文字
のパターンはほとんどのケースで維持されます。‘nil’の場合、展開結果は常に
そのままコピーされます。値が‘case-replace’(デフォルト)の場合、変数
‘case-replace’が展開結果をそのままコピーするかどうかを制御します(*note
Replacement and Lax Matches::を参照してください)。

   しかし、展開結果が複雑にミックスされた大文字小文字のパターンを含む場
合、そして動的abbrevがそのパターンにある程度マッチする場合、これらの変数
の値にかかわらず、展開結果は常にそのままコピーされます。したがって、たと
えばバッファーが‘variableWithSillyCasePattern’というテキストを含む場合、
‘v a M-/’とタイプすると、大文字小文字のパターンを含めて展開結果をコピー
します。

   変数‘dabbrev-abbrev-char-regexp’が非‘nil’の場合、これは動的展開の目的
のために、どの文字を単語の一部とするかを制御します。正規表現は2文字以上
ではなく、ただ1文字だけにマッチしなければなりません。同じ正規表現が、ど
の文字が展開結果の一部となるかも決定します。値が‘nil’(デフォルト)の場合
は特別な意味をもちます。動的abbrev(たとえばポイント位置の単語)は単語構成
文字から構成されますが、それらの展開結果は単語とシンボル文字のシーケンス
から取得されます。これはプログラムソース内、および多くの言語による人間が
読むことができるテキストにたいするシンボルの展開にたいして、一般的にこれ
は適切ですが、一般的ではない句読点を含むテキストバッファーにおいては、お
そらくあなたが望むものではないかもしれません。そのような場合は、値
‘\"\\\\sw\"’がよい結果を生成するかもしれません。

   シェルスクリプトおよびmakefileでは、変数名にプレフィクス‘$’があるとき
と、ないときがあります。このタイプのテキストのためのメジャーモードは、オ
プションのプレフィクスを扱うために、変数
‘dabbrev-abbrev-skip-leading-regexp’をセットして、動的abbrev展開をカスタ
マイズできます。この値には、動的abbrev展開が無視すべきオプションのプレフ
ィクスにマッチする正規表現を指定します。デフォルトは‘nil’で、これは文字
をスキップしないことを意味します


File: emacs-ja.info,  Node: Dired,  Next: Calendar/Diary,  Prev: Abbrevs,  Up: Top

30 Dired (ディレクトリーエディター)
***********************************

Diredはディレクトリー、およびオプションでそれのサブディレクトリーのリス
トを含む、Emacsバッファーを作成します。このバッファー内を移動するために
、通常のEmacsコマンドと、リストされたファイルを操作するための、特別なコ
マンドを使うことができます。Diredはローカルとリモートの両方のディレクト
リーで機能します。

   通常はDiredバッファーは読み取り専用で、テキストの挿入はできません(と
はいえWdiredモードではそれが可能。*note Wdired::を参照されたい)。‘d’や
‘x’のような通常のプリント文字は、特別なDiredコマンドに再定義されています
。Diredコマンドには、“カレントファイル”(カレント行のファイルのこと)を“マ
ーク”したり、“フラグ”をつけるものがいくつかあり、他のコマンドは、マーク
されたファイルやフラグがつけられたファイルにたいして処理を行ないます。最
初に特定のファイルをマークして、それらすべてにたいして1つのコマンドで操
作を行なうのです。

   Dired-Xパッケージは、Diredモードのためのさまざまな特別の機能を提供し
ます。*note Dired-X: (dired-x)Top.を参照してください。

   ディレクトリーのファイルのリストは、‘C-x C-d’ (‘list-directory’)でも
閲覧することができます。Diredとは異なり、このコマンドではリストされたフ
ァイルにたいする操作はできません。*note Directories::を参照してください
。

* Menu:

* Enter: Dired Enter.        Diredの呼び出し方。
* Navigation: Dired Navigation.  Diredバッファーでの特別な移動コマンド。
* Deletion: Dired Deletion.  Diredでのファイルの削除。
* Flagging Many Files::      ファイル名にもとづくファイルへのフラグ付け。
* Visit: Dired Visiting.     Diredによるその他のファイル操作。
* Marks vs Flags::           削除のためのフラグとマーク。
* Operating on Files::       1つまたは複数ファイルにたいするコピー、リネーム、プリント、圧縮など。
* Shell Commands in Dired::  マークしたファイルにたいするシェルコマンドの実行。
* Transforming File Names::  複数ファイルのリネームにパターンを使う。
* Comparison in Dired::      Diredの様式で‘diff’を実行する。
* Subdirectories in Dired::  Diredバッファーにたいするサブディレクトリーの追加。
* Subdir Switches:: Diredでのサブディレクトリーのスイッチ。
* Subdirectory Motion::      サブディレクトリー間の移動、上下への移動。
* Hiding Subdirectories::    サブディレクトリーの表示・非表示。
* Updating: Dired Updating.  重要でないファイル行の削除。
* Find: Dired and Find.      Diredでファイルを選択するために‘find’を使う。
* Wdired::                   Diredバッファーの編集によりファイルを操作する。
* Image-Dired::              Diredでのイメージサムネイルの閲覧。
* Misc: Misc Dired Features.  その他のさまざまな機能。


File: emacs-ja.info,  Node: Dired Enter,  Next: Dired Navigation,  Up: Dired

30.1 Diredの起動
================

Diredを呼び出すには、‘C-x d’ (‘dired’)とタイプします。これはミニバッファ
ーを使用してディレクトリー名を読み取り、そのディレクトリーのファイルを一
覧するする“Diredバッファー”を開きます。ミニバッファーの引数に、ワイルド
カードによるファイル名パターンを与えることもできます。この場合、Dliredバ
ッファーには、そのパターンにマッチする、すべてのファイルが一覧されます。
ディレクトリー部分にワイルドカードが出現することもあります。たとえば、

     C-x d  ~/foo/*.el  <RET>
     C-x d  ~/foo/*/*.el  <RET>

   1つ目の例は、ディレクトリー‘foo’内の、拡張子‘.el’のすべてのファイルを
リストします。2つ目の例は、‘foo’のすべてのサブディレクトリー内の、拡張子
‘.el’のファイルをリストします。

   ミニバッファー内では、通常のヒストリー、および補完のコマンドが使用で
きます。特に、‘M-n’は(もしあれば)visitされているファイルの名前を配します
(*note Minibuffer History::を参照)。

   ‘C-x C-f’ (‘find-file’)にディレクトリー名を与えて、Diredを呼び出すこ
ともできます。

   変数‘dired-listing-switches’は、ディレクトリーをリストするために、
‘ls’に与えるオプションを指定します。この文字列には、‘-l’が_含まれていな
ければなりません_。‘dired’コマンドにプレフィクス引数を使用した場合、ディ
レクトリーの指定の前に、‘ls’のためのスイッチを指定できます。スイッチが指
定される方法は問いません。‘ls’のスイッチには、引数を要求しない短いオプシ
ョン(1文字)と、長いオプション(‘--’で始まり、引数は‘=’で指定される)を含め
ることができます。

   システムの‘ls’コマンドが‘--dired’オプションをサポートする場合、
Diredは自動的にそのオプションを渡します。これにより、Diredが名前を解析で
きないという特殊なファイル名にたいして、‘ls’が特別なエスケープシーケンス
を付します。Emacsセッションで最初にDiredを実行するとき、‘ls’コマンドに
‘--dired’オプションを指定して呼び出すことにより、そのスイッチをサポート
するかどうかチェックします。exitコードが0の場合、それ以降Diredは
‘--dired’オプションを使用し、それ以外の場合は使用しません。変数
‘dired-use-ls-dired’をカスタマイズすることにより、このチェックを抑止する
ことができます。値‘unspecified’(デフォルト)は、チェックを行なうことを意
味します。その他の非‘nil’値は、‘--dired’オプションを使用することを意味し
ます。‘nil’は、‘--dired’オプションを使用しないことを意味します。

   MS-WindowsやMS-DOSシステム、およびいくつかのリモートシステムでは、
Emacsが‘ls’をエミュレートします。このエミュレーションのオプションと特性
については、*note ls in Lisp::を参照してください。

   Diredバッファーを他のウィンドウに表示するには、‘C-x 4 d’
(‘dired-other-window’)を使用します。‘C-x 5 d’ (‘dired-other-frame’)は、
Diredバッファーを別のフレームに表示します。

   ‘q’ (‘quit-window’)とタイプすると、Diredバッファーは隠され(bury)ます
。ウィンドウがそのバッファーのためだけに作成された場合は、そのウィンドウ
を削除します。


File: emacs-ja.info,  Node: Dired Navigation,  Next: Dired Deletion,  Prev: Dired Enter,  Up: Dired

30.2 Diredバッファーでの移動
============================

Emacsの通常のカーソル移動コマンドは、Diredバッファーでも利用可能です。キ
ー‘C-n’と‘C-p’はそれぞれ‘dired-next-line’と‘dired-previous-line’を実行し
て、行の先頭ではなくファイル名の先頭にカーソルを配するように、再定義され
ています。

   特に利便性のために、Diredでの<SPC>および‘n’は、‘C-n’と等価になってい
ます。‘p’は‘C-p’と等価です(行の移動はDiredでは一般的な操作なので、タイプ
しやすいようにするべきです)。<DEL>(上に移動してフラグを外す)は、単なる上
への移動でも便利なときがあります(*note Dired Deletion::を参照してくださ
い)。

   ‘j’ (‘dired-goto-file’)は、ミニバッファーを使用してファイル名の入力を
求め、Diredバッファーで、そのファイルが記述されている行にポイントを移動
します。

   ‘M-s f C-s’ (‘dired-isearch-filenames’)は、Diredバッファーで前方への
インクリメンタル検索を行ないます。これはファイル名にたいするマッチだけを
検索し、それ以外のバッファーのテキストは無視します。‘M-s f M-C-s’
(‘dired-isearch-filenames-regexp’)も同じことを行ないますが、これは正規表
現による検索です。変数‘dired-isearch-filenames’を‘t’に変更した場合、通常
の検索コマンドも検索対象がファイル名だけに制限されるようになります。たと
えば‘C-s’は、‘M-s f C-s’と同様に振る舞います。変数の値が‘dwim’の場合、ポ
イントの最初の位置がファイル名にあるときだけ、検索コマンドはファイル名に
マッチします。インクリメンタル検索についての情報は、*note Search::を参照
してください。

   複数ディレクトリーにたいするものも含めて、Diredバッファーでは追加の移
動コマンドが利用可能です。*note Subdirectory Motion::を参照してください
。


File: emacs-ja.info,  Node: Dired Deletion,  Next: Flagging Many Files,  Prev: Dired Navigation,  Up: Dired

30.3 Diredでのファイルの削除について
====================================

もっともよく使われるDiredの使用法は、最初にファイルを削除するために“フラ
グ(flag)”をつけて、その後にフラグがつけられたファイルを削除をする方法で
す。

‘d’
     削除するために、このファイルにフラグをつけます
     (‘dired-flag-file-deletion’)。
‘u’
     削除フラグを外します(‘dired-unmark’)。
‘<DEL>’
     その行の削除フラグを外して、ポイントを前の行に移動します
     (‘dired-unmark-backward’)。
‘x’
     削除のフラグがつけられたファイルを削除します
     (‘dired-do-flagged-delete’)。

   ファイルが記述されている行に移動して、‘d’
(‘dired-flag-file-deletion’)とタイプすることにより、ファイルを削除するた
めのフラグをつけることができます。削除フラグは行頭に‘D’が表示されます。
このコマンドはポイントを次の行に移動するので、‘d’コマンドを繰り返すこと
により、連続してファイルにフラグをつけることができます。数引数は繰り返し
回数を指定します。負の引数は前のファイルにフラグをつけることを意味します
。

   リージョンがアクティブの場合、‘d’コマンドはリージョンのすべてのファイ
ルに削除のフラグをつけます。この場合、コマンドはポイントを移動せず、プレ
フィクス引数も無視します。

   ファイルを即座に削除せず、削除のフラグをファイルにつける理由は、意図
しないファイルを削除する危険を軽減するためです。フラグがついたファイルを
Diredに削除をさせる前に、コマンド‘u’または<DEL>で、削除フラグを外すこと
ができます。‘u’ (‘dired-unmark’)は‘d’と同じように機能しますが、これはフ
ラグをつけるのではなくフラグを外します。<DEL> (‘dired-unmark-backward’)は
、上に移動してフラグを外します。これは‘u’に引数−1を指定するのと同じです
。どちらのコマンドも、数引数は繰り返し回数で、負の引数は反対方向にフラグ
を外していくことを意味します。リージョンがアクティブの場合、ポイントを移
動せずにリージョン内のすべてのファイルのフラグを外します。

   フラグがついたファイルを削除するには、‘x’
(‘dired-do-flagged-delete’)とタイプします。このコマンドは削除フラグがつ
いた、すべてのファイルのリストを表示して、確認を求めます。もしこれに
‘yes’と応えた場合、Diredはフラグがついたファイルを削除して、それらのファ
イルにたいするDiredバッファーの行を削除します。Diredバッファーの行数は少
し減り、バッファーは選択されたまま残ります。

   確認を求められたとき‘no’と応えるか、‘C-g’で中断した場合は、即座に
Diredに戻ります。バッファーの削除フラグはそのまま残り、実際に削除された
ファイルはありません。

   空ディレクトリーは他のファイルと同様に削除できますが、Diredは通常、空
でないディレクトリーは削除できません。変数‘dired-recursive-deletes’が非
‘nil’の場合には、Diredはディレクトリーの内容も含めて、空でないディレクト
リーを削除できます。‘dired-recursive-deletes’を‘nil’にセットしている場合
でも、ディレクトリーの内容すべてについて問い合わせされることなく、ディレ
クトリーを再帰的に削除したいこともあるかもしれません。これには若干の危険
が伴います。変数の値が‘always’の場合は、さらに危険性は増すとはいえ、
Diredは空でないディレクトリーを再帰的に削除するでしょう。これは、多くの
ディレクトリーにたいして削除のマークを付与して、それらすべてを安全に削除
できると確信がもてるとき便利な方法です。たとえ
‘dired-recursive-deletes’を‘nil’にセットしている場合でも、ディレクトリー
の内容すべてについて問い合わせされることなく、ディレクトリーを再帰的に削
除したいこともあるかもしれません。空でないディレクトリーすべてにたいして
、確認が求められますが、‘all’と応えた場合は、それ以上の問い合わせなしで
残りすべてのディレクトリーが削除されます。

   変数‘delete-by-moving-to-trash’を‘t’に変更した場合、上記の削除コマン
ドは対象となるファイルおよびディレクトリーを削除するかわりに、システムの
Trash(ゴミ箱)に移動します。*note Misc File Ops::を参照してください。

   ファイルを削除する代替手段は、それらを‘m’でマークして‘D’で削除する方
法です。*note Operating on Files::を参照してください。


File: emacs-ja.info,  Node: Flagging Many Files,  Next: Dired Visiting,  Prev: Dired Deletion,  Up: Dired

30.4 大量のファイルに一度にフラグをつける
=========================================

コマンド‘#’、‘~’、‘.’、‘% &’、‘% d’は、ファイル名にもとづき多くのファイ
ルにフラグをつけます。

‘#’
     すべての自動保存ファイル(名前の最初と最後が‘#’のファイル)にたいして
     、削除のフラグをつけます(*note Auto Save::を参照してください)。

‘~’
     すべてのバックアップファイル(名前の最後が‘~’のファイル)にたいして、
     削除のフラグをつけます(*note Backup::を参照してください)。

‘. (ピリオド)’
     余分な番号付きバックアップファイルに、削除のフラグをつけます。一番
     古いものと、一番新しいバックアップのいくつかは除外され、その中間の
     ファイルにフラグがつけられます。

‘% &’
     簡単にファイルを再作成できることを示唆する、特定の種類の名前をもつ
     すべてのファイルに削除のフラグをつけます。

‘% d REGEXP <RET>’
     正規表現REGEXPにマッチする名前の、すべてのファイルに削除のフラグを
     つけます。

   ‘#’ (‘dired-flag-auto-save-files’)は、名前が自動保存ファイルに見える
— つまり名前の最初と最後が‘#’の、すべてのファイルにフラグをつけます。
*note Auto Save::を参照してください。

   ‘~’ (‘dired-flag-backup-files’)は、名前がバックアップファイルであるこ
とを告げる — つまり名前の最後が‘~’の、すべてのファイルにフラグをつけます
。*note Backup::を参照してください。

   ‘.’ (ピリオド、‘dired-clean-directory’)は、いくつかのバックアップファ
イルだけに削除のフラグをつけます。つまり、最古と最新のいくつかのファイル
を除く、すべてのファイルです。残すべき最新バージョンの数は通常、変数
‘dired-kept-versions’(‘kept-new-versions’では_ありません_。これは保存時
だけ適用されます)で与えられます。残すべき最古バージョンの数は、変数
‘kept-old-versions’により与えられます。

   ‘C-u 3 .’のように、ピリオドに正の数引数を指定すると、
‘dired-kept-versions’をオーバーライドして、残すべき最新バージョンの数を
指定します。負の引数は‘kept-old-versions’をオーバーライドします。引数の
値にマイナスをつけると、残すべき最古バージョンの数を指定します。

   ‘% &’ (‘dired-flag-garbage-files’)は、変数
‘dired-garbage-files-regexp’で指定される正規表現に、名前がマッチするファ
イルにフラグをつけます。デフォルトでは、TeXにより生成される‘.bak’ファイ
ルと、‘patch’により生成される‘.orig’ファイルと‘.rej’ファイルにマッチしま
す。

   ‘% d’は、指定された正規表現に名前がマッチするすべてのファイルにフラグ
をつけます(‘dired-flag-files-regexp’)。マッチングにはファイル名の非ディ
レクトリー部分だけが使用されます。マッチのアンカーとして‘^’と‘$’を使用で
きます。‘% d’を使用するとき、特定のサブディレクトリーを隠して除外できま
す。*note Hiding Subdirectories::を参照してください。


File: emacs-ja.info,  Node: Dired Visiting,  Next: Marks vs Flags,  Prev: Flagging Many Files,  Up: Dired

30.5 Diredのファイルをvisitする
===============================

Diredバッファーにリストされたファイルをvisitしたり、調べるためのDiredコ
マンドが、いくつかあります。これらのコマンドは、すべてカレント行のファイ
ルに適用されます。そのファイルが実際にはディレクトリーの場合、これらのコ
マンドは(別のDiredバッファーを作成して)、そのサブディレクトリーにたいし
てDiredを呼び出します。

‘f’
     ‘C-x C-f’とタイプしてファイル名を指定したときと同じように、カレント
     行に記述されたファイルをvisitします(‘dired-find-file’)。*note
     Visiting::を参照してください。

‘<RET>’
‘e’
     ‘f’と等価です。

‘o’
     ‘f’と同じですが、そのファイルのバッファーに別のウィンドウを使用しま
     す(‘dired-find-file-other-window’)。Diredバッファーは、最初のウィン
     ドウに表示されたまま残ります。これは‘C-x 4 C-f’を使用して、ファイル
     をvisitするのと似ています。*note Windows::を参照してください。

‘C-o’
     カレント行に記述されたファイルをvisitし、そのバッファーを別のウィン
     ドウで表示しますが、そのウィンドウを選択しません
     (‘dired-display-file’)。

‘mouse-1’
‘mouse-2’
     クリックした名前のファイルをvisitします
     (‘dired-mouse-find-file-other-window’)。これは‘o’コマンドのように、
     ファイルの表示に別のウィンドウを使います。

‘v’
     カレント行に記述されたファイルを、Viewモードで表示します
     (‘dired-view-file’)。Viewモードは、バッファーを移動するための便利な
     コマンドを提供しますが、バッファーの変更はできません。*note View
     Mode::を参照してください。

‘^’
     カレントディレクトリーの親ディレクトリーをvisitします
     (‘dired-up-directory’)。これは、‘..’の行に移動して‘f’をタイプするの
     と等価です。


File: emacs-ja.info,  Node: Marks vs Flags,  Next: Operating on Files,  Prev: Dired Visiting,  Up: Dired

30.6 Diredでのマークとフラグ
============================

ファイルに‘D’というフラグをつけるのではなく、他の文字(通常は‘*’)でファイ
ルを“マーク”することもできます。ほとんどのDiredコマンドは、‘*’でマークさ
れたファイルにたいしてコマンドを処理します。フラグ付けされたファイルだけ
に作用するコマンドは、それらのファイルを削除する‘x’だけです。

   以下は‘*’でマークしたり、マークを外したり、マークにたいして操作を行な
うコマンドです(ファイルにたいしてフラグをつけたり外すコマンドについては
、*note Dired Deletion::を参照してください)。

‘m’
‘* m’
     カレントファイルを‘*’でマークします(‘dired-mark’)。リージョンがアク
     ティブの場合、かわりにリージョン内のすべてのファイルをマークします
     。そうでない場合、数引数Nが与えられたときは、カレント行から数えて、
     次のN個のファイルまでをマークします(Nが負の場合、前の−N個のファイル
     をマークします)。サブディレクトリーのヘッダー行(subdirectory header
     line: *note Subdirectories in Dired::を参照)で呼び出さた場合、この
     コマンドはそのサブディレクトリー内のすべてのファイルをマークします
     。

‘* *’
     すべての実行ファイルを‘*’でマークします(‘dired-mark-executables’)。
     数引数を指定すると、それらのファイルのマークを外します。

‘* @’
     すべてのシンボリックリンクを、‘*’でマークします
     (‘dired-mark-symlinks’)。数引数を指定すると、それらのファイルのマー
     クを外します。

‘* /’
     ‘.’と‘..’を除く、すべてのディレクトリーを‘*’でマークします
     (‘dired-mark-directories’)。数引数を指定すると、それらのディレクト
     リーのマークを外します。

‘* s’
     ‘.’と‘..’を除く、カレントのサブディレクトリー内のすべてのファイルを
     マークします(‘dired-mark-subdir-files’)。

‘u’
‘* u’
     この行の任意のマークを外します(‘dired-unmark’)。リージョンがアクテ
     ィブの場合は、かわりにリージョン内のすべてのファイルのマークを外し
     ます。そうでない場合、数引数Nが与えられた場合は、カレントファイルか
     ら数えて、次のN個のファイルのマークを外します(Nが負の場合、前の−N個
     のファイルのマークを外します)。

‘<DEL>’
‘* <DEL>’
     ポイントを前の行に移動して、その行のマークを外します
     (‘dired-unmark-backward’)。リージョンがアクティブの場合、かわりにリ
     ージョン内のすべてのファイルのマークを外します。そうでない場合、数
     引数Nが与えられたときは、カレントファイルから数えて、前のN個のファ
     イルのマークを外します(Nが負の場合、次の−N個のファイルのマークを外
     します)。

‘* !’
‘U’
     Diredバッファーの、すべてのファイルのマークを外します
     (‘dired-unmark-all-marks’)。

‘* ? MARKCHAR’
‘M-<DEL>’
     文字MARKCHARを使用する、すべてのマークを外します
     (‘dired-unmark-all-files’)。‘M-<DEL>’で呼び出された場合、このコマン
     ドはMARKCHARの入力を求めます。MARKCHARは1文字です — これを終了させ
     るために<RET>を使用しないでください。以下の‘* c’の説明を参照してく
     ださい。これは1つのマーク文字を、他の文字に置換します。

     数引数を指定した場合、このコマンドはマークされたファイルごとに、マ
     ークを外すか確認します。‘y’はyes(はい)で、‘n’はno(いいえ)、‘!’は残
     りのファイルにたいして確認を行なわずにマークを外します。

‘* C-n’
‘M-}’
     次にマークされたファイルへ下に移動します
     (‘dired-next-marked-file’)。“マークされた”ファイルとは、任意の種類
     のマークがついているファイルです。

‘* C-p’
‘M-{’
     前のマークされたファイルへ、上に移動します
     (‘dired-prev-marked-file’)。

‘t’
‘* t’
     すべてのマークを切り替えます(‘dired-toggle-marks’)。つまり、‘*’でマ
     ークされたファイルのマークを外し、マークされていないファイルを‘*’で
     マークします。他の方法でマークされたファイルは影響を受けません。

‘* c OLD-MARKCHAR NEW-MARKCHAR’
     文字OLD-MARKCHARを使ったすべてのマークを、文字NEW-MARKCHARを使った
     マークに置き換えます(‘dired-change-marks’)。このコマンドは主に‘*’や
     ‘D’以外の文字を使用したマークを作成するのに使われます。引数は1文字
     です — 終了させるために<RET>を使用しないでください。

     このコマンドは、マーク文字としてほとんどの任意の文字を使用できるの
     で、ファイルをさまざまなクラスに分類することができます。
     OLD-MARKCHARがスペース(‘ ’)の場合、このコマンドは、すべてのマークさ
     れていないファイルにたいして処理を行ないます。NEW-MARKCHARがスペー
     スの場合、このコマンドは対象となるファイルのマークを外します。

     このコマンドの威力を知る例として、以下ではマークされていないファイ
     ルすべてにフラグ‘D’をセットして、すでに‘D’フラグがついているものは
     フラグを外しています:

          * c D t  * c <SPC> D  * c t <SPC>

     この例では、すでに‘t’でマークされたファイルがないと仮定しています。

‘% m REGEXP <RET>’
‘* % REGEXP <RET>’
     名前が正規表現REGEXPにマッチするすべてのファイルを、(‘*’で)マークし
     ます(‘dired-mark-files-regexp’)。このコマンドは‘% d’と似ていますが
     、‘D’のフラグをつけるかわりに、‘*’でマークします。

     マッチングには、ファイル名のディレクトリー部分以外だけが使用されま
     す。マッチのアンカーとして、‘^’と‘$’が使用できます。サブディレクト
     リーを一時的に隠すことにより、それらを除外できます(*note Hiding
     Subdirectories::を参照してください)。

‘% g REGEXP <RET>’
     _内容(contents)_に正規表現REGEXPにたいするマッチを含むすべてのファ
     イルを、(‘*’で)マークします(‘dired-mark-files-containing-regexp’)。
     このコマンドは‘% m’と似ていますが、ファイル名ではなくファイル内容を
     検索する点が異なります。ファイルがEmacsバッファーでvisitされていて
     、‘dired-always-read-filesystem’が‘nil’(デフォルト)なら、このコマン
     ドはファイルを再visitせずにバッファーの内容を調べるので、ディスク上
     のファイル内容が、最後にvisitしたときから変更されている場合は、矛盾
     した結果になるかもしれません。これを望まない場合は、このコマンドを
     呼び出す前に、バッファーでvisitされているファイルをリバートしたり、
     それらのバッファーにたいして‘Auto-Revert’モードをオンに切り替えたい
     と思うかもしれません。*note Reverting::を参照してください。ファイル
     をリバートしたりAuto-Revertモードをオンにせずに、このコマンドに常に
     ファイルを再visitさせたい場合は、‘dired-always-read-filesystem’を非
     ‘nil’にセットしたいと思うかもしれません。

‘C-/’
‘C-x u’
‘C-_’
     Diredバッファーでの、マークの追加や削除などの変更をアンドゥします
     (‘dired-undo’)。_このコマンドは実際のファイル操作をリバートしたり、
     失われたファイルを回復しません!_ これは単にバッファー自身にたいする
     変更をアンドゥするだけです。

     ファイルを操作するコマンドの後でこれを使用することにより、問題が起
     こる場合もあります。たとえば1つ以上のファイルをリネームしてから、
     Diredバッファーで‘dired-undo’により元の名前にリストアした場合、
     Diredバッファーと、そのディレクトリーの実際の内容が、同期しなくなり
     ます。


File: emacs-ja.info,  Node: Operating on Files,  Next: Shell Commands in Dired,  Prev: Marks vs Flags,  Up: Dired

30.7 ファイルにたいする操作
===========================

このセクションでは、1つまたは複数のファイルを操作する、基本的なDiredコマ
ンドを説明します。これらのコマンドはすべて大文字で、引数を読み取ったり、
実際に動作する前に確認を求めるのに、ミニバッファーを使用します。これらの
コマンドはすべて、以下の方法により操作するファイルを指定します:

   • コマンドに数引数Nを与えると、カレントファイルから数えて、次のN個の
     ファイルを操作します(Nが負の場合、コマンドはカレント行の前の、−N個
     のファイルを操作します)。

   • 上記以外の場合、‘*’でマークされたファイルがあるときは、コマンドはそ
     れらすべてのファイルを操作します。

   • 上記以外の場合、コマンドはカレントファイルだけを操作します。

コマンド‘!’や‘%’のような他のDiredコマンドにも、操作対象となるファイルを
決定するのに、同じ規則を使うものがあります。

   ファイルのコピーやリネーム、それらにたいするリンクを作成するような、
対象ディレクトリーを尋ねるコマンドは、操作のためにデフォルトの対象ディレ
クトリーの推論を試みます。これらのコマンドは通常、Diredバッファーのデフ
ォルトディレクトリーを提案しますが、変数‘dired-dwim-target’が非‘nil’で、
次のウィンドウに他のDiredバッファーが存在しない場合は、その他のバッファ
ーのディレクトリーをかわりに提案します。

   以下は、ファイルにたいして操作を行なうDiredコマンドです。

‘C NEW <RET>’
     指定されたファイルをコピーします(‘dired-do-copy’)。引数NEWはコピー
     先のディレクトリー、または(1つのファイルをコピーする場合は)新しいフ
     ァイル名です。これはシェルコマンド‘cp’と似ています。

     ‘dired-copy-preserve-time’が非‘nil’の場合、このコマンドでコピーする
     ことにより、‘cp -p’でコピーしたときのように、古いファイルの最終修正
     時刻(modification time)が保持されます。

     変数‘dired-recursive-copies’は、(‘cp -r’のように)ディレクトリーを再
     帰的にコピーするかを制御します。デフォルトは‘top’で、これはディレク
     トリーを再帰的にコピーする前に、確認を求めることを意味します。

‘D’
     指定されたファイルを削除します(‘dired-do-delete’)。これはシェルコマ
     ンド‘rm’と似ています。

     このセクションの他のコマンドと同様、このコマンドは_マークされたファ
     イル_、または次のN個のファイルを操作します。対照的に‘x’
     (‘dired-do-flagged-delete’)は、“フラグがついた”すべてのファイルを削
     除します。

‘R NEW <RET>’
     指定されたファイルをリネームします(‘dired-do-rename’)。1つのファイ
     ルをリネームする場合、引数NEWはファイルの新しい名前です。複数のファ
     イルをリネームする場合、引数NEWはファイルを移動するディレクトリーで
     す(これはシェルコマンド‘mv’と似ています)。

     Diredはリネームされたファイルに関連付けられたバッファーにより
     visitされたファイルの名前を自動的に変更するので、これらのバッファー
     は新しい名前を参照します。

‘H NEW <RET>’
     指定されたファイルのハードリンクを作成します(‘dired-do-hardlink’)。
     これはシェルコマンド‘ln’と似ています。引数NEWはリンクを中に作成する
     ディレクトリー、または(1つのリンクだけを作成する場合は)リンクに与え
     る名前です。

‘S NEW <RET>’
     指定されたファイルのシンボリックリンクを作成します
     (‘dired-do-symlink’)。これは‘ln -s’と似ています。引数NEWはリンクを
     中に作成するディレクトリー、または(1つのリンクだけを作成する場合は
     )リンクに与える名前です。

‘M MODESPEC <RET>’
     指定されたファイルのモード(“パーミッションビット”とも呼ばれる)を変
     更します(‘dired-do-chmod’)。MODESPECには、‘chmod’プログラムで扱われ
     る引数のような、8進かシンボル表記を指定できます。

‘G NEWGROUP <RET>’
     指定されたファイルのグループを、NEWGROUPに変更します
     (‘dired-do-chgrp’)。

‘O NEWOWNER <RET>’
     指定されたファイルの所有者を。NEWOWNERに変更します
     (‘dired-do-chown’。ほとんどのシステムでは、これを行なうことができる
     のはスーパーユーザーだけです)。

     変数‘dired-chown-program’は、処理を行なうために使用するプログラムの
     名前を指定します(システムが異なると、‘chown’が違う場所に配されてい
     る場合があるので、この変数が必要)。

‘T TIMESTAMP <RET>’
     指定されたファイルにtouchします。これはファイルの修正時刻を、現在時
     刻で更新することを意味します。これはシェルコマンド‘touch’に似ていま
     す。

‘P COMMAND <RET>’
     指定されたファイルを印刷します(‘dired-do-print’)。それらを印刷する
     ためのコマンドを指定しなければなりませんが、ミニバッファー開始時に
     は、変数‘lpr-command’および‘lpr-switches’(‘lpr-buffer’が使用するの
     と同じ変数。*note Printing::を参照してください)を使用することにより
     推定された、適切な初期値が示されます。

‘Z’
     指定されたファイルを圧縮します(‘dired-do-compress’)。ファイルがすで
     に圧縮されているように見える場合は、それらを解凍します。マークされ
     たファイルは、自身のアーカイブに圧縮されます。これは可能なら
     ‘gzip’、それ以外は‘compress’を使用します。

‘c’
     指定されたファイルを、ファイルシステム上のどこかにある1つのアーカイ
     ブに圧縮します(‘dired-do-compress-to’)。圧縮アルゴリズムはアーカイ
     ブの拡張子により決定されます。‘dired-compress-files-alist’を参照し
     てください。

‘:d’
     指定されたファイルを復号化します(‘epa-dired-do-decrypt’)。*note
     (epa)Dired integration::を参照してください。

‘:v’
     指定されたファイルのデジタル署名を検証します
     (‘epa-dired-do-verify’)。*note (epa)Dired integration::を参照してく
     ださい。

‘:s’
     指定されたファイルにデジタル署名します(‘epa-dired-do-sign’)。*note
     (epa)Dired integration::を参照してください。

‘:e’
     指定されたファイルを暗号化します(‘epa-dired-do-encrypt’)。*note
     (epa)Dired integration::を参照してください。

‘L’
     指定されたEmacs Lispファイルをロードします(‘dired-do-load’)。*note
     Lisp Libraries::を参照してください。

‘B’
     指定されたEmacs Lispファイルをバイトコンパイルします
     (‘dired-do-byte-compile’)。*note Byte Compilation: (elisp)Byte
     Compilation.を参照してください。

‘A REGEXP <RET>’
     指定されたすべてのファイルにたいして、正規表現REGEXPを検索します
     (‘dired-do-find-regexp’)。

     このコマンドは‘xref-find-references’ (*note Identifier Search::)の
     変種で、必要に応じて、*note Xref Commands::で説明されているコマンド
     を使用することにより、マッチ間を移動したり、それらを表示することが
     できる‘*xref*’バッファーを表示します。

     マークされたファイルやディレクトリーがある場合、このコマンドはそれ
     らのディレクトリーにあるすべてのファイルとサブディレクトリーを再帰
     的に検索します。ただし名前が‘grep-find-ignored-files’にマッチするフ
     ァイルと、‘grep-find-ignored-directories’にマッチするサブディレクト
     リーは除外されます。

‘Q REGEXP <RET> TO <RET>’
     指定された各ファイルにたいして‘query-replace-regexp’を行い、
     REGEXPにたいするマッチを、文字列TOに置換します
     (‘dired-do-find-regexp-and-replace’)。

     このコマンドは‘xref-query-replace-in-results’の変種です。これは
     REGEXPにたいするすべてのマッチをリストする‘*xref*’バッファーを表示
     します。このバッファーでは特別なコマンド(*note Xref Commands::)を使
     用できます。特に、問い合わせつき置換のループ(query replace loop)を
     exitした場合は、そのバッファーで更に置換を行なうために‘r’を使用でき
     ます。*note Identifier Search::を参照してください。

     ‘dired-do-find-regexp’と同様に、マークされたファイルがディレクトリ
     ーの場合、このコマンドはそれらのディレクトリー内、およびそれらのサ
     ブディレクトリーのすべてのファイルの置換を再帰的に行います。ただし
     、名前が‘grep-find-ignored-files’にマッチするファイル、および名前が
     ‘grep-find-ignored-directories’にマッチするサブディレクトリーは除外
     されます。


File: emacs-ja.info,  Node: Shell Commands in Dired,  Next: Transforming File Names,  Prev: Operating on Files,  Up: Dired

30.8 Diredでのシェルコマンド
============================

Diredコマンド‘!’ (‘dired-do-shell-command’)は、ミニバッファーでシェルの
コマンド文字列を読み取り、そのシェルコマンドを1つ以上のファイルにたいし
て実行します。シェルコマンドが処理するファイルは、Diredコマンドが操作す
るファイルを決定する方法と同じです(*note Operating on Files::を参照して
ください)。コマンド‘X’は、‘!’の別名です。

   コマンド‘&’ (‘dired-do-async-shell-command’)は同じことを行ないますが
、これはシェルコマンドを非同期で実行する点が異なります(‘!’でシェルコマン
ドの最後に文字‘&’を追加しても、同じことを行なうことができます)。コマンド
が複数のファイルを処理する場合、ファイルごとに指定したシェルコマンドの複
数コピーを並行で実行します。例外として、指定されたシェルコマンドが‘;’ま
たは‘;&’で終わる場合、バックグラウンドで実行されるシェルコマンドは、各フ
ァイルにたいして順番に実行されます。Emacsは次のコマンドを実行する前に、
呼び出したシェルコマンドが終了するのを待ちます。

   ‘!’と‘&’のどちらも、シェルコマンドの作業ディレクトリーは、Diredバッフ
ァーのトップレベルのディレクトリーです。

   ‘!’または‘&’に複数ファイルを処理させる場合、シェルコマンド文字列は、
シェルコマンドにそれらのファイルを渡す方法を決定します。

   • コマンド文字列の中で、空白文字に囲まれた‘*’を使用した場合、コマンド
     は1度だけ実行され、‘*’はファイル名のリストに置換されます。ファイル
     名の順番は、Diredバッファーでの出現順になります。

     したがって‘! tar cf foo.tar * <RET>’は、ファイル名全体のリストにた
     いして‘tar’を実行し、それらをtarファイル‘foo.tar’に格納します。

     空白文字で囲まれたシェルのワイルドカードとして‘*’を使用したい場合は
     、‘*""’と記述します。シェルではこれは‘*’と等価です。しかし‘*’が空白
     文字で囲まれていないので、Diredはこれを特別に扱うことができるのです
     。

   • 上記以外の場合で、コマンド文字列が空白文字で囲まれた‘?’、または
     ‘`?`’を含むとき、Emacsは_各ファイル_ごとに一度シェルコマンドを実行
     します。その際、‘?’および‘`?`’はカレントファイルに置換されます。コ
     マンドで複数回‘?’または‘`?`’を使用でき、それぞれ同じファイル名に置
     換されます。これらを‘*’とともに使用した場合、このコマンドはエラーを
     シグナルします。

   • コマンド文字列が‘*’、‘?’、‘`?`’のいずれも含まない場合、Emacsは各フ
     ァイルにたいしてシェルコマンドを1度実行し、その際ファイル名はコマン
     ド文字列の最後に追加されます。たとえば‘! uudecode <RET>’は、各ファ
     イルにたいして‘uudecode’を実行します。

   もっと複雑な方法でファイル名を繰り返すには、明示的なシェルループを使
用したいと思うかもしれません。たとえば以下は、各ファイルをuuencodeして、
入力ファイル名に‘.uu’を追加して出力ファイル名を作成する例です:

     for file in * ; do uuencode "$file" "$file" >"$file".uu; done

   以下は、‘`?`’表記による同じ例です:
     uuencode ? ? > `?`.uu

   コマンド‘!’および‘&’は、新しいファイル、または変更されたファイルを表
示するために、Diredバッファーを更新しようとはしません。なぜならこれらの
コマンドは、どのファイルが変更されたかを知らないからです。Diredバッファ
ーを更新するには、‘g’を使用します(*note Dired Updating::を参照してくださ
い)。

   Diredの外でシェルコマンドを実行する情報に関しては、*note Single
Shell::を参照してください。


File: emacs-ja.info,  Node: Transforming File Names,  Next: Comparison in Dired,  Prev: Shell Commands in Dired,  Up: Dired

30.9 Diredでのファイル名の変更
==============================

このセクションでは、ファイル名を系統的な方法で変更する、Diredコマンドを
説明します。各コマンドは、既存の名前を変換することにより作成される新しい
名前を使って、マークされたファイルのいくつか、またはすべてのマークされた
ファイルを操作します。

   基本的なDiredのファイル操作コマンド(*note Operating on Files::を参照
してください)と同じように、ここで説明するコマンドは次のNファイル、または
‘*’でマークされたすべてのファイル、またはカレントファイルにたいして操作
を行ないます(ファイルをマークする方法は*note Marks vs Flags::で説明され
ています)。

   このセクションで説明するすべてのコマンドは、_対話的_に機能します。つ
まり候補となるファイルごとに確認を求めます。したがって、実際に操作が必要
なファイルより多くのファイルを選択(たとえばregexpにより多くのファイルを
選択)して、コマンドが確認を求めるときに‘y’または‘n’をタイプすることによ
り、選択されたファイルを絞り込むことができます。

‘% u’
     選択されたファイルを、大文字の名前にリネームします
     (‘dired-upcase’)。古いファイル名が‘Foo’と‘bar’の場合、新しい名前は
     ‘FOO’と‘BAR’になります。

‘% l’
     選択されたファイルを、小文字の名前にリネームします
     (‘dired-downcase’)。古いファイル名が‘Foo’と‘bar’の場合、新しい名前
     は‘foo’と‘bar’になります。

‘% R FROM <RET> TO <RET>’
‘% C FROM <RET> TO <RET>’
‘% H FROM <RET> TO <RET>’
‘% S FROM <RET> TO <RET>’
     これら4つのコマンドは、それぞれリネーム、コピー、ハードリンクの作成
     、ソフトリンクの作成を行い、古いファイル名にたいして正規表現による
     置換を行って、新しい名前を作成します。

   正規表現の置換を行なう4つのコマンドは、実際には選択されたファイルの名
前にたいして検索と置換を行ないます。これらのコマンドは2つの引数を読み取
ります。それは式FROMと、置換パターンTOです。これらは古いファイル名にマッ
チしたFROMを、TOに置き換えます。‘replace-regexp’ (*note Regexp
Replace::を参照してください)のように、古い名前にマッチしたパターンの全体
または一部を参照するために、TOの中で‘\&’や‘\DIGIT’を使用できます。正規表
現がファイル名の複数の箇所にマッチする場合は、最初のマッチだけが置換され
ます。

   たとえば‘% R ^.*$ <RET> x-\& <RET>’は、選択された各ファイルの名前の前
に‘x-’を追加してリネームします。逆に各ファイル名の前の‘x-’を削除すること
も可能です。1つは‘% R ^x-\(.*\)$ <RET> \1 <RET>’とする方法です。他にも‘%
R ^x- <RET> <RET>’とする方法もあります(ファイル名の範囲を指定するために
、アンカーへのマッチ‘^’および‘$’を使用しています)。

   置換処理は通常、ファイルのディレクトリー名は考慮しません。これはディ
レクトリーにあるファイル名だけを操作します。しかし数引数を0にした場合、
置換はディレクトリー名を含めた絶対ファイル名に作用します(非0の引数は、操
作するファイルの個数を指定します)。

   一連のファイルを操作対象に選択するために、それらを操作するときに使う
のと同じ正規表現FROMを使いたいと思うかもしれません。これを行なうには‘% m
FROM <RET>’でそれらのファイルをマークして、それらのファイルを操作するコ
マンドで同じ正規表現を使用します。もっと便利にするために、ファイルを操作
する‘%’コマンドは、最後の‘%’コマンドで指定された正規表現をデフォルトで使
用します。


File: emacs-ja.info,  Node: Comparison in Dired,  Next: Subdirectories in Dired,  Prev: Transforming File Names,  Up: Dired

30.10 Diredでのファイル比較
===========================

‘=’ (‘dired-diff’)コマンドは、‘diff’プログラムを使用して、カレントファイ
ル(ポイント位置のファイル)と他のファイル(ミニバッファーを使用して指定)を
比較します。ミニバッファーで指定されたファイルは、‘diff’の1番目の引数と
なり、ポイント位置のファイルは2番目の引数になります。‘diff’プログラムの
出力は、Diffモードを使用するバッファーで表示されます(*note Comparing
Files::を参照してください)。

   リージョンがアクティブの場合、ミニバッファーを使って読み取られるファ
イル名のデフォルトは、マーク(Diredのマークではなく、Emacsの通常のマーク
のこと。*note Setting Mark::を参照してください)の位置のファイルになりま
す。リージョンがアクティブでない場合、ポイント位置のファイルがバックアッ
プファイル(*note Backup::を参照してください)のときは、それがデフォルトに
なります。

   ‘ediff-files’を使用してファイルを比較することもできます。*note
(ediff)Major Entry Points::を参照してください。


File: emacs-ja.info,  Node: Subdirectories in Dired,  Next: Subdir Switches,  Prev: Comparison in Dired,  Up: Dired

30.11 Diredでのサブディレクトリー
=================================

Diredバッファーは通常、1つのディレクトリーだけを表示しますが、オプション
でサブディレクトリーも同様に含めることができます。

   1つのDiredバッファーに複数のディレクトリーを含める一番簡単な方法は、
‘ls’にオプション‘-lR’を指定して実行する方方です(Diredを実行するとき数引
数を指定すると、ミニバッファーでこれらのオプションを指定できます)。これ
はすべてのサブディレクトリーの、すべてのレベルにたいして、再帰的にディレ
クトリーを一覧します。

   特定のサブディレクトリーだけを見たいときもあります。これは‘i’
(‘dired-maybe-insert-subdir’)により行なうことができます:

‘i’
     サブディレクトリーの内容を、バッファーの最後に挿入します。

ディレクトリーを記述する行でこのコマンドを使用した場合、同じDiredバッフ
ァーにそのディレクトリーの内容を挿入して、そこに移動します。サブディレク
トリーの内容は、‘ls -lR’の出力と同じように、Diredバッファーのトップレベ
ルのディレクトリーの後に挿入されます。

   サブディレクトリーの内容がすでにバッファーに表示されている場合、‘i’コ
マンドはそこに移動するだけです。

   どちらの場合もm‘i’は移動する前にマークをセットするので、‘C-u
C-<SPC>’でDiredバッファーの元の位置に戻ることができます(*note Setting
Mark::を参照してください)。‘^’を使って、同じDiredバッファーの親ディレク
トリーに戻ることもできます(*note Dired Visiting::を参照してください)。

   ‘l’ (‘dired-do-redisplay’)コマンドを使用すると、サブディレクトリーの
内容を更新し、サブディレクトリーのヘッダー行で‘C-u k’を使用すると、サブ
ディレクトリーのリストを削除します(*note Dired Updating::を参照してくだ
さい)。挿入したサブディレクトリーを、隠したり表示したりすることもできま
す(*note Hiding Subdirectories::を参照してください)。


File: emacs-ja.info,  Node: Subdir Switches,  Next: Subdirectory Motion,  Prev: Subdirectories in Dired,  Up: Dired

30.12 Diredでのサブディレクトリーにたいするスイッチ
===================================================

‘C-u i’を使うことにより、‘ls’のスイッチを指定して、Diredバッファーにサブ
ディレクトリーを挿入できます。すでに挿入されたサブディレクトリーの‘ls’ス
イッチを変更するには、その位置で‘C-u l’を使用します。

   バッファーをリバートしたとき、Diredはこれらのスイッチを保持します。サ
ブディレクトリーを削除すると、それにたいするスイッチは忘れられます。

   ‘dired-undo’ (*note Marks vs Flags::を参照してください) を使用するこ
とにより、スイッチを明示的に指定して挿入されたサブディレクトリーにたいし
て、それらのスイッチを記憶する(または忘れる)ためのDiredの機構をバイパス
して、それらのサブディレクトリーの再挿入または削除を行なうことができます
。‘dired-undo’を使用してサブディレクトリーを削除しても、それのスイッチは
記憶されています。後で‘i’を使ってサブディレクトリーを再挿入すると、これ
は古いスイッチを使用してサブディレクトリーを再挿入します。
(‘dired-undo’ではなく)通常のDiredコマンドを使って削除されたサブディレク
トリーを、‘dired-undo’を使って再挿入すると、最初は古いスイッチを使ってサ
ブディレクトリーを挿入します。しかしバッファーをリバートすると。バッファ
ーのデフォルトのスイッチを使って再リストします。これが問題な場合、‘C-u
i’か‘C-u l’で、この状況を正すことができます。

   Diredは‘R’スイッチを記憶しません。‘R’スイッチを含むスイッチでサブディ
レクトリーを挿入すると、それはそのサブディレクトリーの各サブディレクトリ
ーそれぞれにたいして、残りのスイッチを使用して挿入を行なうのと等価です。
たとえば‘R’で挿入されたサブディレクトリを更新またはkillしても、それのサ
ブディレクトリーは更新またはkillされません。

   バッファーのデフォルトスイッチは、明示的にスイッチを指定して挿入され
たサブディレクトリーに影響を与えません。特にバッファーのスイッチを変更す
る‘s’のようなコマンドは、そのようなサブディレクトリーに影響を与えません
(しかし明示的にスイッチを割り当てられていないサブディレクトリーには影響
します)。

   ‘M-x dired-reset-subdir-switches’を使うことにより、Diredにサブディレ
クトリーにたいするスイッチをすべて忘れさせて、すべてのサブディレクトリー
を再びリストさせることができます。これはDiredのバッファーもリバートしま
す。


File: emacs-ja.info,  Node: Subdirectory Motion,  Next: Hiding Subdirectories,  Prev: Subdir Switches,  Up: Dired

30.13 サブディレクトリー間の移動
================================

Diredバッファーがサブディレクトリーを一覧している場合、ディレクトリー全
体を移動するためのページ移動コマンド‘C-x [’および‘C-x ]’を使用することが
できます。

   以下のコマンドは、ディレクトリー単位で移動したり、Diredバッファーのデ
ィレクトリーツリーを上下に移動します。これらのコマンドは、“ディレクトリ
ーヘッダー行”に移動します。ディレクトリーヘッダー行とは、ディレクトリー
の名前を示す行で、ディレクトリー内容の最初に表示されます。

‘C-M-n’
     ディレクトリーのレベルに関係なく、次のサブディレクトリーのヘッダー
     行に移動します(‘dired-next-subdir’)。

‘C-M-p’
     ディレクトリーのレベルに関係なく、前のサブディレクトリーのヘッダー
     行に移動します(‘dired-prev-subdir’)。

‘C-M-u’
     親ディレクトリーのヘッダー行に移動します(‘dired-tree-up’)。

‘C-M-d’
     次のサブディレクトリーのヘッダー行に、ディレクトリーツリーを下に移
     動します(‘dired-tree-down’)。

‘<’
     前のディレクトリーファイル行に、上へ移動します
     (‘dired-prev-dirline’)。これは親ディレクトリーのファイルとして、デ
     ィレクトリーが記述されている行のことです。

‘>’
     次のディレクトリーファイル行に、下へ移動します
     (‘dired-next-dirline’)。


File: emacs-ja.info,  Node: Hiding Subdirectories,  Next: Dired Updating,  Prev: Subdirectory Motion,  Up: Dired

30.14 サブディレクトリーを隠す
==============================

サブディレクトリーを“隠す”とは、ヘッダー行を除きそれを非表示にすることを
意味します。

‘$’
     ポイント位置のサブディレクトリーを隠す、または表示します
     (‘dired-hide-subdir’)。これは切り替えコマンドです。数引数は繰り返し
     回数として機能します。

‘M-$’
     Diredバッファーのすべてのサブディレクトリーを、ヘッダー行だけを残し
     て隠します(‘dired-hide-all’)。1つでも隠されたサブディレクトリーがあ
     る場合、すべてのサブディレクトリーを再表示します。非常に深いディレ
     クトリーツリーの概観を得たり、離れた場所のサブディレクトリーに素早
     く移動するために、このコマンドを使うことができます。

   通常のDiredコマンドは、隠されたサブディレクトリーの中のファイルは考慮
しません。たとえばマークされたファイルを操作するコマンドは、たとえファイ
ルがマークされていても、それが隠されたディレクトリーの中にある場合は、そ
れらを無視します。したがって、サブディレクトリーのファイルにつけられた
Diredマークを外さなくても、そのサブディレクトリーを一時的に隠せば、操作
対象から除外することができます。

   サブディレクトリーのリストを挿入する方法については*note
Subdirectories in Dired::を、それを削除する方法については*note Dired
Updating::を参照してください。


File: emacs-ja.info,  Node: Dired Updating,  Next: Dired and Find,  Prev: Hiding Subdirectories,  Up: Dired

30.15 Diredバッファーの更新
===========================

このセクションでは、外部(Diredではない)のディレクトリーやファイルに対す
る変更を反映してDiredバッファーを更新したり、Diredバッファーの一部を削除
するコマンドを説明します。

‘g’
     Diredバッファーの内容全体を更新します(‘revert-buffer’)。

‘l’
     指定したファイルを更新します(‘dired-do-redisplay’)。‘l’にたいするフ
     ァイルの指定は、ファイル操作にたいするファイル指定と同じ方法で行な
     います。

‘k’
     指定した_ファイル行_(ファイルではなく、その行だけ)を削除します
     (‘dired-do-kill-lines’)。

‘s’
     並び替えをアルファベット順、日時順に切り替えます
     (‘dired-sort-toggle-or-edit’)。

‘C-u s SWITCHES <RET>’
     SWITCHESを‘dired-listing-switches’に使用して、Diredバッファーを更新
     します。

   ‘g’ (‘revert-buffer’)とタイプすると、リストされたファイルやディレクト
リーにたいする変更にもとづき、Diredバッファーの内容を更新します。消され
たファイルを除き、すでにあるマークはすべて保持されます。隠されたサブディ
レクトリーも更新されますが、隠されたまま残ります。

   いくつかのファイルだけ更新するには、‘l’ (‘dired-do-redisplay’)とタイ
プします。Diredのファイル操作コマンドと同様に、このコマンドは次のNファイ
ル(または前の−Nファイル)、または(もしあれば)マークされたファイル、または
カレントファイルを操作します。ファイルの更新とは、ファイルの現在の状態を
読み取り、バッファーの対応する行がその状態を示すように、その行を更新する
ことを意味します。

   サブディレクトリーのヘッダー行で‘l’を使用した場合、対応するサブディレ
クトリーの内容を更新します。

   ‘C-x d’や他のDiredコマンドを使用して、すでにDiredバッファーで表示され
ているディレクトリーをvisitする場合、Diredはそのバッファーに切り替えます
が更新はしません。そのバッファーが最新でない場合、Diredは‘g’をタイプして
更新するよう警告を表示します。再visitしたとき、自動的にDiredバッファーを
リバートするようEmacsに指示するには、変数‘dired-auto-revert-buffer’を非
‘nil’値にセットしてください。

   バッファーから_ファイル行_ — 実際のファイルではなく ｰｰｰ を削除するに
は、‘k’ (‘dired-do-kill-lines’)とタイプします。ファイル操作コマンドと同
じように、このコマンドは次のNファイル、またはもしあればマークされたファ
イルを操作します。しかし、間違って‘k’をタイプしたとき面倒なので、カレン
トファイルは操作しません。

   すでにDiredバッファーにサブディレクトリーとして挿入したディレクトリー
ファイル行で、‘k’(*note Subdirectories in Dired::を参照してください)とタ
イプすると、これはサブディレクトリーのリストも同様に削除します。サブディ
レクトリーのヘッダー行で‘C-u k’とタイプしても、Diredバッファーからサブデ
ィレクトリーの行を削除できます。

   この方法でkillした個別の行は‘g’で元通り表示されますが、サブディレクト
リーについては、‘i’を使ってサブディレクトリーを再挿入しなければなりませ
ん。

   Diredバッファーのファイルは通常、ファイル名のアルファベット順で一覧さ
れます。かわりにDiredは日時順でソートすることもできます。Diredコマンド
‘s’ (‘dired-sort-toggle-or-edit’)は2、つのソートモードを切り替えます。
Diredバッファーのモードラインには、現在のソート方法がby nameやby dateの
ように示されます。

   ‘C-u s SWITCHES <RET>’で、‘dired-listing-switches’に新しい値を指定で
きます。


File: emacs-ja.info,  Node: Dired and Find,  Next: Wdired,  Prev: Dired Updating,  Up: Dired

30.16 Diredと‘find’
===================

ファイルを選択するために‘find’ユーティリティーを使うことにより、Diredバ
ッファーに表示する一連のファイルを、より柔軟に選択できます。

   ワイルドカードパターンに名前がマッチするファイルを検索するには、‘M-x
find-name-dired’を使います。これは引数DIRECTORYとPATTERNを読み取り、
DIRECTORYおよびそのサブディレクトリーで、名前がPATTERNにマッチするすべて
のファイルを選択します。

   これにより選択されたファイルはDiredバッファーに表示され、通常の
Diredコマンドが利用可能です。

   ファイルの名前ではなく内容をテストしたいときは、‘M-x
find-grep-dired’を使用します。ものコマンドはミニバッファーで2つの引数
DIRECTORYとREGEXPを読み取ります。これはDIRECTORYまたはそれのサブディレク
トリーで、内容がREGEXPにマッチするすべてのファイルを選択します。このコマ
ンドは、プログラム‘find’および‘grep’を実行することにより機能します。
*note Grep Searching::の‘M-x grep-find’も参照してください。正規表現を記
述するときは、Emacsにたいしてではなく、‘grep’にたいして記述することを忘
れないでください(与えられたregexpに内容がマッチするファイルを表示する別
の方法として、‘% g REGEXP’があります。*note Marks vs Flags::を参照してく
ださい)。

   この系列でもっとも一般的なコマンドは‘M-x find-dired’で、これは
‘find’がテストできる任意の条件を指定することができます。これはミニバッフ
ァーで2つの引数DIRECTORYとFIND-ARGSを受け取ります。このコマンドは、
‘find’がどのような条件でテストを行なうかを指定するFIND-ARGSを引数として
、DIRECTORYで‘find’を実行します。このコマンドを使うためには、‘find’の使
い方を理解する必要があります。

   これらのコマンドで生成されるリストの書式は変数‘find-ls-option’により
制御されます。これは一対のオプションです。1番目にファイル一覧を生成する
ために‘find’をどのように呼び出すか、2番目にその出力をDiredが解析するかを
指定します。

   コマンド‘M-x locate’は、‘locate’プログラムと似たインターフェースを提
供します。‘M-x locate-with-filter’も同様ですが、与えられた正規表現に名前
がマッチするファイルだけを保持します。

   これらのバッファーは、通常のDiredバッファーと完全に同じようには機能し
ません。ファイル操作は機能しますが、常にバッファーを自動的に更新するわけ
ではありません。‘g’でバッファーをリバートすると、挿入されたサブディレク
トリーは削除され、フラグとマークはすべてリセットされます。


File: emacs-ja.info,  Node: Wdired,  Next: Image-Dired,  Prev: Dired and Find,  Up: Dired

30.17 Diredバッファーの編集
===========================

Wdiredは、Diredバッファーを直接変更することによりファイル操作を行なうこ
とができる、特別なモードです(“Wdired”の“W”は、“writable: 書き込み可能”が
由来です)。Wdiredモードに入るには、Diredバッファーで‘C-x C-q’
(‘dired-toggle-read-only’)とタイプします。かわりに、メニューアイテムの
‘Immediate / Edit File Names’を使うこともできます。

   Wdiredモードでは、Diredバッファーに表示されているファイルの名前を編集
することにより、ファイルをリネームできます。矩形操作や‘query-replace’も
含めて、通常のEmacs編集コマンドがすべて利用できます。編集を終えたら‘C-c
C-c’ (‘wdired-finish-edit’)とタイプします。これにより変更が適用され、通
常のDiredモードに戻ります。

   単なるファイルのリネーム以外に、ファイルの新しい名前をタイプすること
により(絶対ファイル名でも相対ファイル名でも可)、ファイルを他のディレクト
リーに移動することもできます。ファイルに削除のマークをつけるには、ファイ
ル名全体を削除します。シンボリックリンクのリンク先を変更するには、リンク
名の隣に表示されているリンク先の名前を編集します。

   新たなサブディレクトリーを作成するためにファイル名を編集する場合、
Wdiredはそれらの新たなディレクトリーを自動的に作成するでしょう。この振る
舞いを抑止したい場合は、‘wdired-create-parent-directories’を‘nil’にセッ
トしてください。

   ファイルサイズや修正時刻など、バッファーの残りのテキストは読み込み専
用にマークされているので、編集できません。しかし
‘wdired-allow-to-change-permissions’を‘t’にセットした場合、ファイルのパ
ーミッションを編集できます。たとえば‘-rw-r--r--’を‘-rw-rw-rw-’に変更する
ことにより、そのファイルを誰でも書き込めるようにできます。これらの変更は
、‘C-c C-c’をタイプしたときに効果をもちます。


File: emacs-ja.info,  Node: Image-Dired,  Next: Misc Dired Features,  Prev: Wdired,  Up: Dired

30.18 Diredでのイメージとサムネイルの閲覧
=========================================

Image-Diredは、イメージファイルをブラウズする機能です。これはイメージフ
ァイルにたいして、Emacs内または外部ビューアーを用いた、サムネイルまたは
フルサイズでの閲覧を提供します。

   Image-Diredに入るには、Diredバッファーで見たいイメージファイルを、通
常のように‘m’を使ってマークします。それから‘C-t d’
(‘image-dired-display-thumbs’)とタイプします。これはマークしたファイルに
対応するimage-diredのバッファーを作成して切り替えます。

   ‘M-x image-dired’とタイプすることにより、直接Image-Diredに入ることも
できます。これはディレクトリーの入力を求めるので、イメージファイルがある
ディレクトリーを指定します。これによりそのディレクトリーにある、すべての
イメージファイルのサムネイルが作成され、それらはthumbnailバッファーに表
示されます。ディレクトリーに大量のイメージファイルがある場合は長時間を要
するため、イメージファイルの数が、
‘image-dired-show-all-from-dir-max-files’を越える場合は確認を求めます。

   thumbnailバッファーのサムネイルにポイントを移動して、<RET>
(‘image-dired-display-thumbnail-original-image’)とタイプすると、サイズ調
整されたバージョンを別のウィンドウに表示します。これはイメージをウィンド
ウにフィットするようにサイズ調整します。バッファー内の移動は矢印キーを使
用します。簡単にブラウズするには、次のイメージに移動して、それを表示する
<SPC> (‘image-dired-display-next-thumbnail-original’)を使用します。<DEL>
(‘image-dired-display-previous-thumbnail-original’)とタイプすると、前の
サムネイルに戻って、かわりにそれを表示します。

   イメージをオリジナルのサイズで閲覧するには、<RET>を押す前にプレフィク
ス引数(‘C-u’)を与えるか、‘C-<RET>’
(‘image-dired-thumbnail-display-external’)とタイプして、イメージを外部ビ
ューアーで表示します。これは最初に、‘image-dired-external-viewer’を設定
しなければなりません。

   Image-Diredを通じて、イメージを削除することもできます。‘d’
(‘image-dired-flag-thumb-original-file’)とタイプすると、Diredバッファー
でそのイメージに削除のフラグをつけます。thumbnailバッファーで‘C-d’
(‘image-dired-delete-char’)とタイプすることにより、サムネイルイメージを
削除することもできます。

   さらに上級の機能として、“イメージタグ(image tags)”があります。これは
イメージをカテゴリー分けするために使用されるメタデータです。このタグは、
‘image-dired-db-file’により設定されるプレーンテキストファイルに格納され
ます。

   イメージファイルにタグ付けするには、それらをDiredバッファーでマークし
て(thumbnailバッファーで‘m’をタイプして、Diredのファイルをマークすること
もできます)、‘C-t t’ (‘image-dired-tag-files’)とタイプします。このコマン
ドはミニバッファーでタグ名読み取ります。特定のタグをもつファイルをマーク
するには、‘C-t f’ (‘image-dired-mark-tagged-files’)とタイプします。特定
のタグをもつイメージファイルをマークした後は、‘C-t d’を使ってそれらを閲
覧することができます。

   thumbnailバッファーから直接ファイルにタグ付けするには‘t t’とタイプし
、タグを削除するには‘t r’とタイプします。各ファイルにたいして、“コメント
”と呼ばれる特別なタグがあります(コメントは他のタグと正確に同じ意味でのタ
グではありません。コメントは若干異なる扱いをされるからです)。コメントタ
グは、イメージについてのコメントや説明を入力するのに使用されます。
thumbnailバッファーでコメントするには、‘c’とタイプします。これはコメント
の入力を求めます。Diredからコメントを追加するには、‘C-t c’
(‘image-dired-dired-comment-files’)とタイプしてください。

   Image-Diredは、シンプルなイメージ操作も提供します。thumbnailバッファ
ーで‘L’とタイプすると、オリジナルのイメージを反時計回りに90度ローテート
し、‘R’で時計回りにローテートします。このローテーションは損失がなく、
‘jpegtran’と呼ばれる外部ユーティリティーを使用し、これは最初にインストー
ルする必要があります。


File: emacs-ja.info,  Node: Misc Dired Features,  Prev: Image-Dired,  Up: Dired

30.19 その他のDiredの機能
=========================

コマンド‘+’ (‘dired-create-directory’)はディレクトリー名を読み取り、その
ディレクトリーを作成します。そのディレクトリーがすでに存在する場合は、エ
ラーをシグナルします。

   コマンド‘M-s a C-s’ (‘dired-do-isearch’)は、マークされたファイルにた
いして、複数ファイルにたいするインクリメンタル検索を開始します。ファイル
終端で検索が失敗した場合、‘C-s’とタイプすると、マークされた次のファイル
で検索を繰り返します。マークされた最後のファイルの終端に達すると、マーク
された最初のファイルに戻って検索します。コマンド‘M-s a M-C-s’
(‘dired-do-isearch-regexp’)は、同じことを正規表現検索で行ないます。検索
の繰り返しに関する情報は、*note Repeat Isearch::を参照してください。

   コマンド‘w’ (‘dired-copy-filename-as-kill’)は、マークされたファイル
(または次のNファイル)の名前を、あたかも‘C-w’でkillしたかのように、killリ
ングに配します。ファイル名はスペースで区切られます。

   プレフィクス引数に0を指定した場合、マークされた各ファイルの絶対ファイ
ル名を使用します。プレフィクス引数に‘C-u’だけを指定した場合、Diredバッフ
ァーのデフォルトディレクトリーからの相対ファイル名を使用します(サブディ
レクトリーから行なった場合はスラッシュが含まれます)。特別なケースとして
、ポイントがディレクトリーのヘッダー行にある場合、‘w’で、そのディレクト
リーの絶対パスを得ることができます。この場合、プレフィクス引数とマークさ
れたファイルは無視されます。

   このコマンドの主な目的は、他のEmacsコマンドの引数として、ファイル名を
yankすることです。これはkillリングに何が追加されたかも表示するので、現在
マークされているファイルを、エコーエリアに表示するためにも使用できます。

   ファイルリストの中にHTMLファイルがある場合は、そのファイルをブラウザ
で閲覧できると便利かもしれません。‘W’ (‘browse-url-of-dired-file’)コマン
ドは、そのファイルの閲覧に標準に設定されたブラウザを使用します。

   コマンド‘(’ (‘dired-hide-details-mode’)は、カレントのDiredバッファー
での、ファイル所有者やファイルパーミッションなどの、詳細表示を切り替えま
す。デフォルトでは、シンボリックリンクのリンク先や、ヘッダー行とファイル
やディレクトリーの一覧以外のすべての行も隠します。これを変更するには、オ
プション‘dired-hide-details-hide-symlink-targets’と
‘dired-hide-details-hide-information-lines’をカスタマイズしてください。

   visitしているディレクトリーが、バージョンコントロール(*note Version
Control::)の配下にある場合、選択されたファイルにたいして、通常のVC diffお
よびVC logコマンドが処理を行ないます。

   コマンド‘M-x dired-compare-directories’は、カレントのDiredバッファー
と、他のディレクトリーを比較するために使用されます。2つのディレクトリー
で異なる、すべてのファイルがマークされます。カレントのDiredバッファーも
含めて、それらのファイルをリストする、すべてのDiredバッファーでマークが
付されます。

   (入力を求められたとき<RET>をタイプすると使用される)デフォルトの比較方
法では、ファイル名だけを比較します — つまり別のディレクトリーに存在しな
いファイルは、異なります。Lisp式を入力して、より厳密な比較を指定すること
ができます。この場合、変数‘size1’と‘size2’はファイルサイズ、‘mtime1’と
‘mtime2’は最終修正時刻を秒で表した浮動小数点数、‘fa1’と‘fa2’はファイルの
属性リスト(関数‘file-attributes’で返される形式)です。この比較は、同じ名
前のファイルごとに評価され、式の値が非‘nil’の場合、それらのファイルは異
なります。

   たとえばシーケンス‘M-x dired-compare-directories <RET> (> mtime1
mtime2) <RET>’は、別のディレクトリーよりこのディレクトリーのファイルが新
しい場合はマークし、このディレクトリーより別のディレクトリーのファイルが
古い場合にマークします。相手がいないファイルも、両方のディレクトリーでマ
ークが付されます。

   X Windowシステムでは、Emacsはドラッグアンドドロップをサポートします。
ファイルオブジェクトを他のプログラムにドラッグしたり、Diredバッファーに
ドロップできます。これは、そのディレクトリーのファイルの移動、コピー、ま
たはリンクを作成します。正確に言うと、どのアクションが選択されるかは、プ
ログラムの動作により決定されます。Diredバッファーの外へのファイルのドラ
ッグは、現在のところサポートされていません。


File: emacs-ja.info,  Node: Calendar/Diary,  Next: Sending Mail,  Prev: Dired,  Up: Top

31 カレンダーとダイアリー
*************************

Emacsは、過去のイベントや将来のプランのためのダイアリーをもつ、卓上カレ
ンダー機能を提供します。これにはアポイントメントを管理したり、特定のプロ
ジェクトにどれだけ時間を費やしているか追跡する機能もあります。

   カレンダーを起動するには、‘M-x calendar’とタイプします。これは3ヶ月分
のカレンダーを表示します。当月が中央に表示され、今日の日付にポイントが配
されます。‘C-u M-x calendar’のように数引数を指定すると、3ヶ月カレンダー
の中央に表示する、月と年の入力を求めます。カレンダーは自身のバッファーを
使用し、メジャーモードはCalendarモードです。

   カレンダーの中で‘mouse-3’をクリックすると、特定の日付にたいする操作メ
ニューが表示されます。‘mouse-2’をクリックすると、特定の日付とは関係のな
い、一般的に使用されるカレンダー機能のメニューが表示されます。カレンダー
を終了するには、‘q’とタイプします。

* Menu:

* Calendar Motion::          カレンダー内の移動、日付の選択。
* Scroll Calendar::          過去または将来の月をスクリーンに表示する。
* Counting Days::            2つの日付の間の日数は?
* General Calendar::         カレンダーの終了と再計算。
* Writing Calendar Files::   さまざまなフォーマットで、カレンダーをファイルに書き込む。
* Holidays::                 休日の日付を表示する。
* Sunrise/Sunset::           日の出と日の入りの時間を地方時間で表示する。
* Lunar Phases::             月の位相の表示。
* Other Calendars::          他のカレンダーシステムへの日付の変換。
* Diary::                    ダイアリーからイベントを表示する。
* Daylight Saving::          夏時間がアクティブな期間を指定する方法。
* Time Intervals::           時間間隔の追跡。
* Advanced Calendar/Diary Usage:: カレンダーとダイアリーの上級のカスタマイズ。


File: emacs-ja.info,  Node: Calendar Motion,  Next: Scroll Calendar,  Up: Calendar/Diary

31.1 カレンダーでの移動
=======================

Calendarモードは日、週、月、年のような論理的な単位で、カレンダーを移動す
るコマンドを提供します。最初に表示されている3ヶ月の外に移動すると、カレ
ンダーの表示は選択された日付が表示されるように、自動的にスクロールします
。ある日付に移動することにより、その日が何の休日かを表示したり、ダイアリ
ーのエントリーを表示したり、他のカレンダーに変換できます。単にカレンダー
をスクロールするのは、長い期間を移動するのにも便利です。

* Menu:

* Calendar Unit Motion::     日、週、月、年単位での移動。
* Move to Beginning or End::  週、月、年の開始と終了への移動。
* Specified Dates::          今日の日付や、特定の日付への移動。


File: emacs-ja.info,  Node: Calendar Unit Motion,  Next: Move to Beginning or End,  Up: Calendar Motion

31.1.1 標準的な時間間隔での移動
-------------------------------

カレンダーバッファーでの移動コマンドは、テキスト内での移動コマンドと似て
います。日、週、月、年を前方および後方に移動できます。

‘C-f’
     ポイントを、1日前方に移動します(‘calendar-forward-day’)。
‘C-b’
     ポイントを、1日後方に移動します(‘calendar-backward-day’)。
‘C-n’
     ポイントを、1週前方に移動します(‘calendar-forward-week’)。
‘C-p’
     ポイントを、1週後方に移動します(‘calendar-backward-week’)。
‘M-}’
     ポイントを、1月前方に移動します(‘calendar-forward-month’)。
‘M-{’
     ポイントを、1月後方に移動します(‘calendar-backward-month’)。
‘C-x ]’
     ポイントを、1年前方に移動します(‘calendar-forward-year’)。
‘C-x [’
     ポイントを、1年後方に移動します(‘calendar-backward-year’)。

   dayおよびweekのコマンドは、文字単位または行単位で移動するための
Emacsコマンド、自然に類似しています。通常‘C-n’は、後続の行の同じ列に移動
しますが、Calendarモードでは翌週の同じ日に移動します。‘C-p’は、前の週の
同じ日に移動します。

   他のモードで通常振る舞うように、矢印キーは‘C-f’、‘C-b’、‘C-n’、
‘C-p’と等価です。

   月単位および年単位の移動のためのコマンドは、週単位の移動コマンドに似
ていますが、より長い期間を移動します。monthコマンドの‘M-}’および‘M-{’は
、月全体を前方または後方に移動します。yearコマンドの‘C-x ]’および
‘C-x [’は、年全体を前方または後方に移動します。

   これらのコマンドを簡単に覚える方法は、月および年が、テキストのパラグ
ラフとページに類似するものだと考えることです。しかし、カレンダーの移動コ
マンド自体は、テキスト間の移動コマンドと非常に類似している訳ではありませ
ん。Emacsのパラグラフコマンドは通常、パラグラフの先頭または最後に移動し
ますが、月コマンドと年コマンドは、月または年の同じ日を保ちながら、月単位
または年単位で移動します。

   これらのコマンドは、繰り返し回数として数引数を受け取ります。
Calendarモードでは便宜上、メタ修飾なしの数字キーとマイナス記号で、数引数
を指定できます。たとえば‘100 C-f’は、現在の位置から100日前方へポイントを
移動します。


File: emacs-ja.info,  Node: Move to Beginning or End,  Next: Specified Dates,  Prev: Calendar Unit Motion,  Up: Calendar Motion

31.1.2 週、月、年の開始と終了
-----------------------------

週(または月や年)は、単に日が集まったものではなく、特定に日付から開始され
ると考えます。そのためCalendarモードは週、月、年の、最初と最後に移動する
コマンドを提供します。

‘C-a’
     週の最初にポイントを移動します(‘calendar-beginning-of-week’)。
‘C-e’
     週の最後にポイントを移動します(‘calendar-end-of-week’)。
‘M-a’
     月の最初にポイントを移動します(‘calendar-beginning-of-month’)。
‘M-e’
     月の最後にポイントを移動します(‘calendar-end-of-month’)。
‘M-<’
     年の最初にポイントを移動します(‘calendar-beginning-of-year’)。
‘M->’
     年の最後にポイントを移動します(‘calendar-end-of-year’)。

   これらのコマンドは繰り返し回数として数引数を受け取り、繰り返し回数で
、何週、何ヶ月、何年前方または後方へ移動するかを示します。

   デフォルトでは、週は日曜日から開始されます。週が月曜日から開始される
ようにするには、変数‘calendar-week-start-day’を1にセットします。どの日付
ヘッダーを週末としてハイライトするか変更するには、変数
‘calendar-weekend-days’をセットしてください。


File: emacs-ja.info,  Node: Specified Dates,  Prev: Move to Beginning or End,  Up: Calendar Motion

31.1.3 日付の指定
-----------------

Calendarモードは、さまざまな方法で、指定された特定の日付へ移動するコマン
ドを提供します。

‘g d’
     指定した日付にポイントを移動します(‘calendar-goto-date’)。
‘g D’
     年の指定された日にポイントを移動します
     (‘calendar-goto-day-of-year’)。
‘g w’
     年の指定された週にポイントを移動します(‘calendar-iso-goto-week’)。
‘o’
     指定された月をカレンダーの中央にします(‘calendar-other-month’)。
‘.’
     今日の日付にポイントを移動します(‘calendar-goto-today’)。

   ‘g d’ (‘calendar-goto-date’)は年、月、月の何日目かの入力を求め、その
日付に移動します。カレンダーは西暦の最初からすべての日付を含むので、年は
全部タイプしなければなりません。つまり、‘10’ではなく‘2010’とタイプしてく
ださい。

   ‘g D’ (‘calendar-goto-day-of-year’)は、年と日数の入力を求め、その日付
に移動します。負の日数は年の最後から後方に数えます。‘g w’
(‘calendar-iso-goto-week’)は、年と週数の入力を求め、その週に移動します。

   ‘o’ (‘calendar-other-month’)は、月と年の入力を求め、3ヶ月カレンダーの
中央にその月を配します。

   ‘.’ (‘calendar-goto-today’)で今日の日付に戻ることができます。


File: emacs-ja.info,  Node: Scroll Calendar,  Next: Counting Days,  Prev: Calendar Motion,  Up: Calendar/Diary

31.2 カレンダーでのスクロール
=============================

カレンダーの表示は、ポイントが表示部分の外に移動すると、自動的にスクロー
ルします。手動でスクロールすることもできます。カレンダーのウィンドウに、
月が書き込まれた細長い紙が含まれているのを想像してみてください。カレンダ
ーのスクロールとは、この紙を水平方向に動かして、そのウィンドウに新しい月
を表示することを意味します。

‘>’
     カレンダーを1月前方にスクロールします(‘calendar-scroll-left’)。
‘<’
     カレンダーを1月後方にスクロールします(‘calendar-scroll-right’)。
‘C-v’
‘<PageDown>’
‘<next>’
     カレンダーを3月前方にスクロールします
     (‘calendar-scroll-left-three-months’)。
‘M-v’
‘<PageUp>’
‘<prior>’
     カレンダーを3月後方にスクロールします
     (‘calendar-scroll-right-three-months’)。

   もっとも基本的なカレンダーのスクロールコマンドは、1度に1月スクロール
します。これはコマンドの前後の表示で、2月がオーバーラップして表示される
ことを意味します。‘>’は内容を、1度に1月前方にスクロールします。‘<’は内容
を、1度に1月後方にスクロールします。

   コマンド‘C-v’および‘M-v’は、カレンダーを画面全体 — つまり3月スクロー
ルします。この動作は、これらのコマンドが通常意味する動作と類似しています
。‘C-v’は後の日付を表示し、‘M-v’は前の日付を表示します。これらのコマンド
は、繰り返し回数として数引数を受け取ります。特に‘C-u’は次のコマンドを4倍
するので、‘C-u C-v’は1年前方にカレンダーをスクロールし、‘C-u M-v’は1年後
方にカレンダーをスクロールします。

   他のモードのときと同様に、ファンクションキーの<PageDown> (または
<next>)と<PageUp> (または<prior>)は、‘C-v’や‘M-v’と等価です。


File: emacs-ja.info,  Node: Counting Days,  Next: General Calendar,  Prev: Scroll Calendar,  Up: Calendar/Diary

31.3 日付のカウント
===================

‘M-=’
     カレントリージョン内の日数を表示します
     (‘calendar-count-days-region’)。

   ある範囲の日数を数えるには、‘C-<SPC>’で日付をマークし、他の日付にポイ
ントを移動して、‘M-=’ (‘calendar-count-days-region’)とタイプします。表示
される日数は_包括的(inclusive)_です。つまりマークとポイントで指定された
日も、日数に含まれます。


File: emacs-ja.info,  Node: General Calendar,  Next: Writing Calendar Files,  Prev: Counting Days,  Up: Calendar/Diary

31.4 その他のカレンダーコマンド
===============================

‘p d’
     day-in-year(1年で何日目か)を表示します
     (‘calendar-print-day-of-year’)。
‘C-c C-l’
     カレンダーウィンドウを再生成します(‘calendar-redraw’)。
‘<SPC>’
     次のウィンドウを上にスクロールします(‘scroll-other-window’)。
‘<DEL>’
‘S-<SPC>’
     次のウィンドウを下にスクロールします(‘scroll-other-window-down’)。
‘q’
     カレンダーをexitします(‘calendar-exit’)。

   年の初めからの経過日数と、年の最後までの残り日数を表示するには、‘p d’
command (‘calendar-print-day-of-year’)とタイプします。これは、それら両方
の日数をエコーエリアに表示します。経過日数には選択された日付も含まれます
。残り日数に、その日は含まれません。

   カレンダーウィンドウのテキストがおかしくなった場合は、再描画するため
に‘C-c C-l’ (‘calendar-redraw’)とタイプします(これはCalendarモード以外の
モードの編集コマンドを使ったときだけ発生します)。

   Calendarモードでは、<SPC> (‘scroll-other-window’)と<DEL>
(‘scroll-other-window-down’)を使って、(もしあれば)他のウィンドウを上また
は下にスクロールします。これは休日のリストやダイアリーのエントリーを他の
ウィンドウに表示しているときなどに便利です。

   カレンダーからexitするには、‘q’ (‘calendar-exit’)とタイプします。これ
はカレンダーに関連するすべてのバッファーを隠し(bury)、他のバッファーを選
択します(フレームがカレンダー専用のウィンドウを含む場合、カレンダーを
exitすることによりそのフレームは、削除またはアイコン化されます。これは変
数‘calendar-remove-frame-by-deleting’の値に依存します)。


File: emacs-ja.info,  Node: Writing Calendar Files,  Next: Holidays,  Prev: General Calendar,  Up: Calendar/Diary

31.5 カレンダーファイルの記述
=============================

カレンダーとダイアリーのエントリーを、HTMLやLaTeXに書き出すことができま
す。

   Calendar HTMLコマンドは、カレンダー、休日、ダイアリーのエントリーを含
む、HTMLコードのファイルを生成します。各ファイルは1ヶ月に対応し、
‘YYYY-MM.html’という形式の名前をもちます。ここでYYYYは4桁の年、MMは2桁の
月です。変数‘cal-html-directory’は、HTMLファイルのためのデフォルトの出力
先ディレクトリーを指定します。休日が表示されないようにするには、
‘cal-html-holidays’をカスタマイズしてください。

   ‘<’と‘>’で囲まれたダイアリーのエントリー(たとえば、this is a diary
entry with <font color=”red”>some red text</font>)は、HTMLタグと解釈され
ます。HTMLファイルを含むディレクトリーの中にあるスタイルシート
‘cal.css’を通じて、表示されるHTMLページの全体的な外観を変更できます(関連
するスタイルセッティングについては、変数‘cal-html-css-default’の値を参照
してください)。

‘H m’
     1ヶ月のカレンダーを生成します(‘cal-html-cursor-month’)。
‘H y’
     1年の各月のカレンダーファイルを生成し、同様にインデックスページも生
     成します(‘cal-html-cursor-year’)。デフォルトでは、このコマンドはフ
     ァイルをサブディレクトリーYYYYに書き込みます。これを変更した場合、
     各年の間のハイパーリンクは機能しなくなるでしょう。

   変数‘cal-html-print-day-number-flag’が非‘nil’の場合、マンスリーカレン
ダーにはday-of-the-year(年の何日目か)の数字が表示されます。変数
‘cal-html-year-index-cols’は、年のインデックスページの列数を指定します。

   Calendar LaTeXコマンドは、カレンダーとしてプリントされるLaTeXコードの
バッファーを生成します。どのコマンドを使うかにより、プリントされるカレン
ダーは、ポイントのある日、週、月、年をカバーします。

‘t m’
     1ヶ月のカレンダーを生成します(‘cal-tex-cursor-month’)。
‘t M’
     横向き印刷(sideways-printing)で、1ヶ月のカレンダーを生成します
     (‘cal-tex-cursor-month-landscape’)。
‘t d’
     1日のカレンダーを生成します(‘cal-tex-cursor-day’)。
‘t w 1’
     時間を併記した、1週間の1ページカレンダーを生成します
     (‘cal-tex-cursor-week’)。
‘t w 2’
     時間を併記した、1週間の2ページカレンダーを生成します
     (‘cal-tex-cursor-week2’)。
‘t w 3’
     時間なしで、1週間のISOスタイルのカレンダーを生成します
     (‘cal-tex-cursor-week-iso’)。
‘t w 4’
     時間を併記した、月曜で始まる1週間のカレンダーを生成します
     (‘cal-tex-cursor-week-monday’)。
‘t w W’
     時間なしで、1週間の2ページカレンダーを生成します
     (‘cal-tex-cursor-week2-summary’)。
‘t f w’
     2週間を見開きする、Filofaxスタイルのカレンダーを生成します
     (‘cal-tex-cursor-filofax-2week’)。
‘t f W’
     1週間を見開きする、Filofaxスタイルのカレンダーを生成します
     (‘cal-tex-cursor-filofax-week’)。
‘t y’
     1年のカレンダーを生成します(‘cal-tex-cursor-year’)。
‘t Y’
     横向き印刷(sideways-printing)で、1年のカレンダーを生成します
     (‘cal-tex-cursor-year-landscape’)。
‘t f y’
     1年のFilofaxスタイルのカレンダーを生成します
     (‘cal-tex-cursor-filofax-year’)。

   これらのコマンドの中には、カレンダーを(ランドスケープモードで)横向き
に印刷するものがあり、その場合は縦長ではなく横長になります。Filofaxの用
紙サイズ(3.75in x 6.75in)を使うものもあります。これらのコマンドはすべて
プレフィクス引数を指定でき、これは何日、何週間、何ヶ月、何年分を印刷する
かを指定します(常に選択された日付から開始されます)。

   変数‘cal-tex-holidays’が非‘nil’(デフォルト)の場合、プリンとされたカレ
ンダーには‘calendar-holidays’の休日が表示されます。変数‘cal-tex-diary’が
非‘nil’(デフォルトは‘nil’)の場合、ダイアリーのエントリーも含まれます(マ
ンスリー、Filofax、isoの週カレンダーのみ)。変数‘cal-tex-rules’が非
‘nil’(デフォルトは‘nil’)の場合、カレンダーは充分な空間のある、罫線ページ
のスタイルで表示されます。そのカレンダーがどんな機能をサポートするかは、
個別のcal-tex関数のドキュメントを参照してください。

   必要なら、変数‘cal-tex-preamble-extra’を使用して、生成されたドキュメ
ントのプリアンブル(preamble)に、追加のLaTeXコマンドを挿入できます。


File: emacs-ja.info,  Node: Holidays,  Next: Sunrise/Sunset,  Prev: Writing Calendar Files,  Up: Calendar/Diary

31.6 休日
=========

Emacsのカレンダーは、多くのメジャーおよびマイナーな休日を知っており、そ
れらを表示することができます。デフォルトリストに、あなた自身の休日を追加
できます。

‘mouse-3 Holidays’
‘h’
     選択された日付の休日を表示します(‘calendar-cursor-holidays’)。
‘x’
     カレンダーウィンドウの休日をマークします
     (‘calendar-mark-holidays’)。
‘u’
     カレンダーウィンドウのマークを外します(‘calendar-unmark’)。
‘a’
     表示された3ヶ月の休日を別のウィンドウにリストします
     (‘calendar-list-holidays’)。
‘M-x holidays’
     今日を含む3ヶ月の休日を別のウィンドウにリストします。
‘M-x list-holidays’
     年の指定した範囲の休日を別のウィンドウにリストします。

   ある日付が休日かどうか見るには、カレンダーウィンドウのその日付にポイ
ントを置いて、‘h’コマンドを使用します。その日付を‘mouse-3’でクリックして
表示されるメニューで、‘Holidays’を選択しても見ることができます。どちらの
方法も、その日付にたいする休日を、エコーエリアか、エコーエリアに収まらな
い場合は別のウィンドウに表示します。

   カレンダーに表示された、すべての日付にたいする休日の分布を閲覧するに
は、‘x’コマンドを使用します。これは休日を異なるフェイスで表示します。
*note calendar-holiday-marker: Calendar Customizing.を参照してください。
このコマンドは、現在表示されている月と、スクロールすることにより見ること
ができる他の月の両方に適用されます。マークをオフにして現在のマークを消す
には、‘u’をタイプします。これはダイアリーマークも消します(*note Diary::を
参照してください)。変数‘calendar-mark-holidays-flag’が非‘nil’の場合、カ
レンダーの作成または更新により、自動的に休日がマークされます。

   さらに詳細な情報を得るには、‘a’コマンドを使用します。これはカレントの
3ヶ月の範囲のすべての休日を含むリストを、別のバッファーに表示します。カ
レンダーウィンドウで<SPC>および<DEL>を使用することにより、そのリストを上
または下にスクロールできます。

   コマンド‘M-x holidays’は、今月および前月と来月の休日のリストを表示し
ます。これはカレンダーウィンドウがないときでも機能します。変数
‘calendar-view-holidays-initially-flag’が非‘nil’の場合、カレンダーの作成
により、休日がこの方法で表示されます。違う月を中心にした3ヶ月の休日リス
トが欲しい場合は、月と年の入力を求める‘C-u M-x holidays’を使用してくださ
い。

   Emaceが知っている休日には、United States、major Bahá’í、Chinese、
Christian、Islamic、Jewishの休日、および夏至と冬至(solstices)、春分と秋
分(equinoxes)が含まれます。

   ‘M-x holiday-list’は、ある年の範囲にたいする休日のリストを表示します
。この関数は年の開始と終了の入力を求め、すべての休日、または複数のカテゴ
リーの中の1つのカテゴリーに属する休日を選択することができます。このコマ
ンドは、カレンダーウィンドウがないときでも使用することができます。

   休日に使用される日付は、歴史的事実ではなく、_現在の慣習(current
practice)_にもとづきます。たとえばVeteran’s Day(退役軍人の日)は1919年に
始まった休日ですが、それより前の年でも表示されます。


File: emacs-ja.info,  Node: Sunrise/Sunset,  Next: Lunar Phases,  Prev: Holidays,  Up: Calendar/Diary

31.7 日の出と日の入りの時刻
===========================

特別なカレンダーコマンドにより、任意の日付にたいする日の出(sunrise)と日
の入り(sunset)の時刻を、1、2分の範囲で調べることができます。

‘mouse-3 Sunrise/sunset’
‘S’
     選択された日付の、日の出と日の入りの時刻を表示します
     (‘calendar-sunrise-sunset’)。
‘M-x sunrise-sunset’
     今日の日の出と日の入りの時刻を表示します。
‘C-u M-x sunrise-sunset’
     指定した日付の日の出と日の入りの時刻を表示します。
‘M-x calendar-sunrise-sunset-month’
     選択された月の日の出と日の入りの時刻を表示します。

   カレンダーからは、見たい日付にポイントを移動して‘S’をタイプすると、エ
コーエリアに日の出と日の入りの時刻を、_地方時間_で表示します。日付を
‘mouse-3’でクリックし、表示されたメニューの‘Sunrise/sunset’を選択しても
表示することができます。今日、または指定した日付にたいしてこの情報を表示
するために、カレンダーの外からでも、コマンド‘M-x sunrise-sunset’が利用可
能です。今日以外の日付を指定するには、年、月、日の入力を求める‘C-u M-x
sunrise-sunset’を使用してください。

   ‘C-u C-u M-x sunrise-sunset’により、任意の地域の任意の日付にたいして
、日の出と日の入りの時刻を表示できます。これは経度(longitude)、緯度
(latitude)、調整済みグリニッジ平均時(Coordinated Universal Time)との分差
、日付の入力を求め、その地域の、その日付の日の出と日の入りの時刻を表示し
ます。

   日の出と日の入りの時刻は地球上の位置に依存するので、これらのコマンド
を使用する前に、Emacsに経度(latitude)、緯度(longitude)、地域名(location
name)を指定する必要があります。以下は何をセットするかの例です:

     (setq calendar-latitude 40.1)
     (setq calendar-longitude -88.2)
     (setq calendar-location-name "Urbana, IL")

‘calendar-latitude’と‘calendar-longitude’には、小数点以下1位までの数値を
使用します。

   タイムゾーン(time zone)も、地方時間での日の入りと日の出の時刻に影響を
与えます。Emacsは通常、タイムゾーンの情報をオペレーティングシステムから
得ますが、その情報が間違っている場合(またはオペレーティングシステムがそ
の情報を提供しない場合)、これらを自分でセットしなければなりません。以下
は例です:

     (setq calendar-time-zone -360)
     (setq calendar-standard-time-zone-name "CST")
     (setq calendar-daylight-time-zone-name "CDT")

‘calendar-time-zone’の値は地方標準時(local standard time)と、調整済みグ
リニッジ平均時(Coordinated Universal Time)、またはグリニッジ時(Greenwich
time: GMT)との分差です。‘calendar-standard-time-zone-name’と
‘calendar-daylight-time-zone-name’の値は、あなたのタイムゾーンで使用され
る略語です。Emacsは、_サマータイム(daylight saving time)_で調整済みの、
日の出と日の入りの時刻を表示します。サマータイムが決定される方法について
は、*note Daylight Saving::を参照してください。

   ユーザーとしては‘.emacs’で、普段いる場所をカレンダーの位置変数にセッ
トすると便利だと思うかもしれません。システム管理者としては、
‘default.el’で、すべてのユーザーにたいして、これらの変数をセットしたいと
思うかもしれません。*note Init File::を参照してください。


File: emacs-ja.info,  Node: Lunar Phases,  Next: Other Calendars,  Prev: Sunrise/Sunset,  Up: Calendar/Diary

31.8 月の位相
=============

以下のカレンダーコマンドは、月の位相(phases of the moon)、つまり新月(new
moon)、上弦(first quarter)、満月(full moon)、下弦(last quarter)の日付と
時刻を表示します。この機能は、月の位相に依存する問題をデバッグするのに便
利です。

‘M’
     表示されている3ヶ月にたいして、月のすべての4位相の日付と時刻を表示
     します(‘calendar-lunar-phases’)。
‘M-x lunar-phases’
     今日を含む3ヶ月にたいして、月のすべての4位相の日付と時刻を表示しま
     す。

   カレンダーからは‘M’を使用して、カレントの3ヶ月の範囲での月の位相を、
別のバッファーに表示します。数分の誤差で、日付と時刻がリストされます。

   カレンダーの外からは、コマンド‘M-x lunar-phases’で今月と前後1ヶ月の、
月の位相のリストが表示されます。違う月についての情報は、月と年の入力を求
める‘C-u M-x lunar-phases’を使用してください。

   月の位相にたいして与えられる日付と時刻は、(それが適切なときはサマータ
イム調整されて)地方時間で与えられます。前のセクションの議論を参照してく
ださい。*note Sunrise/Sunset::を参照してください。


File: emacs-ja.info,  Node: Other Calendars,  Next: Diary,  Prev: Lunar Phases,  Up: Calendar/Diary

31.9 他のカレンダーとの間の変換
===============================

Emacsのカレンダーは、_常に_グレゴリオ暦(Gregorian calendar)で表示されま
す。これは、新暦(New Style calendar)と呼ばれることもあり、今日では世界の
ほとんどで使用されています。しかし、このカレンダーは16世紀より前には存在
しておらず、、18世紀より前は広く使われていませんでした。ユリウス暦
(Julian calendar)を置き換えて、世界的に受け入れられたのも20世紀初頭です
。Emacsカレンダーは、西暦1年1月から任意の月を表示できますが、グレゴリオ
歴がまだ存在しない日付にたいしても、カレンダーは常にグレゴリオ暦で表示さ
れます。

   Emacsは他のカレンダーを表示できませんが、日付を他のカレンダーに変換す
ることができます。

* Menu:

* Calendar Systems::         (グレゴリオ歴以外の)Emacsが理解するカレンダー。
* To Other Calendar::        選択された日付をさまざまなカレンダーに変換する。
* From Other Calendar::      他のカレンダーで指定された日付に移動する。


File: emacs-ja.info,  Node: Calendar Systems,  Next: To Other Calendar,  Up: Other Calendars

31.9.1 サポートされるカレンダーシステム
---------------------------------------

ISO商用暦(ISO commercial calendar)は、ビジネスで使われることがあります。

   ユリウス暦(Julian calendar)は、ジュリアス・シーザー(Julius Caesar)か
ら名前がつけられたカレンダーで、中世ヨーロッパで使用され、19世紀まで多く
の国で使用されてきました。

   天文学者は、ユリウス歴のB.C.4713年1月1日正午からの、単純な通算日を使
用します。この経過日は“ユリウス日(Julian day: JD)”、または“天文日
(Astronomical day)”と呼ばれます。

   ヘブライ暦(Hebrew calendar)は伝統的にユダヤ教(Jewish religion)で使用
されます。EmacsのカレンダープログラムはJewishの休日を決定するためにヘブ
ライ暦を使用します。ヘブライ暦では日没が1日の開始と終了です。

   イスラム暦(Islamic calendar)は、主にIslamic国で広く使用されます。
EmacsはIslamicの休日の日付を決定するのに、これを使用します。Islamicの世
界では、カレンダーについての世界的な取り決めが存在しません。Emacsは広く
受け入れられているバージョンを使用しますが、Islamicの休日の正確な日付は
、計算によってではなく、宗教的な権威による公告に依存することがしばしばあ
ります。結果として、行事の正確な日付はEmacsが計算する日付と若干違う場合
があります。イスラム暦では、日没が1日の開始と終了です。

   フランス革命暦(French Revolutionary calendar)は、より非宗教的で自然に
もとづいた観点により1年のサイクルを表すために、1789年の革命後にジャコバ
ン派(Jacobins)により作成されました。これはメートル法のような、合理的な目
安により1週が10日に設定されます。フランス政府は1805年の終わりに、このカ
レンダーを公式に放棄しました。

   中央アメリカのマヤには、互いに個別で重複した3つのカレンダーシステム
_long count_、_tzolkin_、_haab_があります。Emacsはこれら3つのカレンダー
すべてを知っています。専門家はマヤのカレンダーと私たちのカレンダーとの正
確な関連を議論しています。Emacsは、Goodman-Martinez-Thompsonの相関関係を
使用して計算を行ないます。

   コプト教徒(Copts: エジプト教会のクリスチャン)は、エジプト古代の太陽暦
にもとづいたカレンダーを使用します。彼らのカレンダーは30日からなる12の月
と、その後に余分の5日が含まれます。4年に1度、余分な5日に閏日を加えて6日
とします。エチオピア暦は構造的に同じですが、異なる年数と月の名前をもちま
す。

   ペルシャ人は、Omar Khayyamのデザインにもとづく太陽暦を使用します。か
れらのカレンダーは12の月を含み、最初の6ヶ月は31日、次の5ヶ月は30日、最後
の月は、通常の年は29日で、閏年は30日です。閏年は4年または5年後との複雑な
パターンで発生します。ここで実装されているカレンダーは、Birashkにより指
示されている数学的なペルシャ歴で、2820年周期にもとづいています。天文学的
なペルシャ暦との違いは、それが天文学的なイベントにもとづいている点です。
これを記述している時点で、2つの歴に最初に矛盾が発生すると予測されるのは
、2025年の3月20日です。現時点では、そのときのイランの公式カレンダーが何
になるかは、明確ではありません。

   旧暦(Chinese calendar)は、太陽年に太陰月を組み込んだ複雑なシステムで
す。年は60周期で、各年は通常の年は12ヶ月、閏年は13ヶ月です。各月は通常の
月は29日または30日です。年、通常月、日は10の“celestial stems”と、12の
“terrestrial branches”の組み合わせにより名前がつけられ、これが合計で60個
の名前となり、60回周期で繰り返されます。

   Bahá’íのカレンダーシステムは、19日を持つ19ヶ月の太陽周期にもとづきま
す。のこり4日の閏日(intercalary days)は、18ヶ月目と19ヶ月目の間に配され
ます。


File: emacs-ja.info,  Node: To Other Calendar,  Next: From Other Calendar,  Prev: Calendar Systems,  Up: Other Calendars

31.9.2 他のカレンダーへの変換
-----------------------------

以下のコマンドは、選択された日付(ポイント位置の日付)をさまざまなカレンダ
ーシステムで記述します:

‘mouse-3 Other calendars’
‘p o’
     選択された日付を、他のさまざまなカレンダーで表示します
     (‘calendar-print-other-dates’)。
‘p c’
     選択された日付を、ISO商用暦(ISO commercial calendar)で表示します
     (‘calendar-iso-print-date’)。
‘p j’
     選択された日付を、ユリウス日(Julian date)で表示します
     (‘calendar-julian-print-date’)。
‘p a’
     選択された日付を、ユリウス日にもとづく天文日(astronomical day)で表
     示します(‘calendar-astro-print-day-number’)。
‘p h’
     選択された日付を、ヘブライ暦の日付(Hebrew date)で表示します
     (‘calendar-hebrew-print-date’)。
‘p i’
     選択された日付を、イスラム暦の日付(Islamic date)で表示します
     (‘calendar-islamic-print-date’)。
‘p f’
     選択された日付を、フランス革命暦の日付(French Revolutionary date)で
     表示します(‘calendar-french-print-date’)。
‘p b’
     選択された日付を、Bahá’í dateで表示します
     (‘calendar-bahai-print-date’)。
‘p C’
     選択された日付を、旧暦の日付(Chinese date)で表示します
     (‘calendar-chinese-print-date’)。
‘p k’
     選択された日付を、Coptic dateで表示します
     (‘calendar-coptic-print-date’)。
‘p e’
     選択された日付を、Ethiopic dateで表示します
     (‘calendar-ethiopic-print-date’)。
‘p p’
     選択された日付を、ペルシャ暦の日付(Persian date)で表示します
     (‘calendar-persian-print-date’)。
‘p m’
     選択された日付を、マヤ暦の日付(Mayan date)で表示します
     (‘calendar-mayan-print-date’)。

   変換したい日付にポイントを移動して、上記のテーブルから‘p’で始まる適切
なコマンドをタイプします。プレフィクスの‘p’は、“print”のニーモニックです
。これは、Emacsが」変換した日付を、エコーエリアに“プリント”するからです
。‘p o’は日付を、Emacsが知るすべての形式で表示します。‘mouse-3’でクリッ
クして表示されるメニューから、‘Other calendars’を選択することもできます
。これは、日付をEmacsが知るすべての形式でメニュー形式で表示します(メニュ
ー形式で表示されるさまざまな形式の日付を選択しても、何もおこりません。こ
の場合、メニューは表示のためだけに使用されます)。


File: emacs-ja.info,  Node: From Other Calendar,  Prev: To Other Calendar,  Up: Other Calendars

31.9.3 他のカレンダーからの変換
-------------------------------

サポートされている他のカレンダーで日付を指定して、その日付に移動すること
ができます。このセクションでは、マヤ暦以外のカレンダーを使用してこれを行
なうコマンドを説明します。マヤ暦については、以降のセクションを参照してく
ださい。

‘g c’
     ISO商用暦(ISO commercial calendar)で指定された日付に移動します
     (‘calendar-iso-goto-date’)。
‘g w’
     ISO商用暦で指定された週に移動します(‘calendar-iso-goto-week’)。
‘g j’
     ユリウス暦(Julian calendar)で指定された日付に移動します
     (‘calendar-julian-goto-date’)。
‘g a’
     ユリウス暦にもとづく天文日で指定された日付に移動します
     (‘calendar-astro-goto-day-number’)。
‘g b’
     Bahá’í calendarで指定された日付に移動します
     (‘calendar-bahai-goto-date’)。
‘g h’
     ヘブライ暦(Hebrew calendar)で指定された日付に移動します
     (‘calendar-hebrew-goto-date’)。
‘g i’
     イスラム暦(Islamic calendar)で指定された日付に移動します
     (‘calendar-islamic-goto-date’)。
‘g f’
     フランス革命暦(French Revolutionary calendar)で指定された日付に移動
     します(‘calendar-french-goto-date’)。
‘g C’
     旧暦(Chinese calendar)で指定された日付に移動します
     (‘calendar-chinese-goto-date’)。
‘g p’
     ペルシャ暦(Persian calendar)で指定された日付に移動します
     (‘calendar-persian-goto-date’)。
‘g k’
     コプト暦(Coptic calendar)で指定された日付に移動します
     (‘calendar-coptic-goto-date’)。
‘g e’
     エチオピア暦(Ethiopic calendar)で指定された日付に移動します
     (‘calendar-ethiopic-goto-date’)。

   これらのコマンドは、他のカレンダーの日付の入力を求め、その日付と等価
なグレゴリオ暦(Ethiopic calendar)の日付に移動して、他のカレンダーの日付
をエコーエリアに表示します。Emacsは月の名前を入力するとき、常に強い補完
(*note Completion Exit::を参照してください)を使うので、ヘブライ、イスラ
ム、フランスの名前のスペルを心配する必要はありません。

   ヘブライ暦に関する一般的な問題として、“yahrzeit”と呼ばれる死亡日にた
いする記念日の計算があります。Emacsのカレンダーには、そのような計算の機
能が含まれています。カレンダーにいるときは、コマンド‘M-x
calendar-hebrew-list-yahrzeits’により、まず年の範囲の入力を求め、ポイン
ト位置の日付により、それらの年のyahrzeitの日付のリストを表示します。カレ
ンダーにいないときは、このコマンドは最初に死亡日、次に年の範囲の入力を求
め、yahrzeitの日付の一覧を表示します。


File: emacs-ja.info,  Node: Diary,  Next: Daylight Saving,  Prev: Other Calendars,  Up: Calendar/Diary

31.10 ダイアリー
================

Emacsのダイアリーはカレンダーと共に、日常のアポイントメントやその他のイ
ベントを管理します。ダイアリー機能を使うには、最初にイベントとその日付を
含むダイアリーファイル(diary file)を作成しなければなりません。Emacsは今
日、近い将来、指定された日付のイベントを自動的にピックアップして表示しま
す。

   ダイアリーの作成を手作業で行なおうと考えているかもしれませんが、
Emacsはダイアリーのエントリーを閲覧、追加、変更するいくつかのコマンドを
提供します。

* Menu:

* Format of Diary File::     ダイアリーにイベントを入力する。
* Displaying the Diary::     ダイアリーのエントリーと、それに関連するカレンダーの日付を閲覧する。
* Date Formats::             日付を指定するさまざまな方法。
* Adding to Diary::          ダイアリーのエントリーを作成するコマンド。
* Special Diary Entries::    記念日、日付ブロック、周期的なエントリーなど。
* Appointments::             何かを行なう時刻のためのリマインダー。
* Importing Diary::          ダイアリーのイベントと他のフォーマットの変換。


File: emacs-ja.info,  Node: Format of Diary File,  Next: Displaying the Diary,  Up: Diary

31.10.1 ダイアリーファイル
--------------------------

“ダイアリーファイル(diary file)”とは、特定の日付に関連付けられたイベント
を記録するファイルです。ダイアリーファイルの名前は、変数‘diary-file’によ
り指定されます。デフォルトは‘~/.emacs.d/diary’ですが、古いバージョンの
Emacsとの互換性のため、‘~/diary’が存在する場合は、それを使用します。

   ダイアリーファイルの各エントリーは、1つ以上の行からなる1つのイベント
を記述します。エントリーは、常に左端の日付指定で開始されます。エントリー
の残りの部分は、イベントを説明するテキストです。エントリーが複数行の場合
、2行目以降はそれが前のエントリーの継続行であることを示すために、空白文
字で開始しなければなりません。有効な日付で開始されておらず、前のエントリ
ーの継続行でもない行は無視されます。以下は例です:

     12/22/2015  Twentieth wedding anniversary!
     10/22       Ruth's birthday.
     * 21, *:    Payday
     Tuesday--weekly meeting with grad students at 10am
              Supowit, Shen, Bitner, and Kapoor to attend.
     1/13/89     Friday the thirteenth!!
     thu 4pm     squash game with Lloyd.
     mar 16      Dad's birthday
     April 15, 2016 Income tax due.
     * 15        time cards due.

この例では、ほとんどのエントリーにたいして、余分なスペースでイベント説明
を位置揃えしています。このようなフォーマットは、純粋に好みの問題です。

   ダイアリーエントリーの最初の行が、日付または曜日名(後にブランクも句読
点もない)だけの形式を使うこともできます。たとえば:

     02/11/2012
           Bill B. visits Princeton today
           2pm Cognitive Studies Committee meeting
           2:30-5:30 Liz at Lawrenceville
           4:00pm Dentist appt
           7:30pm Dinner at George's
           8:00-10:00pm concert

このエントリーは、シンプルなダイアリー表示を使ったときは、異なる表示にな
ります (*note Diary Display::を参照してください)。 シンプルなダイアリー
表示は最初の日付行を省略して、継続行だけが表示されます。このスタイルのエ
ントリーは、1日分だけのエントリーを表示するときはうまく表示されますが、
複数日のエントリーの場合は混乱するかもしれません。


File: emacs-ja.info,  Node: Displaying the Diary,  Next: Date Formats,  Prev: Format of Diary File,  Up: Diary

31.10.2 ダイアリーの表示
------------------------

1度ダイアリーファイルを作成すると、カレンダーを使ってそれを閲覧できます
。Calendarモードの外で、今日のイベントを閲覧することもできます。以下は
Calendarバッファーで参照されるキーバインドです。

‘mouse-3 Diary’
‘d’
     選択された日付の、すべてのダイアリーエントリーを表示します
     (‘diary-view-entries’)。
‘s’
     ダイアリーファイル全体を表示します(‘diary-show-all-entries’)。
‘m’
     表示されている日付で、ダイアリーエントリーをもつものをすべてマーク
     します(‘diary-mark-entries’)。
‘u’
     カレンダーウィンドウのマークを外します(‘calendar-unmark’)。
‘M-x diary-print-entries’
     表示されているダイアリーのハードコピーを印刷します。
‘M-x diary’
     今日の日付の、すべてのダイアリーエントリーを表示します。
‘M-x diary-mail-entries’
     近づきつつあるダイアリーエントリーのリマインダーとして、あなた自身
     にメールします。

   ‘d’でダイアリーエントリーを表示すると、カレンダーで選択された日付のダ
イアリーエントリーが別のバッファーに表示されます。新しいバッファーのモー
ドラインには、ダイアリーエントリーの日付が表示されます。休日はバッファー
とモードラインの両方で表示され、それは選択した表示方法に依存します
(*note Diary Display::を参照してください)。 ‘d’に数引数を指定した場合、
選択した日付から指定した日数までのすべてのダイアリーエントリーを表示しま
す。したがって、‘2 d’は選択された日と、その次の日のすべてのエントリーを
表示します。

   ある日付にたいするダイアリーエントリーを表示する別の方法は、日付を
‘mouse-3’でクリックして、表示されるメニューから‘Diary entries’を選択する
方法です。変数‘calendar-view-diary-initially-flag’が非‘nil’の場合、カレ
ンダーの作成により、その日のダイアリーエントリーがリストされます(その日
が表示されている場合)。

   より広い視点でダイアリーが記載されている日を知るには、‘m’コマンドを使
用します。これはダイアリーエントリーをもつ日付を、異なるフェイスでマーク
します。 *note diary-entry-marker: Calendar Customizing.を参照してくださ
い。

   このコマンドは現在表示されている月と、スクロールすることにより表示さ
れる月の両方に適用されます。マークを消すには‘u’をタイプします。これによ
り休日のマークもオフになります(*note Holidays::を参照してください)。変数
‘calendar-mark-diary-entries-flag’が非‘nil’の場合、カレンダーの作成また
は更新により、ダイアリーの日付が自動的にマークされます。

   カレンダーで、特定のダイアリーエントリーのマークを抑止するには、エン
トリーの開始、日付の前に、‘diary-nonmarking-symbol’で指定された文字列(デ
フォルトは‘&’)を挿入します。これはエントリーをダイアリーバッファーで表示
する場合は、影響ありません。カレンダーウィンドウで日付をマークするときだ
け影響があります。マークされないエントリーは、マークの数が多くなりすぎる
ような、一般的なエントリーにたいして有用かもしれません。

   限られたエントリーだけでなく、ダイアリーファイル全体を参照するには、
‘s’コマンドを使用します。

   コマンド‘M-x diary’は、カレンダーの表示とは独立に、その日のダイアリー
エントリーと、オプションでその後の何日かのダイアリーエントリーも同様に表
示します。何日分を含めるかは変数‘diary-number-of-entries’で指定してくだ
さい。 *note diary-number-of-entries: Diary Customizing.を参照してくださ
い。

   ‘.emacs’ファイルに‘(diary)’を記述した場合、Emacsを開始したときに、そ
の日のダイアリーエントリーのウィンドウを自動的に表示します。

   ダイアリーのイベント通知を、メールで受けとるのを好む人もいます。その
ようなメールをあなた自身に送るには、コマンド‘M-x diary-mail-entries’を使
用します。プレフィクス引数は、(今日から開始して)何日分をチェックするかを
指定します。プレフィクス引数を指定しない場合、変数‘diary-mail-days’によ
り、何日分をチェックするかが指定されます。


File: emacs-ja.info,  Node: Date Formats,  Next: Adding to Diary,  Prev: Displaying the Diary,  Up: Diary

31.10.3 日付のフォーマット
--------------------------

以下は、異なる方法でフォーマットされた日付を説明するために、ダイアリーエ
ントリーの例をいくつか示したものです。この例では、日付はすべてアメリカ形
式(月、日、年)ですが、Calendarモードは、オプションでヨーロッパ形式(日、
月、年)と、ISO形式(年、月、日)をサポートします。

     4/20/12  Switch-over to new tabulation system
     apr. 25  Start tabulating annual results
     4/30  Results for April are due
     */25  Monthly cycle finishes
     Friday  Don't leave without backing up files

   最初のエントリーは、2012年4月20日に1度だけ表示されます。2番目と3番目
のエントリーは毎年、指定した日に表示され、4番目のエントリーは月にワイル
ドカード(アスタリスク)を使っているので、毎月25日に表示されます。最後のエ
ントリーは毎週、金曜日に表示されます。

   ‘MONTH/DAY’や‘MONTH/DAY/YEAR’のように、日付を表すのに数字だけを使うこ
ともできます。この場合、その後に続く文字は数字以外の文字でなければなりま
せん。日付のMONTHとDAYは、1桁または2桁の数字です。オプションのYEARも数字
で、省略形として最後の2桁を使うこともできます。つまり、‘11/12/2012’また
は‘11/12/12’を使うことができます。

   日付は、‘MONTHNAME DAY’または‘MONTHNAME DAY, YEAR’という形式をもつこ
ともできます。月の名前のスペルには完全形、または省略形(最後のピリオドは
あってもなくてもよい)を指定できます。月または曜日の優先される省略形は、
変数‘calendar-abbrev-length’、‘calendar-month-abbrev-array’、
‘calendar-day-abbrev-array’を使ってセットできます。デフォルトは、名前の
最初の3文字を省略形として使用します。大文字小文字に違いはありません。

   日付は“ジェネリック(generic)” — つまり指定されていない部分があっても
構いません。この場合、エントリーは日付に指定された部分にマッチする、すべ
ての日付に適用されます。日付が年を含まない場合、これはジェネリックで、任
意の年に適用されます。かわりにMONTH、DAY、YEARに‘*’を使用することもでき
ます。これは任意の月、任意の日、任意の年にマッチします。したがって、日付
は‘3/*/*’のダイアリーエントリーは任意の年の3月の任意の日にマッチします。
‘march *’も同じです。

   ヨーロッパ形式(月の前に日を記述する)、またはISO形式(年、月、日の順で
記述する)で日付を記述したい場合は、カレンダーで‘M-x
calendar-set-date-style’とタイプするか、変数‘calendar-date-style’をカス
タマイズします。これはダイアリーの日付がどのように解釈されるか、日付の表
示、コマンドが与えられた引数に要求する順序に影響を与えます。

   週のある曜日に適用されるジェネリックな日付として、曜日名を使うことが
できます。曜日名は完全なスペルを記述するか、上述した省略形を使用できます
。大文字小文字に違いはありません。


File: emacs-ja.info,  Node: Adding to Diary,  Next: Special Diary Entries,  Prev: Date Formats,  Up: Diary

31.10.4 ダイアリーに追加するコマンド
------------------------------------

カレンダーでは、ダイアリーのエントリーを作成するコマンドがいくつかありま
す。以下は基本的なコマンドの一覧です。より複雑なコマンドは次のセクション
で説明します((*note Special Diary Entries::を参照してください))。エント
リーにはグレゴリオ暦以外も使用できます。 *note Non-Gregorian Diary::を参
照してください。

‘i d’
     選択された日付のダイアリーエントリーを追加します
     (‘diary-insert-entry’)。
‘i w’
     選択された曜日のダイアリーエントリーを、各週に追加します
     (‘diary-insert-weekly-entry’)。
‘i m’
     選択された日のダイアリーエントリーを、各月に追加します
     (‘diary-insert-monthly-entry’)。
‘i y’
     選択された日のダイアリーエントリーを、各年に追加します
     (‘diary-insert-yearly-entry’)。

   カレンダーウィンドウで日付を選択して、‘i d’コマンドをタイプすることに
より、特定の日付にたいするダイアリーエントリーを作成することができます。
このコマンドは、ダイアリーファイルの最後の部分を別のウィンドウに表示して
、その日付を追加します。その後、ダイアリーエントリーの残りの部分をタイプ
できます。

   毎週、特定の曜日に適用されるダイアリーエントリーを作成したいときは、
その曜日(同じ曜日ならどの日でも構いません)を選択して、‘i w’とタイプしま
す。これは曜日をジェネリックな日付として挿入します。そのあとダイアリーエ
ントリーの残りの部分をタイプできます。月ごとのダイアリーエントリーも同じ
やり方で作成できます。まず月のある日付を選択して、‘i m’コマンドを使い、
その後エントリーの残りの部分をタイプします。同様に‘i y’コマンドで、年ご
とのダイアリーエントリーを挿入できます。

   上記のすべてのコマンドは、デフォルトでマークされるダイアリーエントリ
ーを作成します。マークされないダイアリーエントリーを作成するには、コマン
ドにプレフィクス引数を与えます。たとえば、‘C-u i w’は、マークされない週
次のダイアリーエントリーを作成します。

   ダイアリーファイルを変更したときは、Emacsを終了する前にそのファイルを
保存してください。上記の挿入コマンドを使用した後でダイアリーファイルを保
存することにより、それが適切な場合は、カレンダーウィンドウのダイアリーの
マークを自動的に更新します。随時に更新させるには、コマンド
‘calendar-redraw’を使うことができます。


File: emacs-ja.info,  Node: Special Diary Entries,  Next: Appointments,  Prev: Adding to Diary,  Up: Diary

31.10.5 特別なダイアリーエントリー
----------------------------------

カレンダーの日付にもとづくエントリーに加え、ダイアリーファイルは記念日の
ような定期的なイベントにたいする、“sexpエントリー(sexp entries: S式エン
トリー)”を含むことができます。これらのエントリーは、Emacsがダイアリーフ
ァイルをスキャンすることにより評価される、Lisp式(sexp)にもとづきます。日
付のかわりに、sexpエントリーは‘%%’と、その後ろに続くLisp式を含んでおり、
Lisp式はカッコで始まりカッコで終わらなければなりません。Lisp式は、エント
リーが適用される日付を決定します。

   Calendarモードは、一般的に使用される特定のsexpエントリーを挿入するた
めのコマンドを提供します:

‘i a’
     選択された日付にたいして、記念日ダイアリーエントリー(anniversary
     diary entry)を追加します。
‘i b’
     カレントリージョンにたいして、ブロックダイアリーエントリー(block
     diary entry)を追加します。
‘i c’
     その日付に開始される、周期的ダイアリーエントリー(cyclic diary
     entry)を追加します。

   特定の日付の記念日に適用されるダイアリーエントリーを作成したい場合は
、ポイントをその日付に移動して‘i a’コマンドを使用します。これはダイアリ
ーファイルの最後の部分を別のウィンドウに表示して、記念日の記述を追加しま
す。その後ダイアリーエントリーの残りの部分をタイプできます。エントリーは
以下のようになります:

     %%(diary-anniversary 10 31 1988) Arthur's birthday

このエントリーは、1988年以降の任意の年の10月31日に適用されます。‘10 31
1988’は日付を指定します(ヨーロッパ形式またはISO形式を使用している場合、
入力順は月、日、年とは異なります)。この式が開始年を要求する理由は、ダイ
アリーの上級機能が、経過年数を計算できるようにするためです。

   “ブロック”ダイアリーエントリーは、特定の連続する日付範囲に適用されま
す。以下は2012年6月24日から2012年7月10日までの、すべての日付に適用される
ブロックダイアリーエントリーです:

     %%(diary-block 6 24 2012 7 10 2012) Vacation

‘6 24 2012’は開始日付を示し、‘7 10 2012’は終了日付を示します(繰り返しに
なりますが、ヨーロッパ形式またはISOカレンダー形式を使用している場合、月
、日、年の順は異なります)。

   ブロックエントリーを入力するには、開始と終了の範囲となる2つの日付にポ
イントとマークを配し、‘i b’とタイプします。このコマンドは、ダイアリーフ
ァイルの最後の部分を別のウィンドウに表示して、ブロックの記述を挿入します
。その後で、ダイアリーエントリーをタイプすることができます。

   “周期的(cyclic)”ダイアリーエントリーは、ある固定された日数の期間繰り
替えされるエントリーです。これを作成するには、開始日を選択して‘i c’コマ
ンドを使用します。コマンドは期間の長さの入力を求め、それから以下のような
エントリーを挿入します:

     %%(diary-cyclic 50 3 1 2012) Renew medication

このエントリーは、2012年3月1日以降の50日間適用されます。‘3 1 2012’は開始
日の指定です(ヨーロッパ形式またはISOカレンダー形式を使用している場合、月
、日、年の入力順は異なります)。

   これら3つのコマンドはすべて、ダイアリーエントリーをマークします。マー
クしないダイアリーエントリーを挿入するには、プレフィクス引数を与えます。
たとえば‘C-u i a’は、マークされない記念日ダイアリーエントリーを作成しま
す。

   カレンダーでsexpダイアリーエントリーを作成すると、カレンダーウィンド
ウで表示されているすべての日付にたいして個別にチェックしなければならない
ので、時間がかかるかもしれません。そのため、可能ならsexpダイアリーエント
リーを、(‘&’を使って)マークされないようにするのがよいでしょう。

   その他の複雑なsexpエントリーとして、“浮動(floating)”ダイアリーエント
リーがあります。これは日、週、年のオフセットで指定される、定期的に発生す
るイベントを指定するためのものです。これは‘cron’により解釈される
crontabエントリーに類似しています。以下はマークされない、浮動ダイアリー
エントリーで、11月の第4木曜日に適用されます。

     &%%(diary-float 11 4 4) American Thanksgiving

11は11月(11番目の月)を指定し、4は木曜日(週の第4日。日曜日は0)、2番目の
4は第4週(1は第1週、2は第2週、−2は最終週から2番目の週)を指定します。月は
1つの月、または月のリストを使用できます。したがって上記の11を‘'(1 2 3)’に
変更すると、このエントリーは1月、2月、3月の第4木曜日に適用されることにな
ります。月が‘t’の場合、そのエントリーは年の各月に適用されます。

   標準的なsexpダイアリーエントリーは、フェイス名またはカレンダーをマー
クするときに使用する1文字の文字列を指定する、オプションのパラメーターを
受け取ります。一般的には、sexpダイアリーエントリーは、それらが適用される
ときを決定するために、任意の計算を処理することができます。 *note Sexp
Diary Entries::を参照してください。


File: emacs-ja.info,  Node: Appointments,  Next: Importing Diary,  Prev: Special Diary Entries,  Up: Diary

31.10.6 Appointments
--------------------

アポイントメント(appointment: 約束、予約)にたいするダイアリーエントリー
がある場合、そのダイアリーエントリーが認識可能な日時で開始されていれば、
Emacsは保留されたアポイントメントがあることを警告することができます。
Emacsは、変数‘appt-display-format’で選択されたフォーマットでメッセージを
表示して、アポイントメントにたいする注意を喚起します。‘appt-audible’の値
が非‘nil’の場合、警告には音によるリマインダーも含まれます。加えて、
‘appt-display-mode-line’が非‘nil’の場合、Emacsはアポイントメントまで何分
あるかを、モードラインに表示します。

   ‘appt-display-format’の値が‘window’の場合、変数
‘appt-display-duration’がリマインダーウィンドウを表示する長さを制御しま
す。変数‘appt-disp-window-function’および‘appt-delete-window-function’は
、ウィンドウを生成または破棄する関数の名前を与えます。

   アポイントメントの通知を有効にするには、‘M-x appt-activate’とタイプし
ます。正の引数は通知を有効に、負の引数は通知を無効に、引数を指定しない場
合は通知のオンとオフを切り替えます。通知を有効にすることにより、ダイアリ
ーファイルから見つかった、認識可能な日時をもつすべてのダイアリーエントリ
ーにより、今日のアポイントメントリストをセットアップし、それらのアポイン
トメントの直前に注意を促します。

   たとえば、ダイアリーファイルに以下のような行が含まれているとします:

     Monday
       9:30am Coffee break
      12:00pm Lunch

月曜日には、9:20am頃にコーヒーブレーク、11:50am頃にランチの注意が促され
ます。変数‘appt-message-warning-time’には、前もって何分前(デフォルトは
12)に警告するかを指定します。これはデフォルトの警告タイムです。
‘appt-warning-time-regexp’に部分マッチングを追加することにより、各アポイ
ントメントに異なる警告タイムを指定できます(詳細は、この変数のドキュメン
トを参照してください)。

   時刻はam/pmスタイル(‘12:00am’は真夜中で、‘12:00pm’は正午)、またはヨー
ロッパ/軍隊の24時間制で記述できます。どちらを使うか一貫性がある必要はあ
りません。ダイアリーファイルで、この2つのスタイルを混交させることができ
ます。時刻が認識されるためは、それがダイアリーエントリーの最初に記述され
ていなければなりません。

   Emacsは、真夜中直後にダイアリーファイルから自動的にアポイントメントリ
ストを更新します。アポイントメント通知を再度有効にすることにより、随時に
更新させることができます。‘appt-display-diary’を‘nil’にセットしていなけ
れば、これらのアクションはその日のダイアリーバッファーにも表示されます。
アポイントメントリストは、ダイアリーファイル(またはそれをインクルードす
るファイル。 *note Fancy Diary Display::を参照) に保存されます。Orgモー
ドを使用していて、アポイントメントをOrgアジェンダファイルに保持したい場
合は、‘org-agenda-to-appt’コマンドを使用して、アポイントメントをアジェン
ダファイルのリストに追加できます。このコマンドについての詳細は、*note
Appointment reminders: (org)Weekly/daily agenda.を参照してください。

   アラーム時計のように、アポイントメント通知機能を使うこともできます。
コマンド‘M-x appt-add’は、ダイアリーファイルに影響を与えずに、アポイント
メントリストにエントリーを追加します。アポイントメントリストからエントリ
ーを削除するには、‘M-x appt-delete’を使います。


File: emacs-ja.info,  Node: Importing Diary,  Prev: Appointments,  Up: Diary

31.10.7 ダイアリーエントリーのインポートとエクスポート
------------------------------------------------------

Emacsのダイアリーファイルと、他のさまざまなフォーマットの間で、ダイアリ
ーエントリーを変換できます。

   Outlookが生成したアポイントメントメッセージから、ダイアリーエントリー
をインポートできます。そのようなメッセージをRmailやGnusで閲覧していると
きは、エントリーをインポートするために‘M-x diary-from-outlook’を実行しま
す。変数‘diary-outlook-formats’をカスタマイズすることにより、このコマン
ドに追加のアポイントメッセージ形式を認識させることができます。他のメール
クライアントは、‘diary-from-outlook-function’を適切な値にセットできます
。

   icalendarパッケージにより、Emacsダイアリーファイルと、‘RFC 2445 —
Internet Calendaring and Scheduling Core Object Specification
(iCalendar)’で定義されるiCalendarとの間で、データを変換することができま
す(初期のvCalendar形式も同様)。

   コマンド‘icalendar-import-buffer’は、カレントバッファーから
iCalendarデータを抽出して、それをダイアリーファイルに追加します。この関
数は、iCalendarデータを自動的に抽出するためにも適しています。たとえば
Rmailメールクライアントは、以下を使用できます:

     (add-hook 'rmail-show-message-hook 'icalendar-import-buffer)

   コマンド‘icalendar-import-file’は、iCalendarファイルをインポートして
、その結果をEmacsダイアリーファイルに追加します。たとえば:

     (icalendar-import-file "/here/is/calendar.ics"
                            "/there/goes/ical-diary")

もし違うファイルが存在する場合は、インポートファイルの内容を追加するため
に、‘#include’ディレクティブを使うことができます。 *note Fancy Diary
Display::を参照してください。

   ‘icalendar-export-file’を使って、Emacsダイアリーファイル全体を
iCalendar形式にエクスポートできます。ダイアリーファイルの一部をエクスポ
ートするには、関連する領域をマークして、‘icalendar-export-region’を呼び
出します。どちらの場合も、Emacsは結果をターゲットファイルに追加します。


File: emacs-ja.info,  Node: Daylight Saving,  Next: Time Intervals,  Prev: Diary,  Up: Calendar/Diary

31.11 サマータイム
==================

Emacsは、標準時とサマータイムの違いを理解します。日の出、日の入り、夏至
、冬至、春分、秋分、月の位相では、時刻を補正しています。サマータイムのル
ールは、場所によりさまざまで、歴史的にも異なります。処理を正しく行なうに
は、Emacsが使用するルールを知る必要があります。

   どこにいるかにより適用されるルールを、追跡するオペレーティングシステ
ムもあります。そのようなシステムでは、Emacsはそのシステムから必要な情報
を取得します。これらの情報の一部またはすべてが欠落している場合、Emacsは
現在マサチューセッツのケンブリッジで使用されているルールで、そのギャップ
を埋めます。その結果としてのルールが望むものでない場合、変数
‘calendar-daylight-savings-starts’および
‘calendar-daylight-savings-ends’をセットすることにより、Emacsに使用する
ルールを指定できます。

   これらの値は、変数‘year’を参照するLisp式で、サマータイムが開始または
終了される、‘(MONTH DAY YEAR)’という形式のリストによる、グレゴリオ暦の日
付として評価されます。その地域がサマータイムを使用しない場合、値は
‘nil’であるべきです。

   Emacsは、サマータイムの開始を決定するためにこれらの式を使い、休日リス
ト、太陽および月に関する時刻の補正を行ないます。

   マサチューセッツのケンブリッジにたいする値は、以下のとおりです:

     (calendar-nth-named-day 2 0 3 year)
     (calendar-nth-named-day 1 0 11 year)

つまり、‘year’で指定される年の、3番目の月(3月)の、第2週の0番目の曜日(日
曜日)と、、その年の11番目の月(11月)の、第1週の日曜日です。サマータイムが
10月1日から開始されるように変更する場合、
‘calendar-daylight-savings-starts’を以下のように変更します:

     (list 10 1 year)

   その地域でサマータイムがない、またはすべての時刻を標準時にしたい場合
は、‘calendar-daylight-savings-starts’と
‘calendar-daylight-savings-ends’を、‘nil’にセットします。

   変数‘calendar-daylight-time-offset’は、サマータイムと標準時の差を、分
で指定します。マサチューセッツのケンブリッジでは60です。

   最後に、2つの変数‘calendar-daylight-savings-starts-time’と
‘calendar-daylight-savings-ends-time’は、サマータイムの開始と終了の遷移
時に、地方時の真夜中から何分ずれるかを指定します。マサチューセッツのケン
ブリッジでは、変数の値は両方とも120です。


File: emacs-ja.info,  Node: Time Intervals,  Next: Advanced Calendar/Diary Usage,  Prev: Daylight Saving,  Up: Calendar/Diary

31.12 時間間隔の加算
====================

timeclockパッケージは、時間間隔を加算していくので、(たとえば)特定のプロ
ジェクトにどれだけ時間を費やしているか、追跡することができます(より上級
の代替手段はOrgモードの時間計測機能の使用である。*note (org)Clocking
work time::を参照されたい)。

   プロジェクトの作業を開始したとき‘M-x timeclock-in’コマンドを使用し、
作業を終えたら‘M-x timeclock-out’コマンドを使用します。これを行なうたび
に、プロジェクトの記録に時間間隔を追加します。違うプロジェクトの作業に変
更する場合は、‘M-x timeclock-change’を使用します。

   いくつかの時間間隔をからデータを収集したら、‘M-x
timeclock-workday-remaining’を使って、その作業にたいして今日の残り時間を
見ることができ(1日の作業時間の平均は通常8時間とみなします)、‘M-x
timeclock-when-to-leave’で作業を終了する時間を計算します。

   Emacsにたいして、モードラインに作業日の残り時間を表示させたいときは、
変数‘timeclock-modeline-display’を‘t’にセットするか、コマンド‘M-x
timeclock-modeline-display’を呼び出します。

   Emacsのカレントセッションを終了することは、そのプロジェクトの作業を終
えることを意味するか不明なので、デフォルトではEmacsは確認を求めます。し
かし変数‘timeclock-ask-before-exiting’の値を‘nil’にカスタマイズすること
により、確認を無視できます。その場合、明示的に‘M-x timeclock-out’か‘M-x
timeclock-change’を呼び出した場合だけ、カレントの時間間隔が終了したと
Emacsに告げます。

   timeclock関数は、‘~/.emacs.d/timelog’と呼ばれるファイルに、データを集
積することにより機能します。変数‘timeclock-file’をカスタマイズすることに
より、このファイルに違う名前を指定できます。手作業でtimeclockを編集した
り、timeclockのカスタマイズ可能な変数の値を変更したときは、コマンド‘M-x
timeclock-reread-log’を実行するべきです。


File: emacs-ja.info,  Node: Advanced Calendar/Diary Usage,  Prev: Time Intervals,  Up: Calendar/Diary

31.13 カレンダーとダイアリーの上級な機能
========================================

このセクションでは、カレンダーとダイアリーの、より上級で特別な機能をいく
つか説明します。まず最初に、個人的な好みに合うようにカレンダーをカスタマ
イズする、多くの方法を紹介します。

* Menu:

* Calendar Customizing::     カレンダーのレイアウトとフック。
* Holiday Customizing::      独自の休日を定義する。
* Mayan Calendar::           マヤ暦で指定された日付への移動。
* Date Display Format::      フォーマットの変更。
* Time Display Format::      フォーマットの変更。
* Diary Customizing::        セットできるデフォルト。
* Non-Gregorian Diary::      他のカレンダーにもとづくダイアリーエントリー。
* Diary Display::            ダイアリーを表示する方法の選択。
* Fancy Diary Display::      インクルードされたダイアリーファイルを使ったダイアリーエントリーのソート。
* Sexp Diary Entries::       より柔軟なダイアリーエントリー。


File: emacs-ja.info,  Node: Calendar Customizing,  Next: Holiday Customizing,  Up: Advanced Calendar/Diary Usage

31.13.1 カレンダーのカスタマイズ
--------------------------------

残念ながら、カレンダーの表示が3ヶ月であるのを変更することはできませんが
、変数‘calendar-left-margin’、‘calendar-day-header-width’、
‘calendar-day-digit-width’、‘calendar-column-width’、
‘calendar-intermonth-spacing’をカスタマイズすることにより、使用される空
白文字をカスタマイズすることはできます。各月の間に、たとえば週の番号を表
示するには、変数‘calendar-intermonth-header’と
‘calendar-intermonth-text’を、変数のドキュメントに記載されているようにカ
スタマイズします。

   変数‘calendar-month-header’は、カレンダーの各月の上に表示されるテキス
トを制御します。デフォルトでは月と年を表示します。変数
‘calendar-day-header-array’は、各月の各曜日の上に表示されるテキストを制
御します。デフォルトでは、各曜日の名前の最初の2文字を表示します。

   変数‘calendar-holiday-marker’は、休日をどのようにマークするか指定しま
す。この変数は、日付の隣に挿入する1文字の文字列か、その日付を表示するの
に使用するフェイス名です。同様に、変数‘diary-entry-marker’は、ダイアリー
エントリーをもつ日を、どのようにマークするか指定します。関数
‘calendar-mark-today’は、今日の日付をマークするのに
‘calendar-today-marker’を使用します。デフォルトでは、この目的のためにカ
レンダーは‘holiday’、‘diary’、‘calendar-today’という名前のフェイスを使い
ます。

   カレンダーの開始により、ノーマルフック
‘calendar-initial-window-hook’が実行されます。カレンダー表示の再計算では
、このフックは実行されません。しかし‘q’でカレンダーを離れ、再度カレンダ
ーに入ると、このフックが再び実行されます。

   変数‘calendar-today-visible-hook’は、カレンダーバッファーがカレンダー
のために準備された後、カレント日付がウィンドウで表示されるときに実行され
るノーマルフックです。このフックの用途の1つは、今日の日付のマークです。
これを行なうには、関数‘calendar-mark-today’または‘calendar-star-date’を
使います:

     (add-hook 'calendar-today-visible-hook 'calendar-mark-today)

同様のノーマルフック‘calendar-today-invisible-hook’は、カレント日付がウ
ィンドウに表示されなくなるとき実行されます。

   カレンダーのカーソル移動コマンドは、カーソルを移動した後に、フック
‘calendar-move-hook’を実行します。


File: emacs-ja.info,  Node: Holiday Customizing,  Next: Mayan Calendar,  Prev: Calendar Customizing,  Up: Advanced Calendar/Diary Usage

31.13.2 休日のカスタマイズ
--------------------------

Emacsが知る、デフォルト休日のリスト変数がいくつかあります。それは
‘holiday-general-holidays’、‘holiday-local-holidays’、
‘holiday-solar-holidays’、‘holiday-bahai-holidays’、
‘holiday-christian-holidays’、‘holiday-hebrew-holidays’、
‘holiday-islamic-holidays’、‘holiday-oriental-holidays’、
‘holiday-other-holidays’です。変数の名前は自己説明的であるべきです。たと
えば、‘holiday-solar-holidays’は、太陽と月に関連した休日のリストです。

   これらの休日リストにたいして、必要に応じて、下記で説明しているように
休日を削除したり追加してカスタマイズできます。これらを‘nil’にセットする
と、関連する休日は表示されなくなります。

   一般的な休日、すなわちholiday-general-holidaysは、デフォルトでは
United Statesで一般的な休日です。対照的に、‘holiday-local-holidays’と
‘holiday-other-holidays’は、デフォルトでは空です。前者はシステムワイドな
セッティング、後者は個人的な使用を意図しています。

   デフォルトでは、Emacsは世俗的なカレンダーに一般的に見出されるものを除
き、宗教的な休日のすべてを含んではいません。宗教的な休日の、より広範なコ
レクションのために、変数‘calendar-bahai-all-holidays-flag’、
‘calendar-christian-all-holidays-flag’、
‘calendar-hebrew-all-holidays-flag’。
‘calendar-islamic-all-holidays-flag’のどれか(またはすべて)を‘t’にセット
できます。

   それぞれの休日の変数は“holiday forms”のリストです。各formは休日(休日
のリストの場合もある)を記述します。以下は利用可能なholiday formの表です
。日付と月は1から数えますが、“曜日名(dayname)”は日曜日を0として数えます
。引数STRINGは、その休日を説明する文字列です。

‘(holiday-fixed MONTH DAY STRING)’
     グレゴリオ暦(Gregorian calendar)の固定日付です。

‘(holiday-float MONTH DAYNAME K STRING &optional DAY)’
     グレゴリオ暦のMONTH月DAY日の前または後のK番目の曜日
     DAYNAME(DAYNAME=0の場合は日曜日)です。Kが負の場合、月の最後から数え
     ます。オプションのDAYのデフォルトは、Kが正のときは1、負のときは
     MONTHの最後の日になります。

‘(holiday-chinese MONTH DAY STRING)’
     旧暦(Chinese calendar)の固定日付です。

‘(holiday-hebrew MONTH DAY STRING)’
     ヘブライ暦(Hebrew calendar)の固定日付です。

‘(holiday-islamic MONTH DAY STRING)’
     イスラム暦(Islamic calendar)の固定日付です。

‘(holiday-julian MONTH DAY STRING)’
     ユリウス暦(Julian calendar)の固定日付です。

‘(holiday-sexp SEXP STRING)’
     Lisp式SEXPにより計算される日付です。式は計算に変数‘year’を使い、
     ‘(MONTH DAY YEAR)’の形式のリストを返すか、その年に休日が発生しない
     場合は‘nil’を返すべきです。

‘(if CONDITION HOLIDAY-FORM)’
     条件CONDITIONが真のときだけ休日が発生します。

‘(FUNCTION [ARGS])’
     引数ARGSを指定して関数FUNCTIONを呼び出すことにより計算される日付の
     リストです。

   たとえばフランスで有名な7月14日のパリ革命記念日(Bastille Day)を追加し
たいとしましょう。以下でこれを行なうことができます:

     (setq holiday-other-holidays '((holiday-fixed 7 14 "Bastille Day")))

   多くの休日は、特定の月の特定の曜日に発生します。以下はVirgin Islandsで
有名な7月第4月曜日のHurricane Supplication Dayを記述します。

     (holiday-float 7 1 4 "Hurricane Supplication Day")

ここで7は7月、1は月曜日(日曜日は0、火曜日は2です)、4はその月の4番目(1は
1番目、2は2番目、−1は最後、−2は最後から2番目)を指定しています。

   Bahá’í暦、旧暦、ヘブライ暦、イスラム暦、ユリウス暦の固定日付に発生す
る休日を指定することもできます。たとえば、

     (setq holiday-other-holidays
           '((holiday-hebrew 10 2 "Last day of Hanukkah")
             (holiday-islamic 3 12 "Mohammed's Birthday")
             (holiday-julian 4 2 "Jefferson's Birthday")))

これは、Hanukkahの最後の日(ヘブライ暦の月はNisanを1として数えられます)、
Mohammedの誕生日を祝うイスラムの祭日(イスラム暦の月はMuharramを1として数
えられます)、そしてユリウス暦の1743年4月2日のThomas Jeffersonの誕生日を
記述したものです。

   条件付きの休日を含めるには、Emacs Lispの‘if’か、‘holiday-sexp’形式を
使用します。たとえばアメリカ大統領選挙は、4で割りきれる年の11月の第1月曜
日の後の、最初の火曜日に発生します:

     (holiday-sexp '(if (zerop (% year 4))
                        (calendar-gregorian-from-absolute
                         (1+ (calendar-dayname-on-or-before
                               1 (+ 6 (calendar-absolute-from-gregorian
                                       (list 11 1 year)))))))
                   "US Presidential Election")

または

     (if (zerop (% displayed-year 4))
         (holiday-fixed 11
                (calendar-extract-day
                  (calendar-gregorian-from-absolute
                    (1+ (calendar-dayname-on-or-before
                          1 (+ 6 (calendar-absolute-from-gregorian
                                   (list 11 1 displayed-year)))))))
                "US Presidential Election"))

   休日の決定に特別な計算が含まれるために、上記の形式に当てはまらない休
日もあります。そのような場合は、その計算を行なうLisp関数を記述しなければ
なりません。たとえば食(eclipses)を含めるには‘holiday-other-holidays’に
‘(eclipses)’を追加して、以下のような、カレンダーウィンドウに表示されてい
る月に関連するグレゴリオ暦の日付のリスト(空の場合もあり得る)を返す、
Emacs Lisp関数‘(eclipses)’を記述します。

     (((6 4 2012) "Lunar Eclipse") ((11 13 2012) "Solar Eclipse") ... )


File: emacs-ja.info,  Node: Mayan Calendar,  Next: Date Display Format,  Prev: Holiday Customizing,  Up: Advanced Calendar/Diary Usage

31.13.3 マヤ暦からの変換
------------------------

以下は、マヤ暦(Mayan calendar)にもとづく日付を選択するコマンドです:

‘g m l’
     long countカレンダーで指定された日付に移動します
     (‘calendar-mayan-goto-long-count-date’)。
‘g m n t’
     tzolkinカレンダーの次の周期の日付に移動します
     (‘calendar-mayan-next-tzolkin-date’)。
‘g m p t’
     tzolkinカレンダーの前の周期の日付に移動します
     (‘calendar-mayan-previous-tzolkin-date’)。
‘g m n h’
     haabカレンダーの次の周期の日付に移動します
     (‘calendar-mayan-next-haab-date’)。
‘g m p h’
     haabカレンダーの前の周期の日付に移動します
     (‘calendar-mayan-previous-haab-date’)。
‘g m n c’
     マヤ暦の次の周期の日付に移動します
     (‘calendar-mayan-next-calendar-round-date’)。
‘g m p c’
     マヤ暦の前の周期の日付に移動します
     (‘calendar-mayan-previous-calendar-round-date’)。

   これらのコマンドを理解するためには、マヤ暦(Mayan calendars)を理解する
必要があります。“long count”は以下の単位にもとづいて日数を計算します:

     1 kin = 1日   1 uinal = 20 kin   1 tun = 18 uinal
     1 katun = 20 tun   1 baktun = 20 katun

したがってlong countの日付12.16.11.16.6は、12baktunの16katunの11tunの
16uinalの6kinを意味します。Emacsのカレンダーはマヤ暦のlong countを
7.17.18.13.3まで遡ることができます。‘g m l’コマンドを使うときはマヤ暦の
long countの日付baktun、katun、tun、uinal、kinをピリオドで区切って入力し
ます。

   マヤ暦のtzolkinは、13日と20日の独立した周期を組み合わせた形式からなる
260日周期のカレンダーです。この周期が永遠に繰り替えされるので、Emacsはこ
のサイクルの前または次の位置に、後方または前方に移動するコマンドを提供し
ます。‘g m p t’は前のtzolkin日付に移動します。Emacsはtzolkin日付の入力を
求め、前の周期のその日付にポイントを移動します。同様に、‘g m n t’とタイ
プすると、次の周期のtzolkin日付に移動します。

   マヤ暦のhaabは、20日からなる18の月と、月に属さない5日間からなる365日
周期のカレンダーです。tzolkinの周期と同様に、この周期は永遠に繰り返され
るので、この周期の前または次の位置へ後方または前方に移動するコマンドがあ
ります。‘g m p h’は前のhaab日付に移動します。Emacsはhaab日付の入力を求め
、前の周期のその日付にポイントを移動します。同様に、‘g m n h’とタイプす
ると次の周期のhaab日付に移動します。

   マヤ暦ではtzolkin日付とhaab日付を組み合わせた日付も使用されていました
。この組み合わせや_calendar round_と呼ばれる、約52年の周期です。‘g m p
c’とタイプすると、Emacsはhaab日付とtzolkin日付の入力を求め、前の周期のそ
の組み合わせの日付にポイントを移動します。‘g m n c’を使用すると、次の周
期のsぽの組み合わせの日付にポイントを移動します。あり得ないhaab日付と
tzolkin日付の組み合わせをタイプした場合は、エラーをシグナルします。

   EmacsはMaya暦の名前の入力を求めるときは強い補完 (*note Completion
Exit::を参照してください) を使うので、スペルについて心配する必要はありま
せん。


File: emacs-ja.info,  Node: Date Display Format,  Next: Time Display Format,  Prev: Mayan Calendar,  Up: Advanced Calendar/Diary Usage

31.13.4 日付の表示フォーマット
------------------------------

‘calendar-date-display-form’をセットすることにより、ダイアリー、モードラ
イン、メッセージに表示される日付をカスタマイズできます。この変数は、文字
列形式の数字をもつ変数‘month’、‘day’、‘year’と、アルファベット文字列をも
つ‘monthname’、‘dayname’を含む式のリストを保持します。アメリカ様式では、
このリストのデフォルト値は以下のようになります:

     ((if dayname (concat dayname ", ")) monthname " " day ", " year)

ヨーロッパ様式では、この値のデフォルトは以下のようになります:

     ((if dayname (concat dayname ", ")) day " " monthname " " year)

デフォルトのISO日付は以下のようになります:

     ((format "%s-%.2d-%.2d" year (string-to-number month)
              (string-to-number day)))

他の典型的なアメリカ様式は以下のものです:

     (month "/" day "/" (substring year -2))


File: emacs-ja.info,  Node: Time Display Format,  Next: Diary Customizing,  Prev: Date Display Format,  Up: Advanced Calendar/Diary Usage

31.13.5 時刻の表示フォーマット
------------------------------

カレンダーとダイアリーは、デフォルトで1日の時刻を、‘am’または‘pm’と、1か
ら12の時刻と分によるアメリカ様式の慣習にしたがって表示します。00から23の
時刻による、ヨーロッパ様式(US軍用様式とも呼ばれる)にしたい場合は、変数
‘calendar-time-display-form’を変更することができます。この変数は式のリス
トです。このリストには文字列形式の数字をもつ変数‘12-hours’、‘24-hours’、
‘minutes’と、アルファベット文字列をもつ‘am-pm’、‘time-zone’を含めること
ができます。デフォルト値は以下のとおりです:

     (12-hours ":" minutes am-pm
               (if time-zone " (") time-zone (if time-zone ")"))

以下の値はヨーロッパ形式の時刻を提供します:

     (24-hours ":" minutes
               (if time-zone " (") time-zone (if time-zone ")"))

   1日の時刻を返すカレンダー関数は少ないことに注意してください(現在のと
ころsolar関数のみ)。


File: emacs-ja.info,  Node: Diary Customizing,  Next: Non-Gregorian Diary,  Prev: Time Display Format,  Up: Advanced Calendar/Diary Usage

31.13.6 ダイアリーのカスタマイズ
--------------------------------

ダイアリーウィンドウは通常、ダイアリーエントリーの日付が休日に相当する場
合は、モードラインとバッファー自身にそれを示します。休日をチェックするプ
ロセスは時間がかかることがあり、それは定義された休日に依存します。このよ
うな場合、‘diary-show-holidays-flag’を‘nil’にセットすることにより、ダイ
アリーの表示を速くすることができます。

   変数‘diary-number-of-entries’は、1度に表示されるダイアリーエントリー
の日数を制御します。これは‘calendar-view-diary-initially-flag’が‘t’のと
きの初期表示と、コマンド‘M-x diary’に影響します。たとえば値1(デフォルト
)は、その日のダイアリーエントリーだけを表示し、値2は翌日のエントリーも表
示します。値には7つの整数のvectorも指定できます。たとえば値が‘[0 2 2 2 2
4 1]’の場合、日曜日にはダイアリーエントリーは表示されず、月曜日から木曜
日までは当日と翌日のダイアリーエントリーが表示され、金曜日には金曜日から
月曜日のエントリーが表示され、土曜日にはその日のエントリーだけが表示され
ます。

   変数‘diary-date-forms’をセットすることにより、ダイアリーファイルの日
付形式をカスタマイズできます。この変数は日付を認識するパターンのリストで
す。各日付パターンは、要素が正規表現(*note (elisp)Regular Expressions::を
参照してください)、またはシンボル‘month’、‘day’、‘year’、‘monthname’、
‘dayname’のリストです。これらすべての要素は、ダイアリーファイルの特定の
種類のテキストにマッチするパターンに供されます。日付パターン全体がマッチ
するためには、リストの各要素が連続してマッチしなければなりません。

   日付パターンの正規表現は、標準の構文テーブルを変更してそれ自身の通常
の方法でマッチするので、‘*’は単語の構成要素になります。

   シンボル‘month’、‘day’、‘year’、‘monthname’、‘dayname’は、日付と考え
られる月番号、日付番号、年番号、月の名前、曜日名にマッチします。数字にマ
ッチするシンボルは、0で開始することもできます。名前にマッチするものは、
大文字名と、(‘calendar-month-abbrev-array’と
‘calendar-day-abbrev-array’で指定されるような)省略形を許容します。ダイア
リーエントリーの‘*’は“任意の月”の‘任意の日付”などを意味するので、すべて
のシンボルは‘*’にマッチすることができ、日付とみなされないものにもマッチ
するべきです。

   アメリカ様式での‘diary-date-forms’のデフォルト値は、
‘diary-american-date-forms’により提供されます:

     ((month "/" day "[^/0-9]")
      (month "/" day "/" year "[^0-9]")
      (monthname " *" day "[^,0-9]")
      (monthname " *" day ", *" year "[^0-9]")
      (dayname "\\W"))

変数‘diary-european-date-forms’および‘diary-iso-date-forms’は、他のデフ
ォルト様式を提供します。

   このリストの日付パターンは、_相互排他的(mutually exclusive)_でなけれ
ばならず、ダイアリーエントリーの任意の部分にマッチせず、日付と1文字の空
白文字だけにマッチしなければなりません。相互排他的であるならば、パターン
は日付を終端する空白文字を越えて、ダイアリーエントリーの一部にマッチしな
ければならず、日付パターンの最初の要素は‘バックアップ(backup)’されなけれ
ばなりません。これにより日付識別処理はマッチお終えた後、ダイアリーエント
リーの先頭の単語をバックアップします。‘backup’を使う場合でも、日付パター
ンはダイアリーエントリーの最初の単語の部分を越えてマッチしてはなりません
。たとえば‘diary-european-date-forms’は以下のようなデフォルト値です:

     ((day "/" month "[^/0-9]")
      (day "/" month "/" year "[^0-9]")
      (backup day " *" monthname "\\W+\\<\\([^*0-9]\\|\\([0-9]+[:aApP]\\)\\)")
      (day " *" monthname " *" year "[^0-9]")
      (dayname "\\W"))

3番目のパターンでの‘backup’の使用に注目してください。これは4番目のパター
ンと区別するために、日付自体を越えて単語の一部にマッチする必要があるから
です。


File: emacs-ja.info,  Node: Non-Gregorian Diary,  Next: Diary Display,  Prev: Diary Customizing,  Up: Advanced Calendar/Diary Usage

31.13.7 非グレゴリオ暦を使用するカレンダーエントリー
----------------------------------------------------

グレゴリオ暦にもとづくエントリーと同様に、ダイアリーはBahá’í、Chinese、
Hebrew、Islamicの日付にもとづくエントリーをもつことができます。そのよう
なエントリーの識別は時間がかかる場合がありますが、これらを使用する人はほ
とんどいないので、使用する場合は明示的に有効にしなければなりません。ダイ
アリーが、ダイアリーエントリーのHebrew日付を識別するようにしたい場合、た
とえば以下のようにして、これを行なわなければなりません:

     (add-hook 'diary-nongregorian-listing-hook 'diary-hebrew-list-entries)
     (add-hook 'diary-nongregorian-marking-hook 'diary-hebrew-mark-entries)

同様にIslamic、Bahá’í、Chineseのエントリーにたいしては、
‘diary-islamic-list-entries’と‘diary-islamic-mark-entries’、または
‘diary-bahai-list-entries’と‘diary-bahai-mark-entries’、または
‘diary-chinese-list-entries’と‘diary-chinese-mark-entries’を追加します。

   これらのダイアリーエントリーは、グレゴリオ日付のダイアリーエントリー
と同じフォーマットをもちます。例外は、Bahá’í日付の前には
‘diary-bahai-entry-symbol’(デフォルトは‘B’)、Chinese日付の前には
‘diary-chinese-entry-symbol’(デフォルトは‘C’)、Hebrew日付の前には
‘diary-hebrew-entry-symbol’(デフォルトは‘H’)、Islamic日付の前には
‘diary-islamic-entry-symbol’(デフォルトは‘I’)が前置されなければならない
ことです。さらに、非グレゴリオの月の名前は省略できません(最初の3文字では
一意にならないものがあるからです。一般的なHebrew年のAdarを使いたい場合は
、“Adar I”を使わなければならないことにも注意してください。) たとえば
Hebrew日付のHeshvan 25にたいするダイアリーエントリーは、以下のようになり
ます:

     HHeshvan 25 Happy Hebrew birthday!

これはヘブライ暦のHeshvan 25に対応する日付のダイアリーに表示されます。以
下はIslamic日付のDhu al-Qada 25にマッチするダイアリーエントリーです:

     IDhu al-Qada 25 Happy Islamic birthday!

   グレゴリオ日付のダイアリーエントリーのように、非グレゴリオのエントリ
ーも前に‘diary-nonmarking-symbol’(デフォルトは‘&’)が前置されている場合は
マークされません。

   以下は、選択された日付または他の日付にたいして、Bahá’í、Chinese、
Hebrew、Islamicの日付によるダイアリーエントリーを作成するコマンドの表で
す:

‘i h d’
     ‘diary-hebrew-insert-entry’
‘i h m’
     ‘diary-hebrew-insert-monthly-entry’
‘i h y’
     ‘diary-hebrew-insert-yearly-entry’
‘i i d’
     ‘diary-islamic-insert-entry’
‘i i m’
     ‘diary-islamic-insert-monthly-entry’
‘i i y’
     ‘diary-islamic-insert-yearly-entry’
‘i B d’
     ‘diary-bahai-insert-entry’
‘i B m’
     ‘diary-bahai-insert-monthly-entry’
‘i B y’
     ‘diary-bahai-insert-yearly-entry’
‘i C d’
     ‘diary-chinese-insert-entry’
‘i C m’
     ‘diary-chinese-insert-monthly-entry’
‘i C y’
     ‘diary-chinese-insert-yearly-entry’
‘i C a’
     ‘diary-chinese-insert-anniversary-entry’

   これらのコマンドは、通常のダイアリーエントリーの対応するコマンドに似
ています。これらはカレンダーウィンドウのポイント位置の日付に適用され、こ
れらのコマンドが行なうのはダイアリーファイルの最後にダイアリーエントリー
の日付部分を挿入することだけです。その後、ダイアリーエントリーの残りを挿
入しなければなりません。特定の非グレゴリオ日付のエントリーを追加する基本
的なコマンドとして、与えられた非グレゴリオ日を各月に追加する‘monthly’コ
マンド、与えられた非グレゴリオの月日を各年に追加する‘yearly’コマンドがあ
ります。


File: emacs-ja.info,  Node: Diary Display,  Next: Fancy Diary Display,  Prev: Non-Gregorian Diary,  Up: Advanced Calendar/Diary Usage

31.13.8 ダイアリーの表示
------------------------

ダイアリーの表示は、ダイアリーエントリーのリストを準備して、変数
‘diary-display-function’で指定された関数を実行することにより機能します。
デフォルト値の‘diary-fancy-display’は、ダイアリーエントリーを表示するた
めだけに存在する特別なバッファーにコピーして、ダイアリーエントリーと休日
を表示します。ダイアリーエントリーを別のバッファーにコピーすることにより
、表示されるテキストの見栄えをよくする機会 — たとえばダイアリーエントリ
ーに適用される日付順にソートするなど — が提供されます。

   通常、fancy diary(装飾的なダイアリー)バッファーは、たとえその日が休日
であっても、ダイアリーエントリーがない日は表示しません。そのような日を
fancy diaryバッファーに表示したいときは、変数
‘diary-list-include-blanks’を‘t’にセットします。

   fancy diaryバッファーはViewモードを有効にします (*note View Mode::を
参照してください)。

   他の表示方法の‘diary-simple-display’は、実際のダイアリーバッファーを
表示して、適合しないエントリーを隠すために非表示のテキストを使います。休
日はモードラインに表示されます。この方法の有利な点は、ダイアリーファイル
を直接編集して、変更を保存できることです。しかし、この方法はfancy方式の
ように柔軟ではありません。たとえば、これはエントリーのソートはできません
。他の不利な点としては、非表示のテキストが混乱の元となることがある点です
。たとえば、他の場所に張り付けるためにリージョンのテキストをコピーした場
合、非表示のテキストも含まれます。同様に、目に見えるダイアリーバッファー
は一種の幻影なので、単にバッファーを印刷しても、スクリーンで表示されてい
るものが印刷されるわけではありません。

   この理由により、ダイアリーバッファーのハードコピーを_見た通りに_印刷
する特別なコマンド‘M-x diary-print-entries’があります。これは、どちらの
表示方式でも機能します(たとえfancy displayバッファーが他のバッファーと同
じようにプリントできるとしても)。週の各曜日のハードコピーを印刷するには
、ポイントを週の初めの曜日に移動して‘7 d’とタイプし、それから‘M-x
diary-print-entries’を実行します。通常のように、休日が含まれる場合、表示
は若干遅くなります。変数‘diary-show-holidays-flag’を‘nil’にセットするこ
とにより、速度を改善することができます。

   このコマンドは、ダイアリーバッファーで現在可視なダイアリーエントリー
だけを含んだ一時的なバッファーを作成します。単なる表示とは異なり、他の無
関係なエントリーは隠されるだけではなく、まったく含まれません。バッファー
を作成したら、フック‘diary-print-entries-hook’が実行されます。このフック
のデフォルト値はコマンド‘lpr-buffer’で、これはデータを直接プリンターに送
信します (*note Printing::を参照してください)。 違うコマンドを印刷に使い
たい場合は、単にこのフックの値を変更するだけです。他のコマンドには、たと
えば行を日付と時刻順に再配置することなどが含まれるかもしれません。

   simpleダイアリーウィンドウで表示されているときと同じように、ダイアリ
ーエントリーを編集できますが、表示されているバッファーには、表示から隠さ
れている部分が含まれていることを覚えておくのは重要です。これは、たとえば
‘C-f’ (‘forward-char’)は表示されている最後の行にポイントを移動できますが
、実際は隠されている行の途中かもしれないことを意味します。

   _simple表示でダイアリーエントリーを編集するときは注意してください。
_表示されている行の途中での行の追加、文字の追加や削除は問題になりません
が、行の最後で編集する場合は、意図した通りにはならないでしょう。行の削除
は、それに続く他の非表示のエントリーを削除するかもしれません。simple
diaryバッファーで編集する前に、‘s’ (‘diary-show-all-entries’)でファイル
全体を表示するのが最善です。


File: emacs-ja.info,  Node: Fancy Diary Display,  Next: Sexp Diary Entries,  Prev: Diary Display,  Up: Advanced Calendar/Diary Usage

31.13.9 Fancy Diary表示
-----------------------

以下の機能は、fancy diary表示だけで機能します。

   ノーマルフック‘diary-list-entries-hook’を使用して、各曜日のダイアリー
エントリーを日時順でソートできます。以下はその方法です:

     (add-hook 'diary-list-entries-hook 'diary-sort-entries t)

これは各曜日にたいして、認識可能は日時で始まるダイアリーエントリーをソー
トします。時刻がないダイアリーエントリーは、各曜日の最初に配置されます。
ソートコマンドがフックリストの最後に配置されているわけに注意してください
。リストの最初の方に配置されている場合、これはダイアリーエントリーの順序
を変更したり、アイテムを追加します。

   コメント区切りとなる文字列を‘diary-comment-start’と
‘diary-comment-end’にセットすることにより、ダイアリーエントリーに‘コメン
ト’を記述できます。fancy表示はコメントを印刷しません。他のパッケージ(た
とえばappointmentパッケージ。 *note Appointments::を参照してください) で
使用するメタデータをコメント内に記述したいと思うかもしれません。

   メインとなるダイアリーファイルに、他のファイルをインクルードできます
。これにより、グループのメンバー全員に適用されるイベント用のダイアリーフ
ァイルを、共有することができます。ダイアリーファイルで、
‘diary-include-string’で開始される行:

     #include "FILENAME"

は、ファイルFILENAMEからダイアリーエントリーをfancy diaryバッファーにイ
ンクルードします。インクルードの仕組みは再帰的なので、インクルードされた
ファイルは他のファイルをインクルードできます(もちろん循環的なインクルー
ドについては注意しなければなりません)。インクルード機能を有効にするには
、以下のようにします:

     (add-hook 'diary-list-entries-hook 'diary-include-other-diary-files)
     (add-hook 'diary-mark-entries-hook 'diary-mark-included-diary-files)

   インクルード機能はfancy diaryだけで機能します。なぜならsimple diary表
示は、エントリーをダイアリーファイルから直接表示するからです。


File: emacs-ja.info,  Node: Sexp Diary Entries,  Prev: Fancy Diary Display,  Up: Advanced Calendar/Diary Usage

31.13.10 sexpエントリーとFancy Diary表示
----------------------------------------

sexp( s-expression: S式)ダイアリーエントリーにより、どのダイアリーエント
リーに適用するか、複雑な条件判定以上のことができます。sexpエントリーは、
ダイアリーファイルで‘diary-sexp-entry-symbol’(デフォルトは‘%%’)が前置さ
れている行です。fancy diary表示では、sexpエントリーはエントリーの日付に
応じて、エントリーのテキストを生成できます。

   たとえば記念日のダイアリーエントリーでは、記念日から経過した年数をダ
イアリーエントリーのテキストに挿入できます。したがって、以下のダイアリー
エントリーの‘%d’:

     %%(diary-anniversary 10 31 1948) Arthur's birthday (%d years old)

は年齢に置換されるので、1990年10月31日のfancy diaryバッファーでは、以下
のように表示されます:

     Arthur's birthday (42 years old)

かわりに、ダイアリーファイルに以下のようなエントリーが含まれている場合:

     %%(diary-anniversary 10 31 1948) Arthur's %d%s birthday

は1990年10月31日のfancy diaryバッファーで、以下のように表示されます:

     Arthur's 42nd birthday

   同様に、周期的なダイアリーエントリーは、それが繰り返し発生した回数を
挿入できます:

     %%(diary-cyclic 50 1 1 2012) Renew medication (%d%s time)

これは以下のように表示されます:

     Renew medication (5th time)

これは2012年9月7日のfancy diary表示です。

   発生する日付だけでなく、それより前のダイアリーエントリーを含めるため
の、事前リマインダー(early-reminder)となるsexpダイアリーエントリーもあり
ます。たとえば記念日の1週間前にリマインダーが欲しいときは、以下を使用し
ます

     %%(diary-remind '(diary-anniversary 12 22 1968) 7) Ed's anniversary

これにより、fancy diaryは12月15日と12月22日に、‘Ed's anniversary’を表示
します。

   関数‘diary-date’は、整数または‘t’(すべての値を意味します)からなる
month、day、yearの組み合わせで日付を指定します。たとえば、

     %%(diary-date '(10 11 12) 22 t) Rake leaves

これによりfancy diaryは

     Rake leaves

を毎年10月22日、11月22日、12月22日に表示します。

   関数‘diary-float’を使って、11月の第3金曜日や、4月の最後の火曜日といっ
た日付をダイアリーエントリーに記述することができます。パラメーターは
MONTH、DAYNAME、およびインデックスNです。エントリーはMONTHの最初の日の後
のN番目の曜日DAYNAMEに表示されます。ここでDAYNAME=0は日曜日、1は月曜日、
...です。Nが負の場合、MONTHの最後から後方に数えます。MONTHの値に指定でき
るのは、月のリスト、単一の月、‘t’の場合はすべての月を意味します。オプシ
ョンのパラメーターDAYを使用して、MONTHのDAY日目の後または前の、N番目の曜
日DAYNAMEを指定することもできます。DAYのデフォルト値は、Nが正のときは1で
、Nが負のときはと気はの最後の日です。たとえば、

     %%(diary-float t 1 -1) Pay rent

これによりfancy diaryは

     Pay rent

を毎月最後の月曜日に表示します。

   sexpダイアリーエントリーの一般性により、アルゴリズム的に記述したダイ
アリーエントリーを指定できます。sexpダイアリーエントリーには、任意の与え
られた日付にたいして、エントリーを適用するかどうかを計算する式が含まれま
す。値が非‘nil’の場合はその日付にエントリーが適用され、そうでない場合は
適用されません。式では判定する日付を変数‘date’で使用することができます。
この変数の値は、グレゴリオ暦を参照するリスト(MONTH DAY YEAR)です。

   sexpダイアリーエントリーは、式の値が非‘nil’のときはその日付に適用され
ますが、いくつかの値は特別な意味をもちます。値が文字列の場合、その文字列
はその日に発生するイベントを説明する文字列です。値は‘(MARK . STRING)’と
いう形式をもつこともできます。MARKは、カレンダーでその日をどのようにマー
クするかを指定し、STRINGはそのイベントの説明です。MARKが1文字の文字列の
場合、その文字はカレンダーの日付の隣に表示されます。MARKがフェイス名の場
合、その日はそのフェイスで表示されます。MARKが‘nil’の場合、その日を特に
ハイライト表示しません。

   21日がウィークデイのときは21日、21日が週末のときは前の日の金曜日に給
料が支払われるとしましょう。以下はそのような日付にマッチするsexpダイアリ
ーエントリーです:

     &%%(let ((dayname (calendar-day-of-week date))
              (day (cadr date)))
           (or (and (= day 21) (memq dayname '(1 2 3 4 5)))
               (and (memq day '(19 20)) (= dayname 5)))
              ) Pay check deposited

   以下のsexpダイアリーエントリーは、(fancy diary表示において)日付により
異なるテキストをもつダイアリーエントリーを作成することができます:

‘%%(diary-sunrise-sunset)’
     地方時で、今日の日の出と日の入りの時刻のダイアリーエントリーを作成
     します。
‘%%(diary-lunar-phases)’
     月の位相にたいするダイアリーエントリーを作成します。
‘%%(diary-day-of-year)’
     その年での通算日数と、その年の残り日数でダイアリーエントリーを作成
     します。
‘%%(diary-iso-date)’
     今日と等価な、ISO商用日付のダイアリーエントリーを作成します。
‘%%(diary-julian-date)’
     今日と等価な、ユリウス暦日のダイアリーエントリーを作成します。
‘%%(diary-astro-day-number)’
     今日と等価な、天文日(ユリウス日)のダイアリーエントリーを作成します
     。
‘%%(diary-bahai-date)’
     今日と等価な、Bahá’í暦日のダイアリーエントリーを作成します。
‘%%(diary-chinese-date)’
     今日と等価な、旧暦日のダイアリーエントリーを作成します。
‘%%(diary-coptic-date)’
     今日と等価な、Copticカレンダー日のダイアリーエントリーを作成します
     。
‘%%(diary-ethiopic-date)’
     今日と等価な、エチオピア暦日のダイアリーエントリーを作成します。
‘%%(diary-french-date)’
     今日と等価な、フランス革命暦の日付のダイアリーエントリーを作成しま
     す。
‘%%(diary-hebrew-date)’
     今日と等価な、ヘブライ暦の日付のダイアリーエントリーを作成します。
‘%%(diary-islamic-date)’
     今日と等価な、イスラム暦の非助のダイアリーエントリーを作成します。
‘%%(diary-mayan-date)’
     今日と等価な、マヤ暦の日付のダイアリーエントリーを作成します。
‘%%(diary-persian-date)’
     今日と等価な、Persian calendarの日付のダイアリーエントリーを作成し
     ます。

例えば、以下のようなダイアリーエントリーを含めると

     &%%(diary-hebrew-date)

fancy diary表示を使用している場合は、毎日のダイアリー表示に、その日に対
応するヘブライ暦の日付が含まれるようになります(simple diary表示を使用し
ている場合は、任意の日付のダイアリーにリテラル行
‘&%%(diary-hebrew-date)’が表示されます)。

   以下の関数は、特定の標準的なヘブライsexpダイアリーエントリーを構築す
るために使用されます:

‘%%(diary-hebrew-rosh-hodesh)’
     新しいヘブライ月にたいして、礼拝の発生と告知を告げるダイアリーエン
     トリーを作成します。
‘%%(diary-hebrew-parasha)’
     毎週のシナゴーグ経典(synagogue scripture)の読書会を告げる、土曜日の
     ダイアリーエントリーを作成します。
‘%%(diary-hebrew-sabbath-candles)’
     安息日のキャンドルライトを告げる、_地方時_のダイアリーエントリーを
     作成します。
‘%%(diary-hebrew-omer)’
     適切な場合は、omerを数えるダイアリーエントリーを作成します。
‘%%(diary-hebrew-yahrzeit MONTH DAY YEAR) NAME’
     命日をマークするダイアリーエントリーを作成します。命日の日付はグレ
     ゴリオ暦の日付です。ダイアリーエントリーは適切なヘブライ暦の命日、
     およびその前日に表示されます(カレンダーの日付様式に対応してパラメー
     ターの順序は変化します。たとえばヨーロッパ標識ではDAY、MONTH、
     YEARの順です)。
‘%%(diary-hebrew-birthday MONTH DAY YEAR)’
     ヘブライ暦での誕生日のダイアリーエントリーを作成します。

   上記でドキュメントされたすべての関数は、オプションの引数MARKを受け取
ります。これはカレンダー表示で、その日をどのようにマークするかを指定しま
す。上記の関数の1つが特定の日付に適用されると決定された場合、上述したよ
うにMARKを含んだ値を戻します。


File: emacs-ja.info,  Node: Sending Mail,  Next: Rmail,  Prev: Calendar/Diary,  Up: Top

32 メールの送信
***************

Emacsから電子メールのメッセージを送信するには、‘C-x m’とタイプします。こ
れはメッセージのテキストとヘッダーを編集できる、‘*unsent mail*’という名
前のバッファーに切り替えます。編集が終了したら‘C-c C-s’または‘C-c C-c’と
タイプして、それを送信します。

‘C-x m’
     メールの作成を開始します(‘compose-mail’)。
‘C-x 4 m’
     同様ですが、他のウィンドウで行ないます
     (‘compose-mail-other-window’)。
‘C-x 5 m’
     同様ですが、新しいフレームで行ないます
     (‘compose-mail-other-frame’)。
‘C-c C-s’
     メールバッファーでは、メッセージを送信します(‘message-send’)。
‘C-c C-c’
     メールバッファーでは、メッセージを送信して、そのバッファーを隠し
     (bury)ます(‘message-send-and-exit’)。

   メールバッファーは通常のEmacsバッファーなので、メールの作成中に他のバ
ッファーに切り替えることができます。現在のメールを終了する前に他のメール
を送信したい場合は、再度‘C-x m’とタイプして新しいメールバッファーを開き
ます、このバッファーは異なる数字が後ろについた名前をもちます(*note Misc
Buffer::を参照してください)。‘C-u C-x m’のように、プレフィクス引数を指定
してコマンドを呼び出した場合、Emacsは最後のメールバッファーに戻って、そ
のバッファーのメッセージを削除したいか尋ねます。これにnoと答えると、中止
した場所から編集を再開できます。

   コマンド‘C-x 4 m’ (‘compose-mail-other-window’)は、‘C-x m’と同じこと
を行ないますが、これはメールバッファーを別のウィンドウに表示します。コマ
ンド‘C-x 5 m’ (‘compose-mail-other-frame’)は、新しいフレームでこれを行な
います。

   ‘C-c C-c’または‘C-c C-s’とタイプしてメールを送信するとき、Emacsはどの
ようにしてメールを送信するべきか — SMTPを通じて直接送信するか、またはほ
かの方法を使うか — を尋ねます。詳細は、*note Mail Sending::を参照してく
ださい。

* Menu:

* Format: Mail Format.       メールメッセージのフォーマット。
* Headers: Mail Headers.     いくつかの標準的なメールヘッダーフィールドの詳細。
* Aliases: Mail Aliases.     メールアドレスの短縮とグループ化。
* Commands: Mail Commands.   作成するメールを編集するための特別なコマンド。
* Signature: Mail Signature.  各メッセージに署名を追加する。
* Amuse: Mail Amusements.    NSAを混乱させるキーワードや、fortuneのメッセージを累加する。
* Methods: Mail Methods.     他のメール作成方法を使用する。


File: emacs-ja.info,  Node: Mail Format,  Next: Mail Headers,  Up: Sending Mail

32.1 メールバッファーのフォーマット
===================================

以下はメールバッファーの内容の例です(訳注: 出典はコナン・ザ・グレートら
しいです):

     To: subotai@example.org
     Cc: mongol.soldier@example.net, rms@gnu.org
     Subject: Re: What is best in life?
     From: conan@example.org
     --text follows this line--
     To crush your enemies, see them driven before you, and to
     hear the lamentation of their women.

メールバッファーのトップは、一連の“ヘッダーフィールド(header fields)”で
す。これは電子メールの受取人、subject(題目)などに関する情報を指定するの
に使用されます。上記のバッファー例には‘To’、‘CC’、‘Subject’、‘From’のヘ
ッダーフィールドが含まれています。いくつかのヘッダーフィールドは、それが
適切なときは、事前に自動的に初期化されます。

   ‘--text follows this line--’という行は、ヘッダーフィールドとメッセー
ジの“body”(本文、または“text”)を分割します。この行の上にあるすべては、ヘ
ッダーの一部として扱われます。下にあるすべては、bodyとして扱われます。区
切り行自体は、実際に送信されるメッセージには含まれません。

   通常の編集コマンドで、ヘッダーフィールドの挿入と編集ができます。ヘッ
ダーフィールドを編集するための特定のコマンドについては、*note Header
Editing::を参照してください。‘Date’や‘Message-Id’のような特定のヘッダー
は、通常はメールバッファーでは省略され、メッセージを送信するとき自動的に
作成されます。


File: emacs-ja.info,  Node: Mail Headers,  Next: Mail Aliases,  Prev: Mail Format,  Up: Sending Mail

32.2 メールヘッダーフィールド
=============================

メールバッファーのヘッダーフィールドは、行の最初がフィールド名で始まりま
す。フィールド名はコロンで終端されます。フィールド名で大文字小文字は区別
されません。コロンとオプションの空白文字の後に、フィールドの内容を記述し
ます。

   好きな名前のヘッダーフィールドを使用できますが、多くの人は通常、一般
に認められた意味をもつは、標準的なフィールド名だけを使用します。

   ヘッダーフィールド‘From’は、電子メールを送信した人(あとえばあなた)を
識別します。これは有効なメールアドレスである必要があります。なぜなら、通
常はそのアドレスに返信されるからです。このヘッダーフィールドのデフォルト
の内容は、変数‘user-full-name’(あなたのフルネームを指定します)と
‘user-mail-address’(あなたの電子メールアドレス)から計算されます。いくつ
かのオペレーティングシステムでは、Emacsはこの2つの変数を環境変数から初期
化します(*note General Variables::を参照してください)。この情報が利用不
可能か間違っている場合、変数を自分でカスタマイズする必要があります(*note
Easy Customization::を参照してください)。

   変数‘mail-from-style’の値は、‘From’フィールドの内容をどのようにフォー
マットするかを指定します:

‘nil’
     ‘king@grassland.com’のように、アドレスだけを使用します。
‘parens’
     ‘king@grassland.com (Elvis Parsley)’のように、アドレスとフルネーム
     の両方を使用します。
‘angles’
     ‘Elvis Parsley <king@grassland.com>’のように、アドレスとフルネーム
     の両方を使用します。
any other value
     通常は‘angles’を使用します。しかし‘angles’では、構文的に有効にする
     ためにアドレスをクォートしなければならないときは、かわりに
     ‘parens’を使用します。これがデフォルトです。

   以下は‘From’以外の、一般的に使用されるフィールドの表です:

‘To’
     メッセージを送信するメールアドレスです。複数のアドレスを記述するに
     は、それらを区切るのにカンマを使用します。

‘Subject’
     メッセージのsubjectです。

‘CC’
     メッセージを送信する追加のメールアドレスです。これは‘To’と似ていま
     すが、受取人はそのメッセージが自分宛だと思うべきではありません。

‘BCC’
     実際に送信するメッセージのヘッダーには現れない、追加のメッセージ送
     信先のメールアドレスです。‘BCC’は“blind carbon copies”が由来です。

‘FCC’
     送信されたメッセージのコピーが追加されるべき、ファイルの名前です。
     ファイルがBabyl形式(Emacs23以前のRmailで使用されていました)の場合、
     EmacsはBabyl形式で書き込み、それ以外はmbox形式で書き込みます。
     Rmailバッファーがそのファイルをvisitしている場合、Emacsはそれに合わ
     せて更新します。複数のファイルを指定するには、複数の‘FCC’フィールド
     を使用して、各フィールドに1つのファイル名を記述します。

‘Reply-to’
     ‘From’のかわりとなる、返信が送信されるべきアドレスです。これは何ら
     かの理由により、‘From’のアドレスが返信を受け取れないときに使用しま
     す。

‘Mail-reply-to’
     このフィールドは‘Reply-to’より優先されます。メーリングリストの中に
     は、‘Reply-to’を独自の目的(問題の多い、何らかの方法)のために使用し
     ているものがあるため、これが使用されます。

‘Mail-Followup-To’
     follow-upメッセージのための、デフォルトの受取人のために使用する1つ
     以上のアドレスです。これは通常、登録しているメーリングリストからメ
     ッセージを受信するとき、余分なコピーを送らせないようにしたいときに
     使用します。

‘In-reply-to’
     返信するメッセージのための識別子です。ほとんどのメールリーダーは、
     関連するメッセージをまとめてグループ化するためにこの情報を使用しま
     す。このヘッダーは通常、Emacsに組み込まれた任意のメールプログラムで
     メッセージに返信するとき、自動的に充填されます。

‘References’
     以前の関連するメッセージのための識別子です。‘In-reply-to’と同じよう
     に、これは通常、自動的に充填されます。

‘To’、‘CC’、‘BCC’のフィールドは何回記述してもよく、また各フィールドには
カンマで括って複数のアドレスを含めることができます。この方法により、メッ
セージを送信する複数の場所を指定できます。これらのフィールドには継続行も
使用できます。フィールドの開始行に続く、空白文字で始まる1行以上の行は、
そのフィールドの一部とみなされます。以下は継続行を使用した‘To’フィールド
の例です:

     To: foo@example.net, this@example.net,
       bob@example.com

   変数‘mail-default-headers’に文字列をセットすることにより、特定のデフ
ォルトヘッダーを挿入するよう、Emacsに指示できます。これにより‘C-x m’でメ
ッセージヘッダーにその文字列が挿入されます。たとえば以下は、各メッセージ
にヘッダー‘Reply-to’と‘FCC’を追加する例です:

     (setq mail-default-headers
           "Reply-to: foo@example.com\nFCC: ~/Mail/sent")

デフォルトのヘッダーフィールドが、特定のメッセージにたいして適切でない場
合、メッセージを送信する前にそれらを編集する必要があります。


File: emacs-ja.info,  Node: Mail Aliases,  Next: Mail Commands,  Prev: Mail Headers,  Up: Sending Mail

32.3 メールエイリアス
=====================

“メールエイリアス(mail aliases)”を定義することができます。これは1つ以上
のメールアドレスを意味する短い呼び名です。デフォルトでは、メールエイリア
スはファイル‘~/.mailrc’で定義されます。変数‘mail-personal-alias-file’を
セットすることにより、異なるファイル名を指定できます。

   ‘~/.mailrc’でエイリアスを定義するには、以下のように記述します:

     alias NICK FULLADDRESSES

これはNICKがFULLADDRESSESに展開されるという意味で、FULLADDRESSESは単一の
アドレス、またはスペースで区切られた複数のアドレスです。たとえば
‘maingnu’が、‘gnu@gnu.org’とあなた自身のローカルのアドレスを意味するよう
定義するには、以下の行を記述します:

     alias maingnu gnu@gnu.org local-gnu

アドレスにスペースが含まれる場合は、以下のようにダブルクォートでアドレス
全体をクォートします:

     alias jsmith "John Q. Smith <none@example.com>"

その人の名前の部分などのような、アドレスの特定の部分をダブルクォートで括
る必要はないことに注意してください。Emacsは必要に応じてそれらを挿入しま
す。たとえば上記のアドレスは‘"John Q. Smith" <none@example.com>’のように
挿入されます。

   Emacsは、‘~/.mailrc’でのincludeコマンドも識別します。これらは以下のよ
うなものです:

     source FILENAME

ファイル‘~/.mailrc’は、Emacsだけのものではありません。他の多くのメールを
閲覧するプログラムが、メールアドレスのためにこれを使用し、他にもさまざま
なコマンドが含まれます。しかしEmacsは、エイリアスの定義とインクルードコ
マンド以外のすべてを無視します。

   メールエイリアスはabbrevのように — つまり、エイリアスの後で単語区切り
文字をタイプするとすぐに — 展開されます。この展開はヘッダーフィールド
‘To’、‘From’、‘CC’、‘BCC’、‘Reply-to’(およびそれらの‘Resent-’の変種)だけ
で展開されます。‘Subject’のような、他のヘッダーフィールドでは展開されま
せん。

   コマンド‘M-x mail-abbrev-insert-alias’を使って、エイリアスされたアド
レスを直接挿入することもできます。これは補完つきでエイリアス名を読み取り
、ポイント位置にそれの定義を挿入します。


File: emacs-ja.info,  Node: Mail Commands,  Next: Mail Signature,  Prev: Mail Aliases,  Up: Sending Mail

32.4 メールコマンド
===================

‘*mail*’バッファーのデフォルトのメジャーモードは、Messageモードと呼ばれ
ます。これはTextモードのように振る舞いますが、メッセージをより快適に編集
するために、‘C-c’プレフィクスを伴う、追加のコマンドをいくつか提供します
。

   このセクションでは、Messageモードで利用可能な、もっとも一般的に使用さ
れるコマンドを説明します。 Messageモードにはそれ自身のマニュアルがあり、
その機能についてより詳細に説明されています。*note Message:
(message)Top.を参照してください。

* Menu:

* Mail Sending::             メッセージを送信するコマンド。
* Header Editing::           ヘッダーフィールドに移動して編集するコマンド。
* Citing Mail::              返信するメッセージのクォート。
* Mail Misc::                ファイル添付、スペルチェックなど。


File: emacs-ja.info,  Node: Mail Sending,  Next: Header Editing,  Up: Mail Commands

32.4.1 メールの送信
-------------------

‘C-c C-c’
     そのメッセージを送信して、メールバッファーを隠し(bury)ます
     (‘message-send-and-exit’)。
‘C-c C-s’
     そのメッセージを送信して、メールバッファーを選択されたまま残します
     (‘message-send’)。

   メッセージを送信するために通常使用されるコマンドは、‘C-c C-c’
(‘mail-send-and-exit’)です。これはメッセージを送信して、メールバッファー
を隠す(bury) — つまりバッファーを再選択するときもっとも低い優先順位にな
るようにします。かわりにメールバッファーをkillしたい場合は、変数
‘message-kill-buffer-on-exit’を‘t’に変更してください。

   コマンド‘C-c C-s’ (‘message-send’)はメッセージを送信して、そのバッフ
ァーを選択されたまま残します。(たとえば新しい送信先のために)メッセージを
変更して、再度送信したい場合に、このコマンドを使用します。

   メッセージの送信により、フック‘message-send-hook’が実行されます。メー
ルバッファーがファイルをvisitしているバッファーの場合をのぞき、送信によ
りメールバッファーは変更なし(unmodified)とマークされます(ファイルを
visitしている場合は、そのファイルを保存したときだけ変更なしとマークされ
ます。このため、同じメッセージを2回送信しても警告はされません)。

   変数‘send-mail-function’は、メッセージの配送方法を制御します。値には
、以下の関数のどれか1つを指定します:

‘sendmail-query-once’
     配送方法(このリストの他の項目のうちの1つ)を尋ね、このメッセージにそ
     の方法を使用します。‘smtpmail-send-it’を通じてすでにメールの配送方
     法を変数にセットしていない場合(以下参照)、これがデフォルトです。

‘smtpmail-send-it’
     インターネットサービスプロバイダーの対外SMTPメールサーバーのような
     、外部のメールホストを通じてメールを送信します。そのSMTPサーバーに
     接続する方法をEmacsに指示していない場合、コマンドはこの情報の入力を
     求め、それは変数‘smtpmail-smtp-server’と、ファイル‘~/.authinfo’に保
     存されます。*note Emacs SMTP Library: (smtpmail)Top.を参照してくだ
     さい。

‘sendmail-send-it’
     システムのデフォルトの‘sendmail’プログラム、またはそれと等価なプロ
     グラムを使用してメールを送信します。これは、そのシステムがSMTPで直
     接メールを配送できるように、セットアップされている必要があります。

‘mailclient-send-it’
     メールバッファーを、システムで指定されたメールクライアントに渡しま
     す。詳細はファイル‘mailclient.el’の、コメントセクションを参照してく
     ださい。

‘feedmail-send-it’
     これは‘sendmail-send-it’と同様ですが、後で送信するためにメッセージ
     をキューできます。詳細は、ファイル‘feedmail.el’の、コメントセクショ
     ンを参照してください。

   非ASCII文字を含むメッセージを送信する場合、それらはコーディングシステ
ムでエンコードされる必要があります。コーディングシステムは通常、選択され
た言語環境(*note Language Environments::を参照してください)により、自動
的に指定されます。変数‘sendmail-coding-system’をセットすることにより、対
外に送信するメールのコーディングシステムを明示的に指定することができます
(*note Recognize Coding::を参照してください)。そのようにして決定されたコ
ーディングシステムで扱えない文字が、特定のメッセージに含まれる場合、
Emacsは利用可能なコーディングシステムのリストを表示して、使用するコーデ
ィングシステムの選択を求めます。*note Output Coding::を参照してください
。


File: emacs-ja.info,  Node: Header Editing,  Next: Citing Mail,  Prev: Mail Sending,  Up: Mail Commands

32.4.2 メールヘッダーの編集
---------------------------

Messageモードは、特定のヘッダーフィールドに移動したり、ヘッダーのアドレ
スを補完する、以下の特別なコマンドを提供します。

‘C-c C-f C-t’
     ‘To’ヘッダーに移動します(‘message-goto-to’)。
‘C-c C-f C-s’
     ‘Subject’ヘッダーに移動します(‘message-goto-subject’)。
‘C-c C-f C-c’
     ‘CC’ヘッダーに移動します(‘message-goto-cc’)。
‘C-c C-f C-b’
     ‘BCC’ヘッダーに移動します(‘message-goto-bcc’)。
‘C-c C-f C-r’
     ‘Reply-to’ヘッダーに移動します(‘message-goto-reply-to’)。
‘C-c C-f C-f’
     ‘Mail-Followup-To’ヘッダーフィールドに移動します
     (‘message-goto-followup-to’)。
‘C-c C-f C-w’
     ファイル名の補完つきで、新しい‘FCC’ヘッダーフィールドを追加します
     (‘message-goto-fcc’)。
‘C-c C-b’
     メッセージ本文の先頭に移動します(‘message-goto-body’)。
‘<TAB>’
     メールアドレスを補完します(‘message-tab’)。

   特定のヘッダーフィールドにポイントを移動するコマンドは、すべて‘C-c
C-f’というプレフィクスを指定します(‘C-f’は“field”が由来です)。指定したフ
ィールドが存在しない場合、コマンドは新たにそれを作成します(例外は
‘mail-fcc’で、これは毎回新たなフィールドを作成します)。

   コマンド‘C-c C-b’ (‘message-goto-body’)は、ポイントをヘッダー区切り行
の下 — つまり本文の先頭にポイントを移動します。

   ‘To:’、‘CC:’、‘BCC:’のようなアドレスを含むヘッダーフィールドを編集し
ているときは、<TAB> (‘message-tab’)をタイプすることにより、アドレスを補
完できます。これは2つの方法にもとづいて、そのアドレスにタイプするフルネ
ームを挿入しようと試みます。まず複数のディレクトリーサーバープロトコルを
認識するEUDCライブラリーを試み(*note EUDC: (eudc)Top.を参照してください
)、それに失敗したときはメールエイリアスによりアドレスの展開を試みます
(*note Mail Aliases::を参照してください)。メール本文のような、アドレスを
要求しないヘッダーフィールドにポイントがあるとき、<TAB>はタブ文字を挿入
するだけです。


File: emacs-ja.info,  Node: Citing Mail,  Next: Mail Misc,  Prev: Header Editing,  Up: Mail Commands

32.4.3 メールの引用
-------------------

‘C-c C-y’
     選択されたメッセージを、引用のためにメールリーダーからyankします
     (‘message-yank-original’)。
‘C-c C-q’
     他のメッセージから引用された各パラグラフをフィルします
     (‘message-fill-yanked-message’)。

   ‘C-c C-y’ (‘message-yank-original’)を使用して、返信するメッセージから
“引用(cite)”することができます。これは、そのメッセージのテキストをメール
バッファーに挿入します。このコマンドは、Rmailのように、Emacsから実行され
るメールリーダーから呼び出されたときだけ機能します。

   デフォルトでは、Emacsは引用されたテキストの各行の前に、文字列‘>’を挿
入します。このプレフィクス文字列は、変数‘message-yank-prefix’で指定され
ます。プレフィクス引数を指定して‘message-yank-original’を呼び出した場合
、引用のためのプレフィクスは挿入されません。

   ‘C-c C-y’を使用した後で、‘C-c C-q’ (‘message-fill-yanked-message’)と
タイプして、引用されたメッセージのパラグラフをフィルできます。‘C-c C-q’の
1つの使い方としては、そのようなパラグラフのすべてを個別にフィルすること
です。クォートされたメッセージの1つのパラグラフをフィルするには、‘M-q’を
使います。フィルが、あなたが使用している引用プレフィクスを自動的に処理し
ない場合は、フィルプレフィクスを明示的にセットしてみてください。*note
Filling::を参照してください。

   フック‘mail-citation-hook’を通じて、メールの引用をカスタマイズできま
す。たとえば、より柔軟な引用を提供するSuperciteパッケージを使うことがで
きます(*note (sc)Introduction::を参照してください)。


File: emacs-ja.info,  Node: Mail Misc,  Prev: Citing Mail,  Up: Mail Commands

32.4.4 メール、その他
---------------------

メールバッファーで‘C-c C-a’ (‘mml-attach-file’)とタイプすることにより、
送信するメッセージに、ファイルを“添付(attach)”できます。添付は、
MIME(Multipurpose Internet Mail Extensions)標準を使って行なわれます。

   ‘mml-attach-file’コマンドはファイル名と、添付ファイルの“content
type(内容のタイプ)”、“description(説明)”、“disposition(性質)”の入力を求
めます。通常content typeは自動的に検知されます。単に<RET>とタイプすると
、そのデフォルトが適用されます。descriptionは1行のテキストで、そのメール
の受取人には添付ファイルの隣に表示されます。これは空にすることもできます
。dispositionは‘inline’、または‘attachment’のどちらかです。‘inline’の場
合、メッセージ本文に添付ファイルへのリンクが表示され、‘attachment’の場合
は、本文とは別にリンクが表示されます。

   ‘mml-attach-file’コマンドは、Messageモードに特有なコマンドです。
Mailモードではかわりに、‘mail-add-attachment’を使用します。これはファイ
ル名の入力だけを求め、content typeとdispositionは自動的に決定されます。
添付ファイルの説明を含めたい場合は、それをメッセージの本文にタイプしてく
ださい。

   添付ファイルの実際の内容は、メールバッファーには挿入されません。かわ
りに、以下のような代替テキストがメールバッファーに挿入されます:

     <#part type="text/plain" filename="~/foo.txt" disposition=inline>
     <#/part>

‘C-c C-c’または‘C-c C-s’でメッセージを送信するとき、それと一緒に添付ファ
イルも送信されます。

   メッセージを作成しているとき、‘M-x ispell-message’とタイプして、メッ
セージテキストのスペル訂正を行なうことができます。受信メッセージから送信
用の下書きにyankした場合、このコマンドはyankされたテキストをスキップして
、あなた自身が挿入したテキストだけをチェックします(このコマンドはインデ
ント、またはあなたの入力と引用された行を区別する‘mail-yank-prefix’を調べ
ます)。*note Spelling::を参照してください。

   Messageモードをオンに切り替えると(‘C-x m’は自動的にこれを行ないます
)、ノーマルフックの‘text-mode-hook’と‘message-mode-hook’が自動的に実行さ
れます。新しい送信メッセージの初期化では、ノーマルフック
‘message-setup-hook’が実行されます。メールバッファーの外観を変更したい場
合は、このフックを使うことができます。*note Hooks::を参照してください。

   これらのフックの主な違いは、それらが呼び出されるタイミングだけです。
‘C-x m’, ‘message-mode-hook’とタイプしたときは、メールバッファーが作成さ
れた直後に‘message-mode-hook’が実行されます。その後‘message-setup’関数が
そのバッファーのデフォルトの内容を挿入します。これらのデフォルトの内容が
挿入された後に、‘message-setup-hook’が実行されます。

   既存のメッセージにたいして、‘C-x m’で作成を継続する場合、そのメールバ
ッファーに切り替えた直後に、‘message-mode-hook’が実行されます。バッファ
ーが変更されていない場合、またはそれを削除して新たに作成を開始する場合に
は、デフォルトの内容が挿入された後に、‘message-setup-hook’が実行されます
。


File: emacs-ja.info,  Node: Mail Signature,  Next: Mail Amusements,  Prev: Mail Commands,  Up: Sending Mail

32.5 メール署名
===============

各メッセージの最後に標準的なテキストの断片 — “メール署名(mail
signature)” — を追加できます。この署名には、あなたの電話番号や住所などの
情報を含めることができます。変数‘message-signature’は、Emacsがメール署名
を扱う方法を決定します。

   ‘message-signature’のデフォルト値は‘t’です。これはメール署名をファイ
ル‘~/.signature’から探すことを意味します。ファイルが存在する場合、そのフ
ァイルの内容がメールバッファーの最後に自動的に挿入されます。変数
‘message-signature-file’を通じて署名ファイルを変更できます。

   ‘message-signature’を文字列に変更すると、それは署名のテキストを直接指
定することになります。

   ‘message-signature’を‘nil’に変更した場合、Emacsはメール署名を自動的に
挿入しません。メールバッファーで‘C-c C-w’ (‘message-insert-signature’)と
タイプすることにより、メール署名を挿入できます。この場合も、Emacsは署名
ファイルから署名を探します。

   メールを作成するのにMessageモードではなくMailモードを使用する場合、ど
のようにして署名を送るか決定する変数は、‘mail-signature’と
‘mail-signature-file’になります。

   慣例により、メール署名は行の内容が‘-- ’であることによりマークされるべ
きです。署名にこのプレフィクスがない場合、このプレフィクスが追加されます
。署名は4行を超えないようにするべきです。


File: emacs-ja.info,  Node: Mail Amusements,  Next: Mail Methods,  Prev: Mail Signature,  Up: Sending Mail

32.6 アミューズメント
=====================

‘M-x spook’は、送信するメールメッセージに、ランダムに選択されたキーワー
ドの行を追加します。これらのキーワードは、あなたが何らかの破壊活動を企て
ていると思わせるような単語のリストから選択されます。

   この機能の背後にあるアイデアは、NSA(1)や他の情報機関が、かれらが関心
をもつキーワードを含むすべてのインターネットメールのメッセージを監視して
いるという疑惑です(そのような政府機関は、“やっていない”と言いますが、も
ちろんかれらはそう言うでしょう)。このアイデアは、もし多くの人々がメッセ
ージに不審な単語を含めれば、政府機関は不審な入力で手一杯になり、やがて最
後はそれらを読むのを止めるだろうというものです。これが本当かどうかはわか
りませんが、少なくとも人々を楽しませることができます。

   ‘fortune’プログラムを使用して、送信メールにフォーチューンクッキー
(fortune cookie)メッセージを追加できます。これを行なうには
‘mail-setup-hook’に‘fortune-to-signature’を追加してください。

     (add-hook 'mail-setup-hook 'fortune-to-signature)

多分、これを使う前に変数‘fortune-file’をセットする必要があるでしょう。

   ---------- Footnotes ----------

   (1) The US National Security Agency.


File: emacs-ja.info,  Node: Mail Methods,  Prev: Mail Amusements,  Up: Sending Mail

32.7 メール作成方法
===================

このチャプターでは、メールを編集したり送信する通常のEmacsモードである、
Messageモードを説明してきました。これは、いくつかの利用可能なモードのう
ちの1つに過ぎません。Emacs23.2以前では、デフォルトのモードはMailモードで
、これは多くの点でMessageモードに似ていますが、MIMEサポートのような機能
がありません。その他の利用可能なモードはMH-Eです(*note MH-E: (mh-e)Top.を
参照してください)。

   これらの“メールユーザーエージェント(mail user agents)”から、メールを
編集したり送信するための、好みの方法を選択できます。コマンド‘C-x m’、
‘C-x 4 m’、‘C-x 5 m’は指定されたエージェントを使用するので、Emacsでメー
ルを送信する他の様々な部分(たとえばバグリポーターなど、*note Bugs::を参
照してください)もこれを行ないます。メールユーザーエージェントを指定する
には、変数‘mail-user-agent’をカスタマイズします。現在のところ、正式な値
には‘message-user-agent’(Messageモード)、‘sendmail-user-agent’(Mailモー
ド)、‘gnus-user-agent’、‘mh-e-user-agent’が含まれます。

   他のメール作成方法を選択した場合、メールバッファーとMessageモードに関
するこのチャプターの情報は適用できません。他の方法は違うバッファーで異な
るフォーマットのテキストを使用し、コマンドも異なります。

   同様に、メールを読むための好みの方法を指定するには、変数
‘read-mail-command’をカスタマイズします。デフォルトは‘rmail’です(*note
Rmail::を参照してください)。


File: emacs-ja.info,  Node: Rmail,  Next: Gnus,  Prev: Sending Mail,  Up: Top

33 Rmailでメールを読む
**********************

Rmailは、メールを閲覧したり処理するための、Emacsのサブシステムです。
Rmailは、Rmailファイルを呼ばれるファイルに、メールメッセージを保存します
。Rmailファイルの中のメッセージの閲覧は、Rmailモードという特別なメジャー
モードで行なわれます。このモードはメールを管理するために実行するコマンド
のために、多くの文字を再定義します。

   Emacsには、より複雑かつ柔軟なGnusと呼ばれるメールを読むためのサブシス
テムが同梱されています。Gnusは巨大なパッケージなので、独自のマニュアル
*note (gnus)Top::で説明されているので、それを参照してください。

* Menu:

* Basic: Rmail Basics.       Rmailの基本的な概念と簡単な使い方。
* Scroll: Rmail Scrolling.   メッセージをスクロールする。
* Motion: Rmail Motion.      他のメッセージへの移動。
* Deletion: Rmail Deletion.  メッセージの削除と完全な削除。
* Inbox: Rmail Inbox.        メールがRmailファイルに取り込まれる方法。
* Files: Rmail Files.        複数のRmailファイルの使用。
* Output: Rmail Output.      ファイルの外へメッセージをコピーする。
* Labels: Rmail Labels.      メッセージにラベルをつけて分類する。
* Attrs: Rmail Attributes.   属性と呼ばれる標準的なラベル。
* Reply: Rmail Reply.        閲覧しているメッセージにたいして返信する。
* Summary: Rmail Summary.    多くのメッセージの簡単な情報の要約。
* Sort: Rmail Sorting.       Rmailでのメッセージのソート。
* Display: Rmail Display.    Rmailがメッセージを表示する方法とカスタマイズ。
* Coding: Rmail Coding.      Rmailがデコードされた文字セットを扱う方法。
* Editing: Rmail Editing.    Rmailでのメッセージのテキストとヘッダーの編集。
* Digest: Rmail Digest.      メッセージのダイジェストからメッセージを抽出する。
* Rot13: Rmail Rot13.        rot13コードでエンコードされたメッセージの閲覧。
* Movemail::                 新たなメールのフェッチに関する詳細。
* Remote Mailboxes::         リモートmailboxからのメールの取得について。
* Other Mailbox Formats::    さまざまなフォーマットのローカルmailboxからのメールの取得。


File: emacs-ja.info,  Node: Rmail Basics,  Next: Rmail Scrolling,  Up: Rmail

33.1 Rmailの基本的な概念
========================

もっとも簡単な方法でRmailを使用するには、メールが保存される‘~/RMAIL’とい
うRmailファイルを使用します。これは“プライマリーRmailファイル(primary
Rmail file)”と呼ばれます。コマンド‘M-x rmail’はプライマリーRmailファイル
を読み込み、inbox(受信箱)から新しいメールをマージして、未読の最初のメッ
セージを表示して、それを閲覧出きるようにします。変数‘rmail-file-name’は
プライマリーRmailファイルの名前を指定します。

   Rmailは、Rmailファイルのメッセージを、1度に1つだけ表示します。表示さ
れているメッセージは、“カレントメッセージ(current message: 現在のメッセ
ージ)”と呼ばれます。Rmailモードの特別なコマンドは、カレントメッセージの
削除、他のファイルへのコピー、返信、他のメッセージへの移動を行なうことが
できます。複数のRmailファイル(*note Files::を参照)を作成して、それらの間
でメッセージの移動をするのに、Rmailを使用することができます(*note Rmail
Output::を参照)。

   Rmailファイルでは通常、メッセージは受信した順になっています。それらを
ソートする他の方法を指定できます(*note Rmail Sorting::を参照してください
)。メッセージは連続する整数で識別され、それは“メッセージナンバー(message
numbers)”と呼ばれます。カレントメッセージのナンバーはRmailのモードライン
に表示され、その後にはファイル内のメッセージの総数が続きます。‘j’でメッ
セージナンバーを指定して、そのメッセージに移動できます(*note Rmail
Motion::を参照してください)。

   通常のEmacsの慣例にしたがい、Rmailでの変更は、そのファイルを保存した
ときだけ永続化されます。‘s’ (‘rmail-expunge-and-save’)で、ファイルを保存
することができます、これは最初に削除されたメッセージをファイルから完全に
削除します(*note Rmail Deletion::を参照してください)。完全な削除を行なわ
ずにファイルを保存するには、‘C-x C-s’を使用します。Rmailは、inboxファイ
ルから新しいメールをマージした後に、自動的にRmailファイルを保存します。

   Rmailをexitするには、‘q’ (‘rmail-quit’)を使用します。これはRmailにた
いして完全な削除と保存を行い、Rmailバッファーと、(表示されていれば)サマ
リーバッファーを隠します(*note Rmail Summary::を参照してください)。しか
し正式にexitする必要はありません。Rmailから他のバッファーを編集するため
に切り替えて、2度とRmailに戻らなければ、それはexitしたことになります。
(他の変更したファイルと同様に)最終的にRmailファイルを確実に保存すること
だけが重要です。これを行なうには‘C-x s’が適しています(*note Save
Commands::を参照してください)。Rmailコマンドの‘b’ ‘rmail-bury’は、
Rmailファイルにたいする完全な削除と保存を行なわずに、Rmailバッファーとサ
マリーを隠します。


File: emacs-ja.info,  Node: Rmail Scrolling,  Next: Rmail Motion,  Prev: Rmail Basics,  Up: Rmail

33.2 メッセージのスクロール
===========================

Rmailが画面に収まらないメッセージを表示しているときは、残りを読むために
スクロールしなければなりません。通常のスクロールコマンド‘C-v’、‘M-v’、
‘M-<’ (*note Scrolling::を参照)などでこれを行なうことができますが、
Rmailでのスクロールは頻繁に行なわれるので、簡単に行なえるようにする価値
があります。

‘<SPC>’
     前方にスクロールします(‘scroll-up-command’)。
‘<DEL>’
‘S-<SPC>’
     後方にスクロールします(‘scroll-down-command’)。
‘.’
     メッセージの最初にスクロールします(‘rmail-beginning-of-message’)。
‘/’
     メッセージの最後にスクロールします(‘rmail-end-of-message’)。

   メッセージを読むときにもっとも一般的に行なうのは、画面単位でメッセー
ジをスクロールすることなので、Rmailは<SPC>と<DEL>(または‘S-<SPC>’)で、
‘C-v’ (‘scroll-up-command’)と‘M-v’ (‘scroll-down-command’)と同じことを行
なうようにしています。

   コマンド‘.’ (‘rmail-beginning-of-message’)は、選択されたメッセージの
最初に、後方へスクロールします。これは‘M-<’とまったく同じではありません
。このコマンドはマークをセットしません。他にも、カレントメッセージのバッ
ファー境界を変更していた場合(たとえば編集により。*note Rmail Editing::を
参照されたい)は、それをリセットします。同様に、コマンド‘/’
(‘rmail-end-of-message’)は、選択されたメッセージの最後に、前方へスクロー
ルします。


File: emacs-ja.info,  Node: Rmail Motion,  Next: Rmail Deletion,  Prev: Rmail Scrolling,  Up: Rmail

33.3 メッセージ間の移動
=======================

メッセージにたいして行なうもっとも基本的なことは、それを読むことです。
Rmailでこれを行なうために、そのメッセージをカレントにします。通常の方法
はファイルを、受信したメッセージ順に移動していく方法です(その最初のメッ
セージは‘unseen’(未読)の属性をもちます。*note Rmail Attributes::を参照し
てください)。他の新しいメッセージを読むには、前方に移動します。古いメッ
セージを再読するには後方に移動します。

‘n’
     間にある削除されたメッセージをスキップして、次の削除されていないメ
     ッセージに移動します(‘rmail-next-undeleted-message’)。
‘p’
     前の削除されていないメッセージに移動します
     (‘rmail-previous-undeleted-message’)。
‘M-n’
     削除されたメッセージも含めて、次のメッセージに移動します
     (‘rmail-next-message’)。
‘M-p’
     削除されたメッセージも含めて、前のメッセージに移動します
     (‘rmail-previous-message’)。
‘C-c C-n’
     カレントメッセージと同じsubjectの、次のメッセージに移動します
     (‘rmail-next-same-subject’)。
‘C-c C-p’
     カレントメッセージと同じsubjectの、前のメッセージに移動します
     (‘rmail-previous-same-subject’)。
‘j’
     最初のメッセージに移動します。引数Nを指定すると、N番目のメッセージ
     に移動します(‘rmail-show-message’)。
‘>’
     最後のメッセージに移動します(‘rmail-last-message’)。
‘<’
     最初のメッセージに移動します(‘rmail-first-message’)。
‘M-s REGEXP <RET>’
     REGEXPへのマッチを含む、次のメッセージに移動します
     (‘rmail-search’)。
‘- M-s REGEXP <RET>’
     REGEXPへのマッチを含む、前のメッセージに移動します(これは負の引数に
     よる‘M-s’である)。

   ‘n’と‘p’は、Rmailでメッセージを移動する通常の方法です。これらは、(通
常そうしたいように)削除されたメッセージをスキップして、メッセージを順番
に移動していきます。これらのコマンドの定義には、
‘rmail-next-undeleted-message’および‘rmail-previous-undeleted-message’と
いう名前がつけられています。削除されたメッセージをスキップしたくない場合
— たとえばメッセージの削除を取り消すために — は、変種の‘M-n’と
‘M-p’(‘rmail-next-message’と‘rmail-previous-message’)を使います。これら
のコマンドへの数引数は、繰り返し回数を指定します。

   Rmailでは数引数の指定は、単に数字をタイプして行なうことができます。最
初に‘C-u’をタイプする必要はありません。単に‘-’とタイプして、負の引数を指
定することもできます。

   ‘M-s’ (‘rmail-search’)は、Rmail版の検索コマンドです。通常のインクリメ
ンタル検索‘C-s’は機能しますが、これはカレントメッセージだけを検索します
。‘M-s’の目的は、他のメッセージにたいする検索です。これは非インクリメン
タルに正規表現(*note Regexps::を参照してください)を読み取り、後続のメッ
セージの先頭から検索を開始して、見つかったらそのメッセージを選択します。
REGEXPが空の場合、‘M-s’は前回使用したregexpを再使用します。

   ファイルの中の他のメッセージにたいして後方に検索するには、‘M-s’に負の
引数を与えます。Rmailでは‘- M-s’でこれを行なうことができます。これは前の
メッセージの最後から検索を開始します。

   ラベルにもとづく検索も可能です。*note Rmail Labels::を参照してくださ
い。

   ‘C-c C-n’ (‘rmail-next-same-subject’)コマンドは、カレントメッセージと
同じsubjectをもつ、次のメッセージに移動します。プレフィクス引数は繰り返
し回数として使用されます。負の引数を指定すると、‘C-c C-p’
(‘rmail-previous-same-subject’)のように、後方に移動します。subjectを比較
するとき、subjectへの返信に通常付加されるようなプレフィクスは無視します
。これらのコマンドは、同じsubjectに関するすべてのメッセージ、いわゆる
threadを読むときに有用です。

   メッセージの絶対番号を指定してメッセージに移動するには、メッセージ番
号を引数として、‘j’ (‘rmail-show-message’)を使用します。引数を与えない場
合、‘j’は最初のメッセージに移動します。‘<’ (‘rmail-first-message’)も最初
のメッセージを選択します。‘>’ (‘rmail-last-message’)は最後のメッセージを
選択します。


File: emacs-ja.info,  Node: Rmail Deletion,  Next: Rmail Inbox,  Prev: Rmail Motion,  Up: Rmail

33.4 メッセージの削除
=====================

メッセージを残す必要がなくなったとき、それを“削除(delete)”できます。これ
はそのメッセージを無視するフラグをつけ、いくつかのRmailコマンドは、その
メッセージが存在しないかのように振る舞います。しかし、そのメッセージはま
だRmailファイルの中にあり、メッセージ番号ももっています。

   Rmailファイルにたいして“完全な削除(expunging)”を行なうことにより、削
除されたメッセージを実際に消去します。残ったメッセージには新たに連番が振
られます。

‘d’
     カレントメッセージを削除して、次の削除されていないメッセージに移動
     します(‘rmail-delete-forward’)。
‘C-d’
     カレントメッセージを削除して、前の削除されていないメッセージに移動
     します(‘rmail-delete-backward’)。
‘u’
     カレントメッセージの削除を取り消すか、前の削除されたメッセージに後
     方へ移動して、そのメッセージの削除を取り消します
     (‘rmail-undelete-previous-message’)。
‘x’
     Rmailファイルにたいして完全な削除を行ないます(‘rmail-expunge’)。

   Rmailには、メッセージを削除するためのコマンドが2つあります。両方とも
カレントメッセージを削除して、他のメッセージを選択します。‘d’
(‘rmail-delete-forward’)は、すでに削除されたメッセージをスキップして次の
メッセージに移動し、‘C-d’ (‘rmail-delete-backward’)は、前の削除されてい
ないメッセージに移動します。指定方向に、移動先となる削除されていないメッ
セージが存在しない場合は、単にそのメッセージを削除するだけで、カレントメ
ッセージはそのメッセージのままです。数引数は繰り返し回数を指定します。こ
れにより1つのコマンドで複数のメッセージを削除できます。負の引数は‘d’と
‘C-d’の意味を逆転します。

   Rmailがメッセージを削除するときは、フック
‘rmail-delete-message-hook’が実行されます。フック関数が呼び出されるとき
、そのメッセージは削除とマークされますが、そのメッセージがRmailバッファ
ーのカレントメッセージのままです。

   すべての削除されたメッセージを最終的にRmailファイルから消すには、‘x’
(‘rmail-expunge’)とタイプします。これを行なうまでは、削除されたメッセー
ジの“削除を取り消す(undelete)”ことができます。削除の取り消しコマンド‘u’
(‘rmail-undelete-previous-message’)は、ほとんどのケースにおいて‘d’コマン
ドの効果を取り消すようにデザインされています。カレントメッセージが削除さ
れている場合は、カレントメッセージの削除を取り消します。そうでない場合は
、削除されたメッセージが見つかるまで後方に移動して、そのメッセージの削除
を取り消します。数引数は繰り返し回数を指定します。これにより1つのコマン
ドで複数のメッセージを削除できます。

   通常、‘d’を‘u’で取り消すことができます。なぜなら‘u’は後方に移動して、
‘d’で削除されたメッセージの削除を取り消すからです。しかしこれは、削除す
るメッセージの前にすでに削除されたメッセージがある場合、‘d’はこれらのメ
ッセージをスキップするのでうまく機能しません。その後で‘u’コマンドを実行
すると、スキップされた最後のメッセージの削除を取り消すからです。この問題
を避ける明解な方法はありません。しかし‘u’コマンドを繰り返すことにより、
削除を取り消したいメッセージに戻ることができます。‘M-p’コマンドで特定の
削除されたメッセージを選択してから、‘u’をタイプして削除を取り消すことも
できます。

   削除されたメッセージは‘deleted’の属性をもち、結果として、カレントメッ
セージが削除されている場合はモードラインに‘deleted’が表示されます。実際
のところ、メッセージの削除と削除の取り消しは、この属性の追加または削除に
過ぎません。*note Rmail Attributes::を参照してください。


File: emacs-ja.info,  Node: Rmail Inbox,  Next: Rmail Files,  Prev: Rmail Deletion,  Up: Rmail

33.5 Rmailファイルとinbox
=========================

ローカルでメールを受信したとき、オペレーティングシステムは受信メールを、
私たちが“inbox”と呼ぶファイルに配します。Rmailを開始したとき、
‘movemail’と呼ばれるCプログラムを実行して、inboxから新しいメッセージを、
RmailセッションのRmailファイルにコピーします。このRmailファイルには、以
前のRmailセッションの他のメッセージも含まれています。Rmailで実際に読むメ
ールは、このファイルの中にあります。この操作は“新しいメールの取得
(getting new mail)”と呼ばれます。‘g’とタイプすることにより、いつでも新し
いメールを取得できます。

   変数‘rmail-primary-inbox-list’は、プライマリーRmailファイルにたいする
inboxファイルのリストを含みます。この変数を明示的にセットしない場合、
Rmailは環境変数‘MAIL’を使用するか、最後の手段として
‘rmail-spool-directory’にもとづく、デフォルトのinboxを使用します。デフォ
ルトのinboxはオペレーティングシステムに依存し、それは
‘/var/mail/USERNAME’、‘/var/spool/mail/USERNAME’、
‘/usr/spool/mail/USERNAME’などです。

   コマンド‘set-rmail-inbox-list’で、カレントセッションでの任意のRmailフ
ァイルにたいするinboxファイルを指定できます。*note Rmail Files::を参照し
てください。

   inboxとは別にRmailファイルをもつべき理由が2つあります。

  1. inboxファイルのフォーマットは、オペレーティングシステムと、それを使
     用する他のメールソフトによりさまざまです。Rmailの一部だけがそれらの
     候補を理解していればよく、それらすべてをRmail自身のフォーマットに変
     換する方法だけを理解すればよいからです。

  2. メールを紛失せずにinboxにアクセスするのは厄介です。なぜならそれはメ
     ール配信とインターロック(連動)する必要があるからです。さらにオペレ
     ーティングシステムごとに、異なるインターロック技術が使用されていま
     す。inboxから別のRmailファイルに1度メールを移動する方法により、
     Rmailの残りのすべてがインターロックの必要性を無視できます。なぜなら
     RmailはRmailファイルだけを操作すればよいからです。

   Rmailは、Rmailファイルの内部フォーマットとして、UnixおよびGNUシステム
に取り入れられた、標準的な‘mbox’フォーマットを使用します(実際のところ、
mboxフォーマットとは若干の違いがあります。その違いは重要ではありませんが
、変数‘rmail-mbox-format’をセットすることにより、あなたのシステムが使用
するフォーマットをRmailに指定できます。詳細は、変数のドキュメントを参照
してください)。

   新しいメールを受信したとき、Rmailは最初にその新しいメールをinboxファ
イルからRmailファイルにコピーします。それからRmailファイルを保存して、そ
の後でinboxファイルからそれをクリアーします。この方法では、システムのク
ラッシュにより、inboxとRmailファイルの間でメールの重複は発生するかもしれ
ませんが、メールを失うことはあり得ません。‘rmail-preserve-inbox’が非
‘nil’の場合、Rmailは新しいメールを受信したときにinboxファイルをクリアー
しません。旅行の際など、携帯用のコンピューターでPOPを通じてメールをチェ
ックするときは、この変数をセットすれば、メールはサーバーに残るので、後で
あなたがメインに使用するワークステーションのデスクトップに保存することが
できます。

   Rmailがinboxファイルから間接的に新しいメールをコピーするケースがあり
ます。最初に‘movemail’プログラムを実行してinboxから、Rmailファイルと同じ
ディレクトリーにある、‘.newmail-INBOXNAME’と呼ばれる中間ファイルにメール
を移動します。その後、Rmailは、そのファイルから新しいメールをマージして
、Rmailファイルを保存し、中間ファイルの削除はその後にだけ行なわれます。
悪いタイミングでクラッシュが発生した場合、中間ファイルは残っているので、
Rmailは次にinboxファイルから新しいメールを取得するとき、それを再使用しま
す。

   Rmailが‘.newmail-INBOXNAME’の中のデータをmbox形式に変換できない場合、
ファイルを‘RMAILOSE.N’(Nはファイル名を一意にするために選ばれます)にリネ
ームするので、Rmailはそのデータで再度問題を起こすことはなくなります。メ
ッセージの何がRmailを混乱させたか調べて、それを削除すべきです(大抵は8進
コード037のcontrol-underscoreがメッセージに含まれている場合です)。その後
、修正されたファイルから‘1 g’を使って新しいメールを取得できます。


File: emacs-ja.info,  Node: Rmail Files,  Next: Rmail Output,  Prev: Rmail Inbox,  Up: Rmail

33.6 複数のRmailファイル
========================

Rmailはデフォルトで、あなたの“プライマリーRmailファイル(primary Rmail
file)”を操作します。これは‘~/RMAIL’というファイルで、inboxファイルからメ
ールを受け取ります。しかし他のRmailファイルを所有して。Rmailでそれを編集
することができます。これらのファイルは、それら自身のinboxからメールを受
け取ったり、明示的なRmailコマンドでメッセージを移動することができます
(*note Rmail Output::を参照してください)。

‘i FILE <RET>’
     FILEをEmacsに読み込んで、それにたいしてRmailを実行します
     (‘rmail-input’)。
‘g’
     カレントRmailファイルのinboxから、新しいメールをマージします
     (‘rmail-get-new-mail’)。
‘C-u g FILE <RET>’
     inboxファイルFILEから新しいメールをマージします。

   プライマリーRmailファイル以外のファイルでRmailを実行するために、
Rmailで‘i’ (‘rmail-input’)コマンドを使用できます。これは、そのファイルを
Rmailモードでvisitします。Rmailの外からでも‘M-x rmail-input’を使用するこ
とができますが、同じことを行なう‘C-u M-x rmail’の方が簡単にタイプできま
す。

   通常‘i’で読み込むファイルは、有効なmboxファイルであるべきです。そうで
ない場合、Rmailはそのファイルのテキストをmbox形式に変換しようと試み、そ
のバッファーで変換されたテキストをvisitします。バッファーを保存すると、
そのファイルが変換されます。

   存在しないファイル名を指定した場合、‘i’は新しいRmailファイルを作成す
るために、新しいバッファーを初期化します。

   メニューからRmailファイルを選択することもできます。メニューClassifyの
、アイテムInput Rmail Fileを選択して、Rmailファイルを選択します。変数
‘rmail-secondary-file-directory’および‘rmail-secondary-file-regexp’は、
メニューがどのファイルを表示するかを指定します。最初の変数はファイルを探
すディレクトリーを指定し、2番目の変数はそのディレクトリーのどのファイル
(正規表現にマッチするファイルすべて)を表示するかを指定します。マッチする
ファイルがない場合、このメニューアイテムは選択できません。これらの変数は
、出力するファイルの選択にも適用されます(*note Rmail Output::を参照して
ください)。

   使用するinboxファイルは変数‘rmail-inbox-list’により指定され、これは
Rmailモードではバッファーローカルな変数です。特別な例外として、プライマ
リーRmailファイルにinboxを指定していない場合、これは環境変数‘MAIL’、また
はシステム標準のinboxを使用します。

   ‘g’ (‘rmail-get-new-mail’)コマンドは、inboxのメールを、カレント
Rmailファイルにマージします。Rmailファイルにinboxがない場合、‘g’は何もし
ません。コマンド‘M-x rmail’も、新しいメールをプライマリーRmailファイルに
マージします。

   通常のinboxではないファイルからメールをマージするには、‘C-u g’のよう
に‘g’キーに数引数を与えます。するとファイル名を読み取り、そのファイルか
らメールをマージします。引数を使用して‘g’を使用しても、inboxファイルの削
除・変更はされません。したがって、これはあるファイルのメッセージを、他の
ファイルにマージする一般的な方法です。


File: emacs-ja.info,  Node: Rmail Output,  Next: Rmail Labels,  Prev: Rmail Files,  Up: Rmail

33.7 外部ファイルへのメッセージのコピー
=======================================

以下はRmailファイルから他のファイルにメッセージをコピーするコマンドです
。

‘o FILE <RET>’
     カレントメッセージの完全なコピーを、ファイルFILEに追加します
     (‘rmail-output’)。

‘C-o FILE <RET>’
     カレントメッセージの表示にしたがい、ファイルFILEに追加します
     (‘rmail-output-as-seen’)。

‘w FILE <RET>’
     メッセージの本文だけをファイルFILEに出力します。デフォルトのファイ
     ル名は、そのメッセージの‘Subject’ヘッダーからとられます。

   コマンド‘o’および‘C-o’は、カレントメッセージのコピーを指定したファイ
ルの最後に追加します。2つのコマンドの主な違いは、どれだけコピーするかで
す。‘C-o’が現在表示されているヘッダーだけをコピーするのにたいし、‘o’はヘ
ッダーがすべて表示されていなくても、メッセージヘッダーを完全にコピーしま
す。*note Rmail Display::を参照してください。加えて、ファイルがBabylフォ
ーマットのとき、‘o’はメッセージをBabylフォーマットに変換しますが、
‘C-o’はBabylファイルを出力できません。

   Emacsバッファーで出力ファイルをvisitしていた場合、出力コマンドはメッ
セージをそのバッファーに追加します。最終的にそのバッファーをファイルに保
存するかは、あなた次第です。

   本文にファイル内容がそのまま記載されているようなメッセージを受信する
ことがあるかもしれません。そのような場合、‘w’
(‘rmail-output-body-to-file’)コマンドで、本文を(メッセージヘッダーを除い
て)ファイルに保存できます。そのようなメッセージは‘Subject’フィールドにフ
ァイル名を意図した内容を含んでいる場合があるので、‘w’コマンドは(ファイル
名に可搬的に使用できないいくつかの文字を置換した後)デフォルトの出力ファ
イル名に‘Subject’フィールドを使用します。しかし、ファイル名はミニバッフ
ァーを使って読み取られるので、異なる名前を指定できます。

   メニューからRmailファイルを選択して、メッセージを出力することもできま
す。メニューClassifyの、メニューアイテムOutput Rmail Fileを選択して、出
力したいRmailファイルを選択します。これは‘o’コマンドのように、カレントメ
ッセージをそのファイルに出力します。変数
‘rmail-secondary-file-directory’および‘rmail-secondary-file-regexp’は、
メニューがどのファイルを表示するかを指定します。最初の変数はファイルを探
すディレクトリーを指定し、2番目の変数はそのディレクトリーのどのファイル
(正規表現にマッチするファイルすべて)を表示するかを指定します。マッチする
ファイルがない場合、このメニューアイテムは選択できません。

   ‘o’または‘C-o’でメッセージをコピーすることにより、メッセージのオリジ
ナルコピーには属性‘filed’が与えられるので、そのメッセージがカレントのと
きは、モードラインに‘filed’が表示されます。

   各メールメッセージにたいして1つのコピーを保持したい場合は、変数
‘rmail-delete-after-output’に‘t’をセットします。その場合、コマンド‘o’、
‘C-o’および‘w’は、コピー後にオリジナルのメッセージを削除します(望むなら
後で削除を取り消すことができる。*note Rmail Deletion::を参照されたい)。

   変数‘rmail-output-file-alist’は、カレントメッセージの内容にもとづいて
、理にかなったデフォルトの出力ファイルを指定できます。値は以下の形式をも
つ要素のリストです:

     (REGEXP . NAME-EXP)

カレントメッセージにREGEXPにたいするマッチが存在する場合、デフォルトの出
力ファイルはNAME-EXPになります。複数の要素がそのメッセージにマッチする場
合、最初にマッチした要素がデフォルトのファイル名を決定します。式
NAME-EXPは使用するファイル名を与える文字列定数、またはより一般的に、ファ
イル名を文字列として取得する任意のLisp式を指定できます。
‘rmail-output-file-alist’は、‘o’と‘C-o’の両方に適用されます。

   Rmailは、(‘rmail-file-name’で指定される)プライマリーRmailファイルから
、(変数‘rmail-automatic-folder-directives’の値にもとづいて)他のファイル
にメッセージを自動的に保存できます。この変数は、どのメッセージをどこに保
存するかを指定する要素(‘directives’)のリストです。各directiveは出力ファ
イルからなるリストで、ヘッダー名と正規表現の組が1つ以上後に続きます。メ
ッセージのヘッダーが指定された正規表現にマッチする場合、そのメッセージは
与えられたファイルに保存されます。directiveが複数のヘッダーエントリーを
もつ場合、それらすべてがマッチしなければなりません。Rmailはファイル
‘rmail-file-name’からメッセージを表示するときdirectiveをチェックして、
(もしあれば)最初のマッチに適用します。出力ファイルが‘nil’の場合、そのメ
ッセージは削除され、保存されません。たとえば特定のアドレスや、特定の
subjectのメッセージを保存するのに、この機能を使用することができます。


File: emacs-ja.info,  Node: Rmail Labels,  Next: Rmail Attributes,  Prev: Rmail Output,  Up: Rmail

33.8 ラベル
===========

各メッセージは、分類(classification)のために割り当てられる、さまざまな
“ラベル(labels)”をもつことができます。各ラベルは名前をもち、名前が異なる
と違うラベルになります。任意のラベルは、特定のメッセージにたいして、付い
ているか付いていないかのどちらかです。標準的な意味をもつラベル名がいくつ
かあり、それが適切なときは、Rmailにより自動的にメッセージに付与されます
。これらの特別なラベルは、“属性(attribute)”と呼ばれます (*note Rmail
Attributes::を参照してください)。 それ以外のすべてのラベルは、ユーザーに
より付与されます。

‘a LABEL <RET>’
     カレントメッセージに、ラベルLABELを割り当てます
     (‘rmail-add-label’)。
‘k LABEL <RET>’
     カレントメッセージから、ラベルLABELを外します(‘rmail-kill-label’)。
‘C-M-n LABELS <RET>’
     複数のラベルLABELSのどれか1つをもつ、次のメッセージに移動します
     (‘rmail-next-labeled-message’)。
‘C-M-p LABELS <RET>’
     複数のラベルLABELSのどれか1つをもつ、前のメッセージに移動します
     (‘rmail-previous-labeled-message’)。
‘l LABELS <RET>’
‘C-M-l LABELS <RET>’
     複数のラベルLABELSのどれかを含む、すべてのメッセージのサマリーを作
     成します(‘rmail-summary-by-labels’)。

   コマンド‘a’ (‘rmail-add-label’)および‘k’ (‘rmail-kill-label’)で、カレ
ントメッセージにたいして任意のラベルを割り当てたり、外すことができます。
引数LABELが空の場合、もっとも最近割り当てられた(または外された)ラベルを
割り当てる(または外す)ことを意味します。

   メッセージを分類するためにラベルを割り当てた後、ラベルを使用する3つの
方法 — 移動、サマリー、ソート — があります。

   ‘C-M-n LABELS <RET>’ (‘rmail-next-labeled-message’)は、複数のラベル
LABELSのうちどれか1つをもつ、次のメッセージに移動します。引数LABELSには
、カンマで区切られた1つ以上のラベル名を指定します。‘C-M-p’
(‘rmail-previous-labeled-message’)も同様ですが、前のメッセージに後方へ移
動します。どちらのコマンドも、数引数は繰り返し回数を指定します。

   コマンド‘C-M-l LABELS <RET>’ (‘rmail-summary-by-labels’)は、指定され
た複数のラベルのうち、少なくとも1つをもつメッセージだけを含むサマリーを
表示します。引数LABELSはカンマで区切られた1つ以上のラベル名です。サマリ
ーについての詳細は、*note Rmail Summary::を参照してください。

   ‘C-M-n’、‘C-M-p’、‘C-M-l’にたいして引数LABELSが空の場合は、それらのコ
マンドにたいして、もっとも最近に指定されたLABELSを使うことを意味します。

   ラベルでメッセージをソートする情報については、*note Rmail Sorting::を
参照してください。


File: emacs-ja.info,  Node: Rmail Attributes,  Next: Rmail Reply,  Prev: Rmail Labels,  Up: Rmail

33.9 Rmailの属性
================

‘deleted’や‘filed’のようないくつかのラベルはビルトインの意味をもち、
Rmailは適切なときに、それらをメッセージに割り当てます。これらのラベルは
“属性(attributes)”と呼ばれます。以下はRmailの属性のリストです:

‘unseen’
     そのメッセージが1度もカレントになっていないことを意味します。
     inboxからメッセージが到着したとき割り当てられ、そのメッセージがカレ
     ントになったときに外されます。Rmailを開始したとき、この属性をもつメ
     ッセージを最初に表示します。
‘deleted’
     メッセージが削除されたことを意味します。削除コマンドにより割り当て
     られ、削除を取り消すコマンドで外されます(*note Rmail Deletion::を参
     照してください)。
‘filed’
     そのメッセージが他のファイルにコピーされたことを意味します。ファイ
     ル出力コマンド‘o’および‘C-o’により割り当てられます(*note Rmail
     Output::を参照してください)。
‘answered’
     メッセージへの返信をメールしたことを意味します。‘r’
     (‘rmail-reply’)コマンドにより割り当てられます。*note Rmail Reply::を
     参照してください。
‘forwarded’
     メッセージを転送したことを意味します。‘f’ (‘rmail-forward’)コマンド
     により割り当てられます。*note Rmail Reply::を参照してください。
‘edited’
     メッセージのテキストをRmailで編集したことを意味します。*note Rmail
     Editing::を参照してください。
‘resent’
     メッセージを再送したことを意味します。コマンド‘M-x rmail-resend’に
     より割り当てられます。*note Rmail Reply::を参照してください。
‘retried’
     送信に失敗したメッセージを再試行したことを意味します。コマンド‘M-x
     rmail-retry-failure’により割り当てられます。*note Rmail Reply::を参
     照してください。

   これ以外のすべてのラベルは、ユーザーだけが割り当てたり外すことができ
、それらのラベルは標準的な意味をもちません。


File: emacs-ja.info,  Node: Rmail Reply,  Next: Rmail Summary,  Prev: Rmail Attributes,  Up: Rmail

33.10 返信の送信
================

Rmailには、送信メールを送るための複数のコマンドがあります。Messageモード
の使い方(Rmailでも動作する特別な機能を含む)に関する情報は、*note Sending
Mail::を参照してください。このセクションでは、送信メッセージ作成に使用す
る、mailバッファーに入るエンターするためのRmailの特別なコマンドを説明し
ます。メールを送信するための通常のキー — ‘C-x m’、‘C-x 4 m’、‘C-x 5 m’ —
は、Rmailモードでも通常どおり機能することに注意してください。

‘m’
     メッセージを送信します(‘rmail-mail’)。
‘c’
     すでに編集を開始した送信メッセージの編集を続けます
     (‘rmail-continue’)。
‘r’
     カレントRmailメッセージにたいする返信を送信します(‘rmail-reply’)。
‘f’
     カレントメッセージを他のユーザーに転送します(‘rmail-forward’)。
‘C-u f’
     カレントメッセージを他のユーザーに再送します(‘rmail-resend’)。
‘M-m’
     送信に失敗して戻ってきたメッセージにたいして、2回目の送信を試みます
     (‘rmail-retry-failure’)。

   Rmailにいるときにメッセージを送信する理由でもっとも一般的なのは、読ん
でいるメールに返信するときでしょう。これを行なうには、‘r’
(‘rmail-reply’)とタイプします。これは‘C-x 4 m’のように、別ウィンドウにメ
ール作成バッファーを表示しますが、ヘッダーフィールド‘Subject’、‘To’、
‘CC’、‘In-reply-to’、‘References’は、返信するメッセージにもとづいて、事
前に初期化されています。‘To’フィールドには、返信するメッセージを送信した
人のアドレスがセットされ、‘CC’にはそのメッセージを受け取った、他のすべて
の人のアドレスがセットされます。

   変数‘mail-dont-reply-to-names’を使用して、自動的に返信に含まれる受信
者から、特定の受信者を除外することができます。この変数の値には正規表現を
指定します。正規表現にマッチする受信者は、‘CC’フィールドから除外されます
。その受信者を除外することにより‘To’フィールドが空になる場合を除き、
‘To’フィールドからも除外されます。この変数が‘nil’の場合、最初に返信を作
成するときに、あなた自身のアドレスにマッチするデフォルト値に初期化されま
す。

   元メッセージの送信者だけにリプライするには、‘C-u r’または‘1 r’のよう
に、数引数とともに返信コマンドをエンターします。特定の返信にたいして
‘CC’フィールドを完全に省略するには、返信コマンドに数引数を指定します。こ
れは、元のメッセージを送信した人だけに返信することを意味します。

   1度メール作成バッファーが初期化されると、後は通常どおりメールの編集と
送信を行なうことができます(*note Sending Mail::を参照してください)。事前
にセットされたヘッダーフィールドが適切でない場合は、それを編集することが
できます。‘C-c C-y’のようなコマンドを使うこともできます。これは返信する
メッセージをyankします(*note Mail Commands::を参照してください)。Rmailバ
ッファーに切り替えて、異なるメッセージを選択してから、また戻って新しいカ
レントメッセージにyankすることもできます。

   メッセージが送信先に届かないこともあります。そのような場合メーラーは
通常、“失敗メッセージ(failure message)”をあなたに返信します。Rmailコマン
ドの‘M-m’ (‘rmail-retry-failure’)は、同じメッセージの2回目の送信を準備を
します。これは前と同じテキストとヘッダーフィールドで、メール作成バッファ
ーをセットアップします。そこですぐに‘C-c C-c’をタイプすると、初回とまっ
たく同じメッセージを再送します。テキストやヘッダーを編集してから送信する
こともできます。変数‘rmail-retry-ignored-headers’は、失敗したメッセージ
を再試行するとき除外するヘッダーを制御し、フォーマットは
‘rmail-ignored-headers’ (*note Rmail Display::を参照してください)と同じ
です。

   Rmailからメールを送信する他のよくある理由に、カレントメッセージを他の
ユーザーに“転送(forward)”することです。‘f’ (‘rmail-forward’)は、メール作
成バッファーのテキストとsubjectを、カレントメッセージで事前に初期化する
ことにより、これを簡単に行なえるようにします。subjectは‘[FROM:
SUBJECT]’という形式で初期化されます。FROMとSUBJECTには、元のメッセージの
送信者とsubjectが入ります。あなたが行なう必要があるのは、送信先を記述し
て、それを送信することだけです。メッセージを転送するとき、受信者が受け取
るメッセージのfromはあなたになり、メールの内容は元のメッセージと同じにな
ります。

   Rmailは転送メッセージにたいして2つのフォーマットを提供します。デフォ
ルトはMIMEフォーマットを使用します(*note Rmail Display::を参照してくださ
い)。これは元のメッセージを別の部分に含めます。変数
‘rmail-enable-mime-composing’を‘nil’にセットすることにより、もっと簡単な
フォーマットを使うこともできます。この場合、Rmailは元のメッセージを2つの
区切り行で囲むだけです。これは各行の行頭に‘- ’を挿入することにより、各行
の変更も行ないます。このフォーマットによる転送メッセージを受信した場合、
それに普通のテキスト以外の何か — たとえばプログラムのソースコード — が含
まれている場合、この変更を取り消せたら便利だと思うかもしれません。これを
行なうには、転送されたメッセージを選択して、‘M-x
unforward-rmail-message’とタイプします。このコマンドは、挿入された文字列
‘- ’を削除して、転送されたメッセージのオリジナルを抽出し、カレントメッセ
ージの直後に、別のメッセージとしてRmailファイルに挿入します。

   “再送(Resending)”は、転送と似た別の方法です。違いは、再送により送信さ
れるメッセージは、あなたが受け取ったときのように、元の送信者がfromになり
、追加のヘッダーフィールド(‘Resent-From’と‘Resent-To’)により、それがあな
たを通じて送られたことを示すことです。Rmailでメッセージを再送するには、
‘C-u f’を使用します(‘f’は‘rmail-forward’を実行し、数引数を指定すると
‘rmail-resend’を呼び出します)。

   ‘m’ (‘rmail-mail’)を使用することにより、返信ではない送信用のメールの
編集を開始します。これはヘッダーフィールドを空のままにします。‘C-x 4 m’と
の違いは、‘r’のように‘C-c C-y’でRmailにアクセスできることです。

   ‘c’ (‘rmail-continue’)コマンドは、既に編集を開始した送信用メッセージ
の編集を終えるために、または送信したメッセージを変更するために、メール作
成バッファーでの編集を再開します。

   変数‘rmail-mail-new-frame’を非‘nil’にセットした場合、メッセージの送信
を開始するすべてのコマンドは、それを編集するために新しいフレームを作成し
ます。このフレームは、そのメッセージを送信すると削除されます。

   メッセージを送信するすべてのRmailコマンドは、選択されたメール作成方法
を使用します(*note Mail Methods::を参照してください)。


File: emacs-ja.info,  Node: Rmail Summary,  Next: Rmail Sorting,  Prev: Rmail Reply,  Up: Rmail

33.11 サマリー
==============

“サマリー(summary)”は、Rmailファイルのメールを概観するために、メッセージ
ごとに1つの行を含むバッファーです。各行にはメッセージ番号、日付、送信者
、行数、ラベル、subjectが表示されます。サマリーバッファーでポイントを移
動することにより、そのサマリー行のメッセージを選択することができます。ほ
とんどのRmailコマンドはサマリーバッファーでも有効です。それらのコマンド
を使うと、サマリーのカレント行に記述されているメッセージに適用されます。

   サマリーバッファーは、1つのRmailファイルだけに適用されます。複数の
Rmailファイルを編集している場合、それぞれが自身のサマリーバッファーをも
つことができます。サマリーバッファーの名前は、Rmailバッファーの名前に
‘-summary’を追加して作成されます。通常は1度に1つだけのサマリーバッファー
が表示されます。

* Menu:

* Rmail Make Summary::       さまざまな種類のサマリーの作成。
* Rmail Summary Edit::       サマリーからのメッセージの操作。


File: emacs-ja.info,  Node: Rmail Make Summary,  Next: Rmail Summary Edit,  Up: Rmail Summary

33.11.1 サマリーの作成
----------------------

以下は、カレントRmailバッファーでサマリーを作成するコマンドです。Rmailバ
ッファーが1度サマリーされると、Rmailバッファーでの変更(メッセージの削除
や完全な削除、新しいメールの受信など)により、サマリーも自動的に更新され
ます。

‘h’
‘C-M-h’
     すべてのメッセージをサマリーします(‘rmail-summary’)。
‘l LABELS <RET>’
‘C-M-l LABELS <RET>’
     1つ以上の指定したラベルをもつメッセージをサマリーします
     (‘rmail-summary-by-labels’)。
‘C-M-r RCPTS <RET>’
     指定した受信者にマッチするメッセージをサマリーします
     (‘rmail-summary-by-recipients’)。
‘C-M-t TOPIC <RET>’
     指定した正規表現TOPICにマッチするsubjectをもつメッセージをサマリー
     します(‘rmail-summary-by-topic’)。
‘C-M-s REGEXP <RET>’
     指定した正規表現REGEXPにマッチするヘッダーをもつメッセージをサマリ
     ーします(‘rmail-summary-by-regexp’)。
‘C-M-f SENDERS <RET>’
     指定した送信者にマッチするメッセージをサマリーします
     (‘rmail-summary-by-senders’)。

   コマンド‘h’または‘C-M-h’ (‘rmail-summary’)は、カレントRmailバッファー
にたいする、すべてのメッセージのサマリーを、サマリーバッファーに表示しま
す。その後、別のウィンドウにサマリーバッファーを表示して、それを選択しま
す。

   ‘C-M-l LABELS <RET>’ (‘rmail-summary-by-labels’)は、1つ以上のラベル
LABELSをもつメッセージの、部分的なサマリーを作成します。LABELSには、カン
マで区切られたラベル名を指定します。

   ‘C-M-r RCPTS <RET>’ (‘rmail-summary-by-recipients’)は、正規表現
RCPTSにマッチする、1つ以上の受信者をもつメッセージのサマリーを作成します
。これはヘッダー‘To’、‘From’、‘CC’にたいしてマッチを行ないます(プレフィ
クス引数を与えた場合は‘CC’ヘッダーを除外する)。

   ‘C-M-t TOPIC <RET>’ (‘rmail-summary-by-topic’)は、正規表現TOPICにマッ
チするsubjectをもつメッセージの、部分的なサマリーを作成します。プレフィ
クス引数を指定した場合、subjectだけでなく、メッセージ全体にたいしてマッ
チを行ないます。

   ‘C-M-s REGEXP <RET>’ (‘rmail-summary-by-regexp’)は、正規表現REGEXPに
マッチするヘッダー(日付とsubject行を含む)をもつメッセージの、部分的なサ
マリーを作成します。

   ‘C-M-f SENDERS <RET>’ (‘rmail-summary-by-senders’)は、正規表現
SENDERSにマッチする‘From’フィールドをもつメッセージの、部分的なサマリー
を作成します。

   1つのRmailバッファーにたいして、1つのサマリーしか存在しないことに注意
してください。他の種類のサマリーを作成すると、以前のサマリーは破棄されま
す。

   変数‘rmail-summary-window-size’は、サマリーウィンドウに何行使用するか
を指定します。変数‘rmail-summary-line-count-flag’は、メッセージのサマリ
ー行に、メッセージの総行数を含めるかを制御します。このオプションに
‘nil’をセットすると、サマリーの生成が速くなるかもしれません。


File: emacs-ja.info,  Node: Rmail Summary Edit,  Prev: Rmail Make Summary,  Up: Rmail Summary

33.11.2 サマリーでの編集
------------------------

Rmailバッファーで行なえることのほとんどは、Rmailサマリーバッファーでも使
用できます。実際、1度サマリーバッファーを作成すれば、Rmailバッファーに戻
る必要はありません。

   サマリーバッファーで異なる行にポイントを移動するだけで、サマリーバッ
ファーからメッセージを選択して、Rmailバッファーに表示することができます
。ポイントを移動するEmacsコマンドが何であるかは問題になりません。コマン
ドの最後でポイントのある行のメッセージが、Rmailバッファーに表示されます
。

   ほとんどのRmailコマンドは、Rmailバッファーと同様に機能します。したが
って、サマリーバッファーでは、‘d’がカレントメッセージの削除、‘u’は削除の
取り消し、‘x’で完全に削除します(しかし、サマリーバッファーでは関連する方
向に削除されていないメッセージが存在しない場合、削除コマンドはカレントメ
ッセージに留まるのではなく、最初または最後のメッセージに移動します)。
‘o’と‘C-o’は、カレントメッセージをファイルに出力します。他にも、‘r’はそ
れにたいする返信を開始する、などです。サマリーバッファーで<SPC>と<DEL>を
使用することにより、カレントメッセージをスクロールできます。しかし、サマ
リーバッファーで<SPC>または<DEL>により、メッセージの終端または先頭を超え
てスクロールすると、削除されていない次または前のメッセージに移動します。
‘rmail-summary-scroll-between-messages’オプションを‘nil’にカスタマイズす
れば、次または前のメッセージへのスクロールが無効になります。

   ‘M-u’ (‘rmail-summary-undelete-many’)は、サマリーで削除されたすべての
メッセージの削除を取り消します。プレフィクス引数を指定した場合、以前に削
除された、指定した数のメッセージの削除を取り消すことを意味します。

   メッセージ間を移動するRmailコマンドはサマリーバッファーでも機能します
が、動作が少し異なります。これらのコマンドはサマリーに含まれる一連のメッ
セージ間を移動します。これらのコマンドは、常にRmailバッファーがスクリー
ンに表示されるようにします(カーソル移動コマンドはRmailバッファーの内容を
更新しますが、これらのコマンドはウィンドウにすでにそれが表示されているの
でなければ、表示しません)。以下はそれらのコマンドのリストです:

‘n’
     “deleted”の行をスキップして次の行に移動し、その行のメッセージを選択
     します(‘rmail-summary-next-msg’)。
‘p’
     “deleted”の行をスキップして前の行に移動し、その行のメッセージを選択
     します(‘rmail-summary-previous-msg’)。
‘M-n’
     次の行に移動して、その行のメッセージを選択します
     (‘rmail-summary-next-all’)。
‘M-p’
     前の行に移動して、その行のメッセージを選択します
     (‘rmail-summary-previous-all’)。
‘>’
     最後の行に移動して、その行のメッセージを選択します
     (‘rmail-summary-last-message’)。
‘<’
     最初の行に移動して、その行のメッセージを選択します
     (‘rmail-summary-first-message’)。
‘j’
‘<RET>’
     (Rmailバッファーがスクリーンに確実に表示されるようにして)カレント行
     のメッセージを選択します(‘rmail-summary-goto-msg’)。引数Nを指定した
     場合、メッセージ番号Nのメッセージを選択し、サマリーバッファーのその
     メッセージの行に移動します。そのメッセージがサマリーバッファーにリ
     ストされていない場合は、エラーをシグナルします。
‘M-s PATTERN <RET>’
     メッセージからPATTERNを検索します。検索はカレントメッセージから開始
     されます。マッチが見つかったらそのメッセージを選択して、サマリーバ
     ッファーのそのメッセージの行にポイントを移動します
     (‘rmail-summary-search’)。プレフィクス引数は繰り返し回数として機能
     します。負の引数は後方に検索を行なうことを意味します
     (‘rmail-summary-search-backward’と等価です)。
‘C-M-n LABELS <RET>’
     指定した1つ以上のラベルのうち、少なくとも1つをもつ次のメッセージに
     移動します(‘rmail-summary-next-labeled-message’)。LABELSはカンマで
     区切られたラベルのリストです。プレフィクス引数は繰り返し回数として
     機能します。
‘C-M-p LABELS <RET>’
     指定した1つ以上のラベルのうち、少なくとも1つをもつ前のメッセージに
     移動します(‘rmail-summary-previous-labeled-message’)。
‘C-c C-n <RET>’
     カレントメッセージと同じsubjectをもつ、次のメッセージに移動します
     (‘rmail-summary-next-same-subject’)。プレフィクス引数は繰り返し回数
     として機能します。
‘C-c C-p <RET>’
     カレントメッセージと同じsubjectをもつ、前のメッセージに移動します
     (‘rmail-summary-previous-same-subject’)。

   削除、削除の取り消し、新しいメールの取得はもちろん、異なるメッセージ
の選択でも、それらの操作をRmailバッファーで行なったとき、サマリーバッフ
ァーは更新されます。変数‘rmail-redisplay-summary’が非‘nil’の場合、これら
の操作はサマリーバッファーをスクリーンに表示します。

   サマリーの使用を終了するときは、‘Q’ (‘rmail-summary-wipe’)とタイプし
て、サマリーバッファーのウィンドウを削除します。サマリーからRmailを終了
することもできます。‘q’ (‘rmail-summary-quit’)はサマリーウィンドウを削除
して、Rmailファイルを保存してからRmailを終了してから、他のバッファーに切
り替えます。かわりに‘b’ (‘rmail-summary-bury’)とタイプすると、単に
RmailとRmailサマリーバッファーを隠し(bury)ます。


File: emacs-ja.info,  Node: Rmail Sorting,  Next: Rmail Display,  Prev: Rmail Summary,  Up: Rmail

33.12 Rmailファイルのソート
===========================

‘C-c C-s C-d’
‘M-x rmail-sort-by-date’
     カレントRmailバッファーのメッセージを、日付順にソートします。

‘C-c C-s C-s’
‘M-x rmail-sort-by-subject’
     カレントRmailバッファーのメッセージを、subject順にソートします。

‘C-c C-s C-a’
‘M-x rmail-sort-by-author’
     カレントRmailバッファーのメッセージを、送信者順にソートします。

‘C-c C-s C-r’
‘M-x rmail-sort-by-recipient’
     カレントRmailバッファーのメッセージを、受信者の名前順にソートします
     。

‘C-c C-s C-c’
‘M-x rmail-sort-by-correspondent’
     カレントRmailバッファーのメッセージを、他の受信者名順にソートします
     。

‘C-c C-s C-l’
‘M-x rmail-sort-by-lines’
     カレントRmailバッファーのメッセージを、行数順にソートします。

‘C-c C-s C-k <RET> LABELS <RET>’
‘M-x rmail-sort-by-labels <RET> LABELS <RET>’
     カレントRmailバッファーのメッセージを、ラベル順にソートします。引数
     LABELSは、カンマで区切られたラベルのリストです。ラベルの順序は、メ
     ッセージの順序を指定します。最初のラベルをもつメッセージが最初に、
     2番目のラベルをもつメッセージが次に、というようになります。ラベルを
     もたないメッセージは最後になります。

   Rmailのソートコマンドは_安定ソート(stable sort)_を行ないます。2つのメ
ッセージのどちらを先にするか特に理由がない場合、メッセージの順序は変更さ
れません。これを使用して複数のソート条件を使用できます。たとえば、
‘rmail-sort-by-date’の後に‘rmail-sort-by-author’を使用すれば、メッセージ
は作者ごとに日付順にソートされます。

   プレフィクス引数を指定した場合、これらのコマンドは逆順で比較をします
。これはメッセージが新しいものから古いものへ、大きいものから小さいものへ
、アルファベットの逆順でソートされることを意味します。

   同じキーをサマリーバッファーで使うと、似た関数が実行されます。たとえ
ば‘C-c C-s C-l’は、‘rmail-summary-sort-by-lines’を実行します。これらのコ
マンドは、たとえサマリーがメッセージの一部しか表示していなくても、
Rmailバッファー全体をソートします。

   ソートのアンドゥはできないことに注意してください。そのため、ソートを
する前にRmailバッファーを保存したいと思うかもしれません。


File: emacs-ja.info,  Node: Rmail Display,  Next: Rmail Coding,  Prev: Rmail Sorting,  Up: Rmail

33.13 メッセージの表示
======================

このセクションではRmailが、メールヘッダー、MIMEのセクションと添付、URL、
暗号化されたメッセージを表示する方法を説明します。

‘t’
     ヘッダーの完全表示を切り替えます(‘rmail-toggle-header’)。

   各メッセージを最初に表示する前に、Rmailは余分な物を減らすために、重要
でないヘッダーを隠して、メッセージのヘッダーを再フォーマットします。‘t’
(‘rmail-toggle-header’)コマンドは、これを切り替えます。つまり再フォーマ
ットされたヘッダーフィールドと、完全な元のヘッダーの間で、表示を切り替え
ます。正の引数を指定した場合、このコマンドは再フォーマットされたヘッダー
を表示します。0または負の引数を指定した場合、完全なヘッダーを表示します
。メッセージを再選択することにより、必要な場合は再フォーマットします。

   変数‘rmail-ignored-headers’は、隠すべきヘッダーフィールドを指定する正
規表現を保持します。これにマッチするヘッダー行は隠されます。変数
‘rmail-nonignored-headers’は、これをオーバーライドします。この変数の正規
表現にマッチするヘッダーフィールドは、たとえそれが
‘rmail-ignored-headers’にマッチしても、表示されます。変数
‘rmail-displayed-headers’は、これら2つの変数のかわりに使用されます。非
‘nil’の場合、その値には表示するヘッダーを指定する正規表現を指定します(デ
フォルトは‘nil’です)。

   Rmailは特に重要なヘッダーフィールド — デフォルトでは‘From’と
‘Subject’フィールドをハイライトします。ハイライトには‘rmail-highlight’フ
ェイスが使用されます。変数‘rmail-highlighted-headers’は、ハイライトする
ヘッダーフィールドを指定する正規表現を保持します。これがヘッダーフィール
ドの先頭にマッチした場合、フィールド全体がハイライトされます。この機能を
無効にするには、‘rmail-highlighted-headers’に‘nil’をセットしてください。

   メッセージがMIME(Multipurpose Internet Mail Extensions)形式で、複数パ
ート(MIMEエンティティー)が含まれている場合、Rmailは各パートに“タグライン
(tagline)”を表示します。タグラインはそのパートのインデックス、サイズ、コ
ンテントタイプを要約します。コンテントタイプに依存して、1つ以上のボタン
が含まれる場合があります。これらのボタンは、そのパートをファイルに保存す
る、などの処理を行ないます。

‘<RET>’
     ポイント位置のMIMEパートを隠す、または表示します
     (‘rmail-mime-toggle-hidden’)。

‘<TAB>’
     次のMIMEタグラインのボタンにポイントを移動します
     (‘rmail-mime-next-item’)。

‘S-<TAB>’
     前のMIMEパートにポイントを移動します(‘rmail-mime-previous-item’)。

‘v’
     MIME表示とrawメッセージの表示を切り替えます(‘rmail-mime’)。

   プレーンテキストのMIMEパートは、最初タグラインの直後に表示され、
Rmailバッファーの他のタイプのMIMEパートは、Rmailバッファーの一部としてタ
グラインだけが表示され(メッセージがHTMLパートをもたない場合。以下参照)、
実際のコンテンツは隠されています。どちらの場合も、MIMEパートのどこか、ま
たはそれのタグラインで<RET>をタイプすることにより、表示と非表示を切り替
えることができます(他の処理を行なうボタンがある場合を除きます)。<RET>と
タイプするかマウスでクリックすることにより、タグラインボタンをアクティブ
にでき、<TAB>でタグラインのボタンにたいして循環的にポイントを移動できま
す。

   ‘v’ (‘rmail-mime’)コマンドは、上記で説明したデフォルトのMIME表示と、
MIMEでデコードされていないrawデータの表示を切り替えます。プレフィクス引
数を指定した場合は、ポイント位置にあるものの表示だけを切り替えます。

   メッセージにHTMLのMIMEパートがあり、EmacsがHTMLを表示できる場合、
Rmailはそれをplain-textパートより優先して表示します(1)。これを抑制してか
わりにplain-textパートを表示するには、変数‘rmail-mime-prefer-html’を
‘nil’にカスタマイズしてください。

   RmailからMIMEでデコードされたメッセージの処理を抑止するには、変数
‘rmail-enable-mime’を‘nil’に変更します。この場合、‘v’ (‘rmail-mime’)は、
カレントMIMEメッセージを表示するために、一時的なバッファーを作成します。

   カレントメッセージが暗号化されている場合、復号化するために‘M-x
rmail-epa-decrypt’を使用します。これはEasyPGライブラリーを使用します
(*note EasyPG: (epa)Top.を参照してください)。

   RmailバッファーでGoto Addressモードを使用して、URLのハイライトとアク
ティブ化ができます:

     (add-hook 'rmail-show-message-hook 'goto-address-mode)

このモードを使用すると、そのURLを‘mouse-2’でクリック(または‘mouse-1’で素
早くクリック)するか、ポイントをそこに移動して‘C-c <RET>’とタイプすること
により、それらのURLをブラウズできます。*note Activating URLs: Goto
Address mode.を参照してください。

   ---------- Footnotes ----------

   (1) この機能は、Emacsが‘libxml2’サポートつきでビルドされているか、
Lynxブラウザーがインストールされている必要があります。


File: emacs-ja.info,  Node: Rmail Coding,  Next: Rmail Editing,  Prev: Rmail Display,  Up: Rmail

33.14 Rmailとコーディングシステム
=================================

Rmailは、Emacsがファイルをvisitしたりサブプロセスの出力にたいして行なう
ように、非ASCII文字を含むメッセージを自動的にデコードします。Rmailはメッ
セージで標準の‘charset=CHARSET’ヘッダーを使用し、もしそれがあれば、送信
者によりメッセージがどのようにエンコードされたか決定します。これは
CHARSETを、対応するEmacsコーディングシステム(*note Coding Systems::を参
照してください)にマップして、メッセージテキストをデコードするために、そ
のコーディングシステムを使います。メッセージヘッダーに‘charset’指定がな
い場合、またはCHARSETが認識されなかった場合、Rmailは通常のEmacsの経験則
とデフォルトに則ったコーディングシステムを選択します(*note Recognize
Coding::を参照してください)。

   メッセージが間違ってデコードされることもあります。これは‘charset’指定
がないためにEmacsが間違ったコーディングシステムを推測したか、そもそも指
定が間違っているかです。たとえば間違って設定されたメーラーが、メッセージ
が実際には‘koi8-r’でエンコードされているのに、‘charset=iso-8859-1’という
ヘッダーでメッセージを送るかもしれません。メッセージテキストが文字化けし
ていたり、文字が16進コードや空ボックスで表示されているときは、おそらくこ
れが発生しています。

   正しいコーディングシステムを解決または推測できる場合、正しいコーディ
ングシステムを使ってメッセージを再デコードすることにより、問題を訂正する
ことができます。これを行なうには‘M-x rmail-redecode-body’コマンドを呼び
出します。これはコーディングシステムの名前を読み取り、指定したコーディン
グシステムを使って、メッセージを再デコードします。正しいコーディングシス
テムを指定した場合、デコード結果は読めるようになるでしょう。

   Rmailで新しいメールを受信したとき、各メッセージは、それらがあたかも個
別のファイルであるかのように、それぞれが記述されたコーディングシステムに
自動的に変換されます。これは指定されたコーディングシステムの優先順を使用
します。MIMEメッセージが文字セットを指定している場合、Rmailはその指定に
したがいます。Rmailファイルの読み込みと保存にたいして、Emacsは、変数
‘rmail-file-coding-system’で指定されたコーディングシステムを使用します。
デフォルト値は‘nil’で、これはRmailファイルが変換されないことを意味します
(これらはEmacsの内部文字セットで読み書きされます)。


File: emacs-ja.info,  Node: Rmail Editing,  Next: Rmail Digest,  Prev: Rmail Coding,  Up: Rmail

33.15 メッセージの編集
======================

通常のEmacsのキーバインドのほとんどはRmailモードで利用可能ですが、
‘C-M-n’や‘C-M-h’のように、他の目的のためにRmailにより再定義されているも
のもあります。しかしRmailバッファーは通常読み取り専用で、ほとんどの文字
はRmailコマンドに再定義されています。メッセージのテキストを編集したい場
合、Rmailの‘e’コマンドを使わなければなりません。

‘e’
     カレントメッセージを通常のテキストとして編集します。

   ‘e’ command (‘rmail-edit-current-message’)は、Rmailモードから、Rmail
Editモードという、Textモードと類似した、別のメジャーモードに切り替えます
。メジャーモードの変更はモードラインに示されます。

   Rmail Editモードでは、文字は通常どおり文字自身を挿入し、Rmailコマンド
は利用できません。メッセージの本文とヘッダーフィールドを編集することがで
きます。メッセージの編集を終えたら、‘C-c C-c’ (‘rmail-cease-edit’)で
Rmailモードに戻ります。かわりに‘C-c C-]’ (‘rmail-abort-edit’)とタイプす
れば、編集をキャンセルしてRmailモードに戻ることができます。

   Rmail Editモードに入ることにより、フック‘text-mode-hook’、その後にフ
ック‘rmail-edit-mode-hook’が実行されます(*note Hooks::を参照してください
)。通常のRmailモードにもどると、メッセージを変更した場合には、そのメッセ
ージに属性‘edited’が追加されます(*note Rmail Attributes::を参照)。


File: emacs-ja.info,  Node: Rmail Digest,  Next: Rmail Rot13,  Prev: Rmail Editing,  Up: Rmail

33.16 ダイジェストメッセージ
============================

“ダイジェストメッセージ(digest message)”は、複数の他のメッセージを含み、
それを運ぶために存在するメッセージです。ダイジェストは、いくつかのメーリ
ングリストで使用されています。1日というような一定の期間の間にメーリング
リストに到着したすべてのメッセージが、1つのダイジェストにまとめられて、
メーリングリストに登録した人に送られます。1つのダイジェストを送信するの
にかかるコンピューター時間は、たとえ合計サイズが同じでも個別にメッセージ
を送信するより短くなります。なぜならネットワークでのメール送信において、
メッセージ単位のオーバーヘッドがあるからです。

   ダイジェストメッセージを受信したとき、それを読むもっとも便利な方法は
、それを“非ダイジェスト化(undigestify)”することです。これはダイジェスト
を複数のメッセージに戻します。それから個別にメッセージを読んだり削除でき
ます。これを行なうにはダイジェストメッセージを選択して、コマンド‘M-x
undigestify-rmail-message’をタイプします。これはダイジェストに含まれるメ
ッセージを個別のRmailメッセージに抽出し、ダイジェストの後に挿入します。
ダイジェストメッセージ自身には、削除のフラグがつけられます。


File: emacs-ja.info,  Node: Rmail Rot13,  Next: Movemail,  Prev: Rmail Digest,  Up: Rmail

33.17 Rot13メッセージを読む
===========================

読む人を怒らせたり不快にするかもしれないメーリングリストのメッセージは、
“rot13”と呼ばれる単純なコードでエンコードされているときがあります。この
名前は、エンコードの方法がアルファベットを13文字分巡回させることに由来し
ます。このコードに機密性はなく、それを提供もしません。むしろ、実際のテキ
ストを見るのを避けたいと思う人のためのものです。たとえばビデオの講評など
では、重要なあらすじを隠すためにrot13を使います。

   rot13を使ったバッファーを閲覧するには、コマンド‘M-x
rot13-other-window’を使用します。これはカレントバッファーを他のウィンド
ウで表示します。このウィンドウではテキストを表示するときこのコードを適用
します。


File: emacs-ja.info,  Node: Movemail,  Next: Remote Mailboxes,  Prev: Rmail Rot13,  Up: Rmail

33.18 ‘movemail’ program
========================

Rmailは、inboxからRmailファイルにメールを移動するために、‘movemail’プロ
グラムを使用します。最初にロードされたとき、Rmailは‘movemail’プログラム
を探して、そのバージョンを判断します。‘movemail’プログラムには2つのバー
ジョンがあります。それはGNU Mailutilsバージョン(*note
(mailutils)movemail::を参照)と、‘--with-mailutils’でEmacsをconfigureした
ときにインストールされるEmacs固有バージョンです。これらのコマンドは、同
じコマンドラインシンタックスをもち、同じ基本的なサブセットオプションをも
ちます。しかしMailutilsバージョンは、追加の機能を提供します。

   Emacsバージョンの‘movemail’は、通常のUnix mailbox形式のmailboxからメ
ールを取得することができます。*警告*: これはPOP3プロトコルの使用も可能で
すが、暗号化されたTLSチャンネルを通じたPOP3をサポートしないので、推奨し
ません。

   Mailutilsバージョンは、プレーンUnix mailbox、‘maildir’および‘MH’のメ
ールボックスなどの、より広範なmailbox形式を処理することができます。これ
はPOP3またはIMAP4プロトコルを使用してリモートのmailboxにアクセスでき、
TLS暗号化チャンネル(TLS encrypted channel)を使用してメールを取得できます
。これはURL形式でのmailbox引数を受けとることもできます。mailboix URLの詳
細な説明は、*note (mailutils)URL::で見ることができます。短く言うと、
URLは以下のようなものです:

     PROTO://[USER[:PASSWORD]@]HOST-OR-FILE-NAME[:PORT]

角カッコ(bracket)はオプションの要素を意味します。

PROTO
     “mailboxプロトコル”、または使用する“フォーマット”を指定します。
     URLの残りの要素の正確な意味は、PROTOの実際の値に依存します(以下参照
     )。

USER
     リモートmailboxにアクセスするためのユーザー名です。

PASSWORD
     リモートmailboxにアクセスするためのユーザーパスワードです。

HOST-OR-FILE-NAME
     リモートmailboxのリモートサーバーのホスト名、またはローカル
     mailboxのファイル名です。

PORT
     そのプロトコルのデフォルト以外のポート番号をオプションで指定します
     。

PROTOには以下の1つを指定します:

‘mbox’
     通常のUnix mailbox形式です。この場合USER、PASS、PORTは使用せず、
     HOST-OR-FILE-NAMEはmailboxファイルのファイル名を意味します(例:
     ‘mbox:///var/spool/mail/smith’)。

‘mh’
     MH形式のローカルmailboxです。USER、PASS、PORTは使用せず、
     HOST-OR-FILE-NAMEはMHフォルダーのファイル名を意味します(例:
     ‘mh:///Mail/inbox’)。

‘maildir’
     maildir形式のローカルmailboxです。USER、PASS、PORTは使用せず、
     HOST-OR-FILE-NAMEは‘maildir’ mailboxの名前を意味します(例:
     ‘maildir:///mail/inbox’)。

‘file’
     mailbox形式の任意のローカルファイルです。実際の形式は‘movemail’によ
     り自動的に決定されます。

‘pop’
‘pops’
     POP3プロトコルを通じてアクセスされるリモートmailboxです。USERは使用
     するリモートのユーザー名を指定し、PASSはユーザーパスワードを指定す
     るのに使用され、HOST-OR-FILE-NAMEは接続するリモートメールサーバーの
     ホスト名かIPアドレス、PORTはポート番号です(例:
     ‘pop://smith:guessme@remote.server.net:995’)。サーバーがサポートす
     る場合、‘movemail’は暗号化された接続 — 暗号化接続に要求される
     ‘pops’の使用を試みます。

‘imap’
‘imaps’
     IMAP4プロトコルを通じてアクセスされるリモートmailboxです。USERは使
     用するリモートのユーザー名を指定し、PASSはユーザーパスワードを指定
     するのに使用され、HOST-OR-FILE-NAMEは接続するリモートメールサーバー
     のホスト名かIPアドレス、PORTはポート番号です(例:
     ‘imap://smith:guessme@remote.server.net:993’)。サーバーがサポートす
     る場合、‘movemail’は暗号化された接続 — 暗号化接続に要求される
     ‘imaps’の使用を試みます。"

   かわりに、使用するmailboxのファイル名を指定できます。これはプロトコル
に‘file’を指定するのと等価です:

     /var/spool/mail/USER ≡ file:///var/spool/mail/USER

   変数‘rmail-movemail-program’は、どのバージョンの‘movemail’を使用する
かを制御します。文字列の場合、それは‘movemail’実行ファイルの絶対ファイル
名を指定します。‘nil’の場合、Rmailは‘rmail-movemail-search-path’、
‘exec-path’(*note Shell::を参照してください)、‘exec-directory’の順で、こ
れらの変数にリストされたディレクトリーから、‘movemail’を検索します。


File: emacs-ja.info,  Node: Remote Mailboxes,  Next: Other Mailbox Formats,  Prev: Movemail,  Up: Rmail

33.19 リモートmailboxからのメールの取得
=======================================

inboxファイルにデータを格納するかわりに、POP3と呼ばれる手法を使用してユ
ーザーのinboxデータにアクセスするサイトがいくつかあります。Mailutilsの
‘movemail’は、デフォルトでTLS暗号化されたPOP3をサポートします。*警告:* た
とえ‘Emacs movemail’がPOP3をサポートしていても、Mailutilsバージョンがサ
ポートする暗号化された接続をサポートしないので、これを使用することは推奨
しません。どちらのバージョンの‘movemail’も、POP3にたいしてだけ機能し、
POPの古いバージョンにたいしては機能しません。

   どちらの‘movemail’を使用するかにかかわらず、POP3 “URL”(*note
Movemail::)を使用してPOP3 inboxを指定できます。POP3 URLは、
‘pop://USERNAME@HOSTNAME:PORT’という形式で、HOSTNAMEとPORTはリモートメー
ルサーバーのホスト名(またはIPアドレス)とポート番号、USERNAMEはそのサーバ
ーでのユーザー名です。これに加えて
‘pop://USERNAME:PASSWORD@HOSTNAME:PORT’のようなmailbox URLでパスワードを
指定することもできます。この場合、PASSWORDは‘rmail-remote-password’ (以
下参照)で指定された値より優先されます。これは複数のリモートメールサーバ
ーで異なるパスワードを指定するとき、特に便利です。

   後方互換のため、RmailはリモートのPOP3 mailboxを指定する他の方法もサポ
ートします。‘po:USERNAME:HOSTNAME:PORT’によるinbox名の指定は、
‘pop://USERNAME@HOSTNAME:PORT’と等価です。:HOSTNAMEの部分を省略した場合
は、環境変数‘MAILHOST’で、どのマシンのPOP3サーバーを探すか指定します。

   リモートmailboxesにアクセスする他の方法に、IMAPがあります。この方法は
Mailutils ‘movemail’だけでサポートされます。inboxリストでIMAP mailboxを
指定するには、‘imap://USERNAME[:PASSWORD]@HOSTNAME:PORT’の形式のmailbox
URLを使用します。上記で説明したように、PASSWORDの部分はオプションです。
‘imap’の箇所に‘imaps’を使用したいと思うかもしれません。

   リモートmailboxへのアクセスにはパスワードが要求されます。これを取得す
るためにRmailは以下のアルゴリズムを使います:

  1. mailbox URL(上記参照)でPASSWORDが与えられた場合はそれを使います。
  2. 変数‘rmail-remote-password-required’が‘nil’の場合、Rmailはパスワー
     ドが要求されないと想定します。
  3. 変数‘rmail-remote-password’が非‘nil’の場合はその値を使います。
  4. 上記以外の場合、Rmailはパスワードの入力を求めます。

   追加のコマンドラインフラグを‘movemail’に渡す必要がある場合は、使いた
いフラグのリストを変数‘rmail-movemail-flags’にセットします。inboxの内容
を保持するために。この変数を使ってフラグ‘-p’を渡さないでください。かわり
に‘rmail-preserve-inbox’を使用してください。

   あなたのサイトにインストールされた‘movemail’プログラムは、ケルベロス
認証(Kerberos authentication)をサポートするでしょう。もしサポートされて
いる場合、‘rmail-remote-password’および
‘rmail-remote-password-required’がセットされていないときに、POP3メールの
取得を試みたときは、デフォルトでケルベロス認証を使います。

   メッセージを逆順に保存するPOP3サーバーもあります。あなたのサーバーが
これを行なっている場合、到着した順にメールを読みたいときは、
‘rmail-movemail-flags’に‘-r’フラグを追加することにより、逆順でメッセージ
をダウンロードするよう、‘movemail’に指示できます。

   Mailutils ‘movemail’は、TLS暗号化(TLS encryption)をサポートします。こ
れを使いたい場合は、‘rmail-movemail-flags’に‘--tls’フラグをセットしてく
ださい。


File: emacs-ja.info,  Node: Other Mailbox Formats,  Prev: Remote Mailboxes,  Up: Rmail

33.20 さまざまな形式のローカルmailboxからのメールの取得
=======================================================

受信したメールがローカルマシンのUnix mailbox以外の形式に保存される場合、
これを取得するためにMailutils ‘movemail’を使う必要があるでしょう。
‘movemail’のバージョンについての詳細な説明は、*note Movemail::を参照して
ください。たとえば‘/var/spool/mail/in’にある‘maildir’形式のinboxのメール
にアクセスするには、Rmailのinboxリストに以下を含める必要があるでしょう:

     maildir:///var/spool/mail/in


File: emacs-ja.info,  Node: Gnus,  Next: Host Security,  Prev: Rmail,  Up: Top

34 Email and Usenet News with Gnus
**********************************

Gnusは、主にUsenetニュースを読んだりポストするためにデザインされた、
Emacsパッケージです。これはいくつかの異なるソース — 電子メール、リモート
ディレクトリー、ダイジェスト、などを読んだり、メッセージを返すためにも使
うことができます。以下はGnusの紹介と、いくつかの基本的な機能の説明です。
完全な詳細に付いては、*note Gnus: (gnus)Top.を参照してください。

* Menu:

* Buffers of Gnus::          グループ、サマリー、アーティクルバッファー。
* Gnus Startup::             Gnusの開始するにあたって知っておくべきこと。
* Gnus Group Buffer::        Gnusグループコマンドの短い説明。
* Gnus Summary Buffer::      Gnusサマリーコマンドの短い説明。


File: emacs-ja.info,  Node: Buffers of Gnus,  Next: Gnus Startup,  Up: Gnus

34.1 Gnusバッファー
===================

Gnusは、情報を表示したり返信コマンドのために、複数のバッファーを使用しま
す。もっとも一般的に使用される3つのGnusバッファーは“グループバッファー
(group buffer)”、“サマリーバッファー(summary buffer)”、“アーティクルバッ
ファー(article buffer)”です。

   “グループバッファー”は、アーティクルソースのリスト(たとえばニュースグ
ループや電子メールのinbox)を含んでおり、それらは“グループ”として参照され
ます。これはGnusを開始したときに最初に表示されるバッファーです。これは通
常、あなたが登録したグループと、未読のアーティクルだけを表示します。この
バッファーから、読みたいグループを選択できます。

   “サマリーバッファー”は1つのグループのアーティクルをリストし、1行に1つ
のアーティクルを表示します。デフォルトでは、アーティクルの作者、
subject、 行数が表示されますが、これはカスタマイズできます。*note
(gnus)Summary Buffer Format::を参照してください。 サマリーバッファーは、
グループバッファーでグループを選択すると作成され、グループを抜けると
killされます。

   サマリーバッファーから、閲覧するアーティクルを選択できます。アーティ
クルは“アーティクルバッファー”で表示されます。通常のGnusの使い方では、こ
のバッファーを閲覧はしますが選択はしません — すべての便利なGnusコマンド
はサマリーバッファーから呼び出すことができます。しかし望むなら、アーティ
クルバッファーを選択して、そこからGnusコマンドを実行することもできます。


File: emacs-ja.info,  Node: Gnus Startup,  Next: Gnus Group Buffer,  Prev: Buffers of Gnus,  Up: Gnus

34.2 Gnusを起動したとき
=======================

あなたのシステムがUsenetニュースをよむためにセットアップされていれば、
Gnusを始めるのは簡単です — ‘M-x gnus’とタイプするだけです。

   起動時に、Gnusはホームディレクトリーにある‘.newsrc’という名前の“ニュ
ース初期化ファイル(news initialization file)”を読み込みます。これにはあ
なたのUsenetニュースグループと購読状況がリストされています(これはGnus固
有のファイルではありません。他の多くのニュースリーダープログラムにより使
用されています)。その後システムのデフォルトのニュースサーバーへの接続を
試みます。これは通常、環境変数‘NNTPSERVER’により指定されます。

   あなたのシステムがデフォルトのニュースサーバーをもっていない場合、ま
たは電子メールを読むためにGnusを使いたい場合は、‘M-x gnus’を呼び出す前に
、どこでニュースおよび/またはメールを取得するか、Gnusに指示する必要があ
ります。これを行なうには、変数‘gnus-select-method’および/または
‘gnus-secondary-select-methods’をカスタマイズします。 *note
(gnus)Finding the News::を参照してください。

   1度Gnusを開始すると、グループバッファーを表示します。デフォルトでは少
数の“subscribedグループ(subscribed groups: 登録されたグループ)”だけが表
示されます。他の状態 — “unsubscribed”、“killed”、“zombie” — のグループは
表示されません。最初にGnusを開始したとき、登録していないグループは
killedグループになります。その後にニュースサーバーに現れたグループは
zombieグループになります。

   先に進むには、グループバッファーでグループを選択して、そのグループの
サマリーバッファーを開かなければなりません。その後サマリーバッファーのア
ーティクルを選択して、別のウィンドウでアーティクルバッファーを閲覧します
。以下のセクションでは、これを行なうための、グループバッファーとサマリー
バッファーの使用について説明します。

   Gnusを終了するには、グループバッファーで‘q’とタイプします。これは自動
的にグループの状態をファイル‘.newsrc’ト‘.newsrc.eld’に記録するので、その
後のGnusセッションでも効果があります。


File: emacs-ja.info,  Node: Gnus Group Buffer,  Next: Gnus Summary Buffer,  Prev: Gnus Startup,  Up: Gnus

34.3 Gnus Groupバッファーの使用
===============================

以下のコマンドは、Gnusグループバッファーで利用可能です:

‘<SPC>’
     カレント行のグループの、サマリーバッファーに切り替えます
     (‘gnus-group-read-group’)。

‘l’
‘A s’
     eグループバッファーでは、未読のアーティクルを含む登録したグループだ
     けをリストします(‘gnus-group-list-groups’。これはデフォルトの一覧方
     法である)。

‘L’
‘A u’
     すべてのsubscribed(登録)およびunsubscribed(未登録)のグループをリス
     トしますが、killedまたはzombieのグループは表示しません
     (‘gnus-group-list-all-groups’)。

‘A k’
     killされたグループをリストします(‘gnus-group-list-killed’)。

‘A z’
     ゾンビ状態のグループをリストします(‘gnus-group-list-zombies’)。

‘u’
     カレント行のグループの登録状態を切り替えます
     ((‘gnus-group-unsubscribe-current-group’。たとえばsubscribedグルー
     プをunsubscribedグループにしたり、その逆を行なう)。killedまたは
     zombieのグループにたいしてこれを呼び出すと、そのグループを
     unsubscribedグループにします。

‘C-k’
     カレント行のグループをkillします(‘gnus-group-kill-group’)。killedと
     なったグループは‘.newsrc’ファイルに記録され、‘l’または‘L’のリストに
     は表示されなくなります。

‘<DEL>’
     未読アーティクルを含む、前のグループにポイントを移動します
     (‘gnus-group-prev-unread-group’)。

‘n’
     次の未読グループにポイントを移動します
     (‘gnus-group-next-unread-group’)。

‘p’
     前の未読グループにポイントを移動します
     (‘gnus-group-prev-unread-group’)。

‘q’
     Gnusのセッティングを更新してGnusを終了します(‘gnus-group-exit’)。


File: emacs-ja.info,  Node: Gnus Summary Buffer,  Prev: Gnus Group Buffer,  Up: Gnus

34.4 Gnus Summaryバッファーの使用
=================================

以下のコマンドは、Gnusサマリーバッファーで利用可能です:

‘<SPC>’
     選択されたアーティクルがない場合、カレント行のアーティクルを選択し
     て、それをアーティクルバッファーに表示します。そうでない場合、選択
     されたアーティクルバッファーのウィンドウでスクロールを試みます。バ
     ッファーの最後に到達した場合、次の未読アーティクルを選択します
     (‘gnus-summary-next-page’)。

     したがって、繰り返し<SPC>をタイプすることにより、すべてのアーティク
     ルを読むことができます。

‘<DEL>’
     アーティクルのテキストを後方にスクロールします
     (‘gnus-summary-prev-page’)。

‘n’
     次の未読アーティクルを選択します
     (‘gnus-summary-next-unread-article’)。

‘p’
     前の未読アーティクルを選択します
     (‘gnus-summary-prev-unread-article’)。

‘s’
     選択されたアーティクルバッファーで、あたかもそのバッファーに切り替
     えて‘C-s’(*note Incremental Search::を参照してください)とタイプした
     かのように、インクリメンタル検索を行ないます
     (‘gnus-summary-isearch-article’)。

‘M-s REGEXP <RET>’
     REGEXPへのマッチを含むアーティクルを、前方に検索します
     (‘gnus-summary-search-article-forward’)。

‘M-r REGEXP <RET>’
     REGEXPへのマッチを含むアーティクルを、後方に検索します
     (‘gnus-summary-search-article-backward’)。

‘q’
     サマリーバッファーをexitして、グループバッファーに戻ります
     (‘gnus-summary-exit’)。


File: emacs-ja.info,  Node: Host Security,  Next: Network Security,  Prev: Gnus,  Up: Top

35 ホストセキュリティー
***********************

EmacsはGNU/Linuxのようなオペレーティングシステムの内部で実行され、ファイ
ルアクセスのようなセキュリティー制限のチェックはオペレーティングシステム
に依存します。Emacsのデフォルトセッティングは、通常の使用のためにデザイ
ンされています。通常よりセキュリティーが重要な場合、または重要でない環境
では、何らかの調整が必要になるでしょう。たとえばファイルローカル変数
(file-local variables)が危険な場合もあるので、変数
‘enable-local-variables’に‘:safe’や、(より安全に)‘nil’をセットできます。
ファイルがすべて信用でき、それらの変数にたいするデフォルトのチェックが煩
わしいときには、‘enable-local-variables’に‘:all’をセットできます。*note
Safe File Variables::を参照してください。

   大きなアプリケーションの一部としてEmacsを使用する場合の、セキュリティ
ー考慮についての情報は、*note (elisp)Security Considerations::を参照して
ください。


File: emacs-ja.info,  Node: Network Security,  Next: Document View,  Prev: Host Security,  Up: Top

36 ネットワークセキュリティー
*****************************

Emacsがネットワーク接続を確立するときは、常にその確立された接続を
NSM(“Network Security Manager”)に渡します。NSMは、あなたのコントロールの
もとにセットワークセキュリティーを実施する責任があります。現在のところ、
これはTLS(Transport Layer Security)の機能を使用して動作します。

   変数‘network-security-level’は、NSMが実施するセキュリティーレベルを決
定します。変数の値が‘low’の場合、セキュリティーのチェックは行なわれませ
ん。

   この変数が‘medium’(デフォルト)の場合、いくつかのチェックが行なわれま
す。チェックの結果、NSMがそのネットワーク接続を信頼できないと判断した場
合は、それを知らせて、そのネットワーク接続にたいして何を行なうか尋ねます
。

   証明されていない接続(unverified connection)にたいして、永続的なセキュ
リティー例外(security exception)を登録したり、一時的な例外(temporary
exception)とするか、接続を完全に拒絶することができます。

   以下は‘medium’で行なわれるチェックのリストです。

TLS認証が検証できない(unable to verify a TLS certificate)
     その接続がTLS、SSL、STARTTLS接続の場合、NSMは接続しようとしているサ
     ーバーの同一性(identity)を証明するために使用される認証が、検証でき
     るかどうかチェックします。

     無効な認証が懸念される場合(Man-in-the-Middleによりネットワーク接続
     がハイジャックて、あなたのパスワードが盗まれるかもしれません)や、と
     にかく接続を行なう正当な理由があるかもしれません。たとえばサーバー
     が自己署名された認証(self-signed certificate)を使用していたり、認証
     の期限が切れている場合もあるでしょう。接続の継続を容認するかどうか
     の決定は、あなたに任されています。

自己署名された認証が変更されている(a self-signed certificate has changed)
     以前自己署名された認証を許容したが、今回はそれが変更されていて、そ
     れはそのサーバーが単に認証を変更しただけかもしれませんが、ネットワ
     ーク接続がハイジャックされている可能性もあります。

以前は暗号化されていた接続が、暗号化されていない(previously encrypted connection now unencrypted)
     接続が暗号化されていないが、以前のセッションでは暗号化されていた場
     合、あなたとそのサーバーの間にSTARTTLSアナウンス(STARTTLS
     announcements)を剥奪して、接続を非暗号化するプロキシーがあることを
     意味するかもしれません。これは通常とても疑わしいです。

パスワードを送信するとき暗号化されていないサービスと通信する(talking to an unencrypted service when sending a password)
     IMAPやPOP3のサーバーに接続するとき、ネットワーク越しにパスワードを
     送信するのが一般的なので、接続は通常暗号化されています。同様に、パ
     スワードを要求するSMTPを通じてemailを送信する場合は通常、その接続が
     暗号化されていることを望むでしょう。その接続が暗号化されていない場
     合、NSMは警告します。

   ‘network-security-level’が‘high’の場合、上記に加えて以下のチェックが
行なわれます:

有効な認証がパブリックキーを変更した(a validated certificate changes the public key)
     サーバーはキーを変更するときがあり、通常それは心配することはありま
     せん。しかし、サードパーティーのサービスにたいして新しい認証を発行
     する、偽装しやすい証明期間(pliable Certificate Authorities)へのアク
     セスをもつエージェントにより、ネットワーク接続がハイジャックされて
     いるか心配なときは、これらの変更を追跡したいと思うかもしれません。

Diffie-Hellmanロープライムビット(Diffie-Hellman low prime bits)
     パグリックキーの交換を行なう際、そのチャンネルが第三者により盗聴で
     きないことを確実にするために、プライムビット(prime bits)の数は高く
     あるべきです。この数があまりに低い(low)場合は、警告されるでしょう。

RC4ストリーム暗号(RC4 stream cipher)
     RC4ストリーム暗号は低品質とされており、第三者による盗聴を許すかもし
     れません。

SSL1、SSL2、SSL3
     TLS1.0より古いプロトコルは、様々な攻撃にたいして脆弱とされており、
     あなたが行なうことがより高いセキュリティーを要する場合は、使用を避
     けたいと思うかもしれません。

   最後に、‘network-security-level’が‘paranoid’の場合は、最初にNSMが新た
な認証に遭遇したときに、それが通知されます。これによりEmacsによるすべて
の接続のすべての認証を検証することができるでしょう。

   以下の追加の変数は、NSM操作の詳細を制御するために使用できます。

‘nsm-settings-file’
     これはNSMが接続の詳細を保存するファイルです。デフォルトは
     ‘~/.emacs.d/network-security.data’です。

‘nsm-save-host-names’
     デフォルトでは、非‘STARTTLS’接続ではホスト名は保存されません。接続
     の識別には、かわりにホストとポートによるハッシュ値(host/port hash)が
     使用されます。ユーザーがどのサーバーに接続しているか確認するために
     、誰かが気軽に設定ファイルを読めないことを意味します。この変数が
     ‘t’の場合、NSMは‘nsm-settings-file’にもホスト名を保存します。


File: emacs-ja.info,  Node: Document View,  Next: Shell,  Prev: Network Security,  Up: Top

37 ドキュメントの閲覧
*********************

DocViewモードは、DVI、PostScript(PS)、PDF、OpenDocument、Microsoft
Officeドキュメントを閲覧するためのメジャーモードです。このモードはスライ
ス、ズーム、ドキュメント内の検索などの機能を提供します。これは、
‘gs’(GhostScript)、または‘mudraw’/‘pdfdraw’(MuPDF)、およびその他の外部ツ
ール(1)を使用して、ドキュメントを一連のイメージに変換し、それらのイメー
ジを表示することにより機能します

   DocViewモードで表示可能なドキュメントをvisitすると、Emacsは自動的にそ
のモードを使用します(2)。例外として、PostScriptファイルをvisitしたとき、
EmacsはPostScriptファイルをテキストとして編集するためのメジャーモードの
、PSモードに切り替わります。しかし、これはDocView minorモードも有効にす
るので、‘C-c C-c’とタイプして、そのドキュメントを閲覧することができます
。DocViewモードまたはDocView minorモードでは、‘C-c C-c’
(‘doc-view-toggle-display’)を繰り返すことにより、DocViewとその背後にある
ファイル内容を切り替えることができます。

   いくつかの要件が満たされないとき(たとえばテキスト端末のフレームを操作
していたり、そのEmacsはPNGをサポートしないときなど)に、通常DocViewモード
で処理されるファイルをvisitした場合は、そのドキュメントの内容をプレーン
テキストとして閲覧したいか問い合わせます。これに同意すると、そのバッファ
ーはtextモードとなり、DocView minorモードがアクティブになります。したが
って‘C-c C-c’とタイプすることにより、fallbackモードに切り替わります。も
う1度‘C-c C-c’とタイプすると、DocViewモードに戻ります。DocViewモードで
‘C-c C-t’ (‘doc-view-open-text’)とタイプすることにより、プレーンテキスト
で内容を表示することもできます。

   コマンド‘M-x doc-view-mode’で、DocViewモードを明示的に有効にすること
ができます。また、‘M-x doc-view-minor-mode’で、DocView minorモードに切り
替えることができます。

   DocViewモードを開始したときは、ウェルカム画面を表示して、そのファイル
を1ページずつフォーマットしていきます。最初のページがフォーマットされる
と、そのページを表示します。

   DocViewバッファーをkillするには、‘k’
(‘doc-view-kill-proc-and-buffer’)とタイプします。バッファーを隠す
(bury)には、‘q’ (‘quit-window’)とタイプします。

* Menu:

* Navigation: DocView Navigation.  DocViewバッファーの操作。
* Searching: DocView Searching.  ドキュメント内の検索。
* Slicing: DocView Slicing.  ページのどの部分を表示するか指定する。
* Conversion: DocView Conversion.  変換に影響を与えたり、それを誘発するもの。

   ---------- Footnotes ----------

   (1) PostScriptファイルにたいしてはGhostScriptが絶対条件です。DVIファ
イルにたいしては‘dvipdf’または‘dvipdfm’が必要です。OpenDocumentおよび
Microsoft Officeドキュメントにたいしては‘unoconv’ツールが必要です。

   (2) そのドキュメントに必要な外部ツールが利用可能でなければならず、
Emacsがグラフィカルなフレームで実行されていて、PNGイメージをサポートしな
ければなりません。これらの条件が満たされなければ、Emacsは他のメジャーモ
ードにフォールバックします。


File: emacs-ja.info,  Node: DocView Navigation,  Next: DocView Searching,  Up: Document View

37.1 DocViewの操作
==================

DocViewモードでは通常のEmacs移動キー、つまり‘C-p’、‘C-n’、‘C-b’、‘C-f’、
および矢印キーを使って、ページをスクロールできます。

   デフォルトでは、行移動キーの‘C-p’と‘C-n’は、カレントページの先頭また
は最後でスクロールを止めます。しかし、変数‘doc-view-continuous’を非
‘nil’値に変更した場合、カレントページの先頭で‘C-p’とタイプすると前のペー
ジを表示し、カレントページの最後で‘C-n’とタイプすると次のページを表示し
ます。

   ‘n’、<PageDown>、<next>、‘C-x ]’をタイプすることにより、次のページを
表示することもできます(‘doc-view-next-page’)。前のページを表示するには、
‘p’、<PageUp>、<prior>、‘C-x [’をタイプします
(‘doc-view-previous-page’)。

   <SPC> (‘doc-view-scroll-up-or-next-page’)は、ドキュメントを順に読んで
いくのに便利な方法です。これはカレントページをスクロールするか、次のペー
ジに移動します。<DEL> (‘doc-view-scroll-down-or-previous-page’)は、同様
の方法で後方に移動します。

   最初のページに移動するには、‘M-<’ (‘doc-view-first-page’)とタイプしま
す。最後のページに移動するには、‘M->’ (‘doc-view-last-page’)とタイプしま
す。ページ番号を指定して移動するには、‘M-g M-g’または‘M-g g’
(‘doc-view-goto-page’)とタイプしてください。

   ‘+’ (‘doc-view-enlarge’)と‘-’ (‘doc-view-shrink’)で、ドキュメントを拡
大したり縮小することができます。これらのコマンドはドキュメントを新しいサ
イズに再変換することにより機能します。DocViewにたいするデフォルトサイズ
を指定するには、変数‘doc-view-resolution’をカスタマイズしてください。


File: emacs-ja.info,  Node: DocView Searching,  Next: DocView Slicing,  Prev: DocView Navigation,  Up: Document View

37.2 DocViewの検索
==================

DocViewモードでは、ファイルのテキストにたいして正規表現の検索を行なうこ
とができます(*note Regexps::を参照してください)。検索のインターフェース
は‘isearch’が元になっています(*note Incremental Search::を参照してくださ
い)。

   検索を開始するには、‘C-s’ (‘doc-view-search’)または‘C-r’
(‘doc-view-search-backward’)とタイプします。これはミニバッファーを使用し
て正規表現を読み取り、そのドキュメントでマッチした数をエコーします。
‘C-s’または‘C-r’とタイプすることにより、マッチ間を前方または後方に移動で
きます。DocViewモードはページイメージの中でマッチを表示できません。かわ
りに、カレントページのマッチするすべての行を一覧するツールチップを、(マ
ウス位置に)表示します。このツールチップを強制的に表示するには‘C-t’
(‘doc-view-show-tooltip’)とタイプしてください。

   新しい検索を開始するには、たとえば前方検索では‘C-u C-s’、後方検索では
‘C-u C-r’のように、検索コマンドにプレフィクス引数を使用します。


File: emacs-ja.info,  Node: DocView Slicing,  Next: DocView Conversion,  Prev: DocView Searching,  Up: Document View

37.3 DocViewのスライス
======================

印刷のために広い余白をもつドキュメントもあります。これらはスクリーンでド
キュメントを読むとき邪魔になることがあります。なぜならこれらは画面スペー
スを消費して、スクロールが不便になるからです。

   DocViewでは、表示するページの“スライス(slice)”を選択することにより、
これらの余白を隠すことができます。スライスはページ内の矩形領域です。
DocViewで1度スライスを指定すると、閲覧するすべてのページに適用されます。

   数値でスライスを指定するには、‘s s’ (‘doc-view-set-slice’)とタイプし
ます。その後、スライスの左上のピクセル位置(pixel position)と、スライスの
幅(width)と高さ(height)を入力します。

   スライスを指定するための、もっと便利でグラフィカルな方法は、‘s m’
(‘doc-view-set-slice-using-mouse’)で、スライスの選択にマウスを使う方法で
す。これは単に、スライスにしたいリージョンの左上隅で左マウスボタンを押し
て、そのまま右下隅にマウスポインターを移動してマウスボタンを離します。

   最適なスライスをセットする一番簡単な方法は、‘s b’
(‘doc-view-set-slice-from-bounding-box’)とタイプすることにより、そのドキ
ュメントから自動的に判断されるBoundingBox情報を使う方法です。

   選択されたスライスを取り消すには、‘s r’ (‘doc-view-reset-slice’)とタ
イプします。するとDocViewは、余白全体を含めたページ全体を表示します。


File: emacs-ja.info,  Node: DocView Conversion,  Prev: DocView Slicing,  Up: Document View

37.4 DocViewの変換
==================

効率のために、DocViewは‘gs’により生成されたイメージをキャッシュします。
イメージをキャッシュするディレクトリーの名前は、変数
‘doc-view-cache-directory’により与えられます。‘M-x
doc-view-clear-cache’とタイプすることにより、キャッシュディレクトリーを
クリアーできます。

   現在閲覧中のドキュメントを強制的に再変換するには、type ‘r’または‘g’
(‘revert-buffer’)とタイプします。カレントバッファーに関連付けられた変換
プロセスをkillするには、‘K’ (‘doc-view-kill-proc’)とタイプします。コマン
ド‘k’ (‘doc-view-kill-proc-and-buffer’)は、変換プロセスとDocViewバッファ
ーをkillします。


File: emacs-ja.info,  Node: Shell,  Next: Emacs Server,  Prev: Document View,  Up: Top

38 Emacsからのシェルコマンドの実行
**********************************

Emacsには、シェルサブプロセスに1つのコマンドラインを渡したり、入出力に
Emacsバッファーを使用して対話的にシェルを実行するコマンドや、端末エミュ
レーターウィンドウでシェルを実行するコマンドがあります。

‘M-! CMD <RET>’
     シェルコマンドCMDを実行して、出力を表示します(‘shell-command’)。
‘M-| CMD <RET>’
     リージョンの内容を入力としてシェルコマンドCMDを実行します。オプショ
     ンでリージョンを出力で置き換えます(‘shell-command-on-region’)。
‘M-& CMD <RET>’
     シェルコマンドCMDを非同期で実行し、出力を表示します
     (‘async-shell-command’)。
‘M-x shell’
     Emacsバッファーを通じて入出力を行なう、サブシェルを実行します。その
     後で、コマンドを対話的に与えることができます。
‘M-x term’
     Emacsバッファーを通じて入出力を行なう、サブシェルを実行します。その
     後でコマンドを対話的に与えることができます。完全な端末エミュレーシ
     ョンが利用できます。

   (上記のコマンドのCMD引数、または他のコンテキストにおいて)実行可能プロ
グラムとして相対ファイル名を指定したときは、Emacsは変数‘exec-path’により
指定されるディレクトリーのプログラムを検索します。この変数の値は、ディレ
クトリーのリストでなければなりません。デフォルト値は、Emacsが開始された
ときの環境変数‘PATH’により初期化されます(*note General Variables::を参照
してください)。

   ‘M-x eshell’は、Emacsで完全に実装されたシェルを呼び出します。eshellに
ついては、自身のマニュアルにドキュメントされています。 *note Eshell:
(eshell)Top.を参照してください。

* Menu:

* Single Shell::             シェルコマンドを実行してから、戻る方法。
* Interactive Shell::        Emacsを通じて入力を行なう永続的なシェル。
* Shell Mode::               永続的なシェルで使用される特別なEmacsコマンド。
* Shell Prompts::            シェルプロンプトを認識する2つの方法。
* History: Shell History.    シェルバッファーで前のコマンドを繰り返す。
* Directory Tracking::       サブシェルでのディレクトリーの変更の追跡。
* Options: Shell Options.    Shellモードをカスタマイズするオプション。
* Terminal emulator::        端末エミュレーターとしてのEmacsウィンドウ。
* Term Mode::                Termモードで使用される特別なEmacsコマンド。
* Remote Host::              他のコンピューターへの接続。
* Serial Terminal::          シリアルポートへの接続。


File: emacs-ja.info,  Node: Single Shell,  Next: Interactive Shell,  Up: Shell

38.1 単一のシェルコマンド
=========================

‘M-!’ (‘shell-command’)は、ミニバッファーを使って1行のテキストを読み取り
、それをシェルコマンドとして、そのコマンドのためだけに作成されたサブシェ
ルで実行します。そのコマンドの標準入力はnullデバイスです。シェルコマンド
が出力を生成する場合、その出力はエコーエリア(出力が短い場合)、または別の
ウィンドウの‘*Shell Command Output*’という名前のEmacsバッファー(出力が長
い場合)に表示されます。変数‘resize-mini-windows’と
‘max-mini-window-height’は、出力がエコーエリアにたいして長過ぎると
Emacsが判断した場合に、ウィンドウのサイズ変更を制御します(*note
Minibuffer Edit::を参照)。

   たとえば‘foo.gz’という名前のファイルを解凍する1つの方法は、‘M-!
gunzip foo.gz <RET>’とタイプすることです。このシェルコマンドは通常、ファ
イル‘foo’を作成して、端末出力を生成しません。

   たとえば‘M-1 M-!’のように‘shell-command’に数引数を指定した場合、別の
バッファーではなく、カレントバッファーに端末出力を挿入します。これはポイ
ントを出力の前に配し、出力の後にマークを配します。たとえば‘M-1 M-!
gunzip < foo.gz <RET>’は、カレントバッファーにファイル‘foo.gz’の解凍され
た内容を挿入します。

   最後が‘&’でないシェルコマンドを指定した場合、コマンドは“同期
(synchronously)”で実行され、Emacsを継続して使用するには、コマンドが
exitするのを待たなければなりません。待つのを中止するには、‘C-g’とタイプ
します。これはシェルコマンドを終了するために、シグナル‘SIGINT’を送ります
(これは通常、シェルで‘C-c’とタイプしたときに生成されるのと同じシグナルで
す)。その後、Emacsはコマンドが実際に終了するまで待ちます。シェルコマンド
が終了しない場合(そのコマンドがシグナル‘SIGINT’を無視する場合)は、再度
‘C-g’とタイプします。これは　そのコマンドにたいして、無視することが不可能
なシグナル‘SIGKILL’を送ります。

   ‘&’で終わるシェルコマンドは“非同期(asynchronously)”で実行され、それを
実行した後でも、継続してEmacsを使用できます。シェルコマンドを非同期で実
行する前に、‘M-&’ (‘async-shell-command’)とタイプすることもできます。こ
れは最後の‘&’が必要ない点を除き、最後に‘&’を指定して‘M-!’を呼び出すこと
と同じです。非同期シェルコマンドにたいするデフォルトの出力バッファーは、
‘*Async Shell Command*’という名前のバッファーです。このバッファーがウィ
ンドウに表示されているかに関わらず、Emacsは出力をこのバッファーに挿入し
ます。

   同時に複数の非同期シェルコマンドを実行した場合、出力バッファーが競合
します。この場合どのようにするか — たとえば既存の出力バッファーをリネー
ムしたり、新しいコマンドに異なるバッファーを使用する — を、オプション
‘async-shell-command-buffer’で指定できます。他の可能なオプションについて
は、この変数のドキュメントを参照してください。

   非同期シェルコマンドが出力を生成したときだけ出力バッファーが表示され
るようにしたい場合は、‘async-shell-command-display-buffer’を‘nil’にセッ
トしてください。

   ‘M-|’ (‘shell-command-on-region’)は‘M-!’と同様ですが、入力を与えない
かわりに、リージョンの内容をシェルコマンドの標準入力として渡します。数引
数を指定した場合、古いリージョンの内容を、シェルコマンドの出力で置き換え
ます。

   たとえば‘M-|’で‘gpg’プログラムを使用して、そのバッファーのキーが何か
を見ることができます。そのバッファーがGnuPGキーを含む場合、‘C-x h M-|
gpg <RET>’とタイプして、バッファー全体の内容を‘gpg’に送ることができます
。これはキーのリストを、‘*Shell Command Output*’バッファーに出力します。

   上記のコマンドは、変数‘shell-file-name’で指定されたシェルを使用します
。この変数のデフォルト値は、Emacsが開始されたときの環境変数‘SHELL’により
決定されます。相対ファイル名の場合、Emacsは‘exec-path’にリストされたディ
レクトリーを検索します(*note Shell::を参照してください)。

   ‘M-!’または‘M-|’にたいするコーディングシステムを指定するには、あらか
じめコマンド‘C-x <RET> c’を使用します。*note Communication Coding::を参
照してください。

   デフォルトでは、出力バッファーではエラー出力と標準出力が混ざって出力
されます。しかし変数‘shell-command-default-error-buffer’の値を文字列に変
更すると、エラー出力はその名前のバッファーに出力されます。

   デフォルトでは、出力バッファーはシェルコマンドとシェルコマンドの間に
消去されます。変数‘shell-command-dont-erase-buffer’の値を非‘nil’値に変更
した場合、出力バッファーは消去されません。この変数は、コマンドが完了した
とき、ポイントを出力バッファーのどこに配すかも制御します。詳細は変数のド
キュメントを参照してください。


File: emacs-ja.info,  Node: Interactive Shell,  Next: Shell Mode,  Prev: Single Shell,  Up: Shell

38.2 対話的なサブシェル
=======================

対話的にサブシェルを実行するには、‘M-x shell’とタイプします。これは
‘*shell*’という名前のバッファーを作成(または再使用)して、そのバッファー
にたいして入出力を行なう、シェルのサブプロセスを実行します。つまりサブシ
ェルからの端末出力はポイントの後に挿入されてポイントを進め、サブシェルに
たいする端末入力はそのバッファーのテキストになります。サブシェルにたいし
て入力を与えるには、バッファーの最後に移動して入力をタイプし、<RET>で終
了します。

   デフォルトでは、サブシェルが対話的に呼び出された際、カレントウィンド
ウですでに‘*shell*’バッファーを表示していない場合は、新たなウィンドウに
‘*shell*’バッファーが表示されます。この動作は
‘display-buffer-alist’(*note Window Choice::を参照)を通じてカスタマイズ
できます。

   サブシェルがコマンドの実行を待つ間、ウィンドウまたはバッファーを切り
替えてEmacsで他の編集を行なうことができます。Emacsはそれを処理するときが
きたら(たとえばキーボード入力待ちになったとき)、サブシェルからの出力を
Shellバッファーに挿入します。

   Shellバッファーでは、プロンプトはフェイス‘comint-highlight-prompt’で
表示され、サブミットされた入力行はフェイス‘comint-highlight-input’で表示
されます。これにより入力行とシェル出力を容易に区別することができます。
*note Faces::を参照してください。

   複数のサブシェルを作成するには、(‘C-u M-x shell’)のように)プレフィク
ス引数を指定して‘M-x shell’を呼び出します。その後、このコマンドはバッフ
ァー名を読み取り、そのバッファーでサブシェルを作成(または再使用)します。
‘M-x rename-uniquely’を使用して‘*shell*’バッファーをリネームしてから、
‘M-x shell’で新しい‘*shell*’バッファーを作成することもできます。異なるバ
ッファーのサブシェルは、並行して独立に実行されます。

   ‘M-x shell’によりシェルファイル名を指定するには、変数
‘explicit-shell-file-name’をカスタマイズします。これが‘nil’(デフォルト
)の場合、もし存在すればEmacsは環境変数‘ESHELL’を使用します。そうでない場
合は通常、変数‘shell-file-name’を使用します(*note Single Shell::を参照し
てください)。しかしデフォルトディレクトリーがリモートの場合(*note Remote
Files::を参照してください)、シェルファイル名の入力を求めます。リモートフ
ァイル名を正しくタイプする方法に関するヒントは、*note Minibuffer File::を
参照してください。

   Emacsは新しいシェルにたいする入力として、もしそれが存在すればファイル
‘~/.emacs_SHELLNAME’の内容を送ります。ここでSHELLNAMEは、そのシェルがロ
ードされたファイルの名前です。たとえばbashを使う場合、送られるファイルは
‘~/.emacs_bash’になります。ファイルが見つからない場合、Emacsは
‘~/.emacs.d/init_SHELLNAME.sh’の使用を試みます。

   シェルにたいしてコーディングシステムを指定するには、‘M-x shell’の直前
にコマンド‘C-x <RET> c’を使用します。‘C-x <RET> p’とタイプすることにより
、実行されているサブシェルにたいするコーディングシステムを変更することも
できます。*note Communication Coding::を参照してください。

   サブシェルでは、Emacsは環境変数‘INSIDE_EMACS’に‘VERSION,comint’をセッ
トします。ここでVERSIONは、Emacsのバージョン(たとえば‘24.1’)です。プログ
ラムはこの変数をチェックして、Emacsの内部で実行されているかを判断するこ
とができます。


File: emacs-ja.info,  Node: Shell Mode,  Next: Shell Prompts,  Prev: Interactive Shell,  Up: Shell

38.3 Shellモード
================

ShellバッファーのためのメジャーモードはShellモードです。このモードの特別
なコマンドは‘C-c’プレフィクスにバインドされており、最初に‘C-c’をタイプし
なければならない点を除けば、通常のシェルでの編集やジョブ制御文字と共通点
があります。以下はShellモードのコマンドのリストです:

‘<RET>’
     サブシェルの入力にカレント行を送ります(‘comint-send-input’)。行頭の
     シェルプロンプトは省略されます(*note Shell Prompts::を参照してくだ
     さい)。ポイントがバッファーの最後にある場合、これは通常の対話的なシ
     ェルにおいてコマンド行をサブミットするのに似ています。しかし、シェ
     ルバッファーの他の場所でも、<RET>を呼び出してカレント行を入力として
     サブミットできます。

‘<TAB>’
     シェルバッファーのポイントの前のコマンド名、またはファイル名を補完
     します(‘completion-at-point’)。これは通常のEmacs補完ルールを使用し
     ます(*note Completion::を参照してください)。ファイル名、環境変数名
     、シェルコマンドヒストリー、ヒストリー参照が補完候補になります
     (*note History References::を参照してください)。補完を制御するオプ
     ションについては、*note Shell Options::を参照してください。

‘M-?’
     ポイントの前のファイル名にたいして、可能性のある補完リストを一時的
     に表示します(‘comint-dynamic-list-filename-completions’)。

‘C-d’
     delete文字、またはEOF文字を送ります
     (‘comint-delchar-or-maybe-eof’)。シェルバッファーの最後でこれをタイ
     プすると、サブシェルにEOFが送られます。バッファーの他の場所でタイプ
     すると、通常どおり文字を削除します。

‘C-c C-a’
     行の先頭に移動しますが、プロンプトがある場合はプロンプトの後に移動
     します(‘comint-bol-or-process-mark’)。このコマンドを連続して繰り返
     すと、2回目はプロセスマーク(process mark)に戻ります。これはサブシェ
     ルにまだ送信されていない入力の開始位置のことです(通常これは同じ場所
     — その行のプロンプトの最後 — ですが、‘C-c <SPC>’の後では、プロセス
     マークは前の行にあるかもしれません)。

‘C-c <SPC>’
     複数行の入力を累積して、それらを合わせて送ります
     (‘comint-accumulate’)。このコマンドはポイントの前に改行を挿入します
     が、その前のテキストをサブシェルの入力として — 少なくともその時点で
     は — 送りません。改行の前後の行は両方、(それらを分割する改行も含め
     て)<RET>をタイプしたとき一緒に送られます。

‘C-c C-u’
     まだ入力として送られていない、バッファーの最後のすべてのテキストを
     killします(‘comint-kill-input’)。ポイントがバッファーの最後にない場
     合、これはポイントの前のテキストだけをkillします。

‘C-c C-w’
     ポイントの前の単語をkillします(‘backward-kill-word’)。

‘C-c C-c’
     シェルまたは(もしあれば)カレントのサブジョブに割り込み(interrupt)ま
     す(‘comint-interrupt-subjob’)。このコマンドはシェルバッファーの最後
     の、まだ送られていない任意のシェル入力もkillします。

‘C-c C-z’
     シェルまたは(もしあれば)カレントのサブジョブを停止(stop)します。
     (‘comint-stop-subjob’)。このコマンドはシェルバッファーの最後の、ま
     だ送られていない任意のシェル入力もkillします。

‘C-c C-\’
     シェルまたは(もしあれば)カレントのサブジョブに、シグナルQUITを送り
     ます(‘comint-quit-subjob’)。このコマンドはシェルバッファーの最後の
     、まだ送られていない任意のシェル入力もkillします。

‘C-c C-o’
     前のシェルコマンドからの出力の一群を削除します
     (‘comint-delete-output’)。これはシェルコマンドが大量の出力を吐くと
     きに便利です。

‘C-c C-s’
     前のシェルコマンドからの出力の一群をファイルに書き込みます
     (‘comint-write-output’)。プレフィクス引数を指定した場合は、ファイル
     に追加で書き込みます。出力の最後のプロンプトは書き込まれません。

‘C-c C-r’
‘C-M-l’
     前の一群の出力の最初がウィンドウの最上部になるようにスクロールし、
     カーソルもそこに移動します(‘comint-show-output’)。

‘C-c C-e’
     バッファーの最後の行がウィンドウの最下部になるようにスクロールしま
     す(‘comint-show-maximum-output’)。

‘C-c C-f’
     シェルコマンド1つ分、前方に移動しますが、カレント行を超えては移動し
     ません(‘shell-forward-command’)。変数‘shell-command-regexp’は、コマ
     ンドの最後を認識する方法を指定します。

‘C-c C-b’
     シェルコマンド1つ分、後方に移動しますが、カレント行を超えて移動はし
     ません(‘shell-backward-command’)。

‘M-x dirs’
     シェルに作業ディレクトリーを尋ね、Shellバッファーのデフォルトディレ
     クトリーを更新します。*note Directory Tracking::を参照してください
     。

‘M-x send-invisible <RET> TEXT <RET>’
     エコーなしでTEXTを読み取った後、それをシェルの入力として送ります。
     これはシェルコマンドでパスワードを尋ねるプログラムを実行するとき便
     利です。

     デフォルトではEmacsはパスワードをエコーしないことに注意してください
     。もし本当にエコーさせたいときは、以下のLisp式を評価します(*note
     Lisp Eval::を参照してください):

          (remove-hook 'comint-output-filter-functions
                       'comint-watch-for-password-prompt)

‘M-x comint-continue-subjob’
     シェルプロセスを継続します。これは間違ってシェルプロセスをサスペン
     ドしてしまったときなどに便利です。(1)

‘M-x comint-strip-ctrl-m’
     シェル出力のカレントグループから、すべてのcontrol-M文字を破棄します
     。このコマンドを使うもっとも便利な方法は、サブシェルからの出力を受
     け取ったときに自動的に実行されるようにする方法です。これを行なうに
     は、以下のLisp式を評価します:

          (add-hook 'comint-output-filter-functions
                    'comint-strip-ctrl-m)

‘M-x comint-truncate-buffer’
     このコマンドはシェルバッファーを、変数
     ‘comint-buffer-maximum-size’により指定される、特定の最大行数に切り
     詰めます。以下は、サブシェルから出力を受けとるとき、毎回自動的にこ
     れを行なう方法です:

          (add-hook 'comint-output-filter-functions
                    'comint-truncate-buffer)

   Shellモードは、サブプロセスと対話的に通信を行なう一般的な用途向けの
Comintモードから派生したモードです。上記のコマンド名からも判るとおり、
Shellモードのほとんどの機能は、実際にはComintモードが由来です。Shellモー
ドの特別な機能には、ディレクトリー追跡機能、およびいくつかのユーザーコマ
ンドが含まれます。

   Comintモードの変種を使う他のEmacs機能には、GUD (*note Debuggers::を参
照してください)や、‘M-x run-lisp’ (*note External Lisp::を参照してくださ
い)が含まれます。

   サブプロセスとして選択した任意のプログラムを実行するために、Shellモー
ドに特化しない未修正のComintモードを使用するには、‘M-x comint-run’を使用
することができます。

   ---------- Footnotes ----------

   (1) シェルプロセスをサスペンドするべきではありません。これはシェルの
サブジョブのサスペンドとはまったく違います。サブジョブのサスペンドは通常
行なわれますが、サブジョブを継続するためにはシェルを使用しなければなりま
せん。このコマンドはそれを行ないません。


File: emacs-ja.info,  Node: Shell Prompts,  Next: Shell History,  Prev: Shell Mode,  Up: Shell

38.4 Shellプロンプト
====================

プロンプトとは、新しいユーザー入力を受け取る準備ができたことを表す、プロ
グラムによるテキスト出力のことです。Comintモード(したがってShellモードも
)は通常、サブプロセスからの出力にもとづいて、バッファーの一部をプロンプ
トとして自動的に判断します(具体的には、改行で終端されていない任意の出力
行を受け取ったときは、プロンプトとみなします)。

   Comintモードは、バッファーを2つのタイプの“フィールド(fields)”に分けま
す。1つは入力フィールド(ユーザーの入力がタイプされるところ)で、もう1つは
出力フィールド(入力フィールド以外)です。プロンプトは出力フィールドの一部
です。ほとんどのEmacs移動コマンドは、そのコマンドが複数行を移動しない限
り、フィールド境界を超えることはありません。たとえば、ポイントがシェルコ
マンドの入力フィールドにある場合、‘C-a’はポイントを入力フィールドの先頭
、プロンプトの後に配します。内部的には、フィールドはテキストプロパティー
‘field’を使って実装されています(*note (elisp)Text Properties::を参照して
ください)。

   変数‘comint-use-prompt-regexp’を非‘nil’値に変更した場合、Comintモード
は正規表現を使ってプロンプトを認識します(*note Regexps::を参照してくださ
い)。Shellモードでは、その正規表現は変数‘shell-prompt-pattern’により指定
されます。‘comint-use-prompt-regexp’のデフォルト値は‘nil’です。なぜなら
プロンプト認識のためのこの方法は信頼性が低いためです。しかし特殊な状況で
は、これを非‘nil’値にセットしたいと思うこともあるでしょう。そのような場
合、EmacsはComintバッファーをフィールドに分割しないので、一般的な移動コ
マンドは、テキストプロパティーを使用せず、それらのコマンドがバッファーで
通常行なうように振る舞います。しかし、バッファーを便利に操作するために、
パラグラフ移動コマンドを使うことができます(*note Paragraphs::を参照して
ください)。Shellモードでは、Emacsはパラグラフ境界に
‘shell-prompt-pattern’を使用します。


File: emacs-ja.info,  Node: Shell History,  Next: Directory Tracking,  Prev: Shell Prompts,  Up: Shell

38.5 Shellコマンドヒストリー
============================

Shellバッファーは、以前のコマンドを繰り返す3つの方法をサポートします。
1つ目はミニバッファーヒストリーにたいして使うのと同じようなキーを使う方
法です。つまり、これらはミニバッファーで行なうのと同じように、前のコマン
ドからテキストを挿入して、ポイントを常にバッファーの最後に保ちます。2つ
目は、バッファーを移動して元の場所から前の入力を取得して、それらを再実行
したり、バッファーの最後にコピーする方法です。3つ目は‘!’スタイルのヒスト
リー参照を使う方法です。

* Menu:

* Ring: Shell Ring.          ヒストリーリストからコマンドを取り出す。
* Copy: Shell History Copying.  コマンドに移動して、それをコピーする。
* History References::       ‘!’スタイルのヒストリー参照の展開。


File: emacs-ja.info,  Node: Shell Ring,  Next: Shell History Copying,  Up: Shell History

38.5.1 Shellヒストリーリング
----------------------------

‘M-p’
‘C-<UP>’
     以前のシェルコマンドから、次に古いコマンドを取り出します
     (‘comint-previous-input’)。

‘M-n’
‘C-<DOWN>’
     以前のシェルコマンドから、次に新しいコマンドを取り出します
     (‘comint-next-input’)。

‘M-r’
     以前のシェルコマンドにたいして、インクリメンタルregexp検索を開始し
     ます(‘comint-history-isearch-backward-regexp’)。

‘C-c C-x’
     ヒストリーから次のコマンドを取り出します
     (‘comint-get-next-from-history’)。

‘C-c .’
     以前のシェルコマンドから引数を1つ取り出します
     (‘comint-input-previous-argument’)。

‘C-c C-l’
     そのバッファーのシェルコマンドのヒストリーを、別のウィンドウに表示
     します(‘comint-dynamic-list-input-ring’)。

   Shellバッファーは、以前に入力したシェルコマンドのヒストリーを提供しま
す。ヒストリーからシェルコマンドを再利用するには、編集コマンド‘M-p’、
‘M-n’、‘M-r’を使用します。これらは、ミニバッファーではなくShellバッファ
ーを操作する点を除き、ミニバッファーヒストリーコマンド(*note Minibuffer
History::を参照してください)と同じように機能します。またShellバッファー
内での‘M-r’は、シェルコマンドヒストリーにたいするインクリメンタル検索を
呼び出します。

   ‘M-p’は、シェルバッファーの最後から以前のシェルコマンドを取り出します
。連続して‘M-p’を使用すると、古いシェルコマンドを連続して取り出し、その
度にシェル入力の候補として表示されているテキストを置き換えます。‘M-n’も
同様に機能しますが、これはバッファーから、より新しいシェルコマンドを連続
して探します。‘C-<UP>’は‘M-p’と同様に機能し、‘C-<DOWN>’は‘M-n’と同様に機
能します。

   ヒストリー検索コマンド‘M-r’は、以前のシェルコマンドにたいしてインクリ
メンタル正規表現検索を開始します。‘M-r’とタイプした後に、検索したい文字
列か正規表現のタイプを開始します。するとマッチする最後のシェルコマンドが
カレント行に表示されます。インクリメンタル検索コマンドは通常の効果をもち
ます — たとえば‘C-s’および‘C-r’は前方または後方に、次のマッチを検索しま
す(*note Incremental Search::を参照してください)。探している入力が見つか
ったら、検索を終了するために<RET>をタイプします。これにより、入力がコマ
ンドラインに配されます。ヒストリーリストを操作する前にタイプしていた入力
の一部は、ヒストリーリングの先頭または最後に達したときに復元されます。

   以前に実行した一連のシェルコマンドを、同じ順番で再実行できたら便利な
こともあります。これを行なうには、最初に順番に再実行する1番目のコマンド
を検索します。その後‘C-c C-x’とタイプします。これは次のコマンド — つまり
再実行したコマンドの次のコマンドを取り出します。それから<RET>でそのコマ
ンドを実行します。‘C-c C-x <RET>’を繰り返しタイプすることにより、連続す
る複数のコマンドを再実行することができます。

   コマンド‘C-c .’ (‘comint-input-previous-argument’)は、Bashの‘<ESC>
.’のように、以前のコマンドから個別に引数をコピーします。一番簡単な使い方
は、以前のシェルコマンドから最後の引数をコピーする方法です。プレフィクス
引数Nを指定すると、N番目の引数をコピーします。繰り返し‘C-c .’とタイプす
ることにより、さらに古いシェルコマンドからコピーします。この場合、常に同
じNの値を使用します(‘C-c .’を繰り返すときは、プレフィクス引数を与えない
でください)。

   これらのコマンドは、以前のシェルコマンドのテキストを、シェルバッファ
ー自身からではなく、特別なヒストリーリストから取得します。したがってシェ
ルバッファーを編集したり、広い範囲をkillしても、これらのコマンドがアクセ
スするヒストリーに影響はありません。

   シェルの中には、コマンドヒストリーをファイルに保存して、以前のシェル
セッションからコマンドを参照できるようにするものがあります。Emacsは選択
されたシェルにたいして、コマンドヒストリーを初期化するために、コマンドヒ
ストリーファイルを読み込みます。ヒストリーファイル名は、bashでは
‘~/.bash_history’、kshでは‘~/.sh_history’、他のシェルでは‘~/.history’で
す。


File: emacs-ja.info,  Node: Shell History Copying,  Next: History References,  Prev: Shell Ring,  Up: Shell History

38.5.2 Shellヒストリーのコピー
------------------------------

‘C-c C-p’
     前のプロンプトにポイントを移動します(‘comint-previous-prompt’)。

‘C-c C-n’
     次のプロンプトにポイントを移動します(‘comint-next-prompt’)。

‘C-c <RET>’
     ポイント位置の入力コマンドをコピーして、そのコピーをバッファーの最
     後に挿入します(‘comint-copy-old-input’)。これは以前のコマンドにポイ
     ントを移動したときに便利です。コマンドをコピーした後、<RET>でそのコ
     ピーを入力として実行することができます。再実行する前に、そのコピー
     を編集することもできます。このコマンドを出力行で使用した場合、その
     行をバッファーの最後にコピーします。

‘mouse-2’
     ‘comint-use-prompt-regexp’が‘nil’(デフォルト)の場合、クリックした以
     前の入力コマンドをコピーして、そのコピーをバッファーの最後に挿入し
     ます(‘comint-insert-input’)。‘comint-use-prompt-regexp’が非‘nil’、
     または以前の入力以外の場所をクリックしたときは、通常のようにyankし
     ます。

   以前の入力に移動して、‘C-c <RET>’または‘mouse-2’でコピーすることは、
‘M-p’を充分な回数使用して、ヒストリーリングから以前の入力を取り出したと
きと同じ結果 — つまり同じバッファー内容 — を生成します。しかし‘C-c
<RET>’は、バッファーからテキストをコピーするので、入力をシェルに送信した
後に入力テキストを編集していた場合は、ヒストリーリストと異なります。


File: emacs-ja.info,  Node: History References,  Prev: Shell History Copying,  Up: Shell History

38.5.3 Shellヒストリーの参照
----------------------------

cshやbashを含むさまざまなシェルは、‘!’や‘^’で始まる“ヒストリー参照
(history references)”をサポートします。Shellモードはこれらを認識して、ヒ
ストリーの置き換える処理をします。

   ヒストリー参照を挿入して<TAB>とタイプすると、これは入力ヒストリーから
マッチするコマンドを検索して、必要なら置換を行い、結果をバッファー内のヒ
ストリー参照の場所に配します。たとえば、一番最近の‘mv’で始まるコマンドを
取り出すには、‘! m v <TAB>’とタイプします。必要ならコマンドを編集して、
<RET>でシェルにたいしてコマンドを再実行できます。

   Shellモードはヒストリー参照をシェルに送るとき、オプションでヒストリー
参照を展開できます。これを行なうには、変数‘comint-input-autoexpand’を
‘input’にセットします。<SPC>を‘comint-magic-space’にバインドすれば、
<SPC>でヒストリー参照を展開できます。*note Rebinding::を参照してください
。

   Shellモードは、ヒストリー参照がプロンプトの後にあればヒストリー参照を
認識します。Shellモードがプロンプトを認識する方法については、*note Shell
Prompts::を参照してください。


File: emacs-ja.info,  Node: Directory Tracking,  Next: Shell Options,  Prev: Shell History,  Up: Shell

38.6 ディレクトリーの追跡
=========================

Shellモードは、Shellバッファーのデフォルトディレクトリー(*note File
Names::を参照してください)をシェルの作業ディレクトリーと同一に保つために
、サブシェルに与えられる‘cd’、‘pushd’、‘popd’のコマンドを追跡します。こ
れは、送信する入力行を調べることにより認識されます。

   これらのコマンドにたいしてエイリアスを使用する場合、変数
‘shell-pushd-regexp’、‘shell-popd-regexp’、‘shell-cd-regexp’に適切な正規
表現(*note Regexps::を参照してください)をセットすることにより、それらも
認識するようEmacsに指示できます。たとえば、‘shell-pushd-regexp’がシェル
コマンドラインの先頭にマッチした場合、その行は‘pushd’コマンドとして記録
されます。これらのコマンドは、シェルコマンドラインの先頭だけで認識されま
す。

   Emacsが作業ディレクトリーの変更に際して混乱した場合は、‘M-x dirs’を試
してください。このコマンドはシェルに作業ディレクトリーを尋ねて、それに対
応してデフォルトディレクリーを更新します。これは、一般的なコマンド構文の
ほとんどをサポートするシェルでは機能しますが、特殊なシェルでは機能しない
かもしれません。

   シェルの作業ディレクトリーを追跡する他の方法を実装した、バッファーロ
ーカルなマイナーモードの、Dirtrackモードを使うこともできます。この方法を
使うには、シェルプロンプトに常に作業ディレクトリーが含まれていなければな
らず、プロンプトのどの部分が作業ディレクトリーを含むか認識するための正規
表現を与えなければなりません。詳細は、変数‘dirtrack-list’のドキュメント
を参照してください。Dirtrackモードを使用するには、Shellバッファーで‘M-x
dirtrack-mode’とタイプするか、‘shell-mode-hook’に‘dirtrack-mode’を追加し
ます(*note Hooks::を参照してください)。


File: emacs-ja.info,  Node: Shell Options,  Next: Terminal emulator,  Prev: Directory Tracking,  Up: Shell

38.7 Shellモードのオプション
============================

変数‘comint-scroll-to-bottom-on-input’が非‘nil’の場合、挿入およびyankコ
マンドは、挿入する前に選択されたウィンドウを、バッファーの最後までスクロ
ールします。デフォルトは‘nil’です。

   ‘comint-scroll-show-maximum-output’が非‘nil’の場合、ポイントが最後に
あるとき到着した出力は、可能な限り有用なテキストを表示するために、テキス
トの最後の行がウィンドウの一番下になるようなスクロールを試みます(これは
ほとんどの端末のスクロール動作を真似た動作です)。デフォルトは‘t’です。

   ‘comint-move-point-for-output’をセットすることにより、出力が到着した
ときにバッファーの最後にポイントをジャンプさせることができます — その前
にポイントがバッファーのどこにあろうと関係ありません。値が‘this’の場合、
選択されたウィンドウ内でポイントがジャンプします。値が‘all’の場合、
Comintバッファーを表示するすべてのウィンドウでポイントがジャンプします。
値が‘other’の場合、カレントバッファーを表示する、選択されていないすべて
のウィンドウでポイントがジャンプします。デフォルト値は‘nil’で、これはポ
イントが最後にジャンプしないことを意味します。

   ‘comint-prompt-read-only’をセットした場合、Comintバッファーのプロンプ
トは読み取り専用になります。

   変数‘comint-input-ignoredups’は、連続する同じ入力を入力ヒストリーに保
存するかを制御します。非‘nil’値は、入力が前の入力と同じ場合は省略するこ
とを意味します。デフォルトは‘nil’で、これは入力が前の入力と同じでも保存
することを意味します。

   ファイル名の補完をカスタマイズする3つの変数があります。変数
‘comint-completion-addsuffix’は、完全に補完されたファイル名またはディレ
クトリー名の最後にスペースまたはスラッシュを挿入するかを制御します(非
‘nil’は、スペースまたはスラッシュを挿入することを意味します)。
‘comint-completion-recexact’が非‘nil’の場合、通常のEmacs補完アルゴリズム
が1文字も追加できないようなときは、<TAB>で一番短い利用可能な補完を選択す
るよう指示します。‘comint-completion-autolist’が非‘nil’の場合、補完が完
全でないときは、利用可能なすべての候補をリストするよう指示します。

   コマンド補完は通常、実行可能ファイルだけを考慮します。
‘shell-completion-execonly’を‘nil’にセットした場合は、実行可能ファイル以
外も同様に考慮します。

   変数‘shell-completion-fignore’は、Shellモードで無視するファイル名の拡
張子のリストを指定します。デフォルトは‘nil’ですが、‘~’、‘#’、‘%’で終わる
ファイル名を無視するために‘("~" "#" "%")’をセットするユーザーもいます。
他のComintモードに関連するモードは、かわりに変数
‘comint-completion-fignore’を使用します。

   シェルコマンド補完の実装の詳細は、‘shell-dynamic-complete-command’関
数のlispドキュメントで見ることもできます。

   ‘pushd’の動作を設定することができます。‘shell-pushd-tohome’は、引数を
与えない場合に‘pushd’が‘cd’のように振る舞うかを制御します。
‘shell-pushd-dextract’は、数引数を与えたときローテートするのではなく
popするかを制御します。‘shell-pushd-dunique’は、ディレクトリースタックに
ディレクトリーがない場合だけ追加するかを制御します。もちろん選択する値は
背後のシェルに適合する必要があります。

   Comintモードは、環境変数‘TERM’の値を安全なデフォルト値にセットします
が、この値はいくつかの有用な機能を無効にします。たとえば、カラーがサポー
トされているかの判断に‘TERM’を使用するため、アプリケーションではカラーが
無効になっています。したがって、Emacsはオプション
‘comint-terminfo-terminal’を提供します。そのため、その端末の高度な機能を
利用するために、システムのterminfoデータベースにより提供される端末にセッ
トできます。


File: emacs-ja.info,  Node: Terminal emulator,  Next: Term Mode,  Prev: Shell Options,  Up: Shell

38.8 Emacsの端末エミュレーター
==============================

テキスト端末エミュレーターでサブシェルを実行するには、‘M-x term’を使用し
ます。これは‘*terminal*’という名前のバッファーを作成(または再利用)して、
キーボードを入力とするサブシェルを実行し、出力はそのバッファーになります
。

   端末エミュレーターは、2つの入力モードをもつTermモードを使用します。
“lineモード(line mode)”では、Termは基本的にShellモードのように振る舞いま
す(*note Shell Mode::を参照してください)。“charモード(char mode)”では、
文字は端末入力として直接サブシェルに送られます。唯一の例外は端末エスケー
プ文字で、デフォルトは‘C-c’です(*note Term Mode::を参照してください)。入
力をエコーするのはサブシェルの役目です。サブシェルからの端末出力は、バッ
ファーのポイントの後に送られます。

   (Emacsのような)いくつかのプログラムでは、端末スクリーンで詳細に外観を
制御する必要があります。これらのプログラムは特別な制御コードを送ることに
よりこれを行ないます。Termモードは、‘xterm’を含むほとんどの現代的な端末
で使用できる、ANSI標準のVT100スタイルのエスケープシーケンスを認識・処理
します(したがって、実際にEmacsのTermウィンドウ内でEmacsを実行することも
できます)。

   ‘term’フェイスは、端末エミュレーターのテキストのデフォルトの外観を指
定します(デフォルトは‘default’フェイスと同じ外観です)。端末の制御コード
がテキストの外観を変更するために使用される場合、これらは端末エミュレータ
ー内で、フェイス‘term-color-black’、‘term-color-red’、
‘term-color-green’、‘term-color-yellow’、‘term-color-blue’、
‘term-color-magenta’、‘term-color-cyan’、‘term-color-white’、
‘term-color-underline’、‘term-color-bold’で表示されます。*note Faces::を
参照してください。

   シリアルポートに接続されたデバイスと通信するために、Termモードを使う
こともできます。*note Serial Terminal::を参照してください。

   サブシェルをロードするために使用されるファイル名は、Shellモードと同じ
方法で決定されます。複数の端末エミュレーターを作成するには、Shellモード
と同じように、‘M-x rename-uniquely’を使って、バッファー‘*terminal*’を違
う名前にリネームします。

   Shellモードとは異なり、Termモードは入力を調べてカレントディレクトリー
を追跡することはしません。しかし、いくつかのシェルはカレントディレクトリ
ーをTermに告げることができます。これは‘bash’のバージョン1.15以降では自動
的に行なわれます。


File: emacs-ja.info,  Node: Term Mode,  Next: Remote Host,  Prev: Terminal emulator,  Up: Shell

38.9 Termモード
===============

Termモードでlineモードとcharモードを切り替えるには、以下のコマンドを使用
します:

‘C-c C-j’
     lineモードに切り替えます(‘term-line-mode’)。すでにlineモードのとき
     は何もしません。

‘C-c C-k’
     charモードに切り替えます(‘term-char-mode’)。すでにcharモードのとき
     は何もしません。

   以下のコマンドはcharモードだけで利用可能です:

‘C-c C-c’
     サブシェルに、リテラルの‘C-c’を送ります(‘term-interrupt-subjob’)。

‘C-c CHAR’
     これは通常のEmacsでの‘C-x CHAR’と等価です。たとえば‘C-c o’は、通常
     ‘C-x o’にグローバルにバインドされている‘other-window’を呼び出します
     。

   Termモードにはpage-at-a-time(1度に1ページ)機能があります。これが有効
な場合、出力の画面の最後で一時停止します。

‘C-c C-q’
     page-at-a-time機能を切り替えます(‘term-pager-toggle’)。このコマンド
     はlineモードとcharモードの両方で機能します。この機能が有効な場合、
     モードラインには単語‘page’が表示され、Termが1画面に収まらない出力を
     受け取ったときは、一時停止してモードラインに‘**MORE**’を表示します
     。<SPC>とタイプすると次の1画面分の出力を表示し、‘?’でオプションを見
     ることができます。このインターフェースは、‘more’プログラムと同様で
     す。


File: emacs-ja.info,  Node: Remote Host,  Next: Serial Terminal,  Prev: Term Mode,  Up: Shell

38.10 リモートホストのシェル
============================

Termウィンドウから、通常の端末から使うコマンド(たとえば‘ssh’、‘telnet’、
‘rlogin’)で、リモートコンピューターにログインすることができます。

   パスワードを尋ねるようなプログラムは、通常パスワードをエコーしないの
で、パスワードはバッファーにも表示されません。バッファーがcharモードの場
合、実際の端末で使用しているのと同じ動作になります。lineモードの場合、パ
スワードは一時的に表示されますが、リターンをタイプするとパスワードは消去
されます(これは自動的に行なわれます。特別なパスワード処理は行なっていま
せん)。

   別のマシンにログインしているときは、リモートログインコマンドのために
、環境変数‘TERM’をセットすることにより、端末タイプを指定する必要がありま
す(bashを使用している場合、リモートログインコマンドの前に、カンマで区切
らず値割り当てを記述することにより、これを行なうことができます)。端末タ
イプ‘ansi’または‘vt100’は、ほとんどのシステムで動作するでしょう。


File: emacs-ja.info,  Node: Serial Terminal,  Prev: Remote Host,  Up: Shell

38.11 シリアル端末
==================

コンピューターに、シリアルポートに接続されたデバイスがあるとき、‘M-x
serial-term’とタイプすることにより、デバイスと通信することができます。こ
のコマンドは新しいTermモードのバッファーのために、ポート番号、スピード、
スイッチを尋ねます。Emacsは、通常のTermモードの端末で行なうのと同じよう
に、このバッファーを通じてシリアルデバイスと通信します。

   シリアルポートのスピードはビット毎秒で計ります。もっとも一般的なスピ
ードは9600ビット毎秒です。モードラインをクリックすることにより、このスピ
ードを対話的に変更できます。

   シリアルポートはモードラインの‘8N1’をクリックしても設定できます。デフ
ォルトでは、シリアルポートは‘8N1’に設定されており、これは各バイトは8ビッ
トからなり、パリティービットチェックなし、ストップビットが1であることを
意味します。

   スピードや設定が間違っている場合、デバイスと通信できず、おそらくウィ
ンドウにはゴミが出力されるでしょう。


File: emacs-ja.info,  Node: Emacs Server,  Next: Printing,  Prev: Shell,  Up: Top

39 サーバーとしてのEmacsの使用
******************************

さまざまなプログラムが、特定のテキスト断片を編集するために、あなたが選択
したエディターを呼び出すことができます。たとえば、バージョンコントロール
システム(*note Version Control::を参照してください)は、バージョンコント
ロールログを入力するためのエディターを呼び出し、Unixの‘mail’ユーティリテ
ィーは送信メッセージの入力にエディターを呼び出します。慣例により、選択す
るエディターは、環境変数‘EDITOR’で指定されます。しかし‘EDITOR’を
‘emacs’にセットした場合、Emacsが呼び出されますが、これは便利な方法ではあ
りません — なぜなら新しいEmacsプロセスが開始されるからです。なぜこれが不
便かというと、新たなEmacsプロセスは、既存のEmacsプロセスのバッファー、コ
マンドヒストリー、その他の情報を共有しないからです。

   Emacsを“edit server(編集サーバー)”としてセットアップして、Emacsが外部
からの編集リクエストを“listen”し、それに応じて動作させることにより、この
問題を解決できます。Emacsサーバーを開始するにはさまざまな方法があります:

   • ‘M-x server-start’とタイプするか、initファイル(*note Init File::を
     参照してください)に式‘(server-start)’を記述して、既存のEmacsプロセ
     スでコマンド‘server-start’を実行します。既存のEmacsプロセスがサーバ
     ーになり、Emacsを終了すると、サーバーはそのEmacsプロセスとともに終
     了します。

   • コマンドラインオプション‘--daemon’のいずれか1つを使用して、Emacsを
     “daemon”として実行します。*note Initial Options::を参照してください
     。Emacsがこの方法で開始された場合、初期化の後に‘server-start’を呼び
     出して、初期フレームを開きません。その後クライアントからの編集リク
     エストをwaitします。

   • オペレーティングシステムがスタートアップ管理に‘systemd’を使用する場
     合、提供される“systemdユニットファイル(systemd unit file)”を使用し
     て、ログイン時に自動的にデーモンモードのEmacsを開始できます。これを
     アクティブにするには:
          systemctl --user enable emacs
     (Emacsが標準的な場所にインストールされていない場合は、
     ‘~/.config/systemd/user/’のような標準的なディレクトリーに
     ‘emacs.service’をコピーする必要があるかもしれません。)

   • 指定されたソケットに接続イベントが発生したとき、外部プロセスは
     Emacsサーバーを呼び出して、そのソケットを新たなEmacsサーバーのプロ
     セスに渡すことができます。このインスタンスは‘systemd’のソケット機能
     です。‘systemd’サービスはソケットを作成して、そのソケットへの接続を
     listenします。‘emacsclient’が最初にこれに接続したとき、
     ‘emacsclient’による接続のために、‘systemd’はEmacsサーバーを起動して
     、そのソケットを渡すことができます。‘emacsclient’が最初にこれに接続
     したとき、‘emacsclient’による接続のために、‘systemd’はEmacsサーバー
     を起動して、そのソケットを渡すことができます。この機能を使用するた
     めのセットアップは:

     ‘~/.config/systemd/user/emacs.socket’:
          [Socket]
          ListenStream=/path/to/.emacs.socket

          [Install]
          WantedBy=sockets.target

     (上述のファイル‘emacs.service’もインストールされていなければなりま
     せん。)

     パス‘ListenStream’は、Emacsが‘emacsclient’からの接続をlistenするパ
     スです。これは、あなたが選択するファイルです。

   Emacsサーバーを一度開始すると、‘emacsclient’というシェルコマンドを使
用してEmacsに接続して、ファイルをvisitするよう指示できます。環境変数
‘EDITOR’に‘emacsclient’をセットすれば、外部プログラムは編集のために既存
のEmacsプロセスを使用できます。(1)

   変数‘server-name’を使って、一意な“サーバー名”を与えることにより、同一
マシン上で複数のEmacsサーバーを実行することができます。たとえば‘M-x
set-variable <RET> server-name <RET> "foo" <RET>’は、サーバー名を‘foo’に
セットします。‘emacsclient’プログラムは、‘-s’オプションで、名前によりサ
ーバーを指定できます(*note emacsclient Options::を参照してください)。

   複数のEmacsデーモン(*note Initial Options::をい参照してください)を実
行したい場合、以下のようにデーモンごとにそれぞれ、独自のサーバー名を与え
ることができます:

       emacs --daemon=foo

   一意なサーバー名によりサーバーを定義した場合、他のEmacsインスタンスか
らそのサーバーに接続し、‘server-eval-at’関数を使用して、そのサーバーで
Lisp式を評価できます。たとえば‘(server-eval-at "foo" '(+ 1 2))’は、式‘(+
1 2)’をサーバー‘foo’で評価して、‘3’を返します(そのような名前のサーバーが
存在しない場合はエラーをシグナルします)。現在のところ、これは主に開発者
に有用な機能です。

* Menu:

* TCP Emacs server::         TCPソケットのlisten。
* Invoking emacsclient::     Emacsサーバーへの接続。
* emacsclient Options::      Emacsクライアントの開始オプション。

   ---------- Footnotes ----------

   (1) 別の環境変数を使うプログラムもいくつかあります。たとえば、TeXが
‘emacsclient’を使うようにするには、環境変数‘TEXEDIT’を‘emacsclient +%d
%s’にセットします。


File: emacs-ja.info,  Node: TCP Emacs server,  Next: Invoking emacsclient,  Up: Emacs Server

39.1 TCP Emacsサーバー
======================

Emacsサーバーは通常、接続にたいしてローカルのUnixドメインソケットを
listenします。 MS-Windowsのようないくつかのオペレーティングシステムは、
ローカルソケットをサポートしません。そのような場合、サーバーはかわりに
TCPソケットをlistenします。ローカルソケットがサポートされている場合でも
、サーバーにTCPソケットをlistenさせるほうが便利な場合があります(たとえば
リモートマシンからEmacsサーバーに接続する必要がある場合)。ローカルソケッ
トのかわりにTCPソケットをEmacsにlistenさせる場合は、‘server-use-tcp’に非
‘nil’をセットできます。これはOSがローカルソケットをサポートしない場合は
、デフォルトです。

   EmacsサーバーがTCPを使うように設定されている場合は、デフォルトでは
localhostインターフェイスのランダムなポートをlistenします。
‘server-host’と‘server-port’を使用して、これを他のインターフェイス、およ
び/または固定されたポートに変更できます。

   TCPソケットは、ファイルシステムのパーミッションの対象ではありません。
TCPソケットを通じて、誰がEmacsサーバーと通信できるか何らかの制御を得るに
は、‘emacsclient’プログラムがサーバーに認証キーを送信しなければなりませ
ん。このキーは通常、Emacsサーバーによりランダムに生成されます。これが推
奨されるモードです。

   必要なら、‘server-auth-key’変数をセットすることにより、認証キーに静的
な値をセットできます。このキーは、スペースを除くプリント可能な64文字の
ASCII文字(これは‘!’から‘~’、10進コードの33から126を意味します)から構成さ
れなければなりません。ランダムキーを得るために、‘M-x
server-generate-key’を使用できます。

   TCP Emacsサーバーを開始したとき、Emacsは‘emacsclient’がサーバーに接続
するために使用する、TCP情報を含む“サーバーファイル(server file)”を作成し
ます。デフォルトでは、これは‘~/.emacs.d/server/’です。アクセス権限(file
permission)をもつlocalソケットが存在しない場合は、このディレクトリーのパ
ーミッションにより、どのユーザーの‘emacsclient’プロセスがEmacsサーバーと
対話(talk)できるか判断されます。

   特定のserverファイルによりTCPサーバーに接続するよう‘emacsclient’に指
示するには、オプション‘-f’または‘--server-file’を使用するか、環境変数
‘EMACS_SERVER_FILE’をセットします(*note emacsclient Options::を参照)。デ
フォルトの‘server-auth-dir’は、相対ファイル名を解決するために使用するデ
ィレクトリーとして、‘emacsclient’内にハードコーディングされているため、
serverファイルにたいする絶対ファイル名が必要になります。


File: emacs-ja.info,  Node: Invoking emacsclient,  Next: emacsclient Options,  Prev: TCP Emacs server,  Up: Emacs Server

39.2 ‘emacsclient’の呼び出し
============================

‘emacsclient’プログラムを使う一番簡単な方法は、シェルコマンド
‘emacsclient FILE’を実行する方法です。ここでFILEはファイル名です。これは
Emacsサーバーに接続して、Emacsプロセスの既存のフレームの1つ — グラフィカ
ルなフレーム、またはテキスト端末のフレーム(*note Frames::を参照してくだ
さい) — でFILEをvisitするよう指示します。それから、そのフレームを選択し
て編集を開始できます。

   Emacsサーバーが存在しない場合、‘emacsclient’はエラーメッセージと共に
終了します(このハプニングによるエラー終了は、‘emacsclient’にたいして
‘--alternate-editor=\"\"’オプションを使用して回避できる。*note
emacsclient Options::を参照されたい)。Emacsプロセスに既存のフレームがな
い場合 — これはサーバーがデーモン(*note Emacs Server::を参照してください
)として開始されたときに発生し得ます — は、‘emacsclient’を呼び出した端末
でEmacsフレームをオープンします。

   オプション‘-c’でグラフィカルなディスプレー、‘-t’を使用しテキスト端末
で新しいフレームを開くように、‘emacsclient’に強制することもできます。
*note emacsclient Options::を参照してください。

   単一のテキスト端末で実行している場合、‘emacsclient’のシェルとEmacsサ
ーバーを、次の2つの方法で切り替えることができます。1つ目は、Emacsサーバ
ーと、別の仮想端末で‘emacsclient’を実行して、‘emacsclient’を呼び出した後
にEmacsサーバーの仮想端末に切り替える方法です。2つ目は、Emacsサーバー自
身からShellモード(*note Interactive Shell::を参照してください)、または
Termモード(*note Term Mode::を参照してください)を使って‘emacsclient’を呼
び出す方法です。‘emacsclient’は、Emacs配下のサブシェルのときだけブロック
するので、依然としてファイルの編集にEmacsを使用できます。

   EmacsサーバーでFILEの編集を終えたら、そのバッファーで‘C-x #’
(‘server-edit’)とタイプします。これはファイルを保存して、‘emacsclient’プ
ログラムに終了を告げるメッセージを送り返します。通常、‘EDITOR’を使うプロ
グラムは、何か他のことを行なう前にエディター — この場合は‘emacsclient’ —
の終了を待ちます。

   複数のファイル名を引数にして‘emacsclient’を呼び出すこともできます。
‘emacsclient FILE1 FILE2 ...’は、EmacsサーバーにFILE1、FILE2、...を
visitするよう指示します。EmacsはFILE1をvisitしているバッファーを選択して
、他のバッファーをバッファーリストの最後に隠します(*note Buffers::を参照
してください)。指定されたすべてのファイルを終了したら(たとえば各サーバー
バッファーで‘C-x #’をタイプしたら)、‘emacsclient’プログラムは終了します
。

   サーバーバッファーを終了すると、そのバッファーがサーバーバッファーを
作成する前から存在していたバッファーでないかぎり、そのバッファーもkillさ
れます。しかし‘server-kill-new-buffers’を‘nil’にセットした場合、別の基準
が使用されます。この場合、サーバーバッファーの終了は、ファイル名が正規表
現‘server-temp-file-regexp’にマッチするときは、バッファーをkillします。
これはある種の一時ファイルを区別するための仕組みです。

   各‘C-x #’は、さまざまなファイルを編集する、保留されている外部要求が他
にないかチェックして、次のそのようなファイルを選択します。サーバーバッフ
ァーに辿り着くのに、‘C-x #’だけを使わなければならない訳ではありません。
サーバーバッファーに手動で切り替えることもできます。しかし‘C-x #’は、
‘emacsclient’に終了したことを告げる方法なのです。

   変数‘server-window’の値をウィンドウやフレームにした場合、‘C-x #’は常
に次のサーバーバッファーを、そのウィンドウまたはそのフレームに表示します
。


File: emacs-ja.info,  Node: emacsclient Options,  Prev: Invoking emacsclient,  Up: Emacs Server

39.3 ‘emacsclient’のオプション
==============================

以下のようなオプション引数を‘emacsclient’プログラムに渡すことができます:

     emacsclient -c +12 FILE1 +4:3 FILE2

引数‘+LINE’および‘+LINE:COLUMN’は、その後に続くファイルの行番号、または
行番号と列番号を指定します。これらはEmacs自身に対するコマンドライン引数
と同じように機能します。 *note Action Arguments::を参照してください。

   その他の‘emacsclient’により認識されるオプション引数を以下にリストしま
す:

‘-a COMMAND’
‘--alternate-editor=COMMAND’
     ‘emacsclient’が、Emacsとの接続に失敗したとき実行するシェルコマンド
     を指定します。これはスクリプト内で‘emacsclient’を実行するとき便利で
     す。このコマンドには、\"like this\"のようにクォートされた引数が含ま
     れるかもしれません。現在のところ、クォートのエスケープはサポートさ
     れていません。

     特別な例外として、COMMANDが空文字列の場合、接続に失敗したら
     ‘emacsclient’は(‘emacs --daemon’のように)Emacsをデーモンモードで開
     始して、再度接続を試みます。

     環境変数‘ALTERNATE_EDITOR’は、‘-a’オプションと同じ効果をもちます。
     両方が指定された場合は、後者のオプションが優先されます。

‘-c’
‘--create-frame’
     既存のEmacsフレームを使うかわりに、新しいグラフィカルな“クライアン
     トフレーム(client frame)”を作成します。クライアントフレームでの、
     ‘C-x C-c’の特別な振る舞いについては、以下を参照してください。(Xサー
     バーに接続できない等で)新たにグラフィカルなフレームを作成しない場合
     、あたかも‘-t’オプションが指定されたかのように、テキスト端末でクラ
     イアントフレームの作成を試みます。

     MS-Windowsでは、単一のEmacsセッションがグラフィカルなフレームとテキ
     スト端末のフレームの両方を表示することはできず、複数のテキスト端末
     のフレームを表示することもできません。したがってEmacsサーバーがテキ
     スト端末で実行されている場合、‘-c’オプションは‘-t’オプションのよう
     に、サーバーのカレントテキスト端末で新たなフレームを作成します。
     *note Windows Startup::を参照してください。

     ‘-c’オプションを指定するときに、ファイル名の引数を省略した場合、新
     しいフレームはデフォルトで‘*scratch*’バッファーを表示します。変数
     ‘initial-buffer-choice’でこの振る舞いをカスタマイズできます(*note
     Entering Emacs::を参照してください)。

‘-F ALIST’
‘--frame-parameters=ALIST’
     新たに作成される、グラフィカルなフレームのパラメーターをセットしま
     す(*note Frame Parameters::を参照してください)。

‘-d DISPLAY’
‘--display=DISPLAY’
     与えられたファイルを、(複数のXディスプレーがあることを想定して)Xデ
     ィスプレーDISPLAYで開くようEmacsに指示します。

‘-e’
‘--eval’
     ファイルをvisitするかわりに、Emacs Lispコードを評価するようEmacsに
     指示します。このオプションが与えられた場合、‘emacsclient’は引数を
     visitするファイルではなく、式のリストと解釈します。

‘-f SERVER-FILE’
‘--server-file=SERVER-FILE’
     TCPを通じてEmacsサーバーに接続するためのserverファイル(*note TCP
     Emacs server::を参照)を指定します。かわりにserverファイルを示すよう
     に、環境変数‘EMACS_SERVER_FILE’をセットできます(コマンドラインオプ
     ションは、環境変数をオーバーライドする)。

     Emacsサーバーは通常は接続にたいしてローカルソケットをlistenしますが
     、TCPを通じた接続もサポートします。TCPによりEmacsサーバーに接続する
     ためには、‘emacsclient’がEmacsサーバーへの接続に関する詳細を含む
     “serverファイル(server file)”を読み込む必要があります。このオプショ
     ンでserverファイル名を指定します。これは‘~/.emacs.d/server’からの相
     対ファイル名か、絶対ファイル名です。*note TCP Emacs server::を参照
     してください。

‘-n’
‘--no-wait’
     すべてのサーバーバッファーが終了するのを待つかわりに、
     ‘emacsclient’が即座に終了するようにします。Emacsのサーバーバッファ
     ーで編集したいときに、このオプションを指定します。‘C-x #’をタイプし
     ても、これらはkillされません。

‘--parent-id ID’
     XEmbedプロトコルを通じて、IDがIDの親Xウィンドウでクライアントフレー
     ムとして、‘emacsclient’フレームをオープンします。現在のところ、これ
     は主に開発者に有用なオプションです。

‘-q’
‘--quiet’
     ‘emacsclient’がEmacsを待つメッセージ、またはリモートのサーバーソケ
     ットに接続するメッセージを表示しないようにします。

‘-u’
‘--suppress-output’
     サーバーからリターンされた結果を、‘emacsclient’が表示しないようにし
     ます。これは主に‘-e’と併用し、評価が結果ではなく副作用を目的として
     いるとき有用です。

‘-s SERVER-NAME’
‘--socket-name=SERVER-NAME’
     名前がSERVER-NAMEのEmacsサーバーに接続します。サーバー名は、Emacsサ
     ーバー上の変数‘server-name’により与えられます。このオプションが省略
     された場合、‘emacsclient’は見つかったサーバーに接続します(このオプ
     ションはMS-Windowsではサポートされません)。

‘-t’
‘--tty’
‘-nw’
     既存のEmacsフレームを使うかわりに、カレントテキスト端末に新たなクラ
     イアントフレームを作成します。これはテキスト端末のフレームを作成す
     る点を除き、上記で説明した‘-c’と同じように振る舞います(*note
     Non-Window Terminals::を参照してください)。

     MS-Windowsでは、Emacsサーバーがグラフィカルなディスプレーを使ってい
     る場合は‘-c’のように振る舞いますが、Emacsサーバーがテキスト端末で実
     行されている場合は、カレントテキスト端末に新たなフレームを作成しま
     す。

‘-T TRAMP-PREFIX’
‘--tramp-prefix=TRAMP-PREFIX’
     EmacsがTRAMP (*note The Tramp Manual: (tramp)Top.を参照)を使用して
     リモートマシンにファイルを配すとき(*note Remote Files::を参照)、フ
     ァイル名に追加されるプレフィクスをセットします。これは主に、TCP上で
     のEmacsサーバーの使用と併用すると有用です(*note TCP Emacs server::を
     参照)。listenするポートをsshフォワードして、リモートマシンで
     SERVER-FILEを利用可能にすることにより、リモートマシン上のプログラム
     は‘EDITOR’、および同種の環境変数にたいする値に‘emacsclient’を使用で
     きますが、リモートマシンからEmacsサーバーと通信するかわりに、そのフ
     ァイルはTRAMPを使用してローカルのEmacsセッションによりvisitされます
     。

     環境変数‘EMACSCLIENT_TRAMP’は、‘-T’オプションと同じ効果をもちます。
     両方が指定された場合は、コマンドラインのオプションが優先されます。

     たとえば２つのホスト‘local’および‘remote’があり、ローカルのEmacsは
     TCPポート12345をlistenしているとします。さらに‘/home’が共有ファイル
     システム上にあるとすると、serverファイル
     ‘~/.emacs.d/server/server’は両方のホストから読み込めることになりま
     す。

          local$ ssh -R12345:localhost:12345 remote
          remote$ export EDITOR="emacsclient \
                  --server-file=server \
                  --tramp=/ssh:remote:"
          remote$ $EDITOR /tmp/foo.txt #Should open in local emacs.

   オプション‘-c’または‘-t’で作成された、グラフィカルなフレームおよびテ
キスト端末のフレームは、“クライアントフレーム(client frames)”とみなされ
ます。クライアントフレームから作成した新たなフレームも、クライアントフレ
ームとみなされます。クライアントフレームで‘C-x C-c’
(‘save-buffers-kill-terminal’)とタイプした場合、それが通常行なうような
Emacsセッションのkill(*note Exiting::を参照してください)は行なわれません
。かわりにEmacsはクライアントフレームを削除します。さらに、制御を取り戻
すために待っている‘emacsclient’をクライアントフレームがもつ場合(たとえば
‘-n’オプションを与えなかった場合)、Emacsは同じくクライアントの他のすべて
のフレームを削除し、(それらすべてにたいして‘C-x #’をタイプしたかのように
)クライアントのサーバーバッファーが終了したとマークします。クライアント
フレームが削除された後、残ったフレームが存在しない場合、Emacsセッション
は終了します。

   例外として、Emacsがデーモンとして開始された場合、すべてのフレームはク
ライアントフレームとみなされ、‘C-x C-c’がEmacsをkillすることはありません
。デーモンセッションを終了するには、‘M-x kill-emacs’とタイプします。

   ‘-t’と‘-n’は、矛盾するオプションであることに注意してください。‘-t’は
カレントテキスト端末に新たにクライアントフレームを作成して制御することを
指示し、‘-n’はテキスト端末で制御を行なわないことを指示するからです。両方
のオプションを与えた場合、‘-t’の効果は打ち消されて、Emacsは新たにフレー
ムを作成せず、既存のフレームで指定されたファイルをvisitします。


File: emacs-ja.info,  Node: Printing,  Next: Sorting,  Prev: Emacs Server,  Up: Top

40 ハードコピーの印刷
*********************

Emacsは、バッファーの全体、または一部のハードコピーを印刷するコマンドを
提供します。以下で詳しく述べるとおり、直接印刷コマンドを呼び出したり、メ
ニューバーの‘File’メニューを使うことができます。

   このセクションで説明するコマンドとは別に、Dired(*note Operating on
Files::を参照してください)からハードコピーを印刷したり、ダイアリー(*note
Displaying the Diary::を参照してください)から印刷することもできます。コ
マンド‘M-x htmlfontify-buffer’で、EmacsバッファーをHTMLに“印刷”すること
もできます。これはEmacsのフェイスをCSSベースのマークアップに置換して、カ
レントバッファーをHTMLに変換します。さらにOrgモード(*note Org Mode::を参
照してください)では、OrgファイルをPDFのような様々なフォーマットに印刷で
きます。

‘M-x print-buffer’
     ファイル名を含むページヘッダーとともに、カレントバッファーのハード
     コピーを印刷します。
‘M-x lpr-buffer’
     ページヘッダーなしで、カレントバッファーのハードコピーを印刷します
     。
‘M-x print-region’
     ‘print-buffer’と同様ですが、カレントリージョンだけを印刷します。
‘M-x lpr-region’
     ‘lpr-buffer’と同様ですが、カレントリージョンだけを印刷します。

   ほとんどのオペレーティングシステムでは、上記のハードコピーコマンドは
、‘lpr’プログラムを呼び出して、印刷のためにファイルをサブミットします。
印刷プログラムを変更するには、変数‘lpr-command’をカスタマイズします。追
加のスイッチを指定して、印刷プログラムにに与えるには、リスト変数
‘lpr-switches’をカスタマイズします。この変数の値はオプション文字列のリス
トで、それぞれが‘-’で始まります(たとえばオプション文字列‘"-w80"’は1行に
80列を指定します)。デフォルトは、空リスト‘nil’です。

   使用するプリンターを指定するには、変数‘printer-name’をセットします。
デフォルトは‘nil’で、これはデフォルトプリンターを指定します。これにプリ
ンター名(文字列)をセットした場合、その名前は‘-P’スイッチとともに‘lpr’に
渡されます。‘lpr’コマンドを使用しない場合は、スイッチを
‘lpr-printer-switch’で指定する必要があります。

   同様に変数‘lpr-headers-switches’は、ページヘッダーを作成するために使
用する追加のスイッチを指定します。変数‘lpr-add-switches’は、印刷プログラ
ムに‘-T’および‘-J’オプション(‘lpr’向きのオプションです)を渡すかどうかを
制御します。‘nil’は、これらを追加しないことを意味します(印刷プログラムが
‘lpr’)互換でない場合は、この値を使用するべきです)。

* Menu:

* PostScript::               バッファーまたはリージョンを、PostScriptとして印刷する。
* PostScript Variables::     PostScript印刷コマンドのカスタマイズ。
* Printing Package::         オプションの上級向け印刷インターフェース。


File: emacs-ja.info,  Node: PostScript,  Next: PostScript Variables,  Up: Printing

40.1 PostScriptのハードコピー
=============================

これらのコマンドはバッファーの内容をPostScriptに変換して、それを印刷また
は別のEmacsバッファーに出力します。

‘M-x ps-print-buffer’
     PostScript形式で、カレントバッファーのハードコピーを印刷します。
‘M-x ps-print-region’
     PostScript形式で、カレントリージョンのハードコピーを印刷します。
‘M-x ps-print-buffer-with-faces’
     PostScript形式で、カレントバッファーのハードコピーを印刷し、テキス
     トで使用されているフェイスはPostScript機能により表示します。
‘M-x ps-print-region-with-faces’
     PostScript形式で、カレントリージョンのハードコピーを印刷し、テキス
     トで使用されているフェイスで表示します。
‘M-x ps-spool-buffer’
     カレントバッファーのテキストにたいするPostScriptイメージを生成およ
     びスプールします。
‘M-x ps-spool-region’
     カレントリージョンにたいするPostScriptイメージを生成およびスプール
     します。
‘M-x ps-spool-buffer-with-faces’
     カレントバッファーにたいするPostScriptイメージを生成およびスプール
     し、使用されているフェイスで表示します。
‘M-x ps-spool-region-with-faces’
     カレントリージョンにたいするPostScriptイメージを生成およびスプール
     し、使用されているフェイスで表示します。
‘M-x ps-despool’
     Send the spooled PostScript to the printer.
‘M-x handwrite’
     カレントバッファーにたいして、手書きされたようなPostScriptを生成・
     印刷します。

   ‘ps-print-buffer’および‘ps-print-region’コマンドは、バッファーの内容
をPostScript形式で印刷します。一方はバッファー全体を印刷し、もう一方はリ
ージョンだけを印刷します。コマンド‘ps-print-buffer-with-faces’および
‘ps-print-region-with-faces’も同様に振る舞いますが、バッファーテキストの
フェイス(フォントとカラー)を表示するためにPostScript機能を使用します。

   プレフィクス引数(‘C-u’)を使用した場合、これらのコマンドは対話的にユー
ザーにファイル名の入力を求め、PostScriptイメージをプリンターに送るかわり
に、そのファイルに保存します。

   ‘print’のかわりに‘spool’が名前につくコマンドは、PostScript出力をプリ
ンターに送るかわりに、Emacsバッファーに出力することを意味します。

   コマンド‘ps-despool’を使用して、スプールされたイメージをプリンターに
送ります。このコマンドは‘-spool-’コマンド(上記コマンド参照)により生成さ
れたPostScriptをプリンターに送ります。プレフィクス引数(‘C-u’)を指定した
場合は、ファイル名の入力を求め、スプールされたPostScriptイメージをプリン
ターに送るかわりに、そのファイルに保存します。

   ‘M-x handwrite’はもっと他愛ない機能です。これはカレントバッファーの
PostScript表現を、草書体の手書きドキュメントのように生成します。これはグ
ループ‘handwrite’でカスタマイズできます。この関数はISO 8859-1文字だけサ
ポートします。


File: emacs-ja.info,  Node: PostScript Variables,  Next: Printing Package,  Prev: PostScript,  Up: Printing

40.2 PostScriptハードコピーにたいする変数
=========================================

すべてのPostScriptハードコピーコマンドは、どのように出力を印刷するかの指
定に、変数‘ps-lpr-command’と‘ps-lpr-switches’を使用します。
‘ps-lpr-command’は実行するコマンド名、‘ps-lpr-switches’は使用するコマン
ドラインオプション、‘ps-printer-name’はプリンターを指定します。最初の2つ
の変数をセットしない場合、変数の初期値を‘lpr-command’と‘lpr-switches’か
ら取得します。‘ps-printer-name’が‘nil’の場合、‘printer-name’が使用されま
す。

   変数‘ps-print-header’は、これらのコマンドが各ページにヘッダー行を追加
するかを制御します。これを‘nil’にセットするとヘッダーはオフになります。

   プリンターがカラーをサポートしない場合は、‘ps-print-color-p’を‘nil’に
セットして、カラー処理をオフにするべきです。デフォルトでは、ディスプレー
がカラーをサポートしていれば、Emacsはカラー情報をもったハードコピー出力
を生成します。モノクロプリンターでは、カラーはグレーの濃淡でエミュレート
されます。スクリーンカラーがグレーの濃淡だけしか使用していなくても、これ
は読みにくい出力を生成するかもしれません。

   かわりに‘ps-print-color-p’を‘black-white’にセットして、モノクロプリン
ターで印刷する色をセットできます。

   デフォルトでは、変数‘ps-use-face-background’が非‘nil’でなければ、
PostScript印刷はフェイスのバックグラウンドカラーは無視します。これは望ま
しくないゼブラストライプや、バックグラウンドイメージとテキストの干渉を避
けるためです。

   変数‘ps-paper-type’は、フォーマットする用紙サイズを指定します。妥当な
値には‘a4’、‘a3’、‘a4small’、‘b4’、‘b5’、‘executive’、‘ledger’、
‘legal’、‘letter’、‘letter-small’、‘statement’、‘tabloid’が含まれます。
デフォルトは‘letter’です。変数‘ps-page-dimensions-database’を変更するこ
とにより、追加の用紙サイズを定義できます。

   変数‘ps-landscape-mode’は、ページの印刷向きを指定します。デフォルトは
‘nil’で、これは縦向き印刷モード(portrait mode)を意味します。非‘nil’値は
横向き印刷モード(landscape mode)を指定します。

   変数は列番号を指定します。この変数は横向きモードと縦向きモードの両方
で効果をもちます。デフォルトは1です。

   変数‘ps-font-family’は、通常のテキストを印刷するために使用するフォン
トファミリーを指定します。妥当な値には、‘Courier’、‘Helvetica’、
‘NewCenturySchlbk’、‘Palatino’、‘Times’が含まれます。変数
‘ps-font-size’は、通常のテキストのためのフォントサイズを指定し、デフォル
トは8.5ポイントです。‘ps-font-size’の値には、2つの浮動小数点によるコンス
でも指定できます。その場合、1つは縦向き印刷モード、もう一方は横向き印刷
モードでの指定です。

   Emacsは、通常のPostScriptプリンターより多くのスクリプトと文字をサポー
トします。したがってバッファーのいくつかの文字は、プリンターに組み込まれ
たフォントを使って印刷できないかもしれません。プリンターが提供するフォン
トをGNU Intlfontsパッケージのフォントで増強したり、EmacsにIntlfontsフォ
ントだけを使うように命令できます。変数‘ps-multibyte-buffer’がこれを制御
します。デフォルト値の‘nil’は、ASCIIおよびLatin-1文字を印刷するのに適し
ています。‘non-latin-printer’は、プリンターにASCII、Latin-1、Japanese、
Korean文字にたいするフォントが組み込まれている場合の値です。_すべて_の文
字にたいして使用される、IntlfontsパッケージのBDFフォントのための値が
‘bdf-font’です。最後に値‘bdf-font-except-latin’は、ASCIIおよびLatin-1文
字にたいしては組み込みフォントを使用し、それ以外の文字にたいしては
IntlfontsのBDFフォントを使用するよう指示します。

   BDFフォントを使えるようにするには、それをどこで見つけることができるか
を、Emacsが知る必要があります。変数‘bdf-directory-list’は、Emacsがこれら
のフォントを探すべきディレクトリーのリストを保持します。デフォルト値には
、1つのディレクトリー‘/usr/local/share/emacs/fonts/bdf’が含まれます。

   これらのコマンドに対する、その他多くのカスタマイズ変数は、Lispファイ
ル‘ps-print.el’および‘ps-mule.el’で定義・説明されています。


File: emacs-ja.info,  Node: Printing Package,  Prev: PostScript Variables,  Up: Printing

40.3 印刷のためのパッケージ
===========================

ハードコピーを印刷するためのEmacsの基本的な機能は、Printingパッケージを
使って拡張できます。これは何を印刷するかの選択、印刷前のPostScriptファイ
ルのプレビュー、プリントヘッダーなどのさまざまな印刷オプションの設定、横
向きモードや縦向きモード、duplexモードにたいする使いやすいインターフェー
スを提供します。GNU/LinuxシステムまたはUnixシステムでは、Printingパッケ
ージは、GhostScriptプログラムの一部として配布される、‘gs’および‘gv’ユー
ティリティーに依存しています。MS-Windowsでは、Ghostscriptのポート版の
‘gstools’が使用されます。

   Printingパッケージを使用するには、initファイル(*note Init File::を参
照してください)に‘(require 'printing)’を追加して、その後に
‘(pr-update-menus)’と記述します。この関数はメニューバーの通常の印刷コマ
ンドを、さまざまな印刷オプションを含む‘Printing’サブメニューに置き換えま
す。‘M-x pr-interface <RET>’とタイプすることもできます。これはカスタマイ
ズバッファーに似た‘*Printing Interface*’バッファーを作成し、そこで印刷オ
プションをセットできます。何をどのようにして印刷するかセットした後、
‘Print’ボタン(それを‘mouse-2’でクリックするか、その上にポイントを移動し
て<RET>をタイプします)で印刷ジョブを開始します。さまざまなオプションにつ
いての詳細は、‘Interface Help’ボタンを使用してください。


File: emacs-ja.info,  Node: Sorting,  Next: Picture Mode,  Prev: Printing,  Up: Top

41 テキストのソート
*******************

Emacsは、バッファーのテキストをソートするためのコマンドをいくつか提供し
ています。これらはすべて、リージョンの内容にたいして処理を行ないます。こ
れらのコマンドはリージョンのテキストを、多数の“ソートレコード(sort
records)”に分割し、各レコードを“ソートキー(sort key)”で識別した後、ソー
トキーにより決定される順序にレコードを並び替えます。レコードは並び替えら
れ、レコードのキーはアルファベット順、または数値ソートでは数値順になりま
す。アルファベット順のソートでは、ASCII文字順にしたがい、‘A’から‘Z’のす
べての大文字は、小文字の‘a’の前になります。(しかし、以下で説明する
‘sort-fold-case’はこれを変更する)。

   種々のソートコマンドは、テキストをどのようにソートレコードに分割する
か、そして各レコードのどの部分がソートキーとして使用されるかという点で異
なります。ほとんどのコマンドは行ごとにソートレコードを分割しますが、ソー
トレコードとしてパラグラフやページを使うコマンドもあります。ほとんどのソ
ートコマンドは、ソートレコード全体をソートキーとして使用しますが、レコー
ドの一部をソートキーとして使用するものもあります。

‘M-x sort-lines’
     リージョンを行に分割して、行のテキスト全体を比較してソートします。
     数引数は降順でソートすることを意味します。

‘M-x sort-paragraphs’
     リージョンをパラグラフに分割して、パラグラフのテキスト全体(先頭の空
     行は除く)を比較してソートします。数引数は降順にソートすることを意味
     します。

‘M-x sort-pages’
     リージョンをページに分割して、ページのテキスト全体(先頭の空行は除く
     )を比較してソートします。数引数は降順にソートすることを意味します。

‘M-x sort-fields’
     リージョンを行に分割して、各行のあるフィールドの内容を比較すること
     によりソートします。フィールドは空白で区切ることにより定義されるの
     で、ある行の最初の連続する非空白文字がフィールド1を構成し、2番目の
     そのような文字構成がフィールド2、...となります。

     どのフィールドでソートするかは数引数で指定します。1はフィールド1、
     2はフィールド2、...となります。デフォルトは1です。負の引数はフィー
     ルドを左からではなく右から数えることを意味します。したがって、-1は
     最後のフィールドでソートするという意味です。ソートされるフィールド
     の内容が同じ行が複数存在する場合、バッファーの元の並び順が維持され
     ます。

‘M-x sort-numeric-fields’
     ‘M-x sort-fields’と同様ですが、各行の指定されたフィールドを整数に変
     換して、その数字を比較します。テキストとして比較したとき‘10’は‘2’の
     前になりますが、数字として比較すると‘2’の後になります。デフォルトで
     は、数字は‘sort-numeric-base’により解釈されますが、‘0x’または‘0’で
     始まる数字は16進および8進で解釈されます。

‘M-x sort-columns’
     ‘M-x sort-fields’と同様ですが、各行で比較に使用されるテキストは固定
     長の列範囲です。プレフィクス引数を指定した場合は、逆順でソートしま
     す。このコマンドの詳細は以下を参照してください。

‘M-x reverse-region’
     リージョンの行を逆順にソートします。フィールドでソートするコマンド
     は降順でソートする機能がないので、フィールドまたは列で降順にソート
     できるのは便利です。

   たとえば、以下のようなバッファー内容のとき:

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

バッファー全体に‘M-x sort-lines’を適用すると以下のようになります:

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

大文字の‘O’はすべての小文字の前にソートされます。かわりに‘C-u 2 M-x
sort-fields’を使用すると、以下が得られます:

     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

ここで、ソートキーは‘Emacs’、‘If’、‘buffer’、‘systems’、‘the’です。

   ‘M-x sort-columns’は説明が必要でしょう。ある列にポイントを配し、別の
列をマークして、ソート列を指定します。ソートしたいテキストの最初の行の先
頭にポイントまたはマークを配すことはできないので、このコマンドは特殊な
“リージョン”の定義を使用します。ポイントがある行はすべてリージョンの一部
と判断されます。マークがある行もすべてリージョンの一部と判断されます。同
様にその間にあるすべての行もリージョンの一部となります。

   たとえば、10列目から15列目までの情報でテーブルをソートするには、テー
ブルの最初の行の10列目にマークを置き、最後の行の15列目にポイントを置いて
、‘sort-columns’を実行します。最初の行の15列目にマークを置き、最後の行の
10列目にポイントを置いても、同じように実行できます。

   これはポイントとマークで指定された矩形領域をソートすると考えることが
できます。1つ違うのは、各行の矩形領域の左右にあるテキストも、矩形領域内
のテキストとともに移動するという点です。*note Rectangles::を参照してくだ
さい。

   ‘sort-fold-case’が非‘nil’の場合、多くのソートコマンドは比較時の大文字
小文字の違いを無視します。


File: emacs-ja.info,  Node: Picture Mode,  Next: Editing Binary Files,  Prev: Sorting,  Up: Top

42 ピクチャーの編集
*******************

テキスト文字で作られたピクチャー(たとえばプログラムのコメントにあるよう
な、レジスターをフィールドに分割したピクチャーなど)を編集するには、コマ
ンド‘M-x picture-mode’を使用してPictureモードに入ります。

   Pictureモードでは、編集はテキストの“quarter-plane(1/4平面)”モデルにも
とづき、テキスト文字は、右方および下方に無限に広がる領域に点在します。こ
のモデルには、行の終端という概念は存在しません。せいぜい言えるのは、その
行の空白でない最後の文字がどこにあるかぐらいです。

   もちろん、実際にはEmacsはテキストを文字シーケンスとして考え、行は終端
をもちます。しかしPictureモードは、もっともよく使われるコマンドを、テキ
ストのquarter-planeモデルをシミュレートする変種に置き換えます。これらの
コマンドはスペースの挿入、またはタブをスペースに置き換えることにより、こ
れを行ないます。

   Emacsのほとんどの基本的な編集コマンドは、本質的には同等なことを
quarter-planeの方法で行なうように、Pictureモードにより再定義されます。そ
れに加えてPictureモードは、‘C-c’プレフィクスで始まる、特別なピクチャー編
集コマンドを実行する、さまざまなキーを定義します。

   これらのキーのうち特に重要なのは‘C-c C-c’です。ピクチャーが、通常は他
のメジャーモードで編集する、大きなファイルの一部ということもあります。
Pictureモードは以前のメジャーモードを記録するので、後で‘C-c C-c’
(‘picture-mode-exit’)コマンドでそのモードに戻ることができます。‘C-c
C-c’は数引数を与えなければ、行末のスペースの削除も行ないます。

   Pictureモードの特別なコマンドのすべては、(‘picture’ライブラリーがロー
ドされていれば)他のモードでも機能しますが、Pictureモード以外ではキーにバ
インドされません。以下の説明では、“1列”移動...のような言い方をしますが、
通常の同等なコマンドと同じように、Pictureモードのコマンドは数引数を扱う
ことができます。

   Pictureモードをオンにすることにより、フック‘picture-mode-hook’が実行
されます。Pictureモードにたいする追加の拡張は、‘artist.el’で見ることがで
きます。

* Menu:

* Basic Picture::            Pictureモードの基本概念と簡単なコマンド。
* Insert in Picture::        自己挿入文字の後のカーソル移動方向の制御。
* Tabs in Picture::          タブストップとインデントにたいするさまざまな機能。
* Rectangles in Picture::    矩形領域のクリアーと重ね合わせ。


File: emacs-ja.info,  Node: Basic Picture,  Next: Insert in Picture,  Up: Picture Mode

42.1 Pictureモードでの基本的な編集
==================================

ほとんどのキーは、Pictureモードでも通常と同じことを、quarter-planeスタイ
ルで行ないます。たとえば‘C-f’は、‘picture-forward-column’を実行するよう
にリバインドされます。これはポイントを1列右に移動します。必要ならスペー
スを挿入するので実際の行末は関係ありません。‘C-b’は、
‘picture-backward-column’を実行するようにリバインドされます。必要ならタ
ブを複数のスペースに変換して、常に1列ポイントを左に移動します。‘C-n’と
‘C-p’は、‘picture-move-down’と‘picture-move-up’を実行するようにリバイン
ドされ、どちらもポイントが同じ列に留まるように、必要に応じてスペースの挿
入とタブの変換を行ないます。‘C-e’は、‘picture-end-of-line’を実行します。
これは、その行の最後の非空白文字の後に移動します。‘C-a’は、
‘picture-beginning-of-line’を実行します(スクリーンモデルの選択は行の開始
に影響を与えません。このコマンドが行なう追加事項は、カレントピクチャー列
を0に更新することです)。

   テキストの挿入は、Overwriteモードを通じてquarter-planeモデルに適合さ
れます (*note Minor Modes::を参照してください)。 自己挿入文字は既存のテ
キストを右にずらすのではなく、列ごとに既存のテキストを置き換えます。
<RET>は‘picture-newline’を実行し、これは単に次の行の先頭に移動するので、
新しいテキストでその行を置き換えることができます。

   Pictureモードでは、通常は削除やkillを行なうコマンドは、かわりにテキス
トを消去(スペースで置き換え)します。<DEL>
(‘picture-backward-clear-column’)は、前の文字を削除するのではなく、スペ
ースで置き換えます。これはポイントを後方に移動します。‘C-d’
(‘picture-clear-column’)は、次の文字をスペースで置き換えますが、ポイント
は移動しません(文字をクリアーして前方に移動したいときは<SPC>を使用します
)。‘C-k’ (‘picture-clear-line’)は、実際に行の内容をkillしますが、バッフ
ァーから改行は削除しません。

   実際に挿入を行なうには、特別なコマンドを使わなければなりません。‘C-o’
(‘picture-open-line’)は、カレント行の後に空行を作成します。行の分割はし
ません。Pictureモードでも‘C-M-o’ (‘split-line’)は意味があるので、変更さ
れていません。‘C-j’ (‘picture-duplicate-line’)は、カレント行の下に同じ内
容の行を挿入します。

   Pictureモードで実際の削除を行なうには、‘C-w’、‘C-c C-d’(これは他のモ
ードでは‘C-d’にバインドされている‘delete-char’にバインドされています)、
またはピクチャー矩形コマンドの1つを使用します(*note Rectangles in
Picture::を参照してください)。


File: emacs-ja.info,  Node: Insert in Picture,  Next: Tabs in Picture,  Prev: Basic Picture,  Up: Picture Mode

42.2 挿入後の移動の制御
=======================

Pictureモードでは、自己挿入文字(self-inserting characters)は上書きとポイ
ント移動を行なうので、ポイントを移動する方法に、本質的に制限はありません
。ポイントは通常右に移動しますが、自己挿入文字の後に移動する方向は、直行
方向と対角方向の8つのうちから任意の方向を指定できます。これはバッファー
に線を描くとき便利です。

‘C-c <’
‘C-c <LEFT>’
     挿入の後、左に移動します(‘picture-movement-left’)。
‘C-c >’
‘C-c <RIGHT>’
     挿入の後、右に移動します(‘picture-movement-right’)。
‘C-c ^’
‘C-c <UP>’
     挿入の後、上に移動します(‘picture-movement-up’)。
‘C-c .’
‘C-c <DOWN>’
     挿入の後、下に移動します(‘picture-movement-down’)。
‘C-c `’
‘C-c <Home>’
     挿入の後、左上(“北西”)に移動します(‘picture-movement-nw’)。
‘C-c '’
‘C-c <PageUp>’
‘C-c <prior>’
     挿入の後、右上(“北東”)に移動します(‘picture-movement-ne’)。
‘C-c /’
‘C-c <End>’
     挿入の後、左下(“南西”)に移動します(‘picture-movement-sw’)。
‘C-c \’
‘C-c <PageDown>’
‘C-c <next>’
     挿入の後、右下(“南東”)に移動します(‘picture-movement-se’)。

   カレントPicture挿入方向にもとづき移動を行なうコマンドは2つです。1つは
コマンド‘C-c C-f’ (‘picture-motion’)で、その時点で挿入後に移動すると定め
られた方向と同じ方向に移動するのが‘C-c C-f’ (‘picture-motion’)で、逆方向
へは‘C-c C-b’ (‘picture-motion-reverse’)です。


File: emacs-ja.info,  Node: Tabs in Picture,  Next: Rectangles in Picture,  Prev: Insert in Picture,  Up: Picture Mode

42.3 Pictureモードでのタブ
==========================

Pictureモードでは、タブのような動作が2つ提供されます。コンテキストベース
のタブ動作には、‘M-<TAB>’ (‘picture-tab-search’)を使用します。引数を与え
ないと、前の空でない行で、空白の後の次の“意味をもつ”文字の下にポイントを
移動します。ここで“次”とは、“開始した位置から水平方向に大な位置”という意
味です。‘C-u M-<TAB>’のようにプレフィックス引数を指定した場合、このコマ
ンドはカレント行で次の意味のある文字に移動します。‘M-<TAB>’はテキストを
変更せず、ポイントだけを移動します。“意味のある”文字は変数
‘picture-tab-chars’により定義され、これは一連の文字で定義されます。この
変数の構文は正規表現での‘[...]’の内側で使用される構文と似ていますが、
‘[’と‘]’はありません。デフォルト値は‘"!-~"’です。

   <TAB>は‘picture-tab’を実行し、これはカレントのタブストップの設定にも
とづき動作します。Pictureモードでは‘tab-to-tab-stop’と等価です。通常はポ
イントを移動するだけですが、数引数を指定した場合は、移動先までのテキスト
をクリアーします。

   コンテキストベースとタブストップベースのタブ動作形式は、‘C-c <TAB>’
(‘picture-set-tab-stops’)で合わせることができます。このコマンドは、カレ
ント行にたいして、‘M-<TAB>’が意味をもつと判断するであろう位置に、タブス
トップをセットします。このコマンドの使い方としては、<TAB>と合わせて、コ
ンテキストベースの効果を得ることができます。しかし‘M-<TAB>’で充分な場合
は、そちらのほうが便利です。

   ピクチャー内では、実際のタブ文字を抑止するほうが便利かもしれません。
たとえば、これにより‘C-x <TAB>’がピクチャーをめちゃくちゃにするのを防ぐ
ことができます。変数‘indent-tabs-mode’を‘nil’にセットすることにより、こ
れを行なうことができます。


File: emacs-ja.info,  Node: Rectangles in Picture,  Prev: Tabs in Picture,  Up: Picture Mode

42.4 Pictureモードの矩形領域コマンド
====================================

Pictureモードは、quarter-planeモデルに適合する方法で、テキストの矩形部分
に作用するコマンドを定義します。標準の矩形領域コマンドも便利でしょう
*note Rectangles::を参照してください。

‘C-c C-k’
     矩形領域をスペースでクリアーします(‘picture-clear-rectangle’)。プレ
     フィクス引数を指定した場合、テキストを削除します。
‘C-c C-w R’
     同様ですが、最初にレジスターRに矩形領域の内容を保存します
     (‘picture-clear-rectangle-to-register’)。 *note Registers::を参照し
     てください。

‘C-c C-y’
     ポイント位置を左上隅として、最後にkillされた矩形領域をバッファーに
     上書きコピーします。引数を指定した場合は、上書きではなく挿入します
     。
‘C-c C-x R’
     同様ですが、レジスターRの矩形領域を使用します
     (‘picture-yank-rectangle-from-register’)。

   ピクチャー矩形領域コマンドの‘C-c C-k’ (‘picture-clear-rectangle’)と
‘C-c C-w’ (‘picture-clear-rectangle-to-register’)が、標準の矩形領域コマ
ンドと異なる点は、通常は矩形領域を削除するかわりにクリアーすることです。
これはPictureモードで‘C-d’が変更された方法と類似しています。

   しかしPictureモードで矩形領域を削除するのが便利なときもあるかもしれな
いので、これらのコマンドは数引数を与えたときは矩形領域を削除します。数引
数の指定の有無に関わらず、‘C-c C-k’は‘C-c C-y’のために矩形領域を保存しま
す。

   矩形領域をyankするPictureモードのコマンドは、挿入ではなく上書きすると
いう点で、標準の矩形領域コマンドと異なります。これはPictureモードでのテ
キストの挿入方法が他のモードと異なるのと同じです。‘C-c C-y’
(‘picture-yank-rectangle’)は、一番最近killされた矩形領域を(上書きにより
)挿入し、‘C-c C-x’ (‘picture-yank-rectangle-from-register’)は、指定され
たレジスターの矩形領域で同様のことを行ないます。


File: emacs-ja.info,  Node: Editing Binary Files,  Next: Saving Emacs Sessions,  Prev: Picture Mode,  Up: Top

43 バイナリーファイルの編集
***************************

バイナリーファイルを編集する特別なメジャーモードに、Hexlモードがあります
。これを使用するには、ファイルをvisitするのに。‘C-x C-f’のかわりに‘M-x
hexl-find-file’を使用します。このコマンドはファイル内容を16進に変換して
、その変換結果を編集できるようにします。ファイルを保存するときは、自動的
にバイナリーに変換されます。

   既存のバッファーをhexに変換するために、‘M-x hexl-mode’を使用すること
もできます。これは普通にファイルをvisitしてから、それがバイナリーファイ
ルだと気づいた場合などに便利です。

   Hexlモードでは通常のテキスト文字は上書きです。これはファイル内のデー
タのアラインメントを意図せず壊してしまう危険を減らすためです。挿入のため
には特別なコマンドがあります。以下はHexlモードのコマンドのリストです:

‘C-M-d’
     10進でタイプされたバイトコードを挿入します。

‘C-M-o’
     8進でタイプされたバイトコードを挿入します。

‘C-M-x’
     16進でタイプされたバイトコードを挿入します。

‘C-x [’
     1Kバイトページの先頭に移動します。

‘C-x ]’
     1Kバイトページの最後に移動します。

‘M-g’
     16進で指定されたアドレスに移動します。

‘M-j’
     10進で指定されたアドレスに移動します。

‘C-c C-c’
     Hexlモードを抜けて、‘hexl-mode’モードを呼び出す前の、このバッファー
     のメジャーモードに戻ります。

他のHexlコマンドには、バイナリーバイトの文字列(シーケンス)の挿入、
‘short’、‘int’単位での移動などがあります。詳細については、‘C-h a
hexl-<RET>’とタイプしてください。


File: emacs-ja.info,  Node: Saving Emacs Sessions,  Next: Recursive Edit,  Prev: Editing Binary Files,  Up: Top

44 Emacsセッションの保存
************************

Emacsの状態を1つのセッションから別のセッションのために保存するためには、
desktopライブラリーを使用します。1度Emacsの“デスクトップ(desktop)” — バ
ッファーと、それらのファイル名、メジャーモード、バッファーでの位置など —
を保存すると、後のEmacsセッションで、保存されたデスクトップをリロードで
きます。デフォルトでは、デスクトップはフレームとウィンドウ設定も保存しよ
うと試みます。これを無効にするには、‘desktop-restore-frames’を‘nil’にセ
ットします(この振る舞いを調整するためにマスタマイズできる関連オプション
については、変数のドキュメントを参照してください)。

   デフォルトでは、リモートファイルをvisitしているバッファーに関する情報
は保存されません。変数‘desktop-files-not-to-save’をカスタマイズして、こ
れを変更することができます。

   desktopがフレームとウィンドウの設定えおリストアするときは、フレームパ
ラメーターの記録された値を使用し、initファイル(*note Init File::を参照
)でそれらのパラメーターに何をセットしていても無視されます。これは、リス
トアされたフレームにたいするフォントやフェイスのようなフレームパラメータ
ーは、前のEmacsセッションを終了したときに保存されたdesktopファイルから取
得され、initファイルでのそれらのパラメーターにたいするセッティングは無視
されることを意味します。これを無効にするには、リストアしたくないフレーム
パラメーターを除外するように、‘frameset-filter-alist’の値をカスタマイズ
してください。

   コマンド‘M-x desktop-save’で、デスクトップを手動で保存できます。
Emacs終了時のデスクトップの自動保存を有効にすることもできます。また
Emacs開始時に最後に保存されたデスクトップを自動的に復元することもできま
す。将来のセッションのためには、Customizationバッファー(*note Easy
Customization::を参照してください)を使用して、‘desktop-save-mode’を‘t’に
セットするか、initファイル(*note Init File::を参照してください)に以下の
行を追加します:

     (desktop-save-mode 1)

   initファイルで‘desktop-save-mode’をオンにした場合、Emacsはカレントデ
ィレクトリーで保存されたデスクトップを探します(より正確には、
‘desktop-path’で指定されたディレクトリーを探して、最初に見つかったデスク
トップを使用します)。したがって異なるディレクトリーに別のデスクトップを
保存でき、開始ディレクトリーによりEmacsがリロードするデスクトップを決定
できます。‘M-x desktop-change-dir’とタイプすることにより、カレントデスク
トップを保存して、他のディレクトリーに保存されたデスクトップをリロードで
きます。‘M-x desktop-revert’とタイプすることにより、前にリロードされたデ
スクトップをリバートできます。

   保存されたデスクトップをリロードしたくないときは、コマンドラインでオ
プション‘--no-desktop’を指定します。これはカレントセッションにたいして、
‘desktop-save-mode’をオフにします。‘--no-init-file’オプションを指定して
Emacsを開始することにより、通常‘desktop-save-mode’をオンにしているinitフ
ァイルをバイパスして、デスクトップのリロードを無効にすることもできます。

   デフォルトでは、デスクトップのすべてのバッファーは1度に復元されます。
しかし、デスクトップにたくさんのバッファーがあるときは遅くなるかもしれま
せん。変数‘desktop-restore-eager’で、即座に復元するバッファーの最大数を
指定できます。残りのバッファーはEmacsのアイドル時に、ゆっくり(lazily)と
復元されます。

   Emacsのデスクトップを空にするには、‘M-x desktop-clear’とタイプします
。これは内部バッファーを除いてすべてのバッファーをkillし、
‘desktop-globals-to-clear’にリストされたグローバル変数をクリアーします。
特定のバッファーを残したい場合は、変数
‘desktop-clear-preserve-buffers-regexp’をカスタマイズします。この変数の
値には、killしないバッファーの名前にマッチする正規表現を指定します。

   あるセッションから別のセッションへ、ミニバッファーのヒストリーを保存
したい場合は、‘savehist’ライブラリーを使用してください。

   ‘desktop-save-mode’がオンの状態でEmacsが実行されているとき、デフォル
トでは何らかの変更があった際は、常にデスクトップを自動保存します。変数
‘desktop-auto-save-timeout’は、デスクトップ変更をEmacsがチェックする頻度
を決定します。

   Emacsがデスクトップを保存するファイルは、他のEmacsセッションによる不
意の上書きを防ぐために、そのセッションの実行中はロックされます。このロッ
クは、通常はEmacsのexit時に解除されますが、Emacsまたはシステムがクラッシ
ュした場合、そのロックは残り、Emacsを再スタートする際に、デフォルトでは
ロックされたデスクトップファイルのどちらを使用するか尋ねます。この質問は
、変数‘desktop-load-locked-desktop’を‘nil’(その場合はデスクトップをロー
ドしない)、または‘t’(確認なしでデスクトップをロードする)のいずれかにカス
タマイズすることにより、抑止することができます。

   Emacsがデーモンモードで起動する際はユーザーに質問することができないの
で、ロックされたデスクトップが見つかった場合は、
‘desktop-load-locked-desktop’が‘t’以外であれば、それをロードしません。デ
ーモンモードでのデスクトップのリストアは、その他の理由により問題になりが
ちなことに注意してください。たとえば、デーモンはGUI機能を使用できないの
で、フレーム位置やサイズ、装飾のようなパラメーターはリストアできません。
この理由により、デスクトップのリストアを、‘after-make-frame-functions’に
フック関数‘desktop-read’を追加して、それが呼び出されることにより、最初の
クライアントが接続するまで、遅延させたいと思うかもしれません(*note
(elisp)Creating Frames::を参照)。


File: emacs-ja.info,  Node: Recursive Edit,  Next: Hyperlinking,  Prev: Saving Emacs Sessions,  Up: Top

45 再帰編集レベル
*****************

“再帰編集(recursive edit)”とは、あるEmacsコマンドの途中で、別のEmacsコマ
ンドを使用して自由に編集を行なうような状況を指します。たとえば
‘query-replace’の途中で‘C-r’をタイプすると、カレントバッファーを変更する
ことができる再帰編集に入ります。再帰編集から抜けると、‘query-replace’に
戻ります。*note Query Replace::を参照してください。

   再帰編集を“抜ける(exit)”とは、実行を継続中の、終了していないコマンド
に戻ることを意味します。再帰編集を抜けるコマンドは‘C-M-c’
(‘exit-recursive-edit’)です。

   再帰編集を“中断(abort)”することもできます。これはexitと似ていますが、
終了していないコマンドも即座に終了します。これを行なうには、コマンド
‘C-]’ (‘abort-recursive-edit’)を使用します。*note Quitting::を参照してく
ださい

   モードラインで常にメジャーモードとマイナーモードの周りを囲む丸カッコ
(parentheses)を、さらに角カッコ(square brackets)で囲んで表示することによ
り、再帰編集中であることが示されます。再帰編集は特定のウィンドウやバッフ
ァーにたいするものではなく、Emacs全体が再帰編集中であるため、すべてのウ
ィンドウのモードラインは同じように表示されます。

   再帰編集中に、さらに再帰編集に入ることも可能です。たとえば
‘query-replace’の途中で‘C-r’とタイプした後、デバッガーに入るコマンドをタ
イプしたとします。これは‘C-r’にたいする再帰編集レベルから、デバッガーに
たいする再帰編集を開始します。モードラインには、現在進行中の再帰編集レベ
ルが角カッコのペアで表示されます。

   (デバッガーでの‘c’コマンドのように)内側の再帰編集を抜けると、次に上の
レベルのコマンドの実行が再開されます。コマンドが終了したら、他の再帰編集
レベルに抜けるために‘C-M-c’を使用することができます。exitは最内レベルだ
けに適用されます。abortも1レベルの再帰編集だけを抜けて、前の再帰編集レベ
ルのコマンドに即座に戻ります。もし望むなら次の再帰編集レベルもabortでき
ます。

   かわりにコマンド‘M-x top-level’は、すべてのレベルの再帰編集をabortし
て、即座にトップレベルのコマンドリーダーに戻ります。ミニバッファーがアク
ティブなときは、ミニバッファーも抜けます。

   再帰編集の中で編集されるテキストは、トップレベルで編集しているテキス
トと同じである必要はありません。これは、何にたいしての再帰編集かに依存し
ます。再帰編集を呼び出したコマンドが最初に別のバッファーを選択する場合、
そのバッファーが再帰編集を行なうバッファーになります。どんな場合でも再帰
編集中に、(バッファーを切り替えるキーがリバインドされていないかぎり)通常
の方法でバッファーを切り替えることができます。再帰編集の中で、ファイルを
visitしたりその他のことを行ない、残りのすべての編集を行なうことも、おそ
らく可能です。しかしこれは、(スタックオーバーフローのような)驚くべき効果
をもたらすことがあります。そのため必要なくなったときは、再帰編集をexitま
たはabortすることを忘れないでください。

   一般的に、わたしたちはGNU Emacsでは再帰編集レベルを最小限にしようと努
めています。これは、特定の順 — 最内のレベルからトップレベルに向かって —
で戻ることをあなたに強いるからです。可能な場合は、異なる作業には別のバッ
ファーを供し、それらを切り替えられるようにします。いくつかのコマンドは、
元のメジャーモードに戻るコマンドを提供する、新しいメジャーモードに切り替
えます。これらの試みは、あなたの選択にしたがい、まだ終了していないタスク
にもどる、柔軟性を与えます。


File: emacs-ja.info,  Node: Hyperlinking,  Next: Amusements,  Prev: Recursive Edit,  Up: Top

46 ハイパーリンクとWebナビゲーション機能
****************************************

以下のサブセクションでは、URLや、Emacsバッファーのテキスト内にある他の種
類のリンクを扱う便利な機能を説明します。

* Menu:

* EWW::                      Emacs内のウェブブラウザ。
* Embedded WebKit Widgets::  Emacsバッファー内に埋め込まれたブラウザウィジェット。
* Browse-URL::               URLをフォローするには。
* Goto Address mode::        URLのアクティブ化について。
* FFAP::                     ポイント位置のファイルを探す、など。


File: emacs-ja.info,  Node: EWW,  Next: Embedded WebKit Widgets,  Up: Hyperlinking

46.1 EWWによるウェブブラウズ
============================

“EWW”(Emacs Web Wowser)は、Emacs用のウェブブラウザーのパッケージです。こ
れはEmacsバッファーでURLブラウズすることを可能にします。コマンド‘M-x
eww’により、URLを開いたり、ウェブを検索します。コマンド‘M-x
eww-open-file’を使用して、ファイルを開くことができます。‘browse-url’にた
いするウェブブラウザーとして。EWWを使うことができます(*note
Browse-URL::を参照してください)。完全な詳細に付いては、*note EWW:
(eww)Top.を参照してください。


File: emacs-ja.info,  Node: Embedded WebKit Widgets,  Next: Browse-URL,  Prev: EWW,  Up: Hyperlinking

46.2 埋め込みWebKitウィジェット
===============================

Emacsが適切なサポートパッケージとともにコンパイルされている場合、Emacsの
バッファーにブラウザーウィジェット(browser widgets)を表示できます。コマ
ンド‘M-x xwidget-webkit-browse-url’は、ブラウザーウィジェットに表示する
URLを尋ねます。通常はポイント位置、またはポイント位置の前にあるURLがデフ
ォルトのURLになります。しかしアクティブなリージョン(*note Mark::を参照し
てください)がある場合は、余分な空白文字を削除してから、そのリージョンか
らデフォルトのURLを取得します。コマンドはその後、指定されたURLを表示する
め込みブラウザー(embedded browser)をもつ、新しいバッファーを作成します。
このパッファーはXwidget-WebKitモード(Imageモードと似ています。*note File
Conveniences::を参照してください)で、ウィジェットのスクロール、サイズ変
更、リロードを1-keyで行なうコマンドを提供します。キーバインドを確認する
には、そのバッファーで‘C-h b’とタイプしてください。


File: emacs-ja.info,  Node: Browse-URL,  Next: Goto Address mode,  Prev: Embedded WebKit Widgets,  Up: Hyperlinking

46.3 URLのフォロー
==================

‘M-x browse-url <RET> URL <RET>’
     ウェブブラウザーへのURLのロード。

   Browse-URLパッケージは、Emacsで簡単にURLをフォロー(辿る)することを可
能にします。ほとんどのURLは、ウェブブラウザーを呼び出すことによりフォロ
ーされます。‘mailto:’のURLは、指定されたアドレスにメールを送るために、
Emacsコマンドの‘compose-mail’でフォローされます。

   コマンド‘M-x browse-url’は、URLの入力を求め、それをフォローします。ポ
イントがURLのようなテキストの近くにある場合、そのURLがデフォルトとして提
示されます。Browse-URLパッケージは、‘browse-url-at-point’や
‘browse-url-at-mouse’のような、キーにバインドしたいと思うような、他のコ
マンドも提供します。

   Customizeグループ‘browse-url’の、さまざまなオプションを通じて、
Browse-URLの振る舞いをカスタマイズできます。特に、オプション
‘browse-url-mailto-function’では‘mailto:’のURL、
‘browse-url-browser-function’ではそれ以外のタイプのURLにたいして、どのよ
うな方法でフォローするか定義することができます。詳細は、‘C-h P
browse-url <RET>’とタイプすることにより表示される、パッケージのコメント
を参照してください。


File: emacs-ja.info,  Node: Goto Address mode,  Next: FFAP,  Prev: Browse-URL,  Up: Hyperlinking

46.4 URLのアクティブ化
======================

‘M-x goto-address-mode’
     カレントバッファーのURLとメールアドレスをアクティブにします。

   ‘M-x goto-address-mode’とタイプすることにより、Emacsにカレントバッフ
ァーのURLを特別にマークさせることができます。このバッファーローカルなマ
イナーモードが有効な場合、バッファーのすべてのURLを探して、それらをハイ
ライトするとともに、クリックできるボタンに変更します。そのようなテキスト
の上にポイントを移動して‘C-c <RET>’ (‘goto-address-at-point’)とタイプす
るか、‘mouse-2’をクリック、または‘mouse-1’を素早くクリックすることにより
(*note Mouse References::を参照してください)、そのURLをフォローできます
。URLのフォローは、‘browse-url’をサブルーチンとして呼び出すことにより行
なわれます(*note Browse-URL::を参照してください)。

   モードフックや受信メッセージを表示するフック(たとえばRmailの
‘rmail-show-message-hook’や、MH-Eの‘mh-show-mode-hook’)に
‘goto-address-mode’を追加するのは便利かもしれません。Gnusには類似の機能
があるので必要ありません。


File: emacs-ja.info,  Node: FFAP,  Prev: Goto Address mode,  Up: Hyperlinking

46.5 ポイント位置のファイルやURLを開く
======================================

FFAPパッケージは、‘C-x C-f’のようなファイルを探すためのキーにバインドさ
れているコマンドを、よりセンシティブなデフォルトを提供するコマンドに置き
換えます。これらのコマンドにプレフィクス引数を与えたときは、通常のコマン
ドと同様に振る舞います。それ以外の場合、ポイント周辺のテキストからデフォ
ルトのファイル名を取得します。バッファーから見つかったのがファイル名では
なくURLの場合、このコマンドはそれを閲覧するために‘browse-url’を使用しま
す(*note Browse-URL::を参照してください)。

   この機能は、メールバッファーやニュースバッファー内の参照、‘README’フ
ァイル、‘MANIFEST’ファイルなどをフォローするのに便利です。詳細については
、‘C-h P ffap <RET>’とタイプして、パッケージのコメントを参照してください
。

   FFAPを有効にするには、‘M-x ffap-bindings’とタイプします。これにより、
以下のキーバインドが作成され、Rmail、Gnus、VMアーティクルバッファーでの
、追加FFAP機能にたいするフックもインストールされます。

‘C-x C-f FILENAME <RET>’
     FILENAMEを検索します(‘find-file-at-point’)。デフォルトのファイル名
     は、ポイント周辺のテキストから推測します。
‘C-x C-r FILENAME <RET>’
     ‘ffap-read-only’。‘find-file-read-only’に相当します。
‘C-x C-v FILENAME <RET>’
     ‘ffap-alternate-file’。‘find-alternate-file’に相当します。
‘C-x d DIRECTORY <RET>’
     ポイント位置のディレクトリーをデフォルトとして、DIRECTORYでDiredを
     開始します(‘dired-at-point’)。
‘C-x C-d DIRECTORY <RET>’
     ‘ffap-list-directory’。‘list-directory’に相当します。
‘C-x 4 f FILENAME <RET>’
     ‘ffap-other-window’。‘find-file-other-window’に相当します。
‘C-x 4 r FILENAME <RET>’
     ‘ffap-read-only-other-window’。‘find-file-read-only-other-window’に
     相当します。
‘C-x 4 d DIRECTORY <RET>’
     ‘ffap-dired-other-window’。‘dired-other-window’と同様です。
‘C-x 5 f FILENAME <RET>’
     ‘ffap-other-frame’。‘find-file-other-frame’に相当します。
‘C-x 5 r FILENAME <RET>’
     ‘ffap-read-only-other-frame’。‘find-file-read-only-other-frame’に相
     当します。
‘C-x 5 d DIRECTORY <RET>’
     ‘ffap-dired-other-frame’。‘dired-other-frame’に相当します。
‘M-x ffap-next’
     バッファーから次のファイル名またはURLを検索して、そのファイルまたは
     URLを開きます。
‘S-mouse-3’
     ‘ffap-at-mouse’は、マウスがクリックされた周辺のテキストから推測され
     たファイルを開きます。
‘C-S-mouse-3’
     カレントバッファーに記述されたファイルとURLのメニューを表示して、選
     択されたものを開きます(‘ffap-menu’)。


File: emacs-ja.info,  Node: Amusements,  Next: Packages,  Prev: Hyperlinking,  Up: Top

47 ゲーム、その他の娯楽
***********************

‘animate’パッケージは、テキストをダンスさせます(たとえば‘M-x
animate-birthday-present’)。

   ‘M-x blackbox’、‘M-x mpuz’、‘M-x 5x5’はパズルです。‘blackbox’はボック
ス内のボールの位置を、トモグラフィー(断層撮影)により当てるパズルです。
‘mpuz’は掛け算パズルを表示します。掛け算の中の英字が何の数字かを当てなけ
ればなりません。数字を入力するには、英字をタイプしてから、その数字をタイ
プします。‘5x5’の目標は、すべてのマスを埋めることです。

   ‘M-x bubbles’は、より少ない回数の移動で、多くのbubble(シャボン玉)を取
り除くゲームです。

   ‘M-x decipher’は、単純なアルファベット置換で暗号化されたバッファーを
解読するのに役立ちます。

   ‘M-x dissociated-press’は、Emacsのカレントバッファーのテキストをスク
ランブルします。スクランブルは単語単位または文字単位で行なわれ、
‘*Dissociation*’という名前のバッファーに出力されます。正の引数は文字単位
での操作を指定し、数にはオーバーラップする文字数を指定します。負の引数は
単語単位での操作を指定し、数にはオーバーラップする単語数を指定します。
Dissociated Pressはマルコフ連鎖と酷似した結果を生成しますが、それとは独
自のigオリジナルな創案です。手法としては、単語または文字の後ろにランダム
にジャンプするマルコフ連鎖とは異なり、ランダムなジャンプの間にあるサンプ
ルから、連続する複数の文字をコピーします。ユーザーに受け入れられ、正確で
ありたいなら、ドキュメントにはdissociwordsを使用しないでください。

   ‘M-x dunnet’は、テキストベースのアドベンチャーゲームを開始します。

   個人的な満足感を得たいなら、‘M-x gomoku’に挑戦してみてください。これ
はあなたと五目並べゲームを対戦します。

   少し退屈していたら‘M-x hanoi’に挑戦してみてください。かなり退屈してい
るなら、数引数を指定します。とてもとても退屈なら、引数9に挑戦してみまし
ょう。さあ、座って眺めましょう。

   ‘M-x life’は、ConwayのLife cellular automatonを実行します。

   ‘M-x morse-region’は、リージョンのテキストをモールス信号に変換し、
‘M-x unmorse-region’で元に戻します。‘M-x nato-region’は、リージョンのテ
キストをNATO発音記号(NATO phonetic alphabet)に変換し、‘M-x
denato-region’で元に戻します。

   ‘M-x pong’、‘M-x snake’、‘M-x tetris’は、有名なPong、Snake、Tetrisの
実装です。

   ‘M-x solitaire’はソリティアーゲームをプレーします。これはピンを他のピ
ンを超えてジャンプさせるゲームです。

   ‘M-x zone’は、Emacsがアイドル時にプレーするゲームです。

   円盤状記憶媒体のビットのフリップにbutterflies(蝶々)を使用する“真のプ
ログラマー”は、‘M-x butterfly’をデプロイします。<https://xkcd.com/378>を
参照してください。

   最後に、もし不満を感じているときは、有名な精神分析医のElizaに問題の説
明を試みてください。これは‘M-x doctor’とタイプするだけです。各入力の最後
には、<RET>を2回タイプしてください。


File: emacs-ja.info,  Node: Packages,  Next: Customization,  Prev: Amusements,  Up: Top

48 Emacs Lispパッケージ
***********************

Emacsには、追加の機能を実装する“パッケージ(packages)”を、簡単にダウンロ
ードしてインストールする機能が含まれています。それぞれのパッケージは個別
のEmacs Lispプログラムで、Infoマニュアルのような他の構成要素が含まれてい
るときもあります。

   ‘M-x list-packages’により、すべてのパッケージのリストを含む、
‘*Packages*’という名前のバッファーが表示されます。このバッファーを通じて
パッケージをインストールしたりアンインストールできます。*note Package
Menu::を参照してください。

   コマンド‘C-h P’ (‘describe-package’)はパッケージ名の入力を求め、その
パッケージの属性や、実装する機能を説明するヘルプバッファーを表示します。

   デフォルトでは、Emacsはemacs開発者により保守されGNUプロジェクトにより
ホスティングされる、“パッケージアーカイブ(package archive)”からパッケー
ジをダウンロードします。オプションでサードパーティーにより保守されるアー
カイブから、パッケージをダウンロードすることもできます。*note Package
Installation::を参照してください。

   Emacs Lispのプログラムをインストール可能なパッケージに変更する情報に
関しては、*note (elisp)Packaging::を参照してください。

* Menu:

* Package Menu::             パッケージを閲覧・管理するためのバッファー。
* Package Installation::     パッケージのインストールにたいするオプション。
* Package Files::            パッケージがインストールされる場所。


File: emacs-ja.info,  Node: Package Menu,  Next: Package Installation,  Up: Packages

48.1 Package Menuバッファー
===========================

コマンド‘M-x list-packages’は、“パッケージメニュー(package menu)”を立ち
上げます。これはEmacsが把握するすべてのパッケージをリストするバッファー
です。リストの各行には以下の情報が表示されます:

   • パッケージ名(例: ‘auctex’)。

   • パッケージのバージョン番号(例: ‘11.86’)。

   • パッケージの状態(state)は通常、‘available’(パッケージアーカイブから
     ダウンロード可能)、‘installed’、‘built-in’(デフォルトでEmacsに含ま
     れる)のうちの1つです。‘external’(外部)という状態は、そのパッケージ
     がビルトイン(組み込み)ではなく、‘package-user-dir’(*note Package
     Files::を参照してください)で指定されたディレクトリーのものでもない
     ことを意味します。外部パッケージはビルトインのパッケージと同様に扱
     われます。これらのパッケージはパッケージメニューから削除できず、更
     新も考慮されません。

     ステータスが‘new’のこともあります。これは‘available’と同じですが、
     最後に‘M-x list-packages’を呼び出した後に、そのパッケージがパッケー
     ジアーカイブで新たに利用可能になったことを意味します。他にもパッケ
     ージは‘held’、‘disabled’、‘obsolete’のステータスをもつかもしれませ
     ん。*note Package Installation::を参照してください。

   • パッケージの短い説明。

‘list-packages’は、パッケージアーカイブサーバーから利用可能なパッケージ
のリストを取得するために、ネットワークにアクセスします。ネットワークが利
用できない場合、一番最近取得したリストにフォールバックします。

   パッケージメニューでは、以下のコマンドが利用可能です:

‘h’
     パッケージメニューの使い方を要約した短いメッセージを表示します
     (‘package-menu-quick-help’)。

‘?’
‘<RET>’
     カレント行のパッケージにたいして、‘C-h P’コマンド(*note Packages::を
     参照してください)により表示されるヘルプウィンドウと同様の、ヘルプバ
     ッファーを表示します(‘package-menu-describe-package’)。

‘i’
     カレント行のパッケージをインストールのためにマークします
     (‘package-menu-mark-install’)。パッケージのステータスが
     ‘available’の場合、行の先頭に文字‘I’を追加します。‘x’とタイプすると
     、パッケージをダウンロードしてインストールします(以下参照)。

‘d’
     カレント行のパッケージを削除のためにマークします
     (‘package-menu-mark-delete’)。パッケージのステータスが‘installed’の
     場合、行の先頭に文字‘D’を追加します。‘x’とタイプすると、パッケージ
     を削除します(以下参照)。パッケージ削除の結果、何が起こるかについて
     の情報は、*note Package Files::を参照してください。

‘~’
     削除のためにすべての時代遅れのパッケージobsolete packagesをマークし
     ます(‘package-menu-mark-obsolete-for-deletion’)。これは状態が
     ‘obsolete’の、すべてのパッケージを削除のためにマークします。

‘u’
‘<DEL>’
     ‘i’や‘d’コマンドにより、でカレント行に追加された、以前のインストー
     ルまたは削除のマークを外します。

‘U’
     新たに利用可能になったすべてのパッケージを、更新のためにマークしま
     す(‘package-menu-mark-upgrades’)。これは新たに利用可能になったバー
     ジョンにインストールのマークをつけ、インストール済みの古いバージョ
     ンに削除のマークをつけます。

‘x’
     ‘i’でマークされたすべてのパッケージをダウンロードしてインストールす
     るとともに、‘d’でマークされたすべてのパッケージを削除します
     (‘package-menu-execute’)。これによりマークは削除されます。

‘r’
     パッケージリストを更新します(‘package-menu-refresh’)。これは再度パ
     ッケージアーカイブから利用可能なパッケージのリストを取得して、パッ
     ケージリストを再計算します。

‘f’
     パッケージリストをフィルターします(‘package-menu-filter’)。これはキ
     ーワード(例: ‘games’)の入力を求め、そのキーワードに関連するパッケー
     ジだけを表示します。完全なパッケージリストを復元するには、‘q’をタイ
     プします。

‘H’
     regexpにマッチするパッケージを永久に隠します
     (‘package-menu-hide-package’)。

‘(’
     古いバージョンのパッケージ、および優先度低のアーカイブから取得した
     バージョンの可視性を切り替えます(‘package-menu-toggle-hiding’)。

たとえばパッケージをインストールするには、そのパッケージの行で‘i’をタイ
プしてから、‘x’をタイプします。


File: emacs-ja.info,  Node: Package Installation,  Next: Package Files,  Prev: Package Menu,  Up: Packages

48.2 パッケージのインストール
=============================

パッケージを一番便利にインストールするのはパッケージメニューを使う方法
(*note Package Menu::を参照してください)ですが、コマンド‘M-x
package-install’を使用することもできます。これはステータスが
‘available’のパッケージ名の入力を求め、それをダウンロードしてインストー
ルします。

   他のパッケージが提供する機能に依存するために、それらのパッケージがイ
ンストール済みであることを“必要(require)”とするパッケージもあるでしょう
。Emacsがそのようなパッケージをインストールするときは、必要なパッケージ
がインストールされていなければ、それらのパッケージのダウンロードとインス
トールも自動に行ないます(必要なパッケージが何らかの理由で利用できない場
合、Emacsはエラーをシグナルしてインストールを中止します)。パッケージの必
要条件リスト(requirements list)は、そのパッケージのヘルプバッファーに表
示されます。

   デフォルトでは、パッケージはEmacs開発者により保守される単一のパッケー
ジアーカイブからダウンロードされます。これは変数‘package-archives’により
制御されます。この変数の値は、Emacsが認識するパッケージアーカイブのリス
トです。リストの各要素は‘(ID . LOCATION)’という形式でなければなりません
。ここで、IDはパッケージアーカイブの名前、LOCATIONはパッケージアーカイブ
ディレクトリーのHTTPアドレスか名前です。サードパーティーのアーカイブを使
用したい場合はこのリストを変更できます — が、自己責任で行い、信用できる
サードパーティーだけを使用してください!

   パッケージアーカイブのメンテナーは、パッケージに“サイン(signing)”を付
して、信頼度を増すことができます。これらはプライベートとパブリックのペア
ーからなる暗号化キーにより生成されます。プライベートキーは各パッケージに
たいする“署名ファイル(signature file)”を作成するのに使用されます。パブリ
ックキーにより、署名ファイルを使用してそのパッケージ作成者と、それが改ざ
んされていないかを確認できます。署名の検証は、EasyPGインターフェイス
(*note EasyPG: (epa)Top.を参照)を通じてthe GnuPG package
(https://www.gnupg.org/)を使用します(*note EasyPG: (epa)Top.を参照)。有
効な署名であっても、それが悪意がないパッケージであることを厳正に保証する
訳ではなく、用心するべきです。パッケージアーカイブは、パブリックキーの入
手方法について、説明を提供するべきです。<http://pgp.mit.edu/>のようなサ
ーバーからキーをダウンロードするのも1つの方法です。Emacsにキーをインポー
トするには、‘M-x package-import-keyring’を使用します。Emacsは変数
‘package-user-dir’で指定されるディレクトリー(デフォルトは
‘package-gnupghome-dir’のサブディレクトリー‘gnupg’)にパッケージキーを格
納します。これにより、Emacsが署名を検証する際に、オプション‘gnupg’で
GnuPGを呼び出すようになります。‘package-gnupghome-dir’が‘nil’,の場合は、
GnuPGのオプション‘--homedir’は省略します。GNUパッケージアーカイブにたい
するパブリックキーはEmacsと共に配布され、‘etc/package-keyring.gpg’にあり
ます。Emacsはこれを自動的に使用します。

   ユーザーオプション‘package-check-signature’が非‘nil’の場合、Emacsはパ
ッケージのインストール時に書名の検証を試みます。このオプションが値
‘allow-unsigned’をもつ場合、サインされていないパッケージのインストールが
できます。パッケージにサインしないアーカイブを使用する場合、それらを
‘package-unsigned-archives’に追加できます。

   暗号化キーとサインについての詳細は、*note GnuPG: (gnupg)Top.を参照し
てください。EmacsのGNU Privacy Guardにたいするインターフェースについては
、*note EasyPG: (epa)Top.を参照してください。

   複数のパッケージアーカイブが有効で、同じパッケージにたいして異なるバ
ージョンを提供する場合は、オプション‘package-pinned-packages’が便利かも
しれません。指定したパッケージが指定されたアーカイブだけからダウンロード
されるように、このリストにパッケージとアーカイブのペアーを追加できます。

   複数の有効なパッケージアーカイブがあるときに便利な他のオプションとし
て、‘package-archive-priorities’があります。これは各アーカイブにたいして
、優先度(高い数字は高い優先度のアーカイブを指定します)を指定します。この
オプションにより指定されない限り、アーカイブの優先度はデフォルトの0です
。優先度高のアーカイブのパッケージが利用可能な場合、優先度低のアーカイブ
のパッケージはメニューに表示されません(これは
‘package-menu-hide-low-priority’の値により制御されます)。

   1度パッケージをダウンロードしてインストールすると、そのパッケージはカ
レントEmacsセッションに“ロード”されます。パッケージのロードは、Lispライ
ブラリーのロード(*note Lisp Libraries::を参照してください)とまったく同一
ではありません。パッケージをロードすることにより、パッケージのディレクト
リーを‘load-path’に追加して、パッケージのautoloadをロードします。パッケ
ージのautoloadの効果はパッケージごとにさまざまです。ほとんどのパッケージ
は、いくつかの新たなコマンドを利用可能にするだけですが、Emacsセッション
にたいして広範な影響を及ぼすものもあります。この種の情報については、パッ
ケージのヘルプバッファーを参照してください。

   デフォルトでは、インストールされたパッケージは、Emacsその後のはセッシ
ョンで、自動的にロードされます。これはEmacs開始時、initファイル処理後
(*note Init File::を参照してください)に行なわれます。例外として、‘-q’ま
たは‘--no-init-file’オプション(*note Initial Options::を参照してください
)で呼び出されたときは、Emacs開始時のパッケージのロードは行なわれません。

   自動的なパッケージのロードを無効にするには、変数
‘package-enable-at-startup’を‘nil’に変更してください。

   自動的なパッケージのロードがinitファイルのロード後である理由は、(パッ
ケージシステムに影響するものも含む)ユーザーオプションが、カスタマイズさ
れた値を受けとるのがinitファイルのロード後だからです。initファイルの中で
明示的にパッケージをロードしたい状況があるかもしれません(たいていは、
initファイルの他のコードが、あるパッケージに依存する等の理由により)。そ
のような場合、initファイルで関数‘package-initialize’を呼び出す必要があり
ます。‘package-initialize’の呼び出しの前に、‘package-load-list’(以下参照
)などの関連するユーザーオプションをセットアップするのは、あなたの責任で
す。initファイルを処理した後に、これにより、パッケージを重複してロードす
るのを避けるために、自動的に‘package-enable-at-startup’が‘nil’にセットさ
れます。かわりに、開始時にパッケージのロードを完全に抑止して、後でコマン
ド‘M-x package-initialize’を呼び出して手動でパッケージをロードする方法を
選択したいと思うかもしれません。

   パッケージのロードをより精密に制御するために、変数
‘package-load-list’を使用することができます。この変数の値にはリストを指
定します。リストの要素は‘(NAME VERSION)’という形式で、これはEmacsにパッ
ケージ名NAMEのバージョンVERSIONをロードするよう指示します。ここで、
VERSIONには、(そのパッケージの特定のバージョンに対応する)バージョン文字
列か、‘t’(これは任意のインストール済みのバージョンを意味します)、または
‘nil’(これはバージョンを意味しません。パッケージがロードされるのを防いで
、そのパッケージを無効にします)を指定します。リストの要素にはシンボル
‘all’も指定でき、これは他のリスト要素で名前指定されていない、任意のパッ
ケージのインストール済みバージョンをロードすることを意味します。デフォル
ト値は、単に‘'(all)’となっています。

   たとえば‘package-load-list’を‘'((muse "3.20") all)’にセットした場合、
Emacsは‘muse’のバージョン3.20と、‘muse’以外のパッケージのインストール済
みの任意のバージョンをロードします。‘muse’の他のバージョンがインストール
されていたとしても、それらは無視されます。‘muse’パッケージは、‘held’とい
うステータスでパッケージメニューにリストされるはずです。


File: emacs-ja.info,  Node: Package Files,  Prev: Package Installation,  Up: Packages

48.3 パッケージのファイルとディレクトリー
=========================================

各パッケージはパッケージアーカイブから単一ファイル形式 －－－ 1つのEmacs
Lispソースファイル、または複数のEmacs Lispソースと他のファイルを含む
tarファイル — でダウンロードされます。パッケージファイルは、パッケージを
インストールするEmacsコマンドにより自動的に取得、処理、配置されます。パ
ッケージを作成する(*note (elisp)Packaging::を参照してください)のでない限
り、通常これらを直接扱う必要はないでしょう。パッケージファイルから直接パ
ッケージをインストールする必要があるときは、コマンド‘M-x
package-install-file’を使用してください。

   1度インストールされると、パッケージの内容はそのサブディレクトリーに配
置されます(変数‘package-user-dir’を変更することにより、ディレクトリーの
名前を変更できます)。パッケージのサブディレクトリーは‘NAME-VERSION’とい
う名前で、NAMEはパッケージ名、VERSIONはバージョン文字列です。

   ‘package-user-dir’に加えて、Emacsは‘package-directory-list’にリストさ
れたディレクトリーからインストール済みパッケージを探します。これらのディ
レクトリーはシステム管理者のためのディレクトリーで、Emacsパッケージをシ
ステムワイドに利用可能にするためのものです。Emacs自身がこれらのディレク
トリーにパッケージをインストールすることはありません。
‘package-directory-list’にたいするパッケージのサブディレクトリーは、
‘package-user-dir’と同じ方法で配置されます。

   パッケージの削除(*note Package Menu::を参照してください)は、対応する
パッケージのサブディレクトリーを削除します。これは‘package-user-dir’にイ
ンストールされたパッケージだけに機能します。システムワイドなパッケージデ
ィレクトリーにたいして呼び出された場合、削除コマンドはエラーをシグナルし
ます。


File: emacs-ja.info,  Node: Customization,  Next: Quitting,  Prev: Packages,  Up: Top

49 カスタマイズ
***************

このチャプターでは、Emacsの振る舞いをカスタマイズするシンプルな方法をい
くつか説明します。

   ここで説明する方法とは別に、EmacsをカスタマイズするためにX resourcesを
使用する情報については*note X Resources::、キーボードマクロの記録と再生
については*note Keyboard Macros::を参照してください。より広範で制限のな
い変更を行なうには、Emacs Lispコードを記述する必要があります。 *note
Emacs Lisp: (elisp)Top.を参照してください。

* Menu:

* Easy Customization::       設定を閲覧したり変更する便利な方法。
* Variables::                多くのEmacsコマンドは何を行なうか決定するためにEmacs変数を調べるので、変数をセットすることによりこれらの機能を制御できます。
* Key Bindings::             keymapsは各キーがどのコマンドを実行するか指定します。これらを変更することによりキーを再定義できます。
* Init File::                初期化ファイルで一般的なカスタマイズを記述する方法。


File: emacs-ja.info,  Node: Easy Customization,  Next: Variables,  Up: Customization

49.1 Easy Customizationインターフェース
=======================================

Emacsには変更できる多くの“セッティング(settings)”があります。ほとんどの
セッティングは“カスタマイズ可能な変数(customizable variables。*note
Variables::を参照してください)”で、これらは“ユーザーオプション(user
options)”とも呼ばれます。非常にたくさんのカスタマイズ可能な変数があり、
それらはEmacsの振る舞いを数々の側面から制御します。このマニュアルにドキ
ュメントされている変数は、*note Variable Index::にリストされています。セ
ッティングの別のクラスには“フェイス(faces)”があり、これはフォント、カラ
ー、その他のテキスト属性を決定します(*note Faces::を参照してください)。

   セッティング(変数およびフェイスの両方)を閲覧したり変更するには、‘M-x
customize’とタイプします。これは論理的に組織化されたセッティングのリスト
の操作、値の編集とセット、永続的な保存を行なうことができる、“カスタマイ
ズバッファー(customization buffer)”を作成します。

* Menu:

* Customization Groups::     セッティングがクラス化される方法。
* Browsing Custom::          セッティングのブラウズとサーチ。
* Changing a Variable::      オプション値の編集、およびオプションをセットする方法。
* Saving Customizations::    将来のEmacsセッションのためにカスタマイズを保存する。
* Face Customization::       フェイスの属性を編集する方法。
* Specific Customization::   グループの特定のセッティングのカスタマイズ。
* Custom Themes::            カスタマイズセッティングのコレクション。
* Creating Custom Themes::   新しいカスタムテーマを作成する方法。


File: emacs-ja.info,  Node: Customization Groups,  Next: Browsing Custom,  Up: Easy Customization

49.1.1 カスタマイズグループ
---------------------------

カスタマイズセッティングは、“カスタマイズグループ(customization
groups)”に組織化されています。これらのグループはより大きなグループに集め
られ、最終的に‘Emacs’と呼ばれるマスターグループに集約されます。

   ‘M-x customize’は、トップレベルの‘Emacs’グループを表示するカスタマイ
ズバッファーを作成します。これは、部分的には以下のようなものです:

     For help using this buffer, see [Easy Customization] in the [Emacs manual].

     ________________________________________ [ Search ]

      Operate on all settings in this buffer:
      [ Revert... ] [ Apply ] [ Apply and Save ]


     Emacs group: Customization of the One True Editor.
           [State]: visible group members are all at standard values.
           See also [Manual].

     [Editing]      Basic text editing facilities.
     [Convenience]  Convenience features for faster editing.

     ...MORE SECOND-LEVEL GROUPS...

このバッファーも表示されている主要な部分は‘Emacs’カスタマイズグループで
、これはいくつかの他のグループ(‘Editing’、‘Convenience’など)を含みます。
これらのグループの内容はここではリストされず、それぞれにたいして1行のド
キュメントだけが表示されています。

   グループの“state(ステート、状態)”には、そのグループ内のセッティングが
、編集されているか(edited)、セットされているか(set)、保存されているか
(saved)が示されます。*note Changing a Variable::を参照してください。

   カスタマイズバッファーのほとんどは読み取り専用ですが、編集できるいく
つかの“編集可能フィールド(editable fields)”が含まれています。たとえばカ
スタマイズバッファーの最上部にある編集可能フィールドは、セッティングを検
索するためのものです(*note Browsing Custom::を参照してください)。マウス
でクリック、またはポイントをそこに移動して‘<RET>’をタイプすることにより
アクティブにできる、“ボタン(buttons)”や“リンク(links)”もあります。たとえ
ば‘[Editing]’のようなグループ名はリンクで、これらのリンクをアクティブに
することにより、そのグループにたいするカスタマイズバッファーが立ち上がり
ます。

   カスタマイズバッファーでは、‘<TAB>’ (‘widget-forward’)とタイプすると
、次のボタンまたは編集可能フィールドに前方へ移動します。‘S-<TAB>’
(‘widget-backward’)は、前のボタンまたは編集可能フィールドに後方へ移動し
ます。


File: emacs-ja.info,  Node: Browsing Custom,  Next: Changing a Variable,  Prev: Customization Groups,  Up: Easy Customization

49.1.2 セッティングのブラウズと検索
-----------------------------------

‘M-x customize’により作成されたトップレベルのカスタマイズバッファーから
、カスタマイズグループ‘Emacs’のサブグループへのリンクをフォローできます
。これらのサブグループは、カスタマイズするためのセッティングを含んでいる
でしょう。また、これらのサブグループには、Emacsのより特化したサブシステ
ムを扱うサブグループが、さらに含まれているかもしれません。カスタマイズグ
ループの階層を移動していけば、カスタマイズしたい、いくつかのセッティング
が見つかるでしょう。

   特定のセッティングまたはカスタマイズグループのカスタマイズに興味があ
る場合は、コマンド‘M-x customize-option’、‘M-x customize-face’、
‘M-x customize-group’で直接移動することもできます。*note Specific
Customization::を参照してください。

   どのグループまたはセッティングをカスタマイズしたいか確信がもてない場
合、各カスタマイズバッファーの上部にある、編集可能なサーチフィールドを使
用して、それらを検索できます。このフィールドで検索条件 — 1つの単語または
スペースで区切られた複数の単語、または正規表現(*note Regexps::を参照して
ください) — をタイプできます。それからそのフィールドで‘<RET>’をタイプす
るか、となりの‘Search’ボタンをアクティブにすることにより、その条件にマッ
チするグループとセッティングを含むカスタマイズバッファーに切り替わります
。しかし、この機能はカレントEmacsセッションにロードされたグループ、また
はセッティングだけを探すことに注意してください。

   カスタマイズバッファーにサーチフィールドを表示したくない場合は、変数
‘custom-search-field’を‘nil’に変更してください。

   コマンド‘M-x customize-apropos’は、同じようにサーチフィールドを使用し
ますが、これはミニバッファーを使用して検索条件を読み取ります。*note
Specific Customization::を参照してください。

   ‘M-x customize-browse’は、利用可能なセッティングをブラウズする別の方
法です。このコマンドは、グループまたはセッティングの名前だけを、構造化さ
れたレイアウトで表示する、特別なカスタマイズバッファーを作成します。グル
ープ名のとなりの‘[+]’ボタンを呼び出すことにより、同じバッファーでグルー
プの内容を表示できます。グループの内容が表示されている場合、ボタンは
‘[-]’に変化し、それを呼び出すことにより、再びグループ内容を隠すことがで
きます。このバッファーのグループまたはセッティングには、それぞれ
‘[Group]’、‘[Option]’、‘[Face]’というリンクがあります。このリンクを呼び
出すことにより、そのグループ、オプション、フェイスだけを表示する、通常の
カスタマイズバッファーが作成されます。‘M-x customize-browse’では、この方
法によりセッティングを変更します。


File: emacs-ja.info,  Node: Changing a Variable,  Next: Saving Customizations,  Prev: Browsing Custom,  Up: Easy Customization

49.1.3 変数の変更
-----------------

以下は変数またはユーザーオプションが、カスタマイズバッファーではどのよう
に表示されるかの例です:

     [Hide] Kill Ring Max: 60
        [State]: STANDARD.
        Maximum length of kill ring before oldest elements are thrown away.

   最初の行には、この変数の名前が‘kill-ring-max’であることが、見やすいよ
う‘Kill Ring Max’のようにフォーマットされてに表示されています。この変数
の値は‘60’です。‘[Hide]’というラベルのボタンは、アクティブにした場合は、
この変数の値とステートを隠します。これは、変数がもし非常に長い値をもつ場
合、カスタマイズバッファーが見にくくなるのを避けるために便利です(この理
由により、非常に長い値をもつ変数は、最初は隠されています)。‘[Hide]’ボタ
ンを使用すると、ボタンは‘[Show Value]’に変化し、これをアクティブにすると
値とステートが表示されます。グラフィカルなディスプレーでは、‘[Hide]’と
‘[Show Value]’ボタンは、下向きまたは右向きのグラフィカルな三角形で置き換
えられます。

   変数名の次の行は、変数の“カスタマイズ状態(customization state)”を示し
ます。この例では‘STANDARD’で、これは変数を変更していないので、値はデフォ
ルトのままだということを意味します。‘[State]’ボタンは、変数をカスタマイ
ズするためのオペレーションメニューを提供します。

   カスタマイズのステートの下は、変数のドキュメントです。これは‘C-h v’コ
マンド(*note Examining::を参照してください)で表示されるのと同じドキュメ
ントです。ドキュメントが複数行の場合、1行だけが表示されます。この場合、
その行の最後に‘[More]’ボタンが表示されるので、これをアクティブにすれば完
全なドキュメントを表示できます。

   ‘Kill Ring Max’に新しい値を入力するには、値にポイントを移動してそれを
編集するだけです。たとえば‘M-d’とタイプして‘60’を削除して、別の値をタイ
プします。テキストの変更を開始すると、‘[State]’行が変化します:

     [State]: EDITED, shown value does not take effect until you
              set or save it.

値を編集してもすぐに変更は反映されません。変更を反映するには、
‘[State]’をアクティブにして、‘Set for Current Session’を選択することによ
り、変数を“セット(set)”しなければなりません。すると変数のステートは以下
のようになります:

     [State]: SET for current session only.

無効な値を指定してしまうことを心配する必要はありません。‘Set for Current
Session’オペレーションは正当性をチェックして、不当な値はインストールしま
せん。

   ファイル名、ディレクトリー名、Emacsコマンドのようなタイプの値を編集す
るときは、‘C-M-i’ (‘widget-complete’)、または等価なキー‘M-<TAB>’、‘<ESC>
<TAB>’で補完を行なうことができます。これはミニバッファーでの補完と同じよ
うに振る舞います(*note Completion::を参照してください)。

   編集可能な値フィールドで‘<RET>’とタイプすることにより、‘<TAB>’のよう
に、次のフィールドまたはボタンに移動できます。したがってフィールドの編集
を終えたら‘<RET>’とタイプして、次のボタンまたはフィールドに移動できます
。編集可能なフィールドに改行を挿入するには、‘C-o’または‘C-q C-j’を使用し
ます。

   あらかじめ決められた値しかセットできず、値を直接編集することができな
い変数もいくつかあります。そのような変数の値の前には、かわりに‘[Value
Menu]’ボタンが表示されます。このボタンをアクティブにすると、値の選択肢が
表示されます。“onかoff”のブーリーン値にたいしては、‘[Toggle]’ボタンが表
示され、このボタンにより値のオンとオフを切り替えることができます。
‘[Value Menu]’ボタンや‘[Toggle]’ボタンを使用した後は、変数をセットして、
選択した値を反映するために、再度値をセットしなければなりません。

   複雑な構造の値をもつ変数もいくつか存在します。たとえば、
‘minibuffer-frame-alist’の値は連想配列(association list、alist)です。こ
れはカスタマイズバッファーでは、以下のように表示されます:

     [Hide] Minibuffer Frame Alist:
     [INS] [DEL] Parameter: width
                 Value: 80
     [INS] [DEL] Parameter: height
                 Value: 2
     [INS]
        [ State ]: STANDARD.
        Alist of parameters for the initial minibuffer frame. [Hide]
        [...more lines of documentation...]

この場合、リストの各association要素は2つのアイテムからなり、1つは
‘Parameter’というラベルがつき、もう1つは‘Value’というラベルがつき、両方
とも編集可能フィールドです。となりにある‘[DEL]’ボタンでリストから
associationを削除できます。associationを追加するには、挿入したい位置の
‘[INS]’ボタンを使用します。一番最後の‘[INS]’ボタンはリストの最後に挿入し
ます。

   変数をセットした場合、新しい値はカレントEmacsセッションでだけ効果があ
ります。将来のセッションのために値を“保存(save)”するには、‘[State]’ボタ
ンを使用して、‘Save for Future Sessions’オペレーションを選択します。
*note Saving Customizations::を参照してください。

   ‘[State]’ボタンを使用して‘Erase Customization’オペレーションを選択す
ることにより、変数の値をその変数の標準値に復元することもできます。実際に
は4つのリセットオペレーションがあります:

‘Undo Edits’
     値を変更したが、まだ変数をセットしていない場合は、実際の値にマッチ
     するようにバッファーのテキストを復元します。

‘Revert This Session's Customizations’
     これは、変更された変数がある場合は、変数の値を最後に保存された値に
     復元し、それ以外は標準の値に復元します。テキストも復元された変数に
     合わせて更新します。

‘Erase Customization’
     これは変数をその変数の標準値にセットします。保存した値も削除します
     。

‘Set to Backup Value’
     これはこのセッションでカスタマイズバッファーでセットされる前の値に
     、変数をリセットします。変数をカスタマイズしてからリセットすると、
     これはカスタマイズした値を破棄するので、このオペレーションにより、
     破棄した値に戻すことができます。

   特定のカスタマイズにたいして、コメントを記録できれば便利なこともあり
ます。コメントを入力するフィールドを作成するには、‘[State]’メニューの
‘Add Comment’アイテムを使用します。

   カスタマイズバッファーの上部には2行のボタン行があります:

      Operate on all settings in this buffer:
      [Revert...] [Apply] [Apply and Save]

‘[Revert...]’ボタンは、上述で説明したうち、最初の3つのリセット操作をドロ
ップダウンします。‘[Apply]’ボタンは、カレントセッションにセッティングを
適用します。‘[Apply and Save]’ボタンはセッティングを適用して、将来のセッ
ションのためにそれらのセッティングを保存します。このボタンは、Emacsが
‘-q’または‘-Q’のオプションで開始された場合は表示されません(*note Initial
Options::を参照)。

   コマンド‘C-c C-c’ (‘Custom-set’)は、‘[Set for Current Session]’ボタン
を使用するのと等価です。コマンド‘C-x C-s’ (‘Custom-save’)は、‘[Save for
Future Sessions]’ボタンを使用するのと同様です。

   ‘[Exit]’ボタンはカスタマイズバッファーを、バッファーリストの最後のバ
ッファーに隠し(bury)ます。カスタマイズバッファーをkillさせるようにするに
は、変数‘custom-buffer-done-kill’を‘t’に変更します。


File: emacs-ja.info,  Node: Saving Customizations,  Next: Face Customization,  Prev: Changing a Variable,  Up: Easy Customization

49.1.4 カスタマイズの保存
-------------------------

カスタマイズバッファーでは、カスタマイズしたセッティングの‘[State]’ボタ
ンで‘Save for Future Sessions’を選択することにより、それを“保存(save)”で
きます。‘C-x C-s’ (‘Custom-save’)コマンド、またはカスタマイズバッファー
のトップにある‘[Apply and Save]’ボタンで、そのバッファー内で適用可能なす
べてのセッティングが保存されます。

   ファイル(通常は初期化ファイル。*note Init File::を参照してください)に
コードを書き込むことにより保存は機能します。将来のEmacsセッションは、開
始時に自動的にこのファイルを読み込んで、カスタマイズを再びセットします。

   初期化ファイル以外の他のファイルにカスタマイズを保存する選択もできま
す。これが機能するには、変数‘custom-file’に保存したいファイル名をセット
して、そのファイルをロードするコード行を追加しなければなりません。たとえ
ば:

     (setq custom-file "~/.emacs-custom.el")
     (load custom-file)

   以下のようにして、Emacsのバージョンごとに違うカスタマイズファイルを指
定することさえ可能です:

     (cond ((< emacs-major-version 22)
            ;; Emacs 21 customization.
            (setq custom-file "~/.custom-21.el"))
           ((and (= emacs-major-version 22)
                 (< emacs-minor-version 3))
            ;; Emacs 22 customization, before version 22.3.
            (setq custom-file "~/.custom-22.el"))
           (t
            ;; Emacs version 22.3 or later.
            (setq custom-file "~/.emacs-custom.el")))

     (load custom-file)

   Emacsが‘-q’または‘--no-init-file’オプションで呼び出されたときは、カス
タマイズを初期化ファイルに保存しません。なぜならそのようなセッションから
カスタマイズを保存することにより、初期化ファイルに記述されていた他のすべ
てのカスタマイズが消されてしまうからです。

   将来のセッションのために保存することを選択しなかった場合、そのカスタ
マイズはEmacsの終了とともに失われてしまうことに注意してください。終了時
に保存されていないカスタマイズにたいするメッセージを表示させたい場合は、
初期化ファイルに以下を追加してください:

     (add-hook 'kill-emacs-query-functions
               'custom-prompt-customize-unsaved-options)


File: emacs-ja.info,  Node: Face Customization,  Next: Specific Customization,  Prev: Saving Customizations,  Up: Easy Customization

49.1.5 フェイスのカスタマイズ
-----------------------------

フェイス(*note Faces::を参照してください)をカスタマイズできます。フェイ
スは、異なる種類のテキストをEmacsがどのように表示するか決定します。カス
タマイズグループは、変数とフェイスの両方を含むことができます。

   たとえばプログラミング言語のモードでは、ソースコードのコメントはフェ
イス‘font-lock-comment-face’で表示されます(*note Font Lock::を参照してく
ださい)。カスタマイズバッファーでは、‘[Show All Attributes]’リンクをクリ
ックした後は、このフェイスについて以下のように表示されます:

     [Hide] Font Lock Comment Face:[sample]
        [State] : STANDARD.
        Font Lock mode face used to highlight comments.
        [ ] Font Family: --
        [ ] Font Foundry: --
        [ ] Width: --
        [ ] Height: --
        [ ] Weight: --
        [ ] Slant: --
        [ ] Underline: --
        [ ] Overline: --
        [ ] Strike-through: --
        [ ] Box around text: --
        [ ] Inverse-video: --
        [X] Foreground: Firebrick     [Choose]  (sample)
        [ ] Background: --
        [ ] Stipple: --
        [ ] Inherit: --
        [Hide Unused Attributes]

最初の3行にはフェイス名、‘[State]’ボタン、そのフェイスにたいするドキュメ
ントが表示されます。その下は、“フェイス属性(face attributes)”のリストで
す。それぞれの属性の前にはチェックボックスがあります。チェックされている
チェックボックスは‘[X]’と表示され、このフェイスがその属性に値を指定して
いることを意味します。空のチェックボックスは‘[ ]’と表示され、このフェイ
スがその属性に特に値を指定していないことを意味します。チェックボックスを
アクティブにすることにより、その属性を指定または未指定にできます。

   フェイスにすべての属性を指定する必要はありません。実際のところ、ほと
んどのフェイスは少しの属性しか指定していません。上記の例では、
‘font-lock-comment-face’はフォアグラウンドカラーだけを指定しています。未
指定の属性にたいしては、すべての属性が指定された特別なフェイス
‘default’の属性が使用されます。‘default’フェイスは、明示的にフェイスが割
り当てられていない任意のテキストを表示するために使用されるフェイスです。
さらに、このフェイスのバックグラウンドカラー属性には、フレームのバックグ
ラウンドカラーが使用されます。

   属性リストの最後にある‘[Hide Unused Attributes]’ボタンは、このフェイ
スの未指定の属性を隠します。隠された属性があるとき、ボタンは‘[Show All
Attributes]’に変化し、これはすべての属性リストを表示します。カスタマイズ
バッファーは、インターフェースが見にくくなるのを避けるため、未指定の属性
が隠された状態で開始されるでしょう。

   属性を指定するときは、通常の方法で値を変更できます。

   フォアグラウンドカラーとバックグラウンドカラーは、カラーネームとRGBト
リプレットの両方を使用して指定できます(*note Colors::を参照してください
)。カラーネームのリストに切り替えるために、‘[Choose]’ボタンも使用できま
す。そのバッファーで‘<RET>’でカラーを選択すると、値フィールドにそのカラ
ーネームが入ります。

   フェイスのセット・保存。リセットは、変数にたいする操作と同様に機能し
ます(*note Changing a Variable::を参照してください)。

   フェイスは、異なるタイプのディスプレーにたいして、違う外観を指定でき
ます。たとえば、カラーディスプレーではテキストを赤にして、モノクロディス
プレーでは太字フォントを使うようにフェイスを設定できます。フェイスにたい
して複数の外観を指定するには、‘[State]’で呼び出されるメニューで‘For All
Kinds of Displays’を選択してください。


File: emacs-ja.info,  Node: Specific Customization,  Next: Custom Themes,  Prev: Face Customization,  Up: Easy Customization

49.1.6 特定のアイテムのカスタマイズ
-----------------------------------

‘M-x customize-option <RET> OPTION <RET>’
‘M-x customize-variable <RET> OPTION <RET>’
     1つのユーザーオプションOPTIONにたいするカスタマイズバッファーをセッ
     トアップします。

‘M-x customize-face <RET> FACE <RET>’
     1つのフェイスFACEにたいするカスタマイズバッファーをセットアップしま
     す。

‘M-x customize-group <RET> GROUP <RET>’
     1つのグループGROUPにたいするカスタマイズバッファーをセットアップし
     ます。

‘M-x customize-apropos <RET> REGEXP <RET>’
     REGEXPにマッチする、すべてのセッティングとグループにたいするカスタ
     マイズバッファーをセットアップします。

‘M-x customize-changed <RET> VERSION <RET>’
     EmacsのバージョンVERSIONから意味が変更された、すべてのセッティング
     とグループでカスタマイズバッファーをセットアップします。

‘M-x customize-changed-options <RET> VERSION <RET>’
     EmacsのバージョンVERSIONから意味、またはデフォルト値が変更された、
     すべてのセッティングとグループのオプションでカスタマイズバッファー
     をセットアップします。

‘M-x customize-saved’
     カスタマイズバッファーを使って保存された、すべてのセッティングを含
     むカスタマイズバッファーをセットアップします。

‘M-x customize-unsaved’
     セットしたが保存していない、すべてのセッティングを含むカスタマイズ
     バッファーをセットアップします。

   特定のユーザーオプションをカスタマイズしたい場合は、‘M-x
customize-option’とタイプします。これは変数名を読み取り、そのユーザーオ
プション1つだけのためのカスタマイズバッファーをセットアップします。ミニ
バッファーから変数名を入力するときは、補完が利用可能ですが、Emacsにロー
ドされた変数名だけが補完されます。

   同様に‘M-x customize-face’を使用して、特定のフェイスをカスタマイズで
きます。‘M-x customize-group’を使用して、特定のカスタマイズグループにた
いするカスタマイズバッファーをセットアップできます。

   ‘M-x customize-apropos’は検索条件 — 1つの単語か、スペースで区切られた
複数の単語、または正規表現 — の入力を求め、名前がそれにマッチする、_ロー
ドされた_すべてのセッティングとグループにたいするカスタマイズバッファー
をセットアップします。これはカスタマイズバッファーのトップにあるサーチフ
ィールドを使用するのと同様です(*note Customization Groups::を参照してく
ださい)。

   新しいバージョンのEmacsにアップグレードしたとき、新しいセッティングを
カスタマイズしたり、意味やデフォルト値が変更されたものをセッティングした
いと思うかもしれません。これを行なうには‘M-x customize-changed’を使用し
て、ミニバッファーから以前のEmacsのバージョンを指定します。これは指定さ
れたバージョンから変更されたすべてのセッティングとグループを表示するカス
タマイズバッファーを作成し、必要ならそれらをロードします。

   セッティングを変更した後、その変更が間違いだと気づいたときは、変更を
戻すために2つのコマンドを使用できます。保存されたカスタマイズのセッティ
ングには、‘M-x customize-saved’を使用します。セットしたが保存していない
カスタマイズのセッティングには、‘M-x customize-unsaved’を使用します。


File: emacs-ja.info,  Node: Custom Themes,  Next: Creating Custom Themes,  Prev: Specific Customization,  Up: Easy Customization

49.1.7 カスタムテーマ
---------------------

“カスタムテーマ(Custom themes)”は、1つの単位として有効または無効にできる
、セッティングのコレクションです。カスタムテーマを使用して、さまざまなセ
ッティングコレクション間を簡単に切り替えることができ、あるコンピューター
から別のコンピューターへそのようなコレクションを持ち運ぶことができます。

   カスタムテーマは、Emacs Lispソースファイルとして保存されています。カ
スタムテーマの名前がNAMEなら、そのテーマのファイル名は‘NAME-theme.el’で
す。テーマファイルのフォーマットと、それを作成する方法については、*note
Creating Custom Themes::を参照してください。

   ‘M-x customize-themes’とタイプすると、Emacsが認識するカスタムテーマを
リストする、‘*Custom Themes*’という名前のバッファーに切り替わります。デ
フォルトでは、Emacsは2つの場所からテーマファイルを探します。1つは
‘custom-theme-directory’により指定されるディレクトリー(デフォルトは
‘~/.emacs.d/’))で、もう1つはEmacsがインストールされた場所(変数
‘data-directory’を参照してください)の‘etc/themes’というディレクトリーで
す。後者にはEmacsと共に配布されるいくつかのカスタムテーマが含まれており
、これらはさまざまなカラースキーム(color schemes)に適合するように、
Emacsフェイスをカスタマイズします(しかし、カスタムテーマの目的はこれだけ
に制限される必要はなく、変数をカスタマイズするのにも使用できることに注意
してください)。

   Emacsに他の場所からカスタムテーマを探させたい場合は、リスト変数
‘custom-theme-load-path’にディレクトリーを追加します。この変数のデフォル
ト値は‘(custom-theme-directory t)’です。ここでシンボル
‘custom-theme-directory’は、変数‘custom-theme-directory’の値を指定すると
いう特別な意味をもち、‘t’はビルトインのテーマディレクトリー
‘etc/themes’を意味します。‘custom-theme-load-path’で指定されるディレクト
リーにあるテーマが、‘*Custom Themes*’バッファーにリストされます。

   ‘*Custom Themes*’バッファーでは、カスタムテーマの隣のチェックボックス
をアクティブにすることにより、カレントEmacsセッションで、そのテーマを有
効または無効にできます。カスタムテーマが有効な場合、そのテーマのすべての
セッティング(変数とフェイス)がEmacsセッションで効果をもちます。選択した
テーマを将来のEmacsセッションに適用するには、‘C-x C-s’
(‘custom-theme-save’)とタイプするか、‘[Save Theme Settings]’ボタンを使用
してください。

   最初にカスタムテーマを有効にするとき、Emacsはテーマファイルの内容を表
示して、本当にロードするか確認を求めます。これはカスタムテーマのロードに
より不定なLispコードが実行されるからで、テーマが安全だと判っているときだ
けyesと答えるべきです。この場合、Emacsは将来のセッションのために、そのテ
ーマが安全だということを記憶するか尋ねます(これは変数
‘custom-safe-themes’にテーマファイルのSHA-256ハッシュ値を保存することに
より行なわれます)。すべてのテーマを安全なものとして扱いたい場合は、変数
の値を‘t’)に変更します。(ディレクトリー‘etc/themes’の)Emacsと共に配布さ
れるテーマは、このチェックから除外されていて、常に安全だと判断されます。

   カスタムテーマのセッティングと保存は、変数‘custom-enabled-themes’をカ
スタマイズすることにより機能します。この変数の値は、カスタムテーマ名
(‘tango’のようなLispシンボル)のリストです。‘custom-enabled-themes’のセッ
トに‘*Custom Themes*’バッファーを使用するかわりに、たとえば‘M-x
customize-option’のような通常のカスタマイズインターフェースを使用して、
変数をカスタマイズできます。カスタムテーマ自身では、
‘custom-enabled-themes’をセットできないことに注意してください。

   カスタマイズバッファーを通じて行なう任意のカスタマイズは、テーマのセ
ッティングより優先されます。これによりテーマのセッティングを簡単にオーバ
ーライドできます。2つの異なるテーマのセッティングがオーバーラップする場
合には、‘custom-enabled-themes’で先に指定されたテーマが優先されます。カ
スタマイズバッファーでは、カスタムテーマによりセッティングがデフォルトか
ら変更されているときは、‘State’には‘STANDARD’ではなく‘THEMED’が表示され
ます。

   ‘M-x load-theme’とタイプすることにより、カレントEmacsセッションで特定
のカスタムテーマを有効にできます。これはテーマ名の入力を求め、テーマファ
イルからテーマをロードし、それを有効にします。すでにテーマファイルがロー
ドされているときは、‘M-x enable-theme’とタイプすることにより、ファイルを
ロードせずにテーマを有効にできます。カスタムテーマを無効にするには、‘M-x
disable-theme’とタイプしてください。

   カスタムテーマの説明を見るには、‘*Custom Themes*’バッファーのその行で
、‘?’とタイプするか、Emacsの任意のバッファーで‘M-x describe-theme’とタイ
プしてテーマ名を入力してください。


File: emacs-ja.info,  Node: Creating Custom Themes,  Prev: Custom Themes,  Up: Easy Customization

49.1.8 カスタムテーマの作成
---------------------------

‘M-x customize-create-theme’とタイプすることにより、カスタマイズバッファ
ーと似たインターフェースを使用して、カスタムテーマを定義できます。これは
‘*Custom Theme*’という名前のバッファーに切り替えます。これは、一般的な
Emacsフェイスをそのテーマに挿入するかも尋ねます(カスタムテーマは、フェイ
スをカスタマイズするのに使用される場合があるので便利です)。これにnoと答
えると、そのテーマには最初は何もセッティングが含まれません。

   ‘*Custom Theme*’バッファーの上部には、テーマ名と説明を入力できる、編
集可能フィールドがあります。‘user’を除く任意の名前を指定できます。説明は
、テーマにたいして‘M-x describe-theme’を呼び出したときに表示される文です
。最初の行は1センテンスの概要であるべきです。‘M-x customize-themes’によ
り作成されたバッファーでは、このセンテンスがテーマ名のとなりに表示されま
す。

   テーマに新しいセッティングを追加するには、‘[Insert Additional Face]’ボ
タンか、‘[Insert Additional Variable]’ボタンを使用します。これらのボタン
はミニバッファーを使用して、補完つきでフェイス名または変数名を読み取り、
そのフェイスまたは変数にたいするカスタマイズエントリーを挿入します。通常
のカスタマイズバッファーと同じ方法で、変数の値またはフェイスの属性を編集
できます。テーマからフェイスまたは変数を削除するには、名前の横のチェック
ボックスのチェックを外してください。

   カスタムテーマのフェイスや変数を指定した後は、‘C-x C-s’
(‘custom-theme-write’)とタイプするか、そのバッファーの‘[Save Theme]’ボタ
ンを使用します。これは‘custom-theme-directory’のディレクトリーに、
‘NAME-theme.el’(NAMEはテーマ名)という名前で、テーマファイルを保存します
。

   ‘*Custom Theme*’バッファーから、‘[Visit Theme]’ボタンをアクティブにし
てテーマ名を指定することにより、既存のカスタムテーマの閲覧と編集ができま
す。‘[Merge Theme]’ボタンを使用して、他のテーマのセッティングをバッファ
ーに追加することもできます。‘[Merge Theme]’ボタンを使用して、‘user’とい
う名前の特別なテーマ名を指定することにより、非テーマセッティングをカスタ
ムテーマにインポートできます。

   テーマファイルは単なるEmacs Lispソースファイルで、カスタムテーマのロ
ードはLispファイルをロードすることにより機能します。したがって‘*Custom
Theme*’バッファーを使用するかわりに、テーマファイルを直接編集することも
できます。詳細は、*note (elisp)Custom Themes::を参照してください。


File: emacs-ja.info,  Node: Variables,  Next: Key Bindings,  Prev: Easy Customization,  Up: Customization

49.2 変数
=========

“変数(variable)”とは、値をもつLipシンボルです。このようなシンボルの名前
は、“変数名(variable name)”とも呼ばれます。変数名には、ファイルに記述で
きる任意の文字を含めることもできますが、ほとんどの変数名は通常の単語をハ
イフンで区切って構成されます。

   変数の名前には、その変数の役割を簡単に説明する役目があります。ほとん
どの変数は“ドキュメント文字列(documentation string)”ももっていて、これは
変数の目的、どのような種類の値をもつべきか、値がどのように使用されるかを
説明します。ヘルプコマンド‘C-h v’ (‘describe-variable’)を使用して、この
ドキュメントを閲覧できます。*note Examining::を参照してください。

   Emacsは内部の記録維持のために多くのLisp変数を使用しますが、非プログラ
マーに一番興味があるのはユーザーが変更することを意図したLisp変数であり、
これらは“カスタマイズ可能変数(customizable variables)”や“ユーザーオプシ
ョン(user options)”と呼ばれます(*note Easy Customization::を参照してくだ
さい)。以下のセクションでは、カスタマイズのためのインターフェース以外か
ら変数をセットする方法など、他の観点からEmacs変数を説明します。

   (少数の例外を除き)Emacs Lispでは、任意の変数は任意のタイプの値をもつ
ことができます。しかし多くの変数は、特定のタイプの値を割り当てられた場合
だけ意味をもちます。たとえばkillリングの最大長さを指定する
‘kill-ring-max’の値としては、数字だけが意味をもちます。‘kill-ring-max’の
値として文字列を与えた場合、‘C-y’ (‘yank’)のようなコマンドはエラーをシグ
ナルするでしょう。一方、タイプを気にしない変数もあります。たとえば、変数
の値が‘nil’のときはある効果をもたらし、非‘nil’のときは別の効果をもたらす
場合、シンボル‘nil’以外の任意の値は、そのタイプに関わらず2番目の効果をも
たらします(慣例により、非‘nil’値を指定するために、通常は値‘t’ — これは
“true”が由来です — を使用します)。カスタマイズバッファーを使用して変数を
セットする場合、無効なタイプを与えてしまう心配はありません。カスタマイズ
バッファーでは通常、意味のある値しか入力できないからです。判別がつかない
ときは、その変数が期待する値の種類を見るために、‘C-h v’
(‘describe-variable’)を使用して、変数のドキュメント文字列をチェックして
ください(*note Examining::を参照してください)。

* Menu:

* Examining::                変数の値の検証とセッティング。
* Hooks::                    フック変数によりEmacsの一部にたいして特定の機会に実行するプログラムを指定できます。
* Locals::                   変数のバッファーごとの値。
* File Variables::           ファイルが変数の値を指定する方法。
* Directory Variables::      ディレクトリーにより変数の値を指定する方法。


File: emacs-ja.info,  Node: Examining,  Next: Hooks,  Up: Variables

49.2.1 変数の確認とセット
-------------------------

‘C-h v VAR <RET>’
     変数VARの値とドキュメントを表示します(‘describe-variable’)。

‘M-x set-variable <RET> VAR <RET> VALUE <RET>’
     変数VARの値をVALUEに変更します。

   変数の値を調べるには、‘C-h v’ (‘describe-variable’)を使用します。これ
はミニバッファーを使用して補完つきで変数名を読み取り、、変数の値とドキュ
メントの両方を表示します。たとえば、

     C-h v fill-column <RET>

これは以下のような出力を表示します:

     fill-column is a variable defined in ‘C source code’.
     Its value is 70

       Automatically becomes buffer-local when set.
       This variable is safe as a file local variable if its value
       satisfies the predicate ‘integerp’.

     Documentation:
     Column beyond which automatic line-wrapping should happen.
     Interactively, you can set the buffer local value using C-x f.

     You can customize this variable.

‘You can customize the variable’の行は、この変数がユーザーオプションであ
ることを示します。‘C-h v’はユーザーオプションだけに制限されません。これ
はカスタマイズ可能でない変数にも使用できます。

   特定のカスタマイズ可能な変数をセットする一番簡単な方法は、‘M-x
set-variable’です。これはミニバッファーで変数名を読み取り(補完つき)、次
にミニバッファーを使用して新しい値にたいするLisp式を読み取ります(‘M-n’を
使用してミニバッファーで編集するために、古い値を挿入することができます
)。たとえば、

     M-x set-variable <RET> fill-column <RET> 75 <RET>

これは‘fill-column’を75にセットします。

   ‘M-x set-variable’はカスタマイズ可能な変数に制限されていますが、以下
のようなLisp式で任意の変数をセットできます:

     (setq fill-column 75)

このような式を実行するには、‘M-:’ (‘eval-expression’)とタイプして、ミニ
バッファーで式を入力します(*note Lisp Eval::を参照してください)。かわり
に‘*scratch*’バッファーに移動して、式をタイプしてから‘C-j’とタイプするこ
ともできます(*note Lisp Interaction::を参照してください)。

   変数のセットは、Emacsのカスタマイズと同様、特に明記しない限りは、カレ
ントEmacsセッションだけに影響します。将来のセッションのために変数を変更
する唯一の方法は、初期化ファイルにそれを記述することです(*note Init
File::を参照してください)。


File: emacs-ja.info,  Node: Hooks,  Next: Locals,  Prev: Examining,  Up: Variables

49.2.2 フック
-------------

“フック(hook)”とは、Emacsをカスタマイズするための重要な仕組みです。フッ
クは関数のリストを保持するLisp変数で、これらの関数は、ある定められたタイ
ミングで呼び出されます(これは、“フックを実行する(running the hook)”)、と
呼ばれます)。リストの中の個別の関数は、そのフックの“フック関数(hook
functions)”と呼ばれます。たとえばフック‘kill-emacs-hook’は、Emacsを終了
する直前に実行されます(*note Exiting::を参照してください)。

   ほとんどのフックは“ノーマルフック(normal hooks)”です。これは、Emacsが
フックを実行するとき、フック関数が引数なしで順に呼び出します。わたしたち
は、ほとんどのフックをノーマルフックに保つために努力しているので、あなた
はこれらのフックを一貫した方法で使用することができます。変数名の最後が
‘-hook’の変数は、ノーマルフックです。

   多くはありませんが、“アブノーマルフック(abnormal hooks)”もあります。
アブノーマルフックは、名前の最後が‘-hook’ではなく‘-functions’です(古いコ
ードの中には時代遅れのサフィックス‘-hooks’を使うものもあります)。これら
のフックがアブノーマルな理由は、関数が呼び出される方法にあります — もし
かしたら引数が与えられているかもしれず、ことによると関数が返す値が何かに
使用されるかもしれません。たとえば‘find-file-not-found-functions’はアブ
ノーマルです。なぜならフック関数のうちの1つが非‘nil’値を返した場合、残り
の関数は呼び出されないからです(*note Visiting::を参照してください)。アブ
ノーマルフック変数のドキュメントには、フック関数がどのように使用されるか
の説明があります。

   他のLisp変数と同じように、‘setq’でフック変数をセットすることもできま
すが、フック(ノーマルとアブノーマルの両方)に関数を追加するための推奨され
る方法は、以下の例で示されるような、‘add-hook’を使う方法です。詳細は、
*note (elisp)Hooks::を参照してください。

   ほとんどのメジャーモードは初期化の最終ステップで、1つ以上の“モードフ
ック(mode hooks)”を実行します。モードフックは個々のモードの振る舞いをカ
スタマイズするための便利な方法で、常にノーマルフックです。たとえば、以下
はTextモードと、Textモードを基礎とする他のモードで、Auto Fillモードをオ
ンにするフックをセットアップする方法です:

     (add-hook 'text-mode-hook 'auto-fill-mode)

これは、引数を与えられない場合にマイナーモードを有効にする
‘auto-fill-mode’を呼び出すことにより機能します(*note Minor Modes::を参照
してください)。次に、Textモードを基礎とするLaTeXモードではAuto Fillモー
ドをオンにしたくない場合、以下の行を追加してこれを行なうことができます:

     (add-hook 'latex-mode-hook (lambda () (auto-fill-mode -1)))

ここでは、無名関数(anonymous function。*note (elisp)Lambda
Expressions::を参照してください)を構築するために、特別なマクロ‘lambda’を
使用しており、‘auto-fill-mode’に‘-1’を与えて呼び出すことにより、マイナー
モードを無効にしています。LaTeXモードは、‘text-mode-hook’を実行した後に
、‘latex-mode-hook’モードを実行するので、その結果Auto Fillモードが無効に
なります。

   以下はもっと複雑な例で、Cコードのインデントをカスタマイズするのにフッ
クを使う方法です:

     (setq my-c-style
       '((c-comment-only-line-offset . 4)
         (c-cleanup-list . (scope-operator
                            empty-defun-braces
                            defun-close-semi))))

     (add-hook 'c-mode-common-hook
       (lambda () (c-add-style "my-style" my-c-style t)))

   メジャーモードフックは、それを元のモードとして“派生された(derived)”他
のメジャーモードにも適用されます(*note (elisp)Derived Modes::を参照して
ください)。たとえばHTMLモード(*note HTML Mode::を参照してください)は
Textモードから派生しており、HTMLモードが有効になるときは、
‘html-mode-hook’を実行する前に‘text-mode-hook’が実行されます。これは1つ
のフックを複数の関連するモードに作用させるための便利な方法を提供します。
特に任意のプログラミング言語にたいしてフック関数を適用したい場合は、それ
を‘prog-mode-hook’モードに追加します。Progモードは、それを継承する他のメ
ジャーモードと比較すると、ほとんど何も行なわないメジャーモードで、まさに
この目的のために存在します。

   実行される順番に依存しないようにフック関数をデザインするのがベストで
す。実行順への依存はトラブルを招きます。しかし実行順は予測可能です。フッ
ク関数はフックに登録された順に実行されます。

   何度も‘add-hook’を呼び出すことにより、さまざまな異なるバージョンのフ
ック関数を追加した場合、追加されたすべてのバージョンのフック関数がフック
変数に残ることを忘れないでください。‘remove-hook’を呼び出すことにより関
数を個別にクリアーするか、‘(setq HOOK-VARIABLE nil)’ですべてのフック関数
を削除できます。

   フック変数がバッファーローカルな場合、グローバル変数のかわりにバッフ
ァーローカル変数が使用されます。しかしバッファーローカル変数が要素‘t’を
含む場合は、グローバル変数も同様に実行されます。


File: emacs-ja.info,  Node: Locals,  Next: File Variables,  Prev: Hooks,  Up: Variables

49.2.3 ローカル変数
-------------------

‘M-x make-local-variable <RET> VAR <RET>’
     変数VARが、カレントバッファーでローカル値をもつようにします。

‘M-x kill-local-variable <RET> VAR <RET>’
     変数VARが、カレントバッファーでグローバル値を使うようにします。

‘M-x make-variable-buffer-local <RET> VAR <RET>’
     変数VARがセットされた時点で、カレントバッファーにたいしてローカルに
     なるようマークします。

   ほとんどの変数は、特定のEmacsバッファーにたいして“ローカル(local)”に
することができます。これは、そのバッファーでの変数の値が、他のバッファー
での変数の値とは、独立していることを意味します。多くはありませんが、常に
バッファーごとにローカルな変数もあります。他のすべてのEmacs変数は、バッ
ファーで変数をローカルにしていないかぎりは、すべてのバッファーに効果を及
ぼす“グローバル(global)”な値をもちます。

   ‘M-x make-local-variable’は変数名を読み取り、それをカレントバッファー
にたいしてローカルにします。その後、このバッファーで変数の値を変更しても
他のバッファーには影響せず、変数のグローバル値を変更してもこのバッファー
には影響しなくなります。

   ‘M-x make-variable-buffer-local’は、変数がセットされたとき自動的にロ
ーカルになるように、変数をマークします。より正確には、1度この方法で変数
がマークされると、通常の方法による変数のセットは、最初に自動的に
‘make-local-variable’を呼び出します。このような変数を“パーバッファー
(per-buffer: バッファーごと)”変数と呼びます。Emacsの多くの変数は、通常は
パーバッファーです。変数のドキュメント文字列には、いつこれを行なうかが記
述されています。パーバッファー変数のグローバル値は、通常は任意のバッファ
ーには影響しませんが、それでもまだ意味があります。グローバル値は、新しい
バッファーにたいする、この変数の初期値として使用されます。

   メジャーモード(*note Major Modes::を参照してください)は常に変数をセッ
トする前に、変数をローカルにします。あるバッファーでメジャーモードを変更
しても、他のバッファーに影響がないのは、これが理由です。マイナーモードは
変数をセットすることにより機能します — 通常、各マイナーモードは1つの制御
変数(controlling variable)をもっていて、この変数が非‘nil’の場合はモード
が有効になります(*note Minor Modes::を参照してください)。多くのマイナー
モードにたいして制御変数はパーバッファーであり、したがって常にバッファー
ローカルです。そうでない場合、他の変数と同様に特定のバッファーで変数をロ
ーカルにできます。

   多くはありませんが、バッファーでローカルにできない(かわりに各ディスプ
レーにたいして常にローカル。*note Multiple Displays::を参照してください
)変数も存在します。そのような変数をバッファーローカルにしようとすると、
エラーメッセージが表示されます。

   ‘M-x kill-local-variable’は、指定された変数が、カレントバッファーにた
いしてローカルであることを終了させます。その後は、そのバッファーにたいし
て、その変数のグローバル値が効力をもちます。メジャーモードのセットにより
、数少ない“パーマネントローカル(permanent locals: 永久にローカル)”な変数
を除いて、そのバッファーのすべてのローカル変数はkillされます。

   変数がカレントバッファーでローカル値をもつかに関わらず、変数にグロー
バル値をセットするには、Lispコンストラクト‘setq-default’を使用することが
できます。このコンストラクトは‘setq’と同じように使用されますが、(もしあ
れば)ローカル値のかわりにグローバル値をセットします。カレントバッファー
がローカル値をもつ場合、新しいグローバル値は他のバッファーに切り替えるま
で見えないでしょう。以下は例です:

     (setq-default fill-column 75)

‘setq-default’は、‘make-variable-buffer-local’でマークされた変数のグロー
バル値をセットする唯一の方法です。

   Lispプログラムは変数のデフォルト値を得るために、‘default-value’を使用
することができます。この関数はシンボルを引数として受け取り、それのデフォ
ルト値を返します。引数は評価されるので、通常は明示的にクォートする必要が
あります。たとえば、以下は‘fill-column’のデフォルト値を得る方法です:

     (default-value 'fill-column)


File: emacs-ja.info,  Node: File Variables,  Next: Directory Variables,  Prev: Locals,  Up: Variables

49.2.4 ファイル内のローカル変数
-------------------------------

ファイルに、Emacsでそのファイルを編集するときに使用するローカル変数の値
を指定できます。ファイルをvisitするか、メジャーモードをセットすることに
より、Emacsはローカル変数指定をチェックします。これは自動的にこれらの変
数をバッファーにたいしてローカルにし、ファイルで指定された値にセットしま
す。

* Menu:

* Specifying File Variables::  ファイルローカル変数の指定。
* Safe File Variables::      ファイルローカル変数が安全であることを確認する。


File: emacs-ja.info,  Node: Specifying File Variables,  Next: Safe File Variables,  Up: File Variables

49.2.4.1 ファイル変数の指定
...........................

ファイルローカル変数を指定するには2つの方法があります。1つは最初の行に記
述する方法で、もう1つはローカル変数リストを使用する方法です。以下は最初
の行でこれらを指定する方法の例です:

     -*- mode: MODENAME; VAR: VALUE; ... -*-

この方法により、任意の数の変数/値(variable/value)ペアーを指定できます。
各ペアーはコロンとセミコロンで区切ります。特別な変数/値ペアー‘mode:
MODENAME;’が与えられた場合、これはメジャーモードを指定します。VALUEは文
字列として使用され、評価はされません。

   手作業でエントリーを追加するかわりに、‘M-x
add-file-local-variable-prop-line’を使用することができます。このコマンド
は変数と値の入力を求め、適切な方法で最初の行にこれらを追加します。‘M-x
delete-file-local-variable-prop-line’は変数の入力を求め、最初の行から変
数のエントリーを削除します。コマンド‘M-x
copy-dir-locals-to-file-locals-prop-line’は、カレントのディレクトリーロ
ーカル変数を最初の行にコピーします(*note Directory Variables::を参照して
ください)。

   以下は、最初の行でLispモードを指定して、2つの変数に数値をセットする例
です:

     ;; -*- mode: Lisp; fill-column: 75; comment-column: 50; -*-

‘mode’の他に、ファイル変数として特別な意味をもつキーワードは‘coding’、
‘unibyte’、‘eval’です。これらは以下で説明します。

   シェルスクリプトでは、最初の行はスクリプトのインタープリターの識別に
使用されるので、ローカル変数をそこに置くことはできません。これに対処する
ために、Emacsは最初の行がインタープリターを指定しているときは、_2行目_か
らローカル変数指定を探します。man pagesにも同じことが言えます。man
pagesはtroffプリプロセッサーのリストを指定するマジック文字列‘'\"’で始ま
るからです(しかし、すべてがこれを行なう訳ではありません)。

   ‘-*-’行を使用するのではなく、ファイルの終端付近で“ローカル変数リスト
(local variables list)”を使用することにより、ファイルローカル変数を定義
することもできます。ローカル変数リストは、ファイル終端から3000文字以内で
開始され、ファイルがページに分かれているときは最後のページになければなり
ません。

   ファイルにローカル変数リストと‘-*-’の両方がある場合、Emacsは最初に
‘-*-’行の_すべて_を処理してから、ローカル変数リストの_すべて_を処理しま
す。例外はメジャーモード指定です。Emacsはメジャーモード指定がどこにあろ
うと、まずそれを適用します。なぜならほとんどのメジャーモードは、初期化部
分ですべてのローカル変数をkillするからです。

   ローカル変数リストは、文字列‘Local Variables:’を含む行で開始され、文
字列‘End:’を含む行で終了します。この間には、以下のように1行に変数名と値
のペアーが記述されます:

     /* Local Variables:  */
     /* mode: c           */
     /* comment-column: 0 */
     /* End:              */

この例では、各行はプレフィクス‘/*’で始まり、サフィックス‘*/’で終了します
。Emacsは、リストの最初の行のマジック文字列‘Local Variables:’を囲む文字
列から、プレフィクスとサフィックスを識別します。その後はリストの他の行で
自動的にこれらを破棄します。プレフィクスおよび/またはサフィックスを使用
する通常の理由は、そのファイルが意図する他のプログラムが混乱しないように
、ローカル変数をコメントに埋め込むためです。上記は、コメントが‘/*’で始ま
り‘*/’で終わるCプログラミング言語での例です。

   Emacsのローカル変数リストではないが、そのように見えるテキストがある場
合は、そのテキストの後にフォームフィード文字(ページ区切りです。*note
Pages::を参照してください)を挿入して、それを取り消すことができます。
Emacsはファイルの最後のページ(つまり最後のページ区切りの後)にあるファイ
ルローカル変数だけを調べます。

   ローカル変数を直接タイプするかわりに、コマンド‘M-x
add-file-local-variable’を使用することができます。これは変数と値の入力を
求め、それらをリストに追加し、‘Local Variables:’と、必要なら開始・終了マ
ーカーも追加します。コマンド‘M-x delete-file-local-variable’は、リストか
ら変数を削除します。‘M-x copy-dir-locals-to-file-locals’は、ディレクトリ
ーローカル変数をリストにコピーします(*note Directory Variables::を参照し
てください)。

   ‘-*-’行と同じように、ローカル変数リストの変数は文字列として使用され、
最初に評価されることはありません。長い文字列値をファイル内で複数行に分割
したい場合、改行とバックスラッシュを使用できます(Lisp文字列定数では無視
されます)。各行には、プレフィクスとサフィックスを記述するべきです。たと
え行がその文字列で開始または終了していても、それらはリストを処理するとき
取り除かれます。以下は例です:

     # Local Variables:
     # compile-command: "cc foo.c -Dfoo=bar -Dhack=whatever \
     #   -Dmumble=blaah"
     # End:

   いくつかの名前は、ローカル変数リスト内で特別な意味をもちます:

   • ‘mode’は、指定されたメジャーモードを有効にします。

   • ‘eval’は、指定されたLisp式を評価します(式が返す値は無視されます)。

   • ‘coding’は、このファイルでの文字コード変換にたいするコーディングシ
     ステムを指定します。*note Coding Systems::を参照してください。

   • ‘unibyte’の値が‘t’の場合、Emacs Lispのロードとコンパイルをunibyteモ
     ードで行ないます。*note Disabling Multibyte Characters:
     (elisp)Disabling Multibyte.を参照してください。

これら4つのキーワードは、実際には変数ではありません。他のコンテキストで
これらをセットしても、特別な意味はありません。

   マイナーモードにたいして‘mode’キーワードを使用しないでください。ロー
カル変数リストでマイナーモードを有効または無効にするには、‘eval’でモード
コマンドを実行するLisp式を指定します(*note Minor Modes::を参照してくださ
い)。たとえば以下のローカル変数リストは、引数なし(引数に1を指定しても同
じことを行ないます)で‘eldoc-mode’を呼び出すことにより、Eldocモード(*note
Lisp Doc::を参照してください)を有効にし、引数−1で‘font-lock-mode’(*note
Font Lock::を参照してください)を呼び出すことにより、Font Lockモードを無
効にする例です。

     ;; Local Variables:
     ;; eval: (eldoc-mode)
     ;; eval: (font-lock-mode -1)
     ;; End:

しかしこの方法でマイナーモードを指定するのは、間違っている場合もあること
に注意してください。マイナーモードは個人の好みを表しており、そのファイル
を編集するユーザーにあなたの好みを強制するのは、不適切かもしれません。状
況に依存して自動的にマイナーモードを有効または無効にしたい場合は、たいて
いメジャーモードフックでこれを行なう方がよいのです(*note Hooks::を参照し
てください)。

   ローカル変数と、ファイル名とファイル内容にしたがったバッファーのメジ
ャーモード(もしあればローカル変数リストも)をリセットするには、コマンド
‘M-x normal-mode’を使用します。*note Choosing Modes::を参照してください
。


File: emacs-ja.info,  Node: Safe File Variables,  Prev: Specifying File Variables,  Up: File Variables

49.2.4.2 安全なファイル変数
...........................

ファイルローカル変数が危険な場合もあります。他の誰かのファイルをvisitす
るとき、そのファイルのローカル変数リストがEmacsに何を行なうか、告げるも
のはありません。‘eval’ “variable”や、その他の‘load-path’などにたいする不
正な値は、実行する意図がないLispコードを実行するかもしれません。

   したがって、安全と判っていないファイルローカル変数を発見した場合、
Emacsはファイルのローカル変数リスト全体を表示して、それらをセットする前
に継続するか尋ねます。‘y’または<SPC>をタイプすると、ローカル変数リストは
効果をもち、‘n’の場合は無視します。Emacsがバッチモード(*note Initial
Options::を参照してください)で実行されている場合、Emacsは確認することが
できないので、‘n’と応えられたとみなします。

   Emacsは通常、特定の変数/値ペアーが安全だと認識できます。たとえば
‘comment-column’や‘fill-column’には、任意の整数値を与えても安全です。フ
ァイルが安全だと判っている変数/値ペアーだけを指定する場合、Emacsはそれら
をセットする前に確認を求めません。そうでない場合、確認プロンプトで‘!’と
タイプすることにより、このファイル内のすべての変数/値ペアーが安全なこと
を記録するようEmacsに指示できます。その後、Emacsが同じファイルまたは別の
ファイルで、これらの変数/値ペアーに出会うと、これらを安全だとみなします
。

   ‘load-path’のようないくつかの変数は、特に“危険”だと判断されます。これ
らをローカル変数として指定すべき理由はほとんどなく、それらを変更するのは
危険です。ファイルに危険なローカル変数だけが含まれる場合、Emacsは確認プ
ロンプトで‘!’の選択肢を提示することも、それを受け入れることもしません。
ファイル内のいくつかのローカル変数が危険で、いくつかの変数は潜在的に安全
ではない場合は、プロンプトで‘!’を入力できます。これはすべての変数に適用
されますが、危険ではない変数だけを将来のセッションのために安全とマークし
ます。もし危険な変数を安全な値として記録したいと本当に望むなら、
‘safe-local-variable-values’をカスタマイズすることによりこれを行ないます
(*note Easy Customization::を参照してください)。

   変数‘enable-local-variables’により、Emacsがローカル変数を処理する方法
を変更できます。デフォルト値は‘t’で、これは上述の振る舞いを指定します。
‘nil’の場合、Emacsは単にすべてのファイルローカル変数を無視します。
‘:safe’は安全な値だけを使用して、残りは無視します。他の値の場合、安全と
判っている値かどうかの決定を試みずに、ローカル変数をもつ各ファイルごとに
尋ねます。

   変数‘enable-local-eval’は、Emacsが‘eval’変数を処理するかどうかを制御
します。‘enable-local-variables’のように、変数に対する可能な値は3つで、
‘t’、‘nil’、およびそれ以外です。デフォルトは、‘t’や‘nil’ではない
‘maybe’で、通常Emacsは‘eval’変数を処理するときに確認を求めます。

   例外として、評価する任意の‘eval’形式が、変数‘safe-local-eval-forms’で
指定された形式の場合、Emacsは確認を求めません。


File: emacs-ja.info,  Node: Directory Variables,  Prev: File Variables,  Up: Variables

49.2.5 ディレクトリーごとのローカル変数
---------------------------------------

大きなソフトウェアプロジェクトでのディレクトリーツリーのような、特定のデ
ィレクトリーや、それのサブディレクトリーのすべてのファイルにたいして、同
じローカル変数を定義したいことがあるかもしれません。これは“ディレクトリ
ーローカル変数(directory-local variables)”で行なうことができます。

   ディレクトリーローカル変数を定義する通常の方法は、そのディレクトリー
に‘.dir-locals.el’(1)を配す方法です。そのディレクトリー、またはそれのサ
ブディレクトリーの任意のファイルをEmacsがvisitするとき、
‘.dir-locals.el’で指定されたディレクトリーローカル変数が、あたかもそのフ
ァイルのファイルローカル変数(*note File Variables::を参照してください)と
して定義されたかのように、ファイルに適用されます。Emacsはvisitされたファ
イルのディレクトリーから、ディレクトリーツリーを上に移動しながら
‘.dir-locals.el’を検索します。スローダウンを避けるために、検索はリモート
ファイルをスキップします。必要なら、変数‘enable-remote-dir-locals’を
‘t’にセットして、検索範囲をリモートファイルに広げることができます。

   Emacsが追加でロードする‘.dir-locals-2.el’が存在する場合は、それを使用
することもできます。これは‘.dir-locals.el’がバージョンコントロールの共有
ディレクトリー配下にあり、個人的なカスタマイズに使用できないときに有用で
す。

   ‘.dir-locals.el’は、特別な構成のリストをもちます。これはモード名(シン
ボルで指定)をalist(Association Lists: 連想リスト。*note
(elisp)Association Lists::を参照してください)にマップします。各alistエン
トリーは、変数名と、指定されたメジャーモードが有効なときに、その変数に割
り当てるディレクトリーローカル値からなります。モード名のかわりに‘nil’を
指定でき、これはalistが任意のモードで適用されることを意味します。サブデ
ィレクトリー(文字列で指定)を指定することもできます。この場合、そのサブデ
ィレクトリーのすべてのファイルにalistが適用されます。

   以下は、‘.dir-locals.el’ファイルの例です:

     ((nil . ((indent-tabs-mode . t)
              (fill-column . 80)))
      (c-mode . ((c-file-style . "BSD")
                 (subdirs . nil)))
      ("src/imported"
       . ((nil . ((change-log-default-name
                   . "ChangeLog.local"))))))

これはディレクトリーツリーの任意のファイルにたいして、
‘indent-tabs-mode’と‘fill-column’をセットし、任意のCソースファイルにたい
してインデントスタイルをセットします。特別な要素‘subdirs’は変数ではあり
ません。これは特別なキーワードで、Cモードのセッティングがカレントディレ
クトリーだけに適用され、任意のサブディレクトリーには適用されないことを示
します。最後に、これは‘src/imported’サブディレクトリー内の任意のファイル
にたいして、違う‘ChangeLog’ファイル名を指定します。

   ‘.dir-locals.el’内では‘mode’、‘eval’、‘unibyte’を指定できます。これら
の変数は、ファイルローカル変数のときとオ同じ意味をもちます。‘coding’は、
ディレクトリーローカル変数としては指定できません。*note File
Variables::を参照してください。

   ‘.dir-locals.el’ファイルを手で編集するかわりに、コマンド‘M-x
add-dir-local-variable’を使用できます。これはモード名またはサブディレク
トリー、および変数名と値の入力を求め、ディレクトリーローカル変数を定義す
るエントリーを追加します。‘M-x delete-dir-local-variable’は、エントリー
を削除します。‘M-x copy-file-locals-to-dir-locals’は、カレントファイル内
のファイルローカル変数を、‘.dir-locals.el’にコピーします。

   ディレクトリーローカル変数を指定する他の方法は、
‘dir-locals-set-class-variables’関数を使用して、“ディレクトリークラス
(directory class)”の中に、変数/値ペアーのグループを定義する方法です。そ
の後、‘dir-locals-set-directory-class’関数を使用して、そのクラスに対応す
るディレクトリーをEmacsに指示します。これらの関数呼び出しは通常、初期化
ファイルで行なわれます(*note Init File::を参照してください)。この方法は
、何らかの理由でディレクトリーに‘.dir-locals.el’を置けないときに便利です
。たとえば、この方法で書き込み不可なディレクトリーにセッティングを適用で
きます:

     (dir-locals-set-class-variables 'unwritable-directory
        '((nil . ((some-useful-setting . value)))))

     (dir-locals-set-directory-class
        "/usr/include/" 'unwritable-directory)

   変数にたいしてディレクトリーローカル値とファイルローカル値の両方が指
定された場合、ファイルローカル値が効果をもちます。安全ではないディレクト
リーローカル値は、安全でないファイルローカル値と同じ方法で扱われます
(*note Safe File Variables::を参照してください)。

   ディレクトリーローカル変数は、Diredバッファー(*note Dired::を参照して
ください)のような、ファイルを直接visitしていないが、ディレクトリーで処理
を行なうバッファーにたいしても効果があります。

   ---------- Footnotes ----------

   (1) MS-DOSでは、DOSファイルシステムの制限により、このファイルの名前は
‘_dir-locals.el’になります。ファイルシステムによりファイル名が8+3に制限
されている場合、OSによりファイル名が‘_dir-loc.el’に切り詰められるでしょ
う。


File: emacs-ja.info,  Node: Key Bindings,  Next: Init File,  Prev: Variables,  Up: Customization

49.3 キーバインディングのカスタマイズ
=====================================

このセクションでは、キーをコマンドにマップする“キーバインド(key
bindings)”と、そのキーバインドを記録する“キーマップ(keymaps)”を説明しま
す。それにinitファイルを編集して、キーバインドをカスタマイズする方法も説
明します(*note Init Rebinding::を参照してください)。

   ほとんどのモードは自身のキーバインディングを定義するので、モードをア
クティブにすることにより、あなたのカスタムキーバインディングがオーバーラ
イドされるかもしれません。いくつかのキーはユーザー定義バインディングのた
めに予約されており、モードはそれらを使用してはならないので、これらのキー
はこの問題にたいして安全です。予約済みのキーは、‘C-c’と英字(大文字と小文
字の両方)、修飾キーなし(*note Modifier Keys::を参照)のファンクションキー
の<F5>から<F9>です。

* Menu:

* Keymaps::                  一般的な考え方。グローバルキーマップ。
* Prefix Keymaps::           プレフィクスキーにたいするキーマップ。
* Local Keymaps::            キーマップをもつメジャーモードとマイナーモード。
* Minibuffer Maps::          ミニバッファーが使用する独自のキーマップ。
* Rebinding::                あるキーの意味を再定義する便利な方法。
* Init Rebinding::           初期化ファイルでのキーのリバインド。
* Modifier Keys::            Using modifier keys.
* Function Keys::            端末のファンクションキーのリバインド。
* Named ASCII Chars::        <TAB>と‘C-i’などを区別する方法。
* Mouse Buttons::            Emacsでのマウスボタンのリバインド。
* Disabling::                コマンドを無効にするとは、それを実行できるようにする前に確認が要求されることを意味します。これはビギナーを戸惑わせないようにするために行なわれます。


File: emacs-ja.info,  Node: Keymaps,  Next: Prefix Keymaps,  Up: Key Bindings

49.3.1 キーマップ
-----------------

*note Commands::で説明されているように、各Emacsコマンドは、対話的に使用
することを条件として定義されたLisp関数です。すべてのLisp関数と同様に、コ
マンドは小文字とハイフンからなる関数名をもちます。

   “キーシーケンス(key sequence)” — 短くは“キー(key)” — とは、1つの単位
として意味をもつ、連続する“入力イベント(input events)”のことです。入力イ
ベントとは文字、ファンクションキー、マウスボタン — つまりコンピューター
に送ることができるすべての入力のことです。キーシーケンスは、それが何のコ
マンドを実行するかを指示する“バインディング(binding)”により、意味をもち
ます。

   キーシーケンスとコマンド関数との間のバインディングは、“keymaps(キーマ
ップ)”と呼ばれるデータ構造に記録されます。Emacsには多くのkeymapsがあり、
それぞれが特別の機会に使用されます。

   一番重要なキーマップは、“グローバルキーマップ(global keymap)”です。な
ぜならグローバルキーマップは常に効果があるからです。グローバルキーマップ
はFundamentalモードにたいしてキーを定義します(*note Major Modes::を参照
してください)。これらの定義のほとんどは、、ほとんどすべてのメジャーモー
ドでは一般的です。メジャーモードまたはマイナーモードは、いくつかのキーに
たいするグローバル定義をオーバーライドするために、それぞれ独自のkeymapを
もつことができます。

   たとえば‘g’のような自己挿入文字(self-inserting character)は、グローバ
ルキーマップがそれをコマンドcommand ‘self-insert-command’にバインドする
ので、自己挿入を行なうのです。‘C-a’のような標準的なEmacsの編集文字もグロ
ーバルキーマップから、それらの標準的な意味を取得します。‘M-x
global-set-key’のような、キーをリバインドするコマンドは、新しいバインデ
ィングをグローバルマップの適切な位置に保存することにより機能します(*note
Rebinding::を参照してください)。

   ほとんどの現代的なキーボードは、文字キーと同じようにファンクションキ
ーをもちます。ファンクションキーは文字キーが行なうように入力イベントを送
り、キーマップはファンクションキーにたいするバインディングをもつことがで
きます。キーシーケンスにはファンクションキーと文字をミックスすることもで
きます。たとえば、キーボードにファンクションキー<Home>がある場合、
Emacsは‘C-x <Home>’のようなキーシーケンスを認識できます。
‘S-down-mouse-1’のように、マウスイベントとキーボードイベントをミックスす
ることさえ可能です。

   テキスト端末では、ファンクションキーをタイプすることにより、文字シー
ケンスがコンピューターに送られます。シーケンスの正確な詳細は、ファンクシ
ョンキーと端末タイプに依存します(シーケンスが‘<ESC> [’で始まることもしば
しばあります)。Emacsが端末タイプを理解する場合、自動的にそのようなシーケ
ンスを1つの入力イベントとして処理します。


File: emacs-ja.info,  Node: Prefix Keymaps,  Next: Local Keymaps,  Prev: Keymaps,  Up: Key Bindings

49.3.2 プレフィクスキーマップ
-----------------------------

内部的には、Emacsは各キーマップの1つのイベントだけを記録します。複数イベ
ントのキーシーケンスの解釈は、キーマップの連鎖を生じます。最初のイベント
にたいして最初のキーマップが定義を与え、シーケンス内の2番目のイベントを
探すのに他のキーマップが使用され...と連鎖していきます。したがって‘C-x’や
<ESC>などのプレフィクスキーは独自のキーマップをもち、それらはプレフィク
スの直後のイベントにたいする定義を保持します。

   プレフィクスキーの定義は通常、それに続くイベントを探すのに使用するキ
ーマップです。プレフィクスキーの定義として、関数定義がキーマップであるよ
うなLispシンボルを指定することもできます。効果は同じですが、そのプレフィ
クスキーが何のためなのか説明するためのコマンド名を提供します。たとえば、
‘C-x’のバインディングはシンボル‘Control-X-prefix’で、このシンボルの関数
定義は、‘C-x’コマンドにたいするキーマップです。プレフィクスキーとしての
‘C-c’、‘C-x’、‘C-h’、<ESC>は、グローバルキーマップに定義されているので、
これらのプレフィクスキーは常に利用できます。

   通常のプレフィクスキー以外に、“架空のプレフィクスキー(fictitious
prefix key)”もあり、これらはメニューバーを表します。メニューバーのキーバ
インディングについての特別な情報は、*note (elisp)Menu Bar::を参照してく
ださい。ポップアップメニューを呼び出すマウスボタンイベントもプレフィクス
キーです。詳細については、*note (elisp)Menu Keymaps::を参照してください
。

   いくつかのキーマップは、名前のついた変数に格納されています:

   • ‘ctl-x-map’は、‘C-x’の後の文字に使用されるマップにたいする変数名で
     す。
   • ‘help-map’は。‘C-h’の後の文字のためのマップです。
   • ‘esc-map’は、<ESC>の後の文字のためのマップです。したがって、すべて
     のメタ文字がこのマップで定義されています。
   • ‘ctl-x-4-map’は、‘C-x 4’の後の文字のためのマップです。
   • ‘mode-specific-map’は、‘C-c’の後の文字のためのマップです。


File: emacs-ja.info,  Node: Local Keymaps,  Next: Minibuffer Maps,  Prev: Prefix Keymaps,  Up: Key Bindings

49.3.3 ローカルキーマップ
-------------------------

ここまではグローバルマップの詳細を説明してきました。メジャーモードは、
“ローカルキーマップ(local keymaps)”で独自のキーバインディングを提供する
ことにより、Emacsをカスタマイズします。たとえばCモードは、C言語のために
カレント行をインデントするために、<TAB>をオーバーライドします。マイナー
モードもローカルキーマップをもつことができます。マイナーモードが効力をも
つとき、マイナーモードのキーマップの定義は、メジャーモードのローカルキー
マップとグローバルキーマップの両方をオーバーライドします。それに加えて、
バッファーの一部のテキストに、他のすべてのキーマップをオーバーライドする
独自のキーマップを指定できます。

   ローカルキーマップは、あるキーをプレフィクスキーマップとして定義する
ことにより、そのキーをプレフィクスキーとして再定義できます。そのキーがグ
ローバルでもプレフィクスとして定義されている場合、そのキーのグローバルお
よびローカルの定義(両方のキーマップ)が、相乗して効果をもちます。つまりプ
レフィクスキーに続くイベントを探すのに、両方の定義が使用されます。たとえ
ばローカルキーマップが‘C-c’をプレフィクスキーマップとして定義し、そのキ
ーマップが‘C-z’をコマンドとして定義する場合、これは‘C-c C-z’にローカルな
意味を提供します。これは‘C-c’で始まる他のシーケンスには影響を与えません
。これらのシーケンスが独自のローカルバインディングをもたない場合、グロー
バルバインディングが効果をもちます。

   これを別の方法で考えると、Emacsはキーシーケンス全体のバインディングに
たいして、複数のキーマップを1つずつ探して、複数イベントキーシーケンスを
処理すると考えることができます。最初にマイナーモードが有効な場合はマイナ
ーモードのキーマップをチェックして、次にメジャーモードのキーマップをチェ
ックして、それからグローバルキーマップをチェックするのです。これはキーの
照合が機能する正確な方法ではありませんが、通常の場面における結果を理解す
るには充分です。


File: emacs-ja.info,  Node: Minibuffer Maps,  Next: Rebinding,  Prev: Local Keymaps,  Up: Key Bindings

49.3.4 ミニバッファーキーマップ
-------------------------------

ミニバッファーは独自のローカルキーマップのセットをもちます。これにはさま
ざまな補完やexitコマンドが含まれます。

   • ‘minibuffer-local-map’は、通常の入力(補完なし)に使用されます。
   • ‘minibuffer-local-ns-map’は同様ですが、<SPC>で<RET>と同じように
     exitします。
   • ‘minibuffer-local-completion-map’は、寛大な補完(permissive
     completion)のためのキーマップです。
   • ‘minibuffer-local-must-match-map’は、強い補完(strict completion)と
     慎重な補完(cautious completion)のためのキーマップです。
   • ‘minibuffer-local-filename-completion-map’と
     ‘minibuffer-local-filename-must-match-map’は、前の2つと同様ですが、
     特にファイル名補完のためのキーマップです。これらは<SPC>をバインドし
     ません。


File: emacs-ja.info,  Node: Rebinding,  Next: Init Rebinding,  Prev: Minibuffer Maps,  Up: Key Bindings

49.3.5 対話的なキーバインディングの変更
---------------------------------------

Emacsがキーを再定義する方法は、キーマップのそのキーのエントリーを変更す
る方法です。グローバルキーマップを変更できます。この場合すべてのメジャー
モードで変更が効果をもちます(ただし同じキーにたいしてそれをオーバーライ
ドする独自のローカルバインディングをもつ場合を除きます)。ローカルキーマ
ップを変更することもできます。これは同じメジャーモードを使用するすべての
バッファーに効果があります。

   このセクションでは、現在のEmacsセッションでキーをリバインドする方法を
説明します。将来のEmacsセッションで効果をもつようにキーをリバインドする
方法については、*note Init Rebinding::を参照してください。

‘M-x global-set-key <RET> KEY CMD <RET>’
     CMDを実行するKEYをグローバルに定義します。
‘M-x local-set-key <RET> KEY CMD <RET>’
     CMDを実行するKEYを、(そのとき効力をもつメジャーモードで)ローカルに
     定義します。
‘M-x global-unset-key <RET> KEY’
     グローバルマップでKEYを未定義にします。
‘M-x local-unset-key <RET> KEY’
     (そのとき効力をもつメジャーモードで)ローカルにKEYを未定義にします。

   たとえば以下は、通常の‘C-z’にたいするグローバルな定義を置き換えて、
‘C-z’を‘shell’コマンド(*note Interactive Shell::を参照してください)にバ
インドします:

     M-x global-set-key <RET> C-z shell <RET>

‘global-set-key’コマンドは、キーの後にコマンド名を読み取ります。キーを押
した後、以下のようなメッセージが表示されるので、そのキーにバインドしたい
コマンドを入力できます:

     Set key C-z to command:

   ファンクションキーとマウスイベントも同じ方法で再定義できます。リバイ
ンドするキーを指定するときに、ファンクションキーをタイプするか、マウスを
クリックするだけです。

   複数のイベントを含むキーも、同じ方法で再定義できます。Emacsは、(プレ
フィクスキーではない)完了キーまで、リバインドするキーの読み取りを続けま
す。したがってKEYに‘C-f’をタイプすると、それで完了です。これによりミニバ
ッファーに入って、すぐにCMDを読み取ります。しかし‘C-x’をタイプした場合、
これはプレフィクスなので、他の文字を読み取ります。それが‘4’の場合、これ
もプレフィクス文字なので、さらに文字を読み取ります。たとえば、

     M-x global-set-key <RET> C-x 4 $ spell-other-window <RET>

これは、(架空のコマンド)‘spell-other-window’を実行するように、‘C-x 4 $’を
再定義します。

   ‘global-unset-key’で、キーのグローバルな定義を削除できます。これはそ
のキーを“未定義(undefined)”にします。その後このキーをタイプしても、
Emacsはビープ音を鳴らすだけです。同様に‘local-unset-key’は、カレントメジ
ャーモードのキーマップでキーを未定義にして、メジャーモードにおいて、その
キーにたいするグローバル定義(またはグローバル定義に無い状態)が有効になり
ます。

   あるキーを再定義(または未定義に)してから、後でその変更を取り消したく
なった場合、キーを未定義にしても上手くいきません — そのキーを標準の定義
に再定義する必要があります。そのキーの標準の定義の名前を見つけるには、フ
レッシュなEmacsのFundamentalモードで、‘C-h c’を使用します。このマニュア
ルのキーのドキュメントにも、それらのコマンド名がリストされています。

   間違ってコマンドを呼び出すことから自分を守りたい場合、そのキーを未定
義にするより、コマンドを無効にするほうがよいでしょう。無効にされたコマン
ドは、実際にそれを実行したくなったとき、少しの手間で呼び出すことができま
す。*note Disabling::を参照してください。


File: emacs-ja.info,  Node: Init Rebinding,  Next: Modifier Keys,  Prev: Rebinding,  Up: Key Bindings

49.3.6 initファイル内でのキーのリバインド
-----------------------------------------

いつでも使いたいキーバインドがある場合、初期化ファイルにLispコードを記述
することにより、それらを指定できます。初期化ファイルの説明については、
*note Init File::を参照してください。

   Lispを使用してキーバインディングを記述するには、いくつかの方法があり
ます。一番簡単なのは‘kbd’関数を使う方法で、これはキーシーケンスのテキス
ト表現 — このマニュアルでキーシーケンスを記述するのと同様な方法 — を、
‘global-set-key’の引数として渡す形式に変換します。たとえば以下は、
‘C-z’を‘shell’コマンド(*note Interactive Shell::を参照してください)にバ
インドする方法の例です:

     (global-set-key (kbd "C-z") 'shell)

コマンド名‘shell’の前のシングルクォートは、それを変数ではなくシンボル定
数としてマークします。クォートを省略した場合、Emacsは‘shell’を変数として
評価しようとします。これはおそらくエラーを引き起こし、もちろんあなたはそ
れを望まないはずです。

   以下に、ファンクションキーやマウスイベントなどを含めた、追加の例を示
します:

     (global-set-key (kbd "C-c y") 'clipboard-yank)
     (global-set-key (kbd "C-M-q") 'query-replace)
     (global-set-key (kbd "<f5>") 'flyspell-mode)
     (global-set-key (kbd "C-<f5>") 'display-line-numbers-mode)
     (global-set-key (kbd "C-<right>") 'forward-sentence)
     (global-set-key (kbd "<mouse-2>") 'mouse-save-then-kill)

   ‘kbd’を使うかわりに、キーシーケンスの指定にLisp文字列やベクターを使用
することができます。文字列を使用するのは単純ですが、これはASCII文字とメ
タ修飾されたASCII文字だけで機能します。たとえば以下は、‘C-x M-l’を
‘make-symbolic-link’(*note Copying and Naming::を参照)にバインドする方法
の例です:

     (global-set-key "\C-x\M-l" 'make-symbolic-link)

   <TAB>、<RET>、<ESC>、<DEL>を含むキーシーケンスにバインドするには、文
字列はEmacs Lispのエスケープシーケンス‘\t’、‘\r’、‘\e’、‘\d’を含むべきで
す。以下は、‘C-x <TAB>’を‘indent-rigidly’(*note Indentation::を参照)にバ
インドする例です:

     (global-set-key "\C-x\t" 'indent-rigidly)

   キーシーケンスがファンクションキーやマウスボタンイベント、または
‘C-=’や‘H-a’のような非ASCII文字を含む場合、キーシーケンスを指定するのに
ベクターを使用することができます。ベクター内の各要素は入力イベントを意味
します。要素はスペースで区切られ、一対の角カッコ(square brackets)で囲ま
れます。ベクターの要素が文字の場合は、それをLisp文字定数、つまり‘?’の後
ろにその文字を、文字列内で表記されるような方法で記述します。ファンクショ
ンキーはシンボルで表され(*note Function Keys::を参照してください)、他の
区切り文字や句読点なしで、単にシンボル名を記述します。以下に例をいくつか
示します:

     (global-set-key [?\C-=] 'make-symbolic-link)
     (global-set-key [?\M-\C-=] 'make-symbolic-link)
     (global-set-key [?\H-a] 'make-symbolic-link)
     (global-set-key [f7] 'make-symbolic-link)
     (global-set-key [C-mouse-1] 'make-symbolic-link)

単純な場合でもベクターを使用できます:

     (global-set-key [?\C-z ?\M-l] 'make-symbolic-link)

   非ASCII文字にたいするキーバインディングは、言語とコーディングシステム
に問題を起こすかもしれません。 *note Init Non-ASCII::を参照してください
。

   *note Local Keymaps::で説明したように、メジャーモードとマイナーモード
はローカルキーマップを定義できます。これらのキーマップは、セッションで最
初にそのモードが使用されるときに構築されます。これらのキーマップを変更し
たい場合は、“モードフック(mode hook)”を使用しなければなりません(*note
Hooks::を参照してください)。

   たとえばTexinfoモードは、フック‘texinfo-mode-hook’を実行します。以下
はTexinfoモードで、‘C-c n’と‘C-c p’にローカルバインディングを追加するた
めに、どのようにフックを使用できるかの例です:

     (add-hook 'texinfo-mode-hook
               (lambda ()
                 (define-key texinfo-mode-map "\C-cp"
                             'backward-paragraph)
                 (define-key texinfo-mode-map "\C-cn"
                             'forward-paragraph)))


File: emacs-ja.info,  Node: Modifier Keys,  Next: Function Keys,  Prev: Init Rebinding,  Up: Key Bindings

49.3.7 修飾キー
---------------

Emacsでは、デフォルトのキーバインディングがセットアップされているので、
修飾されたアルファベット文字は大文字小文字が区別されません。つまり
‘C-A’は‘C-a’と同じことを行い、‘M-A’は‘M-a’と同じことを行ないます。これは
アルファベット文字だけに当てはまり、他のキーのシフトキーが押された
(shifted)バージョンには適用されません。たとえば、‘C-@’は‘C-2’と同じでは
ありません。

   <Control>修飾されたアルファベット文字は、常に大文字小文字が区別されま
せん。Emacsは常に‘C-A’を‘C-a’、‘C-B’を‘C-b’、...として扱います。これは歴
史的な理由によります。

   他の修飾キーでは、Emacsをカスタマイズするとき修飾されたアルファベット
の大文字小文字を区別するようにできます。たとえば‘M-a’と‘M-A’で別のコマン
ドを実行できます。

   一般的に使用される修飾キーは<Control>と<Meta>だけですが、Emacsは他の
修飾キーもサポートします。これらは<Super>、<Hyper>、<Alt>と呼ばれます。
これらの修飾キーを使用する方法を提供する端末の数は多くありません。ほとん
どのキーボードで<Alt>とラベルされたキーは、通常は<Alt>ではなく<Meta>修飾
を発行します。Emacsの標準のキーバインディングでは、これらのキーで修飾さ
れた文字は含まれません。しかしこれらに意味を割り当てるようにEmacsをカス
タマイズできます。修飾ビットは、それぞれ‘s-’、‘H-’、‘A-’になります。

   これらの追加的な修飾キーがキーボードになくても、‘C-x @’を使用して入力
できます。‘C-x @ h’はHyperフラグ、‘C-x @ s’はSuperフラグ、‘C-x @ a’は
Altフラグを次の文字に加えます。たとえば‘Hyper-Control-a’を入力するには、
‘C-x @ h C-a’とタイプします(残念なことに同じ文字にたいして‘C-x @’を使用
して、2つの修飾を追加する方法はありません。なぜなら最初の1つは2回目の
‘C-x’にたいして作用するからです)。


File: emacs-ja.info,  Node: Function Keys,  Next: Named ASCII Chars,  Prev: Modifier Keys,  Up: Key Bindings

49.3.8 ファンクションキーのリバインド
-------------------------------------

キーシーケンスには、通常の文字と同じようにファンクションキーを含めること
ができます。Lisp文字(実際は整数です)がキーボードの文字を表すように、
Lispシンボルはファンクションキーを表します。ファンクションキーのラベルに
示された単語が、それにタイプするLispシンボルの名前になります。以下は一般
的なファンクションキーにたいする、慣例的なLisp名です:

‘left’、‘up’、‘right’、‘down’
     カーソル矢印キーです。

‘begin’、‘end’、‘home’、‘next’、‘prior’
     その他のカーソルを再配置するキーです。

‘select’、‘print’、‘execute’、‘backtab’
‘insert’、‘undo’、‘redo’、‘clearline’
‘insertline’、‘deleteline’、‘insertchar’、‘deletechar’
     その他のファンクションキーです。

‘f1’、‘f2’、...、‘f35’
     (キーボード上部にある)番号つきのファンクションキーです。

‘kp-add’、‘kp-subtract’、‘kp-multiply’、‘kp-divide’
‘kp-backtab’、‘kp-space’、‘kp-tab’、‘kp-enter’
‘kp-separator’、‘kp-decimal’、‘kp-equal’
‘kp-prior’、‘kp-next’、‘kp-end’、‘kp-home’
‘kp-left’、‘kp-up’、‘kp-right’、‘kp-down’
‘kp-insert ’、‘kp-delete’
     (標準的なキーボードでは右側にある)キーパッドの名前や句読点のキーで
     す。

‘kp-0’、‘kp-1’、...、‘kp-9’
     キーパッドの数字キーです。

‘kp-f1’、‘kp-f2’、‘kp-f3’、‘kp-f4’
     キーパッドのPFキーです。

   これらの名前は便利ですが、いくつかのシステム(特にXを使用するシステム
)では、異なる名前を使用するかもしれません。端末のファンクションキーにた
いして、どのシンボルが使用されているか確認するには、‘C-h c’とタイプして
、その後にそのファンクションキーを入力してください。

   ファンクションキーにバインドする例については、*note Init Rebinding::を
参照してください。

   多くのキーボードの右手側には、テンキーボード(numeric keypad)がありま
す。キーパッドのテンキーは‘Num Lock’とラベルされたキーで切り替えるにこと
により、カーソル移動キーにもなります。デフォルトでは、Emacsはこれらのキ
ーを、メインのキーボードの対応するキーに変換します。たとえば‘Num Lock’が
オンの場合、テンキーのlabeled ‘8’のラベルがついたキーは‘kp-8’を生成し、
これは‘8’に変換されます。また‘Num Lock’がオフの場合、このキーは‘kp-up’を
生成し、これは<UP>に変換されます。‘8’や<UP>のようなキーをリバインドした
場合、それはキーパッドの対応するキーにも影響します。しかし直接‘kp-’をリ
バインドした場合、これはメインのキーボードの等価なキーに影響を与えません
。修飾されたキーは変換されないことに注意してください。たとえば<Meta>キー
を押したまま、テンキーの‘8’を押すと、これは‘M-<kp-8>’を生成します。

   Emacsは変数‘keypad-setup’、‘keypad-numlock-setup’、
‘keypad-shifted-setup’、‘keypad-numlock-shifted-setup’を使用することによ
り、テンキーのキーをバインドするための便利な方法を提供します。これらの変
数は‘keyboard’カスタマイズグループで見つけることができます(*note Easy
Customization::を参照してください)。キーをリバインドして、数引数を発行す
るなど、他のタスクを行なうことができます。


File: emacs-ja.info,  Node: Named ASCII Chars,  Next: Mouse Buttons,  Prev: Function Keys,  Up: Key Bindings

49.3.9 名前のあるASCIIコントロール文字
--------------------------------------

当初<TAB>、<RET>、<BS>、<LFD>、<ESC>、<DEL>は、特定のASCIIコントロール文
字の名前として使用され、多用されるために自身の特別なキーをもつようになり
ました。たとえば<TAB>は‘C-i’の別の名前です。その後、ユーザーはEmacsでこ
れらのキーと、<Ctrl>キーと一緒にタイプするコントロール文字を区別できると
便利なことに気づきました。したがってほとんどの現代的な端末では、これらは
同じではありません。つまり<TAB>は‘C-i’と異なります。

   これら2種類の入力を、キーボードが区別するなら、Emacsも区別することが
できます。Emacsは特別なキーを‘tab’、‘return’、‘backspace’、‘linefeed’、
‘escape’、‘delete’という名前のファンクションキーとして扱います。これらの
ファンクションキーは、そのキー自体に何もバインドされていない場合は、対応
するASCII文字に自動的に変換されます。結果として、ユーザーもLispプログラ
マーも、彼らがそうしたいと望まない限りは、これらの区別に注意を払う必要は
ありません。

   (たとえば)<TAB>と‘C-i’を区別したくない場合は、ASCII文字の<TAB>(8進コ
ード011)だけにたいしてバインディングを1つ指定します。これらを区別したい
ときは、ASCII文字にたいして1つのバインディング、ファンクションキーの
‘tab’にたいして別のバインディングを指定します。

   通常のASCII端末では、<TAB>と‘C-i’(および同じような他のペアー)を区別す
る方法はありません。なぜなら端末はどちらの場合も同じ文字を送るからです。


File: emacs-ja.info,  Node: Mouse Buttons,  Next: Disabling,  Prev: Named ASCII Chars,  Up: Key Bindings

49.3.10 マウスボタンのリバインド
--------------------------------

Emacsはマウスボタンを表すためにもLispシンボルを使用します。Emacsで通常の
マウスイベントは、“クリック(click)”イベントです。これはボタンを押して、
マウスを移動せずにボタンを離すと発生します。“ドラッグ(drag)”イベントも取
得できます。これはボタンを押したままマウスを移動したとき発生します。ドラ
ッグイベントは、最後にボタンを離したときにも発生します。

   基本的なクリックイベントにたいするシンボルは、一番左のボタンが
‘mouse-1’、次が‘mouse-2’、...となります。以下は、カレントウィンドウを2番
目のマウスボタンで分割するように再定義する方法です:

     (global-set-key [mouse-2] 'split-window-below)

   ドラッグイベントにたいするシンボルも同様ですが、単語‘mouse’の前にプレ
フィクス‘drag-’がつきます。たとえば左ボタンでのドラッグは
‘drag-mouse-1’イベントを生成します。

   マウスボタンが押されたときに発生するイベントにたいして、バインディン
グを定義することもできます。これらのイベントは‘drag-’ではなく‘down-’で始
まります。このようなイベントは、それらにキーがバインドされているときだけ
生成されます。ボタンダウンイベントを受け取った場合、その後に常にそれに対
応するクリックまたはドラッグイベントが続きます。

   もし望むならシングルクリック、ダブルクリック、トリプルクリックを区別
することもできます。ダブルクリックとは、マウスボタンをほぼ同じ場所で2回
クリックすることを意味します。最初のクリックは通常のクリックイベントを生
成します。2回目のクリックが充分早ければ、かわりにダブルクリックイベント
を生成します。ダブルクリックイベントにたいするイベントタイプは、たとえば
‘double-mouse-3’のように、‘double-’で始まります。

   これは同じ場所での2回目のクリックに特別な意味を与えることができること
を意味しますが、それは最初のクリックを受け取ったときに実行される、通常の
シングルクリックにたいする定義も実行されることを前提にしなければなりませ
ん。

   これはダブルクリックで行なえることを制限しますが、ユーザーインターフ
ェースデザイナーはこの制限は任意のケースにおいて従うべき制限だと言います
。ダブルクリックは、シングルクリックで行なう何かを、よりもっと行なうため
のものであるべきです。ダブルクリックイベントにたいするコマンドは、ダブル
クリックにたいして追加の作業を処理するべきです。

   ダブルクリックイベントにバインディングがない場合、これは対応するシン
グルクリックイベントに変化します。したがって、特にダブルクリックイベント
を定義していない場合、これはシングルクリックコマンドを2回実行します。

   Emacsはトリプルクリックイベントもサポートし、それらの名前は
‘triple-’で始まります。Emacsはクワドループルクリック(quadruple clicks:
4連クリック)をイベントタイプとして区別しません。3回目以降のクリックは、
追加のトリプルクリックイベントを生成します。しかしクリックされた数はすべ
てイベントリストに記録されるので、Emacs Lispを知っていて、本当にそれを使
いたい場合はそれらを区別できます(*note (elisp)Click Events::を参照してく
ださい)。わたしたちは3連クリックを超えるクリックに明確な意味を与えるのは
推奨しませんが、連続するクリックが同じ3つの意味のセットを巡回する — たと
えば4連クリックは1クリックに等しく、5連クリックは2連クリックに等しく、
6連クリックは3連クリックに等しい、とするのが便利なときがあるかもしれませ
ん。

   Emacsはドラッグおよびボタンダウンイベントで、複数回ボタンが押されたこ
とも記録します。たとえば、ボタンを2回押して、それからボタンを押したまま
マウスを移動した場合、Emacsは‘double-drag-’イベントを受け取ります。2回目
にボタンを押した瞬間、Emacsは‘double-down-’イベントを受け取ります(そして
すべてのボタンダウンイベントと同様に、なにもバインドされていなければ無視
されます)。

   変数‘double-click-time’は、複数回のクリックをグループ化するのに、クリ
ックの間にどれだけの時間経過を許すかを指定します。変数の値の単位はミリ秒
です。値が‘nil’の場合、ダブルクリックは検知されません。値が‘t’の場合、時
間の制限はありません。デフォルトは500です。

   変数‘double-click-fuzz’は、複数回のクリックをグループ化するのに、クリ
ックの間にどれだけマウスが移動できるかを指定します。変数の値はウィンドウ
化されたディスプレーではピクセル単位で、テキストモード端末では文字セルの
1/8を単位とし、デフォルトは3です。

   マウスイベントにたいするシンボルは、修飾キーの状態も示し、‘C-’、
‘M-’、‘H-’、‘s-’、‘A-’、‘S-’のプレフィクスが通常つきます。‘double-’や
‘triple-’は常に‘drag-’や‘down-’の前にきますが、これらのプレフィクスは常
にそれより前にきます。

   フレームにはバッファーのテキストを表示しない、モードラインやスクロー
ルバーのような領域が含まれます。スクリーンの特別な領域でマウスボタンが押
されたかどうかは、ダミーのプレフィクスキーで知ることができます。たとえば
モードラインでマウスをクリックした場合、通常のマウスボタンシンボルの前に
プレフィクスキー‘mode-line’を受け取ります。したがって、以下はモードライ
ンで左ボタンをクリックしたときに‘scroll-up-command’を実行する方法です:

     (global-set-key [mode-line mouse-1] 'scroll-up-command)

   以下はダミーのプレフィクスキーと、その意味の完全なリストです:

‘mode-line’
     マウスはウィンドウのモードラインにあります。
‘vertical-line’
     マウスは横に並んだウィンドウを分ける垂直ラインにあります(スクロール
     バーを使用している場合は、垂直ラインに表示されます)。
‘vertical-scroll-bar’
     マウスは垂直スクロールバーにあります(これはEmacsが現在サポートして
     いるスクロールバーにたいしてだけです)。
‘menu-bar’
     マウスはメニューバーにあります。
‘header-line’
     マウスはヘッダーラインにあります。

   キーシーケンスにマウスボタンを複数配することもできますが、これは通常
行なわれません。


File: emacs-ja.info,  Node: Disabling,  Prev: Mouse Buttons,  Up: Key Bindings

49.3.11 コマンドの無効化
------------------------

コマンドを無効にするとは、そのコマンドを対話的に呼び出しユーザーに確認を
求めることを意味します。コマンドを無効にする目的は、ユーザーが間違ってコ
マンドを実行するのを防ぐためです。わたしたちは初心者を混乱させるようなコ
マンドにたいして、これを行なっています。

   無効なコマンドを呼び出そうとすると、Emacsはコマンド名、コマンドのドキ
ュメント、すぐに何を行なうかの手引きを対話的に表示します。その後、
Emacsはコマンドを要求されたとおり実行するか、そのコマンドを有効にしてか
ら実行するか、キャンセルするか入力を求めます。コマンドを有効にすると決め
た場合は、他の質問 — 永続的に有効にするか、それともカレントセッションで
だけ有効にするか — にも応えなければなりません(永続的に有効にする場合、こ
れは自動的に初期化ファイルを編集することにより機能します)。‘!’とタイプし
て、カレントセッションだけにたいして、_すべて_のコマンドを有効にすること
もできます。

   コマンド無効化の直接的なメカニズムは、コマンドにたいするLispシンボル
の‘disabled’プロパティーに非‘nil’をputすることです。以下はこれを行なう
Lispプログラムです:

     (put 'delete-region 'disabled t)

   ‘disabled’プロパティーの値が文字列の場合、その文字列はコマンドが使用
されたときに表示されるメッセージに含まれます。

     (put 'delete-region 'disabled
          "It's better to use `kill-region' instead.\n")

   初期化ファイルを直接編集するか、初期化ファイルを編集する‘M-x
disable-command’コマンドにより、コマンドを無効にできます。同様に‘M-x
enable-command’はコマンドを永続的に有効にするために、初期化ファイルを編
集します。*note Init File::を参照してください。

   Emacsが‘-q’または‘--no-init-file’オプション(*note Initial Options::を
参照してください)で呼び出された場合、これらのコマンドは初期化ファイルを
編集しません。Emacsは初期化ファイルを読み込んでいないので、これを行なう
と情報が失われるかもしれないからです。

   コマンドが無効にされているかどうかは、それを呼び出すのに使用されるキ
ーとは独立しています。‘M-x’を使用してコマンドを呼び出しても、無効化は適
用されます。しかしLispプログラムから関数として呼び出す場合、コマンドの無
効化は効力をもちません。


File: emacs-ja.info,  Node: Init File,  Prev: Key Bindings,  Up: Customization

49.4 Emacs初期化ファイル
========================

Emacsを開始したとき、Emacsは通常、“初期化ファイル(initialization file)”、
短くは“initファイル”から、Lispプログラムのロードを試みます。このファイル
は、もし存在する場合は、Emacsをどのように初期化するかを指定します。
Emacsはファイル名‘~/.emacs’、‘~/.emacs.el’、‘~/.emacs.d/init.el’を使用し
てinitファイルを探します。これら3つのファイル名から、使用するものを選択
できます(*note Find Init::を参照してください)。ここで‘~/’は、ホームディ
レクトリーを意味します。

   コマンドラインスイッチ‘-q’により、initファイルのロードを抑止でき、
‘-u’ (または‘--user’)で、別のユーザーのinitファイルを指定できます(*note
Initial Options::を参照してください)。

   “デフォルトinitファイル”が存在する場合もあります。これは
‘default.el’という名前のライブラリーで、ライブラリーにたいする標準の検索
パスから探されます。Emacsディストリビューションには、そのようなライブラ
リーは含まれていませんが、あなたのサイトは、ローカルなカスタマイズのため
にこれを作成しているかもしれません。このライブラリーが存在する場合、
Emacsを開始したときは常にこれがロードされます(ただし‘-q’を指定した場合は
除きます)。しかしinitファイルがあれば、それが最初にロードされるので、そ
こで‘inhibit-default-init’に非‘nil’をセットすれば、‘デフォルトinitファイ
ル’はロードされません。

   あなたのサイトには“サイトスタートアップファイル(site startup file)”も
あるかもしれません。もし存在する場合、これは‘site-start.el’という名前で
す。‘default.el’と同様に、Emacsはこのファイルを、Lispライブラリーにたい
する標準の検索パスから探します。Emacsはこのライブラリーをinitファイルの
前にロードします。このライブラリーのロードを抑止するには、オプション
‘--no-site-file’を使用します。*note Initial Options::を参照してください
。わたしたちは何かを変更する場合、‘site-start.el’の使用を推奨しません。
これを好まないユーザーもいるからです。変更を‘default.el’に記述すれば、ユ
ーザーはもっと簡単にそれをオーバーライドできます。

   ‘default.el’や‘site-start.el’は、EmacsがLispライブラリーを検索する任
意のディレクトリーに配置できます。変数‘load-path’ (*note Lisp
Libraries::を参照してください)は、これらのディレクトリーを指定します。多
くのサイトはこれらのファイルを、Emacsのインストールディレクトリーの中の
、‘site-lisp’(たとえば‘/usr/local/share/emacs/site-lisp’)に配置します。

   initファイルにたいするバイトコンパイル(*note Byte Compilation:
(elisp)Byte Compilation.を参照してください)は推奨されていません。一般的
にこれは開始時のスピードの大幅な改善はせず、ファイルをリコンパイルするの
を忘れたときに問題を起こすことが多いのです。よりよい解決策は、Emacsサー
バー(*note Emacs Server::を参照してください)を使用して、Emacsを開始する
回数を減らすことです。initファイルで多くの関数を定義している場合、これら
を(バイトコンパイルされた)別のファイルに移動して、それをinitファイルでロ
ードします。

   マイナーなカスタマイズを超えるような、実際のEmacs Lispプログラムを記
述するつもりなら、‘Emacs Lisp Reference Manual’を読むべきでしょう。
*note Emacs Lisp: (elisp)Top.を参照してください。

* Menu:

* Init Syntax::              Emacs Lispでの定数の構文。
* Init Examples::            initファイルで何かを行なう方法。
* Terminal Init::            端末タイプごとのinitファイル。
* Find Init::                Emacsがinitファイルを探す方法について。
* Init Non-ASCII::           initファイルでの非ASCII文字の使用。


File: emacs-ja.info,  Node: Init Syntax,  Next: Init Examples,  Up: Init File

49.4.1 initファイルの構文
-------------------------

initファイルには、1つ以上のLisp式が含まれています。式のそれぞれは引数を
ともなう関数名で、それらはすべてカッコで括られています。たとえば‘(setq
fill-column 60)’は、変数‘fill-column’(*note Filling::を参照してください
)を60にセットするために、関数‘setq’を呼び出します。

   ‘setq’で任意のLisp変数をセットできますが、‘.emacs’の特定の変数にたい
して、‘setq’は多分あなたの望むとおりには動作しないでしょう。いくつかの変
数は‘setq’でセットしたとき、自動的にバッファーローカルになります。あなた
が望むのは、‘.emacs’でデフォルト値をセットすることなので、
‘setq-default’を使用します。マイナーモードのカスタマイズ可能な変数のいく
つかは、それをCustomizeでセットすると、そのモードを有効にするために特別
なことを行ないますが、通常の‘setq’ではそれを行ないません。‘.emacs’ファイ
ルでモードを有効にするには、マイナーモードコマンドを呼び出します。以下の
セクションには、これらの両方の方法の例があります。

   ‘setq’の2番目の引数は、変数にたいする新しい値の式です。これには、定数
、変数、関数呼び出し式を指定できます。‘.emacs’では、定数が使用される場合
がほとんどです。これは以下のとおりです:

数字:
     数字は10進で記述され、オプションで最初にマイナス記号がある場合があ
     ります。

文字列:
     Lispの文字列構文は、少数の例外を除き、Cの文字列構文と同じです。文字
     列定数の開始と終了にはダブルクォートを使用します。

     文字列には改行を含む、特別なリテラル文字を含めることができます。し
     かし、それらにたいして、バックスラッシュシーケンスを使う方が明確に
     なる場合が多くあります。改行は‘\n’、バックスペースは‘\b’、キャリッ
     ジリターンは‘\r’、タブは‘\t’、フォームフィード(control-L)は‘\f’、エ
     スケープは‘\e’、バックスラッシュは‘\\’、ダブルクォートは‘\"’、そし
     て8進コードがOOOの文字は‘\OOO’です。バックスラッシュとダブルクォー
     トだけは、バックスラッシュシーケンスが必須な文字です。

     ‘\C-’はコントロール文字のプレフィクスとして使用でき、‘\C-s’は
     ASCIIのcontrol-Sです。‘\M-’はメタ文字のプレフィクスとして使用でき、
     ‘\M-a’は‘<Meta>-A’で、‘\M-\C-a’は‘<Ctrl>-<Meta>-A’です。

     initファイルに非ASCII文字を含めるための情報は、*note Init
     Non-ASCII::を参照してください。

文字:
     Lispの文字定数の構文は、たとえば‘?x’、‘?\n’、‘?\"’、‘?\)’のように、
     文字‘?’と、その後ろに文字または‘\’で始まるエスケープシーケンスから
     なります。Lispでは、文字列と文字は置き換え可能ではないことに注意し
     てください。あるコンテキストでは一方が、他のコンテキストでは他方が
     要求されます。

     非ASCII文字を送るキーにコマンドをバインドする情報については、*note
     Init Non-ASCII::を参照してください。

True:
     ‘t’は“true(真)”という意味です。

False:
     ‘nil’は“false(偽)”という意味です。

その他のLispオブジェクト:
     シングルクォートに続けてLispオブジェクトを記述します。


File: emacs-ja.info,  Node: Init Examples,  Next: Terminal Init,  Prev: Init Syntax,  Up: Init File

49.4.2 initファイルの例
-----------------------

以下はLisp式で一般的に行ないたいような事柄の例です:

   • 変数‘load-path’にディレクトリーを追加します。その後、Emacsに含まれ
     ていないLispライブラリーをそのディレクトリーに配置すれば、‘M-x
     load-library’でそれらをロードすることができます。*note Lisp
     Libraries::を参照してください。

          (add-to-list 'load-path "/path/to/lisp/libraries")

   • Cモードで、ポイントが行の途中にある場合、<TAB>が単にタブを挿入する
     ようにします。

          (setq c-tab-always-indent nil)

     個の例では、変数の通常の値が‘t’、つまり“true”の変数の値を、‘nil’つ
     まり“false”にしています。

   • (この設定をオーバーライドしないすべてのバッファーで)検索のデフォル
     トを、大文字小文字を区別させるようにします。

          (setq-default case-fold-search nil)

     これはデフォルト値をセットし、この変数にたいするローカル値(*note
     Locals::を参照してください)をもたないすべてのバッファーに効果を及ぼ
     します。‘case-fold-search’を‘setq’でセットした場合は、カレントバッ
     ファーだけに効果があり、それは多分あなたがinitファイルで行ないたい
     ことではないはずです。

   • Emacsがあなたのメールアドレスを正しく推測できない場合、メールアドレ
     スを指定します。

          (setq user-mail-address "cheney@torture.gov")

     Messageモードのような、さまざまなEmacsパッケージは、メールアドレス
     を知る必要がある場合に、‘user-mail-address’を参照します。*note Mail
     Headers::を参照してください。

   • 新しいバッファーにたいするデフォルトのモードをTextモードにします。

          (setq-default major-mode 'text-mode)

     Textモードに入るコマンドに‘text-mode’が使用されていることに注意して
     ください。前のシングルクォートはシンボルを定数にしています。そうし
     ない場合、‘text-mode’は変数名として扱われます。

   • 西ヨーロッパのほとんどの言語をサポートするLatin-1文字を、デフォルト
     にセットアップします。

          (set-language-environment "Latin-1")

   • グローバルなマイナーモードのLine Numberモードをオフに切り替えます。

          (line-number-mode 0)

   • Textモードと関連するモードで、自動的にAuto Fillモードをオンに切り替
     えます(*note Hooks::を参照してください)。

          (add-hook 'text-mode-hook 'auto-fill-mode)

   • インストールされた‘foo’という名前のライブラリー(実際には標準の
     Emacsディレクトリーの‘foo.elc’または‘foo.el’というファイル)をロード
     します。

          (load "foo")

     ‘load’の引数が、‘/’や‘~’で始まらない相対ファイル名の場合、‘load’は
     ‘load-path’のディレクトリーを検索します(*note Lisp Libraries::を参
     照してください)。

   • ホームディレクトリーの、コンパイルされたLispファイル‘foo.elc’をロー
     ドします。

          (load "~/foo.elc")

     ここでは完全なファイル名が使用されているので、検索は行なわれません
     。

   • ‘mypackage’という名前のLispライブラリー(たとえば‘mypackage.elc’や
     ‘mypackage.el’というファイル)をロードすることにより、関数
     ‘myfunction’の定義を探すようEmacsに指示します。

          (autoload 'myfunction "mypackage" "Do what I say." t)

     ここで文字列‘"Do what I say."’は、この関数のドキュメント文字列です
     。これを‘autoload’定義の中で指定することにより、そのパッケージがロ
     ードされていなくてもヘルプコマンドで利用可能になります。最後の引数
     ‘t’は、この関数がinteractive(対話的)であることを示します。つまり、
     この関数は‘M-x myfunction <RET>’とタイプするか、キーにバインドする
     ことにより、対話的に呼び出すことができます。関数がinteractiveでない
     場合は、‘t’を省略するか、‘nil’を使用します。

   • 関数‘make-symbolic-link’を実行するように、キー‘C-x l’をリバインドし
     ます(*note Init Rebinding::を参照してください)。

          (global-set-key "\C-xl" 'make-symbolic-link)

     または

          (define-key global-map "\C-xl" 'make-symbolic-link)

     繰り返しになりますが、シングルクォートは‘make-symbolic-link’を変数
     として値を参照するのではなく、シンボルとして参照するために使用され
     ることに注意してください。

   • Lispモードだけで、同じことを行ないます。

          (define-key lisp-mode-map "\C-xl" 'make-symbolic-link)

   • Fundamentalモードで‘next-line’を実行するすべてのキーにたいして、か
     わりに‘forward-line’を実行するように再定義します。

          (substitute-key-definition 'next-line 'forward-line
                                     global-map)

   • ‘C-x C-v’を未定義にします。

          (global-unset-key "\C-x\C-v")

     キーを未定義にする1つの理由は、それをプレフィクスにできることです。
     単に‘C-x C-v ANYTHING’を定義すると、‘C-x C-v’はプレフィクスになりま
     すが、最初に通常の‘C-x C-v’にたいする非プレフィクス定義を開放しなけ
     ればなりません。

   • Textモードで‘$’に句読点構文をもたせます。‘$’にたいする文字定数の使
     い方に注意してください。

          (modify-syntax-entry ?\$ "." text-mode-syntax-table)

   • 確認なしでの、コマンド‘narrow-to-region’の使用を有効にします。

          (put 'narrow-to-region 'disabled nil)

   • さまざまなプラットフォームとEmacsバージョンにたいして、設定を調整し
     ます。

     ユーザーは通常、すべてのシステムでEmacsが同じように振る舞うことを期
     待するので、すべてのプラットフォームで同じinitファイルを使用するの
     が妥当です。しかしEmacsをカスタマイズするのに使用する関数が、他のプ
     ラットフォームやEmacsバージョンで利用できないということも発生します
     。この状況に対処するには、以下のように、ある関数または機能が利用可
     能かテストする条件文の内部に、カスタマイズを配置します:

          (if (fboundp 'blink-cursor-mode)
              (blink-cursor-mode 0))

          (if (boundp 'coding-category-utf-8)
              (set-coding-priority '(coding-category-utf-8)))

     関数が定義されていない場合に発生するエラーを、単に無視することもで
     きます。

          (ignore-errors (set-face-background 'region "grey75"))

     存在しない変数への‘setq’は一般的に無害なので、これらを条件文の中に
     置く必要はありません。


File: emacs-ja.info,  Node: Terminal Init,  Next: Find Init,  Prev: Init Examples,  Up: Init File

49.4.3 端末固有の初期化
-----------------------

各端末タイプは、Emacsをその端末タイプで実行するときEmacsにロードされる
Lispライブラリーをもつことができます。TERMTYPEという名前の端末タイプにた
いして、そのライブラリーは‘term/TERMTYPE’と呼ばれます
(‘term-file-aliases’の連想配列(association list)の中に‘(TERMTYPE .
ALIAS)’という形式のエントリーがある場合、EmacsはTERMTYPEのところに
ALIASを使用します)。このライブラリーは通常のようにディレクトリー
‘load-path’を検索することにより見つけられ、サフィックスは‘.elc’と‘.el’で
す。通常はほとんどのEmacsライブラリーがあるディレクトリーの、サブディレ
クトリー‘term’にあります。

   端末固有ライブラリーの通常の目的は、‘input-decode-map’ (または、その
前に‘function-key-map’)を使用して、その端末のファンクションキーで使用さ
れるエスケープシーケンスを、より意味のある名前にマップすることです。これ
がどのように行なわれるかの例は、ファイル‘term/lk201.el’を参照してくださ
い。多くのファンクションキーは、Termcapデータベースの情報にしたがい、自
動的にマップされます。端末固有ライブラリーは、Termcapが指定しないファン
クションキーだけをマップすればよいのです。

   端末タイプがハイフンを含む場合、最初のハイフンの前の部分だけが、ライ
ブラリーの選択で意味をもちます。したがって端末タイプ‘aaa-48’と
‘aaa-30-rv’は、両方ともライブラリー‘term/aaa’を使用します。ライブラリー
内のコードは、‘(getenv "TERM")’を使用して、完全なタイプ名を取得できます
。

   ライブラリーの名前は、変数‘term-file-prefix’の値と、端末タイプを結合
することにより構築されます。‘.emacs’で‘term-file-prefix’を‘nil’にセット
することにより、端末固有ライブラリーのロードを抑止できます。

   Emacsは初期化の最後、‘.emacs’と端末固有ライブラリーの両方が読み込まれ
た後に、フック‘tty-setup-hook’を実行します。端末固有ライブラリーの任意の
部分をオーバーライドしたい場合や、ライブラリーをもたない端末の初期化を定
義したい場合は、このフックにフック関数を追加します。*note Hooks::を参照
してください。


File: emacs-ja.info,  Node: Find Init,  Next: Init Non-ASCII,  Prev: Terminal Init,  Up: Init File

49.4.4 Emacsがinitファイルを探す方法
------------------------------------

Emacsは通常、‘.emacs’を探すために環境変数‘HOME’ (*note HOME: General
Variables.を参照してください)を使用します。これはファイル名での‘~’を意味
します。‘~/’の中に‘.emacs’(または‘.emacs.el’)が見つからない場合、Emacsは
‘~/.emacs.d/init.el’(‘~/.emacs.el’と同様に、バイトコンパイルされている可
能性があります)を探します。

   しかし、‘su’により開始されたシェルからEmacsを実行する場合、Emacsは現
在の見かけのユーザーではなく、あなた自身の‘.emacs’を探すことを試みます。
このアイデアは、たとえスーパーユーザーとして実行しているときでも、自分の
エディターカスタマイズを取得するべきだという考えです。

   より正確には、最初にEmacsはどのユーザーのinitファイルを使用するか決定
します。Emacsは環境変数‘LOGNAME’と‘USER’からユーザー名を取得します。どち
らも存在しない場合、実効ユーザーIDを使用します。ユーザー名が実ユーザー
IDとマッチしたとき、Emacsは‘HOME’を使用します。そうでない場合、Emacsはシ
ステムのユーザーデータベースの、そのユーザー名に対応するホームディレクト
リーを探します。


File: emacs-ja.info,  Node: Init Non-ASCII,  Prev: Find Init,  Up: Init File

49.4.5 initファイル内の非ASCII文字
----------------------------------

initファイルの文字列やキーバインディングに、アクセントつき文字などの非
ASCII文字が含まれる場合、それは言語やコーディングシステムに問題を起こす
かもしれません。

   initファイルで非ASCII文字を使用したい場合、initファイルの最初の行に
‘-*-coding: CODING-SYSTEM-*-’タグを配して、問題となる文字をサポートする
コーディングシステムを指定するべきです。*note Recognize Coding::を参照し
てください。なぜなら、非ASCIIテキストのでコーディングにたいするにたいす
るデフォルトのコーディングシステムは、Emacsがinitファイルでそのような文
字列を使用する個所を読み込むまでに、セットアップされていないかもしれない
ので、Emacsがその文字列を間違ってデコードする可能性があるからです。
‘-*-coding: CODING-SYSTEM-*-’を記述した場合、
‘set-language-environment’を呼び出す等、他の方法でコーディングシステムを
変更するEmacs Lispコードの追加は避けるべきです。

   非ASCIIキーをバインドするには、ベクターを使用しなければなりません
(*note Init Rebinding::を参照してください)。非ASCII文字はメタキーとして
解釈されるので、文字列構文は使用できません。たとえば:

     (global-set-key [?CHAR] 'some-function)

CHARを挿入するには、‘C-q’とタイプしてからバインドしたいキーをタイプしま
す。


File: emacs-ja.info,  Node: Quitting,  Next: Lossage,  Prev: Customization,  Up: Top

50 中止と中断
*************

‘C-g’
‘C-<Break> (MS-DOSのみ)’
     quit(中止): コマンドの実行、または途中までタイプしたコマンドをキャ
     ンセルします。
‘C-]’
     最内の再帰編集レベル(recursive editing level)をabort(中断)して、そ
     れを呼び出したコマンドをキャンセルします(‘abort-recursive-edit’)。
‘<ESC> <ESC> <ESC>’
     quitまたはabortのどちらか、意味のあるほうを行ないます
     (‘keyboard-escape-quit’)。
‘M-x top-level’
     現在実行中のすべての再帰編集レベルをabortします。
‘C-/’
‘C-x u’
‘C-_’
     バッファー内容にたいする直前の変更をキャンセルします(‘undo’)。

   完了する前のコマンドをキャンセルする方法は2つあります。それは‘C-g’に
よる“quit”と、‘C-]’や‘M-x top-level’による“abort”です。quitは途中までタ
イプしたコマンド、または実行中のコマンドをキャンセルします。abortは再帰
編集レベルを抜けて、再帰編集を呼び出したコマンドをキャンセルします(*note
Recursive Edit::を参照してください)。

   ‘C-g’によるquitは、途中までタイプしたコマンドから抜けたり、望まない数
引数から抜け出す方法です。さらに、あるコマンドが実行中の場合、‘C-g’は比
較的安全にコマンドを停止します。たとえば、長い時間がかかるkillコマンドを
quitした場合、_すべて_のテキストがバッファーに残るか、または_すべて_のテ
キストがkillリングに残るか、もしかしたらその両方かもしれません。リージョ
ンがアクティブの場合、Transient Markモードがオフでなければ、‘C-g’はマー
クを非アクティブにします(*note Disabled Transient Mark::を参照してくださ
い)。インクリメンタル検索の途中では、‘C-g’は特別に振る舞います。検索を抜
けるには2回連続して‘C-g’をタイプします。詳細は、*note Incremental
Search::を参照してください。

   MS-DOSでは、文字‘C-<Break>’が‘C-g’のような文字の役割をします。
MS-DOSではユーザーとの相互作用を行なうとき以外に、実行中のコマンドで
‘C-g’を認識できないのが理由です。それとは対照的に、‘C-<Break>’は常に認識
できます。 *note MS-DOS Keyboard::を参照してください。

   ‘C-g’をタイプした瞬間に変数‘quit-flag’を‘t’にセットすることにより、
‘C-g’は機能します。Emacs Lispはこの変数を頻繁にチェックして、これが非
‘nil’のときはquitします。Emacsが入力待ちのときにタイプしたときだけ、
‘C-g’は実際にコマンドとして実行されます。この場合に実行されるコマンドは
、‘keyboard-quit’です。

   テキスト端末では、最初の‘C-g’が認識される前に2回目の‘C-g’でquitした場
合は、emergency escape(緊急エスケープ)機能がアクティブになり、シェルに戻
ります。*note Emergency Escape::を参照してください。

   quitできない状況もいくつか存在します。Emacsがオペレーティングシステム
が何か行なうのを待つような場合、待ちが発生する箇所で特定のシステムコール
にたいして、Emacsが特別な対処をしない場合、quitは不可能です。ユーザーが
quitしたいと望むようなシステムコールにたいして、わたしたちはこれを行なっ
ていなすが、それでも処理できないケースに出会う場合もあります。とても一般
的なケースの1つは、NFSを使用したファイルへの入出力待ちです。Emacs自体は
quitする方法を知っていますが、多くのNFS実装は、NFSサーバーがハングしたと
き、ユーザープログラムがNFSを待つのを止めることを、単に許していません。

   ‘C-]’ (‘abort-recursive-edit’)によるabortは、再帰編集レベルを抜けて、
それを呼び出したコマンドをキャンセルするのに使用されます。‘C-g’による
quitはこれを行なわず、行なうこともできません。なぜならこれは再帰編集レベ
ルの_中_で、途中までタイプされたコマンドをキャンセルするからです。どちら
の操作も有用です。たとえば再帰編集中に、数引数を入力するために‘C-u 8’と
タイプした場合、‘C-g’でその引数をキャンセルして、その再帰編集レベルに留
まることができます。

   シーケンス‘<ESC> <ESC> <ESC>’ (‘keyboard-escape-quit’)は、quitか
abortのどちらかを呼び出します(多くのPCプログラムで<ESC>は“抜け出す”こと
を意味するので、このような定義にしました)。これは‘C-g’のように、プレフィ
クス引数のキャンセル、選択されたリージョンのクリアー、また問い合わせつき
置換から抜け出すこともできます。また‘C-]’のように、ミニバッファーから抜
け出したり、再帰編集から抜け出すこともできます。これは‘C-x 1’のように、
フレームの複数ウィンドウ分割から抜け出すこともできます。これが行なうこと
ができないのは、実行中のコマンドの停止です。これは通常のコマンドとして実
行されるので、Emacsが次のコマンドのために準備ができるまで、これを認識し
ないからです。

   コマンド‘M-x top-level’は、現在の再帰編集レベルからすべての再帰編集レ
ベルを抜けるための、充分な回数の‘C-]’コマンドと等価です。ミニバッファー
がアクティブなときは、ミニバッファーも抜けます。‘C-]’は、1度に1レベル再
帰編集レベルを抜けますが、‘M-x top-level’は、1度ですべての再帰編集レベル
を抜けます。‘C-]’と‘M-x top-level’の両方とも、他のすべてのコマンドと同様
(そして‘C-g’とは異なり)、Emacsがコマンドにたいして準備ができているときだ
け効果があります。‘C-]’は通常のキーで、このキーが意味をもつのは、それが
キーマップでバインドされているときだけです。*note Recursive Edit::を参照
してください。

   厳密に言えば‘C-/’ (‘undo’)はキャンセルコマンドではありませんが、すで
に実行を終えたコマンドをキャンセルすると考えることができます。undo機能に
ついての詳細は、*note Undo::を参照してください。


File: emacs-ja.info,  Node: Lossage,  Next: Bugs,  Prev: Quitting,  Up: Top

51 Emacsのトラブルへの対処
**************************

このセクションでは、キーボードコードのミクスアップ(mixup)、文字化け、メ
モリー不足、クラッシュやハングなど、Emacsが期待したとおりに動作しない状
況の認識と対処法について説明します。

   Emacsでバグを見つけたと思ったら何をすればよいかについては、*note
Bugs::を参照してください。

* Menu:

* DEL Does Not Delete::      <DEL>で削除できないとき、何を行なうべきか。
* Stuck Recursive::          モードラインのカッコの周囲の’[...]’。
* Screen Garbled::           画面上のゴミ。
* Text Garbled::             テキストの中のゴミ。
* Memory Full::              メモリー不足に対処する方法。
* Crashing::                 クラッシュ時にEmacsが何を行なうか。
* After a Crash::            クラッシュしたEmacsセッションでの編集をリカバリーする。
* Emergency Escape::         Emacsが応答しなくなったとき、何を行なうべきか。


File: emacs-ja.info,  Node: DEL Does Not Delete,  Next: Stuck Recursive,  Up: Lossage

51.1 <DEL>で削除できない場合
============================

すべてのキーボードには多くのキーがありますが、通常<BACKSPACE>とラベルさ
れたキーは、最後にタイプした文字を削除するのに使用されます。Emacsでは、
このキーは<DEL>に等しいと想定されています。

   グラフィカルなディスプレーでEmacsを開始したとき、Emacsはどのキーが
<DEL>なのか自動的に決定します。いくつかの特殊なケースでは、Emacsがシステ
ムから間違った情報を取得して、<BACKSPACE>が後方ではなく前方に削除する場
合があります。

   <Delete>というキーをもつキーボードもあります。これは通常、前方に削除
するために使用されます。Emacsでこのキーが後方に削除を行なう場合も、
Emacsが間違った情報 — ただし反対の意味の — を受け取ったことを意味します
。

   テキスト端末で、<BACKSPACE>が文字を削除するかわりに、‘Control-h’のよ
うなヘルプコマンドのプロンプトを表示する場合、それはこのキーが実際は
‘BS’文字を送っていることを意味します。Emacsは<BS>を<DEL>と扱うべきですが
、そうしていないのです。

   これらのケースのすべてにおいて、直ちに改善できることは同じでで、それ
はコマンド‘M-x normal-erase-is-backspace-mode’を使用する方法です。これは
Emacsが<DEL>の処理をサポートする2つのモードを切り替えるので、もしEmacsが
間違ったモードで開始された場合、正しいモードに切り替えることができます。
テキスト端末では、<BS>が<DEL>として扱われる場合にヘルプを見たいときは、
‘C-h’のかわりに<F1>を使用します。‘C-?’が文字コード127を送る場合は、この
キーも機能するでしょう。

   すべてのEmacsセッションで問題を解決するには、初期化ファイル(*note
Init File::を参照してください)に以下の行の1つを記述します。上記の最初の
ケースでは、<BACKSPACE>が後方ではなく前方に削除を行なうので、
<BACKSPACE>が<DEL>として動作するように、以下の行を使用します:

     (normal-erase-is-backspace-mode 0)

他の2つのケースでは、以下の行を使用します:

     (normal-erase-is-backspace-mode 1)

   すべてのEmacsセッションで問題を解決する別の方法は、変数
‘normal-erase-is-backspace’をカスタマイズする方法です。<BS>または
<BACKSPACE>が<DEL>となるようにモードを指定するには値‘t’、他のモードにた
いしては‘nil’を指定します。*note Easy Customization::を参照してください
。


File: emacs-ja.info,  Node: Stuck Recursive,  Next: Screen Garbled,  Prev: DEL Does Not Delete,  Up: Lossage

51.2 再帰編集レベル
===================

再帰編集レベルは、Emacsの重要かつ便利な機能ですが、それを理解していない
場合は、うまく機能していないように見えるかもしれません。

   モードラインの、メジャーモードやマイナーモードを囲む丸カッコ
(parentheses)の周囲に、角カッコ(square brackets)‘[...]’がある場合、それ
は再帰編集レベルにいることを意味します。もしこれが目的でない場合、または
その意味を理解していない場合は、すぐに再帰編集レベルを抜けるべきです。こ
れを行なうには、‘M-x top-level’とタイプします。*note Recursive Edit::を
参照してください。


File: emacs-ja.info,  Node: Screen Garbled,  Next: Text Garbled,  Prev: Stuck Recursive,  Up: Lossage

51.3 スクリーン上のゴミ
=======================

テキスト端末でテキストが間違って見える場合、まず行なうことはバッファーの
テキストが間違っていないか確かめることです。画面全体を再描画するために、
‘C-l’ (‘recenter-top-bottom’)とタイプしてください。この後でスクリーンが
正常に表示される場合、問題は前のスクリーンの更新にあります(そうでない場
合は、以下のセクションを参照してください)。

   ディスプレー更新の問題は、使用している端末にたいする間違った
terminfoエントリーの結果であることがしばしばあります。Emacsディストリビ
ューションのファイル‘etc/TERMS’は、この種の既知の問題にたいする解決を与
えます。‘INSTALL’のセクションの中の1つは、これらの問題にたいする一般的な
アドバイスを含みます。正しいterminfoエントリーを使用しているようなら、そ
れはterminfoエントリーにバグがあるか、特定の端末タイプで発生するEmacsの
バグである可能性があります。


File: emacs-ja.info,  Node: Text Garbled,  Next: Memory Full,  Prev: Screen Garbled,  Up: Lossage

51.4 テキスト内のゴミ
=====================

‘C-l’がそのテキストが間違っていることを示す場合、最初に実際の結果を生成
するのに何のコマンドをタイプしたか見るために、‘C-h l’ (‘view-lossage’)と
タイプします。それから‘C-x u’ (‘undo’)を使用して、正しいと思える状態まで
、1つずつ変更をundoします。

   バッファーの先頭または最後の大量のテキストが失われているように見える
場合は、モードラインに単語‘Narrow’が表示されていないかチェックします。も
しこれが表示されている場合、表示されていないテキストはまだ存在しますが、
一時的に制限されています。これに再びアクセスできるようにするには、‘C-x n
w’ (‘widen’)とタイプします。*note Narrowing::を参照してください。


File: emacs-ja.info,  Node: Memory Full,  Next: Crashing,  Prev: Text Garbled,  Up: Lossage

51.5 メモリー不足
=================

‘Virtual memory exceeded’というエラーメッセージが表示された場合は、‘C-x
s’ (‘save-some-buffers’)で変更されたバッファーを保存してください。この方
法は、バッファーを保存するのに最小限の追加メモリーを必要とします。
Emacsはこのエラーが発生したときでも利用可能な予備メモリーを保持しており
、それは‘C-x s’が処理を完了するのに充分なはずです。予備メモリーを使用し
たとき、モードラインの先頭に‘!MEM FULL!’が表示された場合、それは予備メモ
リーも使い切ったことを意味します。

   変更されたバッファーを変更したら、このEmacsセッションを終了して別のセ
ッションを開始するか、‘M-x kill-some-buffers’を使用して、カレントEmacsジ
ョブのスペースを開放できます。これにより充分なスペースが開放された場合、
予備メモリーは再充填され、モードラインから‘!MEM FULL!’の表示が消えます。
これは同じEmacsセッションで、安全に編集を継続できることを意味します。

   メモリー不足のときは、バッファーの保存やkillに‘M-x buffer-menu’を使用
しないでください。Buffer Menuはかなりの量のメモリーを必要とするので、予
備メモリーの供給では不充分でしょう。


File: emacs-ja.info,  Node: Crashing,  Next: After a Crash,  Prev: Memory Full,  Up: Lossage

51.6 Emacsがクラッシュしたとき
==============================

Emacsはクラッシュを前提としていませんが、もしクラッシュした場合、exitす
る前に“クラッシュレポート(crash report)”を生成します。クラッシュレポート
は標準エラーストリームにプリントされます。EmacsがGNUシステムまたはUnixシ
ステムでグラフィカルなデスクトップから開始された場合、標準エラーストリー
ムは一般的に‘~/.xsession-errors’のようなファイルにリダイレクトされるので
、そこでクラッシュレポートを探すことができます。MS-Windowsでは、クラッシ
ュレポートは標準エラーストリームに加え、Emacsプロセスのカレントとディレ
クトリーの、‘emacs_backtrace.txt’という名前のファイルに書き込まれます。

   クラッシュレポートのフォーマットは、プラットフォームに依存します。GNU
Cライブラリーを使用するいくつかのプラットフォームでは、クラッシュレポー
トには、クラッシュ前の実行状態を説明する“backtrace”が含まれ、これはクラ
ッシュをデバッグする助けとなります。以下はGNUシステムの例です:

     Fatal error 11: Segmentation fault
     Backtrace:
     emacs[0x5094e4]
     emacs[0x4ed3e6]
     emacs[0x4ed504]
     /lib64/libpthread.so.0[0x375220efe0]
     /lib64/libpthread.so.0(read+0xe)[0x375220e08e]
     emacs[0x509af6]
     emacs[0x5acc26]
     ...

数字‘11’ はクラッシュにたいするシステムのシグナル番号 — このケースでは
segmentation fault — です。16進数字はプログラムのアドレスで、これにより
デバッグツールを使用して、ソースコード行に関連付けることができます。たと
えばGDBコマンド‘list *0x509af6’は、‘emacs[0x509af6]’エントリーにたいする
ソースコード行をプリントします。システムに‘addr2line’ユーティリティーが
ある場合、以下のシェルコマンドはソースコードの行番号とともに、
backtraceを出力します:

     sed -n 's/.*\[\(.*\)]$/\1/p' BACKTRACE |
       addr2line -C -f -i -p -e BINDIR/EMACS-BINARY

ここで、BACKTRACEはbacktraceのコピーを含むテキストファイル名、BINDIRは
Emacs実行可能ファイルを含むディレクトリー名、EMACS-BINARYはEmacs実行可能
ファイル(GNUおよびUnixシステムでは通常は‘emacs’、MS-Windowsおよび
MS-DOSでは‘emacs.exe’)です。‘-p’オプションがない古いバージョンの
‘addr2line’では、このオプションを省略してください。

   coreファイルをサポートするシステムでは、Emacsはオプションで“コアダン
プ(core dump)”を生成します。コアダンプはクラッシュ前のプログラムの状態に
関する多くのデータを含むファイルで、通常GDBのようなデバッガーにロードし
て調べられます。多くのプラットフォームでは、コアダンプはデフォルトで無効
になっているので、(たとえばシェルのスタートアップスクリプトで)シェルコマ
ンド‘ulimit -c unlimited’を実行して、明示的に有効にしなければなりません
。


File: emacs-ja.info,  Node: After a Crash,  Next: Emergency Escape,  Prev: Crashing,  Up: Lossage

51.7 クラッシュ後のリカバリー
=============================

Emacs、またはコンピューターがクラッシュした場合、クラッシュしたとき編集
していたファイルを、自動保存ファイルからリカバリーすることができます。こ
れを行なうには、再びEmacsを開始して、コマンド‘M-x recover-session’とタイ
プしてください。

   このコマンドはm最初に中断されたセッションのファイルを、ファイルの日付
とともにリストするバッファーを表示します。そこからリカバリーするファイル
を、選択しなければなりません。通常リカバリーしたいファイルは、一番最近の
セッションでしょう。選択したファイルにポイントを移動して、‘C-c C-c’とタ
イプしてください。

   その後‘recover-session’は、そのセッション中に編集していた各ファイルに
ついて、検討を行ないます。そのようなファイルそれぞれについて、そのファイ
ルをリカバリーするか尋ねるのです。あるファイルにたいして‘y’と応えると、
コマンドはファイルとファイルの自動保存ファイルの日付を表示して、再度その
ファイルをリカバリーするか尋ねます。この2回目の質問にたいして同意するに
は、‘yes’と応えなければなりません。‘yes’と応えた場合、Emacsはそのファイ
ルをvisitしますが、テキストは自動保存ファイルから取得します。

   ‘recover-session’が終了すると、リカバリーを選択したファイルがEmacsバ
ッファーに表示されます。そこでファイルを保存する必要があります。それらを
保存することだけが、そのファイル自身を更新するのです。

   ファイルに関連付けられていないバッファーをリカバリーしたいときや、自
動保存が重要な更新を記録するほど最新でなかった場合、最後の手段として — コ
アダンプが保存されていて、Emacsの実行ファイルからデバッグシンボルがスト
リップされていないという条件の元に — コアダンプからそれらを取得するため
に、GDB(GNUデバッガー)で‘etc/emacs-buffer.gdb’スクリプトを使用することが
できます。

   コアダンプを入手したら、すぐに‘core.emacs’のような別の名前にリネーム
します。これにより、他のクラッシュによるコアダンプの上書きを防ぎます。

   このスクリプトを使用するには、Emacs実行ファイル名とコアダンプのファイ
ル名を、‘gdb /usr/bin/emacs core.emacs’のように指定します。‘(gdb)’プロン
プトで、‘source /usr/src/emacs/etc/emacs-buffer.gdb’としてリカバリースク
リプトをロードします。それから利用可能なバッファーを見るために、コマンド
‘ybuffer-list’とタイプします。これは各バッファーにたいして、バッファー番
号をリストします。バッファーを保存するには、‘ysave-buffer’を使用します。
ここでバッファー番号とそのバッファーを書き込むファイル名を指定します。す
でに存在するファイル名を使用するべきではありません。ファイルがすでに存在
する場合、このスクリプトはそのファイルの古い内容のバックアップを作成しま
せん。


File: emacs-ja.info,  Node: Emergency Escape,  Prev: After a Crash,  Up: Lossage

51.8 緊急エスケープ
===================

テキスト端末では、1回目の‘C-g’にたいしてEmacsが実際に反応してquitする前
に、2回目の‘C-g’をタイプすると、“緊急エスケープ(emergency escape)”が、
Emacsを即座にサスペンドします。これにより、どんなにひどくハングしていて
も、常にGNU Emacsを抜け出すことができます。物事が正しく処理されている場
合、Emacsは最初の‘C-g’を素早く認識・処理するので。2回目の‘C-g’は緊急エス
ケープを引き起こしません。しかし何らかの問題が、Emacsが最初の‘C-g’を処理
するのを妨げる場合、2回目の‘C-g’でシェルに戻ります。

   緊急エスケープによるサスペンドからEmacsを再開する場合、サスペンド前に
行なっていた何かに戻る前に、Emacsは回復の報告と、以下の2つの質問をします
:

     Emacs is resuming after an emergency escape.
     Auto-save? (y or n)
     Abort (and dump core)? (y or n)

質問に応えるには、それぞれにたいして‘y’または‘n’の後に、<RET>をタイプし
ます。

   ‘Auto-save?’にたいして‘y’と応えると、自動保存が有効なすべての編集され
たバッファーの自動保存を、即座に行ないます。‘n’と応えると、これをスキッ
プします。この質問は、Emacsが安全に自動保存を行えないような、何らかの状
況にある場合は省略されます。

   ‘Abort (and dump core)?’にたいして‘y’と応えると、Emacsはクラッシュし
てコアダンプします。これは専門家(wizard)が、なぜEmacsが最初の‘C-g’で
quitしなかったかを見つけ出すことを可能にします。コアダンプの後、実行は継
続されません。

   この質問に‘n’と応えた場合、Emacsは実行を再開します。運がよければ、
Emacsは最終的にquit要求を行なうでしょう。そうでない場合、連続して‘C-g’を
タイプして、緊急エスケープを再度呼び出します。

   実際はEmacsがハングしているのではなく、遅いだけの場合、本当に意味する
ところを意図せずに、2連‘C-g’の機能を呼び出してしまうかもしれません。この
場合は、2つの質問の両方に‘n’を応えれば、前の状態に戻ることができます。や
がて要求したquitが行なわれるでしょう。

   緊急エスケープはテキスト端末だけでアクティブになっています。グラフィ
カルなディスプレーでは、マウスを使用してEmacsをkillしたり、他のプログラ
ムに切り替えることができます。

   MS-DOSでは緊急エスケープを発生させるために、‘C-<Break>’を2回タイプし
なければなりません — しかしシステムコールがハングしたり、EmacsがCコード
のタイトなループにハマっているときは機能しないケースがあります。


File: emacs-ja.info,  Node: Bugs,  Next: Contributing,  Prev: Lossage,  Up: Top

52 バグの報告
*************

Emacsでバグを見つけたと思ったときは、それを報告してください。それをfixす
ることは約束できませんし、それがバグであると常に認める訳ではありませんが
、もちろんそれについて知りたいのです。追加したいと考える機能についても、
同じことが言えます。以下のセクションは、有効なバグレポートを作成する助け
となるでしょう。

* Menu:

* Known Problems::           既知の問題とバグについて読む方法。
* Criteria: Bug Criteria.    本当にバグを見つけたのか?
* Understanding Bug Reporting::  バグを報告する効果的な方法。
* Checklist::                良いバグレポートのために従うべきステップ。
* Sending Patches::          GNU Emacsにパッチを送る方法。


File: emacs-ja.info,  Node: Known Problems,  Next: Bug Criteria,  Up: Bugs

52.1 既存のバグレポートの既知の問題を読む
=========================================

バグを報告する前に、少しでも可能なら、それが既知のものか確認してください
。実際には、それがもっと後のEmacsリリースや、Emacsの開発バージョンですで
にfixされているかもしれません。以下は、既知の問題について読むことができ
る、主な場所のリストです:

   • ‘etc/PROBLEMS’ファイル。‘C-h C-p’とタイプして読むことができます。こ
     のファイルには、Emacsをコンパイル、インストール、実行するときに出会
     う、既知の問題の詳しいリストが含まれています。次善策や解決策の提案
     も、多くあります。

   • <https://debbugs.gnu.org>のGNU Bug Tracker。Emacsのバグは‘emacs’パ
     ッケージの下のトラッカーにファイルされています。トラッカーは、各バ
     グの状態、最初のバグレポート、バグ報告者とEmacs開発者によるフォロー
     アップメッセージについて情報を記録します。subject、severity、その他
     の条件でバグを検索できます。

     ウェブページでバグトラッカーを閲覧するかわりに、‘debbugs’パッケージ
     を使用して、それをEmacsから閲覧できます。このパッケージはパッケージ
     メニュー(*note Packages::を参照してください)を通じてダウンロードで
     きます。このパッケージは、バグをリストするコマンド‘M-x
     debbugs-gnu’、特定のバグを検索する‘M-x debbugs-gnu-search’を提供し
     ます。Emacsメンテナーにより適用されるユーザータグは、‘M-x
     debbugs-gnu-usertags’で表示されます。

   • ‘bug-gnu-emacs’メーリングリスト(ニュースグループ‘gnu.emacs.bug’も利
     用可能)。リストのアーカイブは
     <https://lists.gnu.org/mailman/listinfo/bug-gnu-emacs>で見ることが
     できます。このリストはバグトラッカーに送られたEmacsバグレポートとド
     ローアップメッセージの、mirrorとして機能します。これにはバグトラッ
     カーが導入される前(2008年以前)の古いバグレポートも含まれています。

     もし望むなら、メーリングリストに登録できます。このリストの目的は
     Emacsメンテナーにバグと機能リクエストの情報を提供するためのもので、
     報告には大量のデータが含まれるかもしれないことに注意してください。
     購読者はこれについて不満を言うべきではありません。

   • ‘emacs-pretest-bug’メーリングリスト。このリストは今は使用されておら
     ず、主に歴史的な興味のためのものです。一時は(たとえばまだリリースさ
     れていない)Emacs開発バージョンのために使用されていました。2003年か
     ら2007年中頃までのアーカイブは、
     <https://lists.gnu.org/r/emacs-pretest-bug/>で見ることができます。
     現在は‘bug-gnu-emacs’にたいするエイリアスです。

   • ‘emacs-devel’メーリングリスト。このメーリングリストにバグを報告する
     人がときどきいます。しかしこのリストの主な目的は違うので、バグレポ
     ートはバグリストに送るほうがよいでしょう。バグを報告する前に、この
     一覧を読んだことに感謝を感じることはありません。


File: emacs-ja.info,  Node: Bug Criteria,  Next: Understanding Bug Reporting,  Prev: Known Problems,  Up: Bugs

52.2 バグがあったとき
=====================

Emacsが不正なメモリー位置にアクセスする場合(“segmentation fault”と呼ばれ
ます)、または(“disk full”のようなメッセージではなく)プログラムに問題があ
ることを示す、オペレーティングシステムのエラーメッセージとともに終了する
場合、それは確実にバグです。

   Emacsがバッファーの内容を正しく対応して表示しないとき、それはバグです
。しかしバッファーのナローイング(*note Narrowing::を参照してください)チ
ェックするべきです。これはバッファーの一部を隠して、表示される方法を変更
できるので、バグではありません。

   コマンドが永久に完了しないなら、それはバグですが、本当にEmacsのせいか
確認しなくてはなりません。コマンドの中には単に長時間かかるものがいくつか
あります。‘C-g’ (MS-DOSでは‘C-<Break>’)をタイプしてから、‘C-h l’で、
Emacsが受け取った入力が、あなたがタイプしようと意図したものなのか確認し
ます。その入力が、あなたが素早く処理されるべきだと_わかっている_ものだっ
た場合は、バグを報告してください。そのコマンドが長時間かかるものか判らな
い場合は、マニュアルを調べるか、協力してくれる人に尋ねてください。

   あなたの親しんでいるコマンドが、コマンドの通常の定義が正当なのに、
Emacsのエラーメッセージを表示する場合、それはおそらくバグです。

   コマンドが間違ったことを行なうなら、それはバグです。しかしそのコマン
ドが何を行なうべきか確実に知っているか確認してください。そのコマンドに詳
しくない場合、コマンドは実際は正しく動いているのでしょう。疑うなら、コマ
ンドのドキュメント(*note Name Help::を参照してください)を参照してくださ
い。

   あるコマンドの意図された定義が、それを編集するための最良の定義ではな
いこともあります。これはとても重要な問題の一種ですが、判断の問題でもあり
ます。いくつかの既存の機能にたいする無知から、そのような決定を行なうのは
簡単でもあります。通常の方法でドキュメントをチェックして、それを理解した
と確信し、あなたがやりたいことが不可能だと確実に判るまでは、そのような問
題にたいして不満を言わないのが、おそらく最良です。他のEmacsユーザーにも
尋ねてみましょう。マニュアルを注意深く読んだ後でも、そのコマンドが何を想
定しているか確信がもてないときは、不明解な単語をindex(索引)やglossary(用
語集)でチェックしましょう。

   注意深くマニュアルを読んだ後でも、そのコマンドが何を行なうべきか判ら
ないとき、それは報告すべきマニュアルのバグであることを示します。Emacsの
エクスパートでない人 — あなたを含めて — にたいして、すべてを明解にするの
がマニュアルの役目です。プログラムのバグと同様に、ドキュメントのバグレポ
ートは重要です。

   関数や変数のビルトインドキュメントがマニュアルと異なる場合、どちらか
一方が間違っていなければならないので、これはバグです。

   Emacsの一部ではないパッケージについての問題は、そのパッケージの開発者
にそれらを報告することにより開始したほうが良いでしょう。


File: emacs-ja.info,  Node: Understanding Bug Reporting,  Next: Checklist,  Prev: Bug Criteria,  Up: Bugs

52.3 バグレポートの理解
=======================

バグがあると判断したときは、それを報告すること、そして有用な方法で報告す
ることが重要です。もっとも有用なのは、Emacsを起動するシェルコマンドから
、問題が発生するまでに、何のコマンドをタイプしたかの正確な記述です。

   バグレポートのもっとも重要な原理は、_事実_を報告することです。仮定や
口頭の説明は、詳細な生データの代替にはなりません。事実の報告は簡単ですが
、多くの人は事実のかわりに仮定の説明をしようと懸命に努め、それを報告する
のです。その説明がEmacsが実装されている方法にたいする仮定にもとづく場合
、それらは使い道がありません。その一方で事実の欠落により、わたしたちはバ
グについての実際の情報を得られないでしょう。実際に問題を_デバッグ_して、
推定を超える説明を報告したい場合、それは有用です — しかし、どうか生の事
実も同様に含めてください。

   たとえば、‘C-x C-f /glorp/baz.ugh <RET>’とタイプして、ファイルを
visitしたとき、そのファイルが偶然大きい(とあなたは知っている)ファイルで
、Emacsが‘I feel pretty today’と表示したとします。バグレポートにはすべて
の情報が必要になります。あなたは問題がファイルのサイズにあると仮定して、
“大きなファイルをvisitしたら、Emacsが‘I feel pretty today’と表示します
”、などと報告すべきではありません。これはわたしたちが“推測説明(guessing
explanations)”と呼ぶものです。ファイル名に‘z’があるという事実が、問題の
原因かもしれません。もしそうなら、あなたの報告を受け取ったとき、わたした
ちは大きなファイルで問題の再現を試み、それらのファイル名にはおそらく
‘z’が含まれておらず、問題を確認できないでしょう。名前に‘z’が含まれるファ
イルをvisitしてみるべきだと、推測できる方法はありません。

   ‘C-x C-f’のではなく、“ファイルをvisit”とさえ言うべきではありません。
同様にテキストを入力する方法では、“その行に3文字あるとき”ではなく、
“‘<RET> A B C <RET> C-p’とタイプした後”と書いてください。

   可能なら、すぐにバグを再現するために‘emacs -Q’(Emacsは初期のカスタマ
イズなしで開始されます。*note Initial Options::を参照してください)で
Emacsを呼び出して、バグを発生させるステップを繰り返してみてください。こ
の方法でバグを再現できたら、あなたの個人的なカスタマイズをバグから除外で
きます。バグレポートは、Emacsを‘emacs -Q’で開始したことから始まり、バグ
を再現させる正確な一連のステップを続けるべきです。可能ならバグを再現する
のに必要な、正確なファイル内容を報告してください。

   ‘emacs -Q’では再現できないバグもいくつかあります。結局は再現するのが
難しいバグもあります。そのような場合、何を行なったかを報告すべきです — が
、前述したように、どうか最初にバグを発生させた生の事実を固持してください
。

   報告したい複数の問題がある場合は、どうかそれらを個別のバグとしてそれ
ぞれ報告してください。


File: emacs-ja.info,  Node: Checklist,  Next: Sending Patches,  Prev: Understanding Bug Reporting,  Up: Bugs

52.4 バグレポートのためのチェックリスト
=======================================

バグを報告する前に、まずその問題がすでに報告されていないか、確認を試みて
ください(*note Known Problems::を参照してください)。

   もし可能なら、その問題がすでにfixされていないか、最新リリース版の
Emacsも試してみてください。同様に、最新の開発版を試してみるのもよいでし
ょう。これがある人にとっては簡単でないことは認識しているので、バグを報告
する前に、絶対にこれを行なわなければならないと思わないでください。

   Emacsでバグレポートを書くベストな方法は、コマンド‘M-x
report-emacs-bug’を使用する方法です。これはメールバッファー(*note
Sending Mail::を参照してください)をセットアップして、自動的に_いくつかの
_重要な情報を挿入します。しかし、すべての必要な情報は提供できません。だ
から以下のガイドラインを読んで、それに従うべきです。そうすればメッセージ
を送る前に、他の重大な情報を手で入力できます。‘M-x report-emacs-bug’によ
って挿入されたいくつかの情報は、適切ではないと感じるかもしれませんが、完
全に確信があるのでなければそれを残してください。そうすれば開発者たちがそ
れを判断できます。

   レポートを記述し終えたら、‘C-c C-c’とタイプすると、それはEmacsメンテ
ナー <bug-gnu-emacs@gnu.org>に送られます (新しい機能や改善を提案したいと
きも、同じアドレスを使用します)。Emacsの中からメールを送れない場合、バグ
レポートのテキストを通常使用しているメールクライアントにコピーして(シス
テムがサポートしている場合は、‘C-c M-i’でEmacsにそれを行なわせることがで
きます)、そのアドレスに送信できます。または、そのアドレスに問題を説明す
る簡単なメールを送ることもできます。

   レポートは‘bug-gnu-emacs’メーリングリストに送られ、
<https://debbugs.gnu.org>のGNU Bug Trackerに保管されます。報告について、
より詳細な情報を尋ねる必要がある場合のために、どうか有効な返信用アドレス
を含めてください。提出されたレポートは調停されるので、レポートが見られる
ようになるまで遅れが生じることもあります。

   バグを報告するためにGNU Bug Trackerがどのように機能するか知る必要はあ
りませんが、もし望むなら、トラッカーのオンラインドキュメントで、使用でき
るさまざま機能を見ることができます。

   ‘bug-gnu-emacs’メーリングリストに送られたすべてのメールは、
‘gnu.emacs.bug’ニュースグループにもゲートウェイされます。この逆も真です
が、バグレポート(または返信)をニュースグループにポストしないでください。
これにより、さらに情報を尋ねるためにあなたに連絡するのが困難になるのと、
それがバグトラッカーと充分に統合されていないからです。

   データが500,000バイトを超える場合は、どうかそれを直接レポートに含めな
いでください。要求されたら送るという提案に留めるか、データをオンラインで
利用可能にしてその場所を知らせてください。

   GNU Bug Trackerはあなたの報告にたいしてバグ番号を付与するでしょう。以
下のディスカッションでは、その番号を使用するようお願いいたします。

   メンテナーがバグを詳細に調べられるように、レポートには以下の事項を含
めるべきです:

   • Emacsのバージョン番号。これがないと、GNU Emacsのカレントバージョン
     で, バグを探す意義があるかを知ることができません。

     この情報は、‘M-x report-emacs-bug’により自動的にレポートに含まれま
     すが、レポートでこのコマンドを使用しない場合は、‘M-x emacs-version
     <RET>’とタイプして、バージョン番号を取得できます。このコマンドが機
     能しない場合、たぶんあなたはGNU Emacsではない他の何かを使っているの
     で、どこか他のところにそのバグを報告する必要があるでしょう。

   • 使用している機種のタイプ、およびオペレーティングシステム名とバージ
     ョン番号(繰り返しになりますが、これらは‘M-x report-emacs-bug’で自動
     的にレポートに含まれます)。‘M-x emacs-version <RET>’もこの情報を提
     供します。‘*Messages*’バッファーからコマンドの出力をコピーすれば、
     すべてを正確に取得できます。

   • Emacsをインストールしたとき、‘configure’に与えたオプション(‘M-x
     report-emacs-bug’により自動的にレポートに含まれます)。

   • Emacsのソースにたいして行なった変更の完全なリスト(わたしたちには、
     変更されたEmacsのバグを詳細に調べる時間はないでしょう。しかし変更を
     行なっていて、それをわたしたちに告げないとしたら、それはわたしたち
     を野性のダチョウ狩りに送り出すようなものです)。

     これらの変更について正確に記述してください。英語による説明では充分
     ではありません。それらにたいする統一コンテキストdiff(unified
     context diff)も送ってください。

     独自のファイル追加や、他の機種へのポートも、ソースの変更です。

   • GNU Emacsの標準的なインストール手順からの、その他あらゆる逸脱の詳細
     。

   • バグを再現するのに必要なファイルの完全なテキスト。

     ファイルをvisitせずに問題を発生させる方法を説明できるなら、ぜひそう
     してください。これによりデバッグがとても簡単になります。ファイルが
     必要な場合、わたしたちがファイルの正確な内容を見られるよう確実にし
     てください。たとえば、行末にスペースがあるか、バッファーの最終行の
     後に改行があるかが問題となる場合があります(最終行が終端されているか
     どうかを心配すべき理由はないかもしれませんが、それがバグだと報告す
     ることを試みてください)。

   • バグを再現するためにタイプする必要がある、正確なコマンド。少しでも
     可能なら、‘-Q’オプション(*note Initial Options::を参照してください
     )でEmacsを開始したときからの、完全なレシピを送ってください。このオ
     プションはあなたの個人的なカスタマイズをバイパスします。

     Emacsへの入力を正確に記録する方法の1つとして、それをdribbleファイル
     に書き込む方法があります。このファイルを開始するには、‘M-x
     open-dribble-file’コマンドを使用します。このコマンドからそのEmacsプ
     ロセスがkillされるまで、Emacsはすべての入力を指定されたdribbleファ
     イルにコピーします。機密情報(パスワードなど)は、dribbleファイルへの
     記録を終了させることに注意してください。

   • テキスト端末上での表示のバグである可能性がある場合は、端末タイプ(環
     境変数‘TERM’の値)、その端末にたいする‘/etc/termcap’の完全な
     termcapエントリー(このファイルはすべての機種で同じではありません)、
     Emacsが実際に端末に送った出力。

     端末出力を収集する方法は、以下のLisp式

          (open-termscript "~/termscript")

     を、Emacs開始直後に、‘M-:’を使用するか、‘*scratch*’バッファーで実行
     します。その後Emacsプロセスがkillされるまで、Emacsはすべての端末出
     力を、指定されたtermscriptファイルにもコピーします。Emacs開始時にそ
     の問題が発生する場合は、この式をEmacs初期化ファイルに記述すれば、
     Emacsが最初にスクリーンを表示するときに、termscriptファイルもオープ
     ンされます。

     警告: バグをシミュレートする端末タイプへのアクセスなしに、端末依存
     バグをfixするのは、しばしば困難で、不可能なときもあります。

   • 非ASCIIまたは国際化されたテキストと関連性がある場合は、Emacsを開始
     したときのlocale。GNU/LinuxとUnixシステム、またはBashのような
     POSIXスタイルのシェルを使用している場合、以下のシェルコマンドを使用
     して関連する値を見ることができます:

          echo LC_ALL=$LC_ALL LC_COLLATE=$LC_COLLATE LC_CTYPE=$LC_CTYPE \
            LC_MESSAGES=$LC_MESSAGES LC_TIME=$LC_TIME LANG=$LANG

     別の方法として、システムにそれがある場合は、GNU/LinuxおよびUnixコマ
     ンドを使用して、localeセッティングを表示できます。

     ‘M-!’コマンドを使用してEmacsからこれらのコマンドを実行して、
     ‘*Messages*’バッファーからコマンドの出力をバグレポートにコピーでき
     ます。かわりに‘M-x getenv <RET> LC_ALL <RET>’とタイプすると、
     ‘LC_ALL’の値をエコーエリアに表示するので、‘*Messages*’バッファーか
     らこの出力をコピーすることもできます。

   • あなたが間違いと主張する動作の説明。たとえば“Emacsプロセスが致命的
     なシグナルを受け取った”とか“結果のテキストは以下だが、これは間違い
     だと思う”など。

     もちろん、Emacsが致命的なシグナルを受け取るというバグなら、見逃すこ
     とはないでしょう。しかし、そのバグが正しくないテキストの場合、メン
     テナーは何が間違っているか気づかないかもしれません。なぜそのような
     危険を放置するのですか?

     あなたが遭遇した問題が致命的なシグナルの場合でも、明示的にそれを告
     げるべきです。何か奇妙なこと — たとえばあなたのソースコピーの同期が
     とれていない、またはあなたのシステムのCライブラリーにバグがある(こ
     れはあり得ます) — が起こっているとしましょう。あなたのコピーはクラ
     ッシュするかもしれませんが、私たちのコピーはクラッシュしないでしょ
     う。あなたがクラッシュすることを_告げて_いれば、わたしたちのEmacsは
     クラッシュしないので、バグはなかったとわたしたちは言うことができま
     す。クラッシュすることを告げていない場合、わたしたちはバグがあるか
     どうか知ることができません — わたしたちの観察から、なんらかの結論を
     描くことも不可能です。

   • Emacs ManualやEmacs Lisp Reference Manualが、実際のEmacsの振る舞い
     を記述できていない、またはテキストが分かりにくいといったバグの場合
     、間違いだと思うテキストをマニュアルからコピーしてください。そのセ
     クションが小さければ、セクション名だけで充分です。

   • バグの徴候がEmacsのエラーメッセージの場合、エラーメッセージの正確な
     テキストと、EmacsのLispプログラムがどのようにしてエラーに至ったかを
     示す、backtraceを報告するのが重要です。

     エラーメッセージを正確に取得するには、それを‘*Messages*’バッファー
     からバグレポートにコピーします。一部だけではなく、すべてをコピーし
     てください。

     エラーにたいするbacktraceを作成するには、エラーが発生する前に‘M-x
     toggle-debug-on-error’を使用します(つまり、このコマンドを与えた後で
     、バグを発生させなければなりません)。これはエラーによりbacktraceを
     表示するLispデバッガーを開始します。デバッガーのbacktraceをバグレポ
     ートにコピーしてください。EdebugパッケージでEmacs Lispプログラムを
     デバッグする情報については、*note Edebug: (elisp)Edebug.を参照して
     ください。

     このデバッガーの使用は、バグを再現する方法を知っているときだけ利用
     可能です。バグを再現できなければ、最低でもエラーメッセージ全体をコ
     ピーしてください。

     Emacsが無限ループや、とても長い処理にハマっているように見えるとき、
     (変数‘debug-on-quit’が非‘nil’の場合は)‘C-g’とタイプするとLispデバッ
     ガーを開始して、backtraceを表示します。このbacktraceは、そのような
     長いloopのデバッグにたいして有用なので、backtraceを生成できたら、バ
     グレポートにコピーしてください。

     (‘inhibit-quit’がセットされている等で)、‘C-g’にEmacsが応答しない場
     合、Emacsの外から‘debug-on-event’で指定されたシグナル(デフォルトは
     SIGUSR2)を送ることにより、デバッガーに入ることができます。

   • Lispの世界にロードしたプログラム(初期化ファイルを含みます)をチェッ
     クしてください。任意の変数にたいするセットは、Emacsの機能に影響を与
     えるかもしれません。初期化ファイルをロードせずに、フレッシュな状態
     で開始されたEmacsでも、その問題が発生するか確認してください(‘-Q’ス
     イッチでEmacsを開始することによりinitファイルのロードを抑止できます
     )。それで問題が発生しなかったら、問題を発生させるためにLispの世界に
     ロードしなければならないプログラムの、正確な内容を報告しなければな
     りません。

   • その問題がinitファイルやEmacsの標準システムの一部ではない他のLispプ
     ログラムに依存する場合、最初にそれらのプログラムのメンテナーに苦情
     を訴えて、それがバグでないことを確認すべきです。彼らが機能すると思
     われる方法でEmacsを使用してバグを確認した後、彼らがそのバグを報告す
     べきです。

   • GNU Emacsのソース中の何かについて言及したい場合、数行のコンテキスト
     とともにそのコードの行を示してください。行番号だけを示すのは止めて
     ください。

     開発ソースの行番号と、あなたのソースの行番号は一致しません。行番号
     だけでは、あなたのバージョンでその行番号がどのコードをさすのか、メ
     ンテナーが判断するのに余分な作業を要しますし、それに確信をもつこと
     もできません。

   • GDBのようなCデバッガーからの追加情報は、そのマシンを利用できなくて
     も問題を見つけることを可能にするかもしれません。GDBの使い方を知らな
     ければ、どうかGDBマニュアルを読んでください — 非常に長いという訳で
     はありませんし、GDBは簡単に使用できます。GDBマニュアルを含むGDBディ
     ストリビューションはオンライン形式で見つけることができ、ほとんどは
     Emacsディストリビューションと同じ場所で見つけることができます。
     GDBの下でEmacsを実行するためには、Emacsをコンパイルした場所の
     ‘src’サブディレクトリーに移動するべきです。カレントディレクトリーが
     ‘src’であることは重要です。GDBはこのディレクトリーの‘.gdbinit’を読
     み込みます。

     しかし、何がバグを引き起こしたかを示すような追加の情報を収集すると
     きは、考える必要があります。

     たとえば、多くの人はCレベルのbacktraceだけを送って着ますが、これだ
     けではとても有用とは言えません。引数つきのシンプルなbacktraceは、
     GNU Emacsの中で何が起こっているかを少ししか伝えないことがしばしばで
     す。なぜならbacktraceにリストされたほとんどの引数は、Lispオブジェク
     トへのポインターだからです。これらのポインターの数値は、何であれ意
     味をもちません。問題となるのはポインターが指すオブジェクトの内容(そ
     して、その内容自身もポインターの場合がほとんどです)なのです。

     有用な情報を提供するためには、Lispオブジェクトの値をLisp表記で示す
     必要があります。基底スタックの近傍のスタックフレームのいくつかで、
     Lispオブジェクト変数それぞれにたいしてこれを行ないます。どの変数が
     Lispオブジェクトであるかはソースを調べます。なぜならデバッガーはそ
     れらを整数と判断するからです。

     Lisp構文で変数の値を表示するには、最初にその値をプリントして、それ
     からLispオブジェクトをLisp構文でプリントするために、ユーザー定義の
     GDBコマンド‘pr’を使用します(他のデバッガーを使用しなければならない
     場合、そのオブジェクトを引数として、関数‘debug_print’を呼び出します
     )。‘pr’コマンドはファイル‘.gdbinit’で定義されていて、(コアダンプで
     はなく)実行中のプロセスにたいしてデバッグするときだけ機能します。

     LispエラーでEmacsを停止させてGDBに戻るには、‘Fsignal’にブレークポイ
     ントを置きます。

     実行中のLisp関数の短いリストのためには、GDBコマンド‘xbacktrace’をタ
     イプします。

     ファイル‘.gdbinit’では、データ型やLispオブジェクトの内容を調べるた
     めの、他のコマンドも定義されています。これらのコマンドの名前は‘x’で
     始まります。これらのコマンドは‘pr’より低いレベルで動作するので、少
     し不便になりますが、コアダンプをデバッグしていたり、Emacsが致命的な
     シグナルを受け取ったときなど、‘pr’が機能しないようなときでも、機能
     するでしょう。

     Emacsのデバッグにたいする、より詳細なアドバイスと、他の有用なテクニ
     ックは、Emacsディストリビューションの、ファイル‘etc/DEBUG’で利用可
     能です。そのファイルには、Emacsが応答しない問題を詳しく調べる手順も
     含まれています(多くの人はこれをEmacsが“ハング”したとみなしますが、
     実際はおそらく無限ループにハマっているのでしょう)。

     インストールしたEmacsのファイル‘etc/DEBUG’を探すには、変数
     ‘data-directory’に保管されたディレクトリー名を使用します。

   以下はバグレポートには不要な事柄です:

   • バグを取り巻く状況の説明 — これは再現可能なバグにたいしては必要あり
     ません。

     バグに遭遇したとき人は、入力ファイルを変えてバグが発生しなくなるか
     、影響がないかなどを詳しく調べるのに、多くの時間を費やすことがしば
     しばです。

     これは大抵多くの時間がかかる割に、とても有用とは言えません。なぜな
     らわたしたちがバグを探す方法は、ブレークポイントを設定したデバッガ
     ーの元で1つの例を実行することであり、一連の例から得られる推論ではな
     いからです。追加の例を探すのを止めることにより、あなたも時間を節約
     できるでしょう。すぐにバグレポートを送って、編集作業に戻り、報告す
     べき他のバグを探す法がよいでしょう。

     もちろんオリジナルの_かわり_に、簡単な例を見つけることができたら、
     そちらのほうが便利です。出力中のエラーは簡単に見分けられますし、デ
     バッガーでの実行も時間が短くなります

     しかし単純化は必須ではありません、これを行なうことができなかったり
     、試す時間がない場合は、どうかオリジナルのテストケースでバグを報告
     してください。

   • コアダンプファイル。

     コアダンプによるデバッグは有用ですが、それはあなたのEmacs実行ファイ
     ルと、あなたのマシンだけで行なうことができます。したがってEmacsメン
     テナーにコアダンプを送るのは、有益ではないでしょう。何よりも、コア
     ダンプをメールのバグレポートに含めないでください! そのような巨大な
     メッセージは、すこぶる迷惑です。

   • Emacsを実行したときのシステムコールトレース。

     システムコールトレースは、ある特別な種類のデバッグにはとても有用で
     すが、有用な情報が少ない場合がほとんどです。したがって、クラッシュ
     に関する情報を報告する_一番_の方法は、システムコールトレースを送る
     ことだと考えているように思える人が多いのは奇妙です。おそらくソース
     コードやデバッグシンボルがないプログラムをデバッグする経験がもたら
     す、習慣的なやり方なのでしょう。

     ほとんどのプログラムでは、システムコールトレースより、backtraceのほ
     うが、通常はずっとずっと参考になります。完全な情報を得るには、変数
     の値を表示して、それらを‘pr’でLispオブジェクトとしてプリントするこ
     とによりbacktraceを補完すべきであるとはいえ、シンプルなbacktraceの
     ほうが一般的により参考になります(上記参照)。

   • バグにたいするパッチ。

     バグにたいするパッチは、それが良いものなら有用です。しかし、そのパ
     ッチで充分だと思い込んで、テストケースのような、バグレポートに必要
     な他の情報を省略しないでください。わたしたちはそのパッチに問題を見
     つけて別の方法でfixすると判断するかもしれないし、結局はそれを理解で
     きないかもしれません。わたしたちが、あなたがfixしようと試みているバ
     グを理解できなければ、そしてなぜそのパッチが改善なのかを理解できな
     ければ、私たちはそれを採用できません。

     わたしたちにパッチを理解させて、採用を簡単にするためのガイドライン
     については、*note Sending Patches::を参照してください。

   • バグが何か、何に依存するかについての推測。

     そのような推測は通常間違っています。エキスパートでさえ、事実を見つ
     けるために最初にデバッガーを使用しなければ、そのような事柄を正しく
     推測できないのです。


File: emacs-ja.info,  Node: Sending Patches,  Prev: Checklist,  Up: Bugs

52.5 GNU Emacsへのパッチの送付
==============================

GNU Emacsを改善するためにバグfixを書きたいなら、それはとても助けになりま
す。変更を送るとき、メンテナーがそれらを使うのが簡単になるように、どうか
以下のガイドラインにしたがってください。これらのガイドラインにしたがわな
い場合でも、あなたの情報はまだ有用でしょうが、それを使用するのに余分な作
業が必要になります。GNU Emacsの保守は最良の状況でも多くの作業を要すので
、わたしたちを助けるのにあなたがベストをすくさなければ、わたしたちはそれ
を維持できないのです。

   各パッチは、わたしたちがそれを正しく評価するために、簡単な情報をもた
なければなりません。

   そのような情報がすべてあるなら、それらをメールメッセージにまとめて、
開発者に送ってください。推奨される送信先は、<bug-gnu-emacs@gnu.org>です
(これはバグおよび機能のためのリストです)。なぜなら、このリストにはパッチ
を簡単に確認するための追跡システム(tracking system)があるからです。その
パッチが完全ではなく、さらに議論が必要だと思うときは、かわりにそれを
<emacs-devel@gnu.org>に送りたいと思うかもしれません。パッチを改訂したら
、それを最初のトピックにたいするfollowupとして送ってください。

   わたしたちはそのパッチをプレーンテキストとして受けとるのを好みます。
それはインライン(メールクライアントが行ブレークを変更しないように注意し
てください)、またはMIMEアタッチメントのどちらでも構いません。

   • そのパッチがどんな問題をfixするのか、またはどんな改善をもたらすのか
     、あなたの変更にたいする説明を含めてください。

        • 既存のバグにたいするfixについては、‘bug-gnu-emacs’リストの関連
          するディスカッションか、<https://debbugs.gnu.org>のGNU Bug
          Trackerのバグエントリーに返信するのが最善でしょう。その変更が
          、なぜバグをfixするのか説明してください。

        • 新しい機能については、その機能と実装についての説明を含めてくだ
          さい。

        • 新しいバグにたいしては、あなたがfixしたと思っている問題にたい
          する、正しいバグレポートを含めてください。それを採用する前に、
          わたしたちはその変更が正しいと、私たち自身に納得させる必要があ
          ります。もしそれが正しくても、問題を再現する方法がない場合、そ
          れを理解する妨げになるでしょう。

   • 将来このソースを読む人の理解を助けとなるように、なぜこの変更が必要
     なのか、適切なコメントを含めてください。

   • 異なる理由にたいする変更を一緒に混ぜないでください。それらを_個別
     _に送ってください。

     異なる理由にたいして2つの変更を行なった場合、わたしたちをそれを一緒
     に採用したいとは思わないでしょう。1つだけを採用したいと思うかもしれ
     ません。それらを合わせて1つのdiffにして送った場合、それらを区別する
     ために — 変更のどの部分がどの目的のためかを理解するために — 余計な
     作業を行なう必要があります。これを行なう時間がない場合、わたしたち
     は変更全体を無視する必要があるかもしれません。

     1つの変更を記述したら、その変更の説明と一緒にそれをすぐに送れば、
     2つの変更は混ざることはなくなり、それらを区別する余計な作業なしに、
     わたしたちはそれぞれを正しく判断することができます。

   • 1つの変更を終えたら、それをすぐに送ってください。ときどき人は多くの
     変更を累積して、すべて一緒に送るのがわたしたちの助けとなると考えま
     す。上述したように、それは正にあなたにできる最悪のことです。

     変更は個別に送るべきなので、すぐに送ることができるでしょう。これは
     、その変更が重要なものなら、それをすぐに採用するオプションをわたし
     たちに与えます。

   • パッチそのもの

     diffを作成するために、‘diff -u’を使用してください。コンテキストなし
     のdiffは確実に採用が困難です。それ以上に調べるのが難しくなります。
     わたしたちは変更の採用を望ましいか判断するために、つねにパッチを調
     べなければなりません。Contextフォーマットはコンテキストなしのdiffよ
     り優れていますが、好ましいのはUnifiedフォーマットです。

     GNU diffがある場合、Cコードのdiffの作成には‘diff -u
     -F'^[_a-zA-Z0-9$]\+ *('’を使用してください。これは変更のある関数名
     を表示します。

     Emacsリポジトリーを使用している場合、あなたのコピーが(たとえば‘git
     pull’などにより)最新であることを確認してください。あなたの変更をプ
     ライベートのブランチにコミットして、‘git format-patch master’を使用
     することにより、マスターバージョンからパッチを生成できます。または
     変更をコミットせずに、‘git diff’を使用することもできます。

   • どちらが古いバージョンで、どちらが新しいバージョンか、あいまいにな
     るのを避けてください。どうかdiffの第1引数に古いバージョン、2番目の
     引数に新しいバージョンを指定してください。そして一方のバージョンに
     たいして、それが古いバージョンなのか、変更した新しいバージョンなの
     かを示す名前をつけてください。

   • あなたの変更にたいする、変更ログ(ChangeLog)のエントリーを記述してく
     ださい。それにより、わたしたちがそれを記述するために余計な作業をし
     なくてすみ、あなたが行なった変更をわたしたちが理解する助けにもなり
     ます。

     変更された場所を示すのが、変更ログの目的です。したがって変更した関
     数について、具体的である必要があります。大きな関数では、関数のどこ
     を変更したか示すのが、助けになる場合が多々あります。

     それとは逆に、変更箇所を示せば、変更ログで変更目的の説明をする必要
     はありません。したがって、新しい関数を追加した場合、必要なのはそれ
     が新しいということを示すだけです。変更目的の説明が必要だと感じたら
     、多分その通りなのでしょう、がコードのコメントにその説明を記述して
     ください。変更目的はそこに記述されているほうが、より有用です。

     どのような種類の情報を記述するかを見るために、最近のコミットにたい
     する変更ログエントリーを見て、わたしたちが使用しているスタイルを学
     んでください。他のプロジェクトとは異なり、たとえばTexinfoファイルの
     ような、ドキュメントにたいする変更ログも必要です。*note Change
     Log::、および *note Change Log Concepts: (standards)Change Log
     Concepts.を参照してください。

   • fixを記述するときは、わたしたちが他のシステムを壊すような変更は採用
     できないということを、念頭に置いてください。あなたの変更が、ほかの
     タイプのシステムでコンパイルされた場合の影響について、考えてくださ
     い。

     一般的には改善となる_かもしれない_が、そう確信するのは難しいような
     fixを送る人が、ときどきいます。そのような変更を採用するのは、わたし
     たちがそれをとても慎重に調べなければならないので、難しくなります。
     もちろん、その変更が正しい理由の説明は、わたしたちを納得させる助け
     になります。

     一番安全な変更は、特定の機種の設定ファイルにたいする変更です。これ
     らの変更は、新しいバグを他の機種に作成しないので、安全です。

     インストールの安全性が明確な形式でパッチをデザインして、わたしたち
     の作業量を、良い状態に保つ助けとなってください。


File: emacs-ja.info,  Node: Contributing,  Next: Service,  Prev: Bugs,  Up: Top

53 Emacs開発への貢献
********************

Emacsは共同制作によるプロジェクトであり、わたしたちは誰でも貢献できこと
を励行します。

   Emacsに貢献する多くの方法があります:

   • バグ探しと報告。*note Bugs::を参照してください。

   • Emacsユーザーメーリングリスト
     <https://lists.gnu.org/mailman/listinfo/help-gnu-emacs>の質問にたい
     する回答。

   • Wiki (https://www.emacswiki.org/)またはEmacs source
     repository(*note Sending Patches::を参照してください)のドキュメント
     の記述。

   • 既存のバグレポートが新しいバージョンの
     Emacs<https://debbugs.gnu.org/cgi/pkgreport.cgi?which=pkg&data=emacs>で
     fixされているかのチェック。

   • 既存バグのfixの報告。

   • Emacsディストリビューションの‘etc/TODO’にリストされた機能の実装、お
     よびパッチの送付。

   • 新しい機能の実装、およびパッチの送付。

   • Emacsで動作するパッケージの開発と、あなた自身またはGNU
     ELPA(<https://elpa.gnu.org/>)での公開。

   • 新しいプラットフォームへEmacsをポート。ただしこれは現在一般的ではあ
     りません。

   Emacsを改善する作業をしたい場合は、 <emacs-devel@gnu.org>のメンテナー
に連絡してください。 提案されたプロジェクトを尋ねたり、あなたのアイデア
を提案することができます。

   すでに改善を記述したことがある場合は、それについて教えてください。ま
だ作業を開始していなければ、作業を開始する前に、 <emacs-devel@gnu.org> に
連絡をとるのが有益です。Emacsの他の部分にたいして、あなたの拡張がより適
合する方法を提案することが可能かもしれません。

   機能を実装するときは、Emacs coding standardsに従ってください。*note
Coding Standards::を参照してください。くわえて、些細とは言えないような貢
献にたいしてはFSFへの著作権の譲渡が必要になります。*note Copyright
Assignment::を参照してください。

   Emacsの開発バージョンは、開発者グループにより活発にメンテされている、
レポジトリーからダウンロードできます。アクセスの詳細についてはEmacsプロ
ジェクトのページ<https://savannah.gnu.org/projects/emacs/>を参照してくだ
さい。

   カレントワーキングバージョンにたいしてパッチを記述することは重要です
。古いバージョンから開始した場合、パッチは時代遅れかもしれず(そのためメ
ンテナーはそれを適用するのが難しくなります)、Emacsの変更によりあなたのパ
ッチを不必要になっているかもしれません。リポジトリーソースからダウンロー
ドした後は、ビルド手順についてファイル‘INSTALL.REPO’を読むべきです(ビル
ド手順が通常のビルドとは異なります)。

   より広範な貢献をしたい場合は、Emacs開発者になる方法についての情報を得
るために、Emacsディストリビューションの‘CONTRIBUTE’ファイルを参照してく
ださい。

   (望む変更を実装する方法を理解するために)、以下のEmacsドキュメントを参
照してください:

   • *note Emacs Manual: (emacs)Top.を参照してください。

   • *note Emacs Lisp Reference Manual: (elisp)Top.を参照してください。

   • <https://www.gnu.org/software/emacs>

   • <https://www.emacswiki.org/>

* Menu:

* Coding Standards::         GNU Emacsコーディング規約
* Copyright Assignment::     FSFへの著作権の譲渡


File: emacs-ja.info,  Node: Coding Standards,  Next: Copyright Assignment,  Up: Contributing

53.1 コーディング規約
=====================

貢献されたコードはGNUコーディング規約(GNU Coding Standards:
<https://www.gnu.org/prep/standards/>)にしたがうべきです。これはシステム
のinfoでも利用可能かもしれません。

   これにしたがっていない場合、わたしたちがそれを使えるように、そのコー
ドをfixする誰かを探す必要があるでしょう。

   Emacsには追加のスタイルとコーディング規約があります:

   • *note “Tips and Conventions” Appendix in the Emacs Lisp Reference:
     (elisp)Tips.を参照してください。

   • Emacsに含まれるLispコードでは、‘defadvice’と
     ‘with-eval-after-load’の使用を避けてください。

   • すべてのソースおよびテキストファイルの、すべての行末の空白文字を削
     除してください。

   • Emacsにはソースコード中にタブを使うかどうかの規約がありません。編集
     するファイル内の空白文字を変更しないでください。

   • Lispコード内のスペース文字は、‘? ’のかわりに‘?\s’を使用してください
     。


File: emacs-ja.info,  Node: Copyright Assignment,  Prev: Coding Standards,  Up: Contributing

53.2 著作権の譲渡
=================

FSF(Free Software Foundation)は、GNU Emacsの著作権所有者です。FSFはコン
ピューターユーザーの自由の促進、およびすべてのフリーソフトウェアーユーザ
ーの権利を守るという、世界的な使命をもつ、非営利団体です。一般的な情報に
ついては、ウェブサイト<https://www.fsf.org/>を参照してください。

   一般的には、GNU Emacs、およびGNU ELPAに格納されているパッケージにたい
する些細とは言えない貢献にたいして、わたしたちは著作権をFSFに譲渡するこ
とを求めます。この背景にある理由については、
<http://www.gnu.org/licenses/why-assign.html>を参照してください。

   著作権譲渡はシンプルなプロセスです。いくつかの国の住民は、これを完全
にコンピューター上で行なうことができます。わたしたちは
<emacs-devel@gnu.org>メーリングリストで、あなたが始めるのを助けること、
あなたがもつかもしれない疑問にたいして回答(または回答をもつ人物を指示)す
ることができます。

   (どうか注意してください: なぜいくつかのGNUプロジェクトは版権譲渡を求
めるかについての一般的な議論は、emacs-develではoff-topicです。かわりに
gnu-misc-discussを参照してください)

   著作権放棄も可能ですが、好ましいのは譲渡です。著作権放棄者は、著作権
譲渡者と同様に、FSFにサインされた書類を送ることが必要になります(単に
“this is in the public domain”というだけでは充分ではありません)。著作権
放棄は将来の作業には適用できないので、新しい何かを送りたいときは、毎回こ
れを繰り返す必要があります。

   わたしたちは、譲渡なしで小さな変更(大雑把に言うと15行以下)を受けとる
ことができます。これはあなたの貢献全体にたいする蓄積的な制限です(たとえ
ば5行パッチを3つ)。


File: emacs-ja.info,  Node: Service,  Next: Copying,  Prev: Contributing,  Up: Top

54 GNU Emacsにたいして助けを得る方法
************************************

インストール、使用方法、またはGNU Emacsの変更について助言を必要とする場
合は、それを探す2つの方法があります:

   • メッセージを メーリングリスト<help-gnu-emacs@gnu.org>に送るか、 あ
     なたの要求をニュースグループ‘gnu.emacs.help’にポストしてください(こ
     のメーリングリストとニュースグループは相互接続しているので、どちら
     を使っても問題ありません)。

   • 手数料を徴収して助言してくれる人物を、service directory
     (https://www.fsf.org/resources/service/)で探してください。


File: emacs-ja.info,  Node: Copying,  Next: GNU Free Documentation License,  Prev: Service,  Up: Top

Appendix A GNU GENERAL PUBLIC LICENSE
*************************************

                        Version 3, 29 June 2007

     Copyright © 2007 Free Software Foundation, Inc. <https://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies of this
     license document, but changing it is not allowed.

Preamble
========

The GNU General Public License is a free, copyleft license for software
and other kinds of works.

   The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program—to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

   To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

   Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

   For the developers’ and authors’ protection, the GPL clearly explains
that there is no warranty for this free software.  For both users’ and
authors’ sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

   Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users’ freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

   Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

   The precise terms and conditions for copying, distribution and
modification follow.

TERMS AND CONDITIONS
====================

  0. Definitions.

     “This License” refers to version 3 of the GNU General Public
     License.

     “Copyright” also means copyright-like laws that apply to other
     kinds of works, such as semiconductor masks.

     “The Program” refers to any copyrightable work licensed under this
     License.  Each licensee is addressed as “you”.  “Licensees” and
     “recipients” may be individuals or organizations.

     To “modify” a work means to copy from or adapt all or part of the
     work in a fashion requiring copyright permission, other than the
     making of an exact copy.  The resulting work is called a “modified
     version” of the earlier work or a work “based on” the earlier work.

     A “covered work” means either the unmodified Program or a work
     based on the Program.

     To “propagate” a work means to do anything with it that, without
     permission, would make you directly or secondarily liable for
     infringement under applicable copyright law, except executing it on
     a computer or modifying a private copy.  Propagation includes
     copying, distribution (with or without modification), making
     available to the public, and in some countries other activities as
     well.

     To “convey” a work means any kind of propagation that enables other
     parties to make or receive copies.  Mere interaction with a user
     through a computer network, with no transfer of a copy, is not
     conveying.

     An interactive user interface displays “Appropriate Legal Notices”
     to the extent that it includes a convenient and prominently visible
     feature that (1) displays an appropriate copyright notice, and (2)
     tells the user that there is no warranty for the work (except to
     the extent that warranties are provided), that licensees may convey
     the work under this License, and how to view a copy of this
     License.  If the interface presents a list of user commands or
     options, such as a menu, a prominent item in the list meets this
     criterion.

  1. Source Code.

     The “source code” for a work means the preferred form of the work
     for making modifications to it.  “Object code” means any non-source
     form of a work.

     A “Standard Interface” means an interface that either is an
     official standard defined by a recognized standards body, or, in
     the case of interfaces specified for a particular programming
     language, one that is widely used among developers working in that
     language.

     The “System Libraries” of an executable work include anything,
     other than the work as a whole, that (a) is included in the normal
     form of packaging a Major Component, but which is not part of that
     Major Component, and (b) serves only to enable use of the work with
     that Major Component, or to implement a Standard Interface for
     which an implementation is available to the public in source code
     form.  A “Major Component”, in this context, means a major
     essential component (kernel, window system, and so on) of the
     specific operating system (if any) on which the executable work
     runs, or a compiler used to produce the work, or an object code
     interpreter used to run it.

     The “Corresponding Source” for a work in object code form means all
     the source code needed to generate, install, and (for an executable
     work) run the object code and to modify the work, including scripts
     to control those activities.  However, it does not include the
     work’s System Libraries, or general-purpose tools or generally
     available free programs which are used unmodified in performing
     those activities but which are not part of the work.  For example,
     Corresponding Source includes interface definition files associated
     with source files for the work, and the source code for shared
     libraries and dynamically linked subprograms that the work is
     specifically designed to require, such as by intimate data
     communication or control flow between those subprograms and other
     parts of the work.

     The Corresponding Source need not include anything that users can
     regenerate automatically from other parts of the Corresponding
     Source.

     The Corresponding Source for a work in source code form is that
     same work.

  2. Basic Permissions.

     All rights granted under this License are granted for the term of
     copyright on the Program, and are irrevocable provided the stated
     conditions are met.  This License explicitly affirms your unlimited
     permission to run the unmodified Program.  The output from running
     a covered work is covered by this License only if the output, given
     its content, constitutes a covered work.  This License acknowledges
     your rights of fair use or other equivalent, as provided by
     copyright law.

     You may make, run and propagate covered works that you do not
     convey, without conditions so long as your license otherwise
     remains in force.  You may convey covered works to others for the
     sole purpose of having them make modifications exclusively for you,
     or provide you with facilities for running those works, provided
     that you comply with the terms of this License in conveying all
     material for which you do not control copyright.  Those thus making
     or running the covered works for you must do so exclusively on your
     behalf, under your direction and control, on terms that prohibit
     them from making any copies of your copyrighted material outside
     their relationship with you.

     Conveying under any other circumstances is permitted solely under
     the conditions stated below.  Sublicensing is not allowed; section
     10 makes it unnecessary.

  3. Protecting Users’ Legal Rights From Anti-Circumvention Law.

     No covered work shall be deemed part of an effective technological
     measure under any applicable law fulfilling obligations under
     article 11 of the WIPO copyright treaty adopted on 20 December
     1996, or similar laws prohibiting or restricting circumvention of
     such measures.

     When you convey a covered work, you waive any legal power to forbid
     circumvention of technological measures to the extent such
     circumvention is effected by exercising rights under this License
     with respect to the covered work, and you disclaim any intention to
     limit operation or modification of the work as a means of
     enforcing, against the work’s users, your or third parties’ legal
     rights to forbid circumvention of technological measures.

  4. Conveying Verbatim Copies.

     You may convey verbatim copies of the Program’s source code as you
     receive it, in any medium, provided that you conspicuously and
     appropriately publish on each copy an appropriate copyright notice;
     keep intact all notices stating that this License and any
     non-permissive terms added in accord with section 7 apply to the
     code; keep intact all notices of the absence of any warranty; and
     give all recipients a copy of this License along with the Program.

     You may charge any price or no price for each copy that you convey,
     and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

     You may convey a work based on the Program, or the modifications to
     produce it from the Program, in the form of source code under the
     terms of section 4, provided that you also meet all of these
     conditions:

       a. The work must carry prominent notices stating that you
          modified it, and giving a relevant date.

       b. The work must carry prominent notices stating that it is
          released under this License and any conditions added under
          section 7.  This requirement modifies the requirement in
          section 4 to “keep intact all notices”.

       c. You must license the entire work, as a whole, under this
          License to anyone who comes into possession of a copy.  This
          License will therefore apply, along with any applicable
          section 7 additional terms, to the whole of the work, and all
          its parts, regardless of how they are packaged.  This License
          gives no permission to license the work in any other way, but
          it does not invalidate such permission if you have separately
          received it.

       d. If the work has interactive user interfaces, each must display
          Appropriate Legal Notices; however, if the Program has
          interactive interfaces that do not display Appropriate Legal
          Notices, your work need not make them do so.

     A compilation of a covered work with other separate and independent
     works, which are not by their nature extensions of the covered
     work, and which are not combined with it such as to form a larger
     program, in or on a volume of a storage or distribution medium, is
     called an “aggregate” if the compilation and its resulting
     copyright are not used to limit the access or legal rights of the
     compilation’s users beyond what the individual works permit.
     Inclusion of a covered work in an aggregate does not cause this
     License to apply to the other parts of the aggregate.

  6. Conveying Non-Source Forms.

     You may convey a covered work in object code form under the terms
     of sections 4 and 5, provided that you also convey the
     machine-readable Corresponding Source under the terms of this
     License, in one of these ways:

       a. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by the
          Corresponding Source fixed on a durable physical medium
          customarily used for software interchange.

       b. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by a
          written offer, valid for at least three years and valid for as
          long as you offer spare parts or customer support for that
          product model, to give anyone who possesses the object code
          either (1) a copy of the Corresponding Source for all the
          software in the product that is covered by this License, on a
          durable physical medium customarily used for software
          interchange, for a price no more than your reasonable cost of
          physically performing this conveying of source, or (2) access
          to copy the Corresponding Source from a network server at no
          charge.

       c. Convey individual copies of the object code with a copy of the
          written offer to provide the Corresponding Source.  This
          alternative is allowed only occasionally and noncommercially,
          and only if you received the object code with such an offer,
          in accord with subsection 6b.

       d. Convey the object code by offering access from a designated
          place (gratis or for a charge), and offer equivalent access to
          the Corresponding Source in the same way through the same
          place at no further charge.  You need not require recipients
          to copy the Corresponding Source along with the object code.
          If the place to copy the object code is a network server, the
          Corresponding Source may be on a different server (operated by
          you or a third party) that supports equivalent copying
          facilities, provided you maintain clear directions next to the
          object code saying where to find the Corresponding Source.
          Regardless of what server hosts the Corresponding Source, you
          remain obligated to ensure that it is available for as long as
          needed to satisfy these requirements.

       e. Convey the object code using peer-to-peer transmission,
          provided you inform other peers where the object code and
          Corresponding Source of the work are being offered to the
          general public at no charge under subsection 6d.

     A separable portion of the object code, whose source code is
     excluded from the Corresponding Source as a System Library, need
     not be included in conveying the object code work.

     A “User Product” is either (1) a “consumer product”, which means
     any tangible personal property which is normally used for personal,
     family, or household purposes, or (2) anything designed or sold for
     incorporation into a dwelling.  In determining whether a product is
     a consumer product, doubtful cases shall be resolved in favor of
     coverage.  For a particular product received by a particular user,
     “normally used” refers to a typical or common use of that class of
     product, regardless of the status of the particular user or of the
     way in which the particular user actually uses, or expects or is
     expected to use, the product.  A product is a consumer product
     regardless of whether the product has substantial commercial,
     industrial or non-consumer uses, unless such uses represent the
     only significant mode of use of the product.

     “Installation Information” for a User Product means any methods,
     procedures, authorization keys, or other information required to
     install and execute modified versions of a covered work in that
     User Product from a modified version of its Corresponding Source.
     The information must suffice to ensure that the continued
     functioning of the modified object code is in no case prevented or
     interfered with solely because modification has been made.

     If you convey an object code work under this section in, or with,
     or specifically for use in, a User Product, and the conveying
     occurs as part of a transaction in which the right of possession
     and use of the User Product is transferred to the recipient in
     perpetuity or for a fixed term (regardless of how the transaction
     is characterized), the Corresponding Source conveyed under this
     section must be accompanied by the Installation Information.  But
     this requirement does not apply if neither you nor any third party
     retains the ability to install modified object code on the User
     Product (for example, the work has been installed in ROM).

     The requirement to provide Installation Information does not
     include a requirement to continue to provide support service,
     warranty, or updates for a work that has been modified or installed
     by the recipient, or for the User Product in which it has been
     modified or installed.  Access to a network may be denied when the
     modification itself materially and adversely affects the operation
     of the network or violates the rules and protocols for
     communication across the network.

     Corresponding Source conveyed, and Installation Information
     provided, in accord with this section must be in a format that is
     publicly documented (and with an implementation available to the
     public in source code form), and must require no special password
     or key for unpacking, reading or copying.

  7. Additional Terms.

     “Additional permissions” are terms that supplement the terms of
     this License by making exceptions from one or more of its
     conditions.  Additional permissions that are applicable to the
     entire Program shall be treated as though they were included in
     this License, to the extent that they are valid under applicable
     law.  If additional permissions apply only to part of the Program,
     that part may be used separately under those permissions, but the
     entire Program remains governed by this License without regard to
     the additional permissions.

     When you convey a copy of a covered work, you may at your option
     remove any additional permissions from that copy, or from any part
     of it.  (Additional permissions may be written to require their own
     removal in certain cases when you modify the work.)  You may place
     additional permissions on material, added by you to a covered work,
     for which you have or can give appropriate copyright permission.

     Notwithstanding any other provision of this License, for material
     you add to a covered work, you may (if authorized by the copyright
     holders of that material) supplement the terms of this License with
     terms:

       a. Disclaiming warranty or limiting liability differently from
          the terms of sections 15 and 16 of this License; or

       b. Requiring preservation of specified reasonable legal notices
          or author attributions in that material or in the Appropriate
          Legal Notices displayed by works containing it; or

       c. Prohibiting misrepresentation of the origin of that material,
          or requiring that modified versions of such material be marked
          in reasonable ways as different from the original version; or

       d. Limiting the use for publicity purposes of names of licensors
          or authors of the material; or

       e. Declining to grant rights under trademark law for use of some
          trade names, trademarks, or service marks; or

       f. Requiring indemnification of licensors and authors of that
          material by anyone who conveys the material (or modified
          versions of it) with contractual assumptions of liability to
          the recipient, for any liability that these contractual
          assumptions directly impose on those licensors and authors.

     All other non-permissive additional terms are considered “further
     restrictions” within the meaning of section 10.  If the Program as
     you received it, or any part of it, contains a notice stating that
     it is governed by this License along with a term that is a further
     restriction, you may remove that term.  If a license document
     contains a further restriction but permits relicensing or conveying
     under this License, you may add to a covered work material governed
     by the terms of that license document, provided that the further
     restriction does not survive such relicensing or conveying.

     If you add terms to a covered work in accord with this section, you
     must place, in the relevant source files, a statement of the
     additional terms that apply to those files, or a notice indicating
     where to find the applicable terms.

     Additional terms, permissive or non-permissive, may be stated in
     the form of a separately written license, or stated as exceptions;
     the above requirements apply either way.

  8. Termination.

     You may not propagate or modify a covered work except as expressly
     provided under this License.  Any attempt otherwise to propagate or
     modify it is void, and will automatically terminate your rights
     under this License (including any patent licenses granted under the
     third paragraph of section 11).

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, you do not qualify to receive new licenses
     for the same material under section 10.

  9. Acceptance Not Required for Having Copies.

     You are not required to accept this License in order to receive or
     run a copy of the Program.  Ancillary propagation of a covered work
     occurring solely as a consequence of using peer-to-peer
     transmission to receive a copy likewise does not require
     acceptance.  However, nothing other than this License grants you
     permission to propagate or modify any covered work.  These actions
     infringe copyright if you do not accept this License.  Therefore,
     by modifying or propagating a covered work, you indicate your
     acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

     Each time you convey a covered work, the recipient automatically
     receives a license from the original licensors, to run, modify and
     propagate that work, subject to this License.  You are not
     responsible for enforcing compliance by third parties with this
     License.

     An “entity transaction” is a transaction transferring control of an
     organization, or substantially all assets of one, or subdividing an
     organization, or merging organizations.  If propagation of a
     covered work results from an entity transaction, each party to that
     transaction who receives a copy of the work also receives whatever
     licenses to the work the party’s predecessor in interest had or
     could give under the previous paragraph, plus a right to possession
     of the Corresponding Source of the work from the predecessor in
     interest, if the predecessor has it or can get it with reasonable
     efforts.

     You may not impose any further restrictions on the exercise of the
     rights granted or affirmed under this License.  For example, you
     may not impose a license fee, royalty, or other charge for exercise
     of rights granted under this License, and you may not initiate
     litigation (including a cross-claim or counterclaim in a lawsuit)
     alleging that any patent claim is infringed by making, using,
     selling, offering for sale, or importing the Program or any portion
     of it.

  11. Patents.

     A “contributor” is a copyright holder who authorizes use under this
     License of the Program or a work on which the Program is based.
     The work thus licensed is called the contributor’s “contributor
     version”.

     A contributor’s “essential patent claims” are all patent claims
     owned or controlled by the contributor, whether already acquired or
     hereafter acquired, that would be infringed by some manner,
     permitted by this License, of making, using, or selling its
     contributor version, but do not include claims that would be
     infringed only as a consequence of further modification of the
     contributor version.  For purposes of this definition, “control”
     includes the right to grant patent sublicenses in a manner
     consistent with the requirements of this License.

     Each contributor grants you a non-exclusive, worldwide,
     royalty-free patent license under the contributor’s essential
     patent claims, to make, use, sell, offer for sale, import and
     otherwise run, modify and propagate the contents of its contributor
     version.

     In the following three paragraphs, a “patent license” is any
     express agreement or commitment, however denominated, not to
     enforce a patent (such as an express permission to practice a
     patent or covenant not to sue for patent infringement).  To “grant”
     such a patent license to a party means to make such an agreement or
     commitment not to enforce a patent against the party.

     If you convey a covered work, knowingly relying on a patent
     license, and the Corresponding Source of the work is not available
     for anyone to copy, free of charge and under the terms of this
     License, through a publicly available network server or other
     readily accessible means, then you must either (1) cause the
     Corresponding Source to be so available, or (2) arrange to deprive
     yourself of the benefit of the patent license for this particular
     work, or (3) arrange, in a manner consistent with the requirements
     of this License, to extend the patent license to downstream
     recipients.  “Knowingly relying” means you have actual knowledge
     that, but for the patent license, your conveying the covered work
     in a country, or your recipient’s use of the covered work in a
     country, would infringe one or more identifiable patents in that
     country that you have reason to believe are valid.

     If, pursuant to or in connection with a single transaction or
     arrangement, you convey, or propagate by procuring conveyance of, a
     covered work, and grant a patent license to some of the parties
     receiving the covered work authorizing them to use, propagate,
     modify or convey a specific copy of the covered work, then the
     patent license you grant is automatically extended to all
     recipients of the covered work and works based on it.

     A patent license is “discriminatory” if it does not include within
     the scope of its coverage, prohibits the exercise of, or is
     conditioned on the non-exercise of one or more of the rights that
     are specifically granted under this License.  You may not convey a
     covered work if you are a party to an arrangement with a third
     party that is in the business of distributing software, under which
     you make payment to the third party based on the extent of your
     activity of conveying the work, and under which the third party
     grants, to any of the parties who would receive the covered work
     from you, a discriminatory patent license (a) in connection with
     copies of the covered work conveyed by you (or copies made from
     those copies), or (b) primarily for and in connection with specific
     products or compilations that contain the covered work, unless you
     entered into that arrangement, or that patent license was granted,
     prior to 28 March 2007.

     Nothing in this License shall be construed as excluding or limiting
     any implied license or other defenses to infringement that may
     otherwise be available to you under applicable patent law.

  12. No Surrender of Others’ Freedom.

     If conditions are imposed on you (whether by court order, agreement
     or otherwise) that contradict the conditions of this License, they
     do not excuse you from the conditions of this License.  If you
     cannot convey a covered work so as to satisfy simultaneously your
     obligations under this License and any other pertinent obligations,
     then as a consequence you may not convey it at all.  For example,
     if you agree to terms that obligate you to collect a royalty for
     further conveying from those to whom you convey the Program, the
     only way you could satisfy both those terms and this License would
     be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

     Notwithstanding any other provision of this License, you have
     permission to link or combine any covered work with a work licensed
     under version 3 of the GNU Affero General Public License into a
     single combined work, and to convey the resulting work.  The terms
     of this License will continue to apply to the part which is the
     covered work, but the special requirements of the GNU Affero
     General Public License, section 13, concerning interaction through
     a network will apply to the combination as such.

  14. Revised Versions of this License.

     The Free Software Foundation may publish revised and/or new
     versions of the GNU General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies that a certain numbered version of the GNU
     General Public License “or any later version” applies to it, you
     have the option of following the terms and conditions either of
     that numbered version or of any later version published by the Free
     Software Foundation.  If the Program does not specify a version
     number of the GNU General Public License, you may choose any
     version ever published by the Free Software Foundation.

     If the Program specifies that a proxy can decide which future
     versions of the GNU General Public License can be used, that
     proxy’s public statement of acceptance of a version permanently
     authorizes you to choose that version for the Program.

     Later license versions may give you additional or different
     permissions.  However, no additional obligations are imposed on any
     author or copyright holder as a result of your choosing to follow a
     later version.

  15. Disclaimer of Warranty.

     THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
     APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE
     COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM “AS IS”
     WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE
     RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.
     SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
     NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

     IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES
     AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
     DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
     CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
     THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
     BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
     PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
     PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF
     THE POSSIBILITY OF SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

     If the disclaimer of warranty and limitation of liability provided
     above cannot be given local legal effect according to their terms,
     reviewing courts shall apply local law that most closely
     approximates an absolute waiver of all civil liability in
     connection with the Program, unless a warranty or assumption of
     liability accompanies a copy of the Program in return for a fee.

END OF TERMS AND CONDITIONS
===========================

How to Apply These Terms to Your New Programs
=============================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least the
“copyright” line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YEAR NAME OF AUTHOR

     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or (at
     your option) any later version.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see <https://www.gnu.org/licenses/>.

   Also add information on how to contact you by electronic and paper
mail.

   If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

     PROGRAM Copyright (C) YEAR NAME OF AUTHOR
     This program comes with ABSOLUTELY NO WARRANTY; for details type ‘show w’.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type ‘show c’ for details.

   The hypothetical commands ‘show w’ and ‘show c’ should show the
appropriate parts of the General Public License.  Of course, your
program’s commands might be different; for a GUI interface, you would
use an “about box”.

   You should also get your employer (if you work as a programmer) or
school, if any, to sign a “copyright disclaimer” for the program, if
necessary.  For more information on this, and how to apply and follow
the GNU GPL, see <https://www.gnu.org/licenses/>.

   The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Lesser General Public License instead of this License.  But first,
please read <https://www.gnu.org/licenses/why-not-lgpl.html>.


File: emacs-ja.info,  Node: GNU Free Documentation License,  Next: Emacs Invocation,  Prev: Copying,  Up: Top

Appendix B GNU Free Documentation License
*****************************************

                     Version 1.3, 3 November 2008

     Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <https://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document “free” in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of “copyleft”, which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     “Document”, below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as “you”.  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A “Modified Version” of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A “Secondary Section” is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document’s overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The “Invariant Sections” are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The “Cover Texts” are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A “Transparent” copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     “Transparent” is called “Opaque”.

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The “Title Page” means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, “Title
     Page” means the text near the most prominent appearance of the
     work’s title, preceding the beginning of the body of the text.

     The “publisher” means any person or entity that distributes copies
     of the Document to the public.

     A section “Entitled XYZ” means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.)
     To “Preserve the Title” of such a section when you modify the
     Document means that it remains a section “Entitled XYZ” according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document’s license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document’s
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled “History”, Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled “History” in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          “History” section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled “Acknowledgements” or “Dedications”,
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled “Endorsements”.  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          “Endorsements” or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version’s
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled “Endorsements”, provided it contains
     nothing but endorsements of your Modified Version by various
     parties—for example, statements of peer review or that the text has
     been approved by an organization as the authoritative definition of
     a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     “History” in the various original documents, forming one section
     Entitled “History”; likewise combine any sections Entitled
     “Acknowledgements”, and any sections Entitled “Dedications”.  You
     must delete all sections Entitled “Endorsements.”

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an “aggregate” if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation’s users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document’s Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled “Acknowledgements”,
     “Dedications”, or “History”, the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, receipt of a copy of some or all of the
     same material does not give you any rights to use it.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <https://www.gnu.org/licenses/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License “or any later version” applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.  If the Document specifies that a proxy can
     decide which future versions of this License can be used, that
     proxy’s public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

  11. RELICENSING

     “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A “Massive Multiauthor Collaboration” (or “MMC”) contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     “Incorporate” means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is “eligible for relicensing” if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the “with...Texts.” line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: emacs-ja.info,  Node: Emacs Invocation,  Next: X Resources,  Prev: GNU Free Documentation License,  Up: Top

Appendix C Emacs呼び出しにたいするコマンドライン引数
****************************************************

Emacsは、Emacsを開始するとき、様々な動作を要求するための、コマンドライン
引数をサポートします。これらのコマンド引数の中には、他のエディターとの互
換性のためのものや、高度な動作を指定するものがあります。通常の編集にこれ
らを使用することはお勧めしません(コマンドラインから既存のEmacsジョブにア
クセスする方法は、*note Emacs Server::を参照してください)。

   ‘-’で始まる引数は“オプションで”、‘+LINENUM’もオプションです。Emacsは
、スタートアップ時に指定されたファイルをvisitします。コマンドラインで最
後に指定されたファイルがカレントバッファーになり、それ以外のファイルも別
のバッファーでvisitされます。ほとんどのプログラムと同様に、特別な引数
‘--’は、それ以降のすべての引数が、(名前が‘-’で始まっていても)オプション
ではなくファイル名であることを指定します。

   Emacsのコマンドオプションは、XウィンドウでEmacsが使用するウィンドウの
サイズや位置、カラーなど、多くのことを指定できます。多くはありませんが、
ファイルのLisp関数をバッチモードで実行するなど、高度な使い方をサポートす
るためのオプションもあります。このチャプターの各セクションでは、利用可能
なオプションを、その目的に合わせて整理して説明します。

   オプションを記述するには2つの方法があります。それは1つの‘-’で始まる短
い形式と、‘--’で始まる長い形式です。たとえば、短い形式が‘-d’で、それに対
応する長い形式は‘--display’です。

   ‘--’の長い形式は、覚えるのが簡単ですが、多くタイプしなければなりませ
ん。しかしオプション名全体を綴る必要はありません。あいまいさのない省略形
で充分です。長いオプションが引数をとる場合、オプション名と、そのオプショ
ンにたいする引数を区切るには、スペースとイコール記号の両方を使用すること
ができます。したがって‘--display’オプションにたいしては、‘--display
sugar-bombs:0.0’と‘--display=sugar-bombs:0.0’の、どちらでも記述すること
ができます。関連性が明確になるのでイコール記号を推奨します。以下の表では
、常にイコール記号で記すことにします。

   ほとんどのオプションは、Emacsを初期化する方法や、Emacsセッションのパ
ラメーターを指定します。これらを“初期化オプション(initial options)”と呼
びます。多くはありませんが、ライブラリーのロードや、Lisp関数の呼び出しな
ど、動作を指定するオプションもあります。これらを“動作オプション(action
options)”と呼びます。これらとファイル名を合わせたものを、“動作引数
(action arguments)”と呼びます。動作引数は、変数‘command-line-args’に、文
字列のリストとして保管されます(実際のところ、Emacsスタートアップ時には、
コマンドラインで渡されたすべての引数が、‘command-line-args’に含まれてい
ますが、初期化を行なう間に、初期化引数は処理されるごとにこのリストから削
除され、動作引数だけが残ります)。

* Menu:

* Action Arguments::         ファイルのvisit、ライブラリーのロード、関数を呼び出す引数。
* Initial Options::          Emacsの開始に影響する引数。
* Command Example::          コマンドライン引数の使用例。
* Environment::              Emacsが使用する環境変数。
* Display X::                デフォルトディスプレーの変更と、リモートログインの使用。
* Font X::                   Xでのテキストのフォント選択。
* Colors X::                 ディスプレーカラーの選択。
* Window Size X::            Xでのスタートアップウィンドウのサイズ。
* Borders X::                Xでの内枠ボーダーと外枠ボーダー。
* Title X::                  初期フレームのタイトルの指定。
* Icons X::                  Xで使用するアイコンの選択。
* Misc X::                   その他のディスプレーオプション。


File: emacs-ja.info,  Node: Action Arguments,  Next: Initial Options,  Up: Emacs Invocation

C.1 動作引数
============

以下は動作引数の表です:

‘FILE’
‘--file=FILE’
‘--find-file=FILE’
‘--visit=FILE’
     指定されたFILEをvisitします。*note Visiting::を参照してください。

     Emacsスタートアップ時、1つのウィンドウでスタートアップバッファーを
     表示し、FILEをvisitするバッファーを別のウィンドウで表示します(*note
     Windows::を参照してください)。複数のファイル引数を与えた場合、コマ
     ンドラインの最後に指定されたファイルが表示され、他のファイルも
     visitされますが、表示はされません。

     スタートアップバッファーが無効(*note Entering Emacs::を参照)の場合
     、ファイル引数が1つのときは1つのウィンドウでFILEをvisitするバッファ
     ーを表示し、ファイル引数が2つのときは、Emacsはファイルを2つの別のウ
     ィンドウに表示します。ファイル引数が3つ以上の場合、Emacsは最後に指
     定されたファイルを1つのウィンドウに表示して、別のウィンドウにその他
     すべてのファイルを表示するバッファーメニュー(*note Several
     Buffers::を参照)を表示します。このバッファーメニューの使用を抑制す
     るには、変数‘inhibit-startup-buffer-menu’を‘t’に変更してください。

‘+LINENUM FILE’
     指定されたFILEをvisitし、行番号LINENUMに移動します。

‘+LINENUM:COLUMNNUM FILE’
     指定されたFILEをvisitし、行番号LINENUMに移動して、列番号COLUMNNUMに
     ポイントを置きます。

‘-l FILE’
‘--load=FILE’
     関数‘load’で、FILEという名前のLispライブラリーをロードします。
     FILEが絶対ファイル名でない場合、Emacsは最初にカレントディレクトリー
     を探して、次に‘load-path’ (*note Lisp Libraries::を参照してください
     )にリストされたディレクトリーを探します。

     *警告: *前のコマンドライン引数にvisitされたファイルがある場合、カレ
     ントディレクトリーは最後にvisitされたファイルのディレクトリーになり
     ます。

‘-L DIR’
‘--directory=DIR’
     変数‘load-path’にリストされたディレクトリーの前に、ディレクトリー
     DIRを追加します。複数の‘-L’オプションを指定した場合、Emacsはその順
     番を保持します。たとえば‘-L /foo -L /bar’を使用すると、
     ‘load-path’は‘("/foo" "/bar" ...)’となります。DIRが‘:’で始まる場合
     、Emacsは‘:’を削除した残りを、‘load-path’にリストされたディレクトリ
     ーの(前ではなく)後ろに追加します(MS Windowsでは‘:’のかわりに、
     ‘path-separator’の値‘;’を使用します)。

‘-f FUNCTION’
‘--funcall=FUNCTION’
     Lisp関数FUNCTIONを呼び出します。それがインタラクティブな関数(コマン
     ド)の場合、同じ関数をキーシーケンスで呼び出したときのように、引数を
     対話的に読み取ります。そうでない場合は、その関数を引数なしで呼び出
     します。

‘--eval=EXPRESSION’
‘--execute=EXPRESSION’
     Lisp式EXPRESSIONを評価します。

‘--insert=FILE’
     FILEの内容を、コマンドライン引数が処理されるときにカレントのバッフ
     ァーに挿入します。これは通常、‘*scratch*’バッファー(*note Lisp
     Interaction::を参照してください)ですが、コマンドラインの前の引数が
     ファイルをvisitしたりバッファーを切り替えるときは、別のバッファーに
     なるでしょう。このコマンドライン引数の効果は、‘M-x insert-file’が行
     なうのと同様です(*note Misc File Ops::を参照してください)。

‘--kill’
     確認なしでEmacsを終了します。

‘--help’
     利用可能なすべてのオプションがリストされたUsageメッセージをプリント
     してから、正常終了します。

‘--version’
     Emacsのバージョンをプリントしてから、正常終了します。


File: emacs-ja.info,  Node: Initial Options,  Next: Command Example,  Prev: Action Arguments,  Up: Emacs Invocation

C.2 初期化オプション
====================

初期化オプションは、Emacsセッションにたいするパラメーターを指定します。
このセクションでは、より一般的な初期化オプションを説明します。いくつかの
オプションは、厳密には以降のセクションで説明するXウィンドウシステムに関
連したオプションです。

   いくつかの初期化オプションは、初期化ファイルのロードに影響します。
Emacsは通常、‘site-start.el’が存在する場合は最初にそれをロードし、ユーザ
ーの初期化ファイルが存在すれば次にそれをロードして、デフォルト初期化ファ
イル‘default.el’が存在すれば最後にそれをロードします(*note Init File::を
参照してください)。それらのファイルのロードを抑制したり、それらのファイ
ルを別のファイルで置き換えるオプションもあります。

‘-chdir DIRECTORY’
‘--chdir=DIRECTORY’
     他のことを行なう前にまず、カレントディレクトリーをDIRECTORYに変更し
     ます。これはEmacsが停止したのと同じディレクトリーで開始されるように
     、主にXでのセッション管理に使用されます。これによりデスクトップの保
     存と復元が簡単になります。

‘-t DEVICE’
‘--terminal=DEVICE’
     端末の入出力にDEVICEをデバイスとして使用します。このオプションは暗
     に‘--no-window-system’を含みます。

‘-d DISPLAY’
‘--display=DISPLAY’
     Emacs初期フレームを開くために、XウィンドウシステムとDISPLAYという名
     前のディスプレーを使用します。詳細は、*note Display X::を参照してく
     ださい。

‘-nw’
‘--no-window-system’
     環境変数‘DISPLAY’がセットされていても、ウィンドウシステムと直接やり
     とりしません。これはEmacsが、Emacsのすべての表示と出力のために、開
     始された端末を使用することを意味します。

‘-batch’
‘--batch’
     Emacsを“バッチモード(batch mode)”で実行します。バッチモードは、シェ
     ルスクリプトやmakeファイルから、Emacs Lispで記述されたプログラムを
     実行するために使用されます。Lispプログラムを呼び出すには、
     ‘-batch’オプションと併せて、1つ以上の‘-l’、‘-f’、‘--eval’を使用しま
     す(*note Action Arguments::を参照してください)。使用例は、*note
     Command Example::を参照してください。

     バッチモードでは、Emacsは編集されるテキストを表示せず、‘C-z’や
     ‘C-c’のような、標準の端末割り込みが通常の効果をもちます。通常はエコ
     ーエリアにメッセージをプリントするEmacs関数は、かわりに標準出力スト
     リーム(‘stdout’)、または標準エラーストリーム(‘stderr’)にメッセージ
     をプリントします(正確に言うと、‘prin1’、‘princ’、‘print’のような関
     数は‘stdout’にプリントし、‘message’や‘error’は‘stderr’にプリントし
     ます)。通常はミニバッファーからキーボード入力を読み取る関数は、かわ
     りに端末の標準入力ストリーム(‘stdin’)から入力を受け取ります。

     ‘--batch’は暗に‘-q’(初期化ファイルをロードしません)を含みますが、そ
     れでも‘site-start.el’はロードされます。これはすべてのコマンドオプシ
     ョンを処理した後に、Emacsを終了します。それに加えて、自動保存が明示
     的に要求された場合を除き、自動保存を無効にします。また自動保存が要
     求されていない場合は、ファイルの保存での‘fsync’システムコールを省略
     します。

‘--script FILE’
     ‘--batch’と同様に、Emacsをバッチモードで実行してから、FILEのLispコ
     ードを読み込み実行します。

     このオプションは通常、Emacsを実行する実行可能スクリプトの中で使用し
     ます。これは以下のテキストを最初の行に記述します:

          #!/usr/bin/emacs --script

     これは‘--script’でEmacsを呼び出し、スクリプトファイル名はFILEです。
     それからEmacs Lispは最初の行の‘#!’をコメント区切りとして扱います。

‘--no-build-details’
     Emacs実行可能形式からシステム名やビルド日時などの詳細を取り除き、そ
     のビルドがより決定論的になります。

‘-q’
‘--no-init-file’
     初期化ファイルをロードしません(*note Init File::を参照してください
     )。Emacsがこのオプションで呼び出された場合、Customize機能は、保存の
     オプションを受け付けません(*note Easy Customization::を参照してくだ
     さい)。このオプションは‘site-start.el’のロードは無効にしません。

‘--no-site-file’
     ‘site-start.el’をロードしません(*note Init File::を参照してください
     )。‘-Q’オプションもこれを行ないますが、‘-q’のような他のオプションは
     これを行ないません。

‘--no-site-lisp’
     ‘load-path’に‘site-lisp’ディレクトリーを含めません(*note Init
     File::を参照してください)。‘-Q’オプションもこれを行ないます。

‘--no-splash’
     スタートアップ画面を表示しません。初期化ファイルで変数
     ‘inhibit-startup-screen’を非‘nil’にセットしても、この効果を得ること
     ができます(*note Entering Emacs::を参照してください)。

‘-Q’
‘--quick’
     最小のカスタマイズでEmacsを開始します。これは‘-q’、
     ‘--no-site-file’、‘--no-site-lisp’、‘--no-splash’を一緒に使用したの
     と同様です。これは‘inhibit-x-resources’を‘t’にセットすることにより
     、EmacsがXリソースの処理を行なうことも停止します(*note Resources::を
     参照してください)。

‘-daemon’
‘--daemon[=NAME]’
‘--bg-daemon[=NAME]’
‘--fg-daemon[=NAME]’
     Emacsをデーモンとして開始します。これはフレームをオープンせずに、ま
     ずEmacsを開始した後、Emacsサーバーを開始します(オプションでサーバー
     に明示的にNAMEを指定できる)。‘emacsclient’コマンドを使用して、編集
     のためにEmacsに接続できます。デーモンとしてのEmacsの使用についての
     情報は、*note Emacs Server::を参照してください。“バックグラウンド
     ”のデーモンは端末から切り離され、バックグラウンドで実行されます
     (‘--daemon’は‘--bg-daemon’のエイリアス)。

‘--no-desktop’
     保存されたデスクトップをリロードしません。*note Saving Emacs
     Sessions::を参照してください。

‘-u USER’
‘--user=USER’
     あなたの初期化ファイルのかわりに、USERの初期化ファイルをロードしま
     す。(1)

‘--debug-init’
     initファイルのエラーにたいして、Emacs Lispデバッガーを有効にします
     。*note Entering the Debugger on an Error: (elisp)Error Debugging.を
     参照してください。

‘--module-assertions’
     動的ロードモジュールを処理する際に、高価な正当性チェックを有効にし
     ます。これは、作成したモジュールがモジュールAPI仕様に従っているか検
     証したいモジュール作者を意図したものです。モジュール関連のassertが
     発生した場合、Emacsはabortします。

   ---------- Footnotes ----------

   (1) このオプションはMS-Windowsでは効果がありません。


File: emacs-ja.info,  Node: Command Example,  Next: Environment,  Prev: Initial Options,  Up: Emacs Invocation

C.3 コマンド引数の例
====================

以下は、引数とオプションを指定してEmacsを使用する例です。ここでは、ロー
ドすることにより、Cプログラムをvisitしたカレントバッファーにたいして、何
か便利な操作を行なう、‘hack-c.el’という名前のLispプログラムファイルがあ
るとしましょう。

     emacs --batch foo.c -l hack-c -f save-buffer >& log

これは‘foo.c’をvisitしてから、‘hack-c.el’(これはvisitされたファイルに何
らかの変更を行ないます)をロードし、‘foo.c’を保存(‘save-buffer’は‘C-x
C-s’にバインドされた関数であることに注意してください)した後に、
(‘--batch’オプションなので)Emacsを終了してシェルに戻ります。‘--batch’は
、出力を‘log’にリダイレクトしても問題がないことが保証されます。なぜなら
Emacsは作業するためのディスプレー端末をもたないと想定されるからです。


File: emacs-ja.info,  Node: Environment,  Next: Display X,  Prev: Command Example,  Up: Emacs Invocation

C.4 環境変数
============

“環境(environment)”とは、オペレーティングシステムの機能です。これは値と
名前をもつ変数のコレクションからなります。それぞれの変数は“環境変数
(environment variable)”と呼ばれます。環境変数名は大文字小文字を区別し、
慣習では大文字だけを使用します。値はすべてテキスト文字列です。

   何が環境を便利にしているかというと、それはサブプロセスが親プロセスか
ら自動的に環境を継承できることです。これはログインシェルで環境変数をセッ
トして、実行するすべて(Emacsを含む)のプログラムが、それを参照できること
を意味します。Emacsのサブプロセス(シェル、コンパイラー、バージョンコント
ロールシステムなど)も、Emacsから環境を継承します。

   Emacsの中では、コマンド‘M-x getenv’は環境変数の名前を読み取って、その
値をエコーエリアにプリントします。‘M-x setenv’はEmacs環境で変数をセット
し、‘C-u M-x setenv’は変数を削除します(‘$’による環境変数の置き換えは、フ
ァイル名にたいする値と同様に機能します。*note File Names with $::を参照
してください)。変数‘initial-environment’は、Emacsにより継承された初期環
境を保管します。

   Emacsの外で環境変数をセットする方法は、オペレーティングシステム、特に
使用しているシェルに依存します。たとえば以下はBashを使用して、環境変数
‘ORGANIZATION’に‘not very much’をセットする例です:

     export ORGANIZATION="not very much"

以下はcshまたはtcshでこれを行なう方法の例です:

     setenv ORGANIZATION "not very much"

   EmacsがXウィンドウシステムを使用している場合、Xを制御するさまざまな環
境変数は、Emacsも同様に制御します。詳細は、Xのドキュメントを参照してくだ
さい。

* Menu:

* General Variables::        すべてのバージョンのEmacsが使用する環境変数。
* Misc Variables::           システム固有の変数。
* MS-Windows Registry::      MS-Windowsでの環境の代用。


File: emacs-ja.info,  Node: General Variables,  Next: Misc Variables,  Up: Environment

C.4.1 一般的な変数
------------------

以下は、Emacsで特別な意味をもつ環境変数の、アルファベット順のリストです
。これらの変数のほとんどは、他のプログラムでも使用されます。Emacsはこれ
らの環境変数がセットされていることを要求しませんが、セットされている場合
はその値を使用します。

‘CDPATH’
     相対ディレクトリーを指定したときに、指定したディレクトリーを検索す
     るために、‘cd’コマンドにより使用されます。
‘DBUS_SESSION_BUS_ADDRESS’
     D-BusサポートつきでEmacsがコンパイルされている場合、D-Busにより使用
     されます。通常これを変更する必要はありません。
     ‘unix:path=/dev/null’のようなダミーアドレスをセットすることにより、
     D-Busセッションバスとの接続を抑止し、同様にD-Busセッションバスがま
     だ実行されていないときは自動的に開始します。
‘EMACSDATA’
     Emacsに含まれるアーキテクチャーに独立なファイルのディレクトリーです
     。これは変数‘data-directory’の初期化に使用されます。
‘EMACSDOC’
     ドキュメント文字列ファイル(documentation string file)にたいするディ
     レクトリーで、Lisp変数‘doc-directory’の初期化に使用されます。
‘EMACSLOADPATH’
     Emacs Lispファイルを検索する、コロンで区切られたディレクトリーのリ
     スト(1)です。セットされている場合は、変数‘load-path’の初期値です
     (*note Lisp Libraries::を参照してください)。空の要素は、
     ‘load-path’のデフォルト値を意味します。たとえば
     ‘EMACSLOADPATH="/tmp:"’を使用すると、デフォルトの‘load-path’の前に
     ‘/tmp’を追加します。リストの中間に空の要素を指定するには、
     ‘EMACSLOADPATH="/tmp::/foo"’のように、2つのコロンを続けます。
‘EMACSPATH’
     実行可能ファイルを検索するための、コロンで区切られたディレクトリー
     のリストです。セットされている場合、Emacsは変数‘exec-path’(*note
     Shell::を参照してください)を初期化するときに、‘PATH’(以下参照)に加
     えてこれをを使用します。
‘EMAIL’
     メールアドレスです。Lisp変数‘user-mail-address’を初期化するために使
     用されます。Emacsのメールインターフェースは、送信メッセージの
     ‘From’ヘッダーにこれを使用します(*note Mail Headers::を参照してくだ
     さい)。
‘ESHELL’
     シェルモードで、環境変数‘SHELL’をオーバーライドするために使用されま
     す(*note Interactive Shell::を参照してください)。
‘HISTFILE’
     ログインしている間のシェルコマンドが保存されるファイルの名前です。
     この変数のデフォルトは、Bashを使用している場合は‘~/.bash_history’、
     kshのときは‘~/.sh_history’、それ以外では‘~/.history’です。
‘HOME’
     ディレクトリーツリー上で、あなたのファイルがある場所です。チルダ
     (‘~’)で始まるファイル名の展開に使用されます。MS-DOSでは、この変数の
     デフォルトはEmacsが開始されたディレクトリーで、そのディレクトリー名
     が‘/bin’で終わる場合、‘/bin’は取り除かれます。Windowsでは、‘HOME’の
     デフォルト値は、ユーザープロファイルディレクトリーの‘Application
     Data’サブディレクトリー(つまり通常は‘C:/Documents and
     Settings/USERNAME/Application Data’。USERNAMEはユーザー名)ですが、
     後方互換のため、‘C:/’に‘.emacs’がある場合は、かわりに‘C:/’がデフォ
     ルト値になります。
‘HOSTNAME’
     Emacsが実行されているホストの名前です。
‘INFOPATH’
     コロンで区切られた、Infoファイルを検索するディレクトリーのリストで
     す。
‘LC_ALL’
‘LC_COLLATE’
‘LC_CTYPE’
‘LC_MESSAGES’
‘LC_MONETARY’
‘LC_NUMERIC’
‘LC_TIME’
‘LANG’
     そのユーザーの優先されるlocaleです。localeには6つのカテゴリーがあり
     、それぞれ環境変数で指定されます。ソートは‘LC_COLLATE’、文字エンコ
     ーディングは‘LC_CTYPE’、システムメッセージは‘LC_MESSAGES’、通貨形式
     は‘LC_MONETARY’、数字は‘LC_NUMERIC’、日時は‘LC_TIME’でlocaleを指定
     します。これらの変数の1つがセットされていない場合、そのカテゴリーの
     デフォルトは環境変数‘LANG’の値、‘LANG’がセットされていない場合は‘C’
     localeになります。しかし‘LC_ALL’が指定された場合、これは他のすべて
     のlocale環境変数のセッティングをオーバーライドします。

     MS-WindowsとmacOSでは、環境で‘LANG’がまだセットされていない場合、
     Emacsはシステムワイドなデフォルト言語にもとづき、‘LANG’をセットしま
     す。MS-Windowsのいくつかのバージョンでは、これはコントロールパネル
     の‘Regional Settings’でセットでき、macOSではSystem Preferenceの
     “Language and Region”でセットできます。

     ‘LC_CTYPE’カテゴリーの値は、デフォルトの言語環境(language
     environment)とコーディングシステム(coding system)を選択するために、
     ‘locale-language-names’、‘locale-charset-language-names’、
     ‘locale-preferred-coding-systems’のエントリーにたいしてマッチされま
     す。*note Language Environments::を参照してください。
‘LOGNAME’
     ユーザーのログイン名です。‘USER’も参照してください。
‘MAIL’
     システムのメールinbox名です。
‘MH’
     mhシステムのセットアップファイル名です。*note MH-E: (mh-e)Top.を参
     照してください。
‘NAME’
     あなたの現実世界での名前です。これは変数‘user-full-name’を初期化す
     るために使用されます(*note Mail Headers::を参照してください)。
‘NNTPSERVER’
     ニュースサーバーの名前です。Gnusパッケージで使用されます。
‘ORGANIZATION’
     あなたが属する組織の名前です。Gnusパッケージで、ポストの
     ‘Organization:’ヘッダーをセットするために使用されます。
‘PATH’
     コロンで区切られた、実行可能ファイルを含むディレクトリーのリストで
     す。これは変数‘exec-path’を初期化するために使用されます(*note
     Shell::を参照してください)。
‘PWD’
     セットされている場合、これはEmacsが開始されたときのデフォルトディレ
     クトリーになるはずです。
‘REPLYTO’
     セットされている場合は、変数‘mail-default-reply-to’の初期値になりま
     す(*note Mail Headers::を参照してください)。
‘SAVEDIR’
     新しいアーティクルがデフォルトで保存されるディレクトリーの名前です
     。Gnusパッケージにより使用されます。
‘SHELL’
     Emacsの中からプログラムのパースや実行に使用されるインタープリターの
     名前です。
‘SMTPSERVER’
     送信メールサーバーの名前です。これは変数‘smtpmail-smtp-server’を初
     期化するために使用されます(*note Mail Sending::を参照してください
     )。
‘TERM’
     Emacsが使用する端末タイプです。Emacsがバッチモードで実行されていな
     いとき、この変数はセットされていなければなりません。MS-DOSでは、デ
     フォルトは‘internal’で、これはその機種固有のディスプレーを扱う、ビ
     ルトインの端末エミュレーションを指定します。
‘TERMCAP’
     ‘TERM’で指定された端末をどのようにプログラムするかを記述する、
     termcapライブラリーファイルの名前です。デフォルトは‘/etc/termcap’で
     す。
‘TMPDIR’
‘TMP’
‘TEMP’
     これらの環境変数は、変数‘temporary-file-directory’を初期化するため
     に使用されます。これは一時ファイルを置く場所を指定します(*note
     Backup::を参照してください)。Emacsは最初に‘TMPDIR’の使用を試みます
     。これがセットされていない場合、通常Emacsは‘/tmp’にフォールバックし
     ます。しかしMS-WindowsとMS-DOSでは、かわりに‘TMP’、次に‘TEMP’、最後
     に‘c:/temp’にフォールバックします。
‘TZ’
     これはデフォルトのタイムゾーン(もしかしたらサマータイムの情報も)を
     指定します。*note (elisp)Time Zone Rules::を参照してください。
     MS-DOSでは、Emacsを開始したときの環境で‘TZ’がセットされていない場合
     、EmacsはDOSが返す国コードにたいして、適切なデフォルト値を定義しま
     す。MS-Windowsでは、Emacsは‘TZ’を使用しません。
‘USER’
     ユーザーのログイン名です。‘LOGNAME’も参照してください。MS-DOSでは、
     デフォルトは‘root’です。
‘VERSION_CONTROL’
     変数‘version-control’の初期化に使用されます(*note Backup Names::を
     参照してください)。

   ---------- Footnotes ----------

   (1) これ以降、“コロンで区切られたディレクトリーのリスト”という場合は
、UnixおよびGNU/Linuxシステムの場合を指します。MS-DOSおよびMS-Windowsで
は、DOS/Windowsファイル名にはドライブ文字の後のコロンが含まれるので、か
わりにセミコロンでディレクトリーが区切られます。


File: emacs-ja.info,  Node: Misc Variables,  Next: MS-Windows Registry,  Prev: General Variables,  Up: Environment

C.4.2 その他の変数
------------------

これらの変数は、特定の設定だけにたいして使用されます:

‘COMSPEC’
     MS-DOSとMS-Windowsで、バッチファイルとシェルの内部コマンドを呼び出
     すときに使用する、コマンドインタープリターの名前です。MS-DOSでは、
     環境変数‘SHELL’のデフォルト値のためにも使用されます。

‘NAME’
     MS-DOSで、この変数は変数‘USER’のデフォルト値として使用されます。

‘EMACSTEST’
     MS-DOSで、内部端末エミュレーターの操作ログに使用するファイルを指定
     します。この機能はバグレポートを送るときに便利です。

‘EMACSCOLORS’
     MS-DOSで、スクリーンカラーを指定します。Emacsは開始時の数瞬、デフォ
     ルトカラーを表示するので、それらの指定にこの方法が便利です。

     この変数の値は2文字のエンコーディングで指定し、それぞれデフォルトフ
     ェイスにたいして、1文字目はフォアグラウンドカラー、2文字目はバック
     グラウンドカラーを指定します。それぞれの文字は、標準のPCテキストモ
     ードディスプレーのカラーを記述する、16進コードを指定します。たとえ
     ばlight grayの背景色でblueのテキストを得たい場合は、
     ‘EMACSCOLORS=17’を指定します。ここで1はカラーblue、7はカラーlight
     grayを指定しています。

     PCディスプレーは通常、8色のバックグラウンドカラーだけをサポートしま
     す。しかしバックグラウンドカラーにたいして、16色すべてを使用できる
     DOSディスプレーにモードを切り替えるので、実際には4ビットのバックグ
     ラウンドカラーすべてが使用されます。

‘PRELOAD_WINSOCK’
     MS-Windowsでこの変数をセットしている場合、Emacsは開始時に、最初に要
     求されたときまで待たずに、ネットワークライブラリーのロードと初期化
     を行ないます。

‘emacs_dir’
     MS-Windowsでは、‘emacs_dir’は特別な環境変数で、これはEmacsがインス
     トールされたディレクトリーのフルパスを指します。Emacsが標準的なディ
     レクトリー構造にインストールされた場合、この変数の値は自動的に計算
     されます。他の環境変数とは異なり、これは開始時にEmacsによりオーバー
     ライドされるので、標準的なインストールをした場合には、あなた自身が
     この変数のセッティングを使用することは、あまりないでしょう。
     ‘EMACSLOADPATH’のような他の環境変数をセットするとき、絶対パスをハー
     ドコーディングするより、‘emacs_dir’を使う法が便利だと気づくでしょう
     。これにより複数バージョンのEmacsが、同じ環境変数のセッティングを共
     有することが可能になり、環境やレジストリーのセッティングを変更せず
     に、Emacsのインストールディレクトリーを変更できるようになります。


File: emacs-ja.info,  Node: MS-Windows Registry,  Prev: Misc Variables,  Up: Environment

C.4.3 MS-Windowsのシステムレジストリー
--------------------------------------

MS-Windowsでは、インストールプログラム‘addpm.exe’が、システムレジストリ
ーの‘HKEY_LOCAL_MACHINE’セクションの、‘/Software/GNU/Emacs’の下の
‘emacs_dir’、‘EMACSLOADPATH’、‘EMACSDATA’、‘EMACSPATH’、‘EMACSDOC’、
‘SHELL’、‘TERM’の値を追加します。これを行なうのは、異なるバージョンの
Windowsにたいして環境変数をセットする、標準的な場所がないからです。最近
のバージョンのEmacsでは、‘addpm.exe’の実行は絶対に必要ではなくなりました
が、古いバージョンからアップグレードする場合、‘addpm.exe’は以前のインス
トールから、(おそらく最新のEmacsと互換性がない)古いレジストリーエントリ
ーを取得しないことを保証します。

   Emacsを開始したときは、環境のチェックと同様に、システムレジストリーの
、これらの変数と‘HOME’、‘LANG’、‘PRELOAD_WINSOCK’もチェックします。

   これらの変数の値を決定するために、Emacsは次の手順にしたがいます。最初
に環境がチェックされます。そこで変数が見つからない場合、Emacsは
‘/Software/GNU/Emacs’のレジストリーキーを名前で探します。最初にレジスト
リーの‘HKEY_CURRENT_USER’セクション、そこで見つからなければ、
‘HKEY_LOCAL_MACHINE’セクションを探します。それでもなおEmacsが値を決定で
きない場合、コンパイルされたときのデフォルトが使用されます。

   上記の環境変数に加えて、Xリソース(*note X Resources::を参照)を指定す
るために‘/Software/GNU/Emacs’のレジストリーキーにセッティングを追加する
こともできます。‘.Xdefaults’ファイル内で指定可能なほとんどのセッティング
を、そのレジストリキーからセットできます。


File: emacs-ja.info,  Node: Display X,  Next: Font X,  Prev: Environment,  Up: Emacs Invocation

C.5 ディスプレー名の指定
========================

環境変数‘DISPLAY’は、Emacsを含むすべてのXクライアントに、ウィンドウをど
こに表示するかを指定します。通常の状況では、この変数の値は、Xサーバーを
開始してローカルでジョブを実行したとき、デフォルトにセットされます。ディ
スプレーを自分で指定することもできます。これを行なう理由の1つは、他のシ
ステムにログインして、そこでEmacsを実行し、ウィンドウはローカル端末のウ
ィンドウに表示させたい場合です。

   ‘DISPLAY’は、‘HOST:DISPLAY.SCREEN’という構文をもちます。ここでHOSTは
Xウィンドウシステムのサーバー機のホスト名、DISPLAYは、あなたのサーバー
(Xサーバー)を、同一機種上の他のサーバーと区別するために任意に割り当てら
れる数字、そしてSCREENフィールドは、Xサーバーが複数の端末スクリーンを制
御することを可能にします。ピリオドとSCREENフィールドはオプションです。
SCREENが含まれる場合、通常は0です。

   たとえば、あなたのホスト名が‘glasperle’で、あなたのサーバーが設定にリ
ストされた最初の(もしかしたら唯一の)サーバーの場合、‘DISPLAY’は
‘glasperle:0.0’になります。

   Emacsを実行するとき、変数‘DISPLAY’を変更するか、オプション‘-d
DISPLAY’または‘--display=DISPLAY’で、明示的にディスプレーを指定できます
。以下は例です:

     emacs --display=glasperle:0 &

   ‘-nw’オプションで、Xウィンドウシステムの使用を抑止できます。その場合
、Emacsはディスプレーとして制御テキスト端末を使用します。*note Initial
Options::を参照してください。

   セキュリティーの規制により、リモートシステムのプログラムが、ローカル
システムで表示を行なうのを禁ずることがあります。この場合、Emacsは以下の
ようなメッセージを出力します:

     Xlib:  connection to "glasperle:0.0" refused by server

ローカル機で‘xhost’コマンドを使用することにより、リモート機からアクセス
する権限を与えれば、この問題を解決できるでしょう。


File: emacs-ja.info,  Node: Font X,  Next: Colors X,  Prev: Display X,  Up: Emacs Invocation

C.6 フォント指定オプション
==========================

デフォルトのフォントを指定するために、コマンドラインオプション‘-fn
FONT’(または‘--font’。これは‘-fn’のエイリアスです)を使用できます。

‘-fn FONT’
‘--font=FONT’
     FONTをデフォルトフォントとして使用します。

   コマンドラインでフォント名をEmacsに渡す場合、フォント名にシェルが特別
に扱う文字(たとえばスペース)が含まれる場合は、クォーテーションマークで囲
んでクォートする必要があるでしょう。たとえば:

     emacs -fn "DejaVu Sans Mono-12"

   フォント名やデフォルトフォントを指定する別の方法についての詳細は、
*note Fonts::を参照してください。


File: emacs-ja.info,  Node: Colors X,  Next: Window Size X,  Prev: Font X,  Up: Emacs Invocation

C.7 ウィンドウカラーオプション
==============================

Emacsディスプレーのさまざまな場所で使用するカラーを指定するために、以下
のコマンドラインオプションを使用できます。カラーは、カラーネーム(color
names)か、RGBトリプレット(RGB triplets)のどちらかを使用して、指定します
。

‘-fg COLOR’
‘--foreground-color=COLOR’
     フォアグラウンドカラーを指定します。‘default’フェイス(*note
     Faces::を参照してください)で指定されたカラーをオーバーライドします
     。
‘-bg COLOR’
‘--background-color=COLOR’
     バックグラウンドカラーを指定します。‘default’フェイスで指定されたカ
     ラーをオーバーライドします。
‘-bd COLOR’
‘--border-color=COLOR’
     Xウィンドウのボーダーカラーを指定します。EmacsがGTK+サポートつきで
     ンパイルされいてる場合、効果はありません。
‘-cr COLOR’
‘--cursor-color=COLOR’
     ポイントがある位置を示すEmacsのカーソルカラーを指定します。
‘-ms COLOR’
‘--mouse-color=COLOR’
     Emacsウィンドウにマウスがあるときの、マウスカーソルカラーを指定しま
     す。
‘-r’
‘-rv’
‘--reverse-video’
     フォアグラウンドカラーとバックグラウンドカラーを入れ替えて、反転表
     示します。
‘--color=MODE’
     Emacsをテキスト端末で実行するときの、“カラーサポートモード(color
     support mode)”をセットします。その文字端末の‘terminfo’データベース
     または‘termcap’で示される、いくつかのサポートされたカラーをオーバー
     ライドします。パラメーターMODEには、以下の1つを指定できます:
     ‘never’
     ‘no’
          端末の能力がカラーをサポートすると指定していても、カラーを使用
          しません。
     ‘default’
     ‘auto’
          ‘--color’を指定しないときと同じです。Emacsは開始時に端末がカラ
          ーをサポートするか検知して、もしサポートされていれば、カラーデ
          ィスプレーをオンに切り替えます。
     ‘always’
     ‘yes’
     ‘ansi8’
          無条件にカラーサポートをオンに切り替えて、標準的な8カラーにた
          いするANSIエスケープシーケンスによるカラーコマンドを使用します
          。
     ‘NUM’
          NUM個のカラーにたいするカラーモードを使用します。NUMが−1の場合
          、カラーサポートをオフに切り替えます(‘never’と同じです)。0の場
          合、この端末にたいするデフォルトのカラーサポートを使用します
          (‘auto’と同じです)。そうでない場合、NUM個のカラーにたいする適
          切な標準モードを使用します。端末の能力により、NUMの値に応じて
          、Emacsは8色、16色、88色、256色のカラーモードに切り替えること
          ができるでしょう。NUMカラーをサポートするモードが存在しない場
          合、EmacsはあたかもNUMに0が指定された場合のように、その端末の
          デフォルトのカラーサポートを使用します。
     MODEが省略された場合のデフォルトは、ANSI8です。

   たとえばcoralのマウスカーソルと、slate blueのテキストカーソルを使用す
るには、以下のように入力します:

     emacs -ms coral -cr 'slate blue' &

   ‘-rv’オプションを指定するか、Xリソースの‘reverseVideo’で、フォアグラ
ウンドとバックグラウンドのカラーを反転できます。

   ‘-fg’、‘-bg’、‘-rv’オプションの機能は、テキスト端末でも、グラフィカル
なディスプレーと同様です。


File: emacs-ja.info,  Node: Window Size X,  Next: Borders X,  Prev: Colors X,  Up: Emacs Invocation

C.8 ウィンドウのサイズと位置にたいするオプション
================================================

以下は、Emacsの初期フレームのサイズと位置を指定する、コマンドラインオプ
ションのリストです:

‘-g WIDTHxHEIGHT[{+-}XOFFSET{+-}YOFFSET]]’
‘--geometry=WIDTHxHEIGHT[{+-}XOFFSET{+-}YOFFSET]]’
     サイズWIDTHとHEIGHT(文字の列数と行数)、および位置XOFFSETと
     YOFFSET(ピクセル)を指定します。パラメーターWIDTHとHEIGHTはすべての
     フレームに適用されますが、XOFFSETとYOFFSETは初期フレームだけに適用
     されます。

‘-fs’
‘--fullscreen’
     スクリーンのサイズになるように、幅と高さを指定します。通常は、ウィ
     ンドウマネージャーによる装飾は表示されません(Emacsを起動した後に、
     <F11> ‘toggle-frame-fullscreen’を使用して、この状態を切り替えること
     ができます)。

‘-mm’
‘--maximized’
     Emacsのフレームが最大化されるよう指定します。これは通常、そのフレー
     ムがウィンドウマネージャーによる装飾をもつことを意味します(Emacsを
     起動した後に、‘M-F10’ ‘toggle-frame-maximized’を使用して、この状態
     を切り替えることができます)。

‘-fh’
‘--fullheight’
     高さがスクリーンの高さになるように指定します。

‘-fw’
‘--fullwidth’
     幅がスクリーンと同じ幅になるように指定します。

‘--geometry’オプションでは、‘{+-}’は、プラス記号かマイナス記号のどちらか
を意味します。XOFFSETの前のプラス記号はスクリーンの左端からの距離、マイ
ナス記号は右端からの距離を意味します。YOFFSETの前のプラス記号はスクリー
ンの上端からの距離、マイナス記号は下端からの距離を意味します。XOFFSETと
YOFFSETの値自体に正または負の値を指定できますが、それはこれらの意味を変
更するものではなく、方向だけを変更します。

   Emacsは、‘xterm’がジオメトリーを解釈するのと同じ単位を使用します。
WIDTHとHEIGHTは文字で数えられるので、大きなフォントは、小さなフォントよ
り大きなフレームを作成します(プロポーショナルフォントを指定した場合、
Emacsは幅の単位として、そのプロポーショナルフォントの最大幅を使用します
)。XOFFSETとYOFFSETはピクセルで数えます。

   ジオメトリー指定で、すべてのフィールドを指定する必要はありません。
XOFFSETとYOFFSETの両方を省略した場合、ウィンドウマネージャーがEmacsフレ
ームをどこに配置するかを決定するか、もしかしたらマウスでその場所を指定で
きるかもしれません。たとえば‘164x55’は、ウィンドウの幅が164(通常のウィン
ドウを横に2つ並べられる幅)で、55行分の高さを指定します。

   デフォルトのフレーム幅は80文字で、デフォルトの高さは40行です。幅と高
さの、どちらか一方、または両方を省略できます。ジオメトリーが整数で開始さ
れる場合、Emacsはそれを幅と解釈します。ジオメトリーの開始が‘x’でその後に
整数が続く場合、Emacsはそれを高さと解釈します。したがって‘81’は幅だけを
指定し、‘x45’は高さだけを指定します。

   ジオメトリーを‘+’か‘-’で開始した場合、それはオフセットを示し、幅と高
さの両方のサイズが省略されたことを意味します。したがって‘-3’はXOFFSETだ
けを指定します(オフセットを1つだけ与えたとき、それは常にXOFFSETになりま
す)。‘+3-3’はXOFFSETとYOFFSETの両方を指定し、フレームをスクリーンの左下
に配置します。

   Xリソースファイル(*note Resources::を参照してください)で、任意または
すべてのフィールドにたいするデフォルトを指定できます。それらにたいしてフ
ィールドを選択して、‘--geometry’オプションでオーバーライドできます。

   モードラインとエコーエリアはフレームの2行を占めるので、初期のテキスト
ウィンドウの高さは、ジオメトリーで指定した高さより、2つ少なくなります。
非X-toolkitバージョンのEmacsでは、指定した数から、メニューバーの占める
1行が引かれます。しかしX-toolkitバージョンでは、メニューバーは付加的で、
指定された高さにたいして数えられません。ツールバーがある場合も、それは付
加的です。

   メニューバーやツールバーを有効または無効にすることにより、通常のテキ
ストが利用できるスペースが変わります。したがって、Emacsがツールバーつき
(デフォルト)で開始しされ、ツールバーがあることを前提にジオメトリー指定を
処理して、それを初期化ファイルでツールバーを無効にしていた場合、あなたが
指定したのと異なるフレームジオメトリーになるでしょう。ツールバーがないサ
イズを得るには、Xリソースで“no tool bar”を指定します(*note Table of
Resources::を参照してください)。そうすれば、Emacsは指定されたジオメトリ
ーを処理するときに、ツールバーがないことを知ることができます。

   ‘--fullscreen’、‘--maximized’、‘--fullwidth’、‘--fullheight’のどれか
1つを使用するとき、フレームが本当に最大化またはフルスクリーンに見えるよ
うにするために、変数‘frame-resize-pixelwise’を非‘nil’値にすることを要求
するウィンドウマネージャーがいくつかあります。

   位置にたいする、プログラム指定とユーザー指定の両方を無視するようにで
きるオプションをもつウィンドウマネージャーがいくつかあります。これらのオ
プションがセットされている場合、Emacsはウィンドウを正しく配置するのに失
敗します。


File: emacs-ja.info,  Node: Borders X,  Next: Title X,  Prev: Window Size X,  Up: Emacs Invocation

C.9 内枠ボーダーと外枠ボーダー
==============================

１つのEmacsフレームは内枠ボーダー(internal border)と、外枠ボーダー(outer
border)をもちます。内枠ボーダーはフレームのテキスト部分の周囲にある、バ
ックグラウンドカラーによる追加の縁取り(extra strip)です。内枠ボーダーは
Emacs自身が描画します。外枠ボーダーはフレームのツールバーとメニューバー
の外側にあり、Xにより描画されます。ウィンドウマネージャーにより描画され
る外部ボーダー(external border)も存在します。外部ボーダーのサイズは、
Emacs内からセットすることはできません。

‘-ib WIDTH’
‘--internal-border=WIDTH’
     内枠ボーダー(フレームのテキストエリア周辺)の幅に、ピクセル単位で
     WIDTHを指定します。

‘-bw WIDTH’
‘--border-width=WIDTH’
     外枠ボーダーの幅に、ピクセル単位でWIDTHを指定します。

   フレームのサイズを指定するとき、ボーダーは含まれません。フレームの位
置は、外枠ボーダーの縁端から測られます。

   ピクセル幅Nの内枠ボーダーを指定するには、‘-ib N’オプションを使用しま
す。デフォルトは1です。外枠ボーダーの幅を指定するには、‘-bw N’を使用しま
す(ウィンドウマネージャーはその指定に注意を払わないかもしれませんが)。外
枠ボーダーのデフォルト幅は2です。


File: emacs-ja.info,  Node: Title X,  Next: Icons X,  Prev: Borders X,  Up: Emacs Invocation

C.10 フレームタイトル
=====================

Emacshフレームは常に指定されたタイトルをもち、それはウィンドウ装飾とアイ
コンに、フレームの名前として表示されます。デフォルトのタイトルは
‘INVOCATION-NAME@MACHINE’という形式(フレームが1つだけのとき)か、選択され
たウィンドウのバッファー名(複数のフレームがある場合)になります。

   コマンドラインオプションで、Emacsの初期フレームにデフォルト以外のタイ
トルを指定できます:

‘-T TITLE’
‘--title=TITLE’
     Emacs初期フレームのタイトルとしてTITLEを指定します。

   ‘--name’オプション(*note Resources::を参照してください)でも、Emacs初
期フレームのタイトルを指定できます。


File: emacs-ja.info,  Node: Icons X,  Next: Misc X,  Prev: Title X,  Up: Emacs Invocation

C.11 アイコン
=============

‘-iconic’
‘--iconic’
     Emacsをアイコン化した状態で開始します。

‘-nbi’
‘--no-bitmap-icon’
     Emacsアイコンの使用を無効にします。

   ほとんどのウィンドウマネージャーでは、Emacsフレームをアイコン化(また
は“最小化”)して、見えなくすることができます。いくつかのウィンドウマネー
ジャーでは、他のウィンドウマネージャーがアイコン化されたウィンドウを完全
に見えなくするのにたいして、アイコン化されたウィンドウを小さなアイコンで
おきかえるものもあります。‘-iconic’オプションは、フレームをすぐに表示す
るのではなく、アイコン化された状態で実行を開始するよう、Emacsに指示しま
す。テキストフレームはアイコン化の解除(または“最小化の解除”)をするまで表
示されません。

   デフォルトでは、EmacsはEmacsロゴを含むアイコンを使用します。Gnomeのよ
うなデスクトップ環境では、このアイコンは他のコンテキスト、たとえば
Emacsフレームに切り替えるときにも表示されます。‘-nbi’または
‘--no-bitmap-icon’オプションは、使用するアイコンの種類をウィンドウマネー
ジャーに選択させるよう、Emacsに指示します。通常これはフレームのタイトル
を含んだ、ただの矩形です。


File: emacs-ja.info,  Node: Misc X,  Prev: Icons X,  Up: Emacs Invocation

C.12 その他のディスプレーオプション
===================================

‘--parent-id ID’
     XEmbedプロトコルを通じて、IDを親XウィンドウIDとする、クライアント
     Xウィンドウとして、Emacsを開始します。現在のところ、このオプション
     は開発者にとって有用です。

‘-vb’
‘--vertical-scroll-bars’
     垂直スクロールバーを有効にします。

‘-lsp PIXELS’
‘--line-spacing=PIXELS’
     行間の追加のスペースPIXELSを、ピクセルで指定します。

‘-nbc’
‘--no-blinking-cursor’
     グラフィカルなディスプレーで、点滅カーソルを無効にします。

‘-D’
‘--basic-display’
     メニューバー、ツールバー、スクロールバー、ツールチップを無効にして
     、点滅カーソルをオフに切り替えます。これは表示問題のデバッグするテ
     ストケースを簡単にするのに有用です。

   ‘--xrm’オプション(*note Resources::を参照してください)は、追加のXリソ
ース値を指定します。


File: emacs-ja.info,  Node: X Resources,  Next: Antinews,  Prev: Emacs Invocation,  Up: Top

Appendix D Xのオプションとリソース
**********************************

Xを使用するプログラムにたいして通常行なうように、Xリソースを使用して
EmacsのXに関連する外観をカスタマイズできます。

   EmacsがGTK+サポートつきでコンパイルされている場合、メニューバー、スク
ロールバー、ダイアログボックスなどの、さまざまなグラフィカルウィジェット
の外観は GTK+リソースで決定されるので、これについても説明します。 Emacsが
GTK+のサポートなしでビルドされた場合、これらのウィジェットの外観は追加の
Xリソースにより決定されます。

   MS-Windowsでは、システムレジストリー(*note MS-Windows Registry::を参
照してください)を使用して、いくつかの外観を同じようにカスタマイズできま
す。

* Menu:

* Resources::                EmacsでXリソースを使用する(概説)。
* Table of Resources::       Emacsに影響する特定のXリソースの表。
* Lucid Resources::          LucidメニューにたいするXリソース。
* Motif Resources::          MotifおよびLessTifメニューにたいするXリソース。
* GTK resources::            GTK+ウィジェットにたいするリソース。


File: emacs-ja.info,  Node: Resources,  Next: Table of Resources,  Up: X Resources

D.1 Xリソース
=============

Xウィンドウシステムの下で実行されているプログラムは、クラスとリソースの
階層の下にユーザーオプションを組織化します。これらのオプションにたいして
、“Xリソースファイル(X resource file)”でデフォルト値を指定できます。Xリ
ソースファイルは、通常‘~/.Xdefaults’または‘~/.Xresources’という名前です
。このファイルの内容を変更しても、変更は即座に効果をもちません。これは
Xサーバーが独自にリソースのリストを保持しているからです。これを更新する
には、たとえば‘xrdb ~/.Xdefaults’のように、コマンド‘xrdb’を使用します。

   (MS-WindowsシステムはXリソースファイルをサポートしません。そのような
システムでは、EmacsはWindowsレジストリーの中からXリソースを探します。最
初にキー‘HKEY_CURRENT_USER\SOFTWARE\GNU\Emacs’の下を探します。これはカレ
ントユーザーだけに影響し、システムワイドなセッティングをオーバーライドし
ます。次にキー‘HKEY_LOCAL_MACHINE\SOFTWARE\GNU\Emacs’の下を探します。こ
れはシステムのすべてのユーザーに影響します。メニューとスクロールバーは、
MS-Windowsのネイティブなウィジェットなので、Display Control Panelのシス
テムワイドなセッティングからしかカスタマイズできません。以下で説明するよ
うに、コマンドラインオプション‘-xrm’を使用して、リソースをセットすること
もできます。)

   Xリソースファイルの各行は、1つのオプション、または関連するオプション
のコレクションにたいして値を指定します。ファイル内で行が出現する順番に意
味はありません。各リソース指定は、“プログラム名(program name)”と“リソー
ス名(resource name)”から構成されます。これらの名前の大文字小文字は区別さ
れます。以下は例です:

     emacs.cursorColor: dark green

   プログラム名は、そのリソースが適用される実行可能ファイルの名前です。
Emacsでは通常、‘emacs’です。Emacsの実行可能ファイル名の如何にかかわらず
に、Emacsのすべてのインスタンスに適用される定義を指定するには、‘Emacs’を
使用します。

   リソース名はプログラムセッティングの名前です。たとえばEmacsは、
‘cursorColor’リソースを、テキストカーソルのカラーを制御するリソースと認
識します。

   リソースは、名前のついたクラスにグループ化されます。たとえば
‘Foreground’クラスには、リソース‘cursorColor’、‘foreground’、
‘pointerColor’が含まれます(*note Table of Resources::を参照してください
)。以下のように、リソース名を使用するかわりに、クラス内のすべてのリソー
スにたいしてデフォルト値を指定するのに、クラス名を使用できます:

     emacs.Foreground: dark green

   変数‘inhibit-x-resources’を非‘nil’値にセットした場合、EmacsはXリソー
スを処理しません。コマンドラインオプション‘-Q’ (または‘--quick’)で
Emacsを呼び出した場合、‘inhibit-x-resources’は自動的に‘t’にセットされま
す(*note Initial Options::を参照してください)。

   これに加えて、Xリソースファイルをオーバーライドするために、以下のコマ
ンドラインオプションが使用できます:

‘-name NAME’
‘--name=NAME’
     このオプションは初期Emacsフレームのプログラム名をNAMEにセットします
     。これは初期フレームのタイトルもNAMEにセットします。このオプション
     は、それ以降のフレームには影響しません。

     このオプションを指定しない場合、プログラム名としてEmacs実行可能ファ
     イル名をデフォルトとして使用されます。

     整合性のため、‘-name’は、特定のフレームに属さない、他のリソース値に
     たいして使用する名前も指定します。

     Emacs呼び出しの名前がつくリソースは、‘Emacs’という名前のクラスにも
     所属します。‘emacs’のかわりに‘Emacs’と記述した場合、実行可能ファイ
     ル名にかかわらず、そのリソースは、すべてのEmacsジョブのすべてのフレ
     ームに適用されます。

‘-xrm RESOURCE-VALUE’
‘--xrm=RESOURCE-VALUE’
     このオプションは、現在のEmacsジョブにたいして、Xリソース値を指定し
     ます。

     RESOURCE-VALUEは、Xリソースファイルの内部で使用するのと同じ形式をも
     つ必要があります。複数のリソース指定を含めるために、複数の‘-xrm’オ
     プションを利用可能です。‘#include \"FILENAME\"’を使用して、ファイル
     のリソース指定をすべてインクルードすることもできます。‘-xrm’で指定
     されたリソース値は、他のすべてのリソース指定に優先します。


File: emacs-ja.info,  Node: Table of Resources,  Next: Lucid Resources,  Prev: Resources,  Up: X Resources

D.2 EmacsにたいするXリソースの表
================================

以下のテーブルは、Emacsが認識するXリソース名です。いくつかのリソースは、
Emacsが種々のXツールキット(GTK+、Lucid、...等)とともにコンパイルされてい
なければ効果がないことに注意してください(以下ではそのような場合は個々に
を示す)。

‘background’ (class ‘Background’)
     バックグラウンドカラーです(*note Colors::を参照してください)。

‘bitmapIcon’ (class ‘BitmapIcon’)
     ‘on’のときはEmacsアイコンを表示し、‘off’のときは表示しないように、
     ウィンドウマネージャーに指示します。アイコンの説明は、*note Icons
     X::を参照してください。

‘borderColor’ (class ‘BorderColor’)
     フレームの外枠ボーダーのカラーです。EmacsがGTK+サポートつきでコンパ
     イルされている場合、効果はありません。

‘borderWidth’ (class ‘BorderWidth’)
     フレームの外枠ボーダーの幅(ピクセル)です。EmacsがGTK+サポートつきで
     コンパイルされている場合、効果はありません。

‘cursorBlink’ (class ‘CursorBlink’)
     開始時に、このリソースの値が‘off’、‘false’、‘0’の場合、EmacsはBlink
     Cursorモードを無効にします(*note Cursor Display::を参照してください
     )。

‘cursorColor’ (class ‘Foreground’)
     テキストカーソルのカラーです。Emacs開始時にこのリソースが指定されて
     いる場合、Emacsはその値を‘cursor’フェイス(*note Faces::を参照してく
     ださい)のバックグラウンドカラーとしてセットします。

‘font’ (class ‘Font’)
     ‘default’フェイスにたいするフォント名です(*note Fonts::を参照してく
     ださい)。フォントセット名(*note Fontsets::を参照してください)を指定
     することもできます。

‘fontBackend’ (class ‘FontBackend’)
     フォントの描画に使用するバックエンドを、優先順にカンマ区切りで記述
     したリストです。たとえば値‘x,xft’は、EmacsにXコアフォントドライバー
     (X core font driver)を使用してフォントを描画し、それに失敗したとき
     はXftフォントドライバー(Xft font driver)にフォールバックするよう指
     示します。このリソースは通常、セットしないでおくべきです。その場合
     、Emacsは利用可能なすべてのバックエンドの使用を試みます。

‘foreground’ (class ‘Foreground’)
     テキストにたいするデフォルトのフォアグラウンドカラーです。

‘fullscreen’ (class ‘Fullscreen’)
     望ましいフルスクリーンサイズを指定します。値は‘fullboth’、
     ‘maximized’、‘fullwidth’、‘fullheight’のうちどれか1つを指定でき、こ
     れらはコマンドラインオプションの‘-fs’、‘-mm’、‘-fw’、‘-fh’に相当し
     ます(*note Window Size X::を参照してください)。これは初期フレームだ
     けに適用されることに注意してください。

‘geometry’ (class ‘Geometry’)
     ウィンドウのサイズと位置です。値にはコマンドラインオプション‘-g’ま
     たは‘--geometry’と同じ形式で、サイズと位置を指定します。

     サイズはEmacsセッションのすべてのフレームに適用されますが、位置は初
     期フレーム(特定のフレームにたいするリソースの場合は、そのフレーム
     )だけに適用されます。

     このリソースを、‘emacs*geometry’のように指定しないように気をつけて
     ください。これはEmacsのメインのフレームと同じように、個別のメニュー
     にも影響します。

‘horizontalScrollBars’ (class ‘ScrollBars’)
     このリソースの値が‘off’、‘false’、‘0’の場合、Emacsは開始時に
     Horizontal Scroll Barモードを無効にします(*note Scroll Bars::を参照
     )。

‘iconName’ (class ‘Title’)
     アイコンに表示する名前です。

‘internalBorder’ (class ‘BorderWidth’)
     フレームの内枠ボーダーの幅(ピクセル)です。

‘lineSpacing’ (class ‘LineSpacing’)
     行間の追加のスペース(ピクセル)です。

‘menuBackground’ (class ‘Background’)
     ツールキット版でないEmacsの、メニューのバックグラウンドカラーです
     (ツールキット版の場合は*note Motif Resources::と*note GTK
     resources::を参照してください)。

‘menuBar’ (class ‘MenuBar’)
     このリソースの値が‘off’、‘false’、‘0’の場合、Emacsは開始時にMenu
     Barモードを無効にします(*note Menu Bars::を参照してください)。

‘minibuffer’ (class ‘Minibuffer’)
     ‘none’の場合、Emacsはこのフレームにミニバッファーを作成しません。か
     わりに別のミニバッファーフレームを使用します。

‘paneFont’ (class ‘Font’)
     ツールキット版でないEmacsの、メニューペインタイトルのフォント名です
     (ツールキット版の場合は*note Lucid Resources::、*note Motif
     Resources::、*note GTK resources::を参照)。

‘paneForeground’ (class ‘Foreground’)
     ツールキット版でないEmacsの、メニューペインタイトルのフォント名です
     (ツールキット版の場合は*note Lucid Resources::、*note Motif
     Resources::、*note GTK resources::を参照)。

‘pointerColor’ (class ‘Foreground’)
     マウスカーソルのカラーです。多くのグラフィカルなデスクトップ環境で
     は、この方法でEmacsがマウスカーソルを変更するのを許さないので、効果
     はありません。

‘privateColormap’ (class ‘PrivateColormap’)
     ‘on’の場合、Emacsが使用するクラスPseudoColorのdefault visualが使用
     されている場所で、プライベートなカラーマップを使用します。

‘reverseVideo’ (class ‘ReverseVideo’)
     ‘on’の場合はデフォルトのフォア九ラウンドカラーとバックグラウンドカ
     ラーを切り替え、‘off’の場合は指定されたカラーを使用します。

‘screenGamma’ (class ‘ScreenGamma’)
     カラーのガンマ補正で、フレームパラメーターの‘screen-gamma’と等価で
     す。

‘scrollBar’ (class ‘ScrollBar’)
     このリソースの値が‘off’、‘false’、‘0’の場合、Emacsは開始時にScroll
     Barモードを無効にします(*note Scroll Bars::を参照してください)。

‘scrollBarWidth’ (class ‘ScrollBarWidth’)
     スクロールバーの幅(ピクセル)で、フレームパラメーターの
     ‘scroll-bar-width’と等価です。EmacsがGTK+サポートつきでコンパイルさ
     れている場合は、このリソースをセットしないでください。

‘selectionFont’ (class ‘SelectionFont’)
     ツールキット版でないEmacsの、ポップアップメニューアイテムのフォント
     名です(ツールキット版の場合は*note Lucid Resources::、*note Motif
     Resources::、*note GTK resources::を参照)。

‘selectionForeground’ (class ‘SelectionForeground’)
     ツールキット版でないEmacsの、ポップアップメニューアイテムのフォアグ
     ラウンドカラーです(ツールキット版の場合は*note Lucid Resources::、
     *note Motif Resources::、*note GTK resources::を参照してください)。

‘selectionTimeout’ (class ‘SelectionTimeout’)
     選択にたいする応答を待つ時間(ミリ秒)です。選択したオーナーが、この
     時間内に応答しない場合は諦めます。値0は必要なだけ待つことを意味しま
     す。

‘synchronous’ (class ‘Synchronous’)
     ‘on’の場合、Emacsを同期モード(synchronous mode)で実行します。同期モ
     ードはXに関する問題のデバッグに有用です。

‘title’ (class ‘Title’)
     初期Emacsフレームのタイトルバーに表示する名前です。

‘toolBar’ (class ‘ToolBar’)
     このリソースの値が‘off’、‘false’、‘0’の場合、Emacsは開始時にTool
     Barモードを無効にします(*note Tool Bars::を参照してください)。

‘useXIM’ (class ‘UseXIM’)
     ‘false’または‘off’の場合、X入力メソッド(XIM: X input methods)の使用
     を無効にします。これはEmacsがXIMサポートつきでビルドされた場合だけ
     関係があります。Xのクライアント/サーバーのリンクが遅いときは、XIMを
     オフにするのが便利かもしれません。

‘verticalScrollBars’ (class ‘ScrollBars’)
     ‘left’の場合はフレームの左側、‘right’の場合は右側、‘off’のときはス
     クロールバーをもちません(*note Scroll Bars::を参照)。

‘visualClass’ (class ‘VisualClass’)
     Xカラーディスプレーの“visual class”です。指定する場合、値は
     ‘TrueColor’、‘PseudoColor’、‘DirectColor’、‘StaticColor’、
     ‘GrayScale’、‘StaticGray’で始まり、その後に‘-DEPTH’が続きます。ここ
     でDEPTHは色平面の数です。

   特定のEmacsフェイスのカスタマイズに、Xリソースを使用することもできま
す(*note Faces::を参照してください)。たとえば
‘FACE.attributeForeground’をセットするのは、フェイスFACEの‘foreground’属
性をカスタマイズするのと等価です。しかし、わたしたちはXリソースを使用し
てフェイスのカスタマイズするかわりに、Emacs内でフェイスをカスタマイズす
る方法を推奨します。*note Face Customization::を参照してください。


File: emacs-ja.info,  Node: Lucid Resources,  Next: Motif Resources,  Prev: Table of Resources,  Up: X Resources

D.3 Lucidのメニューとダイアログ
===============================

EmacsがLucidウィジェットを使用したXツールキットサポートつきでコンパイル
された場合、メニューバー(*note Menu Bar::を参照)、ポップアップメニュー、
ダイアログボックス(*note Dialog Boxes::を参照)の外観をカスタマイズするた
めに、Xリソースを使用できます。メニューバーにたいするリソースは、
‘pane.menubar’クラスの中に集められています(例のごとくEmacs実行可能ファイ
ル名または、すべてのEmacs呼び出しに対応する‘Emacs’の後に続けて記述します
)。ポップアップメニューにたいするリソースは、‘menu*’クラスの中です。ダイ
アログボックスにたいするリソースは、‘dialog*’クラスの中です。

   たとえばメニューバーエントリーを‘Courier-12’フォントで表示するには、
以下のように記述します:

     Emacs.pane.menubar.font: Courier-12

Lucidウィジェットは、あなたのlocaleで他国語テキストを表示できます。これ
を有効にするには、‘font’リソースのかわりに、‘fontSet’リソースを指定しま
す。‘font’と‘fontSet’の両方のリソースが指定された場合は、‘fontSet’リソー
スが使用されます。

   以下はメニューバー、ポップアップメニュー、ダイアログにたいするリソー
スのリストです:

‘font’
     メニューアイテムのテキストにたいするフォントです。
‘fontSet’
     メニューアイテムのテキストにたいするフォントセットです。
‘background’
     バックグラウンドカラーです。
‘buttonForeground’
     選択されたアイテムのフォアグラウンドカラーです。
‘foreground’
     フォアグラウンドカラーです。
‘horizontalSpacing’
     アイテム間の水平間隔(ピクセル)です。デフォルトは3です。
‘verticalSpacing’
     アイテム間の垂直間隔(ピクセル)です。デフォルトは2です。
‘arrowSpacing’
     (サブメニューを示す)矢印と、それに付随するテキストの間の水平間隔で
     す。デフォルトは10です。
‘shadowThickness’
     3Dのボタン、矢印、その他グラフィカルな要素の陰線(shadow lines)の厚
     さです。デフォルトは1です。
‘margin’
     メニューバーの余白(文字数)です。デフォルトは1です。


File: emacs-ja.info,  Node: Motif Resources,  Next: GTK resources,  Prev: Lucid Resources,  Up: X Resources

D.4 MotifメニューのXリソース
============================

EmacsがMotifまたはLessTifのウィジェットを使用するXツールキットサポートつ
きでコンパイルされた場合、メニューバー(*note Menu Bar::を参照)、ポップア
ップメニュー、ダイアログボックス(*note Dialog Boxes::を参照)の外観をカス
タマイズするために、Xリソースを使用できます。しかし、これらのリソースは
、Lucidウィジェットとは組織方法が異なります。

   メニューバーにたいするリソース名は‘pane.menubar’クラスの中にあり、そ
れらは以下の形式で指定しなければなりません:

     Emacs.pane.menubar.SUBWIDGET.RESOURCE: VALUE

ポップアップメニューにたいするリソースは、‘pane.menubar’ではなく、
‘menu*’クラスの中にあります。ダイアログボックスにたいするリソースは
‘dialog’クラスの中です。どの場合でも、それぞれのメニュー文字列がサブウィ
ジェットです。サブウィジェットの名前は、メニューアイテム文字列と同じです
。たとえば、メニューバーの中の‘File’メニューは、
‘emacs.pane.menubar.File’という名前のサブウィジェットです。

   通常は、メニューバー全体に同じリソースを指定したいでしょう。これを行
なうには、特定のウィジェット名のかわりに‘*’を使用します。たとえば、サブ
メニューを含むすべてのメニューバーアイテムに、フォント‘8x16’を指定するに
は、以下のように記述します:

     Emacs.pane.menubar.*.fontList: 8x16

   サブメニューの中の各アイテムは、Xリソースにたいする独自の名前をもちま
す。たとえば‘File’サブメニューは、‘Save (current buffer)’という名前のア
イテムをもちます。サブメニューアイテムにたいするリソース指定は以下のよう
になります:

     Emacs.pane.menubar.popup_*.MENU.ITEM.RESOURCE: VALUE

たとえば、以下は‘Save (current buffer)’アイテムにフォントを指定する方法
です:

     Emacs.pane.menubar.popup_*.File.Save (current buffer).fontList: 8x16

‘Tools’の下の、‘Spell Checking’の下の‘Complete Word’のような、第2レベル
のアイテムには、以下のテンプレートが当てはまります:

     Emacs.pane.menubar.popup_*.popup_*.MENU.RESOURCE: VALUE

たとえば、

     Emacs.pane.menubar.popup_*.popup_*.Spell Checking.Complete Word: VALUE

(これは長い1行で記述する必要があります。)

   サブメニューアイテムにメニューバー自体とは異なる外観を与えたい場合、
最初にすべてにたいしてリソースを指定してから、そのサブメニューにたいする
値をオーバーライドしなければなりません。以下は例です:

     Emacs.pane.menubar.*.fontList: 9x18
     Emacs.pane.menubar.popup_*.fontList: 8x16

   LessTifのファイル選択ボックスにたいしてリソースを指定するには、以下の
ように‘fsb*’を使用します:

     Emacs.fsb*.fontList: 8x16

   以下はLessTifのメニューバーとポップアップメニューにたいするリソースの
リストです:

‘armColor’
     アームドボタン(armed button: 押されてまだ離されていないボタン)を表
     示するカラーです。
‘fontList’
     使用するフォントです。
‘marginBottom’
‘marginHeight’
‘marginLeft’
‘marginRight’
‘marginTop’
‘marginWidth’
     アイテムの周囲に残すスペースの量を、ボーダーも含めて指定します。
‘borderWidth’
     メニューアイテムの各辺のボーダーの幅です。
‘shadowThickness’
     ボーダーの影の幅です。
‘bottomShadowColor’
     ボーダーの影の底辺と右辺のカラーです。
‘topShadowColor’
     ボーダーの影の上辺と左辺のカラーです。


File: emacs-ja.info,  Node: GTK resources,  Prev: Motif Resources,  Up: X Resources

D.5 GTK+ resources
==================

EmacsがGTK+サポートつきでコンパイルされた場合、EmacsのGTK+ウィジェット
(例: メニュー、ダイアログ、ツールバー、スクロールバー)をカスタマイズする
一番簡単な方法は、たとえばGNOME theme selectorなどで適切なGTK+テーマを選
択する方法です。

   GTK+バージョン2では、Emacsで使用されるGTK+ウィジェットの外観をカスタ
マイズするために、“GTK+リソース”も使用できます。これらのリソースは、ファ
イル‘~/.emacs.d/gtkrc’(Emacs固有のGTK+リソース用)、またはファイル
‘~/.gtkrc-2.0’(一般的なGTK+リソース用)のどちらかで指定されます。GTK+は、
GNOMEでGConfを実行するとき‘~/.gtkrc-2.0’を無視するように思われるため、わ
たしたちは‘~/.emacs.d/gtkrc’の使用を推奨します。しかし
‘~/.emacs.d/gtkrc’によるカスタマイズをオーバーライドするGTK+テーマがある
ことに注意してください。これにたいして、わたしたちができることはありませ
ん。GTK+リソースは、EmacsのGTK+ウィジェットと関係のない側面、たとえば
Emacsのメインウィンドウのフォントやカラーにたいしては影響しません。これ
らは通常のXリソースに管理されます(*note Resources::を参照してください)。

   以下のセクションでは、EmacsにたいしてGTK+リソースをカスタマイズする方
法を説明します。GTK+リソースについての詳細は、
<https://developer.gnome.org/gtk2/stable/gtk2-Resource-Files.html>のGTK+
APIドキュメントを参照してください。

   GTK+バージョン3では、GTK+リソースは完全に異なるシステムに置き換えられ
ました。GTK+ウィジェットの外観は、今やCSS-likeなスタイルのファイル、すな
わちGTK+をインストールしたディレクトリーの‘gtk-3.0/gtk.css’、およびロー
カルなスタイルセッティングにたいしては
‘~/.themes/THEME/gtk-3.0/gtk.css’で決定されます(THEMEはカレントGTK+テー
マの名前です)。したがってこのセクションのGTK+リソースの説明は、GTK+3に適
合しません。GTK+3スタイリングシステムについての詳細は、
<https://developer.gnome.org/gtk3/3.0/GtkCssProvider.html>を参照してくだ
さい。

* Menu:

* GTK Resource Basics::      GTK+リソースの基本的な使い方。
* GTK Widget Names::         GTK+ウィジェットの命名方法。
* GTK Names in Emacs::       Emacsが使用するGTK+ウィジェット。
* GTK styles::               GTK+ウィジェットの何がカスタマイズできるか。


File: emacs-ja.info,  Node: GTK Resource Basics,  Next: GTK Widget Names,  Up: GTK resources

D.5.1 GTK+リソースの基本
------------------------

GTK+2リソースファイル(通常は‘~/.emacs.d/gtkrc’)で、リソースをセットする
一番簡単な方法は、単に変数に値を割り当てる方法です。たとえば以下の行を利
ソースファイルに置くことにより、すべてのGTK+ウィジェットのフォントが
‘courier-12’に変更されます:

     gtk-font-name = "courier 12"

この場合、フォント名はFontconfigスタイルのフォント名やXLFDではなく、
GTKフォントパターン(“Pangoフォント名”とも呼ばれます)で記述しなければなり
ません。*note Fonts::を参照してください。

   ウィジェットをカスタマイズするには、最初に“スタイル”を定義して、その
スタイルをウィジェットに適用します。以下はメニューにたいしてフォントをセ
ットする例です(文字‘#’はコメントを示します):

     # Define the style ‘my_style’.
     style "my_style"
     {
       font_name = "helvetica bold 14"
     }

     # Specify that widget type ‘*emacs-menuitem*’ uses ‘my_style’.
     widget "*emacs-menuitem*" style "my_style"

この例のウィジェット名にはワイルドカードが含まれるので、このスタイルは
‘*emacs-menuitem*’にマッチするすべてのウィジェットに適用されます。ウィジ
ェットは、外側のウィジェットから内側のウィジェットへと、それが含まれる方
法により、名前がつけられます。以下はEmacsメニューバーに‘my_style’を指定
して適用する例です:

     widget "Emacs.pane.menubar.*" style "my_style"

   以下はスクロールバーを部分的に変更する方法を示す、より複雑な例です:

     style "scroll"
     {
       fg[NORMAL] = "red"     # Arrow color.
       bg[NORMAL] = "yellow"  # Thumb and background around arrow.
       bg[ACTIVE] = "blue"    # Trough color.
       bg[PRELIGHT] = "white" # Thumb color when the mouse is over it.
     }

     widget "*verticalScrollBar*" style "scroll"


File: emacs-ja.info,  Node: GTK Widget Names,  Next: GTK Names in Emacs,  Prev: GTK Resource Basics,  Up: GTK resources

D.5.2 GTK+ウィジェット名
------------------------

GTK+ウィジェットは“ウィジェット名(widget name)”と“ウィジェットクラス
(widget class)”により指定されます。ウィジェット名は特定のウィジェット(た
とえば‘emacs-menuitem’)を参照し、ウィジェットクラスは似通ったウィジェッ
ト(たとえば‘GtkMenuItem’)のコレクションを参照します。ウィジェットは常に
クラスをもちますが、名前をもつ必要はありません。

   “絶対名(absolute names)”とは、一連のウィジェット名またはウィジェット
クラスで、他のウィジェットに埋め込まれたウィジェットの階層に対応します。
たとえば、‘top’という名前の‘GtkWindow’が、‘box’という名前の‘GtkVBox’を含
み、それがさらに‘menubar’という名前の‘GtkMenuBar’を含む場合、メニューバ
ーウィジェットの完全クラス名は‘GtkWindow.GtkVBox.GtkMenuBar’で、完全ウィ
ジェット名は‘top.box.menubar’になります。

   GTK+リソースファイルには、ウィジェットの外観を指定する2種類のコマンド
を含めることができます:

‘widget’
     クラス名または単にクラスにもとづいてウィジェットのスタイルを指定し
     ます。

‘widget_class’
     クラス名にもとづいてウィジェットのスタイルを指定します。

‘widget’コマンドを使用する例は、前のセクションを参照してください。
‘widget_class’コマンドも同じように使用されます。ウィジェット名/ウィジェ
ットクラスとスタイルはダブルクォートで囲わなければならないこと、そしてこ
れらのコマンドはGTK+リソースファイルのトップレベルに記述しなければならな
いことに注意してください。

   前に記したように、ウィジェット名とウィジェットクラスはシェルのワイル
ドカード構文で指定することができます。‘*’は0文字以上にマッチし、‘?’は1文
字にマッチします。以下はすべてのウィジェットにスタイルを割り当てる例です
:

     widget "*" style "my_style"


File: emacs-ja.info,  Node: GTK Names in Emacs,  Next: GTK styles,  Prev: GTK Widget Names,  Up: GTK resources

D.5.3 EmacsでのGTK+ウィジェット名
---------------------------------

Emacsフレームが使用するGTK+ウィジェットを以下にリストします:

‘Emacs’ (class ‘GtkWindow’)
     ‘pane’ (class ‘GtkVBox’)
          ‘menubar’ (class ‘GtkMenuBar’)
               [menu item widgets]
          [unnamed widget] (class ‘GtkHandleBox’)
               ‘emacs-toolbar’ (class ‘GtkToolbar’)
                    [tool bar item widgets]
          ‘emacs’ (class ‘GtkFixed’)
               ‘verticalScrollBar’ (class ‘GtkVScrollbar’)

Emacsウィンドウの内容は、‘emacs’ウィジェットにより描画されます。複数の
Emacsウィンドウがある場合でも、それぞれのスクロールバーウィジェットの名
前は‘verticalScrollBar’であることに注意してください。

   たとえば、以下はメニューバーのスタイルをセットする、2つの異なる方法の
例です:

     widget "Emacs.pane.menubar.*" style "my_style"
     widget_class "GtkWindow.GtkVBox.GtkMenuBar.*" style "my_style"

   GTK+ダイアログにたいしては、Emacsはクラス‘GtkDialog’の、
‘emacs-dialog’という名前のウィジェットを使用します。ファイル選択にたいし
ては、Emacsはクラス‘GtkFileSelection’の、‘emacs-filedialog’という名前の
ウィジェットを使用します。

   ポップアップメニューとダイアログのウィジェットは独立したウィンドウで
あり、‘Emacs’ウィジェットに含まれていないので、それらのGTK+完全名は
‘Emacs’で始まりません。これらのウィジェットをカスタマイズするには、以下
のようにワイルドカードを使用します:

     widget "*emacs-dialog*" style "my_dialog_style"
     widget "*emacs-filedialog* style "my_file_style"
     widget "*emacs-menuitem* style "my_menu_style"

   Emacsのすべてのメニューにスタイルを適用したい場合は、以下を使用します
:

     widget_class "*Menu*" style "my_menu_style"


File: emacs-ja.info,  Node: GTK styles,  Prev: GTK Names in Emacs,  Up: GTK resources

D.5.4 GTK+ styles
-----------------

以下は2つのGTK+スタイル宣言の例です:

     pixmap_path "/usr/share/pixmaps:/usr/include/X11/pixmaps"

     style "default"
     {
       font_name = "helvetica 12"

       bg[NORMAL] = { 0.83, 0.80, 0.73 }
       bg[SELECTED] = { 0.0, 0.55, 0.55 }
       bg[INSENSITIVE] = { 0.77, 0.77, 0.66 }
       bg[ACTIVE] = { 0.0, 0.55, 0.55 }
       bg[PRELIGHT] = { 0.0, 0.55, 0.55 }

       fg[NORMAL] = "black"
       fg[SELECTED] = { 0.9, 0.9, 0.9 }
       fg[ACTIVE] = "black"
       fg[PRELIGHT] = { 0.9, 0.9, 0.9 }

       base[INSENSITIVE] = "#777766"
       text[INSENSITIVE] = { 0.60, 0.65, 0.57 }

       bg_pixmap[NORMAL] = "background.xpm"
       bg_pixmap[INSENSITIVE] = "background.xpm"
       bg_pixmap[ACTIVE] = "background.xpm"
       bg_pixmap[PRELIGHT] = "<none>"

     }

     style "ruler" = "default"
     {
       font_name = "helvetica 8"
     }


   スタイル‘ruler’は‘default’を継承します。この方法により、既存のスタイ
ルを元にすることができます。フォントとカラーの構文は以下に記述されていま
す。

   この例が示すように、ウィジェットの“状態”にもとづいてフォアグラウンド
とバックグラウンドのカラーに複数の値を指定することが可能です。以下の状態
が利用できます:

‘NORMAL’
     ウィジェットのフォルトの状態です。

‘ACTIVE’
     ウィジェットが何かを行なう準備ができた状態です。これはスクロールバ
     ーの溝(trough)にも適用できます。たとえば‘bg[ACTIVE] = "red"’はスク
     ロールバーの溝を赤にセットします。ボタンのarmed(ボタンが押されてま
     だ離されていない状態)も、この状態です。

‘PRELIGHT’
     マウスポインターがその上にきたとき、ウィジェットが操作可能な状態で
     す — たとえばマウスがスクロールバーのハンドルの上やメニューアイテム
     の上にきたときの状態です。押されていないボタンの上にマウスがくると
     、そのボタンはこの状態になります。

‘SELECTED’
     ユーザーにより選択されたデータにたいする状態です。それは選択された
     テキストやリストの選択されたアイテムの場合もあります。この状態は
     Emacsでは使用されません。

‘INSENSITIVE’
     ウィジェットが可視だが通常の方法では操作できない状態 — たとえば押せ
     ないボタンや、無効なメニューアイテムなどです。無効なメニューアイテ
     ムを黄色で表示するには、‘fg[INSENSITIVE] = "yellow"’を使用します。

   以下をスタイル宣言に記述できます:

‘bg[STATE] = COLOR’
     ウィジェットのバックグラウンドカラーを指定します。編集可能なテキス
     トは‘bg’ではなく‘base’を使用することに注意してください。

‘base[STATE] = COLOR’
     編集可能なテキストのバックグラウンドカラーを指定します。Emacsでは、
     ファイルダイアログのテキストフィールドのバックグラウンドに、このカ
     ラーが使用されます。

‘bg_pixmap[STATE] = "PIXMAP"’
     (バックグラウンドカラーのかわりに)バックグラウンドイメージを指定し
     ます。PIXMAPはイメージファイル名です。GTK+はXPM、XBM、GIF、JPEG、
     PNGヲ含む、いくつかのイメージファイルを使用することができます。親ウ
     ィジェットと同じイメージをウィジェットに使用したい場合は、
     ‘<parent>’を使用します。イメージを使わない場合は、‘<none>’を使用し
     ます。‘<none>’で、親スタイルから継承されたバックグラウンドイメージ
     をキャンセルできます。

     ファイル名は絶対ファイル名で指定できません。GTK+は‘pixmap_path’で指
     定されたディレクトリーのpixmapファイルを探します。‘pixmap_path’は、
     ダブルクォートされたファイルをコロンで区切ったリストで、‘gtkrc’ファ
     イルのトップレベルで指定します(スタイル定義の中ではありません。上記
     の例を参照してください)。

          pixmap_path "/usr/share/pixmaps:/usr/include/X11/pixmaps"

‘fg[STATE] = COLOR’
     使用するウィジェットのフォアグラウンドカラーを指定します。これはメ
     ニューやボタンのテキストのカラー、スクロールバーの矢印のカラーです
     。編集可能なテキストにたいしては、‘text’を使用します。

‘text[STATE] = COLOR’
     編集可能なテキストのカラーです。Emacsでは、ファイルダイアログのテキ
     ストフィールドに使用されるカラーです。

‘font_name = "FONT"’
     ウィジェット内のテキストのフォントを指定します。FONTは、‘Sans
     Italic 10’のような、GTK(Pango)スタイルのフォント名です。*note
     Fonts::を参照してください。名前は大文字小文字を区別しません。

   カラーを指定する3つの方法があります。それはカラーネーム、RGBトリプレ
ット、GTKスタイルRGBトリプレットです。カラーネームとRGBトリプレットにつ
いては、*note Colors::を参照してください。カラーネームは‘"red"’のように
、ダブルクォートで囲む必要があります。RGBトリプレットは‘#ff0000’のように
、ダブルクォートで囲う必要がありません。GTKスタイルRGBトリプレットは
‘{ R, G, B }’という形式をもち、R、G、Bは、0から65535の整数か、0.0から
1.0の浮動小数点数です。


File: emacs-ja.info,  Node: Antinews,  Next: Mac OS / GNUstep,  Prev: X Resources,  Up: Top

Appendix E Emacs 25 アンチニュース
**********************************

時代に逆らって生きるユーザーのために、以下はEmacsバージョン25.3へのダウ
ングレードに関する情報です。Emacs 26.1機能の不在による結果としての偉大な
る単純さを、ぜひ堪能してください。

   • Emacsはビルド時にデフォルトでGnuTLSライブラリーを要求しなくなりまし
     た。ビルトインとしてTLS機能を欲するユーザーは、ビルド時に明示的に要
     求するか — 永遠に口を閉じているかです。わたしたちはTLS機能をもつこ
     とにより、libgnutls不在によるエラーメッセージにより、ユーザーやパッ
     ケージをビルドする人を煩わせるのは、正当性はないと判断しました。ま
     た、GnuTLSとともにビルドする場合は、バージョン2.12.2はあなたが時代
     を逆行するにしたがい利用性と知名度が減少するので、2.12.2より古いバ
     ージョンが容認されると判断しました。

   • 同様の理由により、安全でないチャンネルを通じた平文によりPOP3メール
     を取得する、わたしたち自身のバージョンの‘movemail’をビルドするよう
     に戻しました。あなたが時代を逆行するにしたがい、POP3の安全な代替物
     の利用性は減少していき、わたしたちは単にそれを熱烈に支持するだけで
     す。さらにconfigure時のオプション‘--with-mailutils’は、観察可能な過
     去において意味をもたないため削除されました。

   • わたしたちは‘systemd’と、それに類するサービスにたいするサポートを削
     除しました。これらのサービスを通じたEmacs使用を可能にするユーザーの
     initファイルは提供されなくなり、これらのサービス下でのEmacsクライア
     ントにとっては重要だったEmacsサーバーのソケット起動にたいするサポー
     トも削除されました。繰り返しますが、これらのサービスはあなたが時代
     を逆行するにしたがい知名度を失うので、これらをサポートするコードは
     Emacsを肥大化させるだけの不要コードなのです。

   • Emacsの再現可能なビルドは、過去の開発により不必要になるので、サポー
     トされなくなります。

   • ‘--fg-daemon’はなくなり、‘--daemon’だけが残りました。新しい光り輝く
     “愚かなEmacs(headless Emacs)”を欲すべきか否かというジレンマなどでグ
     ズグズする必要はありません。Hail, simplicity!(単純さ、万歳!)

   • あなたが時代を逆行するにしたがいTrueColorをサポートするテキスト端末
     は地歩を失うので、わたしたちはテキスト端末の24ビットカラーにたいす
     るサポートを削除しました。テキスト端末に色を望むなら、8ビットカラー
     で満足すべきなのです。(正直に言うと、わたしたちはテキスト端末はモノ
     クロであるべきと考えています。ただ、あなたがこの機能に戻るためには
     、古いEmacsバージョンへとダウングレードを続ける必要があるでしょう。
     )

   • Emacs 25.3ではスクリプト内の‘#!/usr/bin/env INTERPRETER’形式による
     フォーマット識別子(magic signature)はサポートされなくなります。時代
     を逆行するということは、すべてのインタープリターは単一のディレクト
     リー‘/bin’にあるという原始Unixデザインに近づくことを意味するので、
     この空想的な機能は単に不必要となるのが確実です。

   • X上でのEmacsディスプレイのダブルバッファリング機能は削除されました
     。たとえこの機能で得られるものを一部の人々が熱望するとしても、わた
     したちはその複雑性と2、3の突発的で驚くべき副作用は、それにより得ら
     れるものを正当化しないと判断しました。確かにEmacs 25.3は、あるユー
     スケースにおいてはチカチカします。しかしEmacsユーザーは彼らが何年も
     してきたように、そんなことは乗り越えるのです。この機能がなくなった
     ので、今や不必要となったフレームパラメーター
     ‘inhibit-double-buffering’も削除しました。

   • サポートされていないクォート文字の代替えとして表示されていた
     non-breaking hyphenとASCII文字は、再び‘escape-glyph’フェイスを使用
     して表示されます。わたしたちは3つの異なるフェイスより単一のフェイス
     をもつほうが、ユーザーのEmacsカスタマイズ作業をより単純にすると考え
     ます。同じ理由により‘header-line-highlight’は削除され、Emacsディス
     プレイのモードライン周辺の要素は単なる‘highlight’フェイスとなります
     。

   • Cのスタックオーバーフローのような致命的な例外や致命的なシグナルから
     のリカバリーの試みは、無効にできなくなりました。Emacsに含まれるリカ
     バリー機能は十分に信頼に足るので、これらの状況が発生したときに編集
     内容を失うような危険にさらす必要はないとわたしたちは判断しました。
     したがって、変数‘attempt-stack-overflow-recovery’および
     ‘attempt-orderly-shutdown-on-fatal-signal’は削除されました。

   • タイマーはユーザーレベルの機能ではないとわたしたちは判断したため、
     ‘list-timers’コマンドは削除されました。ユーザーはタイマーへの干渉を
     許されるべきではないのです。近くのEmacs Lisp導師に、セッション内に
     暴走タイマー(runaway timer)があったらどうなるか尋ねてください。(も
     ちろん、あなたが時代を逆行するにしたがい、そのような暴走タイマーは
     稀になり、実際のタイマーは反対方向の時間には対処できないので、自動
     的にシャットダウンを開始するでしょう。)

   • マウスやタッチパッドを使用した水平スクロールは削除されました。過去
     にはワイドモニターはそれほどポピュラーではなかったので、水平スクロ
     ールはもはや必要とされないでしょう。水平スクロールにたいするマウス
     サポートの削除は、以前のバージョンのEmacsにおける水平スクロール完全
     削除の最初のステップです。

   • わたしたちは‘emacsclient’の‘--tramp’オプションは、あまりに危険かつ
     複雑なことに気づいたので、クライアントコードと使い方の単純化のため
     削除しました。

   • ‘display-raw-bytes-as-hex’変数はなくなったので、8進エスケープでのみ
     rawバイトの表示が可能です。Emacsユーザーなら、8進から他の基数への変
     換など、眠りながらできるべきなのです!

   • バッファーにたいする行番号の表示は、ディスプレイ余白に番号を表示す
     るだけの‘linum-mode’モードのようなアドオンを使用したときだけ可能に
     なります。これらの機能を用いた行番号表示は低速でもあり、第一そのよ
     うな機能はEmacsっぽくなく、Emacsに含まれるべきではないと、わたした
     ちは確信しています。その結果、‘display-line-numbers-mode’は削除され
     ました。

   • Emacsのシンプル化という永遠の課題のもと、わたしたちはオプション
     ‘--alternate-editor’および環境変数‘ALTERNATE_EDITOR’を通じてコマン
     ドライン引数をEmacsに渡すためのサポートを削除しました。残ったのは真
     のEmacs — ‘emacs’として呼び出されたときは、これらすべての奇妙なオプ
     ションなど必要としないEmacsだけです!

   • “単一行水平スクロール(single-line horizontal scrolling)”として知ら
     れる複雑さは、Emacs 25.3からなくなります。これは、“他のエディター
     ”に屈従する機能でした。そのかわりに毎回ウィンドウ全体を水平スクロー
     ルすることにより、他のエディターをEmacsに屈従させましょう。わたしの
     後に続けてください、“Emacs流オンリー!!(The Emacs way is the Only
     Way!)”

   • TurkishやGreekのようないくつかのlocaleで使用されていた、非ASCIIの空
     想的な大文字小文字変換は、7ビットASCIIにおける大文字と小文字の単純
     な関連性のみを残して削除されました。同様に、大文字小文字を変換した
     ときに複数の文字に変換されるような関連性も — 削除されました。

   • Enchant、および同じようなスペルチェックコマンドは、
     ‘ispell-buffer’によりサポートされなくなりました。あなたが時代を逆行
     するにしたがいEnchantは次第に消え去り、それにたいするサポートも必要
     なくなります。

   • TrampはGoogle Driveリポジトリーにたいするサポートを失いました。あな
     たが時代を逆行するにしたがいクラウドストレージは逐次消え去るので、
     この機能は冗長になっていきます。

   • 不必要に複雑と思われる、いくつかのコマンドは削除されました。それら
     のコマンドには、たとえば‘replace-buffer-contents’や
     ‘apropos-local-variable’が含まれます。

   • Emacs 25.3では、コンピューターのメモリー容量とディスク容量を削減し
     て、良好な状態に保つために、その他多くの機能とファイルが削除されま
     した。


File: emacs-ja.info,  Node: Mac OS / GNUstep,  Next: Microsoft Windows,  Prev: Antinews,  Up: Top

Appendix F EmacsとmacOS / GNUstep
*********************************

このセクションでは、GNU/Linuxまたはその他のオペレーティングシステムで
GNUstepライブラリーとともにビルドされたEmacs、またはmacOSでネイティブウ
ィンドウシステムのサポートつきでビルドされたEmacsを使用する際の特性を説
明します。macOSでは、Emacsはウィンドウシステムサポートなし/あり、X11、
Cocoaインターフェースのいずれかでビルドできます。このセクションはCocoaビ
ルドだけに適合します。バージョン10.6より前のmacOSはサポートしません。

   GNUstepはフリーソフトウェアであり、macOSはそうではありません。非フリ
ーなオペレーティングシステムのため、macOSはすべてのコンピューターユーザ
ーが享受すべき自由を、ユーザーに与えません。これは不当です。あなたの自由
のために、わたしたちはフリーなオペレーティングシステムへの切り替えを強く
推奨します。

   わたしたちは、商業オペレーティングシステム上のGNU Emacsをサポートしま
す。なぜならそれは、この自由の経験が、商業オペレーティングシステムから脱
却するよう、ユーザーを奮起するだろうからです。

   さまざまな歴史的、技術的な理由により、Emacsは内部的に“Cocoa”や
“macOS”ではなく、‘Nextstep’という用語を使用します。たとえばこのセクショ
ンで説明するほとんどのコマンドや変数は‘ns-’で始まりますが、これは
‘Nextstep’を短縮したものです。NeXTstepは1980年代にNeXT Inc.からリリース
されたアプリケーションインターフェースで、Cocoaはそれの直系の子孫です。
Cocoaとは別に、他にもNeXTstepスタイルのシステムのGNUstepがあり、これはフ
リーソフトウェアです。これを記述している時点で、EmacsのGNUstepサポートは
アルファ状態(*note GNUstep Support::を参照してください)ですが、わたした
ちは、将来これを改善したいと望んでいます。

* Menu:

* Mac / GNUstep Basics::     GNUstepまたはmacOSでのEmacsの基本的な使用方法。
* Mac / GNUstep Customization::  GNUstepまたはmacOSでのカスタマイズ。
* Mac / GNUstep Events::     ウィンドウシステムイベントが処理される方法。
* GNUstep Support::          GNUstepサポート状態の詳細。


File: emacs-ja.info,  Node: Mac / GNUstep Basics,  Next: Mac / GNUstep Customization,  Up: Mac OS / GNUstep

F.1 macOSおよびGNUstepでのEmacsの基本的な使い方
===============================================

デフォルトでは、キー<Alt>と<Option>は、<Meta>と同じです。Macの<Cmd>キー
は<Super>と同じで、Emacsは他のMac/GNUstepアプリケーション(*note Mac /
GNUstep Events::を参照してください)を模倣するこれらの修飾キーを使用した
、一連のキーバインドを提供します。これらのキーバインドは通常の方法で変更
できます(*note Key Bindings::を参照してください)。

   変数‘ns-right-alternate-modifier’は、右の<Alt>と<Option>キーの動作を
制御します。変数の値が‘left’(デフォルト)の場合、これらのキーは左側のキー
と同じように動作します。値が‘control’、‘meta’、‘alt’、‘super’、‘hyper’の
場合、これらのキーはその値に対応する修飾キーのように動作します。値
‘left’は、‘ns-alternate-modifier’と同じキーであることを意味します。値
‘none’は、Emacsにこれらを無視するよう指示します。この場合は、右
<Option>キーにたいするmacOS強調システム(accentuation system)のデフォルト
の挙動を得ることができます。

   ‘S-mouse-1’は‘mouse-3’と同様に、クリックした位置にリージョンを調整し
ます(‘mouse-save-then-kill’)。‘S-mouse-1’が通常行なうように、デフォルト
フェイスを変更するためのポップアップメニュー(*note Text Scale::を参照し
てください)は表示しません。この変更は、Emacsが他のMac/GNUstepアプリケー
ションと同じように動作させるためです。

   メニューを使用してファイルを開いたり保存するときや、‘Cmd-o’や
‘Cmd-S’といったキーバインドを使用する場合、Emacsはファイル名の読み取りに
グラフィカルなファイルダイアログを使用します。しかし‘C-x C-f’のような標
準のEmacsのキーシーケンスを使用する場合、Emacsはミニバッファーを使用して
ファイル名を読み取ります。

   GNUstepでは、X-windows環境においてテキストをXのプライマリー選択
(primary selection)に転送するために、‘C-w’や‘M-w’のかわりに、‘Cmd-c’を使
用する必要があります。そうでない場合、Emacsはクリップボード選択を使用し
ます。同様に(‘C-y’のかわりに)‘Cmd-y’は、killリングやクリップボードではな
く、Xのプライマリー選択からyankします。

F.1.1 環境変数の取得
--------------------

latexやmanのような、Emacsの下で実行される多くのプログラムは、環境変数の
セッティングに依存します。Emacsがシェルから起動された場合、自動的にこれ
らの環境変数を継承し、Emacsのサブプロセスもそれらを継承します。しかし
EmacsがFinderから起動された場合は、シェルの子プロセスではないので、環境
変数はセットされません。これによりサブプロセスの振る舞いが、シェルから実
行したときと異なることが起こり得ます。

   変数PATHおよびMANPATHにたいしては、macOSではPATHをセットするシステム
ワイドな手法は、‘/etc/paths’ファイルと‘/etc/paths.d’ディレクトリーを使用
することが推奨されています。


File: emacs-ja.info,  Node: Mac / GNUstep Customization,  Next: Mac / GNUstep Events,  Prev: Mac / GNUstep Basics,  Up: Mac OS / GNUstep

F.2 Mac / GNUstepでのカスタマイズ
=================================

多くはありませんが、Nextstepポートに特有のカスタマイズオプションがいくつ
かあります。たとえば修飾キーやフルスクリーン動作に影響するオプションです
。そのようなオプションをすべて閲覧するには、‘M-x customize-group <RET>
ns <RET>’を使用します。

F.2.1 フォントパネル
--------------------

標準のMac/GNUstepのフォントパネルにアクセスするには、‘M-x
ns-popup-font-panel’を使用します。これは一番最近使用された、またはクリッ
クされたフレームの、デフォルトフォントをセットします。

   macOSでは、EmacsはデフォルトでCore Textベースのフォントバックエンドを
使用します。古いフォントスタイルにしたい場合は、Emacsを起動する前に、以
下のコマンドラインを入力します:

     % defaults write org.gnu.Emacs FontBackend ns


File: emacs-ja.info,  Node: Mac / GNUstep Events,  Next: GNUstep Support,  Prev: Mac / GNUstep Customization,  Up: Mac OS / GNUstep

F.3 macOSおよびGNUstepでのウィンドウシステムイベント
====================================================

Nextstepアプリケーションは、Xでは同等なものがない、特別なイベントを受け
取ります。これらは、対応するキーストロークのシーケンスとしてではなく、特
別に定義されたキーイベントとして送られます。Emacsでは、これらのキーイベ
ントを、通常のキーストロークのように、関数にバインドできます。以下はこの
ようなイベントのリストです。

<ns-open-file>
     このイベントは、他のNextstepアプリケーションがEmacsにファイルを開く
     よう要求したときに発生します。これの典型的な理由としては、ユーザー
     がFinderアプリケーションでファイルをダブルクリックしたときなどです
     。デフォルトでは、Emacsはこのイベントにたいして、新しいフレームを開
     いて、そのフレームでファイルをvisitして応答します(‘ns-find-file’)。
     例外として、選択されたバッファーが‘*scratch*’バッファーの場合、
     Emacsは選択されたフレームでファイルをvisitします。

     Emacsが‘ns-open-file’イベントにたいしてどのように応答するかは、
     ‘ns-pop-up-frames’を変更することにより、変えることができます。デフ
     ォルト値は‘fresh’で、これは上で説明したとおりの動作を行ないます。値
     ‘t’は、ファイルを常に新しいフレームでvisitすることを意味します。値
     ‘nil’は、ファイルを常に選択されたフレームでvisitすることを意味しま
     す。

<ns-open-temp-file>
     このイベントは、他のアプリケーションがEmacsに一時ファイルを開くよう
     に要求したとき発生します。デフォルトでは、単に‘ns-open-file’イベン
     トを生成することにより処理され、結果は上で説明したとおりになります
     。

<ns-open-file-line>
     ProjectBuilderやgdbのようないくつかのアプリケーションは、特定のファ
     イルだけではなく、そのファイルの特定の行、または一連の行を要求しま
     す。Emacsはそのファイルをvisitして要求された行をハイライトすること
     により、これを処理します(‘ns-open-file-select-line’)。

<ns-drag-n-drop>
     このイベントは、ユーザーが他のアプリケーションから、Emacsフレームに
     ファイルをドラッグしたとき発生します。デフォルトの動作は、マウスの
     下にあるウィンドウでファイルをオープンするか、マウスの下にあるウィ
     ンドウのポイント位置にテキストを挿入します。テキストを強制的に挿入
     するために、<Meta>キーとの併用が必要な場合もあるかもしれません。

<ns-change-font>
     このイベントは、ユーザーがNextstep font panel(これは‘Cmd-t’で開くこ
     とができます)でフォントを選択したとき発生します。デフォルトの動作は
     、選択されたフレームのフォントを変更します
     (‘ns-respond-to-changefont’)。選択されたフォントの名前とサイズは、
     変数‘ns-input-font’と‘ns-input-fontsize’に格納されます。

<ns-power-off>
     このイベントは、ユーザーがEmacsを実行中にログアウトしたとき、または
     アプリケーションメニューから“Quit Emacs”を選択したとき発生します。
     デフォルトの動作は、ファイルをvisitしているすべてのバッファーを保存
     します。

   Emacsはユーザーに、‘ns-service-’で始まりサービス名で終わるコマンドを
通じて、Nextstepサービスを使用することも可能にします。‘M-x
ns-service-<TAB>’とタイプして、これらのコマンドをリストを見ることができ
ます。これらの関数は、マークされたテキストを処理(結果でそれを置き換える
)したり、文字列を引数として結果を文字列で返します。Lisp関数
‘ns-perform-service’を使用して、任意の文字列を任意のサービスに渡して、結
果を受けとることもできます。新たに利用可能になったサービスにアクセスする
には、Emacsの再起動が必要なことに注意してください。


File: emacs-ja.info,  Node: GNUstep Support,  Prev: Mac / GNUstep Events,  Up: Mac OS / GNUstep

F.4 GNUstepにたいするサポート
=============================

EmacsはGNUstepの下でビルドして実行することができますが、解決すべき問題が
残っています。興味のある開発者は、 <emacs-devel@gnu.org>に連絡してくださ
い。


File: emacs-ja.info,  Node: Microsoft Windows,  Next: Manifesto,  Prev: Mac OS / GNUstep,  Up: Top

Appendix G EmacsとMicrosoft Windows/MS-DOS
******************************************

このセクションでは、Microsoft WindowsでEmacsを使用する際の特性を説明しま
す。これらの特性の中には、Microsoft’sの古いMS-DOSオペレーティングシステ
ムに関連するものもあります。しかしMS-DOS_だけ_に関連するEmacs機能につい
ては、別の セクション(*note MS-DOS::を参照してください)で説明します。

   フリーなオペレーティングシステムのため、MS-Windowsはすべてのコンピュ
ーターユーザーが享受すべき自由を、ユーザーに与えません。これは不当です。
あなたの自由のために、わたしたちはフリーなオペレーティングシステムへの切
り替えを強く推奨します。

   わたしたちは、商業オペレーティングシステム上のGNU Emacsをサポートしま
す。なぜならそれは、この自由の経験が、商業オペレーティングシステムから脱
却するよう、ユーザーを奮起するだろうからです。

   MS-WindowsでのEmacsの振る舞いは、ロングファイル名のサポート、複数フレ
ーム、スクロールバー、マウスメニュー、サブプロセスを含めて、このマニュア
ルの他の部分でドキュメントされているのと、だいたい同じです。しかし多くは
ありませんが、特別に考慮すべきこともあるので、それらについてはここで説明
します。

* Menu:

* Windows Startup::          WindowsでEmacsを開始する方法。
* Text and Binary::          行末にCRLFを使用するテキストファイル。
* Windows Files::            Windowsのファイル名の慣習。
* ls in Lisp::               Diredにたいする‘ls’のエミュレーション。
* Windows HOME::             開始時にEmacsが‘.emacs’を探す場所。
* Windows Keyboard::         Windows特有のキーボード機能。
* Windows Mouse::            Windows特有のマウス機能。
* Windows Processes::        Windowsでのサブプロセスの実行。
* Windows Printing::         MS-Windowsでプリンターを指定する方法。
* Windows Fonts::            MS-Windowsでのフォントの指定。
* Windows Misc::             その他のWindowsの機能。
* MS-DOS:: MS-DOSでのEmacsの使用。


File: emacs-ja.info,  Node: Windows Startup,  Next: Text and Binary,  Up: Microsoft Windows

G.1 MS-WindowsでEmacsを開始する方法
===================================

MS-WindowsでEmacsを開始するには、いくつかの方法があります:

  1. デスクトップのショートカットアイコンから、それを左マウスボタンでダ
     ブルクリックするか、1回クリックしてから<RET>を押します。デスクトッ
     プのショートカットは、ショートカットの“Target”(ショートカットの
     ‘Properties”の中にあります)に、‘emacs.exe’ではなく、
     ‘runemacs.exe’の絶対ファイル名を指定する必要があります。なぜならシ
     ョートカットのターゲットが‘emacs.exe’(Windowsから見る限りこれはコン
     ソールプログラムです)のときに作成されるコンソールウィンドウを、
     ‘runemacs.exe’は隠すからです。この方法を使用する場合、Emacsはショー
     トカットで指定されたディレクトリーで開始されます。これを制御するに
     は、ショートカットを右クリックして“Properties”を選択し、
     “Shortcut”タブで“Start in”フィールドを変更します。

  2. タスクバーのショートカットアイコンを左マウスボタンで1回クリックしま
     す。Windows Vista以降のバージョンでは、タスクバー内に表示される実行
     中プログラムのアイコンを“ピン留め(pinning)”することにより、そのよう
     なショートカットが作成できます。Emacsでこれを行うことができますが、
     その後にピン留めされたショートカットのプロパティで、実行するプログ
     ラムを‘emacs.exe’_ではなく_‘runemacs.exe’に変更する必要があるでしょ
     う。Startメニュー内のEmacsアイコンをマウスの右ボタンでクリックして
     、‘Pin to taskbar’を選択する方法でも、タスクバーにEmacsをピン留めす
     ることができます。繰り返しますが、実行するプログラムには、
     ‘runemacs.exe’を指定してください。ショートカットのプロパティで
     “Start in”をセットすることにより、Emacsを開始する場所を制御できます
     。

  3. コマンドプロンプトウィンドウから、プロンプトにたいして‘emacs
     <RET>’とタイプします。そのコマンドプロンプトウィンドウからは、
     Emacsを終了するまで、他のコマンドを呼び出すことはできなくなります。
     この場合、EmacsはWindowsシェルのカレントディレクトリーで開始されま
     す。

  4. コマンドプロンプトウィンドウから、プロンプトにたいして‘runemacs
     <RET>’とタイプします。そのコマンドプロンプトウィンドウから、すぐに
     別のコマンドを呼び出すことが可能になります。この場合Emacsは
     Windowsシェルのカレントディレクトリーで開始されます。

  5. Windowsの‘Run’ダイアログ(通常は‘Start’ボタンをクリックしてアクセス
     できる)を使用します。そのダイアログ内で‘runemacs <RET>’とタイプすれ
     ば、Windowsでのユーザーの‘HOME’ディレクトリーの親ディレクトリーで、
     Emacsが起動するでしょう。*note Windows HOME::を参照してください。

  6. ‘emacsclient.exe’または‘emacsclientw.exe’を通じてEmacsを開始します
     。これらのコマンドは、Emacsを他のプログラムから呼び出して、他のプロ
     グラムから要求された編集ジョブのために、実行中のEmacsプロセスを再使
     用します。*note Emacs Server::を参照してください。2つのコマンドの違
     いは、‘emacsclient.exe’がコンソールプログラムなのにたいして、
     ‘emacsclientw.exe’はWindowsのGUIプログラムであるという点です。どち
     らのプログラムも、プログラムを終了して呼び出したプログラムに制御を
     戻す前に、Emacsが編集ジョブの終了をシグナルするまで待ちます。これら
     のコマンドを、それぞれどのような場合に使用するかは、編集サービスを
     必要とするプログラムが期待することに依存します。そのプログラム自身
     がコンソール(テキストモード)プログラムの場合は、‘emacsclient.exe’を
     使用するべきです。そうすれば呼び出したプログラムと同じコマンドウィ
     ンドウにメッセージとプロンプトが表示されます。対照的に呼び出し側の
     プログラムがGUIプログラムの場合は、‘emacsclientw.exe’を使用するほう
     がよいでしょう。なぜなら‘emacsclient.exe’はGUIプログラムから呼び出
     された場合、コマンドウィンドウをポップアップするからです。
     ‘emacsclientw.exe’を使いたい状況としては、Windows Explorerでファイ
     ルを右クリックして、ポップアップメニューで“Open With”を選択する場合
     です。‘emacsclient’を呼び出すときにEmacsが実行中でない(またはサーバ
     ーとして実行されていない)場合は、‘--alternate-editor=’または‘-a’オ
     プションを使用します。このオプションは常にエディターを与えます。
     ‘emacsclient’を通じて呼び出された場合、Emacsは‘emacsclient’を呼び出
     したプログラムのカレントディレクトリーで開始されます。

   MS-Windowsの制限により、Emacsは同一セッションでGUIとテキストモードの
フレームをもつことはできないことに注意してください。また複数の“コマンド
プロンプト”ウィンドウでテキストモードのフレームを開くこともできません。
なぜならWindowsのプログラムは、それぞれ1度に1つのコンソールしかもつこと
ができないからです。これらの理由により、‘emacsclient’を‘-c’オプションで
呼び出したとき、Emacsサーバーがテキストモードセッションで実行されている
場合、Emacsは常にそれが開始されたのと同じ“コマンドプロンプト”ウィンドウ
に、テキストモードのフレームを開きます。GUIフレームはサーバーがGUIセッシ
ョンで実行されているときだけ作成されます。同様に、‘emacsclient’を‘-t’オ
プションで呼び出したとき、サーバーがGUIセッションで実行されている場合は
GUIフレームを作成し、サーバーセッションが“コマンドプロンプト”ウィンドウ
のテキストモードで実行されている場合はテキストモードのフレームを作成しま
す。*note emacsclient Options::を参照してください。


File: emacs-ja.info,  Node: Text and Binary,  Next: Windows Files,  Prev: Windows Startup,  Up: Microsoft Windows

G.2 テキストファイルとバイナリーファイル
========================================

GNU Emacsはテキスト行を分けるのに改行文字を使用します。これはGNU、
Unixmその他のPOSIX準拠システムで使用されている慣習です。

   対照的にMS-DOSとMS-Windowsは、テキスト行を分けるのに、通常は
CR(carriage-return: キャリッジリターン)とその後にLF(linefeed: ラインフィ
ード)の、2文字からなるシーケンスを使用します(LFは改行と同じ文字です)。し
たがってこれらのファイルを便利に編集するために、Emacsはこれらの行末(EOL:
end-of-line)文字を変換する必要があります。そしてこれはEmacsが通常行なっ
ていることです。Emacsはファイルを読み込むときCRLFを改行に変換して、ファ
イルに書き込むときは改行をCRLFに変換します。国際化文字コードの変換を処理
するのと同じ仕組みが、この変換でも行なわれます(*note Coding Systems::を
参照してください)。

   ほとんどのファイルにおいて、この特別なフォーマット変換の重要な問題は
、Emacsが報告する文字の位置(*note Position Info::を参照してください)が、
オペレーティングシステムが認識するファイルサイズの情報と一致しないことで
す。

   それに加えて、ファイル内容から行の区切りにCRLFではなく改行(LF)が使用
されているとEmacsが認識した場合、Emacsはファイルの読み書きでEOL変換を行
ないません。したがって特別に何かを行なわなくても、GNUおよびUnixシステム
のファイルをMS-DOSで読み書きでき、編集した後でも、それらのファイルの
EOLはUnixスタイルの慣習にしたがいます。

   カレントバッファーにたいして、どのEOL変換が使用されているかは、モード
ラインに表示されます。そのバッファーにたいしてMS-DOSのEOL変換が使用され
ている場合、MS-WindowsでビルドされたEmacsでは、モードラインの先頭付近の
、コーディングシステムニーモニックの後ろにバックスラッシュ‘\’が表示され
ます。なんのEOL変換も処理されていない場合、そのファイルのEOLフォーマット
が通常のCRLFではないことを警告するために、バックスラッシュのかわりに文字
列‘(Unix)’が表示されます。

   ファイルをvisitして、DOSスタイルとUnixスタイルのどちらを使用するか指
定するには、コーディングシステムを指定します(*note Text Coding::を参照し
てください)。たとえば‘C-x <RET> c unix <RET> C-x C-f foobar.txt’は、
EOL変換をせずに、ファイル‘foobar.txt’をvisitします。CRLFで終わる行がある
場合、Emacsは行末に‘^M’を表示します。同様に、‘C-x <RET> f’コマンドで、そ
のバッファーを指定したEOLフォーマットで保存するよう指示できます。たとえ
ばバッファーをUnixのEOLフォーマットで保存するには、‘C-x <RET> f unix
<RET> C-x C-s’とタイプします。DOSのEOL変換でファイルをvisitしていて、そ
れをUnixのEOLフォーマットで保存すると、‘dos2unix’コマンドのように、その
ファイルをUnixのEOLスタイルに変換できます。

   NFS、Samba、または他の類似した方法により、GNUおよびUnixシステムを使用
しているコンピューターのファイルシステムにアクセスする場合、Emacsはそれ
らのファイルシステム上のファイル — たとえファイルを新たに作成する場合で
も、EOL変換を行なうべきではありません。EOL変換を行なわないようにするには
、関数‘add-untranslated-filesystem’を呼び出して、それらのファイルシステ
ムが“untranslated(変換なし)”だと指定します。この関数は、ドライブ文字とオ
プションでディレクトリーを含む、ファイルシステム名を引数にとります。たと
えば、

     (add-untranslated-filesystem "Z:")

これはZドライブが変換なしのファイルシステムであると指定し、

     (add-untranslated-filesystem "Z:\\foo")

これはドライブZのディレクトリー‘\foo’は、変換なしのファイルシステムだと
指定します。

   ‘.emacs’や‘init.el’などのinitファイル、または‘site-start.el’の中で
‘add-untranslated-filesystem’を使用するのが、ほとんどでしょう。
‘site-start.el’に記述しておけば、そのサイトのすべてのユーザーが恩恵にあ
ずかることができます。

   ‘add-untranslated-filesystem’の効果を取り消すには、関数
‘remove-untranslated-filesystem’を使用します。この関数は、前に
‘add-untranslated-filesystem’で使用された文字列と同様の文字列を引数にと
ります。

   ファイルシステムを変換なしと指定しても、影響があるのはEOL変換だけで、
文字セットの変換に影響はありません。原則的として、行末に改行を使用する
Unixスタイルをデフォルトとして、新たにファイルを作成するようEmacsに指示
します。*note Coding Systems::を参照してください。


File: emacs-ja.info,  Node: Windows Files,  Next: ls in Lisp,  Prev: Text and Binary,  Up: Microsoft Windows

G.3 MS-Windowsのファイル名
==========================

MS-WindowsとMS-DOSでは通常、ファイル名の名前単位の区切りにバックスラッシ
ュを使用します(他のシステムではスラッシュを使用します)。MS-DOSおよび
MS-WindowsのEmacsは、スラッシュとバックスラッシュのどちらも使用でき、フ
ァイル名に含まれるドライブ文字も識別できます。

   MS-DOSおよびMS-Windowsでは、ファイル名は大文字小文字を区別せず、
Emacsもデフォルトではファイル名の補完で大文字小文字の違いを無視します。
これを行うために、MS-DOS/MS-Windowsでは
‘read-file-name-completion-ignore-case’のデフォルト値は非‘nil’です。
*note Completion Options::を参照してください。

   変数‘w32-get-true-file-attributes’は、‘file-attributes’や
‘directory-files-and-attributes’のように、より正確にプリミティブなファイ
ル属性を判断するために、Emacsが追加のシステムコールを呼び出すべきかを制
御します。これらの追加のシステムコールは、ファイルの正しい所有者、リンク
カウントと、パイプのような特殊ファイルのファイルタイプを取得するのに必要
となります。システムコールを使用しない場合、ファイルの所有者はカレントユ
ーザーとなり、リンクカウントは常に1に、そして特殊ファイルは通常ファイル
となるでしょう。

   この変数の値が‘local’(デフォルト)の場合、Emacsはローカルの固定ドライ
ブのファイルにたいしてのみ、システムコールを呼び出します。他の非‘nil’値
は、ファイルがリムーバブルメディアやリモートボリュームにある場合も、シス
テムコールを呼び出すことを意味し、これはDiredやその他の関連する機能の速
度低下を招く恐れがあります。値‘nil’はシステムコールを呼び出さないことを
意味します。非‘nil’値は、FAT、FAT32、exFATのようなボリュームより、ハード
リンクやファイルセキュリティーをサポートするNTFSのボリュームの場合のほう
が有用です。

   Unixとは異なり、MS-Windowsのファイルシステムでは、ファイル名に使用さ
れるかもしれない複数の文字にたいして制限があります。以下の文字は使用でき
ません:

   • シェルのリダイレクション文字‘<’、‘>’、‘|’。

   • コロン‘:’(ただしドライブ文字を除く)。

   • スラッシュ‘/’とバックスラッシュ‘\’(ただしディレクトリー区切り文字の
     場合を除く)。

   • ワイルドカード文字‘*’と‘?’。

   • コードポイントが10進の1から31の制御文字。特にファイル名の中の改行は
     許されていません。

   • コードポイント0のnull文字(この制限はUnixファイルシステムにもありま
     す)。

これらに加えて、ファイル名拡張子の有無に関わらず、‘NUL’、‘LPT1’、‘PRN’、
‘CON’のようなDOSの文字デバイスに名前がマッチする任意のファイルは、どのデ
ィレクトリーにあっても、文字デバイスとして解釈されます。したがってその文
字デバイスを使用したいときだけ、そのようなファイル名を使用します。


File: emacs-ja.info,  Node: ls in Lisp,  Next: Windows HOME,  Prev: Windows Files,  Up: Microsoft Windows

G.4 MS-Windowsでの‘ls’のエミュレーション
========================================

Diredは通常、Diredバッファーで表示するディレクトリーリストを生成するため
に、外部プログラムの‘ls’を使用します。しかしMS-WindowsとMS-DOSには、GNU
‘ls’のいくつかのポートは存在するものの、システムにはそのようなプログラム
がありません。したがって、そのようなシステム上のEmacsは、‘ls-lisp.el’パ
ッケージを使用することにより、Lispで‘ls’を_エミュレート_します。
‘ls-lisp.el’は、‘ls’のほぼ完全なエミュレーションを提供し、エミュレーショ
ンに特化したオプションと機能もあります。 それらについては、このセクショ
ンで説明します。

   ‘ls’エミュレーションは、‘ls’スイッチの多くをサポートしますが、すべて
をサポートする訳ではありません。サポートされているオプションは、‘-A’、
‘-a’、‘-B’、‘-C’、‘-c’、‘-G’、‘-g’、‘-h’、‘-i’、‘-n’、‘-R’、‘-r’、‘-S’、
‘-s’、‘-t’、‘-U’、‘-u’、‘v’、‘-X’です。‘-F’オプションは、部分的にサポー
トされています(ファイルをクラス化する文字を追加しますが、シンボリックリ
ンクのフォローを抑止しません)。

   MS-WindowsとMS-DOSでは、‘ls-lisp.el’はEmacsが構築されるとき事前ロード
されるので、それらの環境では常に‘ls’のLispエミュレーションが使用されます
。ポートされた‘ls’がある場合、‘ls-lisp-use-insert-directory-program’を非
‘nil’値にセットすることにより、変数‘insert-directory-program’にセットさ
れた名前の外部プログラムを使用するように戻すことができます。

   ‘ls-lisp.el’がファイルをソートする順序は、以下で説明するいくつかのカ
スタマイズ可能なオプションに依存します。

   デフォルトのソート順は、システムlocaleから派生したlocale固有ルールに
したがいます。‘ls-lisp-use-string-collate’を‘nil’値にカスタマイズするこ
とにより、localeから独立したソート順にすることができます。

   GNUおよびUnixシステムでは、localeのエンコーディングがUTF-8のときの照
合順はUCA(Unicode Collation Algorithm: Unicode照合順序アルゴリズム )にし
たがいます。MS-Windowsで同様の効果を得るには、変数
‘ls-lisp-UCA-like-collation’が非‘nil’値をもつべきです(これがデフォルトで
す)。結果となるソート順は句読点、シンボル文字、空白文字を無視するので、
‘.foobar’、‘foobar’、‘foo bar’は別々ではなく一緒に表示されるでしょう。

   デフォルトでは、‘ls-lisp.el’はディレクトリーのリストを生成するのに、
大文字小文字を区別するソート順を使用します。これは他のプラットフォームと
同じような見映えにリストするためです。大文字小文字を区別せずにファイルを
ソートしたい場合は、変数‘ls-lisp-ignore-case’に非‘nil’値をセットしてくだ
さい。

   デフォルトでは、‘ls’の動作をエミュレートするために、ファイルとサブデ
ィレクトリーは一緒にソートされます。しかしネイティブのMS-Windowsと
MS-DOSのファイルマネージャーでは、ファイルの前にディレクトリーがリストさ
れます。このように動作させたい場合は、オプション‘ls-lisp-dirs-first’を非
‘nil’値にカスタマイズしてください。

   変数‘ls-lisp-verbosity’は、‘ls-lisp.el’が表示するファイル属性を制御し
ます。値にはシンボル‘links’、‘uid’、‘gid’を1つ以上含むリストを指定します
。‘links’は、そのファイルデータに関連付けられている(“links to”とも言いま
す)別のファイルの数を表示することを意味し、これはNTFSボリュームでのみ有
用です。‘uid’はそのファイルを所有するユーザーの、数字による識別子を表示
することを意味します。‘gid’はそのファイルの所有者のグループの、数字によ
る識別子を表示することを意味します。デフォルト値は‘(links uid gid)’で、
3つのすべてのオプション属性が表示されます。

   変数‘ls-lisp-emulation’は、上記で説明した3つのオプション
‘ls-lisp-ignore-case’、‘ls-lisp-dirs-first’、‘ls-lisp-verbosity’でデフォ
ルトをセットすることにより、‘ls’エミュレーションの風合いを制御します。こ
のオプションの値には、以下のシンボルを指定できます:

‘GNU’
‘nil’
     GNUシステムをエミュレートします(デフォルト)。これは
     ‘ls-lisp-ignore-case’と‘ls-lisp-dirs-first’を‘nil’に、
     ‘ls-lisp-verbosity’を‘(links uid gid)’にセットします。
‘UNIX’
     Unixシステムをエミュレートします。‘GNU’と同様ですが、
     ‘ls-lisp-verbosity’は‘(links uid)’にセットします。
‘MacOS’
     macOSをエミュレートします。‘ls-lisp-ignore-case’を‘t’に、
     ‘ls-lisp-dirs-first’と‘ls-lisp-verbosity’を‘nil’にセットします。
‘MS-Windows’
     MS-Windowsをエミュレートします。‘ls-lisp-ignore-case’と
     ‘ls-lisp-dirs-first’を‘t’にセットし、‘ls-lisp-verbosity’を、Windows
     9Xでは‘nil’、Windowsのモダンなバージョンでは‘t’にセットします。これ
     らのプラットフォームのEmacsユーザーの多くがデフォルトとしてGNUを好
     むため、たとえWindowsにおいても、デフォルトのエミュレーションは
     ‘MS-Windows’ではないことに注意してください。

これ以外の値を‘ls-lisp-emulation’にセットするのは、‘GNU’をセットするのと
同じです。このオプションをカスタマイズすることにより、必要に応じて3つの
従属オプションを更新するために、関数‘ls-lisp-set-options’が呼び出されま
す。‘ls-lisp.el’がロードされた後(MS-WindowsとMS-DOSでは事前ロードされる
ことに注意してください)に、customizeを使用せずにこの変数の値を変更した場
合、この関数を手動で呼び出して、同じ結果を得ることができます。

   変数‘ls-lisp-support-shell-wildcards’は、ファイル名パターンがサポート
される方法を制御します。非‘nil’(デフォルト)の場合、ファイル名パターンは
シェルスタイルのワイルドカードとして扱われ、‘nil’の場合はEmacsの正規表現
として扱われます。

   変数‘ls-lisp-format-time-list’は、ファイルの日付と時刻の書式をフォー
マットする方法を定義します。Emacsがカレントlocaleを判断できる場合、_この
変数の値は無視されます_(しかし‘ls-lisp-use-localized-time-format’の値が
非‘nil’の場合、Emacsはカレントlocaleが利用できるときでも
‘ls-lisp-format-time-list’にしたがいます。以下を参照してください)。

   ‘ls-lisp-format-time-list’の値は、2つの文字列からなるリストです。最初
の文字列は、そのファイルがその年に変更されている場合に使用され、2番目の
文字列はそれより古いファイルに使用されます。2つの文字列では、日時の一部
を置換するために‘%’シーケンスを使用できます。たとえば:
     ("%b %e %H:%M" "%b %e  %Y")

これらの‘%’シーケンスにたいする文字列の置換は、カレントlocaleに依存する
ことに注意してください。日時のフォーマットの仕様については、*note
(elisp)Time Parsing::を参照してください。

   Emacsは通常、ファイルのタイムスタンプの日時フォーマットに、慣習にした
がったフォーマット、またはISOスタイルのフォーマットを使用します。しかし
変数‘ls-lisp-use-localized-time-format’の値が非‘nil’の場合、Emacsはファ
イルのタイムスタンプを、‘ls-lisp-format-time-list’の指定にしたがってフォ
ーマットします。‘ls-lisp-format-time-list’の‘%’シーケンスは、localeにし
たがった月の名前と曜日名を生成し、それによりDiredの列表示がずれるかもし
れません。‘ls-lisp-use-localized-time-format’のデフォルト値は‘nil’です。


File: emacs-ja.info,  Node: Windows HOME,  Next: Windows Keyboard,  Prev: ls in Lisp,  Up: Microsoft Windows

G.5 MS-WindowsでのHOMEディレクトリーと開始ディレクトリー
========================================================

Windowsで‘HOME’に相当するのは、“ユーザー固有のアプリケーションデータディ
レクトリー”で、それの実際の位置はWindowsのバージョンに依存します。典型的
な値は、Windows 2000からXPでは‘C:\Documents and
Settings\USERNAME\Application Data’、Windows Vista以降では‘C:\Documents
and Settings\USERNAME\Application Data’、そしてWindows 9X/MEでは
‘C:\WINDOWS\Application Data’か‘C:\WINDOWS\Profiles\USERNAME\Application
Data’のいずれかです。このディレクトリーが存在しない、またはアクセスでき
ない場合、Emacsは‘HOME’のデフォルト値を‘C:\’にフォールバックします。

   環境変数‘HOME’をシステムの他のディレクトリーを指すように明示的にセッ
トすることにより、‘HOME’のデフォルト値をオーバーライドできます。‘HOME’は
コマンドシェルプロンプト、または‘My Computer’の‘Properties’ダイアログか
らセットできます。‘HOME’はシステムレジストリーからもセットできます。
*note MS-Windows Registry::を参照してください。

   古いバージョンのEmacs(1)との互換性のため、ドライブ‘C:’のルートディレ
クトリー‘C:\’に‘.emacs’という名前のファイルが存在する場合、そして
‘HOME’が環境とレジストリーのどちらでもセットされていない場合、Emacsは
‘C:\’をデフォルトの‘HOME’の場所として扱い、たとえアプリケーションデータ
ディレクトリーが存在する場合でも、そこを探しません。古い名前の
‘_emacs’(以下参照)ではなく、‘C:\’の‘.emacs’だけが探されることに注意して
ください。‘C:\.emacs’を使用して‘HOME’を定義する方法は、推奨されていませ
ん。Emacsはスタートアップ時にそれが使用されていることに関して、警告を表
示するでしょう。

   最終的な場所がどこであれ、Emacsはその場所を指すように環境変数‘HOME’の
内部値をセットし、通常ホームディレクトリーで探したり作成するファイルとデ
ィレクトリーのために、その場所を使用します。

   Emacsがホームディレクトリーをどこだと認識しているかは、‘C-x d ~/
<RET>’とタイプして常に確認できます。これはホームディレクトリーのファイル
のリストを表示し、最初の行にホームディレクトリーの完全な名前を表示します
。同様にinitファイルをvisitするには、(initファイルの名前が‘.emacs’の場合
)‘C-x C-f ~/.emacs <RET>’とタイプしてください。

   *note Init File::で述べられるとおり、initファイルは任意の名前をもつこ
とができます。

   MS-DOSはドットで始まるファイル名を使用できず、古いWindowsシステムでは
そのような名前のファイルを作成するのが困難だったので、EmacsのWindowsポー
トは、ホームディレクトリーに‘_emacs’が存在して、‘.emacs’が存在しない場合
、‘_emacs’という名前のinitファイルをサポートします。この名前は時代遅れと
考えられおり、使用した場合、Emacsは警告を表示するでしょう。

   ---------- Footnotes ----------

   (1) 古いバージョンのEmacsは、アプリケーションデータディレクトリーをチ
ェックしません。


File: emacs-ja.info,  Node: Windows Keyboard,  Next: Windows Mouse,  Prev: Windows HOME,  Up: Microsoft Windows

G.6 MS-Windowsでのキーボードの使用方法
======================================

このセクションでは、Emacsでのキーボード入力に関するWindows固有の機能につ
いて説明します。

   MS-Windowsプログラムで慣習的に使用されるキー組み合わせ(“キーボードシ
ョートカット”として知られる)の多くが、伝統的なEmacsのキーバインドと衝突
します(これらEmacsのキーバインドは、Microsoftが設立される数年前には確立
されていました)。衝突の例には‘C-c’、‘C-x’、‘C-z’、‘C-a’、‘W-<SPC>’が含ま
れます。CUAモード(*note CUA Bindings::を参照してください)を有効にするこ
とにより、これらのいくつかの意味をMS-Windowsでの意味に近づけるよう再定義
できます。他のWindowsのようにEmacsを振る舞わせる他のオプション機能として
、Delete Selectionモード(*note Using Region::を参照)があります。

   デフォルトでは、<Alt>とラベルされたキーは、<Meta>キーにマップされます
。かわりに‘Alt’修飾を生成したい場合は、変数‘w32-alt-is-meta’に‘nil’をセ
ットしてください。

   MS-Windowsでは、‘<Alt>-<TAB>’、およびWindowsキーと組み合わされたいく
つかのキーのような特定のキー組み合わせは、Windowsが使用するために予約済
みです。これらのキー組み合わせは、Emacsがそれを読み取る前に、システムに
より解釈されます。さらにWindows 10では、たとえその時点で特定のキー組み合
せがホットキーとして定義されていなくても、すべてのWindowsキーと組み合わ
されたキーは、アプリケーションに決して渡されないように、システムにより予
約済みです。関数‘w32-register-hot-key’を使用して、Windowsに横取りされる
ことなく、Emacsがキーシーケンスを取得できます。ホットキー(hot key)として
登録した場合、そのキー組み合せはWindowsが処理する前にシステムの入力キュ
ーから取り出され、そのシーケンスがもつWindowsにたいする特別な意味を、効
果的にオーバーライドします。これはEmacsがアクティブなときだけオーバーラ
イドされ、他のアプリケーションがフォアグラウンドのときには、そのキーは通
常どおり振る舞います。

   ‘w32-register-hot-key’に指定する引数は、1つの修飾キー、1つのキーを指
定しなければなりません。control修飾とshift修飾は、引数に影響を与えません
。‘w32-alt-is-meta’が‘t’(デフォルト)の場合、meta修飾は<Alt>キーと解釈さ
れ、super修飾とhyper修飾はそれぞれ、‘w32-lwindow-modifier’と
‘w32-rwindow-modifier’のバインディングに解釈されます。さらにキーがなく末
尾がダッシュの修飾は、Emacs用にその修飾にたいしてるWindowsが定義するすべ
てのホットキーをオーバーライドすることを示します。

   たとえば‘(w32-register-hot-key [M-tab])’により、(たとえばトップレベル
のポイント位置の単語やシンボルを補完したり、インクリメンタル検索において
以前に検索した文字列で現在の検索文字列を補完したり等)、Emacsで通常使用す
るように‘M-<TAB>’を使用できます。‘(w32-register-hot-key [s-])’と
‘w32-lwindow-modifier’を併用すると、WindowsキーにもとづくWindowsのすべて
のショートカットを無効にします。(1)

   ‘w32-register-hot-key’は、関数呼び出し時に‘w32-[lr]window-modifier’の
値をチェックすることに注意してください。したがって、
‘w32-lwindow-modifier’を‘super’としてセットしてから
‘(w32-register-hot-key [s-r])’を呼び出し、最後に同じように
‘w32-rwindow-modifier’を‘super’としてセットできます。その結果、左
Windowsキーと<R>の組み合せは、その組み合せにたいしてEmacsでバインドした
関数を呼び出し、右Windowsキーと<R>の組み合せはWindowsの‘Run’ダイアログを
オープンします。

   ホットキーの登録には常に、与えられたホットキーにたいするshift修飾と
control修飾による組み合せのすべてが含まれます。つまり、‘s-a’をホットキー
として登録すると、同様に‘S-s-a’、‘C-s-a’、‘C-S-s-a’が登録されます。

   Windows 98、およびWindows MEではホットキーの登録はより制限されます。
ホットキーが常に完全指定されねばなりません。望む結果を得るために、
‘w32-phantom-key-code’をカスタマイズできます。

   関数‘w32-unregister-hot-key’は、引数となるキーシーケンスにたいして、
‘w32-register-hot-key’と逆のことを行ないます。

   デフォルトでは、<CapsLock>キー(このキーは小文字を大文字に変換します
)は通常の文字キーだけに効果をもちます。しかし変数
‘w32-capslock-is-shiftlock’を非‘nil’値にセットした場合、<CapsLock>は非文
字キーにも同様に効果をもつようになり、その非文字キーをタイプするとき、あ
たかも<SHIFT>キーが押されたかのようになります。

   変数‘w32-enable-caps-lock’に‘nil’値をセットした場合、<CapsLock>キーは
、タイプされた文字にたいするシフトが押されたバージョンのキーではなく、か
わりにシンボル‘capslock’を生成します。デフォルト値は‘t’です。

   同様に‘w32-enable-num-lock’が‘nil’の場合、<NumLock>キーはシンボル
‘kp-numlock’を生成します。デフォルトは‘t’で、これは<NumLock>に期待された
動作、すなわちテンキー上のキーのもつ意味の切り替えを行ないます。

   変数‘w32-apps-modifier’は、<Apps>キー(通常は右<Alt>キーと右<Ctrl>キー
の間にあります)の効果を制御します。変数の値には、対応する修飾キーを示す
シンボル‘hyper’、‘super’、‘meta’、‘alt’、‘control’、‘shift’のどれか1つを
指定するか、‘nil’を指定してそれをキー‘apps’として扱います。デフォルトは
‘nil’です。

   変数‘w32-lwindow-modifier’は、左Windowsキー(通常は<start>とWindowsの
ロゴのラベル)の効果を決定します。この変数の値が‘nil’ (デフォルト)の場合
、このキーはシンボル‘lwindow’を生成します。シンボル‘hyper’、‘super’、
‘meta’、‘alt’、‘control’、‘shift’のうち、どれか1つをセットした場合は、対
応する修飾が生成されます。これと似た変数‘w32-rwindow-modifier’は、右
Windowsキーの効果を制御し、‘w32-scroll-lock-modifier’は<ScrLock>と同様の
ことを行います。これらの変数が‘nil’にセットされている場合、右Windowsキー
がシンボル‘rwindow’、<ScrLock>がシンボル‘scroll’を生成します。たとえばキ
ーボード上のScroll Lock LED標示を切り替える等、他のアプリケーションのと
きと同様の効果を<ScrLock>に生成させたい場合は、
‘w32-scroll-lock-modifier’の値に上記の修飾シンボルではなく‘t’か、任意の
非‘nil’をセットしてください。

   EmacsがネイティブのWindowsアプリケーションとしてコンパイルされている
と、Windowsメニューを呼び出す<Alt>をタップ(tapping: 覗き見)するWindows機
能をオフに切り替えます。これはEmacsでは<Meta>として用いられるからです。
Emacsを使用するとき、ユーザーが1度<Meta>キーを押して、後で気が変わること
があります。もしこのキーがWindowsメニューを立ち上げる効果をもつ場合、そ
れに続くコマンドの意味が変更されてしまいます。多くのユーザーは、これにイ
ライラするでしょう。

   ‘w32-pass-alt-to-system’を非‘nil’値にセットすることにより、<Alt>キー
の覗き見にたいするWindowsのデフォルトの処理を再び有効にできます。

   変数‘w32-pass-lwindow-to-system’と‘w32-pass-rwindow-to-system’は、左
Windowsキーと右Windowsキーが、Windowsに渡されるか、Emacsに渡されるかを決
定します。値が‘nil’の場合、これらのキーはEmacsに渡され、それ以外の場合は
Windowsに渡されます。両方の変数のデフォルトは‘t’です。これらのキーを
Windowsに渡すことにより、たとえば‘<Lwindow>’は‘Start’メニューを開くなど
の、通常の効果が生成されます。

   変数‘w32-recognize-altgr’は、(もしそれがキーボードにあれば)<AltGr>キ
ー(またはそれと同種のキー)が右<Alt>と左<Ctrl>キーを一緒に押したときの組
み合わせとするか、それともそれを<AltGr>キーとして認識するかを制御します
。デフォルトは‘t’で、これはそれらのキーが‘AltGr’を生成することを意味しま
す。これを‘nil’にセットすることにより、<AltGr>キー(またはそれと同種のキ
ー)との組み合わせは、<Ctrl>修飾と<Meta>修飾の組み合わせとして解釈されま
す。

   ---------- Footnotes ----------

   (1) これには既知の例外が１つあります。ワークステーションをロックする
‘<Windows>-<L>’の組み合せは、システムのより低レベルで処理されます。この
理由により、‘w32-register-hot-key’はこのキー組み合せをオーバーライドでき
ません。これは常にコンピューターをロックします。


File: emacs-ja.info,  Node: Windows Mouse,  Next: Windows Processes,  Prev: Windows Keyboard,  Up: Microsoft Windows

G.7 MS-Windowsでのマウスの使用方法
==================================

このセクションでは、マウスに関連したWindows固有の変数について説明します
。

   変数‘w32-mouse-button-tolerance’は、2ボタンマウスで、マウス中央ボタン
を模倣する際の時間間隔を、ミリ秒で指定します。左ボタンと右ボタンの両方の
ボタンが、この時間間隔のうちに離された場合、Emacsはそれらどちらかのボタ
ンのダブルクリックイベントのかわりに、マウス中央ボタンのクリックイベント
を生成します。

   変数‘w32-pass-extra-mouse-buttons-to-system’が非‘nil’の場合、Emacsは
Windowsに第4、第5マウスボタンを渡します。

   変数‘w32-swap-mouse-buttons’、は3ボタンマウスが‘mouse-2’イベントを生
成するかを制御します。これが‘nil’(デフォルト)の場合、中央のボタンは
‘mouse-2’を生成し、右ボタンは‘mouse-3’を生成します。この変数が非‘nil’の
場合、これら2つのボタンの役割は逆になります。


File: emacs-ja.info,  Node: Windows Processes,  Next: Windows Printing,  Prev: Windows Mouse,  Up: Microsoft Windows

G.8 Windows 9X/MEおよびWindows NT/2000/XP/Vista/7/8/10でのサブプロセス
======================================================================

WindowsのネイティブアプリケーションとしてコンパイルされたEmacsには、
(DOSバージョンとは対照的に)非同期サブプロセスにたいする完全なサポートが
含まれます。Windowsバージョンでは、同期および非同期サブプロセスは、すべ
てのバージョンのWindowsで32ビット、または64bitのWindowsアプリケーション
を実行する限りうまく動作します。しかしサブプロセスでDOSアプリケーション
を実行する場合は、問題に遭遇したり、そのアプリケーションを実行できないか
もしれません。また、2つのサブプロセスで2つのDOSアプリケーションを実行す
る場合は、システムを再起動する必要があるかもしれません。

   Windows9X標準のコマンドインプリターはDOSアプリケーションなので、その
ようなシステムを使用する場合に、これらの問題が重要になります。しかしこれ
らの問題についてわたしたちができることはありません。Microsoftだけがこれ
をfixできるのです。

   サブプロセスで1つのDOSアプリケーションを実行する場合、それが“様式に従
って(well-behaved)”いる限り、そしてスクリーンへの直接アクセスや、その他
の異例なことを行なわない限り、そのサブプロセスは期待されたとおりに動作す
べきです。CPUモニターアプリケーションがある場合、そのDOSアプリケーション
がアイドル状態でも、CPUは100%ビジーに見えるかもしれませんが、これは単に
CPUモニターがプロセッサー負荷を計測する方法によるものです。

   他のDOSアプリケーションを別のサブプロセスで開始する前に、DOSアプリケ
ーションを終了しなければなりません。EmacsはDOSサブプロセスに割り込み、ま
たは終了させることができません。プログラムの終了コマンドを与えることだけ
が、そのようなサブプロセスを終了できる唯一の方法です。

   同時に別のサブプロセスで2つのDOSアプリケーションの実行を試みた場合、
それらの一方、または両方が非同期であっても、最初のサブプロセスが終了する
まで、2番目に開始されたサブプロセスはサスペンドされます。

   もし最初のサブプロセスと対話することができ、終了を指示できたら2番目の
プロセスは通常どおり実行を継続するはずです。しかし2番目のサブプロセスが
同期実行されている場合、Emacsは最初のサブプロセスが終了するまでハングす
るでしょう。最初のプロセスがユーザーによる入力なしには終了しない場合、
Windows9Xでは再起動する以外に選択肢はありません。Windows NT以降で実行し
ている場合、プロセスビューアーアプリケーションを使用して、適切なNTVDMの
インスタンスをkillすることができます(これにより、両方のDOSサブプロセスが
終了します)。

   このような状況でWindows9Xを再起動する場合、‘Start’メニューの
‘Shutdown’コマンドを使用しないでください。これは通常システムをハングさせ
ます。かわりに‘<Ctrl>-<Alt>-<DEL>’とタイプして‘Shutdown’を選択します。こ
れは処理を行なうのに数分かかるかもしれませんが、通常どおり機能します。

   変数‘w32-quote-process-args’は、Emacsがプロセス引数をクォートする方法
を制御します。非‘nil’は文字‘"’でクォートすることを意味します。変数の値が
文字の場合、Emacsは任意のクォート文字をエスケープするのに、その文字を使
用します。それ以外の場合、プログラムのタイプにもとづいて、適切なエスケー
プ文字を選択します。

   変数‘w32-pipe-buffer-size’は、サブプロセスとの通信のためにパイプを作
成するときに、Emacsがシステムに要求するバッファーサイズを制御します。デ
フォルト値は0で、この場合はOSがサイズを選択します。有効な正の値を指定し
た場合は、そのサイズ(byte)のバッファーを要求します。これは、サブプロセス
と、バッファーされたパイプ入出力にたいして通常とは異なる動作を見せるプロ
グラムとの通信を調整するのに使用できます。

   関数‘w32-shell-execute’は、特定のタイプのファイルやドキュメントにたい
して、ある種の標準的なWindows操作を処理するために登録された、
MS-Windowsアプリケーションを実行するカスタマイズコマンドを記述するのに有
用かもしれません。この関数はWindows APIの‘ShellExecute’にたいするラッパ
ーです。詳細は、MS-WindowsのAPIドキュメントを参照してください。


File: emacs-ja.info,  Node: Windows Printing,  Next: Windows Fonts,  Prev: Windows Processes,  Up: Microsoft Windows

G.9 MS-Windowsでの印刷
======================

POSIXスタイルの‘lpr’プログラムが利用できない場合、MS-DOSとMS-Windowsでは
、‘lpr-buffer’(*note Printing::を参照してください)や
‘ps-print-buffer’(*note PostScript::を参照してください)のような印刷コマ
ンドは、プリンターポートの1つに出力を送ります。同じEmacs変数がすべてのシ
ステムでの印刷を制御しますが、MS-DOSとMS-Windowsでは、それらの変数が異な
るデフォルト値をもつ場合があります。

   MS WindowsのEmacsは、(関数‘default-printer-name’を使用して)デフォルト
プリンターの自動検出を試みます。しかし、これはある稀なケースでは失敗する
ことがあり、Emacsから別のプリンターを使用したいと思うときがあるかもしれ
ません。このセクションの残りの部分では、Emacsに使用するプリンターを指示
する方法を説明します。

   ローカルプリンターを使用したい場合、Lisp変数‘lpr-command’に‘""’(これ
はWindowsではデフォルトです)をセットして、‘printer-name’にプリンターポー
ト、たとえば通常のローカルプリンターポート‘"PRN"’、または‘"LPT2"’、また
はシリアルプリンターにたいする‘"COM1"’などをセットします。
‘printer-name’にファイル名をセットすることもできます。この場合、“印刷”さ
れた出力は、そのファイルに追加されます。‘printer-name’を‘"NUL"’にセット
した場合、印刷された出力は破棄されます(システムのnullデバイスに送られま
す)。

   ‘printer-name’にそのプリンターのUNC共有名 — たとえば
‘"//joes_pc/hp4si"’のような — をセットすることにより、他のマシンで共有さ
れているプリンターを使用することもできます(ここではスラッシュを使用する
か、バックスラッシュを使用するかは問題ではありません)。共有プリンターの
名前を探すには、サーバーのリストを取得するために、コマンドプロンプトでコ
マンド‘net view’を実行して、‘net view SERVER-NAME’でそのサーバーで共有さ
れているプリンター(とディレクトリー)の名前を確認します。かわりにデスクト
ップの‘Network Neighborhood’アイコンをクリックして、ネットワークを通じて
プリンターを共有しているマシンを確認することもできます。

   プリンターが‘net view’で出力されない場合、または‘printer-name’にUNC共
有名をセットしても、そのプリンターからハードコピーが出力されない場合、
‘net use’コマンドを使用して、‘"LPT2"’のようなローカルプリンターポートを
、ネットワークプリンターに接続できます。たとえば‘net use LPT2:
\\joes_pc\hp4si’(1)により、Windowsに‘LPT2’ポートを“キャプチャー”させて、
印刷物をマシン‘joes_pc’に接続されているプリンターにリダイレクトします。
このコマンド後は、‘printer-name’に‘"LPT2"’をセットすることにより、そのネ
ットワークプリンターでハードコピーが印刷されます。

   あるWindowsネットワークソフトウェアーでは、‘"LPT2"’のような特定のプリ
ンターポートをキャプチャーして、‘net use’のかわりに
‘Control Panel->Printers’を通じてネットワークプリンターにリダイレクトす
るよう、Windowsに指示できます。

   ‘printer-name’にファイル名をセットする場合、絶対ファイル名を使用する
のが最良です。Emacsはカレントバッファーのデフォルトディレクトリーに合わ
せて作業ディレクトリーを変更するので、‘printer-name’のファイル名が相対フ
ァイル名の場合、結果として印刷が行なわれたバッファーのディレクトリーごと
に、複数のファイルができてしまいます。

   変数‘printer-name’の値が正しいのに、印刷してもそのプリンターからハー
ドコピーが印刷されない場合、そのプリンターがプレーンテキストの印刷をサポ
ートしない可能性があります(安価なプリンターのいくつかでは、この機能が省
略されています)。そのような場合、以下で説明するPostScriptプリントコマン
ドを試してみてください。

   コマンド‘print-buffer’および‘print-region’は、印刷された各ページにヘ
ッダーを生成するために、‘pr’プログラムを呼び出すか、‘lpr’プログラムの特
別なスイッチを使用します。通常MS-DOSとMS-Windowsにはこれらのプログラムが
ないので、デフォルトでは印刷ページのヘッダーの印刷リクエストは単に無視さ
れるように、‘lpr-headers-switches’がセットされています。したがって
‘print-buffer’と‘print-region’は、‘lpr-buffer’および‘lpr-region’と同じ出
力を生成します。適切な‘pr’プログラム(たとえばGNU Coreutilsのもの)がある
場合は、‘lpr-headers-switches’に‘nil’をセットします。するとEmacsはページ
ヘッダーを生成するために‘pr’を呼び出し、その結果を‘printer-name’で指定さ
れたプリンターで印刷します。

   最後に、もし‘lpr’によく似たものがある場合、変数‘lpr-command’を
‘"lpr"’にセットします。するとEmacsは他のシステムと同じように、印刷に
‘lpr’を使用します(そのプログラムの名前が‘lpr’でない場合は、
‘lpr-command’に適切な値をセットします)。‘lpr-command’が‘""’でないときに
、変数‘lpr-switches’は、その標準的な意味をもちます。変数‘printer-name’の
値が文字列のとき、Unixの場合のように、‘lpr’の‘-P’オプションの値としてそ
の文字列が使用されます。

   類似の変数‘ps-lpr-command’、‘ps-lpr-switches’、‘ps-printer-name’
(*note PostScript Variables::を参照してください)は、PostScriptファイルが
どのように印刷されるかを定義します。これらの変数は、上記で説明した非
PostScript印刷にたいする変数と同じ方法で使用されます。したがって非
PostScript印刷にたいして‘printer-name’が使用される方法と同様に、
‘ps-printer-name’の値はPostScript出力が送られるデバイス(またはファイル
)の名前として使用されます(2つの異なるポートに接続された2つのプリンターが
あり、それらの1つだけがPostScriptプリンターの場合、2つの個別の変数セット
をもつことができます)。

   変数‘ps-lpr-command’のデフォルト値は‘""’で、これはPostScript出力を
‘ps-printer-name’で指定されたプリンターポートに送りますが、
‘ps-lpr-command’にはPostScriptファイルを受け付けるプログラム名をセットす
ることもできます。したがって非PostScriptプリンターがある場合、この変数に
(Ghostscriptのような)PostScriptのインタープリタープログラムをセットでき
ます。インタープリタープログラムに渡す必要があるスイッチを指定するには、
‘ps-lpr-switches’を使用します(‘ps-printer-name’の値が文字列の場合、
‘-P’オプションにたいする値として、スイッチのリストが追加されます。これは
おそらく‘lpr’を使用する場合だけ有用なので、インタープリターを使用すると
きは‘ps-printer-name’に文字列以外の何かをセットすれば、無視させることが
できます)。

   たとえばシステムのデフォルトプリンターで、Ghostscriptを使用して印刷す
るには、以下を‘.emacs’に記述します:

     (setq ps-printer-name t)
     (setq ps-lpr-command "D:/gs6.01/bin/gswin32c.exe")
     (setq ps-lpr-switches '("-q" "-dNOPAUSE" "-dBATCH"
                             "-sDEVICE=mswinpr2"
                             "-sPAPERSIZE=a4"))

(Ghostscriptがディレクトリー‘D:/gs6.01’にインストールされていると仮定し
ます。)

   ---------- Footnotes ----------

   (1) ‘printer-name’の値は、スラッシュとバックスラッシュの両方でセット
できますが、‘net use’コマンドはUNC共有名がWindowsスタイルのバックスラッ
シュでタイプされるのを要求することに注意してください。


File: emacs-ja.info,  Node: Windows Fonts,  Next: Windows Misc,  Prev: Windows Printing,  Up: Microsoft Windows

G.10 MS-Windowsでのフォント指定
===============================

Emacs23からは、フォントはフォント名、サイズ、オプションのプロパティーに
より指定されるようになりました。フォントを指定するフォーマットは、モダン
なフリーデスクトップで使用されているfontconfigライブラリーから由来してい
ます。

       [Family[-PointSize]][:Option1=Value1[:Option2=Value2[...]]]

   後方互換のため、古いXLFDベースのフォーマットもサポートされます。

   Emacs23以降では、いくつかのフォントバックエンドがサポートされています
。現在のところ、Windowsではバックエンドとして、‘gdi’と‘uniscribe’がサポ
ートされます。‘gdi’フォントバックエンドは、すべてのバージョンのWindowsで
利用でき、Windowsでネイティブにサポートされるすべてのフォントをサポート
します。‘uniscribe’フォントバックエンドはWindows 2000以降で利用でき、
TrueTypeフォントとOpenTypeフォントをサポートします。複雑なレイアウトを要
求するいくつかの言語は、Uniscribeバックエンドだけが正しくサポートできる
言語もあります。デフォルトでは、どちらのバックエンドもサポートされていれ
ば有効になり、‘gdi’より‘uniscribe’が優先されます。これをオーバーライドし
て、Uniscribeが利用できる場合もGDIバックエンドを使用するには、コマンドラ
イン引数‘-xrm Emacs.fontBackend:gdi’を指定してEmacsを呼び出すか、レジス
トリーのキー‘HKEY_CURRENT_USER\SOFTWARE\GNU\Emacs’または
‘HKEY_LOCAL_MACHINE\SOFTWARE\GNU\Emacs’のいずれかの下に、リソース
‘Emacs.fontBackend’を追加して値を‘gdi’にセットします(*note Resources::を
参照してください)。

以下は、MS-Windowsのすべてのフォントバックエンドにたいして一般的なオプシ
ョンのプロパティーです:

‘weight’
     フォントのweightを指定します。特別な値‘light’、‘medium’、
     ‘demibold’、‘bold’、‘black’は、‘weight=’を使わずに指定できます(例:
     ‘Courier New-12:bold’)。それ以外の場合、weightは100から900の数字か
     、‘font-weight-table’の中の名前のついたweightを指定します。指定され
     ない場合は、regularフォントが指定されたとみなします。

‘slant’
     フォントがitalicかどうかを指定します。特別な値‘roman’、‘italic’、
     ‘oblique’は、‘slant=’を使わずに指定できます(例: ‘Courier
     New-12:italic’)。それ以外の場合は、数字か、‘font-slant-table’内のな
     まえつきのslantの1つを指定します。Windowsでは、150を越える任意の
     slantはitalicとして扱われ、150以下のものはすべてromanとして扱われま
     す。

‘family’
     フォントファミリーを指定しますが、通常はフォント名の最初でファミリ
     ーを指定します。

‘pixelsize’
     フォントサイズをピクセルで指定します。これはファミリー名の後のポイ
     ントサイズ指定のかわりに使用することができます。

‘adstyle’
     そのフォントにたいする、追加のスタイル情報を指定します。
     MS-Windowsでは、値‘mono’、‘sans’、‘serif’、‘script’、‘decorative’が
     認識されます。これはフォントファミリーが指定されていない場合のフォ
     ールバックとして、もっとも有用です。

‘registry’
     そのフォントがカバーすることを期待される、文字セットregistryを指定
     します。ほとんどのTrueTypeフォントとOpenTypeフォントは、複数の国際
     化文字セット(national character sets)をカバーするUnicodeフォントで
     すが、ここで‘w32-charset-info-alist’から、特定の文字セットをサポー
     トするregistry指定を使用することにより、選択されるフォントを絞り込
     むことができます。

‘spacing’
     フォントがspacingされる方法を指定します。‘p’はプロポーショナルフォ
     ントを指定し、‘m’および‘c’はモノスペースフォントを指定します。

‘foundry’
     Windowsでは使用されませんが、情報的な目的のために、そしてこれをセッ
     トしようとするコードによる問題を防ぐため、ビットマップフォントでは
     ‘raster’、スケーラブルフォントでは‘outline’、どちらともタイプが特定
     できなかった場合は‘unknown’が、内部的にセットされます。

   Options specific to ‘GDI’ fonts:

‘script’
     そのフォントがサポートすべきUnicodeの部分範囲(subrange)を指定します
     。

     Windowsでは‘latin’、‘greek’、‘coptic’、‘cyrillic’、‘armenian’、
     ‘hebrew’、‘arabic’、‘syriac’、‘nko’、‘thaana’、‘devanagari’、
     ‘bengali’、‘gurmukhi’、‘gujarati’、‘oriya’、‘tamil’、‘telugu’、
     ‘kannada’、‘malayam’、‘sinhala’、‘thai’、‘lao’、‘tibetan’、
     ‘myanmar’、‘georgian’、‘hangul’、‘ethiopic’、‘cherokee’、
     ‘canadian-aboriginal’、‘ogham’、‘runic’、‘khmer’、‘mongolian’、
     ‘symbol’、‘braille’、‘han’、‘ideographic-description’、‘cjk-misc’、
     ‘kana’、‘bopomofo’、‘kanbun’、‘yi’、‘byzantine-musical-symbol’、
     ‘musical-symbol’、‘mathematical’のscriptが認識されます。

‘antialias’
     アンチエイリアシング(antialiasing)の方法を指定します。値‘none’は、
     アンチエイリアシングを行なわないことを意味します。‘standard’は、標
     準のアンチエイリアシングを使用することを意味します。‘subpixel’は、
     subpixelアンチエイリアシング(WindowsではCleartypeとして知られます
     )を使用することを意味します。‘natural’は、文字間のspacing調整つきで
     subpixelアンチエイリアシングを使用することを意味します。指定されな
     い場合、そのフォントはシステムのデフォルトのアンチエイリアシングを
     使用します。


File: emacs-ja.info,  Node: Windows Misc,  Next: MS-DOS,  Prev: Windows Fonts,  Up: Microsoft Windows

G.11 その他のWindows固有の機能
==============================

このセクションでは、他のどれにも当てはまらないWindows固有の機能について
説明します。

   変数‘w32-use-visible-system-caret’は、システムカレット(system caret)を
可視にするか決定するフラグです。スクリーンリーダーソフトウェアーが使用さ
れていないときのデフォルトは‘nil’で、これはEmacsがポイント位置を示すため
に自分でカーソルを描画することを意味します。非‘nil’値は、Emacsがシステム
カレットでポイント位置を示すことを意味します。これはスクリーンリーダーソ
フトウェアーの使用を容易にし、そのようなソフトウェアーがEmacsの実行を検
知したときのデフォルトになります。この変数が非‘nil’の場合、カーソル表示
に影響を与える他の変数は効果がなくなります。

   変数‘w32-grab-focus-on-raise’が非‘nil’値にセットされている場合、フレ
ームがraiseされるときフォーカスを奪います。デフォルトは‘t’で、これは
Windowsのデフォルトのclick-to-focusポリシーに適合します。


File: emacs-ja.info,  Node: MS-DOS,  Prev: Windows Misc,  Up: Microsoft Windows

G.12 EmacsとMS-DOS
==================

このセクションでは、EmacsをMS-DOSで使用する際の特質を、簡単に説明します
。 MS-DOSとMicrosoftの現在のオペレーティングシステムのWindowsについての
情報は、*note Microsoft Windows::の中にあります。

   EmacsをMS-DOSにたいしてビルドした場合、そのバイナリーはWindows 3.X、
Windows NT、Windows 9X/ME、Windows 2000/XPでもDOSアプリケーションとして
実行されます。MS-DOSにたいしてビルドされたEmacsを使用する場合、このチャ
プターの内容は、それらすべてのシステムに適用されます。

   MS-DOS(およびWindows)でのテキストファイルにたいするEmacsの特別な処理
については、*note Text and Binary::を参照してください 。

* Menu:

* Keyboard: MS-DOS Keyboard.  MS-DOSでのキーボードの慣習。
* Mouse: MS-DOS Mouse.       MS-DOSでのマウスの慣習。
* Display: MS-DOS Display.   MS-DOSでのフォント、フレーム、ディスプレーのサイズ。
* Files: MS-DOS File Names.  MS-DOSでのファイル名の慣習。
* Printing: MS-DOS Printing.  MS-DOSでの印刷の特性。
* I18N: MS-DOS and MULE.     MS-DOSでの国際化のサポート。
* Processes: MS-DOS Processes.  MS-DOSでのサブプロセスの実行。


File: emacs-ja.info,  Node: MS-DOS Keyboard,  Next: MS-DOS Mouse,  Up: MS-DOS

G.12.1 MS-DOSでのキーボードの使用方法
-------------------------------------

Emacsで<DEL>と呼ばれるキー(ほとんどのワークステーションでそれが指定され
ているのが由来です)は、PCでは<BS>(バックスペース)として知られています。
PC固有の端末の初期化で、<BS>が<DEL>として動作するよう再マップされるのは
、これが理由です。同じ理由により、<Delete>キーは‘C-d’として動作するよう
に、再マップされます。

   MS-DOSにたいしてビルドされたEmacsは、‘C-<Break>’を‘C-g’のような、中止
(quit)文字として認識します。新たな入力にたいして準備ができるまで、
‘C-g’をタイプしてもEmacsが検知できないのは、これが理由です。そのため、実
行中のコマンドを停止させるために、‘C-g’を使用することはできません (*note
Quitting::を参照してください)。 対照的に‘C-<Break>’は、(他のシステムでの
‘C-g’のように)、タイプされるとすぐに検知されるので、実行中のコマンドを停
止したり、緊急エスケープのために使用されます (*note Emergency Escape::を
参照してください)。

   PCのキーボードマップは、左<Alt>キーを<Meta>キーとして使用します。
<SUPER>キーと<Hyper>キーをエミュレートするために、2つの選択肢があります
。変数‘dos-hyper-key’および‘dos-super-key’に、1または2をセットすることに
より、右<Ctrl>キーと右<Alt>キーのどちらかを選択します。‘dos-super-key’と
‘dos-hyper-key’がどちらも1以外の場合、デフォルトにより右<Alt>キーも
<Meta>キーにマップされます。しかしMSｰDOSの国際化キーボードサポートプログ
ラム‘KEYB.COM’がインストールされている場合、非US配列のキーボードでは右
<Alt>は‘~’や‘@’のような文字を入力するために使用されるので、Emacsは右
<Alt>を<Meta>にマップしません。この場合、左<Alt>キーだけを<Meta>キーとし
て使用することになるでしょう。

   変数‘dos-keypad-mode’は、テンキーにより返されるキーコードを制御するフ
ラグ変数です。以下の行を‘_emacs’ファイルに記述して、テンキーの<ENTER>キ
ーを、‘C-j’のように定義することもできます:

     ;; Make the <ENTER> key from the numeric keypad act as ‘C-j’.
     (define-key function-key-map [kp-enter] [?\C-j])


File: emacs-ja.info,  Node: MS-DOS Mouse,  Next: MS-DOS Display,  Prev: MS-DOS Keyboard,  Up: MS-DOS

G.12.2 MS-DOSでびマウスの使用方法
---------------------------------

MS-DOSのEmacsはマウスをサポートします(デフォルト端末のみ)。メニューやメ
ニューバーの使用を含めて、マウスコマンドはドキュメントされているように機
能します (*note Menu Bar::を参照してください)。 MS-DOSのEmacsではスクロ
ールバーは機能しません。PCマウスには通常2つしかボタンがありません。これ
らは‘mouse-1’、‘mouse-2’として機能しますが、これらのボタンを一緒に押すと
、‘mouse-3’の効果をもちます。マウスにボタンが3つある場合、Emacsは開始時
にそれを検知し、Xのようにすべての3ボタンは通常のように機能します。

   メニューアイテムの上にマウスポインターが移動すると、メニューバーとポ
ップアップメニューにたいするヘルプ文字列が、エコーエリアに表示されます。
マウスに反応するテキストはハイライト (*note Mouse References::を参照して
ください) もサポートされます。

   マウスドライバーのいくつかのバージョンは、マウスのボタン数を正しく報
告しません。たとえばホイールつきのマウスは3つボタンがあると報告されます
が、Emacsに渡されるのはそのうち2つだけです。真ん中のボタンとして使用され
るホイールのクリックも渡されません。このような場合、マウスボタンがいくつ
あるかEmacsに指示するために、‘M-x msdos-set-mouse-buttons’コマンドを使用
できます。initファイル‘_emacs’に以下の行を追加することにより、そのような
セッティングを永続化できます:

     ;; Treat the mouse like a 2-button mouse.
     (msdos-set-mouse-buttons 2)

   MS-DOSにたいしてビルドされたEmacsは、Windows上で実行されているときは
、クリップボード操作をサポートします。killリングにテキストを置くコマンド
、またはkillリングからテキストをyankするコマンドは、EmacsがXウィンドウシ
ステムで行なうように、最初にWindowsのクリップボードをチェックします
(*note Mouse Commands::を参照してください)。 Windows上でのMS-DOS版の
Emacsは、プライマリー選択とカットバッファーだけをサポートします。セカン
ダリー選択は常に空になります。

   クリップボードに対するアクセス方法はWindowsにより実装されているため、
クリップボードに置くことができるテキストの長さは、Emacsが利用可能なDOSメ
モリー量により制限されます。通常はクリップボードに最大620KBのテキストを
置くことができますが、この制限はシステム設定に依存し、Emacsを他のプログ
ラムのサブプロセスとして実行している場合は、もっと少なくなります。killし
たテキストが一致しない場合、Emacsはその旨を告げるメッセージを出力して、
クリップボードにテキストを置きません。

   ヌル文字をWindowsクリップボードに置くこともできません。killされたテキ
ストにヌル文字が含まれる場合、Emacsはそのようなテキストをクリップボード
に置かず、その結果にたいするメッセージをエコーエリアに表示します。

   変数‘dos-display-scancodes’が非‘nil’の場合、Emacsは各キーストロークの
ASCII値とキーボードのスキャンコードを表示します。この機能は、デバッグの
ための‘view-lossage’コマンドを補足するためのものです。


File: emacs-ja.info,  Node: MS-DOS Display,  Next: MS-DOS File Names,  Prev: MS-DOS Mouse,  Up: MS-DOS

G.12.3 MS-DOSでの表示
---------------------

MS-DOSのディスプレーでは、boldやitalicのようなフォントの変種が使用できま
せんが、複数のフェイスをサポートしており、それぞれのフェイスでフォアグラ
ウンドとバックグラウンドのカラーを指定できます。したがってm異なるカラー
を使用するために関連するフェイスを定義することにより、フォントを使用する
Emacsパッケージ(‘font-lock’やEnriched Textモードなそ)の完全な機能を使用
することができます。利用できるカラーとフェイスと、それらの外観を確認する
には、‘list-colors-display’コマンド (*note Colors::を参照してください) 、
および‘list-faces-display’ (*note Faces::を参照してください) を使用して
ください。

   DOSディスプレーでネイティブにサポートされていないグリフと文字を
Emacsが表示する方法については、このチャプターの後のほうの、*note MS-DOS
and MULE::を参照してください。

   Emacsを開始したとき、Emacsはカーソルの形状を塗りつぶしたボックスに変
更します。他のシステムではボックスカーソルがEmacsのデフォルトなので、こ
れは互換性のためです。デフォルトのカーソル形状は、変数
‘default-frame-alist’の中の‘cursor-type’パラメーターでbarを指定すること
により変更できます (*note Creating Frames::を参照してください)。 MS-DOS端
末は垂直バーのカーソルをサポートしないので、カーソルは水平バーになり、フ
レームのパラメターで‘WIDTH’パラメーターが指定された場合、それは実際には
水平バーの高さになります。この理由により、MS-DOSではカーソルタイプ
‘bar’と‘hbar’は同じ効果を生みます。拡張として、以下のようにして、バーカ
ーソル指定にはwidthと同様に、カーソルが行を読み取る開始位置を含めること
ができます:

      '(cursor-type bar WIDTH . START)

これに加えて、WIDTHパラメーターが負の場合、カーソルバーはその文字セルの
最上部から開始されます。

   MS-DOS端末は1度に1つのフレームだけを表示できます。MS-DOSで動作する
Emacsのフレーム機能は、Emacsがテキスト端末で動作する場合と同じように機能
します (*note Frames::を参照してください)。 MS-WindowsでDOS窓からEmacsを
実行した場合、フルスクリーンより小さい可視フレームを作成できますが、それ
でもEmacsは1度に1つのフレームしか表示できません。

   ‘dos-mode4350’コマンドはディスプレーを43行または50行に切り替え、それ
はハードウェアーに依存します。‘dos-mode25’コマンドはスクリーンサイズをデ
フォルトの80x25に切り替えます。

   デフォルトではEmacsが理解するするスクリーンサイズは、列を80列、行を
25、28、35、40、43、50行にセットする方法だけです。しかしビデオアダプター
が、ディスプレーを他のサイズに切り替える特別なビデオモードをもつ場合、
Emacsもそれをサポートするようにできます。EmacsにフレームをN行M列のサイズ
に切り替えるように指示した場合、Emacsは‘screen-dimensions-NxM’という名前
があるかチェックして、もしあれば切り替えるビデオモードの値(整数でなけれ
ばなりません)としてそれを使用します(Emacsは‘AL’レジスターに
‘screen-dimensions-NxM’の値をセットして、BIOS関数の‘Set Video Mode’を呼
び出すことによりそのビデオモードに切り替えます)。たとえばビデオアダプタ
ーがビデオモードを85にしたとき、サイズ66x80に切り替わるとしましょう。そ
の場合、以下を‘_emacs’ファイルに記述して、Emacsにそれをサポートさせるこ
とができます:

     (setq screen-dimensions-66x80 85)

   MS-DOSのEmacsは特定のサポートされたフレームサイズだけしかセットできな
いので、可能性のあるすべてのフレームのサイズ変更要求に従うことはできませ
ん。サポートされていないサイズが要求された場合、Emacsは指定されたサイズ
を越える、次に大きなサポートされたサイズを選択します。この場合、たとえば
36x80フレームを要求して、かわりに40x80を得ることになります。

   変数‘screen-dimensions-NxM’は、指定されたサイズに正確にマッチするとき
だけ使用され、サポートされた次に大きなサイズを検索するときには、無視され
ます。上記の例ではVGAは38x80のサイズをサポートし、
‘screen-dimensions-38x80’を適切な値で定義していても、36x80フレームを要求
すると40x80のスクリーンになります。この場合サイズを38x80にするには、
‘screen-dimensions-36x80’という名前の変数に、‘screen-dimensions-38x80’と
同じビデオもーどの値をセットして、これを行なうことができます。

   MS-DOSでフレームサイズを変更すると、他のすべてのフレームも新しいサイ
ズに変更されます。


File: emacs-ja.info,  Node: MS-DOS File Names,  Next: MS-DOS Printing,  Prev: MS-DOS Display,  Up: MS-DOS

G.12.4 MS-DOSでのファイル名
---------------------------

MS-DOSでは、ファイル名は大文字小文字を区別せず8文字に制限され、それに加
えてオプションでピリオドと追加の3文字を使用できます。Emacsは他のオペレー
ティングシステムで、ファイル名を処理するためのこれらの制限を充分認識して
います。たとえばファイル名の前のドット‘.’はMS-DOSでは無効なので、Emacsは
それらを透過的にアンダースコアー‘_’に変換します。したがって、MS-DOSでは
デフォルトのinitファイル (*note Init File::を参照してください) は
‘_emacs’と呼ばれます。ピリオドの前後の余分な文字は、一般的にMS-DOS自身に
より無視されます。したがってファイル‘LongFileName.EvenLongerExtension’を
visitした場合、それは暗黙に‘longfile.eve’となりますが、それでもEmacsはモ
ードラインに長いファイル名を表示し続けます。それ以外ではMS-DOSで有効なフ
ァイル名を指定するのはユーザーの責任です。上記の透過的な変換は、Emacsに
組み込まれたファイル名だけにたいして機能します。

   MS-DOSでのファイル名にたいする上記の制限は、オリジナルのファイル名の
文字を失うことなしにバックアップファイルの名前を構築するのを、ほとんど不
可能にします (*note Backup Names::を参照してください)。 たとえば
‘docs.txt’というファイルにたいするバックアップファイルの名前は、単一のバ
ックアップを使用しているときでさえ‘docs.tx~’になります。

   Windows 9X、Windows ME、Windows 2000/XPでEmacsをDOSアプリケーションと
して実行する場合、長いファイル名のサポートをオンに切り替えることができま
す。これを行なうと、Emacsはファイル名を切り詰めたり、ファイル名を小文字
に変換するかわりに、指定された文字通りのファイル名を使用します。長いファ
イル名のサポートを有効にするには、Emacsを開始する前に、環境変数‘LFN’を
‘y’にセットします。残念なことにWindows NTはDOSプログラムが長いファイル名
にアクセスすることを許さないので、MS-DOSにたいしてビルドされたEmacsは、
短い8+3のエイリアスだけを見ることになります。

   MS-DOSにはホームディレクトリーという概念がないので、MS-DOS上のEmacsは
Emacsがインストールされた場所が、環境変数‘HOME’の値であるかのように振る
舞います。つまりEmacsのバイナリー‘emacs.exe’がディレクトリー
‘c:/utils/emacs/bin’にある場合、Emacsは‘HOME’が‘c:/utils/emacs’にセット
されているかのように動作します。この場所は特に、Emacsがinitファイル
‘_emacs’を探す場所でもあります。これを念頭におけば、GNUやUnixのように、
ファイル名の中で‘~’をホームディレクトリーのエイリアスとして使用できます
。Emacsを開始する前に、その環境で‘HOME’変数をセットすることもできます。
この変数の値は、上記のデフォルトの振る舞いをオーバーライドします。

   MS-DOSのEmacsは、‘/dev’という名前を特別に使います。なぜならGJGPPのエ
ミュレーターライブラリーの機能は、I/Oデバイスの名前がそのディレクトリー
にあるかのように振る舞うからです。わたしたちは任意のディスクにたいして、
‘/dev’という名前のディレクトリーの使用を避けることを推奨します。


File: emacs-ja.info,  Node: MS-DOS Printing,  Next: MS-DOS and MULE,  Prev: MS-DOS File Names,  Up: MS-DOS

G.12.5 印刷とMS-DOS
-------------------

‘lpr-buffer’ (*note Printing::を参照してください)や、‘ps-print-buffer’
(*note PostScript::を参照してください) のようなコマンドは、POSIXスタイル
の‘lpr’プログラムが利用できない場合、出力を1つのプリンターポートに送るこ
とにより、MS-DOSで機能します。同じEmacs変数がすべてのシステムでの印刷を
制御しますが、MS-DOSでは異なるデフォルト値をもつ場合もあります。

   ネットワークプリンターでの印刷のセットアップに関する詳細は、*note
Windows Printing::を参照してください 。

   プリンターが同じlocaleにたいして異なるエンコーディングを使用する
Windows機に接続されている場合にも、非ASCIIテキストのDOSコードページによ
るエンコーディングを期待するプリンターがいくつかあります。たとえば
localeがLatin-1のとき、Windowsはコードページ1252を使用しますが、DOSはコ
ードページ850を使用します。*note MS-DOS and MULE::を参照してください。
Windowsからそのようなプリンターで印刷する場合、‘M-x lpr-buffer’の前に、
‘C-x <RET> c’ (‘universal-coding-system-argument’)を使用することができま
す。その場合、Emacsは指定したDOSコードページにテキストを変換します。たと
えば‘C-x <RET> c cp850-dos <RET> M-x lpr-region <RET>’は、リージョンをコ
ードページ850のエンコーディングに変換して印刷します。

   MS-DOSでは後方互換のため、‘dos-printer’ (‘dos-ps-printer’)に値がセッ
トされている場合、‘printer-name’ (‘ps-printer-name’)の値をオーバーライド
します。


File: emacs-ja.info,  Node: MS-DOS and MULE,  Next: MS-DOS Processes,  Prev: MS-DOS Printing,  Up: MS-DOS

G.12.6 MS-DOSでの国際化サポート
-------------------------------

MS-DOSのEmacsは、異なる文字セット同士を変換するためのコーディングシステ
ムを含む、GNU、Unix、その他のプラットフォームでサポートされているのと同
じ国際化文字セットをサポートします (*note International::を参照してくだ
さい)。 しかしMS-DOSと、MS-Windowsや他のシステムとの間の非互換により、こ
のサポートには知っておくべきいくつかのDOS特有の状況があります。このセク
ションではこれらの状況について説明します。

   以下の説明では、主にEmacsのMS-DOSポートについて、特に経験豊富な
Emacsユーザーにとって密接に関係する部分について説明します。

‘M-x dos-codepage-setup’
     カレントDOSコードページにたいして、適切なEmacsディスプレーとコーデ
     ィングシステムをセットアップします。

   MS-DOSは常に256文字の文字セットをサポートするようにデザインされていま
すが、それからさまざまな文字セットを選択できます。選択できる文字セットは
“DOSコードページ”として知られます。各コードページはすべて128文字の
ASCII文字を含みますが、それ以外の128文字(コード128から255)は、コードペー
ジごとに異なります。各コードページは850、862のように3桁の数字で識別され
ます。

   同時に複数のフォントを使用できるXとは対照的に、通常MS-DOSは1つのセッ
ションで複数のコードページを使用できません。MS-DOSはシステムの開始時に
1つのコードページをロードするようにデザインされており、それを変更するに
は再起動が必要です(1)。MS-Windowsのような他のシステムでDOSの実行可能ファ
イルを実行するときも、ほぼ同じ制限が適用されます。

   MS-DOSでのマルチバイト処理にたいして、Emacsは選択されたDOSコードペー
ジで表示できる文字を知る必要があります。そのため起動後に、選択されたコー
ドページ番号を得るためにシステムに問い合わせを行い、その番号を変数
‘dos-codepage’に格納します。実際のコードページは異なっていても、カレント
コードページにたいしてデフォルト値437を返すシステムがいくつかあります(通
常これはディスプレーハードウェアーに組み込まれているコードページを使用し
ているとき発生します)。initファイルで変数‘dos-codepage’をセットすること
により、Emacsに別のコードページを指定できます。

   マルチバイトのEmacsは特定のDOSコードページ — 日本語コードページ932の
ような極東アジアのスクリプトを表示できるものや、1つのISO 8859文字セット
をエンコードするものがあります。

   極東アジアのコードページは、それらの国々にたいするMULE文字セットの1つ
を直接表示できるので、Emacsはそのコードページでサポートされる適切な端末
コーディングシステムを使用するためにセットアップを行なうだけです。このセ
クションの残りの部分で説明する特別な機能は、主にISO 8859文字セットをエン
コードするコードページに関するものです。

   ISO文字セットの1つに対応するコードページにたいして、Emacsはそのコード
ページ番号にもとづいた文字セットを認識します。Emacsは、カレントコードペ
ージを使用したファイルの読み書きをサポートするためのコーディングシステム
を自動的に作成して、そのコーディングシステムをデフォルトとして使用します
。このコーディングシステムの名前は‘cpNNN’で、NNNはコードページ番号です。
(2)

   ‘cpNNN’というコーディングシステムはすべて、モードラインのニーモニック
に文字‘D’ (“DOS”)を使用します。端末のコーディングシステムと、ファイル
I/Oにたいするデフォルトのコーディングシステムは、開始時に適切な‘cpNNN’コ
ーディングシステムにセットされているので、普通はMS-DOSのモードラインは
‘-DD\-’で始まります。 *note Mode Line::を参照してください。 極東アジアの
DOS端末は‘cpNNN’コーディングシステムを使用しないので、Emacsデフォルトの
モードラインが初期表示されます。

   コードページ番号は使用しているスクリプトも示すので、Emacsはそのスクリ
プトにたいする言語環境を選択するために、自動的に
‘set-language-environment’を実行します (*note Language Environments::を
参照してください)。

   バッファーにISO 8859文字セット以外の文字が含まれていて、それが選択さ
れたDOSコードページでサポートされていない場合、EmacsはASCII文字のシーケ
ンスを使用して、それを表示します。たとえばカレントコードページが文字
‘ò’(grave accentつきの小文字の‘o’)にたいするグリフをもたない場合、その文
字は‘{`o}’と表示されます。ここで中カッコ(braces)はそれが1つの文字である
ことを示す指標です(これはギリシャ文字やヘブライのアルファベットのような
非ラテン文字にたいして不格好に見えるかもしれませんが、その言語を知る人は
これを読むことができます)。その文字がスクリーンの複数列を占めていても、
それは単なる1つの文字であり、Emacsコマンドは、それを1文字として扱います
。

   MS-Windowsは独自のコードページを提供し、同じロケールにたいするDOSコー
ドページとは異なります。たとえばDOSコードページと同じ文字をサポートする
Windowsコードページは1252で、DOSコードページ855と同じ文字をサポートする
Windowsコードページは1252、などです。EmacsのMS-Windowsバージョンを
‘-nw’オプションで呼び出したとき、Emacsはカレントコードページを使用して表
示を行ないます。

   ---------- Footnotes ----------

   (1) 通常1つの特定のコードページがディスプレーメモリーに組み込まれてい
て、‘CONFIG.SYS’のようなシステム設定ファイルを変更して再起動することによ
り他のコードページをインストールできます。再起動なしでコードページを変更
できるサードパーティーのソフトウェアーもありますが、ここでは普通の
MS-DOSシステムが振る舞う方法を説明します。

   (2) ISO 8859にたいすEmacsの標準コーディングシステムは、この目的に完全
に沿っているとは言えません。なぜならDOSコードページは通常、標準ISO文字コ
ードにマッチしないからです。たとえば文字‘ç’(cedillaつきの‘c’)は標準
Latin-1文字セットのコード231ですが、それに対応するDOSコードページ850はこ
のグリフにコード135を使用します。


File: emacs-ja.info,  Node: MS-DOS Processes,  Prev: MS-DOS and MULE,  Up: MS-DOS

G.12.7 MS-DOSでのサブプロセス
-----------------------------

MS-DOSは単一プロセスの“オペレーティングシステム”なので、非同期サブプロセ
スは利用できません。特にShellモードと、その変種は機能しません。非同期サ
ブプロセスを使用するEmacs機能のほとんどは、ShellモードやGUDを含めて、
MS-DOSでは動作しません。疑わしいときは、コマンドを実行してみれば、機能し
ない場合は非同期プロセスがサポートされない旨を告げるメッセージが出力され
ます。

   ‘M-x compile’によるEmacsでのコンパイル、‘M-x grep’によるファイル検索
、‘M-x diff’によるファイル間の相違の表示は、同期的に内部プロセスを実行す
ることにより機能します。これはその内部プロセスが終了するまで、編集を行な
うことができないことを意味します。

   ‘ispell’プログラムの同期呼び出しにたいする特別なサポートにより、スペ
ルチェックも機能します。これは他のプラットフォームでの非同期呼び出しより
遅くなります。

   MS-DOSでは、機能しないShellモードのかわりに、‘M-x eshell’コマンドを使
用することができます。これはPOSIX-likeなシェルを、Emacs Lispで実装した
Eshellパッケージを呼び出します。

   対照的に、ネイティブなWindowsアプリケーションとしてコンパイルされた
Emacsは、非同期サブプロセスを*サポートします* *note Windows Processes::を
参照してください。

   ‘lpr-buffer’ (*note Printing::を参照してください)と、
‘ps-print-buffer’ (*note PostScript::を参照してください)は、プリンターポ
ートの1つに出力を送ることにより、MS-DOSでも機能します。*note MS-DOS
Printing::を参照してください。

   MS-DOSでサブプロセスを同期実行する場合は、そのプログラムが終了するこ
とと、そのプログラムがキーボード入力の読み取りを試みないことを確認してく
ださい。プログラムが自分で終了しない場合、それを終了させることはできませ
ん。なぜならMS-DOSはプロセスを終了させる一般的な方法を提供しないからです
。このような場合、‘C-c’や‘C-<Break>’を押すことが助けになる場合もあります
。

   MS-DOSでは、他のマシンにあるファイルへのアクセスもサポートされません
。何らかのネットワークリダイレクト処理により、MS-DOSにネットワークアクセ
ス機能が組み込まれていない限り、メール送信、ウェブ閲覧、リモートログイン
などのようなネットワーク指向のコマンドは機能しません。

   MS-DOSのDiredは‘ls-lisp’パッケージを使用します (*note ls in Lisp::を
参照してください)。 したがってMS-DOSのDiredは、変数
‘dired-listing-switches’に記述できる、利用可能なオプションは限られます。
機能するオプションは‘-A’、‘-a’、‘-c’、‘-i’、‘-r’、‘-S’、‘-s’、‘-t’、
‘-u’です。


File: emacs-ja.info,  Node: Manifesto,  Next: Glossary,  Prev: Microsoft Windows,  Up: Top

The GNU Manifesto
*****************

     The GNU Manifesto which appears below was written by Richard
     Stallman at the beginning of the GNU project, to ask for
     participation and support.  For the first few years, it was updated
     in minor ways to account for developments, but now it seems best to
     leave it unchanged as most people have seen it.

     Since that time, we have learned about certain common
     misunderstandings that different wording could help avoid.
     Footnotes added in 1993 help clarify these points.

     For up-to-date information about available GNU software, please see
     our web site, <https://www.gnu.org>.  For software tasks and other
     ways to contribute, see <https://www.gnu.org/help>.

What’s GNU? Gnu’s Not Unix!
===========================

GNU, which stands for Gnu’s Not Unix, is the name for the complete
Unix-compatible software system which I am writing so that I can give it
away free to everyone who can use it.(1)  Several other volunteers are
helping me.  Contributions of time, money, programs and equipment are
greatly needed.

   So far we have an Emacs text editor with Lisp for writing editor
commands, a source level debugger, a yacc-compatible parser generator, a
linker, and around 35 utilities.  A shell (command interpreter) is
nearly completed.  A new portable optimizing C compiler has compiled
itself and may be released this year.  An initial kernel exists but many
more features are needed to emulate Unix.  When the kernel and compiler
are finished, it will be possible to distribute a GNU system suitable
for program development.  We will use TeX as our text formatter, but an
nroff is being worked on.  We will use the free, portable X window
system as well.  After this we will add a portable Common Lisp, an
Empire game, a spreadsheet, and hundreds of other things, plus on-line
documentation.  We hope to supply, eventually, everything useful that
normally comes with a Unix system, and more.

   GNU will be able to run Unix programs, but will not be identical to
Unix.  We will make all improvements that are convenient, based on our
experience with other operating systems.  In particular, we plan to have
longer file names, file version numbers, a crashproof file system, file
name completion perhaps, terminal-independent display support, and
perhaps eventually a Lisp-based window system through which several Lisp
programs and ordinary Unix programs can share a screen.  Both C and Lisp
will be available as system programming languages.  We will try to
support UUCP, MIT Chaosnet, and Internet protocols for communication.

   GNU is aimed initially at machines in the 68000/16000 class with
virtual memory, because they are the easiest machines to make it run on.
The extra effort to make it run on smaller machines will be left to
someone who wants to use it on them.

   To avoid horrible confusion, please pronounce the “G” in the word
“GNU” when it is the name of this project.

Why I Must Write GNU
====================

I consider that the golden rule requires that if I like a program I must
share it with other people who like it.  Software sellers want to divide
the users and conquer them, making each user agree not to share with
others.  I refuse to break solidarity with other users in this way.  I
cannot in good conscience sign a nondisclosure agreement or a software
license agreement.  For years I worked within the Artificial
Intelligence Lab to resist such tendencies and other inhospitalities,
but eventually they had gone too far: I could not remain in an
institution where such things are done for me against my will.

   So that I can continue to use computers without dishonor, I have
decided to put together a sufficient body of free software so that I
will be able to get along without any software that is not free.  I have
resigned from the AI lab to deny MIT any legal excuse to prevent me from
giving GNU away.

Why GNU Will Be Compatible with Unix
====================================

Unix is not my ideal system, but it is not too bad.  The essential
features of Unix seem to be good ones, and I think I can fill in what
Unix lacks without spoiling them.  And a system compatible with Unix
would be convenient for many other people to adopt.

How GNU Will Be Available
=========================

GNU is not in the public domain.  Everyone will be permitted to modify
and redistribute GNU, but no distributor will be allowed to restrict its
further redistribution.  That is to say, proprietary modifications will
not be allowed.  I want to make sure that all versions of GNU remain
free.

Why Many Other Programmers Want to Help
=======================================

I have found many other programmers who are excited about GNU and want
to help.

   Many programmers are unhappy about the commercialization of system
software.  It may enable them to make more money, but it requires them
to feel in conflict with other programmers in general rather than feel
as comrades.  The fundamental act of friendship among programmers is the
sharing of programs; marketing arrangements now typically used
essentially forbid programmers to treat others as friends.  The
purchaser of software must choose between friendship and obeying the
law.  Naturally, many decide that friendship is more important.  But
those who believe in law often do not feel at ease with either choice.
They become cynical and think that programming is just a way of making
money.

   By working on and using GNU rather than proprietary programs, we can
be hospitable to everyone and obey the law.  In addition, GNU serves as
an example to inspire and a banner to rally others to join us in
sharing.  This can give us a feeling of harmony which is impossible if
we use software that is not free.  For about half the programmers I talk
to, this is an important happiness that money cannot replace.

How You Can Contribute
======================

I am asking computer manufacturers for donations of machines and money.
I’m asking individuals for donations of programs and work.

   One consequence you can expect if you donate machines is that GNU
will run on them at an early date.  The machines should be complete,
ready to use systems, approved for use in a residential area, and not in
need of sophisticated cooling or power.

   I have found very many programmers eager to contribute part-time work
for GNU.  For most projects, such part-time distributed work would be
very hard to coordinate; the independently-written parts would not work
together.  But for the particular task of replacing Unix, this problem
is absent.  A complete Unix system contains hundreds of utility
programs, each of which is documented separately.  Most interface
specifications are fixed by Unix compatibility.  If each contributor can
write a compatible replacement for a single Unix utility, and make it
work properly in place of the original on a Unix system, then these
utilities will work right when put together.  Even allowing for Murphy
to create a few unexpected problems, assembling these components will be
a feasible task.  (The kernel will require closer communication and will
be worked on by a small, tight group.)

   If I get donations of money, I may be able to hire a few people full
or part time.  The salary won’t be high by programmers’ standards, but
I’m looking for people for whom building community spirit is as
important as making money.  I view this as a way of enabling dedicated
people to devote their full energies to working on GNU by sparing them
the need to make a living in another way.

Why All Computer Users Will Benefit
===================================

Once GNU is written, everyone will be able to obtain good system
software free, just like air.(2)

   This means much more than just saving everyone the price of a Unix
license.  It means that much wasteful duplication of system programming
effort will be avoided.  This effort can go instead into advancing the
state of the art.

   Complete system sources will be available to everyone.  As a result,
a user who needs changes in the system will always be free to make them
himself, or hire any available programmer or company to make them for
him.  Users will no longer be at the mercy of one programmer or company
which owns the sources and is in sole position to make changes.

   Schools will be able to provide a much more educational environment
by encouraging all students to study and improve the system code.
Harvard’s computer lab used to have the policy that no program could be
installed on the system if its sources were not on public display, and
upheld it by actually refusing to install certain programs.  I was very
much inspired by this.

   Finally, the overhead of considering who owns the system software and
what one is or is not entitled to do with it will be lifted.

   Arrangements to make people pay for using a program, including
licensing of copies, always incur a tremendous cost to society through
the cumbersome mechanisms necessary to figure out how much (that is,
which programs) a person must pay for.  And only a police state can
force everyone to obey them.  Consider a space station where air must be
manufactured at great cost: charging each breather per liter of air may
be fair, but wearing the metered gas mask all day and all night is
intolerable even if everyone can afford to pay the air bill.  And the TV
cameras everywhere to see if you ever take the mask off are outrageous.
It’s better to support the air plant with a head tax and chuck the
masks.

   Copying all or parts of a program is as natural to a programmer as
breathing, and as productive.  It ought to be as free.

Some Easily Rebutted Objections to GNU’s Goals
==============================================

     “Nobody will use it if it is free, because that means they can’t
     rely on any support.”

     “You have to charge for the program to pay for providing the
     support.”

   If people would rather pay for GNU plus service than get GNU free
without service, a company to provide just service to people who have
obtained GNU free ought to be profitable.(3)

   We must distinguish between support in the form of real programming
work and mere handholding.  The former is something one cannot rely on
from a software vendor.  If your problem is not shared by enough people,
the vendor will tell you to get lost.

   If your business needs to be able to rely on support, the only way is
to have all the necessary sources and tools.  Then you can hire any
available person to fix your problem; you are not at the mercy of any
individual.  With Unix, the price of sources puts this out of
consideration for most businesses.  With GNU this will be easy.  It is
still possible for there to be no available competent person, but this
problem cannot be blamed on distribution arrangements.  GNU does not
eliminate all the world’s problems, only some of them.

   Meanwhile, the users who know nothing about computers need
handholding: doing things for them which they could easily do themselves
but don’t know how.

   Such services could be provided by companies that sell just
hand-holding and repair service.  If it is true that users would rather
spend money and get a product with service, they will also be willing to
buy the service having got the product free.  The service companies will
compete in quality and price; users will not be tied to any particular
one.  Meanwhile, those of us who don’t need the service should be able
to use the program without paying for the service.

     “You cannot reach many people without advertising, and you must
     charge for the program to support that.”

     “It’s no use advertising a program people can get free.”

   There are various forms of free or very cheap publicity that can be
used to inform numbers of computer users about something like GNU.  But
it may be true that one can reach more microcomputer users with
advertising.  If this is really so, a business which advertises the
service of copying and mailing GNU for a fee ought to be successful
enough to pay for its advertising and more.  This way, only the users
who benefit from the advertising pay for it.

   On the other hand, if many people get GNU from their friends, and
such companies don’t succeed, this will show that advertising was not
really necessary to spread GNU.  Why is it that free market advocates
don’t want to let the free market decide this?(4)

     “My company needs a proprietary operating system to get a
     competitive edge.”

   GNU will remove operating system software from the realm of
competition.  You will not be able to get an edge in this area, but
neither will your competitors be able to get an edge over you.  You and
they will compete in other areas, while benefiting mutually in this one.
If your business is selling an operating system, you will not like GNU,
but that’s tough on you.  If your business is something else, GNU can
save you from being pushed into the expensive business of selling
operating systems.

   I would like to see GNU development supported by gifts from many
manufacturers and users, reducing the cost to each.(5)

     “Don’t programmers deserve a reward for their creativity?”

   If anything deserves a reward, it is social contribution.  Creativity
can be a social contribution, but only in so far as society is free to
use the results.  If programmers deserve to be rewarded for creating
innovative programs, by the same token they deserve to be punished if
they restrict the use of these programs.

     “Shouldn’t a programmer be able to ask for a reward for his
     creativity?”

   There is nothing wrong with wanting pay for work, or seeking to
maximize one’s income, as long as one does not use means that are
destructive.  But the means customary in the field of software today are
based on destruction.

   Extracting money from users of a program by restricting their use of
it is destructive because the restrictions reduce the amount and the
ways that the program can be used.  This reduces the amount of wealth
that humanity derives from the program.  When there is a deliberate
choice to restrict, the harmful consequences are deliberate destruction.

   The reason a good citizen does not use such destructive means to
become wealthier is that, if everyone did so, we would all become poorer
from the mutual destructiveness.  This is Kantian ethics; or, the Golden
Rule.  Since I do not like the consequences that result if everyone
hoards information, I am required to consider it wrong for one to do so.
Specifically, the desire to be rewarded for one’s creativity does not
justify depriving the world in general of all or part of that
creativity.

     “Won’t programmers starve?”

   I could answer that nobody is forced to be a programmer.  Most of us
cannot manage to get any money for standing on the street and making
faces.  But we are not, as a result, condemned to spend our lives
standing on the street making faces, and starving.  We do something
else.

   But that is the wrong answer because it accepts the questioner’s
implicit assumption: that without ownership of software, programmers
cannot possibly be paid a cent.  Supposedly it is all or nothing.

   The real reason programmers will not starve is that it will still be
possible for them to get paid for programming; just not paid as much as
now.

   Restricting copying is not the only basis for business in software.
It is the most common basis because it brings in the most money.  If it
were prohibited, or rejected by the customer, software business would
move to other bases of organization which are now used less often.
There are always numerous ways to organize any kind of business.

   Probably programming will not be as lucrative on the new basis as it
is now.  But that is not an argument against the change.  It is not
considered an injustice that sales clerks make the salaries that they
now do.  If programmers made the same, that would not be an injustice
either.  (In practice they would still make considerably more than
that.)

     “Don’t people have a right to control how their creativity is
     used?”

   “Control over the use of one’s ideas” really constitutes control over
other people’s lives; and it is usually used to make their lives more
difficult.

   People who have studied the issue of intellectual property rights(6)
carefully (such as lawyers) say that there is no intrinsic right to
intellectual property.  The kinds of supposed intellectual property
rights that the government recognizes were created by specific acts of
legislation for specific purposes.

   For example, the patent system was established to encourage inventors
to disclose the details of their inventions.  Its purpose was to help
society rather than to help inventors.  At the time, the life span of 17
years for a patent was short compared with the rate of advance of the
state of the art.  Since patents are an issue only among manufacturers,
for whom the cost and effort of a license agreement are small compared
with setting up production, the patents often do not do much harm.  They
do not obstruct most individuals who use patented products.

   The idea of copyright did not exist in ancient times, when authors
frequently copied other authors at length in works of non-fiction.  This
practice was useful, and is the only way many authors’ works have
survived even in part.  The copyright system was created expressly for
the purpose of encouraging authorship.  In the domain for which it was
invented—books, which could be copied economically only on a printing
press—it did little harm, and did not obstruct most of the individuals
who read the books.

   All intellectual property rights are just licenses granted by society
because it was thought, rightly or wrongly, that society as a whole
would benefit by granting them.  But in any particular situation, we
have to ask: are we really better off granting such license?  What kind
of act are we licensing a person to do?

   The case of programs today is very different from that of books a
hundred years ago.  The fact that the easiest way to copy a program is
from one neighbor to another, the fact that a program has both source
code and object code which are distinct, and the fact that a program is
used rather than read and enjoyed, combine to create a situation in
which a person who enforces a copyright is harming society as a whole
both materially and spiritually; in which a person should not do so
regardless of whether the law enables him to.

     “Competition makes things get done better.”

   The paradigm of competition is a race: by rewarding the winner, we
encourage everyone to run faster.  When capitalism really works this
way, it does a good job; but its defenders are wrong in assuming it
always works this way.  If the runners forget why the reward is offered
and become intent on winning, no matter how, they may find other
strategies—such as, attacking other runners.  If the runners get into a
fist fight, they will all finish late.

   Proprietary and secret software is the moral equivalent of runners in
a fist fight.  Sad to say, the only referee we’ve got does not seem to
object to fights; he just regulates them (“For every ten yards you run,
you can fire one shot”).  He really ought to break them up, and penalize
runners for even trying to fight.

     “Won’t everyone stop programming without a monetary incentive?”

   Actually, many people will program with absolutely no monetary
incentive.  Programming has an irresistible fascination for some people,
usually the people who are best at it.  There is no shortage of
professional musicians who keep at it even though they have no hope of
making a living that way.

   But really this question, though commonly asked, is not appropriate
to the situation.  Pay for programmers will not disappear, only become
less.  So the right question is, will anyone program with a reduced
monetary incentive?  My experience shows that they will.

   For more than ten years, many of the world’s best programmers worked
at the Artificial Intelligence Lab for far less money than they could
have had anywhere else.  They got many kinds of non-monetary rewards:
fame and appreciation, for example.  And creativity is also fun, a
reward in itself.

   Then most of them left when offered a chance to do the same
interesting work for a lot of money.

   What the facts show is that people will program for reasons other
than riches; but if given a chance to make a lot of money as well, they
will come to expect and demand it.  Low-paying organizations do poorly
in competition with high-paying ones, but they do not have to do badly
if the high-paying ones are banned.

     “We need the programmers desperately.  If they demand that we stop
     helping our neighbors, we have to obey.”

   You’re never so desperate that you have to obey this sort of demand.
Remember: millions for defense, but not a cent for tribute!

     “Programmers need to make a living somehow.”

   In the short run, this is true.  However, there are plenty of ways
that programmers could make a living without selling the right to use a
program.  This way is customary now because it brings programmers and
businessmen the most money, not because it is the only way to make a
living.  It is easy to find other ways if you want to find them.  Here
are a number of examples.

   A manufacturer introducing a new computer will pay for the porting of
operating systems onto the new hardware.

   The sale of teaching, hand-holding and maintenance services could
also employ programmers.

   People with new ideas could distribute programs as freeware(7),
asking for donations from satisfied users, or selling hand-holding
services.  I have met people who are already working this way
successfully.

   Users with related needs can form users’ groups, and pay dues.  A
group would contract with programming companies to write programs that
the group’s members would like to use.

   All sorts of development can be funded with a Software Tax:

     Suppose everyone who buys a computer has to pay x percent of the
     price as a software tax.  The government gives this to an agency
     like the NSF to spend on software development.

     But if the computer buyer makes a donation to software development
     himself, he can take a credit against the tax.  He can donate to
     the project of his own choosing—often, chosen because he hopes to
     use the results when it is done.  He can take a credit for any
     amount of donation up to the total tax he had to pay.

     The total tax rate could be decided by a vote of the payers of the
     tax, weighted according to the amount they will be taxed on.

     The consequences:

        • The computer-using community supports software development.
        • This community decides what level of support is needed.
        • Users who care which projects their share is spent on can
          choose this for themselves.

   In the long run, making programs free is a step toward the
post-scarcity world, where nobody will have to work very hard just to
make a living.  People will be free to devote themselves to activities
that are fun, such as programming, after spending the necessary ten
hours a week on required tasks such as legislation, family counseling,
robot repair and asteroid prospecting.  There will be no need to be able
to make a living from programming.

   We have already greatly reduced the amount of work that the whole
society must do for its actual productivity, but only a little of this
has translated itself into leisure for workers because much
nonproductive activity is required to accompany productive activity.
The main causes of this are bureaucracy and isometric struggles against
competition.  Free software will greatly reduce these drains in the area
of software production.  We must do this, in order for technical gains
in productivity to translate into less work for us.

   ---------- Footnotes ----------

   (1) The wording here was careless.  The intention was that nobody
would have to pay for _permission_ to use the GNU system.  But the words
don’t make this clear, and people often interpret them as saying that
copies of GNU should always be distributed at little or no charge.  That
was never the intent; later on, the manifesto mentions the possibility
of companies providing the service of distribution for a profit.
Subsequently I have learned to distinguish carefully between “free” in
the sense of freedom and “free” in the sense of price.  Free software is
software that users have the freedom to distribute and change.  Some
users may obtain copies at no charge, while others pay to obtain
copies—and if the funds help support improving the software, so much the
better.  The important thing is that everyone who has a copy has the
freedom to cooperate with others in using it.

   (2) This is another place I failed to distinguish carefully between
the two different meanings of “free.” The statement as it stands is not
false—you can get copies of GNU software at no charge, from your friends
or over the net.  But it does suggest the wrong idea.

   (3) Several such companies now exist.

   (4) The Free Software Foundation raises most of its funds from a
distribution service, although it is a charity rather than a company.
If _no one_ chooses to obtain copies by ordering from the FSF, it will
be unable to do its work.  But this does not mean that proprietary
restrictions are justified to force every user to pay.  If a small
fraction of all the users order copies from the FSF, that is sufficient
to keep the FSF afloat.  So we ask users to choose to support us in this
way.  Have you done your part?

   (5) A group of computer companies recently pooled funds to support
maintenance of the GNU C Compiler.

   (6) In the 80s I had not yet realized how confusing it was to speak
of “the issue” of “intellectual property.” That term is obviously
biased; more subtle is the fact that it lumps together various disparate
laws which raise very different issues.  Nowadays I urge people to
reject the term “intellectual property” entirely, lest it lead others to
suppose that those laws form one coherent issue.  The way to be clear is
to discuss patents, copyrights, and trademarks separately.  See
<https://www.gnu.org/philosophy/not-ipr.xhtml> for more explanation of
how this term spreads confusion and bias.

   (7) Subsequently we have discovered the need to distinguish between
“free software” and “freeware”.  The term “freeware” means software you
are free to redistribute, but usually you are not free to study and
change the source code, so most of it is not free software.  See
<https://www.gnu.org/philosophy/words-to-avoid.html> for more
explanation.


File: emacs-ja.info,  Node: Glossary,  Next: Acknowledgments,  Prev: Manifesto,  Up: Top

Glossary
********

Abbrev
     An abbrev is a text string that expands into a different text
     string when present in the buffer.  For example, you might define a
     few letters as an abbrev for a long phrase that you want to insert
     frequently.  *Note Abbrevs::.

Aborting
     Aborting means getting out of a recursive edit (q.v.).  The
     commands ‘C-]’ and ‘M-x top-level’ are used for this.  *Note
     Quitting::.

Active Region
     Setting the mark (q.v.) at a position in the text also activates
     it.  When the mark is active, we call the region an active region.
     *Note Mark::.

<Alt>
     Alt is the name of a modifier bit that a keyboard input character
     may have.  To make a character Alt, type it while holding down the
     <Alt> key.  Such characters are given names that start with
     ‘<Alt>-’ (usually written ‘A-’ for short).  (Note that many
     terminals have a key labeled <Alt> that is really a <Meta> key.)
     *Note Alt: User Input.

Argument
     *Note Glossary---Numeric Argument::.

ASCII character
     An ASCII character is either an ASCII control character or an ASCII
     printing character.  *Note User Input::.

ASCII control character
     An ASCII control character is the Control version of an upper-case
     letter, or the Control version of one of the characters ‘@[\]^_?’.

ASCII printing character
     ASCII letters, digits, space, and the following punctuation
     characters: ‘!@#$%^&*()_-+=|\~`{}[]:;"'<>,.?/’.

Auto Fill Mode
     Auto Fill mode is a minor mode (q.v.) in which text that you insert
     is automatically broken into lines of a given maximum width.  *Note
     Filling::.

Auto Saving
     Auto saving is the practice of periodically saving the contents of
     an Emacs buffer in a specially-named file, so that the information
     will be preserved if the buffer is lost due to a system error or
     user error.  *Note Auto Save::.

Autoloading
     Emacs can automatically load Lisp libraries when a Lisp program
     requests a function from those libraries.  This is called
     “autoloading”.  *Note Lisp Libraries::.

Backtrace
     A backtrace is a trace of a series of function calls showing how a
     program arrived at a certain point.  It is used mainly for finding
     and correcting bugs (q.v.).  Emacs can display a backtrace when it
     signals an error or when you type ‘C-g’ (*note
     Glossary---Quitting::).  *Note Checklist::.

Backup File
     A backup file records the contents that a file had before the
     current editing session.  Emacs makes backup files automatically to
     help you track down or cancel changes you later regret making.
     *Note Backup::.

Balancing Parentheses
     Emacs can balance parentheses (or other matching delimiters) either
     manually or automatically.  You do manual balancing with the
     commands to move over parenthetical groupings (*note Moving by
     Parens::).  Automatic balancing works by blinking or highlighting
     the delimiter that matches the one you just inserted, or inserting
     the matching delimiter for you (*note Matching Parens: Matching.).

Balanced Expressions
     A balanced expression is a syntactically recognizable expression,
     such as a symbol, number, string constant, block, or parenthesized
     expression in C.  *Note Balanced Expressions: Expressions.

Balloon Help
     *Note Glossary---Tooltips::.

Base Buffer
     A base buffer is a buffer whose text is shared by an indirect
     buffer (q.v.).

Bidirectional Text
     Some human languages, such as English, are written from left to
     right.  Others, such as Arabic, are written from right to left.
     Emacs supports both of these forms, as well as any mixture of
     them—this is “bidirectional text”.  *Note Bidirectional Editing::.

Bind
     To bind a key sequence means to give it a binding (q.v.).  *Note
     Rebinding::.

Binding
     A key sequence gets its meaning in Emacs by having a binding, which
     is a command (q.v.)—a Lisp function that is run when you type that
     sequence.  *Note Binding: Commands.  Customization often involves
     rebinding a character to a different command function.  The
     bindings of all key sequences are recorded in the keymaps (q.v.).
     *Note Keymaps::.

Blank Lines
     Blank lines are lines that contain only whitespace.  Emacs has
     several commands for operating on the blank lines in the buffer.
     *Note Blank Lines::.

Bookmark
     Bookmarks are akin to registers (q.v.) in that they record
     positions in buffers to which you can return later.  Unlike
     registers, bookmarks persist between Emacs sessions.  *Note
     Bookmarks::.

Border
     A border is a thin space along the edge of the frame, used just for
     spacing, not for displaying anything.  An Emacs frame has an
     ordinary external border, outside of everything including the menu
     bar, plus an internal border that surrounds the text windows, their
     scroll bars and fringes, and separates them from the menu bar and
     tool bar.  You can customize both borders with options and
     resources (*note Borders X::).  Borders are not the same as fringes
     (q.v.).

Buffer
     The buffer is the basic editing unit; one buffer corresponds to one
     text being edited.  You normally have several buffers, but at any
     time you are editing only one, the current buffer, though several
     can be visible when you are using multiple windows or frames
     (q.v.).  Most buffers are visiting (q.v.) some file.  *Note
     Buffers::.

Buffer Selection History
     Emacs keeps a buffer selection history that records how recently
     each Emacs buffer has been selected.  This is used for choosing
     which buffer to select.  *Note Buffers::.

Bug
     A bug is an incorrect or unreasonable behavior of a program, or
     inaccurate or confusing documentation.  Emacs developers treat bug
     reports, both in Emacs code and its documentation, very seriously
     and ask you to report any bugs you find.  *Note Bugs::.

Button Down Event
     A button down event is the kind of input event (q.v.) generated
     right away when you press down on a mouse button.  *Note Mouse
     Buttons::.

By Default
     *Note Glossary---Default::.

Byte Compilation
     *Note Glossary---Compilation::.

cf.
c.f.
     Short for “confer” in Latin, which means “compare with” or “compare
     to”.  The second variant, “c.f.”, is a widespread misspelling.

‘C-’
     ‘C-’ in the name of a character is an abbreviation for Control.
     *Note C-: User Input.

‘C-M-’
     ‘C-M-’ in the name of a character is an abbreviation for
     Control-Meta.  If your terminal lacks a real <Meta> key, you type a
     Control-Meta character by typing <ESC> and then typing the
     corresponding Control character.  *Note C-M-: User Input.

Case Conversion
     Case conversion means changing text from upper case to lower case
     or vice versa.  *Note Case::.

Case Folding
     Case folding means ignoring the differences between case variants
     of the same letter: upper-case, lower-case, and title-case.  Emacs
     performs case folding by default in text search.  *Note Lax
     Search::.

Character
     Characters form the contents of an Emacs buffer.  Also, key
     sequences (q.v.) are usually made up of characters (though they may
     include other input events as well).  *Note User Input::.

Character Folding
     Character folding means ignoring differences between similarly
     looking characters, such as between ‘a’, and ‘ä’ and ‘á’.  Emacs
     performs character folding by default in text search.  *Note Lax
     Search::.

Character Set
     Emacs supports a number of character sets, each of which represents
     a particular alphabet or script.  *Note International::.

Character Terminal
     *Note Glossary---Text Terminal::.

Click Event
     A click event is the kind of input event (q.v.) generated when you
     press a mouse button and release it without moving the mouse.
     *Note Mouse Buttons::.

Client
     *Note Glossary---Server::.

Clipboard
     A clipboard is a buffer provided by the window system for
     transferring text between applications.  On the X Window System,
     the clipboard is provided in addition to the primary selection
     (q.v.); on MS-Windows and Mac, the clipboard is used _instead_ of
     the primary selection.  *Note Clipboard::.

Coding System
     A coding system is a way to encode text characters in a file or in
     a stream of information.  Emacs has the ability to convert text to
     or from a variety of coding systems when reading or writing it.
     *Note Coding Systems::.

Command
     A command is a Lisp function specially defined to be able to serve
     as a key binding in Emacs or to be invoked by its name (*note
     Glossary---Command Name::).  When you type a key sequence (q.v.),
     its binding (q.v.) is looked up in the relevant keymaps (q.v.) to
     find the command to run.  *Note Commands::.

Command History
     *Note Glossary---Minibuffer History::.

Command Name
     A command name is the name of a Lisp symbol that is a command
     (*note Commands::).  You can invoke any command by its name using
     ‘M-x’ (*note M-x: M-x.).

Comment
     A comment is text in a program which is intended only for humans
     reading the program, and which is specially marked so that it will
     be ignored when the program is loaded or compiled.  Emacs offers
     special commands for creating, aligning and killing comments.
     *Note Comments::.

Common Lisp
     Common Lisp is a dialect of Lisp (q.v.) much larger and more
     powerful than Emacs Lisp.  Emacs provides a subset of Common Lisp
     in the CL package.  *Note Common Lisp: (cl)Top.

Compilation
     Compilation is the process of creating an executable program from
     source code.  Emacs has commands for compiling files of Emacs Lisp
     code (*note (elisp)Byte Compilation::) and programs in C and other
     languages (*note Compilation::).  Byte-compiled Emacs Lisp code
     loads and executes faster.

Complete Key
     A complete key is a key sequence that fully specifies one action to
     be performed by Emacs.  For example, ‘X’ and ‘C-f’ and ‘C-x m’ are
     complete keys.  Complete keys derive their meanings from being
     bound (*note Glossary---Bind::) to commands (q.v.).  Thus, ‘X’ is
     conventionally bound to a command to insert ‘X’ in the buffer; ‘C-x
     m’ is conventionally bound to a command to begin composing a mail
     message.  *Note Keys::.

Completion
     Completion is what Emacs does when it automatically expands an
     abbreviation for a name into the entire name.  Completion is done
     for minibuffer (q.v.) arguments when the set of possible valid
     inputs is known; for example, on command names, buffer names, and
     file names.  Completion usually occurs when <TAB>, <SPC> or <RET>
     is typed.  *Note Completion::.

Continuation Line
     When a line of text is longer than the width of the window, it
     normally takes up more than one screen line when displayed (but see
     *note Glossary---Truncation::).  We say that the text line is
     continued, and all screen lines used for it after the first are
     called continuation lines.  *Note Continuation Lines::.  A related
     Emacs feature is filling (q.v.).

Control Character
     A control character is a character that you type by holding down
     the <Ctrl> key.  Some control characters also have their own keys,
     so that you can type them without using <Ctrl>.  For example,
     <RET>, <TAB>, <ESC> and <DEL> are all control characters.  *Note
     User Input::.

Copyleft
     A copyleft is a notice giving the public legal permission to
     redistribute and modify a program or other work of art, but
     requiring modified versions to carry similar permission.  Copyright
     is normally used to keep users divided and helpless; with copyleft
     we turn that around to empower users and encourage them to
     cooperate.

     The particular form of copyleft used by the GNU project is called
     the GNU General Public License.  *Note Copying::.

<Ctrl>
     The <Ctrl> or control key is what you hold down in order to enter a
     control character (q.v.).  *Note Glossary---C-::.

Current Buffer
     The current buffer in Emacs is the Emacs buffer on which most
     editing commands operate.  You can select any Emacs buffer as the
     current one.  *Note Buffers::.

Current Line
     The current line is the line that point is on (*note Point::).

Current Paragraph
     The current paragraph is the paragraph that point is in.  If point
     is between two paragraphs, the current paragraph is the one that
     follows point.  *Note Paragraphs::.

Current Defun
     The current defun is the defun (q.v.) that point is in.  If point
     is between defuns, the current defun is the one that follows point.
     *Note Defuns::.

Cursor
     The cursor is the rectangle on the screen which indicates the
     position (called point; q.v.) at which insertion and deletion takes
     place.  The cursor is on or under the character that follows point.
     Often people speak of “the cursor” when, strictly speaking, they
     mean “point”.  *Note Cursor: Point.

Customization
     Customization is making minor changes in the way Emacs works, to
     reflect your preferences or needs.  It is often done by setting
     variables (*note Variables::) or faces (*note Face
     Customization::), or by rebinding key sequences (*note Keymaps::).

Cut and Paste
     *Note Glossary---Killing::, and *note Glossary---Yanking::.

Daemon
     A daemon is a standard term for a system-level process that runs in
     the background.  Daemons are often started when the system first
     starts up.  When Emacs runs in daemon-mode, it does not open a
     display.  You connect to it with the ‘emacsclient’ program.  *Note
     Emacs Server::.

Default Argument
     The default for an argument is the value that will be assumed if
     you do not specify one.  When the minibuffer is used to read an
     argument, the default argument is used if you just type <RET>.
     *Note Minibuffer::.

Default
     A default is the value that is used for a certain purpose when you
     do not explicitly specify a value to use.

Default Directory
     When you specify a file name that does not start with ‘/’ or ‘~’,
     it is interpreted relative to the current buffer’s default
     directory.  (On MS systems, file names that start with a drive
     letter ‘X:’ are treated as absolute, not relative.)  *Note Default
     Directory: Minibuffer File.

Defun
     A defun is a major definition at the top level in a program.  The
     name “defun” comes from Lisp, where most such definitions use the
     construct ‘defun’.  *Note Defuns::.

<DEL>
     <DEL> is a character that runs the command to delete one character
     of text before the cursor.  It is typically either the <Delete> key
     or the <BACKSPACE> key, whichever one is easy to type.  *Note DEL:
     Erasing.

Deletion
     Deletion means erasing text without copying it into the kill ring
     (q.v.).  The alternative is killing (q.v.).  *Note Deletion:
     Killing.

Deletion of Files
     Deleting a file means erasing it from the file system.  (Note that
     some systems use the concept of a trash can, or recycle bin, to
     allow you to undelete files.)  *Note Misc File Ops: Misc File Ops.

Deletion of Messages
     Deleting a message (in Rmail, and other mail clients) means
     flagging it to be eliminated from your mail file.  Until you
     expunge (q.v.) the Rmail file, you can still undelete the messages
     you have deleted.  *Note Rmail Deletion::.

Deletion of Windows
     Deleting a window means eliminating it from the screen.  Other
     windows expand to use up the space.  The text that was in the
     window is not lost, and you can create a new window with the same
     dimensions as the old if you wish.  *Note Windows::.

Directory
     File directories are named collections in the file system, within
     which you can place individual files or subdirectories.  They are
     sometimes referred to as “folders”.  *Note Directories::.

Directory Local Variable
     A directory local variable is a local variable (q.v.) that applies
     to all the files within a certain directory.  *Note Directory
     Variables::.

Directory Name
     On GNU and other Unix-like systems, directory names are strings
     that end in ‘/’.  For example, ‘/no-such-dir/’ is a directory name
     whereas ‘/tmp’ is not, even though ‘/tmp’ names a file that happens
     to be a directory.  On MS-Windows the relationship is more
     complicated.  *Note (elisp)Directory Names::.

Dired
     Dired is the Emacs facility that displays the contents of a file
     directory and allows you to “edit the directory”, performing
     operations on the files in the directory.  *Note Dired::.

Disabled Command
     A disabled command is one that you may not run without special
     confirmation.  The usual reason for disabling a command is that it
     is confusing for beginning users.  *Note Disabling::.

Down Event
     Short for “button down event” (q.v.).

Drag Event
     A drag event is the kind of input event (q.v.) generated when you
     press a mouse button, move the mouse, and then release the button.
     *Note Mouse Buttons::.

Dribble File
     A dribble file is a file into which Emacs writes all the characters
     that you type on the keyboard.  Dribble files can be used to make a
     record for debugging Emacs bugs.  Emacs does not make a dribble
     file unless you tell it to.  *Note Bugs::.

e.g.
     Short for “exempli gratia” in Latin, which means “for example”.

Echo Area
     The echo area is the bottom line of the screen, used for echoing
     the arguments to commands, for asking questions, and showing brief
     messages (including error messages).  The messages are stored in
     the buffer ‘*Messages*’ so you can review them later.  *Note Echo
     Area::.

Echoing
     Echoing is acknowledging the receipt of input events by displaying
     them (in the echo area).  Emacs never echoes single-character key
     sequences; longer key sequences echo only if you pause while typing
     them.

Electric
     We say that a character is electric if it is normally
     self-inserting (q.v.), but the current major mode (q.v.) redefines
     it to do something else as well.  For example, some programming
     language major modes define particular delimiter characters to
     reindent the line, or insert one or more newlines in addition to
     self-insertion.

End Of Line
     End of line is a character or a sequence of characters that
     indicate the end of a text line.  On GNU and Unix systems, this is
     a newline (q.v.), but other systems have other conventions.  *Note
     end-of-line: Coding Systems.  Emacs can recognize several
     end-of-line conventions in files and convert between them.

Environment Variable
     An environment variable is one of a collection of variables stored
     by the operating system, each one having a name and a value.  Emacs
     can access environment variables set by its parent shell, and it
     can set variables in the environment it passes to programs it
     invokes.  *Note Environment::.

EOL
     *Note Glossary---End Of Line::.

Error
     An error occurs when an Emacs command cannot execute in the current
     circumstances.  When an error occurs, execution of the command
     stops (unless the command has been programmed to do otherwise) and
     Emacs reports the error by displaying an error message (q.v.).

Error Message
     An error message is output displayed by Emacs when you ask it to do
     something impossible (such as, killing text forward when point is
     at the end of the buffer), or when a command malfunctions in some
     way.  Such messages appear in the echo area, accompanied by a beep.

<ESC>
     <ESC> is a character used as a prefix for typing Meta characters on
     keyboards lacking a <Meta> key.  Unlike the <Meta> key (which, like
     the <SHIFT> key, is held down while another character is typed),
     you press the <ESC> key as you would press a letter key, and it
     applies to the next character you type.

etc.
     Short for “et cetera” in Latin, which means “and so on”.

Expression
     *Note Glossary---Balanced Expression::.

Expunging
     Expunging an Rmail, Gnus newsgroup, or Dired buffer is an operation
     that truly discards the messages or files you have previously
     flagged for deletion.

Face
     A face is a style of displaying characters.  It specifies
     attributes such as font family and size, foreground and background
     colors, underline and strike-through, background stipple, etc.
     Emacs provides features to associate specific faces with portions
     of buffer text, in order to display that text as specified by the
     face attributes.  *Note Faces::.

File Local Variable
     A file local variable is a local variable (q.v.) specified in a
     given file.  *Note File Variables::, and *note Glossary---Directory
     Local Variable::.

File Locking
     Emacs uses file locking to notice when two different users start to
     edit one file at the same time.  *Note Interlocking::.

File Name
     A file name is a name that refers to a file.  File names may be
     relative or absolute; the meaning of a relative file name depends
     on the current directory, but an absolute file name refers to the
     same file regardless of which directory is current.  On GNU and
     Unix systems, an absolute file name starts with a slash (the root
     directory) or with ‘~/’ or ‘~USER/’ (a home directory).  On
     MS-Windows/MS-DOS, an absolute file name can also start with a
     drive letter and a colon, e.g., ‘D:’.

     Some people use the term “pathname” for file names, but we do not;
     we use the word “path” only in the term “search path” (q.v.).

File-Name Component
     A file-name component names a file directly within a particular
     directory.  On GNU and Unix systems, a file name is a sequence of
     file-name components, separated by slashes.  For example, ‘foo/bar’
     is a file name containing two components, ‘foo’ and ‘bar’; it
     refers to the file named ‘bar’ in the directory named ‘foo’ in the
     current directory.  MS-DOS/MS-Windows file names can also use
     backslashes to separate components, as in ‘foo\bar’.

Fill Prefix
     The fill prefix is a string that should be expected at the
     beginning of each line when filling is done.  It is not regarded as
     part of the text to be filled.  *Note Filling::.

Filling
     Filling text means adjusting the position of line-breaks to shift
     text between consecutive lines, so that all the lines are
     approximately the same length.  *Note Filling::.  Some other
     editors call this feature “line wrapping”.

Font Lock
     Font Lock is a mode that highlights parts of buffer text in
     different faces, according to the syntax.  Some other editors refer
     to this as “syntax highlighting”.  For example, all comments (q.v.)
     might be colored red.  *Note Font Lock::.

Fontset
     A fontset is a named collection of fonts.  A fontset specification
     lists character sets and which font to use to display each of them.
     Fontsets make it easy to change several fonts at once by specifying
     the name of a fontset, rather than changing each font separately.
     *Note Fontsets::.

Formfeed Character
     *Note Glossary---Page::.

Frame
     A frame is a rectangular cluster of Emacs windows.  Emacs starts
     out with one frame, but you can create more.  You can subdivide
     each frame into Emacs windows (q.v.).  When you are using a window
     system (q.v.), more than one frame can be visible at the same time.
     *Note Frames::.  Some other editors use the term “window” for this,
     but in Emacs a window means something else.

Free Software
     Free software is software that gives you the freedom to share,
     study and modify it.  Emacs is free software, part of the GNU
     project (q.v.), and distributed under a copyleft (q.v.) license
     called the GNU General Public License.  *Note Copying::.

Free Software Foundation
     The Free Software Foundation (FSF) is a charitable foundation
     dedicated to promoting the development of free software (q.v.).
     For more information, see the FSF website (https://fsf.org/).

Fringe
     On a graphical display (q.v.), there’s a narrow portion of the
     frame (q.v.) between the text area and the window’s border.  These
     “fringes” are used to display symbols that provide information
     about the buffer text (*note Fringes::).  Emacs displays the fringe
     using a special face (q.v.) called ‘fringe’.  *Note fringe: Faces.

FSF
     *Note Glossary---Free Software Foundation::.

FTP
     FTP is an acronym for File Transfer Protocol.  This is one standard
     method for retrieving remote files (q.v.).

Function Key
     A function key is a key on the keyboard that sends input but does
     not correspond to any character.  *Note Function Keys::.

Global
     Global means “independent of the current environment; in effect
     throughout Emacs”.  It is the opposite of local (q.v.).  Particular
     examples of the use of “global” appear below.

Global Abbrev
     A global definition of an abbrev (q.v.) is effective in all major
     modes that do not have local (q.v.) definitions for the same
     abbrev.  *Note Abbrevs::.

Global Keymap
     The global keymap (q.v.) contains key bindings that are in effect
     everywhere, except when overridden by local key bindings in a major
     mode’s local keymap (q.v.).  *Note Keymaps::.

Global Mark Ring
     The global mark ring records the series of buffers you have
     recently set a mark (q.v.) in.  In many cases you can use this to
     backtrack through buffers you have been editing, or in which you
     have found tags (*note Glossary---Tags Table::).  *Note Global Mark
     Ring::.

Global Substitution
     Global substitution means replacing each occurrence of one string
     by another string throughout a large amount of text.  *Note
     Replace::.

Global Variable
     The global value of a variable (q.v.) takes effect in all buffers
     that do not have their own local (q.v.) values for the variable.
     *Note Variables::.

GNU
     GNU is a recursive acronym for GNU’s Not Unix, and it refers to a
     Unix-compatible operating system which is free software (q.v.).
     *Note Manifesto::.  GNU is normally used with Linux as the kernel
     since Linux works better than the GNU kernel.  For more
     information, see the GNU website (https://www.gnu.org/).

Graphic Character
     Graphic characters are those assigned pictorial images rather than
     just names.  All the non-Meta (q.v.) characters except for the
     Control (q.v.) characters are graphic characters.  These include
     letters, digits, punctuation, and spaces; they do not include <RET>
     or <ESC>.  In Emacs, typing a graphic character inserts that
     character (in ordinary editing modes).  *Note Inserting Text::.

Graphical Display
     A graphical display is one that can display images and multiple
     fonts.  Usually it also has a window system (q.v.).

Highlighting
     Highlighting text means displaying it with a different foreground
     and/or background color to make it stand out from the rest of the
     text in the buffer.

     Emacs uses highlighting in several ways.  It highlights the region
     whenever it is active (*note Mark::).  Incremental search also
     highlights matches (*note Incremental Search::).  *Note
     Glossary---Font Lock::.

Hardcopy
     Hardcopy means printed output.  Emacs has various commands for
     printing the contents of Emacs buffers.  *Note Printing::.

<HELP>
     <HELP> is the Emacs name for ‘C-h’ or <F1>.  You can type <HELP> at
     any time to ask what options you have, or to ask what a command
     does.  *Note Help::.

Help Echo
     Help echo is a short message displayed in the echo area (q.v.) when
     the mouse pointer is located on portions of display that require
     some explanations.  Emacs displays help echo for menu items, parts
     of the mode line, tool-bar buttons, etc.  On graphical displays,
     the messages can be displayed as tooltips (q.v.).  *Note
     Tooltips::.

Home Directory
     Your home directory contains your personal files.  On a multi-user
     GNU or Unix system, each user has his or her own home directory.
     When you start a new login session, your home directory is the
     default directory in which to start.  A standard shorthand for your
     home directory is ‘~’.  Similarly, ‘~USER’ represents the home
     directory of some other user.

Hook
     A hook is a list of functions to be called on specific occasions,
     such as saving a buffer in a file, major mode activation, etc.  By
     customizing the various hooks, you can modify Emacs’s behavior
     without changing any of its code.  *Note Hooks::.

Hyper
     Hyper is the name of a modifier bit that a keyboard input character
     may have.  To make a character Hyper, type it while holding down
     the <Hyper> key.  Such characters are given names that start with
     ‘Hyper-’ (usually written ‘H-’ for short).  *Note Modifier Keys::.

i.e.
     Short for “id est” in Latin, which means “that is”.

Iff
     “Iff” means “if and only if”.  This terminology comes from
     mathematics.  Try to avoid using this term in documentation, since
     many are unfamiliar with it and mistake it for a typo.

Inbox
     An inbox is a file in which mail is delivered by the operating
     system.  Rmail transfers mail from inboxes to Rmail files in which
     the mail is then stored permanently or until explicitly deleted.
     *Note Rmail Inbox::.

Incremental Search
     Emacs provides an incremental search facility, whereby Emacs begins
     searching for a string as soon as you type the first character.  As
     you type more characters, it refines the search.  *Note Incremental
     Search::.

Indentation
     Indentation means blank space at the beginning of a line.  Most
     programming languages have conventions for using indentation to
     illuminate the structure of the program, and Emacs has special
     commands to adjust indentation.  *Note Indentation::.

Indirect Buffer
     An indirect buffer is a buffer that shares the text of another
     buffer, called its base buffer (q.v.).  *Note Indirect Buffers::.

Info
     Info is the hypertext format used by the GNU project for writing
     documentation.

Input Event
     An input event represents, within Emacs, one action taken by the
     user on the terminal.  Input events include typing characters,
     typing function keys, pressing or releasing mouse buttons, and
     switching between Emacs frames.  *Note User Input::.

Input Method
     An input method is a system for entering non-ASCII text characters
     by typing sequences of ASCII characters (q.v.).  *Note Input
     Methods::.

Insertion
     Insertion means adding text into the buffer, either from the
     keyboard or from some other place in Emacs.

Interlocking
     *Note Glossary---File Locking::.

Isearch
     *Note Glossary---Incremental Search::.

Justification
     Justification means adding extra spaces within lines of text in
     order to adjust the position of the text edges.  *Note Fill
     Commands::.

Key Binding
     *Note Glossary---Binding::.

Keyboard Macro
     Keyboard macros are a way of defining new Emacs commands from
     sequences of existing ones, with no need to write a Lisp program.
     You can use a macro to record a sequence of commands, then play
     them back as many times as you like.  *Note Keyboard Macros::.

Keyboard Shortcut
     A keyboard shortcut is a key sequence (q.v.) that invokes a
     command.  What some programs call “assigning a keyboard shortcut”,
     Emacs calls “binding a key sequence”.  *Note Glossary---Binding::.

Key Sequence
     A key sequence (key, for short) is a sequence of input events
     (q.v.) that are meaningful as a single unit.  If the key sequence
     is enough to specify one action, it is a complete key (q.v.); if it
     is not enough, it is a prefix key (q.v.).  *Note Keys::.

Keymap
     The keymap is the data structure that records the bindings (q.v.)
     of key sequences to the commands that they run.  For example, the
     global keymap binds the character ‘C-n’ to the command function
     ‘next-line’.  *Note Keymaps::.

Keyboard Translation Table
     The keyboard translation table is an array that translates the
     character codes that come from the terminal into the character
     codes that make up key sequences.

Kill Ring
     The kill ring is where all text you have killed (*note
     Glossary---Killing::) recently is saved.  You can reinsert any of
     the killed text still in the ring; this is called yanking (q.v.).
     *Note Yanking::.

Killing
     Killing means erasing text and saving it on the kill ring so it can
     be yanked (q.v.) later.  Some other systems call this “cutting”.
     Most Emacs commands that erase text perform killing, as opposed to
     deletion (q.v.).  *Note Killing::.

Killing a Job
     Killing a job (such as, an invocation of Emacs) means making it
     cease to exist.  Any data within it, if not saved in a file, is
     lost.  *Note Exiting::.

Language Environment
     Your choice of language environment specifies defaults for the
     input method (q.v.) and coding system (q.v.).  *Note Language
     Environments::.  These defaults are relevant if you edit non-ASCII
     text (*note International::).

Line Wrapping
     *Note Glossary---Filling::.

Lisp
     Lisp is a programming language.  Most of Emacs is written in a
     dialect of Lisp, called Emacs Lisp, which is extended with special
     features that make it especially suitable for text editing tasks.

List
     A list is, approximately, a text string beginning with an open
     parenthesis and ending with the matching close parenthesis.  In C
     mode and other non-Lisp modes, groupings surrounded by other kinds
     of matched delimiters appropriate to the language, such as braces,
     are also considered lists.  Emacs has special commands for many
     operations on lists.  *Note Moving by Parens::.

Local
     Local means “in effect only in a particular context”; the relevant
     kind of context is a particular function execution, a particular
     buffer, or a particular major mode.  It is the opposite of “global”
     (q.v.).  Specific uses of “local” in Emacs terminology appear
     below.

Local Abbrev
     A local abbrev definition is effective only if a particular major
     mode is selected.  In that major mode, it overrides any global
     definition for the same abbrev.  *Note Abbrevs::.

Local Keymap
     A local keymap is used in a particular major mode; the key bindings
     (q.v.) in the current local keymap override global bindings of the
     same key sequences.  *Note Keymaps::.

Local Variable
     A local value of a variable (q.v.) applies to only one buffer.
     *Note Locals::.

‘M-’
     ‘M-’ in the name of a character is an abbreviation for <Meta>, one
     of the modifier keys that can accompany any character.  *Note M-:
     User Input.

‘M-C-’
     ‘M-C-’ in the name of a character is an abbreviation for
     Control-Meta; it means the same thing as ‘C-M-’ (q.v.).

‘M-x’
     ‘M-x’ is the key sequence that is used to call an Emacs command by
     name.  This is how you run commands that are not bound to key
     sequences.  *Note M-x: M-x.

Mail
     Mail means messages sent from one user to another through the
     computer system, to be read at the recipient’s convenience.  Emacs
     has commands for composing and sending mail, and for reading and
     editing the mail you have received.  *Note Sending Mail::.  *Note
     Rmail::, for one way to read mail with Emacs.

Mail Composition Method
     A mail composition method is a program runnable within Emacs for
     editing and sending a mail message.  Emacs lets you select from
     several alternative mail composition methods.  *Note Mail
     Methods::.

Major Mode
     The Emacs major modes are a mutually exclusive set of options, each
     of which configures Emacs for editing a certain sort of text.
     Ideally, each programming language has its own major mode.  *Note
     Major Modes::.

Margin
     The space between the usable part of a window (including the
     fringe) and the window edge.

Mark
     The mark points to a position in the text.  It specifies one end of
     the region (q.v.), point being the other end.  Many commands
     operate on all the text from point to the mark.  Each buffer has
     its own mark.  *Note Mark::.

Mark Ring
     The mark ring is used to hold several recent previous locations of
     the mark, in case you want to move back to them.  Each buffer has
     its own mark ring; in addition, there is a single global mark ring
     (q.v.).  *Note Mark Ring::.

Menu Bar
     The menu bar is a line at the top of an Emacs frame.  It contains
     words you can click on with the mouse to bring up menus, or you can
     use a keyboard interface to navigate it.  *Note Menu Bars::.

Message
     *Note Glossary---Mail::.

Meta
     Meta is the name of a modifier bit which you can use in a command
     character.  To enter a meta character, you hold down the <Meta> key
     while typing the character.  We refer to such characters with names
     that start with ‘Meta-’ (usually written ‘M-’ for short).  For
     example, ‘M-<’ is typed by holding down <Meta> and at the same time
     typing ‘<’ (which itself is done, on most terminals, by holding
     down <SHIFT> and typing ‘,’).  *Note Meta: User Input.

     On some terminals, the <Meta> key is actually labeled <Alt> or
     <Edit>.

Meta Character
     A Meta character is one whose character code includes the Meta bit.

Minibuffer
     The minibuffer is the window that appears when necessary inside the
     echo area (q.v.), used for reading arguments to commands.  *Note
     Minibuffer::.

Minibuffer History
     The minibuffer history records the text you have specified in the
     past for minibuffer arguments, so you can conveniently use the same
     text again.  *Note Minibuffer History::.

Minor Mode
     A minor mode is an optional feature of Emacs, which can be switched
     on or off independently of all other features.  Each minor mode has
     a command to turn it on or off.  Some minor modes are global
     (q.v.), and some are local (q.v.).  *Note Minor Modes::.

Minor Mode Keymap
     A minor mode keymap is a keymap that belongs to a minor mode and is
     active when that mode is enabled.  Minor mode keymaps take
     precedence over the buffer’s local keymap, just as the local keymap
     takes precedence over the global keymap.  *Note Keymaps::.

Mode Line
     The mode line is the line at the bottom of each window (q.v.),
     giving status information on the buffer displayed in that window.
     *Note Mode Line::.

Modified Buffer
     A buffer (q.v.) is modified if its text has been changed since the
     last time the buffer was saved (or since it was created, if it has
     never been saved).  *Note Saving::.

Moving Text
     Moving text means erasing it from one place and inserting it in
     another.  The usual way to move text is by killing (q.v.) it and
     then yanking (q.v.) it.  *Note Killing::.

MULE
     Prior to Emacs 23, MULE was the name of a software package which
     provided a “MULtilingual Enhancement” to Emacs, by adding support
     for multiple character sets (q.v.).  MULE was later integrated into
     Emacs, and much of it was replaced when Emacs gained internal
     Unicode support in version 23.

     Some parts of Emacs that deal with character set support still use
     the MULE name.  *Note International::.

Multibyte Character
     A multibyte character is a character that takes up several bytes in
     a buffer.  Emacs uses multibyte characters to represent non-ASCII
     text, since the number of non-ASCII characters is much more than
     256.  *Note International Characters: International Chars.

Named Mark
     A named mark is a register (q.v.), in its role of recording a
     location in text so that you can move point to that location.
     *Note Registers::.

Narrowing
     Narrowing means creating a restriction (q.v.) that limits editing
     in the current buffer to only a part of the text.  Text outside
     that part is inaccessible for editing (or viewing) until the
     boundaries are widened again, but it is still there, and saving the
     file saves it all.  *Note Narrowing::.

Newline
     Control-J characters in the buffer terminate lines of text and are
     therefore also called newlines.  *Note Glossary---End Of Line::.

‘nil’
     ‘nil’ is a value usually interpreted as a logical “false”.  Its
     opposite is ‘t’, interpreted as “true”.

Numeric Argument
     A numeric argument is a number, specified before a command, to
     change the effect of the command.  Often the numeric argument
     serves as a repeat count.  *Note Arguments::.

Overwrite Mode
     Overwrite mode is a minor mode.  When it is enabled, ordinary text
     characters replace the existing text after point rather than
     pushing it to one side.  *Note Minor Modes::.

Package
     A package is a collection of Lisp code that you download and
     automatically install from within Emacs.  Packages provide a
     convenient way to add new features.  *Note Packages::.

Page
     A page is a unit of text, delimited by formfeed characters (ASCII
     control-L, code 014) at the beginning of a line.  Some Emacs
     commands are provided for moving over and operating on pages.
     *Note Pages::.

Paragraph
     Paragraphs are the medium-size unit of human-language text.  There
     are special Emacs commands for moving over and operating on
     paragraphs.  *Note Paragraphs::.

Parsing
     We say that certain Emacs commands parse words or expressions in
     the text being edited.  Really, all they know how to do is find the
     other end of a word or expression.

Point
     Point is the place in the buffer at which insertion and deletion
     occur.  Point is considered to be between two characters, not at
     one character.  The terminal’s cursor (q.v.) indicates the location
     of point.  *Note Point::.

Prefix Argument
     *Note Glossary---Numeric Argument::.

Prefix Key
     A prefix key is a key sequence (q.v.) whose sole function is to
     introduce a set of longer key sequences.  ‘C-x’ is an example of
     prefix key; any two-character sequence starting with ‘C-x’ is
     therefore a legitimate key sequence.  *Note Keys::.

Primary Selection
     The primary selection is one particular X selection (q.v.); it is
     the selection that most X applications use for transferring text to
     and from other applications.

     The Emacs commands that mark or select text set the primary
     selection, and clicking the mouse inserts text from the primary
     selection when appropriate.  *Note Shift Selection::.

Prompt
     A prompt is text used to ask you for input.  Displaying a prompt is
     called prompting.  Emacs prompts always appear in the echo area
     (q.v.).  One kind of prompting happens when the minibuffer is used
     to read an argument (*note Minibuffer::); the echoing that happens
     when you pause in the middle of typing a multi-character key
     sequence is also a kind of prompting (*note Echo Area::).

q.v.
     Short for “quod vide” in Latin, which means “which see”.

Query-Replace
     Query-replace is an interactive string replacement feature provided
     by Emacs.  *Note Query Replace::.

Quitting
     Quitting means canceling a partially typed command or a running
     command, using ‘C-g’ (or ‘C-<BREAK>’ on MS-DOS). *Note Quitting::.

Quoting
     Quoting means depriving a character of its usual special
     significance.  The most common kind of quoting in Emacs is with
     ‘C-q’.  What constitutes special significance depends on the
     context and on convention.  For example, an ordinary character as
     an Emacs command inserts itself; so in this context, a special
     character is any character that does not normally insert itself
     (such as <DEL>, for example), and quoting it makes it insert itself
     as if it were not special.  Not all contexts allow quoting.  *Note
     Quoting: Inserting Text.

Quoting File Names
     Quoting a file name turns off the special significance of
     constructs such as ‘$’, ‘~’ and ‘:’.  *Note Quoted File Names::.

Read-Only Buffer
     A read-only buffer is one whose text you are not allowed to change.
     Normally Emacs makes buffers read-only when they contain text which
     has a special significance to Emacs; for example, Dired buffers.
     Visiting a file that is write-protected also makes a read-only
     buffer.  *Note Buffers::.

Rectangle
     A rectangle consists of the text in a given range of columns on a
     given range of lines.  Normally you specify a rectangle by putting
     point at one corner and putting the mark at the diagonally opposite
     corner.  *Note Rectangles::.

Recursive Editing Level
     A recursive editing level is a state in which part of the execution
     of a command involves asking you to edit some text.  This text may
     or may not be the same as the text to which the command was
     applied.  The mode line (q.v.) indicates recursive editing levels
     with square brackets (‘[’ and ‘]’).  *Note Recursive Edit::.

Redisplay
     Redisplay is the process of correcting the image on the screen to
     correspond to changes that have been made in the text being edited.
     *Note Redisplay: Screen.

Regexp
     *Note Glossary---Regular Expression::.

Region
     The region is the text between point (q.v.) and the mark (q.v.).
     Many commands operate on the text of the region.  *Note Region:
     Mark.

Register
     Registers are named slots in which text, buffer positions, or
     rectangles can be saved for later use.  *Note Registers::.  A
     related Emacs feature is bookmarks (q.v.).

Regular Expression
     A regular expression is a pattern that can match various text
     strings; for example, ‘a[0-9]+’ matches ‘a’ followed by one or more
     digits.  *Note Regexps::.

Remote File
     A remote file is a file that is stored on a system other than your
     own.  Emacs can access files on other computers provided that they
     are reachable from your machine over the network, and (obviously)
     that you have a supported method to gain access to those files.
     *Note Remote Files::.

Repeat Count
     *Note Glossary---Numeric Argument::.

Replacement
     *Note Glossary---Global Substitution::.

Restriction
     A buffer’s restriction is the amount of text, at the beginning or
     the end of the buffer, that is temporarily inaccessible.  Giving a
     buffer a nonzero amount of restriction is called narrowing (q.v.);
     removing a restriction is called widening (q.v.).  *Note
     Narrowing::.

<RET>
     <RET> is a character that in Emacs runs the command to insert a
     newline into the text.  It is also used to terminate most arguments
     read in the minibuffer (q.v.).  *Note Return: User Input.

Reverting
     Reverting means returning to the original state.  For example,
     Emacs lets you revert a buffer by re-reading its file from disk.
     *Note Reverting::.

Saving
     Saving a buffer means copying its text into the file that was
     visited (q.v.) in that buffer.  This is the way text in files
     actually gets changed by your Emacs editing.  *Note Saving::.

Scroll Bar
     A scroll bar is a tall thin hollow box that appears at the side of
     a window.  You can use mouse commands in the scroll bar to scroll
     the window.  The scroll bar feature is supported only under
     windowing systems.  *Note Scroll Bars::.

Scrolling
     Scrolling means shifting the text in the Emacs window so as to see
     a different part of the buffer.  *Note Scrolling::.

Searching
     Searching means moving point to the next occurrence of a specified
     string or the next match for a specified regular expression.  *Note
     Search::.

Search Path
     A search path is a list of directories, to be used for searching
     for files for certain purposes.  For example, the variable
     ‘load-path’ holds a search path for finding Lisp library files.
     *Note Lisp Libraries::.

Secondary Selection
     The secondary selection is one particular X selection (q.v.); some
     X applications can use it for transferring text to and from other
     applications.  Emacs has special mouse commands for transferring
     text using the secondary selection.  *Note Secondary Selection::.

Selected Frame
     The selected frame is the one your input currently operates on.
     *Note Frames::.

Selected Window
     The selected window is the one your input currently operates on.
     *Note Basic Window::.

Selecting a Buffer
     Selecting a buffer means making it the current (q.v.) buffer.
     *Note Select Buffer::.

Selection
     Windowing systems allow an application program to specify
     selections whose values are text.  A program can also read the
     selections that other programs have set up.  This is the principal
     way of transferring text between window applications.  Emacs has
     commands to work with the primary (q.v.) selection and the
     secondary (q.v.) selection, and also with the clipboard (q.v.).

Self-Documentation
     Self-documentation is the feature of Emacs that can tell you what
     any command does, or give you a list of all commands related to a
     topic you specify.  You ask for self-documentation with the help
     character, ‘C-h’.  *Note Help::.

Self-Inserting Character
     A character is self-inserting if typing that character inserts that
     character in the buffer.  Ordinary printing and whitespace
     characters are self-inserting in Emacs, except in certain special
     major modes.

Sentences
     Emacs has commands for moving by or killing by sentences.  *Note
     Sentences::.

Server
     Within Emacs, you can start a “server” process, which listens for
     connections from “clients”.  This offers a faster alternative to
     starting several Emacs instances.  *Note Emacs Server::, and *note
     Glossary---Daemon::.

Sexp
     A sexp (short for “s-expression”) is the basic syntactic unit of
     Lisp in its textual form: either a list, or Lisp atom.  Sexps are
     also the balanced expressions (q.v.) of the Lisp language; this is
     why the commands for editing balanced expressions have ‘sexp’ in
     their name.  *Note Sexps: Expressions.

Simultaneous Editing
     Simultaneous editing means two users modifying the same file at
     once.  Simultaneous editing, if not detected, can cause one user to
     lose his or her work.  Emacs detects all cases of simultaneous
     editing, and warns one of the users to investigate.  *Note
     Interlocking: Interlocking.

<SPC>
     <SPC> is the space character, which you enter by pressing the space
     bar.

Speedbar
     The speedbar is a special tall frame that provides fast access to
     Emacs buffers, functions within those buffers, Info nodes, and
     other interesting parts of text within Emacs.  *Note Speedbar::.

Spell Checking
     Spell checking means checking correctness of the written form of
     each one of the words in a text.  Emacs can use various external
     spelling-checker programs to check the spelling of parts of a
     buffer via a convenient user interface.  *Note Spelling::.

String
     A string is a kind of Lisp data object that contains a sequence of
     characters.  Many Emacs variables are intended to have strings as
     values.  The Lisp syntax for a string consists of the characters in
     the string with a ‘"’ before and another ‘"’ after.  A ‘"’ that is
     part of the string must be written as ‘\"’ and a ‘\’ that is part
     of the string must be written as ‘\\’.  All other characters,
     including newline, can be included just by writing them inside the
     string; however, backslash sequences as in C, such as ‘\n’ for
     newline or ‘\241’ using an octal character code, are allowed as
     well.

String Substitution
     *Note Glossary---Global Substitution::.

Syntax Highlighting
     *Note Glossary---Font Lock::.

Syntax Table
     The syntax table tells Emacs which characters are part of a word,
     which characters balance each other like parentheses, etc.  *Note
     Syntax Tables: (elisp)Syntax Tables.

Super
     Super is the name of a modifier bit that a keyboard input character
     may have.  To make a character Super, type it while holding down
     the <SUPER> key.  Such characters are given names that start with
     ‘Super-’ (usually written ‘s-’ for short).  *Note Modifier Keys::.

Suspending
     Suspending Emacs means stopping it temporarily and returning
     control to its parent process, which is usually a shell.  Unlike
     killing a job (q.v.), you can later resume the suspended Emacs job
     without losing your buffers, unsaved edits, undo history, etc.
     *Note Exiting::.

<TAB>
     <TAB> is the tab character.  In Emacs it is typically used for
     indentation or completion.

Tags Table
     A tags table is a file that serves as an index to the function
     definitions in one or more other files.  *Note Tags Tables::.

Termscript File
     A termscript file contains a record of all characters sent by Emacs
     to the terminal.  It is used for tracking down bugs in Emacs
     redisplay.  Emacs does not make a termscript file unless you tell
     it to.  *Note Bugs::.

Text

     “Text” has two meanings (*note Text::):

        • Data consisting of a sequence of characters, as opposed to
          binary numbers, executable programs, and the like.  The basic
          contents of an Emacs buffer (aside from the text properties,
          q.v.) are always text in this sense.

        • Data consisting of written human language (as opposed to
          programs), or following the stylistic conventions of human
          language.

Text Terminal
     A text terminal, or character terminal, is a display that is
     limited to displaying text in character units.  Such a terminal
     cannot control individual pixels it displays.  Emacs supports a
     subset of display features on text terminals.

Text Properties
     Text properties are annotations recorded for particular characters
     in the buffer.  Images in the buffer are recorded as text
     properties; they also specify formatting information.  *Note
     Editing Format Info::.

Theme
     A theme is a set of customizations (q.v.) that give Emacs a
     particular appearance or behavior.  For example, you might use a
     theme for your favorite set of faces (q.v.).

Tool Bar
     The tool bar is a line (sometimes multiple lines) of icons at the
     top of an Emacs frame.  Clicking on one of these icons executes a
     command.  You can think of this as a graphical relative of the menu
     bar (q.v.).  *Note Tool Bars::.

Tooltips
     Tooltips are small windows displaying a help echo (q.v.) text,
     which explains parts of the display, lists useful options available
     via mouse clicks, etc.  *Note Tooltips::.

Top Level
     Top level is the normal state of Emacs, in which you are editing
     the text of the file you have visited.  You are at top level
     whenever you are not in a recursive editing level (q.v.) or the
     minibuffer (q.v.), and not in the middle of a command.  You can get
     back to top level by aborting (q.v.) and quitting (q.v.).  *Note
     Quitting::.

Transient Mark Mode
     The default behavior of the mark (q.v.) and region (q.v.), in which
     setting the mark activates it and highlights the region, is called
     Transient Mark mode.  In GNU Emacs 23 and onwards, it is enabled by
     default.  *Note Disabled Transient Mark::.

Transposition
     Transposing two units of text means putting each one into the place
     formerly occupied by the other.  There are Emacs commands to
     transpose two adjacent characters, words, balanced expressions
     (q.v.) or lines (*note Transpose::).

Trash Can
     *Note Glossary---Deletion of Files::.

Truncation
     Truncating text lines in the display means leaving out any text on
     a line that does not fit within the right margin of the window
     displaying it.  *Note Truncation: Continuation Lines, and *note
     Glossary---Continuation Line::.

TTY
     *Note Glossary---Text Terminal::.

Undoing
     Undoing means making your previous editing go in reverse, bringing
     back the text that existed earlier in the editing session.  *Note
     Undo::.

Unix
     Unix is a class of multi-user computer operating systems with a
     long history.  There are several implementations today.  The GNU
     project (q.v.) aims to develop a complete Unix-like operating
     system that is free software (q.v.).

User Option
     A user option is a face (q.v.) or a variable (q.v.) that exists so
     that you can customize Emacs by setting it to a new value.  *Note
     Easy Customization::.

Variable
     A variable is an object in Lisp that can store an arbitrary value.
     Emacs uses some variables for internal purposes, and has others
     (known as “user options”; q.v.) just so that you can set their
     values to control the behavior of Emacs.  The variables used in
     Emacs that you are likely to be interested in are listed in the
     Variables Index in this manual (*note Variable Index::).  *Note
     Variables::, for information on variables.

Version Control
     Version control systems keep track of multiple versions of a source
     file.  They provide a more powerful alternative to keeping backup
     files (q.v.).  *Note Version Control::.

Visiting
     Visiting a file means loading its contents into a buffer (q.v.)
     where they can be edited.  *Note Visiting::.

Whitespace
     Whitespace is any run of consecutive formatting characters (space,
     tab, newline, backspace, etc.).

Widening
     Widening is removing any restriction (q.v.) on the current buffer;
     it is the opposite of narrowing (q.v.).  *Note Narrowing::.

Window
     Emacs divides a frame (q.v.) into one or more windows, each of
     which can display the contents of one buffer (q.v.) at any time.
     *Note Screen::, for basic information on how Emacs uses the screen.
     *Note Windows::, for commands to control the use of windows.  Some
     other editors use the term “window” for what we call a “frame” in
     Emacs.

Window System
     A window system is software that operates on a graphical display
     (q.v.), to subdivide the screen so that multiple applications can
     have their own windows at the same time.  All modern operating
     systems include a window system.

Word Abbrev
     *Note Glossary---Abbrev::.

Word Search
     Word search is searching for a sequence of words, considering the
     punctuation between them as insignificant.  *Note Word Search::.

Yanking
     Yanking means reinserting text previously killed (q.v.).  It can be
     used to undo a mistaken kill, or for copying or moving text.  Some
     other systems call this “pasting”.  *Note Yanking::.


File: emacs-ja.info,  Node: Acknowledgments,  Next: Key Index,  Prev: Glossary,  Up: Top

Acknowledgments
***************

Many people have contributed code included in the Free Software
Foundation’s distribution of GNU Emacs.  To show our appreciation for
their public spirit, we list here in alphabetical order those who have
written substantial portions.  Others too numerous to mention have
reported and fixed bugs, and added features to many parts of Emacs.  We
thank them for their generosity as well.

   This list is intended to mention every contributor of a major package
or feature we currently distribute; if you know of someone we have
omitted, please make a bug report.  More comprehensive information is
available in the ‘ChangeLog’ files, summarized in the file ‘etc/AUTHORS’
in the distribution.

   • Per Abrahamsen wrote the customization facilities, as well as
     ‘double.el’, for typing accented characters not normally available
     from the keyboard; ‘xt-mouse.el’, which allows mouse commands
     through Xterm; ‘gnus-cus.el’, which implements customization
     commands for Gnus; ‘gnus-cite.el’, a citation-parsing facility for
     news articles; ‘gnus-score.el’, scoring for Gnus; ‘cpp.el’, which
     hides or highlights parts of C programs according to preprocessor
     conditionals; and the widget library files ‘wid-browse.el’,
     ‘wid-edit.el’, ‘widget.el’.  He also co-wrote ‘gnus-soup.el’.

   • Tomas Abrahamsson wrote ‘artist.el’, a package for producing ASCII
     art with a mouse or with keyboard keys.

   • Jay K. Adams wrote ‘jka-compr.el’ and ‘jka-cmpr-hook.el’, providing
     automatic decompression and recompression for compressed files.

   • Michael Albinus wrote ‘dbus.el’, a package that implements the
     D-Bus message bus protocol; ‘zeroconf.el’, a mode for browsing
     Avahi services; ‘secrets.el’, an interface to keyring daemons for
     storing confidential data; and ‘filenotify.el’ and the associated
     low-level interface routines, for watching file status changes.  He
     and Kai Großjohann wrote the Tramp package, which provides
     transparent remote file editing using ssh, ftp, and other network
     protocols.  He and Daniel Pittman wrote ‘tramp-cache.el’.

   • Ralf Angeli wrote ‘scroll-lock.el’, a minor mode which keeps the
     point vertically fixed by scrolling the window when moving up and
     down in the buffer.

   • Aurélien Aptel added dynamic module support to Emacs.  Philipp
     Stephani and others also worked on the dynamic module code.

   • Joe Arceneaux wrote the original text property implementation, and
     implemented support for X11.

   • Emil Åström, Milan Zamaza, and Stefan Bruda wrote ‘prolog.el’, a
     mode for editing Prolog (and Mercury) code.

   • Miles Bader wrote ‘image-file.el’, support code for visiting image
     files; ‘minibuf-eldef.el’, a minor mode that hides the minibuffer
     default value when appropriate; ‘rfn-eshadow.el’, shadowing of
     ‘read-file-name’ input; ‘mb-depth.el’, display of minibuffer depth;
     ‘button.el’, the library that implements clickable buttons;
     ‘face-remap.el’, a package for changing the default face in
     individual buffers; and ‘macroexp.el’ for macro-expansion.  He also
     worked on an early version of the lexical binding code.

   • David Bakhash wrote ‘strokes.el’, a mode for controlling Emacs by
     moving the mouse in particular patterns.

   • Juanma Barranquero wrote ‘emacs-lock.el’ (based on the original
     version by Tom Wurgler), which makes it harder to exit with
     valuable buffers unsaved; and ‘frameset.el’, for saving and
     restoring the frame/window setup.  He also made many other
     contributions to other areas, including MS Windows support.

   • Eli Barzilay wrote ‘calculator.el’, a desktop calculator for Emacs.

   • Steven L. Baur wrote ‘footnote.el’ which lets you include footnotes
     in email messages; and ‘gnus-audio.el’ and ‘earcon.el’, which
     provide sound effects for Gnus.  He also wrote ‘gnus-setup.el’.

   • Alexander L. Belikoff, Sergey Berezin, Sacha Chua, David Edmondson,
     Noah Friedman, Andreas Fuchs, Mario Lang, Ben Mesander, Lawrence
     Mitchell, Gergely Nagy, Michael Olson, Per Persson, Jorgen Schäfer,
     Alex Schroeder, and Tom Tromey wrote ERC, an advanced Internet
     Relay Chat client (for more information, see the file ‘CREDITS’ in
     the ERC distribution).

   • Scott Bender, Michael Brouwer, Christophe de Dinechin, Carl Edman,
     Christian Limpach and Adrian Robert developed and maintained the
     NeXTstep port of Emacs.

   • Stephen Berman wrote ‘todo-mode.el’ (based on the original version
     by Oliver Seidel), a package for maintaining ‘TODO’ list files.

   • Anna M. Bigatti wrote ‘cal-html.el’, which produces HTML calendars.

   • Ray Blaak and Simon South wrote ‘opascal.el’, a mode for editing
     Object Pascal source code.

   • Martin Blais, Stefan Merten, and David Goodger wrote ‘rst.el’, a
     mode for editing reStructuredText documents.

   • Jim Blandy wrote Emacs 19’s input system, brought its configuration
     and build process up to the GNU coding standards, and contributed
     to the frame support and multi-face support.  Jim also wrote
     ‘tvi970.el’, terminal support for the TeleVideo 970 terminals; and
     co-wrote ‘wyse50.el’ (q.v.).

   • Per Bothner wrote ‘term.el’, a terminal emulator in an Emacs
     buffer.

   • Terrence M. Brannon wrote ‘landmark.el’, a neural-network robot
     that learns landmarks.

   • Frank Bresz wrote ‘diff.el’, a program to display ‘diff’ output.

   • Peter Breton implemented ‘dirtrack.el’, a library for tracking
     directory changes in shell buffers; ‘filecache.el’, which records
     which directories your files are in; ‘locate.el’, which interfaces
     to the ‘locate’ command; ‘find-lisp.el’, an Emacs Lisp emulation of
     the ‘find’ program; ‘net-utils.el’; and the generic mode feature.

   • Emmanuel Briot wrote ‘xml.el’, an XML parser for Emacs; and
     ‘ada-prj.el’, editing of Ada mode project files, as well as
     co-authoring ‘ada-mode.el’ and ‘ada-xref.el’.

   • Kevin Broadey wrote ‘foldout.el’, providing folding extensions to
     Emacs’s outline modes.

   • David M. Brown wrote ‘array.el’, for editing arrays and other
     tabular data.

   • Włodek Bzyl and Ryszard Kubiak wrote ‘ogonek.el’, a package for
     changing the encoding of Polish characters.

   • Bill Carpenter provided ‘feedmail.el’, a package for massaging
     outgoing mail messages and sending them through various popular
     mailers.

   • Per Cederqvist and Inge Wallin wrote ‘ewoc.el’, an Emacs widget for
     manipulating object collections.  Per Cederqvist, Inge Wallin, and
     Thomas Bellman wrote ‘avl-tree.el’, for balanced binary trees.

   • Hans Chalupsky wrote ‘advice.el’, an overloading mechanism for
     Emacs Lisp functions; and ‘trace.el’, a tracing facility for Emacs
     Lisp.

   • Chris Chase, Carsten Dominik, and J. D. Smith wrote IDLWAVE mode,
     for editing IDL and WAVE CL.

   • Bob Chassell wrote ‘texnfo-upd.el’, ‘texinfo.el’, and
     ‘makeinfo.el’, modes and utilities for working with Texinfo files;
     and ‘page-ext.el’, commands for extended page handling.  He also
     wrote the Emacs Lisp introduction.  *Note (eintr)Top::.

   • Jihyun Cho wrote ‘hanja-util.el’ and ‘hangul.el’, utilities for
     Korean Hanja.

   • Andrew Choi and Yamamoto Mitsuharu wrote the Carbon support, used
     prior to Emacs 23 for macOS.  Yamamoto Mitsuharu continued to
     contribute to macOS support in the newer Nextstep port; and also
     improved support for multi-monitor displays.

   • Chong Yidong was the Emacs co-maintainer from Emacs 23 to 24.3.  He
     made many improvements to the Emacs display engine.  He also wrote
     ‘tabulated-list.el’, a generic major mode for lists of data; and
     improved support for themes and packages.

   • James Clark wrote SGML mode, a mode for editing SGML documents; and
     nXML mode, a mode for editing XML documents.  He also contributed
     to Emacs’s dumping procedures.

   • Mike Clarkson wrote ‘edt.el’, an emulation of DEC’s EDT editor.

   • Glynn Clements provided ‘gamegrid.el’ and a couple of games that
     use it, Snake and Tetris.

   • Andrew Cohen wrote ‘spam-wash.el’, to decode and clean email before
     it is analyzed for spam.

   • Theresa O’Connor wrote ‘json.el’, a file for parsing and generating
     JSON files.

   • Georges Brun-Cottan and Stefan Monnier wrote ‘easy-mmode.el’, a
     package for easy definition of major and minor modes.

   • Andrew Csillag wrote M4 mode (‘m4-mode.el’).

   • Doug Cutting and Jamie Zawinski wrote ‘disass.el’, a disassembler
     for compiled Emacs Lisp code.

   • Mathias Dahl wrote ‘image-dired.el’, a package for viewing image
     files as thumbnails.

   • Julien Danjou wrote an implementation of desktop notifications
     (‘notifications.el’, and related packages for ERC and Gnus); and
     ‘color.el’, a library for general color manipulation.  He also made
     various contributions to Gnus.

   • Vivek Dasmohapatra wrote ‘htmlfontify.el’, to convert a buffer or
     source tree to HTML.

   • Matthieu Devin wrote ‘delsel.el’, a package to make newly-typed
     text replace the current selection.

   • Eric Ding wrote ‘goto-addr.el’,

   • Jan Djärv added support for the GTK+ toolkit and X drag-and-drop.
     He also wrote ‘dynamic-setting.el’.

   • Carsten Dominik wrote RefTeX, a package for setting up labels and
     cross-references in LaTeX documents; and co-wrote IDLWAVE mode
     (q.v.).  He was the original author of Org mode, for maintaining
     notes, todo lists, and project planning.  Bastien Guerry
     subsequently took over maintainership.  Benjamin Andresen, Thomas
     Baumann, Joel Boehland, Jan Böcker, Lennart Borgman, Baoqiu Cui,
     Dan Davison, Christian Egli, Eric S. Fraga, Daniel German, Chris
     Gray, Konrad Hinsen, Tassilo Horn, Philip Jackson, Martyn Jago,
     Thorsten Jolitz, Jambunathan K, Tokuya Kameshima, Sergey Litvinov,
     David Maus, Ross Patterson, Juan Pechiar, Sebastian Rose, Eric
     Schulte, Paul Sexton, Ulf Stegemann, Andy Stewart, Christopher
     Suckling, David O’Toole, John Wiegley, Zhang Weize, Piotr
     Zieliński, and others also wrote various Org mode components.  For
     more information, *note (org)History and acknowledgments::.

   • Scott Draves wrote ‘tq.el’, help functions for maintaining
     transaction queues between Emacs and its subprocesses.

   • Benjamin Drieu wrote ‘pong.el’, an implementation of the classical
     pong game.

   • Viktor Dukhovni wrote support for dumping under SunOS version 4.

   • John Eaton and Kurt Hornik wrote Octave mode.

   • Rolf Ebert, Markus Heritsch, and Emmanuel Briot wrote Ada mode.

   • Paul Eggert integrated the Gnulib portability library, and made
     many other portability fixes to the C code; as well as his
     contributions to VC and the calendar.

   • Stephen Eglen wrote ‘mspools.el’, which tells you which Procmail
     folders have mail waiting in them.

   • Torbjörn Einarsson wrote ‘f90.el’, a mode for Fortran 90 files.

   • Tsugutomo Enami co-wrote the support for international character
     sets.

   • David Engster wrote ‘mairix.el’ and ‘nnmairix.el’, an interface to
     the Mairix indexing tool.

   • Hans Henrik Eriksen wrote ‘simula.el’, a mode for editing SIMULA 87
     code.

   • Michael Ernst wrote ‘reposition.el’, a command for recentering a
     function’s source code and preceding comment on the screen.

   • Ata Etemadi wrote ‘cdl.el’, functions for working with Common Data
     Language source code.

   • Frederick Farnbach implemented ‘morse.el’, which converts text to
     Morse code.

   • Oscar Figueiredo wrote EUDC, the Emacs Unified Directory Client,
     which is an interface to directory servers via LDAP, CCSO PH/QI, or
     BBDB; and ‘ldap.el’, the LDAP client interface.

   • Fred Fish wrote the support for dumping COFF executable files.

   • Karl Fogel wrote ‘bookmark.el’, which implements named
     placeholders; ‘mail-hist.el’, a history mechanism for outgoing mail
     messages; and ‘saveplace.el’, for preserving point’s location in
     files between editing sessions.

   • Gary Foster wrote ‘scroll-all.el’, a mode for scrolling several
     buffers together.

   • Romain Francoise contributed ACL (Access Control List) support, for
     preserving extended file attributes on backup and copy.

   • Noah Friedman wrote ‘rlogin.el’, an interface to Rlogin,
     ‘type-break.el’, which reminds you to take periodic breaks from
     typing, and ‘eldoc-mode’, a mode to show the defined parameters or
     the doc string for the Lisp function near point.

   • Shigeru Fukaya wrote a testsuite for the byte-compiler.

   • Keith Gabryelski wrote ‘hexl.el’, a mode for editing binary files.

   • Kevin Gallagher rewrote and enhanced the EDT emulation, and wrote
     ‘flow-ctrl.el’, a package for coping with unsuppressible XON/XOFF
     flow control.

   • Fabián E. Gallina rewrote ‘python.el’, the major mode for the
     Python programming language used in Emacs 24.3 onwards.

   • Kevin Gallo added multiple-frame support for Windows NT and wrote
     ‘w32-win.el’, support functions for the MS-Windows window system.

   • Juan León Lahoz García wrote ‘wdired.el’, a package for performing
     file operations by directly editing Dired buffers.

   • Howard Gayle wrote much of the C and Lisp code for display tables
     and case tables.  He also wrote ‘rot13.el’, a command to display
     the plain-text form of a buffer encoded with the Caesar cipher;
     ‘vt100-led.el’, a package for controlling the LEDs on
     VT100-compatible terminals; and much of the support for ISO-8859
     European character sets (which includes ‘iso-ascii.el’,
     ‘iso-insert.el’, ‘iso-swed.el’, ‘iso-syntax.el’, ‘iso-transl.el’,
     and ‘swedish.el’).

   • Stephen Gildea made the Emacs quick reference card, and made many
     contributions for ‘time-stamp.el’, a package for maintaining
     last-change time stamps in files.

   • Julien Gilles wrote ‘gnus-ml.el’, a mailing list minor mode for
     Gnus.

   • David Gillespie wrote the Common Lisp compatibility packages;
     ‘Calc’, an advanced calculator and mathematical tool, since
     maintained and developed by Jay Belanger; ‘complete.el’, a partial
     completion mechanism; and ‘edmacro.el’, a package for editing
     keyboard macros.

   • Bob Glickstein wrote ‘sregex.el’, a facility for writing regexps
     using a Lisp-like syntax.

   • Boris Goldowsky wrote ‘avoid.el’, a package to keep the mouse
     cursor out of the way of the text cursor; ‘shadowfile.el’, a
     package for keeping identical copies of files in more than one
     place; ‘format.el’, a package for reading and writing files in
     various formats; ‘enriched.el’, a package for saving text
     properties in files; ‘facemenu.el’, a package for specifying faces;
     and ‘descr-text.el’, describing text and character properties.

   • Michelangelo Grigni wrote ‘ffap.el’ which visits a file, taking the
     file name from the buffer.

   • Odd Gripenstam wrote ‘dcl-mode.el’ for editing DCL command files.

   • Michael Gschwind wrote ‘iso-cvt.el’, a package to convert between
     the ISO 8859-1 character set and the notations for non-ASCII
     characters used by TeX and net tradition.

   • Bastien Guerry wrote ‘gnus-bookmark.el’, bookmark support for Gnus;
     as well as helping to maintain Org mode (q.v.).

   • Henry Guillaume wrote ‘find-file.el’, a package to visit files
     related to the currently visited file.

   • Doug Gwyn wrote the portable ‘alloca’ implementation.

   • Ken’ichi Handa implemented most of the support for international
     character sets, and wrote most of the Emacs 23 font handling code.
     He also wrote ‘composite.el’, which provides a minor mode that
     composes characters automatically when they are displayed;
     ‘isearch-x.el’, a facility for searching non-ASCII text; and
     ‘ps-bdf.el’, a BDF font support for printing non-ASCII text on a
     PostScript printer.  Together with Naoto Takahashi, he wrote
     ‘quail.el’, an input facility for typing non-ASCII text from an
     ASCII keyboard.

   • Jesper Harder wrote ‘yenc.el’, for decoding yenc encoded messages.

   • Alexandru Harsanyi wrote a library for accessing SOAP web services.

   • K. Shane Hartman wrote ‘chistory.el’ and ‘echistory.el’, packages
     for browsing command history lists; ‘electric.el’ and ‘helper.el’,
     which provide an alternative command loop and appropriate help
     facilities; ‘emacsbug.el’, a package for reporting Emacs bugs;
     ‘picture.el’, a mode for editing ASCII pictures; and ‘view.el’, a
     package for perusing files and buffers without editing them.

   • John Heidemann wrote ‘mouse-copy.el’ and ‘mouse-drag.el’, which
     provide alternative mouse-based editing and scrolling features.

   • Jon K Hellan wrote ‘utf7.el’, support for mail-safe transformation
     format of Unicode.

   • Karl Heuer wrote the original blessmail script, implemented the
     ‘intangible’ text property, and rearranged the structure of the
     ‘Lisp_Object’ type to allow for more data bits.

   • Manabu Higashida ported Emacs to MS-DOS.

   • Anders Holst wrote ‘hippie-exp.el’, a versatile completion and
     expansion package.

   • Tassilo Horn wrote DocView mode, allowing viewing of PDF,
     PostScript and DVI documents.

   • Tom Houlder wrote ‘mantemp.el’, which generates manual C++ template
     instantiations.

   • Joakim Hove wrote ‘html2text.el’, a html to plain text converter.

   • Denis Howe wrote ‘browse-url.el’, a package for invoking a WWW
     browser to display a URL.

   • Lars Magne Ingebrigtsen did a major redesign of the Gnus
     news-reader and wrote many of its parts.  Several of these are now
     general components of Emacs, including: ‘dns.el’ for Domain Name
     Service lookups; ‘format-spec.el’ for formatting arbitrary format
     strings; ‘netrc.el’ for parsing of ‘.netrc’ files; and
     ‘time-date.el’ for general date and time handling.  He also wrote
     ‘network-stream.el’, for opening network processes; ‘url-queue.el’,
     for controlling parallel downloads of URLs; and implemented libxml2
     support.  He also wrote ‘eww.el’, an Emacs Lisp web browser; and
     implemented native zlib decompression.  Components of Gnus have
     also been written by: Nagy Andras, David Blacka, Scott Byer,
     Ludovic Courtès, Julien Danjou, Kevin Greiner, Kai Großjohann, Joe
     Hildebrand, Paul Jarc, Simon Josefsson, Sascha Lüdecke, David
     Moore, Jim Radford, Benjamin Rutt, Raymond Scholz, Thomas Steffen,
     Reiner Steib, Jan Tatarik, Didier Verna, Ilja Weis, Katsumi
     Yamaoka, Teodor Zlatanov, and others (*note (gnus)Contributors::).

   • Andrew Innes contributed extensively to the MS-Windows support.

   • Seiichiro Inoue improved Emacs’s XIM support.

   • Philip Jackson wrote ‘find-cmd.el’, to build a ‘find’ command-line.

   • Ulf Jasper wrote ‘icalendar.el’, a package for converting Emacs
     diary entries to and from the iCalendar format; ‘newsticker.el’, an
     RSS and Atom based Newsticker; and ‘bubbles.el’, a puzzle game.

   • Kyle Jones wrote ‘life.el’, a package to play Conway’s Game of
     Life.

   • Terry Jones wrote ‘shadow.el’, a package for finding potential
     load-path problems when some Lisp file shadows another.

   • Simon Josefsson wrote ‘dns-mode.el’, an editing mode for Domain
     Name System master files; ‘dig.el’, a Domain Name System interface;
     ‘flow-fill.el’, a package for interpreting RFC2646 formatted text
     in messages; ‘fringe.el’, a package for customizing the fringe;
     ‘imap.el’, an Emacs Lisp library for talking to IMAP servers;
     ‘password-cache.el’, a password reader; ‘nnimap.el’, the IMAP
     back-end for Gnus; ‘url-imap.el’ for the URL library; ‘rfc2104.el’,
     a hashed message authentication facility; the Gnus S/MIME and Sieve
     components; and ‘tls.el’ and ‘starttls.el’ for the Transport Layer
     Security protocol.

   • Arne Jørgensen wrote ‘latexenc.el’, a package to automatically
     guess the correct coding system in LaTeX files.

   • Alexandre Julliard wrote ‘vc-git.el’, support for the Git version
     control system.

   • Tomoji Kagatani implemented ‘smtpmail.el’, used for sending out
     mail with SMTP.

   • Ivan Kanis wrote ‘vc-hg.el’, support for the Mercurial version
     control system.

   • Henry Kautz wrote ‘bib-mode.el’, a mode for maintaining
     bibliography databases compatible with ‘refer’ (the ‘troff’
     version) and ‘lookbib’, and ‘refbib.el’, a package to convert those
     databases to the format used by the LaTeX text formatting package.

   • Taichi Kawabata added support for Devanagari script and the Indian
     languages, and wrote ‘ucs-normalize.el’ for Unicode normalization.

   • Taro Kawagishi implemented the MD4 Message Digest Algorithm in
     Lisp; and wrote ‘ntlm.el’ and ‘sasl-ntlm.el’ for NT LanManager
     authentication support.

   • Howard Kaye wrote ‘sort.el’, commands to sort text in Emacs
     buffers.

   • Michael Kifer wrote ‘ediff’, an interactive interface to the
     ‘diff’, ‘patch’, and ‘merge’ programs; and Viper, an emulator of
     the VI editor.

   • Richard King wrote the first version of ‘userlock.el’ and
     ‘filelock.c’, which provide simple support for multiple users
     editing the same file.  He also wrote the initial version of
     ‘uniquify.el’, a facility to make buffer names unique by adding
     parts of the file’s name to the buffer name.

   • Peter Kleiweg wrote ‘ps-mode.el’, a mode for editing PostScript
     files and running a PostScript interpreter interactively from
     within Emacs.

   • Karel Klíč contributed SELinux support, for preserving the
     Security-Enhanced Linux context of files on backup and copy.

   • Shuhei Kobayashi wrote ‘hex-util.el’, for operating on hexadecimal
     strings; and support for HMAC (Keyed-Hashing for Message
     Authentication).

   • Pavel Kobyakov wrote ‘flymake.el’, a minor mode for performing
     on-the-fly syntax checking.

   • David M. Koppelman wrote ‘hi-lock.el’, a minor mode for interactive
     automatic highlighting of parts of the buffer text.

   • Koseki Yoshinori wrote ‘iimage.el’, a minor mode for displaying
     inline images.

   • Robert Krawitz wrote the original ‘xmenu.c’, part of Emacs’s pop-up
     menu support.

   • Sebastian Kremer wrote ‘dired-mode’, with contributions by Lawrence
     R. Dodd.  He also wrote ‘ls-lisp.el’, a Lisp emulation of the ‘ls’
     command for platforms that don’t have ‘ls’ as a standard program.

   • David Kågedal wrote ‘tempo.el’, providing support for easy
     insertion of boilerplate text and other common constructions.

   • Igor Kuzmin wrote ‘cconv.el’, providing closure conversion for
     statically scoped Emacs lisp.

   • Daniel LaLiberte wrote ‘edebug.el’, a source-level debugger for
     Emacs Lisp; ‘cl-specs.el’, specifications to help ‘edebug’ debug
     code written using David Gillespie’s Common Lisp support; and
     ‘isearch.el’, Emacs’s incremental search minor mode.  He also
     co-wrote ‘hideif.el’ (q.v.).

   • Karl Landstrom and Daniel Colascione wrote ‘js.el’, a mode for
     editing JavaScript.

   • Vinicius Jose Latorre wrote the Emacs printing facilities, as well
     as ‘ps-print’ (with Jim Thompson, Jacques Duthen, and Kenichi
     Handa), a package for pretty-printing Emacs buffers to PostScript
     printers; ‘delim-col.el’, a package to arrange text into columns;
     ‘ebnf2ps.el’, a package that translates EBNF grammar to a syntactic
     chart that can be printed to a PostScript printer; and
     ‘whitespace.el’, a package that detects and cleans up excess
     whitespace in a file (building on an earlier version by Rajesh
     Vaidheeswarran).

   • Frederic Lepied wrote ‘expand.el’, which uses the abbrev mechanism
     for inserting programming constructs.

   • Peter Liljenberg wrote ‘elint.el’, a Lint-style code checker for
     Emacs Lisp programs.

   • Lars Lindberg wrote ‘msb.el’, which provides more flexible menus
     for buffer selection; co-wrote ‘imenu.el’ (q.v.); and rewrote
     ‘dabbrev.el’, originally written by Don Morrison.

   • Anders Lindgren wrote ‘autorevert.el’, a package for automatically
     reverting files visited by Emacs that were changed on disk;
     ‘cwarn.el’, a package to highlight suspicious C and C++ constructs;
     and ‘follow.el’, a minor mode to synchronize windows that show the
     same buffer.

   • Thomas Link wrote ‘filesets.el’, a package for handling sets of
     files.

   • Juri Linkov wrote ‘misearch.el’, extending isearch to multi-buffer
     searches; the code in ‘files-x.el’ for handling file- and
     directory-local variables; and the ‘info-finder’ feature that
     creates a virtual Info manual of package keywords.

   • Leo Liu wrote ‘pcmpl-x.el’, providing completion for miscellaneous
     external tools; and revamped support for Octave in Emacs 24.4.

   • Károly Lőrentey wrote the multi-terminal code, which allows Emacs
     to run on graphical and text terminals simultaneously.

   • Martin Lorentzon wrote ‘vc-annotate.el’, support for version
     control annotation.

   • Dave Love wrote much of the code dealing with Unicode support and
     Latin-N unification.  He added support for many coding systems,
     including the various UTF-7 and UTF-16 coding systems.  He also
     wrote ‘autoarg-mode’, a global minor mode whereby digit keys supply
     prefix arguments; ‘autoarg-kp-mode’, which redefines the keypad
     numeric keys to digit arguments; ‘autoconf.el’, a mode for editing
     Autoconf files; ‘cfengine.el’, a mode for editing Cfengine files;
     ‘elide-head.el’, a package for eliding boilerplate text from file
     headers; ‘hl-line.el’, a minor mode for highlighting the line in
     the current window on which point is; ‘cap-words.el’, a minor mode
     for motion in ‘CapitalizedWordIdentifiers’; ‘latin1-disp.el’, a
     package that lets you display ISO 8859 characters on Latin-1
     terminals by setting up appropriate display tables; the version of
     ‘python.el’ used prior to Emacs 24.3; ‘smiley.el’, a facility for
     displaying smiley faces; ‘sym-comp.el’, a library for performing
     mode-dependent symbol completion; ‘benchmark.el’ for timing code
     execution; and ‘tool-bar.el’, a mode to control the display of the
     Emacs tool bar.  With Riccardo Murri he wrote ‘vc-bzr.el’, support
     for the Bazaar version control system.

   • Eric Ludlam wrote the Speedbar package; ‘checkdoc.el’, for checking
     doc strings in Emacs Lisp programs; ‘dframe.el’, providing
     dedicated frame support modes; ‘ezimage.el’, a generalized way to
     place images over text; ‘chart.el’ for drawing bar charts etc.; and
     the EIEIO (Enhanced Implementation of Emacs Interpreted Objects)
     package.  He was also the main author of the CEDET (Collection of
     Emacs Development Environment Tools) package.  Portions were also
     written by Jan Moringen, David Ponce, and Joakim Verona.

   • Roland McGrath wrote ‘compile.el’ (since updated by Daniel
     Pfeiffer), a package for running compilations in a buffer, and then
     visiting the locations reported in error messages; ‘etags.el’, a
     package for jumping to function definitions and searching or
     replacing in all the files mentioned in a ‘TAGS’ file; with
     Sebastian Kremer ‘find-dired.el’, for using ‘dired’ commands on
     output from the ‘find’ program; ‘grep.el’ for running the ‘grep’
     command; ‘map-ynp.el’, a general purpose boolean question-asker;
     ‘autoload.el’, providing semi-automatic maintenance of autoload
     files.

   • Alan Mackenzie wrote the integrated AWK support in CC Mode, and
     maintained CC Mode from Emacs 22 onwards.

   • Michael McNamara and Wilson Snyder wrote Verilog mode.

   • Christopher J. Madsen wrote ‘decipher.el’, a package for cracking
     simple substitution ciphers.

   • Neil M. Mager wrote ‘appt.el’, functions to notify users of their
     appointments.  It finds appointments recorded in the diary files
     used by the ‘calendar’ package.

   • Ken Manheimer wrote ‘allout.el’, a mode for manipulating and
     formatting outlines, and ‘icomplete.el’, which provides incremental
     completion feedback in the minibuffer.

   • Bill Mann wrote ‘perl-mode.el’, a mode for editing Perl code.

   • Brian Marick and Daniel LaLiberte wrote ‘hideif.el’, support for
     hiding selected code within C ‘#ifdef’ clauses.

   • Simon Marshall wrote ‘regexp-opt.el’, which generates a regular
     expression from a list of strings; and the fast-lock and lazy-lock
     font-lock support modes.  He also extended ‘comint.el’ and
     ‘shell.el’, originally written by Olin Shivers.

   • Bengt Martensson, Dirk Herrmann, Marc Shapiro, Mike Newton, Aaron
     Larson, and Stefan Schoef, wrote ‘bibtex.el’, a mode for editing
     BibTeX bibliography files.

   • Charlie Martin wrote ‘autoinsert.el’, which provides automatic
     mode-sensitive insertion of text into new files.

   • Yukihiro Matsumoto and Nobuyoshi Nakada wrote Ruby-mode.

   • Tomohiro Matsuyama wrote the native Elisp profiler.

   • Thomas May wrote ‘blackbox.el’, a version of the traditional
     blackbox game.

   • David Megginson wrote ‘derived.el’, which allows one to define new
     major modes by inheriting key bindings and commands from existing
     major modes.

   • Will Mengarini wrote ‘repeat.el’, a command to repeat the preceding
     command with its arguments.

   • Richard Mlynarik wrote ‘cl-indent.el’, a package for indenting
     Common Lisp code; ‘ebuff-menu.el’, an electric browser for buffer
     listings; ‘ehelp.el’, bindings for browsing help screens; and
     ‘rfc822.el’, a parser for E-mail addresses in the RFC-822 format,
     used in mail messages and news articles.

   • Gerd Möllmann was the Emacs maintainer from the beginning of Emacs
     21 development until the release of 21.1.  He wrote the new display
     engine used from Emacs 21 onwards, and the asynchronous timers
     facility.  He also wrote ‘ebrowse’, the C++ browser; ‘jit-lock.el’,
     the Just-In-Time font-lock support mode; ‘tooltip.el’, a package
     for displaying tooltips; ‘authors.el’, a package for maintaining
     the ‘AUTHORS’ file; and ‘rx.el’, a regular expression constructor.

   • Stefan Monnier was the Emacs (co-)maintainer from Emacs 23 until
     late in the development of 25.1.  He added support for Arch and
     Subversion to VC, re-wrote much of the Emacs server to use the
     built-in networking primitives, and re-wrote the abbrev and
     minibuffer completion code for Emacs 23.  He also wrote ‘PCL-CVS’,
     a directory-level front end to the CVS version control system;
     ‘reveal.el’, a minor mode for automatically revealing invisible
     text; ‘smerge-mode.el’, a minor mode for resolving ‘diff3’
     conflicts; ‘diff-mode.el’, a mode for viewing and editing context
     diffs; ‘css-mode.el’ for Cascading Style Sheets; ‘bibtex-style.el’
     for BibTeX Style files; ‘mpc.el’, a client for the Music Player
     Daemon (MPD); ‘smie.el’, a generic indentation engine; and
     ‘pcase.el’, implementing ML-style pattern matching.  In Emacs 24,
     he integrated the lexical binding code, cleaned up the CL namespace
     (making it acceptable to use CL functions at runtime), added
     generalized variables to core Emacs Lisp, and implemented a new
     lightweight advice mechanism.

   • Morioka Tomohiko wrote several packages for MIME support in Gnus
     and elsewhere.

   • Sen Nagata wrote ‘crm.el’, a package for reading multiple strings
     with completion, and ‘rfc2368.el’, support for ‘mailto:’ URLs.

   • Erik Naggum wrote the time-conversion functions.  He also wrote
     ‘disp-table.el’, for dealing with display tables; ‘mailheader.el’,
     for parsing email headers; and ‘parse-time.el’, for parsing time
     strings.

   • Takahashi Naoto co-wrote ‘quail.el’ (q.v.), and wrote ‘robin.el’,
     another input method.

   • Thomas Neumann and Eric Raymond wrote ‘make-mode.el’, a mode for
     editing makefiles.

   • Thien-Thi Nguyen and Dan Nicolaescu wrote ‘hideshow.el’, a minor
     mode for selectively displaying blocks of text.

   • Dan Nicolaescu added support for running Emacs as a daemon.  He
     also wrote ‘romanian.el’, support for editing Romanian text;
     ‘iris-ansi.el’, support for running Emacs on SGI’s ‘xwsh’ and
     ‘winterm’ terminal emulators; and ‘vc-dir.el’, displaying the
     status of version-controlled directories.

   • Hrvoje Nikšić wrote ‘savehist.el’, for saving the minibuffer
     history between Emacs sessions.

   • Jeff Norden wrote ‘kermit.el’, a package to help the Kermit dialup
     communications program run comfortably in an Emacs shell buffer.

   • Andrew Norman wrote ‘ange-ftp.el’, providing transparent FTP
     support.

   • Kentaro Ohkouchi created the Emacs icons used beginning with Emacs
     23.

   • Christian Ohler wrote ‘ert.el’, a library for automated regression
     testing.

   • Alexandre Oliva wrote ‘gnus-mlspl.el’, a group params-based mail
     splitting mechanism.

   • Takaaki Ota wrote ‘table.el’, a package for creating and editing
     embedded text-based tables.

   • Pieter E. J. Pareit wrote ‘mixal-mode.el’, an editing mode for the
     MIX assembly language.

   • David Pearson wrote ‘quickurl.el’, a simple method of inserting a
     URL into the current buffer based on text at point; ‘5x5.el’, a
     game to fill all squares on the field.

   • Jeff Peck wrote ‘sun.el’, key bindings for sunterm keys.

   • Damon Anton Permezel wrote ‘hanoi.el’, an animated demonstration of
     the Towers of Hanoi puzzle.

   • William M. Perry wrote ‘mailcap.el’ (with Lars Magne Ingebrigtsen),
     a MIME media types configuration facility; ‘mwheel.el’, a package
     for supporting mouse wheels; co-wrote (with Dave Love) ‘socks.el’,
     a Socks v5 client; and developed the URL package.

   • Per Persson wrote ‘gnus-vm.el’, the VM interface for Gnus.

   • Jens Petersen wrote ‘find-func.el’, which makes it easy to find the
     source code for an Emacs Lisp function or variable.

   • Nicolas Petton wrote ‘map.el’, a library providing map-manipulation
     functions that work on alists, hash-table and arrays; ‘seq.el’, a
     library providing advanced sequence manipulation functions and
     macros; and ‘thunk.el’, a library providing functions and macros to
     delay the evaluation of forms.  He also created the new icon in
     Emacs 25.

   • Daniel Pfeiffer wrote ‘conf-mode.el’, a mode for editing
     configuration files; ‘copyright.el’, a package for updating
     copyright notices in files; ‘executable.el’, a package for
     executing interpreter scripts; ‘sh-script.el’, a mode for editing
     shell scripts; ‘skeleton.el’, implementing a concise language for
     writing statement skeletons; and ‘two-column.el’, a minor mode for
     simultaneous two-column editing.

     Daniel also rewrote ‘apropos.el’ (originally written by Joe Wells),
     for finding commands, functions, and variables matching a regular
     expression; and, together with Jim Blandy, co-authored ‘wyse50.el’,
     support for Wyse 50 terminals.  He also co-wrote ‘compile.el’
     (q.v.) and ‘ada-stmt.el’.

   • Richard L. Pieri wrote ‘pop3.el’, a Post Office Protocol (RFC 1460)
     interface for Emacs.

   • Fred Pierresteguy and Paul Reilly made Emacs work with X Toolkit
     widgets.

   • François Pinard, Greg McGary, and Bruno Haible wrote ‘po.el’,
     support for PO translation files.

   • Christian Plaunt wrote ‘soundex.el’, an implementation of the
     Soundex algorithm for comparing English words by their
     pronunciation.

   • David Ponce wrote ‘recentf.el’, a package that puts a menu of
     recently visited files in the Emacs menu bar; ‘ruler-mode.el’, a
     minor mode for displaying a ruler in the header line; and
     ‘tree-widget.el’, a package to display hierarchical data
     structures.

   • Francesco A. Potortì wrote ‘cmacexp.el’, providing a command which
     runs the C preprocessor on a region of a file and displays the
     results.  He also expanded and redesigned the ‘etags’ program.

   • Michael D. Prange and Steven A. Wood wrote ‘fortran.el’, a mode for
     editing Fortran code.

   • Ashwin Ram wrote ‘refer.el’, commands to look up references in
     bibliography files by keyword.

   • Eric S. Raymond wrote ‘vc.el’, an interface to the RCS and SCCS
     source code version control systems, with Paul Eggert; ‘gud.el’, a
     package for running source-level debuggers like GDB and SDB in
     Emacs; ‘asm-mode.el’, a mode for editing assembly language code;
     ‘AT386.el’, terminal support package for IBM’s AT keyboards;
     ‘cookie1.el’, support for fortune-cookie programs like ‘yow.el’ and
     ‘spook.el’; ‘finder.el’, a package for finding Emacs Lisp packages
     by keyword and topic; ‘keyswap.el’, code to swap the <BS> and <DEL>
     keys; ‘loadhist.el’, functions for loading and unloading Emacs
     features; ‘lisp-mnt.el’, functions for working with the special
     headers used in Emacs Lisp library files; and code to set and make
     use of the ‘load-history’ lisp variable, which records the source
     file from which each lisp function loaded into Emacs came.

   • Edward M. Reingold wrote the calendar and diary support, with
     contributions from Stewart Clamen (‘cal-mayan.el’), Nachum
     Dershowitz (‘cal-hebrew.el’), Paul Eggert (‘cal-dst.el’), Steve
     Fisk (‘cal-tex.el’), Michael Kifer (‘cal-x.el’), Lara Rios
     (‘cal-menu.el’), and Denis B. Roegel (‘solar.el’).  Andy Oram
     contributed to its documentation.  Reingold also contributed to
     ‘tex-mode.el’, a mode for editing TeX files, as did William F.
     Schelter, Dick King, Stephen Gildea, Michael Prange, and Jacob
     Gore.

   • David Reitter wrote ‘mailclient.el’ which can send mail via the
     system’s designated mail client.

   • Alex Rezinsky wrote ‘which-func.el’, a mode that shows the name of
     the current function in the mode line.

   • Rob Riepel wrote ‘vt-control.el’, providing some control functions
     for the DEC VT line of terminals.

   • Nick Roberts wrote ‘t-mouse.el’, for mouse support in text
     terminals; and ‘gdb-ui.el’, a graphical user interface to GDB.
     Together with Dmitry Dzhus, he wrote ‘gdb-mi.el’, the successor to
     ‘gdb-ui.el’.

   • Danny Roozendaal implemented ‘handwrite.el’, which converts text
     into “handwriting”.

   • Markus Rost wrote ‘cus-test.el’, a testing framework for customize.

   • Guillermo J. Rozas wrote ‘scheme.el’, a mode for editing Scheme and
     DSSSL code.

   • Martin Rudalics implemented improved display-buffer handling in
     Emacs 24; and implemented pixel-wise resizing of windows and
     frames.

   • Ivar Rummelhoff wrote ‘winner.el’, which records recent window
     configurations so you can move back to them.

   • Jason Rumney ported the Emacs 21 display engine to MS-Windows, and
     has contributed extensively to the MS-Windows port of Emacs.

   • Wolfgang Rupprecht wrote Emacs 19’s floating-point support
     (including ‘float-sup.el’ and ‘floatfns.c’).

   • Kevin Ryde wrote ‘info-xref.el’, a library for checking references
     in Info files.

   • James B. Salem and Brewster Kahle wrote ‘completion.el’, providing
     dynamic word completion.

   • Holger Schauer wrote ‘fortune.el’, a package for using fortune in
     message signatures.

   • William Schelter wrote ‘telnet.el’, support for ‘telnet’ sessions
     within Emacs.

   • Ralph Schleicher wrote ‘battery.el’, a package for displaying
     laptop computer battery status, and ‘info-look.el’, a package for
     looking up Info documentation for symbols in the buffer.

   • Michael Schmidt and Tom Perrine wrote ‘modula2.el’, a mode for
     editing Modula-2 code, based on work by Mick Jordan and Peter
     Robinson.

   • Ronald S. Schnell wrote ‘dunnet.el’, a text adventure game.

   • Philippe Schnoebelen wrote ‘gomoku.el’, a Go Moku game played
     against Emacs; and ‘mpuz.el’, a multiplication puzzle.

   • Jan Schormann wrote ‘solitaire.el’, an implementation of the
     Solitaire game.

   • Alex Schroeder wrote ‘ansi-color.el’, a package for translating
     ANSI color escape sequences to Emacs faces; ‘sql.el’, a package for
     interactively running an SQL interpreter in an Emacs buffer;
     ‘cus-theme.el’, an interface for custom themes; ‘master.el’, a
     package for making a buffer ‘master’ over another; and
     ‘spam-stat.el’, for statistical detection of junk email.  He also
     wrote parts of the IRC client ERC (q.v.).

   • Randal Schwartz wrote ‘pp.el’, a pretty-printer for lisp objects.

   • Manuel Serrano wrote the Flyspell package, which does spell
     checking as you type.

   • Hovav Shacham wrote ‘windmove.el’, a set of commands for selecting
     windows based on their geometrical position on the frame.

   • Stanislav Shalunov wrote ‘uce.el’, for responding to unsolicited
     commercial email.

   • Richard Sharman wrote ‘hilit-chg.el’, which uses colors to show
     recent editing changes.

   • Olin Shivers wrote ‘comint.el’, a library for modes running
     interactive command-line-oriented subprocesses, and ‘shell.el’, for
     running inferior shells (both since extended by Simon Marshall);
     ‘cmuscheme.el’, for running inferior Scheme processes;
     ‘inf-lisp.el’, for running inferior Lisp process.

   • Espen Skoglund wrote ‘pascal.el’, a mode for editing Pascal code.

   • Rick Sladkey wrote ‘backquote.el’, a lisp macro for creating
     mostly-constant data.

   • Lynn Slater wrote ‘help-macro.el’, a macro for writing interactive
     help for key bindings.

   • Chris Smith wrote ‘icon.el’, a mode for editing Icon code.

   • David Smith wrote ‘ielm.el’, a mode for interacting with the Emacs
     Lisp interpreter as a subprocess.

   • Paul D. Smith wrote ‘snmp-mode.el’.

   • William Sommerfeld wrote ‘scribe.el’, a mode for editing Scribe
     files, and ‘server.el’, a package allowing programs to send files
     to an extant Emacs job to be edited.

   • Andre Spiegel made many contributions to the Emacs Version Control
     package, and in particular made it support multiple back ends.

   • Michael Staats wrote ‘pc-select.el’, which rebinds keys for
     selecting regions to follow many other systems.

   • Richard Stallman invented Emacs.  He is the original author of GNU
     Emacs, and has been Emacs maintainer over several non-contiguous
     periods.  In addition to much of the core Emacs code, he has
     written ‘easymenu.el’, a facility for defining Emacs menus;
     ‘image-mode.el’, support for visiting image files; ‘menu-bar.el’,
     the Emacs menu bar support code; ‘paren.el’, a package to make
     matching parentheses stand out in color; and also co-authored
     portions of CC mode.

   • Sam Steingold wrote ‘midnight.el’, a package for running a command
     every midnight.

   • Ake Stenhoff and Lars Lindberg wrote ‘imenu.el’, a framework for
     browsing indices made from buffer contents.

   • Peter Stephenson wrote ‘vcursor.el’, which implements a virtual
     cursor that you can move with the keyboard and use for copying
     text.

   • Ken Stevens wrote ‘ispell.el’, a spell-checker interface.

   • Kim F. Storm made many improvements to the Emacs display engine,
     process support, and networking support.  He also wrote
     ‘bindat.el’, a package for encoding and decoding binary data; CUA
     mode, which allows Emacs to emulate the standard CUA key bindings;
     ‘ido.el’, a package for selecting buffers and files quickly;
     ‘keypad.el’ for simplified keypad bindings; and ‘kmacro.el’, the
     keyboard macro facility.

   • Martin Stjernholm co-authored CC Mode, a major editing mode for C,
     C++, Objective-C, Java, Pike, CORBA IDL, and AWK code.

   • Steve Strassmann did not write ‘spook.el’, and even if he did, he
     really didn’t mean for you to use it in an anarchistic way.

   • Olaf Sylvester wrote ‘bs.el’, a package for manipulating Emacs
     buffers.

   • Tibor Šimko and Milan Zamazal wrote ‘slovak.el’, support for
     editing text in Slovak language.

   • Luc Teirlinck wrote ‘help-at-pt.el’, providing local help through
     the keyboard.

   • Jean-Philippe Theberge wrote ‘thumbs.el’, a package for viewing
     image files as thumbnails.

   • Spencer Thomas wrote the original ‘dabbrev.el’, providing a command
     which completes the partial word before point, based on other
     nearby words for which it is a prefix.  He also wrote the original
     dumping support.

   • Toru Tomabechi contributed to Tibetan support.

   • Markus Triska wrote ‘linum.el’, a minor mode that displays line
     numbers in the left margin.

   • Tom Tromey and Chris Lindblad wrote ‘tcl.el’, a mode for editing
     Tcl/Tk source files and running a Tcl interpreter as an Emacs
     subprocess.  Tom Tromey also wrote ‘bug-reference.el’, providing
     clickable links to bug reports; and the first version of the Emacs
     package system.

   • Eli Tziperman wrote ‘rmail-spam-filter.el’, a spam filter for
     RMAIL.

   • Daiki Ueno wrote ‘starttls.el’, support for Transport Layer
     Security protocol; ‘sasl-cram.el’ and ‘sasl-digest.el’ (with
     Kenichi Okada), and ‘sasl.el’, support for Simple Authentication
     and Security Layer (SASL); ‘plstore.el’ for secure storage of
     property lists; and the EasyPG (and its predecessor PGG) package,
     for GnuPG and PGP support.

   • Masanobu Umeda wrote GNUS, a feature-rich reader for Usenet news
     that was the ancestor of the current Gnus package.  He also wrote
     ‘rmailsort.el’, a package for sorting messages in RMAIL folders;
     ‘metamail.el’, an interface to the Metamail program;
     ‘gnus-kill.el’, the Kill File mode for Gnus; ‘gnus-mh.el’, an mh-e
     interface for Gnus; ‘gnus-msg.el’, a mail and post interface for
     Gnus; and ‘timezone.el’, providing functions for dealing with time
     zones.

   • Neil W. Van Dyke wrote ‘webjump.el’, a Web hotlist package.

   • Didier Verna wrote ‘rect.el’, a package of functions for operations
     on rectangle regions of text.  He also contributed to Gnus (q.v.).

   • Joakim Verona implemented ImageMagick support.

   • Ulrik Vieth implemented ‘meta-mode.el’, for editing MetaFont code.

   • Geoffrey Voelker wrote the Windows NT support.  He also wrote
     ‘dos-w32.el’, functions shared by the MS-DOS and MS-Windows ports
     of Emacs, and ‘w32-fns.el’, MS-Windows specific support functions.

   • Johan Vromans wrote ‘forms.el’ and its associated files, a mode for
     filling in forms.  He also wrote ‘iso-acc.el’, a minor mode
     providing electric accent keys.

   • Colin Walters wrote Ibuffer, an enhanced buffer menu.

   • Barry Warsaw wrote ‘cc-mode.el’, a mode for editing C, C++, and
     Java code, based on earlier work by Dave Detlefs, Stewart Clamen,
     and Richard Stallman; ‘elp.el’, a profiler for Emacs Lisp programs;
     ‘man.el’, a mode for reading Unix manual pages; ‘regi.el’,
     providing an AWK-like functionality for use in lisp programs;
     ‘reporter.el’, providing customizable bug reporting for lisp
     packages; and ‘supercite.el’, a minor mode for quoting sections of
     mail messages and news articles.

   • Christoph Wedler wrote ‘antlr-mode.el’, a major mode for ANTLR
     grammar files.

   • Morten Welinder helped port Emacs to MS-DOS, and introduced face
     support into the MS-DOS port of Emacs.  He also wrote ‘desktop.el’,
     facilities for saving some of Emacs’s state between sessions;
     ‘timer.el’, the Emacs facility to run commands at a given time or
     frequency, or when Emacs is idle, and its C-level support code;
     ‘pc-win.el’, the MS-DOS “window-system” support; ‘internal.el’, an
     “internal terminal” emulator for the MS-DOS port of Emacs;
     ‘arc-mode.el’, the mode for editing compressed archives;
     ‘s-region.el’, commands for setting the region using the shift key
     and motion commands; and ‘dos-fns.el’, functions for use under
     MS-DOS.

   • Joe Wells wrote the original version of ‘apropos.el’ (q.v.);
     ‘resume.el’, support for processing command-line arguments after
     resuming a suspended Emacs job; and ‘mail-extr.el’, a package for
     extracting names and addresses from mail headers, with
     contributions from Jamie Zawinski.

   • Rodney Whitby and Reto Zimmermann wrote ‘vhdl-mode.el’, a major
     mode for editing VHDL source code.

   • John Wiegley was the Emacs maintainer from Emacs 25 onwards.  He
     wrote ‘align.el’, a set of commands for aligning text according to
     regular-expression based rules; ‘isearchb.el’ for fast buffer
     switching; ‘timeclock.el’, a package for keeping track of time
     spent on projects; the Bahá’í calendar support; ‘pcomplete.el’, a
     programmable completion facility; ‘remember.el’, a mode for jotting
     down things to remember; ‘eudcb-mab.el’, an address book backend
     for the Emacs Unified Directory Client; and ‘eshell’, a command
     shell implemented entirely in Emacs Lisp.  He also contributed to
     Org mode (q.v.).

   • Mike Williams wrote ‘thingatpt.el’, a library of functions for
     finding the “thing” (word, line, s-expression) at point.

   • Roland Winkler wrote ‘proced.el’, a system process editor.

   • Bill Wohler wrote MH-E, the Emacs interface to the MH mail system;
     making use of earlier work by James R. Larus.  Satyaki Das, Peter
     S. Galbraith, Stephen Gildea, and Jeffrey C. Honig also wrote
     various MH-E components.

   • Dale R. Worley wrote ‘emerge.el’, a package for interactively
     merging two versions of a file.

   • Francis J. Wright wrote ‘woman.el’, a package for browsing manual
     pages without the ‘man’ command.

   • Masatake Yamato wrote ‘ld-script.el’, an editing mode for GNU
     linker scripts, and contributed subword handling and style guessing
     in CC mode.

   • Jonathan Yavner wrote ‘testcover.el’, a package for keeping track
     of the testing status of Emacs Lisp code; ‘unsafep.el’ to determine
     if a Lisp form is safe; and the SES spreadsheet package.

   • Ryan Yeske wrote ‘rcirc.el’ a simple Internet Relay Chat client.

   • Ilya Zakharevich and Bob Olson wrote ‘cperl-mode.el’, a major mode
     for editing Perl code.  Ilya Zakharevich also wrote ‘tmm.el’, a
     mode for accessing the Emacs menu bar on a text-mode terminal.

   • Milan Zamazal wrote ‘czech.el’, support for editing Czech text;
     ‘glasses.el’, a package for easier reading of source code that uses
     illegible identifier names; and ‘tildify.el’, commands for adding
     hard spaces to text, TeX, and SGML/HTML files.

   • Victor Zandy wrote ‘zone.el’, a package for people who like to zone
     out in front of Emacs.

   • Eli Zaretskii made many standard Emacs features work on MS-DOS and
     Microsoft Windows.  He also wrote ‘tty-colors.el’, which implements
     transparent mapping of X colors to tty colors; and ‘rxvt.el’.  He
     implemented support for bidirectional text, menus on text-mode
     terminals, and built-in display of line numbers.

   • Jamie Zawinski wrote much of the support for faces and X
     selections.  With Hallvard Furuseth, he wrote the optimizing byte
     compiler used from Emacs 19 onwards.  He also wrote
     ‘mailabbrev.el’, a package that provides automatic expansion of
     mail aliases, and ‘tar-mode.el’, which provides simple viewing and
     editing commands for tar files.

   • Andrew Zhilin created the Emacs 22 icons.

   • Shenghuo Zhu wrote ‘binhex.el’, a package for reading and writing
     binhex files; ‘mm-partial.el’, message/partial support for MIME
     messages; ‘rfc1843.el’, an HZ decoding package; ‘uudecode.el’, an
     Emacs Lisp decoder for uuencoded data; and ‘webmail.el’, an
     interface to Web mail.  He also wrote several other Gnus
     components.

   • Ian T. Zimmerman wrote ‘gametree.el’.

   • Reto Zimmermann wrote ‘vera-mode.el’.

   • Neal Ziring and Felix S. T. Wu wrote ‘vi.el’, an emulation of the
     VI text editor.

   • Ted Zlatanov (as well as his contributions to the Gnus newsreader)
     wrote an interface to the GnuTLS library, for secure network
     connections; and a futures facility for the URL library.

   • Detlev Zundel wrote ‘re-builder.el’, a package for building regexps
     with visual feedback.


File: emacs-ja.info,  Node: Key Index,  Next: Option Index,  Prev: Acknowledgments,  Up: Top

Key (Character) Index
*********************

 [index ]
* Menu:

* ! (Dired):                             Shell Commands in Dired.
                                                              (line   6)
* " (TeX mode):                          TeX Editing.         (line  22)
* # (Dired):                             Flagging Many Files. (line  30)
* $ (Dired):                             Hiding Subdirectories.
                                                              (line  10)
* % & (Dired):                           Flagging Many Files. (line  50)
* % (Buffer Menu):                       Several Buffers.     (line  78)
* % C (Dired):                           Transforming File Names.
                                                              (line  35)
* % d (Dired):                           Flagging Many Files. (line  56)
* % g (Dired):                           Marks vs Flags.      (line 127)
* % H (Dired):                           Transforming File Names.
                                                              (line  36)
* % l (Dired):                           Transforming File Names.
                                                              (line  29)
* % m (Dired):                           Marks vs Flags.      (line 117)
* % R (Dired):                           Transforming File Names.
                                                              (line  34)
* % S (Dired):                           Transforming File Names.
                                                              (line  37)
* % u (Dired):                           Transforming File Names.
                                                              (line  23)
* ( (Dired):                             Misc Dired Features. (line  38)
* * ! (Dired):                           Marks vs Flags.      (line  63)
* * % (Dired):                           Marks vs Flags.      (line 117)
* * * (Dired):                           Marks vs Flags.      (line  27)
* * / (Dired):                           Marks vs Flags.      (line  36)
* * ? (Dired):                           Marks vs Flags.      (line  68)
* * @ (Dired):                           Marks vs Flags.      (line  31)
* * c (Dired):                           Marks vs Flags.      (line  96)
* * C-n (Dired):                         Marks vs Flags.      (line  80)
* * C-p (Dired):                         Marks vs Flags.      (line  86)
* * DEL (Dired):                         Marks vs Flags.      (line  54)
* * m (Dired):                           Marks vs Flags.      (line  17)
* * s (Dired):                           Marks vs Flags.      (line  41)
* * t (Dired):                           Marks vs Flags.      (line  91)
* * u (Dired):                           Marks vs Flags.      (line  46)
* + (Dired):                             Misc Dired Features. (line   6)
* + (DocView mode):                      DocView Navigation.  (line  30)
* - (DocView mode):                      DocView Navigation.  (line  30)
* . (Calendar mode):                     Specified Dates.     (line  33)
* . (Dired):                             Flagging Many Files. (line  38)
* . (Rmail):                             Rmail Scrolling.     (line  27)
* / (Rmail):                             Rmail Scrolling.     (line  27)
* 1 (Buffer Menu):                       Several Buffers.     (line 107)
* 2 (Buffer Menu):                       Several Buffers.     (line 111)
* :d (Dired):                            Operating on Files.  (line 118)
* :e (Dired):                            Operating on Files.  (line 131)
* :s (Dired):                            Operating on Files.  (line 127)
* :v (Dired):                            Operating on Files.  (line 122)
* < (Calendar mode):                     Scroll Calendar.     (line  27)
* < (Dired):                             Subdirectory Motion. (line  30)
* < (Rmail):                             Rmail Motion.        (line  80)
* = (Dired):                             Comparison in Dired. (line   6)
* > (Calendar mode):                     Scroll Calendar.     (line  27)
* > (Dired):                             Subdirectory Motion. (line  35)
* > (Rmail):                             Rmail Motion.        (line  80)
* ? (completion):                        Completion Commands. (line  33)
* ^ (Dired):                             Dired Visiting.      (line  45)
* ~ (Buffer Menu):                       Several Buffers.     (line  73)
* ~ (Dired):                             Flagging Many Files. (line  34)
* a (Calendar mode):                     Holidays.            (line  41)
* A (Dired):                             Operating on Files.  (line 144)
* a (Rmail):                             Rmail Labels.        (line  31)
* A k (Gnus Group mode):                 Gnus Group Buffer.   (line  24)
* A s (Gnus Group mode):                 Gnus Group Buffer.   (line  12)
* A u (Gnus Group mode):                 Gnus Group Buffer.   (line  18)
* A z (Gnus Group mode):                 Gnus Group Buffer.   (line  27)
* AltGr (MS-Windows):                    Windows Keyboard.    (line 122)
* b (Buffer Menu):                       Several Buffers.     (line 117)
* B (Dired):                             Operating on Files.  (line 139)
* b (Rmail summary):                     Rmail Summary Edit.  (line  93)
* b (Rmail):                             Rmail Basics.        (line  36)
* BS (MS-DOS):                           MS-DOS Keyboard.     (line   6)
* C (Dired):                             Operating on Files.  (line  32)
* c (Dired):                             Operating on Files.  (line 112)
* c (Rmail):                             Rmail Reply.         (line 106)
* C-/:                                   Undo.                (line  21)
* C-@:                                   Setting Mark.        (line  25)
* C-a:                                   Moving Point.        (line  47)
* C-a (Calendar mode):                   Move to Beginning or End.
                                                              (line  10)
* C-b:                                   Moving Point.        (line  27)
* C-b (Calendar mode):                   Calendar Unit Motion.
                                                              (line  26)
* C-Break (MS-DOS):                      MS-DOS Keyboard.     (line  12)
* C-c ' (Picture mode):                  Insert in Picture.   (line   6)
* C-c , j:                               Semantic.            (line  30)
* C-c , J:                               Semantic.            (line  34)
* C-c , l:                               Semantic.            (line  46)
* C-c , SPC:                             Semantic.            (line  38)
* C-c . (C mode):                        Custom C Indent.     (line  26)
* C-c . (Picture mode):                  Insert in Picture.   (line   6)
* C-c . (Shell mode):                    Shell Ring.          (line  25)
* C-c / (Picture mode):                  Insert in Picture.   (line   6)
* C-c / (SGML mode):                     HTML Mode.           (line  52)
* C-c 8 (SGML mode):                     HTML Mode.           (line  57)
* C-c ; (Fortran mode):                  Fortran Comments.    (line  78)
* C-c < (GUD):                           Commands of GUD.     (line  66)
* C-c < (Picture mode):                  Insert in Picture.   (line   6)
* C-c > (GUD):                           Commands of GUD.     (line  71)
* C-c > (Picture mode):                  Insert in Picture.   (line   6)
* C-c ? (SGML mode):                     HTML Mode.           (line  48)
* C-c @ (Outline minor mode):            Outline Mode.        (line  33)
* C-c @ C-h:                             Hideshow.            (line  20)
* C-c @ C-l:                             Hideshow.            (line  20)
* C-c @ C-M-h:                           Hideshow.            (line  20)
* C-c @ C-M-s:                           Hideshow.            (line  20)
* C-c @ C-r:                             Hideshow.            (line  20)
* C-c @ C-s:                             Hideshow.            (line  20)
* C-c C-a (C mode):                      Electric C.          (line  29)
* C-c C-a (F90 mode):                    Fortran Motion.      (line  29)
* C-c C-a (Log Edit mode):               Log Buffer.          (line  42)
* C-c C-a (Message mode):                Mail Misc.           (line   6)
* C-c C-a (Outline mode):                Outline Visibility.  (line  71)
* C-c C-a (SGML mode):                   HTML Mode.           (line  30)
* C-c C-a (Shell mode):                  Shell Mode.          (line  38)
* C-c C-b (Help mode):                   Help Mode.           (line  29)
* C-c C-b (Message mode):                Header Editing.      (line  35)
* C-c C-b (Outline mode):                Outline Motion.      (line  19)
* C-c C-b (Picture mode):                Insert in Picture.   (line  39)
* C-c C-b (SGML mode):                   HTML Mode.           (line  38)
* C-c C-b (Shell mode):                  Shell Mode.          (line 100)
* C-c C-b (TeX mode):                    TeX Print.           (line  38)
* C-c C-c (C mode):                      Comment Commands.    (line  79)
* C-c C-c (customization buffer):        Changing a Variable. (line 137)
* C-c C-c (Edit Abbrevs):                Editing Abbrevs.     (line  41)
* C-c C-c (Edit Tab Stops):              Tab Stops.           (line  15)
* C-c C-c (Log Edit mode):               Log Buffer.          (line   6)
* C-c C-c (Message mode):                Mail Sending.        (line  13)
* C-c C-c (Outline mode):                Outline Visibility.  (line  49)
* C-c C-c (Shell mode):                  Shell Mode.          (line  61)
* C-c C-c (TeX mode):                    TeX Print.           (line 147)
* C-c C-d (C Mode):                      Hungry Delete.       (line  19)
* C-c C-d (Fortran mode):                ForIndent Commands.  (line  31)
* C-c C-d (GUD):                         Commands of GUD.     (line  54)
* C-c C-d (Log Edit mode):               Log Buffer.          (line  33)
* C-c C-d (Org Mode):                    Org Organizer.       (line  13)
* C-c C-d (Outline mode):                Outline Visibility.  (line  54)
* C-c C-d (Picture mode):                Basic Picture.       (line  41)
* C-c C-d (SGML mode):                   HTML Mode.           (line  43)
* C-c C-DEL (C Mode):                    Hungry Delete.       (line  13)
* C-c C-Delete (C Mode):                 Hungry Delete.       (line  19)
* C-c C-e (C mode):                      Other C Commands.    (line  36)
* C-c C-e (F90 mode):                    Fortran Motion.      (line  22)
* C-c C-e (LaTeX mode):                  LaTeX Editing.       (line  26)
* C-c C-e (Org mode):                    Org Authoring.       (line   6)
* C-c C-e (Outline mode):                Outline Visibility.  (line  49)
* C-c C-e (Shell mode):                  Shell Mode.          (line  91)
* C-c C-f (GUD):                         Commands of GUD.     (line  83)
* C-c C-f (Help mode):                   Help Mode.           (line  29)
* C-c C-f (Log Edit mode):               Log Buffer.          (line  33)
* C-c C-f (Outline mode):                Outline Motion.      (line  16)
* C-c C-f (Picture mode):                Insert in Picture.   (line  39)
* C-c C-f (SGML mode):                   HTML Mode.           (line  33)
* C-c C-f (Shell mode):                  Shell Mode.          (line  95)
* C-c C-f (TeX mode):                    TeX Print.           (line 106)
* C-c C-f C-b (Message mode):            Header Editing.      (line  30)
* C-c C-f C-c (Message mode):            Header Editing.      (line  30)
* C-c C-f C-f (Message mode):            Header Editing.      (line  30)
* C-c C-f C-r (Message mode):            Header Editing.      (line  30)
* C-c C-f C-s (Message mode):            Header Editing.      (line  30)
* C-c C-f C-t (Message mode):            Header Editing.      (line  30)
* C-c C-f C-w (Message mode):            Header Editing.      (line  30)
* C-c C-i (GUD):                         Commands of GUD.     (line  39)
* C-c C-i (Outline mode):                Outline Visibility.  (line  59)
* C-c C-j (Term mode):                   Term Mode.           (line   9)
* C-c C-k (Outline mode):                Outline Visibility.  (line  59)
* C-c C-k (Picture mode):                Rectangles in Picture.
                                                              (line  26)
* C-c C-k (Term mode):                   Term Mode.           (line  13)
* C-c C-k (TeX mode):                    TeX Print.           (line  75)
* C-c C-l (C mode):                      Electric C.          (line  19)
* C-c C-l (Calendar mode):               General Calendar.    (line  24)
* C-c C-l (GUD):                         Commands of GUD.     (line  24)
* C-c C-l (Outline mode):                Outline Visibility.  (line  59)
* C-c C-l (Shell mode):                  Shell Ring.          (line  29)
* C-c C-l (TeX mode):                    TeX Print.           (line  75)
* C-c C-n (C mode):                      Motion in C.         (line  33)
* C-c C-n (Fortran mode):                Fortran Motion.      (line  12)
* C-c C-n (GUD):                         Commands of GUD.     (line  34)
* C-c C-n (Outline mode):                Outline Motion.      (line  10)
* C-c C-n (Rmail):                       Rmail Motion.        (line  72)
* C-c C-n (SGML mode):                   HTML Mode.           (line  16)
* C-c C-n (Shell mode):                  Shell History Copying.
                                                              (line   9)
* C-c C-o (LaTeX mode):                  LaTeX Editing.       (line  15)
* C-c C-o (Outline mode):                Outline Visibility.  (line  66)
* C-c C-o (Shell mode):                  Shell Mode.          (line  76)
* C-c C-p (C mode):                      Motion in C.         (line  28)
* C-c C-p (Fortran mode):                Fortran Motion.      (line  16)
* C-c C-p (GUD):                         Commands of GUD.     (line  43)
* C-c C-p (Outline mode):                Outline Motion.      (line  13)
* C-c C-p (Rmail):                       Rmail Motion.        (line  72)
* C-c C-p (Shell mode):                  Shell History Copying.
                                                              (line   6)
* C-c C-p (TeX mode):                    TeX Print.           (line  38)
* C-c C-q (C mode):                      C Indent.            (line   9)
* C-c C-q (Message mode):                Citing Mail.         (line  23)
* C-c C-q (Outline mode):                Outline Visibility.  (line  71)
* C-c C-q (Term mode):                   Term Mode.           (line  30)
* C-c C-r (Fortran mode):                Fortran Columns.     (line  29)
* C-c C-r (GUD):                         Commands of GUD.     (line  48)
* C-c C-r (Shell mode):                  Shell Mode.          (line  87)
* C-c C-r (TeX mode):                    TeX Print.           (line  86)
* C-c C-s (C mode):                      Other C Commands.    (line  66)
* C-c C-s (GUD):                         Commands of GUD.     (line  29)
* C-c C-s (Message mode):                Mail Sending.        (line  13)
* C-c C-s (Org Mode):                    Org Organizer.       (line  13)
* C-c C-s (Outline mode):                Outline Visibility.  (line  54)
* C-c C-s (Shell mode):                  Shell Mode.          (line  81)
* C-c C-t (GUD):                         Commands of GUD.     (line  60)
* C-c C-t (Org Mode):                    Org Organizer.       (line   6)
* C-c C-t (Outline mode):                Outline Visibility.  (line  71)
* C-c C-t (SGML mode):                   HTML Mode.           (line  20)
* C-c C-u (C mode):                      Motion in C.         (line  18)
* C-c C-u (GUD):                         Commands of GUD.     (line  76)
* C-c C-u (Outline mode):                Outline Motion.      (line  22)
* C-c C-u (Shell mode):                  Shell Mode.          (line  53)
* C-c C-v (SGML mode):                   HTML Mode.           (line  61)
* C-c C-v (TeX mode):                    TeX Print.           (line  38)
* C-c C-w (Fortran mode):                Fortran Columns.     (line  48)
* C-c C-w (Message mode):                Mail Signature.      (line  19)
* C-c C-w (Picture mode):                Rectangles in Picture.
                                                              (line  26)
* C-c C-w (Shell mode):                  Shell Mode.          (line  58)
* C-c C-x:                               Foldout.             (line  43)
* C-c C-x (Picture mode):                Rectangles in Picture.
                                                              (line  36)
* C-c C-x (Shell mode):                  Shell Ring.          (line  21)
* C-c C-y (Message mode):                Citing Mail.         (line  13)
* C-c C-y (Picture mode):                Rectangles in Picture.
                                                              (line  36)
* C-c C-z:                               Foldout.             (line  16)
* C-c C-z (Shell mode):                  Shell Mode.          (line  66)
* C-c C-\ (C mode):                      Other C Commands.    (line  47)
* C-c C-\ (Shell mode):                  Shell Mode.          (line  71)
* C-c DEL (C Mode):                      Hungry Delete.       (line  13)
* C-c Delete (C Mode):                   Hungry Delete.       (line  19)
* C-c DOWN (Picture mode):               Insert in Picture.   (line   6)
* C-c End (Picture mode):                Insert in Picture.   (line   6)
* C-c Home (Picture mode):               Insert in Picture.   (line   6)
* C-c LEFT (Picture mode):               Insert in Picture.   (line   6)
* C-c next (Picture mode):               Insert in Picture.   (line   6)
* C-c PageDown (Picture mode):           Insert in Picture.   (line   6)
* C-c PageUp (Picture mode):             Insert in Picture.   (line   6)
* C-c prior (Picture mode):              Insert in Picture.   (line   6)
* C-c RET (Goto Address mode):           Goto Address mode.   (line   9)
* C-c RET (Shell mode):                  Shell History Copying.
                                                              (line  12)
* C-c RIGHT (Picture mode):              Insert in Picture.   (line   6)
* C-c TAB (Picture mode):                Tabs in Picture.     (line  22)
* C-c TAB (SGML mode):                   HTML Mode.           (line  66)
* C-c TAB (TeX mode):                    TeX Print.           (line 136)
* C-c UP (Picture mode):                 Insert in Picture.   (line   6)
* C-c [ (Enriched mode):                 Enriched Indentation.
                                                              (line  32)
* C-c [ (Org Mode):                      Org Organizer.       (line  20)
* C-c \ (Picture mode):                  Insert in Picture.   (line   6)
* C-c ] (Enriched mode):                 Enriched Indentation.
                                                              (line  32)
* C-c ^ (Picture mode):                  Insert in Picture.   (line   6)
* C-c ` (Picture mode):                  Insert in Picture.   (line   6)
* C-c { (TeX mode):                      TeX Editing.         (line  40)
* C-c } (TeX mode):                      TeX Editing.         (line  40)
* C-d (Buffer Menu):                     Several Buffers.     (line  35)
* C-d (Rmail):                           Rmail Deletion.      (line  28)
* C-d (Shell mode):                      Shell Mode.          (line  32)
* C-Down-mouse-1:                        Buffer Menus.        (line  22)
* C-e:                                   Moving Point.        (line  51)
* C-e (Calendar mode):                   Move to Beginning or End.
                                                              (line  11)
* C-END:                                 Moving Point.        (line  90)
* C-f:                                   Moving Point.        (line  19)
* C-f (Calendar mode):                   Calendar Unit Motion.
                                                              (line  26)
* C-g:                                   Quitting.            (line  29)
* C-g (Incremental search):              Error in Isearch.    (line  21)
* C-g (MS-DOS):                          MS-DOS Keyboard.     (line  12)
* C-h:                                   Help.                (line   6)
* C-h .:                                 Help Echo.           (line  14)
* C-h a:                                 Apropos.             (line  16)
* C-h b:                                 Misc Help.           (line  40)
* C-h c:                                 Key Help.            (line   9)
* C-h C:                                 Coding Systems.      (line  46)
* C-h C-c:                               Help Files.          (line  13)
* C-h C-d:                               Help Files.          (line  13)
* C-h C-e:                               Help Files.          (line  13)
* C-h C-f:                               Help Files.          (line  13)
* C-h C-h:                               Help.                (line   6)
* C-h C-h (Incremental Search):          Special Isearch.     (line  90)
* C-h C-m:                               Help Files.          (line  13)
* C-h C-n:                               Help Files.          (line  13)
* C-h C-o:                               Help Files.          (line  13)
* C-h C-p:                               Help Files.          (line  13)
* C-h C-t:                               Help Files.          (line  13)
* C-h C-w:                               Help Files.          (line  13)
* C-h C-\:                               Select Input Method. (line  16)
* C-h d:                                 Apropos.             (line  44)
* C-h e:                                 Misc Help.           (line  31)
* C-h f:                                 Name Help.           (line   6)
* C-h F:                                 Name Help.           (line  46)
* C-h g:                                 Help Files.          (line  13)
* C-h h:                                 International Chars. (line  19)
* C-h i:                                 Misc Help.           (line   6)
* C-h I:                                 Select Input Method. (line  16)
* C-h k:                                 Key Help.            (line  12)
* C-h K:                                 Key Help.            (line  16)
* C-h l:                                 Misc Help.           (line  25)
* C-h L:                                 Language Environments.
                                                              (line  76)
* C-h m:                                 Misc Help.           (line  35)
* C-h o:                                 Name Help.           (line  51)
* C-h p:                                 Package Keywords.    (line  11)
* C-h P:                                 Package Keywords.    (line  19)
* C-h S:                                 Misc Help.           (line  20)
* C-h s:                                 Misc Help.           (line  40)
* C-h t:                                 Basic.               (line   6)
* C-h v:                                 Name Help.           (line  37)
* C-h w:                                 Key Help.            (line  25)
* C-j:                                   Inserting Text.      (line  12)
* C-j (and major modes):                 Major Modes.         (line   6)
* C-j (Lisp Interaction mode):           Lisp Interaction.    (line  11)
* C-j (MS-DOS):                          MS-DOS Keyboard.     (line  32)
* C-j (TeX mode):                        TeX Editing.         (line  49)
* C-k:                                   Killing by Lines.    (line  11)
* C-k (Gnus Group mode):                 Gnus Group Buffer.   (line  37)
* C-l:                                   Recentering.         (line  20)
* C-LEFT:                                Moving Point.        (line  69)
* C-M-%:                                 Query Replace.       (line  21)
* C-M-.:                                 Looking Up Identifiers.
                                                              (line  48)
* C-M-/:                                 Dynamic Abbrevs.     (line  12)
* C-M-@:                                 Marking Objects.     (line  38)
* C-M-a:                                 Moving by Defuns.    (line  17)
* C-M-b:                                 Expressions.         (line  24)
* C-M-c:                                 Recursive Edit.      (line  12)
* C-M-d:                                 Moving by Parens.    (line  40)
* C-M-d (Dired):                         Subdirectory Motion. (line  26)
* C-M-e:                                 Moving by Defuns.    (line  17)
* C-M-f:                                 Expressions.         (line  24)
* C-M-f (Rmail):                         Rmail Make Summary.  (line  54)
* C-M-h:                                 Moving by Defuns.    (line  17)
* C-M-h (C mode):                        Moving by Defuns.    (line  29)
* C-M-i:                                 Symbol Completion.   (line   9)
* C-M-i (customization buffer):          Changing a Variable. (line  53)
* C-M-j:                                 Multi-Line Comments. (line   6)
* C-M-j (Fortran mode):                  ForIndent Commands.  (line  26)
* C-M-k:                                 Expressions.         (line  43)
* C-M-l:                                 Recentering.         (line  56)
* C-M-l (Rmail):                         Rmail Make Summary.  (line  36)
* C-M-l (Shell mode):                    Shell Mode.          (line  87)
* C-M-n:                                 Moving by Parens.    (line  29)
* C-M-n (Dired):                         Subdirectory Motion. (line  15)
* C-M-n (Fortran mode):                  Fortran Motion.      (line  33)
* C-M-n (Rmail):                         Rmail Labels.        (line  39)
* C-M-o:                                 Indentation Commands.
                                                              (line  10)
* C-M-p:                                 Moving by Parens.    (line  29)
* C-M-p (Dired):                         Subdirectory Motion. (line  19)
* C-M-p (Fortran mode):                  Fortran Motion.      (line  41)
* C-M-p (Rmail):                         Rmail Labels.        (line  39)
* C-M-q:                                 Multi-line Indent.   (line  25)
* C-M-q (C mode):                        C Indent.            (line  13)
* C-M-q (Fortran mode):                  ForIndent Commands.  (line  22)
* C-M-r:                                 Regexp Search.       (line  18)
* C-M-r (Rmail):                         Rmail Make Summary.  (line  40)
* C-M-s:                                 Regexp Search.       (line  18)
* C-M-s (Rmail):                         Rmail Make Summary.  (line  50)
* C-M-SPC:                               Expressions.         (line  54)
* C-M-t:                                 Expressions.         (line  46)
* C-M-t (Rmail):                         Rmail Make Summary.  (line  45)
* C-M-u:                                 Moving by Parens.    (line  33)
* C-M-u (Dired):                         Subdirectory Motion. (line  23)
* C-M-v:                                 Other Window.        (line  26)
* C-M-w:                                 Appending Kills.     (line  36)
* C-M-w (Incremental search):            Isearch Yank.        (line  27)
* C-M-x (Emacs Lisp mode):               Lisp Eval.           (line  49)
* C-M-x (Lisp mode):                     External Lisp.       (line  25)
* C-M-x (Scheme mode):                   External Lisp.       (line  34)
* C-M-y (Incremental search):            Isearch Yank.        (line  27)
* C-M-\:                                 Indentation Commands.
                                                              (line  45)
* C-mouse-1:                             Menu Mouse Clicks.   (line  10)
* C-mouse-2:                             Menu Mouse Clicks.   (line  17)
* C-mouse-2 (mode line):                 Split Window.        (line  53)
* C-mouse-2 (scroll bar):                Split Window.        (line  53)
* C-mouse-3:                             Menu Mouse Clicks.   (line  22)
* C-mouse-3 (when menu bar is disabled): Menu Bars.           (line  12)
* C-n:                                   Moving Point.        (line  36)
* C-n (Calendar mode):                   Calendar Unit Motion.
                                                              (line  26)
* C-n (Dired):                           Dired Navigation.    (line   6)
* C-o:                                   Blank Lines.         (line  13)
* C-o (Buffer Menu):                     Several Buffers.     (line 103)
* C-o (Dired):                           Dired Visiting.      (line  28)
* C-o (Occur mode):                      Other Repeating Search.
                                                              (line  63)
* C-o (Rmail):                           Rmail Output.        (line  21)
* C-p:                                   Moving Point.        (line  42)
* C-p (Calendar mode):                   Calendar Unit Motion.
                                                              (line  26)
* C-p (Dired):                           Dired Navigation.    (line   6)
* C-q:                                   Inserting Text.      (line  30)
* C-r:                                   Basic Isearch.       (line  58)
* C-RIGHT:                               Moving Point.        (line  59)
* C-s:                                   Basic Isearch.       (line  11)
* C-S-backspace:                         Killing by Lines.    (line  32)
* C-S-mouse-3 (FFAP):                    FFAP.                (line  56)
* C-SPC:                                 Setting Mark.        (line  25)
* C-SPC C-SPC:                           Mark Ring.           (line  18)
* C-SPC C-SPC, disabling Transient Mark: Disabled Transient Mark.
                                                              (line  32)
* C-t:                                   Transpose.           (line  15)
* C-t d (Image-Dired):                   Image-Dired.         (line  10)
* C-TAB:                                 File Name Cache.     (line   6)
* C-u:                                   Arguments.           (line  40)
* C-u C-/:                               Undo.                (line  52)
* C-u C-c C-w (Fortran mode):            Fortran Columns.     (line  53)
* C-u C-SPC:                             Mark Ring.           (line  27)
* C-u C-x C-x:                           Disabled Transient Mark.
                                                              (line  38)
* C-u C-x v =:                           Old Revisions.       (line  37)
* C-u M-;:                               Comment Commands.    (line  72)
* C-u TAB:                               Multi-line Indent.   (line  33)
* C-v:                                   Moving Point.        (line  96)
* C-v <1>:                               Scrolling.           (line  38)
* C-v (Calendar mode):                   Scroll Calendar.     (line  32)
* C-w:                                   Other Kill Commands. (line  26)
* C-w (Incremental search):              Isearch Yank.        (line  10)
* C-x #:                                 Invoking emacsclient.
                                                              (line  34)
* C-x $:                                 Selective Display.   (line   6)
* C-x (:                                 Basic Keyboard Macro.
                                                              (line  79)
* C-x ):                                 Basic Keyboard Macro.
                                                              (line  79)
* C-x +:                                 Change Window.       (line  69)
* C-x -:                                 Change Window.       (line  64)
* C-x .:                                 Fill Prefix.         (line  24)
* C-x 0:                                 Change Window.       (line  29)
* C-x 1:                                 Change Window.       (line  40)
* C-x 2:                                 Split Window.        (line  13)
* C-x 3:                                 Split Window.        (line  28)
* C-x 4:                                 Pop Up Window.       (line   6)
* C-x 4 .:                               Looking Up Identifiers.
                                                              (line  41)
* C-x 4 0:                               Change Window.       (line  36)
* C-x 4 a:                               Change Log Commands. (line   6)
* C-x 4 b:                               Select Buffer.       (line  53)
* C-x 4 c:                               Indirect Buffers.    (line  17)
* C-x 4 C-o:                             Pop Up Window.       (line  17)
* C-x 4 d:                               Dired Enter.         (line  51)
* C-x 4 f:                               Visiting.            (line 109)
* C-x 4 f (FFAP):                        FFAP.                (line  36)
* C-x 4 m:                               Sending Mail.        (line  34)
* C-x 5:                                 Creating Frames.     (line   6)
* C-x 5 .:                               Looking Up Identifiers.
                                                              (line  41)
* C-x 5 0:                               Frame Commands.      (line   9)
* C-x 5 1:                               Frame Commands.      (line  21)
* C-x 5 2:                               Creating Frames.     (line  18)
* C-x 5 b:                               Select Buffer.       (line  58)
* C-x 5 d:                               Dired Enter.         (line  51)
* C-x 5 f:                               Visiting.            (line 117)
* C-x 5 f (FFAP):                        FFAP.                (line  43)
* C-x 5 m:                               Sending Mail.        (line  34)
* C-x 5 o:                               Frame Commands.      (line  17)
* C-x 5 r:                               Creating Frames.     (line  39)
* C-x 6 1:                               Two-Column.          (line  51)
* C-x 6 2:                               Two-Column.          (line  12)
* C-x 6 b:                               Two-Column.          (line  32)
* C-x 6 d:                               Two-Column.          (line  56)
* C-x 6 RET:                             Two-Column.          (line  47)
* C-x 6 s:                               Two-Column.          (line  21)
* C-x 8:                                 Inserting Text.      (line  58)
* C-x ;:                                 Options for Comments.
                                                              (line   6)
* C-x <:                                 Horizontal Scrolling.
                                                              (line  38)
* C-x =:                                 Position Info.       (line  54)
* C-x =, and international characters:   International Chars. (line  37)
* C-x >:                                 Horizontal Scrolling.
                                                              (line  38)
* C-x a g:                               Defining Abbrevs.    (line  31)
* C-x a i g:                             Defining Abbrevs.    (line  46)
* C-x a i l:                             Defining Abbrevs.    (line  46)
* C-x a l:                               Defining Abbrevs.    (line  42)
* C-x b:                                 Select Buffer.       (line  24)
* C-x C-+:                               Text Scale.          (line   6)
* C-x C--:                               Text Scale.          (line   6)
* C-x C-0:                               Text Scale.          (line   6)
* C-x C-;:                               Comment Commands.    (line  63)
* C-x C-=:                               Text Scale.          (line   6)
* C-x C-a (GUD):                         Commands of GUD.     (line  17)
* C-x C-a C-b:                           Commands of GUD.     (line  10)
* C-x C-a C-j (GUD):                     Commands of GUD.     (line  90)
* C-x C-a C-w (GUD):                     Watch Expressions.   (line   6)
* C-x C-b:                               List Buffers.        (line   9)
* C-x C-c:                               Exiting.             (line  13)
* C-x C-c (customization buffer):        Changing a Variable. (line 137)
* C-x C-d:                               Directories.         (line  24)
* C-x C-e:                               Lisp Eval.           (line  35)
* C-x C-f:                               Visiting.            (line  27)
* C-x C-f (FFAP):                        FFAP.                (line  24)
* C-x C-k b:                             Save Keyboard Macro. (line  24)
* C-x C-k C-a:                           Keyboard Macro Counter.
                                                              (line  55)
* C-x C-k C-c:                           Keyboard Macro Counter.
                                                              (line  49)
* C-x C-k C-e:                           Edit Keyboard Macro. (line  15)
* C-x C-k C-f:                           Keyboard Macro Counter.
                                                              (line  60)
* C-x C-k C-i:                           Keyboard Macro Counter.
                                                              (line  27)
* C-x C-k C-k:                           Keyboard Macro Ring. (line  32)
* C-x C-k C-n:                           Keyboard Macro Ring. (line  42)
* C-x C-k C-p:                           Keyboard Macro Ring. (line  42)
* C-x C-k e:                             Edit Keyboard Macro. (line  21)
* C-x C-k l:                             Edit Keyboard Macro. (line  26)
* C-x C-k n:                             Save Keyboard Macro. (line  15)
* C-x C-k r:                             Basic Keyboard Macro.
                                                              (line  75)
* C-x C-k RET:                           Edit Keyboard Macro. (line  15)
* C-x C-k SPC:                           Keyboard Macro Step-Edit.
                                                              (line   6)
* C-x C-k x:                             Keyboard Macro Registers.
                                                              (line   6)
* C-x C-l:                               Case.                (line  40)
* C-x C-n:                               Moving Point.        (line 127)
* C-x C-o:                               Blank Lines.         (line  13)
* C-x C-p:                               Pages.               (line  35)
* C-x C-q:                               Misc Buffer.         (line  16)
* C-x C-r:                               Visiting.            (line 105)
* C-x C-r (FFAP):                        FFAP.                (line  27)
* C-x C-s:                               Save Commands.       (line  22)
* C-x C-s (Custom Themes buffer):        Custom Themes.       (line  36)
* C-x C-SPC:                             Global Mark Ring.    (line  14)
* C-x C-t:                               Transpose.           (line  27)
* C-x C-u:                               Case.                (line  40)
* C-x C-v:                               Visiting.            (line  80)
* C-x C-v (FFAP):                        FFAP.                (line  29)
* C-x C-w:                               Save Commands.       (line  93)
* C-x C-x:                               Setting Mark.        (line  46)
* C-x C-x, in rectangle-mark-mode:       Rectangles.          (line 123)
* C-x C-z:                               External Lisp.       (line  11)
* C-x d:                                 Dired Enter.         (line   6)
* C-x d (FFAP):                          FFAP.                (line  31)
* C-x DEL:                               Sentences.           (line  35)
* C-x e:                                 Basic Keyboard Macro.
                                                              (line  79)
* C-x ESC ESC:                           Repetition.          (line  19)
* C-x f:                                 Fill Commands.       (line  39)
* C-x h:                                 Marking Objects.     (line  52)
* C-x i:                                 Misc File Ops.       (line  34)
* C-x k:                                 Kill Buffer.         (line  22)
* C-x l:                                 Pages.               (line  49)
* C-x LEFT:                              Select Buffer.       (line  48)
* C-x m:                                 Sending Mail.        (line   6)
* C-x n d:                               Narrowing.           (line  39)
* C-x n n:                               Narrowing.           (line  34)
* C-x n p:                               Narrowing.           (line  39)
* C-x n w:                               Narrowing.           (line  44)
* C-x o:                                 Other Window.        (line  15)
* C-x q:                                 Keyboard Macro Query.
                                                              (line  13)
* C-x r +:                               Number Registers.    (line  13)
* C-x r b:                               Bookmarks.           (line  31)
* C-x r c:                               Rectangles.          (line  90)
* C-x r d:                               Rectangles.          (line  62)
* C-x r f:                               Configuration Registers.
                                                              (line   6)
* C-x r i:                               Text Registers.      (line  49)
* C-x r j:                               Position Registers.  (line  17)
* C-x r k:                               Rectangles.          (line  62)
* C-x r l:                               Bookmarks.           (line  41)
* C-x r m:                               Bookmarks.           (line  31)
* C-x r M:                               Bookmarks.           (line  37)
* C-x r M-w:                             Rectangles.          (line  75)
* C-x r N:                               Rectangles.          (line  98)
* C-x r n:                               Number Registers.    (line  11)
* C-x r o:                               Rectangles.          (line  90)
* C-x r r:                               Rectangle Registers. (line   9)
* C-x r s:                               Text Registers.      (line  26)
* C-x r SPC:                             Position Registers.  (line  13)
* C-x r t:                               Rectangles.          (line 104)
* C-x r w:                               Configuration Registers.
                                                              (line   6)
* C-x r y:                               Rectangles.          (line  79)
* C-x RET:                               International Chars. (line  34)
* C-x RET c:                             Text Coding.         (line  42)
* C-x RET C-\:                           Select Input Method. (line  25)
* C-x RET f:                             Text Coding.         (line  26)
* C-x RET F:                             File Name Coding.    (line  10)
* C-x RET k:                             Terminal Coding.     (line  28)
* C-x RET p:                             Communication Coding.
                                                              (line  43)
* C-x RET r:                             Text Coding.         (line  72)
* C-x RET t:                             Terminal Coding.     (line  14)
* C-x RET x:                             Communication Coding.
                                                              (line  24)
* C-x RET X:                             Communication Coding.
                                                              (line  24)
* C-x RIGHT:                             Select Buffer.       (line  48)
* C-x s:                                 Save Commands.       (line  39)
* C-x TAB:                               Indentation Commands.
                                                              (line  52)
* C-x TAB (Enriched mode):               Enriched Indentation.
                                                              (line  13)
* C-x u:                                 Undo.                (line  21)
* C-x v +:                               Pulling / Pushing.   (line  39)
* C-x v =:                               Old Revisions.       (line  30)
* C-x v a:                               Change Logs and VC.  (line  19)
* C-x v D:                               Old Revisions.       (line  59)
* C-x v d:                               VC Directory Mode.   (line  15)
* C-x v g:                               Old Revisions.       (line  80)
* C-x v G:                               VC Ignore.           (line  10)
* C-x v h:                               VC Change Log.       (line 107)
* C-x v i:                               Registering.         (line   9)
* C-x v l:                               VC Change Log.       (line  18)
* C-x v P:                               Pulling / Pushing.   (line  19)
* C-x v r:                               Revision Tags.       (line  23)
* C-x v s:                               Revision Tags.       (line  18)
* C-x v u:                               VC Undo.             (line  10)
* C-x v v:                               Basic VC Editing.    (line  27)
* C-x v ~:                               Old Revisions.       (line  75)
* C-x w .:                               Highlight Interactively.
                                                              (line  71)
* C-x w b:                               Highlight Interactively.
                                                              (line  76)
* C-x w h:                               Highlight Interactively.
                                                              (line  28)
* C-x w i:                               Highlight Interactively.
                                                              (line  88)
* C-x w l:                               Highlight Interactively.
                                                              (line  59)
* C-x w p:                               Highlight Interactively.
                                                              (line  64)
* C-x w r:                               Highlight Interactively.
                                                              (line  48)
* C-x z:                                 Repeating.           (line  12)
* C-x [:                                 Pages.               (line  29)
* C-x [ (Calendar mode):                 Calendar Unit Motion.
                                                              (line  34)
* C-x [ (DocView mode):                  DocView Navigation.  (line  15)
* C-x ]:                                 Pages.               (line  29)
* C-x ] (Calendar mode):                 Calendar Unit Motion.
                                                              (line  34)
* C-x ] (DocView mode):                  DocView Navigation.  (line  15)
* C-x ^:                                 Change Window.       (line  45)
* C-x `:                                 Compilation Mode.    (line  51)
* C-x }:                                 Change Window.       (line  45)
* C-y:                                   Yanking.             (line  20)
* C-y (Incremental search):              Isearch Yank.        (line  19)
* C-z:                                   Exiting.             (line  47)
* C-z (X windows):                       Frame Commands.      (line  13)
* C-\:                                   Select Input Method. (line  31)
* C-]:                                   Quitting.            (line  64)
* C-^ (Incremental Search):              Special Isearch.     (line  49)
* C-_:                                   Undo.                (line  21)
* C-_ (Dired):                           Marks vs Flags.      (line 145)
* d (Buffer Menu):                       Several Buffers.     (line  29)
* d (Calendar mode):                     Displaying the Diary.
                                                              (line  29)
* d (Dired):                             Dired Deletion.      (line  22)
* D (Dired):                             Operating on Files.  (line  46)
* D (GDB Breakpoints buffer):            Breakpoints Buffer.  (line  19)
* D (GDB speedbar):                      Watch Expressions.   (line  24)
* d (GDB threads buffer):                Threads Buffer.      (line  31)
* d (Rmail):                             Rmail Deletion.      (line  28)
* DEL (and major modes):                 Major Modes.         (line   6)
* DEL (Buffer Menu):                     Several Buffers.     (line  53)
* DEL (Dired):                           Dired Deletion.      (line  34)
* DEL (DocView mode):                    DocView Navigation.  (line  20)
* DEL (Gnus Group mode):                 Gnus Group Buffer.   (line  42)
* DEL (Gnus Summary mode):               Gnus Summary Buffer. (line  18)
* DEL (MS-DOS):                          MS-DOS Keyboard.     (line   6)
* DEL (programming modes):               Program Modes.       (line  30)
* DEL (Rmail):                           Rmail Scrolling.     (line  22)
* DEL (View mode):                       View Mode.           (line   6)
* DOWN:                                  Moving Point.        (line  36)
* DOWN (minibuffer history):             Minibuffer History.  (line  53)
* e (Dired):                             Dired Visiting.      (line  19)
* e (Rmail):                             Rmail Editing.       (line  15)
* e (View mode):                         View Mode.           (line  12)
* END:                                   Moving Point.        (line  51)
* ESC ESC ESC:                           Quitting.            (line  72)
* f (Buffer Menu):                       Several Buffers.     (line  95)
* f (Dired):                             Dired Visiting.      (line  13)
* f (GDB threads buffer):                Threads Buffer.      (line  35)
* f (Rmail):                             Rmail Reply.         (line  69)
* F1:                                    Help.                (line   6)
* F10:                                   Menu Bar.            (line  22)
* F11:                                   Frame Commands.      (line  29)
* F2 1:                                  Two-Column.          (line  51)
* F2 2:                                  Two-Column.          (line  12)
* F2 b:                                  Two-Column.          (line  32)
* F2 d:                                  Two-Column.          (line  56)
* F2 RET:                                Two-Column.          (line  47)
* F2 s:                                  Two-Column.          (line  21)
* F3:                                    Basic Keyboard Macro.
                                                              (line  23)
* F4:                                    Basic Keyboard Macro.
                                                              (line  23)
* G (Dired):                             Operating on Files.  (line  81)
* g (Dired):                             Dired Updating.      (line  30)
* g (Rmail):                             Rmail Files.         (line  51)
* g CHAR (Calendar mode):                From Other Calendar. (line  11)
* g d (Calendar mode):                   Specified Dates.     (line  21)
* g D (Calendar mode):                   Specified Dates.     (line  26)
* g m (Calendar mode):                   Mayan Calendar.      (line  36)
* g w (Calendar mode):                   Specified Dates.     (line  26)
* H (Calendar mode):                     Writing Calendar Files.
                                                              (line  23)
* h (Calendar mode):                     Holidays.            (line  26)
* H (Dired):                             Operating on Files.  (line  64)
* h (Rmail):                             Rmail Make Summary.  (line  31)
* HOME:                                  Moving Point.        (line  47)
* i (Dired):                             Subdirectories in Dired.
                                                              (line  18)
* i (Rmail):                             Rmail Files.         (line  22)
* i a (Calendar mode):                   Special Diary Entries.
                                                              (line  27)
* i b (Calendar mode):                   Special Diary Entries.
                                                              (line  50)
* i c (Calendar mode):                   Special Diary Entries.
                                                              (line  55)
* i d (Calendar mode):                   Adding to Diary.     (line  25)
* i m (Calendar mode):                   Adding to Diary.     (line  31)
* i w (Calendar mode):                   Adding to Diary.     (line  31)
* i y (Calendar mode):                   Adding to Diary.     (line  31)
* INSERT:                                Minor Modes.         (line  88)
* j (Dired):                             Dired Navigation.    (line  17)
* j (Rmail):                             Rmail Motion.        (line  80)
* k (Dired):                             Dired Updating.      (line  52)
* k (Rmail):                             Rmail Labels.        (line  31)
* L (Dired):                             Operating on Files.  (line 135)
* l (Dired):                             Dired Updating.      (line  35)
* l (GDB threads buffer):                Threads Buffer.      (line  39)
* l (Gnus Group mode):                   Gnus Group Buffer.   (line  12)
* L (Gnus Group mode):                   Gnus Group Buffer.   (line  18)
* l (Help mode):                         Help Mode.           (line  29)
* l (Rmail):                             Rmail Make Summary.  (line  36)
* LEFT:                                  Moving Point.        (line  30)
* LEFT, and bidirectional text:          Bidirectional Editing.
                                                              (line  70)
* m (Buffer Menu):                       Several Buffers.     (line 121)
* M (Calendar mode):                     Lunar Phases.        (line  18)
* m (Calendar mode):                     Displaying the Diary.
                                                              (line  44)
* m (Dired):                             Marks vs Flags.      (line  17)
* M (Dired):                             Operating on Files.  (line  76)
* m (Rmail):                             Rmail Reply.         (line 102)
* M-!:                                   Single Shell.        (line   6)
* M-$:                                   Spelling.            (line  44)
* M-$ (Dired):                           Hiding Subdirectories.
                                                              (line  15)
* M-%:                                   Query Replace.       (line  11)
* M-% (Incremental search):              Special Isearch.     (line  69)
* M-&:                                   Single Shell.        (line  36)
* M-':                                   Expanding Abbrevs.   (line  34)
* M-,:                                   Looking Up Identifiers.
                                                              (line  57)
* M--:                                   Arguments.           (line  15)
* M-- M-c:                               Fixing Case.         (line  14)
* M-- M-l:                               Fixing Case.         (line  14)
* M-- M-u:                               Fixing Case.         (line  14)
* M-.:                                   Looking Up Identifiers.
                                                              (line  25)
* M-/:                                   Dynamic Abbrevs.     (line  12)
* M-1:                                   Arguments.           (line  15)
* M-;:                                   Comment Commands.    (line  29)
* M-<:                                   Moving Point.        (line  85)
* M-< (Calendar mode):                   Move to Beginning or End.
                                                              (line  17)
* M-< (DocView mode):                    DocView Navigation.  (line  25)
* M-=:                                   Position Info.       (line  45)
* M-= (Calendar mode):                   Counting Days.       (line  10)
* M->:                                   Moving Point.        (line  90)
* M-> (Calendar mode):                   Move to Beginning or End.
                                                              (line  19)
* M-> (DocView mode):                    DocView Navigation.  (line  25)
* M-?:                                   Identifier Search.   (line  26)
* M-? (Nroff mode):                      Nroff Mode.          (line  16)
* M-? (Shell mode):                      Shell Mode.          (line  28)
* M-@:                                   Marking Objects.     (line  29)
* M-@ <1>:                               Words.               (line  55)
* M-a:                                   Sentences.           (line  18)
* M-a (C mode):                          Motion in C.         (line  38)
* M-a (Calendar mode):                   Move to Beginning or End.
                                                              (line  13)
* M-b:                                   Words.               (line  26)
* M-c:                                   Case.                (line  20)
* M-c (Incremental search):              Lax Search.          (line  59)
* M-colon:                               Lisp Eval.           (line  30)
* M-d:                                   Words.               (line  34)
* M-DEL:                                 Words.               (line  42)
* M-DEL (Buffer Menu):                   Several Buffers.     (line  57)
* M-DEL (Dired):                         Marks vs Flags.      (line  68)
* M-DOWN (Org Mode):                     Org Mode.            (line  29)
* M-Drag-mouse-1:                        Secondary Selection. (line  11)
* M-e:                                   Sentences.           (line  18)
* M-e (C mode):                          Motion in C.         (line  48)
* M-e (Calendar mode):                   Move to Beginning or End.
                                                              (line  15)
* M-e (Incremental search):              Repeat Isearch.      (line  49)
* M-f:                                   Words.               (line  26)
* M-F10:                                 Frame Commands.      (line  25)
* M-g c:                                 Moving Point.        (line 108)
* M-g g:                                 Moving Point.        (line 113)
* M-g M-g:                               Moving Point.        (line 113)
* M-g M-n:                               Compilation Mode.    (line  51)
* M-g n:                                 Compilation Mode.    (line  51)
* M-g TAB:                               Moving Point.        (line 122)
* M-h:                                   Paragraphs.          (line  23)
* M-i:                                   Indentation Commands.
                                                              (line  22)
* M-j:                                   Multi-Line Comments. (line   6)
* M-j b (Enriched mode):                 Enriched Justification.
                                                              (line  17)
* M-j c (Enriched mode):                 Enriched Justification.
                                                              (line  21)
* M-j l (Enriched mode):                 Enriched Justification.
                                                              (line  11)
* M-j r (Enriched mode):                 Enriched Justification.
                                                              (line  14)
* M-j u (Enriched mode):                 Enriched Justification.
                                                              (line  25)
* M-k:                                   Sentences.           (line  29)
* M-l:                                   Case.                (line  20)
* M-LEFT:                                Moving Point.        (line  69)
* M-LEFT (Org Mode):                     Org Mode.            (line  29)
* M-m:                                   Indentation Commands.
                                                              (line  16)
* M-m (Rmail):                           Rmail Reply.         (line  58)
* M-mouse-1:                             Secondary Selection. (line  21)
* M-mouse-2:                             Secondary Selection. (line  30)
* M-mouse-3:                             Secondary Selection. (line  24)
* M-n (Incremental search):              Repeat Isearch.      (line  41)
* M-n (Log Edit mode):                   Log Buffer.          (line  56)
* M-n (Man mode):                        Man Page.            (line  31)
* M-n (minibuffer history):              Minibuffer History.  (line  30)
* M-n (Nroff mode):                      Nroff Mode.          (line  16)
* M-n (Rmail):                           Rmail Motion.        (line  45)
* M-n (Shell mode):                      Shell Ring.          (line  11)
* M-o b (Enriched mode):                 Enriched Faces.      (line  15)
* M-o d (Enriched mode):                 Enriched Faces.      (line  12)
* M-o i (Enriched mode):                 Enriched Faces.      (line  18)
* M-o l (Enriched mode):                 Enriched Faces.      (line  21)
* M-o M-s (Text mode):                   Fill Commands.       (line  46)
* M-o o (Enriched mode):                 Enriched Faces.      (line  28)
* M-o u (Enriched mode):                 Enriched Faces.      (line  25)
* M-p (Incremental search):              Repeat Isearch.      (line  41)
* M-p (Log Edit mode):                   Log Buffer.          (line  56)
* M-p (Man mode):                        Man Page.            (line  31)
* M-p (minibuffer history):              Minibuffer History.  (line  30)
* M-p (Nroff mode):                      Nroff Mode.          (line  16)
* M-p (Rmail):                           Rmail Motion.        (line  45)
* M-p (Shell mode):                      Shell Ring.          (line   6)
* M-q:                                   Fill Commands.       (line  17)
* M-q (C mode):                          Other C Commands.    (line  29)
* M-q (Fortran mode):                    ForIndent Commands.  (line  35)
* M-r:                                   Moving Point.        (line  74)
* M-r (Gnus Summary mode):               Gnus Summary Buffer. (line  40)
* M-r (Incremental Search):              Special Isearch.     (line  28)
* M-r (Log Edit mode):                   Log Buffer.          (line  56)
* M-r (minibuffer history):              Minibuffer History.  (line  61)
* M-r (Shell mode):                      Shell Ring.          (line  16)
* M-RIGHT:                               Moving Point.        (line  59)
* M-RIGHT (Org Mode):                    Org Mode.            (line  29)
* M-s ' (Incremental Search):            Lax Search.          (line  87)
* M-S (Enriched mode):                   Enriched Justification.
                                                              (line  21)
* M-s (Gnus Summary mode):               Gnus Summary Buffer. (line  36)
* M-s (Log Edit mode):                   Log Buffer.          (line  56)
* M-s (minibuffer history):              Minibuffer History.  (line  61)
* M-s (Rmail):                           Rmail Motion.        (line  58)
* M-s .:                                 Symbol Search.       (line  26)
* M-s a C-s (Dired):                     Misc Dired Features. (line  10)
* M-s a M-C-s (Dired):                   Misc Dired Features. (line  10)
* M-s c (Incremental search):            Lax Search.          (line  59)
* M-s C-e (Incremental search):          Isearch Yank.        (line  15)
* M-s f C-s (Dired):                     Dired Navigation.    (line  21)
* M-s f M-C-s (Dired):                   Dired Navigation.    (line  21)
* M-s h .:                               Highlight Interactively.
                                                              (line  71)
* M-s h f:                               Highlight Interactively.
                                                              (line  88)
* M-s h l:                               Highlight Interactively.
                                                              (line  59)
* M-s h p:                               Highlight Interactively.
                                                              (line  64)
* M-s h r:                               Highlight Interactively.
                                                              (line  28)
* M-s h r (Incremental Search):          Special Isearch.     (line  82)
* M-s h u:                               Highlight Interactively.
                                                              (line  48)
* M-s h w:                               Highlight Interactively.
                                                              (line  76)
* M-s i (Incremental search):            Special Isearch.     (line  24)
* M-s M-w:                               Word Search.         (line  53)
* M-s o:                                 Other Repeating Search.
                                                              (line  42)
* M-s o (Incremental Search):            Special Isearch.     (line  65)
* M-s r (Incremental Search):            Special Isearch.     (line  28)
* M-s SPC (Incremental search):          Lax Search.          (line  15)
* M-s w:                                 Word Search.         (line  27)
* M-s _:                                 Symbol Search.       (line  26)
* M-SPC:                                 Deletion.            (line  40)
* M-t:                                   Transpose.           (line  27)
* M-TAB:                                 Symbol Completion.   (line   9)
* M-TAB (customization buffer):          Changing a Variable. (line  53)
* M-TAB (Incremental search):            Special Isearch.     (line  74)
* M-TAB (Picture mode):                  Tabs in Picture.     (line   6)
* M-TAB (Text mode):                     Text Mode.           (line  36)
* M-TAB, (MS-Windows):                   Windows Keyboard.    (line  44)
* M-u:                                   Case.                (line  20)
* M-UP (Org Mode):                       Org Mode.            (line  29)
* M-v:                                   Moving Point.        (line 103)
* M-v <1>:                               Scrolling.           (line  38)
* M-v (Calendar mode):                   Scroll Calendar.     (line  32)
* M-w:                                   Other Kill Commands. (line  26)
* M-x:                                   M-x.                 (line  17)
* M-y:                                   Earlier Kills.       (line  11)
* M-y (Incremental search):              Isearch Yank.        (line  19)
* M-z:                                   Other Kill Commands. (line  40)
* M-\:                                   Deletion.            (line  40)
* M-^:                                   Indentation Commands.
                                                              (line  32)
* M-^ (Fortran mode):                    ForIndent Commands.  (line  31)
* M-`:                                   Menu Bar.            (line  31)
* M-{:                                   Paragraphs.          (line  17)
* M-{ (Calendar mode):                   Calendar Unit Motion.
                                                              (line  34)
* M-{ (Dired):                           Marks vs Flags.      (line  86)
* M-|:                                   Single Shell.        (line  55)
* M-}:                                   Paragraphs.          (line  17)
* M-} (Calendar mode):                   Calendar Unit Motion.
                                                              (line  34)
* M-} (Dired):                           Marks vs Flags.      (line  80)
* M-~:                                   Save Commands.       (line  71)
* mouse-1:                               Mouse Commands.      (line   6)
* mouse-1 (mode line):                   Mode Line Mouse.     (line  16)
* mouse-1 (on buttons):                  Mouse References.    (line   6)
* mouse-1 (scroll bar):                  Mode Line Mouse.     (line  35)
* mouse-1 in the minibuffer (Incremental Search): Repeat Isearch.
                                                              (line  49)
* mouse-2:                               Mouse Commands.      (line   6)
* mouse-2 (GDB Breakpoints buffer):      Breakpoints Buffer.  (line  26)
* mouse-2 (mode line):                   Mode Line Mouse.     (line  24)
* mouse-2 (on buttons):                  Mouse References.    (line   6)
* mouse-2 in the minibuffer (Incremental search): Isearch Yank.
                                                              (line  19)
* mouse-3:                               Mouse Commands.      (line   6)
* mouse-3 (mode line):                   Mode Line Mouse.     (line  28)
* n (DocView mode):                      DocView Navigation.  (line  15)
* n (Gnus Group mode):                   Gnus Group Buffer.   (line  46)
* n (Gnus Summary mode):                 Gnus Summary Buffer. (line  22)
* n (Rmail):                             Rmail Motion.        (line  45)
* next:                                  Moving Point.        (line  96)
* next <1>:                              Scrolling.           (line  38)
* next (Calendar mode):                  Scroll Calendar.     (line  32)
* next (DocView mode):                   DocView Navigation.  (line  15)
* o (Buffer Menu):                       Several Buffers.     (line  99)
* o (Calendar mode):                     Specified Dates.     (line  30)
* o (Dired):                             Dired Visiting.      (line  22)
* O (Dired):                             Operating on Files.  (line  85)
* o (Occur mode):                        Other Repeating Search.
                                                              (line  63)
* o (Rmail):                             Rmail Output.        (line  21)
* p (Calendar mode):                     To Other Calendar.   (line   9)
* P (Dired):                             Operating on Files.  (line  99)
* p (DocView mode):                      DocView Navigation.  (line  15)
* p (Gnus Group mode):                   Gnus Group Buffer.   (line  50)
* p (Gnus Summary mode):                 Gnus Summary Buffer. (line  26)
* p (Rmail):                             Rmail Motion.        (line  45)
* p d (Calendar mode):                   General Calendar.    (line  19)
* PageDown:                              Moving Point.        (line  96)
* PageDown <1>:                          Scrolling.           (line  38)
* PageDown (Calendar mode):              Scroll Calendar.     (line  32)
* PageDown (DocView mode):               DocView Navigation.  (line  15)
* PageUp:                                Moving Point.        (line 103)
* PageUp <1>:                            Scrolling.           (line  38)
* PageUp (Calendar mode):                Scroll Calendar.     (line  32)
* PageUp (DocView mode):                 DocView Navigation.  (line  15)
* prior:                                 Moving Point.        (line 103)
* prior <1>:                             Scrolling.           (line  38)
* prior (Calendar mode):                 Scroll Calendar.     (line  32)
* prior (DocView mode):                  DocView Navigation.  (line  15)
* q (Buffer Menu):                       Several Buffers.     (line  90)
* q (Calendar mode):                     General Calendar.    (line  33)
* q (Dired):                             Dired Enter.         (line  55)
* Q (Dired):                             Operating on Files.  (line 159)
* q (Gnus Group mode):                   Gnus Group Buffer.   (line  54)
* q (Gnus Summary mode):                 Gnus Summary Buffer. (line  44)
* Q (Rmail summary):                     Rmail Summary Edit.  (line  93)
* q (Rmail summary):                     Rmail Summary Edit.  (line  93)
* q (Rmail):                             Rmail Basics.        (line  36)
* q (View mode):                         View Mode.           (line  12)
* R (Dired):                             Operating on Files.  (line  54)
* r (GDB threads buffer):                Threads Buffer.      (line  43)
* r (Help mode):                         Help Mode.           (line  29)
* r (Rmail):                             Rmail Reply.         (line  28)
* RET:                                   Inserting Text.      (line  12)
* RET (Buffer Menu):                     Several Buffers.     (line  95)
* RET (completion in minibuffer):        Completion Exit.     (line   6)
* RET (Dired):                           Dired Visiting.      (line  19)
* RET (GDB Breakpoints buffer):          Breakpoints Buffer.  (line  22)
* RET (GDB speedbar):                    Watch Expressions.   (line  27)
* RET (Help mode):                       Help Mode.           (line  29)
* RET (Occur mode):                      Other Repeating Search.
                                                              (line  63)
* RET (Shell mode):                      Shell Mode.          (line  12)
* RIGHT:                                 Moving Point.        (line  22)
* RIGHT, and bidirectional text:         Bidirectional Editing.
                                                              (line  70)
* s (Buffer Menu):                       Several Buffers.     (line  39)
* S (Buffer Menu):                       Several Buffers.     (line 134)
* S (Calendar mode):                     Sunrise/Sunset.      (line  20)
* s (Calendar mode):                     Displaying the Diary.
                                                              (line  62)
* S (Dired):                             Operating on Files.  (line  70)
* s (Dired):                             Dired Updating.      (line  68)
* s (Gnus Summary mode):                 Gnus Summary Buffer. (line  30)
* s (Rmail):                             Rmail Basics.        (line  29)
* s (View mode):                         View Mode.           (line   6)
* S-mouse-2:                             Hideshow.            (line  20)
* S-mouse-3 (FFAP):                      FFAP.                (line  53)
* S-SPC (Rmail):                         Rmail Scrolling.     (line  22)
* S-TAB (customization buffer):          Customization Groups.
                                                              (line  49)
* S-TAB (Help mode):                     Help Mode.           (line  43)
* S-TAB (Org Mode):                      Org Mode.            (line  24)
* SPC (Calendar mode):                   General Calendar.    (line  28)
* SPC (completion):                      Completion Commands. (line  27)
* SPC (Dired):                           Dired Navigation.    (line  11)
* SPC (DocView mode):                    DocView Navigation.  (line  20)
* SPC (GDB Breakpoints buffer):          Breakpoints Buffer.  (line  13)
* SPC (Gnus Group mode):                 Gnus Group Buffer.   (line   8)
* SPC (Gnus Summary mode):               Gnus Summary Buffer. (line   8)
* SPC (Incremental search):              Lax Search.          (line  15)
* SPC (Rmail):                           Rmail Scrolling.     (line  22)
* SPC (View mode):                       View Mode.           (line   6)
* t (Buffer Menu):                       Several Buffers.     (line  83)
* T (Buffer Menu):                       Several Buffers.     (line 139)
* t (Calendar mode):                     Writing Calendar Files.
                                                              (line  39)
* t (Dired):                             Marks vs Flags.      (line  91)
* T (Dired):                             Operating on Files.  (line  94)
* t (Rmail):                             Rmail Display.       (line  12)
* TAB (and major modes):                 Major Modes.         (line   6)
* TAB (completion example):              Completion Example.  (line   6)
* TAB (completion):                      Completion Commands. (line  22)
* TAB (customization buffer):            Customization Groups.
                                                              (line  49)
* TAB (GUD):                             Commands of GUD.     (line  97)
* TAB (Help mode):                       Help Mode.           (line  43)
* TAB (indentation):                     Indentation.         (line  13)
* TAB (Message mode):                    Header Editing.      (line  38)
* TAB (Org Mode):                        Org Mode.            (line  16)
* TAB (programming modes):               Basic Indent.        (line  11)
* TAB (Shell mode):                      Shell Mode.          (line  20)
* TAB (Text mode):                       Text Mode.           (line  16)
* u (Buffer Menu):                       Several Buffers.     (line  48)
* U (Buffer Menu):                       Several Buffers.     (line  63)
* u (Calendar mode):                     Holidays.            (line  32)
* u (Dired deletion):                    Dired Deletion.      (line  34)
* u (Dired):                             Marks vs Flags.      (line  46)
* U (Dired):                             Marks vs Flags.      (line  63)
* u (Gnus Group mode):                   Gnus Group Buffer.   (line  30)
* u (Rmail):                             Rmail Deletion.      (line  43)
* UP:                                    Moving Point.        (line  42)
* UP (minibuffer history):               Minibuffer History.  (line  53)
* v (Buffer Menu):                       Several Buffers.     (line 127)
* v (Dired):                             Dired Visiting.      (line  39)
* v (Rmail):                             Rmail Display.       (line  55)
* w (Dired):                             Misc Dired Features. (line  18)
* W (Dired):                             Misc Dired Features. (line  34)
* w (Rmail):                             Rmail Output.        (line  33)
* x (Buffer Menu):                       Several Buffers.     (line  45)
* x (Calendar mode):                     Holidays.            (line  32)
* x (Dired):                             Dired Deletion.      (line  44)
* X (Dired):                             Shell Commands in Dired.
                                                              (line   6)
* x (Rmail):                             Rmail Deletion.      (line  43)
* Z (Dired):                             Operating on Files.  (line 106)


File: emacs-ja.info,  Node: Option Index,  Next: Command Index,  Prev: Key Index,  Up: Top

Command-Line Options Index
**************************

 [index ]
* Menu:

* +LINENUM:                              Action Arguments.    (line  30)
* --background-color:                    Colors X.            (line  18)
* --basic-display:                       Misc X.              (line  25)
* --batch:                               Initial Options.     (line  43)
* --border-color:                        Colors X.            (line  22)
* --border-width:                        Borders X.           (line  21)
* --chdir:                               Initial Options.     (line  20)
* --color:                               Colors X.            (line  37)
* --cursor-color:                        Colors X.            (line  26)
* --daemon:                              Initial Options.     (line 114)
* --debug-init:                          Initial Options.     (line 134)
* --directory:                           Action Arguments.    (line  49)
* --display:                             Initial Options.     (line  32)
* --eval:                                Action Arguments.    (line  65)
* --execute:                             Action Arguments.    (line  66)
* --file:                                Action Arguments.    (line   9)
* --find-file:                           Action Arguments.    (line  10)
* --font:                                Font X.              (line  11)
* --foreground-color:                    Colors X.            (line  13)
* --fullheight:                          Window Size X.       (line  32)
* --fullscreen:                          Window Size X.       (line  18)
* --fullwidth:                           Window Size X.       (line  36)
* --funcall:                             Action Arguments.    (line  59)
* --geometry:                            Window Size X.       (line  11)
* --help:                                Action Arguments.    (line  80)
* --iconic:                              Icons X.             (line   7)
* --insert:                              Action Arguments.    (line  69)
* --internal-border:                     Borders X.           (line  16)
* --kill:                                Action Arguments.    (line  77)
* --line-spacing:                        Misc X.              (line  17)
* --load:                                Action Arguments.    (line  38)
* --maximized:                           Window Size X.       (line  25)
* --module-assertions:                   Initial Options.     (line 139)
* --mouse-color:                         Colors X.            (line  29)
* --name:                                Resources.           (line  59)
* --no-bitmap-icon:                      Icons X.             (line  12)
* --no-blinking-cursor:                  Misc X.              (line  21)
* --no-build-details:                    Initial Options.     (line  80)
* --no-desktop:                          Initial Options.     (line 125)
* --no-init-file:                        Initial Options.     (line  85)
* --no-site-file:                        Initial Options.     (line  91)
* --no-site-lisp:                        Initial Options.     (line  96)
* --no-splash:                           Initial Options.     (line 100)
* --no-window-system:                    Initial Options.     (line  38)
* --quick:                               Initial Options.     (line 106)
* --reverse-video:                       Colors X.            (line  34)
* --script:                              Initial Options.     (line  68)
* --terminal:                            Initial Options.     (line  27)
* --title:                               Title X.             (line  16)
* --user:                                Initial Options.     (line 130)
* --version:                             Action Arguments.    (line  84)
* --vertical-scroll-bars:                Misc X.              (line  13)
* --visit:                               Action Arguments.    (line  11)
* --xrm:                                 Resources.           (line  76)
* -bd:                                   Colors X.            (line  21)
* -bg:                                   Colors X.            (line  17)
* -bw:                                   Borders X.           (line  20)
* -chdir:                                Initial Options.     (line  19)
* -cr:                                   Colors X.            (line  25)
* -d:                                    Initial Options.     (line  31)
* -D:                                    Misc X.              (line  24)
* -daemon:                               Initial Options.     (line 113)
* -f:                                    Action Arguments.    (line  58)
* -fg:                                   Colors X.            (line  12)
* -fh:                                   Window Size X.       (line  31)
* -fn:                                   Font X.              (line  10)
* -fs:                                   Window Size X.       (line  17)
* -fw:                                   Window Size X.       (line  35)
* -g:                                    Window Size X.       (line  10)
* -ib:                                   Borders X.           (line  15)
* -l:                                    Action Arguments.    (line  37)
* -L:                                    Action Arguments.    (line  48)
* -lsp:                                  Misc X.              (line  16)
* -mm:                                   Window Size X.       (line  24)
* -ms:                                   Colors X.            (line  28)
* -nbc:                                  Misc X.              (line  20)
* -nbi:                                  Icons X.             (line  11)
* -nw:                                   Initial Options.     (line  37)
* -q:                                    Initial Options.     (line  84)
* -Q:                                    Initial Options.     (line 105)
* -r:                                    Colors X.            (line  32)
* -rv:                                   Colors X.            (line  33)
* -t:                                    Initial Options.     (line  26)
* -T:                                    Title X.             (line  15)
* -u:                                    Initial Options.     (line 129)
* -vb:                                   Misc X.              (line  12)


File: emacs-ja.info,  Node: Command Index,  Next: Variable Index,  Prev: Option Index,  Up: Top

Command and Function Index
**************************

 [index ]
* Menu:

* 2C-associate-buffer:                   Two-Column.          (line  32)
* 2C-dissociate:                         Two-Column.          (line  56)
* 2C-merge:                              Two-Column.          (line  51)
* 2C-newline:                            Two-Column.          (line  47)
* 2C-split:                              Two-Column.          (line  21)
* 2C-two-columns:                        Two-Column.          (line  12)
* 5x5:                                   Amusements.          (line   9)
* abbrev-mode:                           Abbrev Concepts.     (line  12)
* abbrev-prefix-mark:                    Expanding Abbrevs.   (line  34)
* abort-recursive-edit:                  Quitting.            (line  64)
* add-change-log-entry-other-window:     Change Log Commands. (line   6)
* add-change-log-entry-other-window, in Diff mode: Diff Mode. (line 116)
* add-dir-local-variable:                Directory Variables. (line  59)
* add-file-local-variable:               Specifying File Variables.
                                                              (line  76)
* add-file-local-variable-prop-line:     Specifying File Variables.
                                                              (line  17)
* add-global-abbrev:                     Defining Abbrevs.    (line  31)
* add-hook:                              Hooks.               (line  30)
* add-mode-abbrev:                       Defining Abbrevs.    (line  42)
* add-name-to-file:                      Copying and Naming.  (line  42)
* add-untranslated-filesystem:           Text and Binary.     (line  49)
* animate-birthday-present:              Amusements.          (line   6)
* append-next-kill:                      Appending Kills.     (line  36)
* append-to-buffer:                      Accumulating Text.   (line   6)
* append-to-file:                        Accumulating Text.   (line   6)
* append-to-register:                    Text Registers.      (line  34)
* apply-macro-to-region-lines:           Basic Keyboard Macro.
                                                              (line  75)
* appt-activate:                         Appointments.        (line  20)
* appt-add:                              Appointments.        (line  57)
* appt-delete:                           Appointments.        (line  57)
* apropos:                               Apropos.             (line  20)
* apropos-command:                       Apropos.             (line  16)
* apropos-documentation:                 Apropos.             (line  44)
* apropos-local-value:                   Apropos.             (line  40)
* apropos-local-variable:                Apropos.             (line  32)
* apropos-user-option:                   Apropos.             (line  24)
* apropos-value:                         Apropos.             (line  35)
* apropos-variable:                      Apropos.             (line  28)
* ask-user-about-lock:                   Interlocking.        (line  17)
* async-shell-command:                   Single Shell.        (line  36)
* auto-compression-mode:                 Compressed Files.    (line  16)
* auto-fill-mode:                        Auto Fill.           (line  16)
* auto-revert-mode:                      Reverting.           (line  35)
* auto-revert-tail-mode:                 Reverting.           (line  35)
* auto-save-mode:                        Auto Save Control.   (line   6)
* back-to-indentation:                   Indentation Commands.
                                                              (line  16)
* backward-button:                       Help Mode.           (line  43)
* backward-char:                         Moving Point.        (line  27)
* backward-delete-char-untabify:         Program Modes.       (line  30)
* backward-kill-sentence:                Sentences.           (line  35)
* backward-kill-word:                    Words.               (line  42)
* backward-list:                         Moving by Parens.    (line  29)
* backward-page:                         Pages.               (line  29)
* backward-paragraph:                    Paragraphs.          (line  17)
* backward-sentence:                     Sentences.           (line  18)
* backward-sexp:                         Expressions.         (line  24)
* backward-up-list:                      Moving by Parens.    (line  33)
* backward-word:                         Words.               (line  26)
* balance-windows:                       Change Window.       (line  69)
* beginning-of-buffer:                   Moving Point.        (line  85)
* beginning-of-defun:                    Moving by Defuns.    (line  17)
* beginning-of-visual-line:              Visual Line Mode.    (line  22)
* bibtex-mode:                           TeX Mode.            (line   6)
* binary-overwrite-mode:                 Minor Modes.         (line  97)
* blackbox:                              Amusements.          (line   9)
* blink-cursor-mode:                     Cursor Display.      (line  23)
* bookmark-delete:                       Bookmarks.           (line  83)
* bookmark-insert:                       Bookmarks.           (line  89)
* bookmark-insert-location:              Bookmarks.           (line  86)
* bookmark-jump:                         Bookmarks.           (line  31)
* bookmark-load:                         Bookmarks.           (line  74)
* bookmark-save:                         Bookmarks.           (line  47)
* bookmark-set:                          Bookmarks.           (line  31)
* bookmark-set-no-overwrite:             Bookmarks.           (line  37)
* bookmark-write:                        Bookmarks.           (line  80)
* browse-url:                            Browse-URL.          (line   6)
* browse-url-at-mouse:                   Browse-URL.          (line   6)
* browse-url-at-point:                   Browse-URL.          (line   6)
* browse-url-of-dired-file:              Misc Dired Features. (line  34)
* bs-customize:                          Buffer Menus.        (line  13)
* bs-show:                               Buffer Menus.        (line   6)
* bubbles:                               Amusements.          (line  15)
* buffer-menu:                           Several Buffers.     (line  17)
* Buffer-menu-1-window:                  Several Buffers.     (line 107)
* Buffer-menu-2-window:                  Several Buffers.     (line 111)
* Buffer-menu-backup-unmark:             Several Buffers.     (line  53)
* Buffer-menu-bury:                      Several Buffers.     (line 117)
* Buffer-menu-delete:                    Several Buffers.     (line  29)
* Buffer-menu-delete-backwards:          Several Buffers.     (line  35)
* Buffer-menu-execute:                   Several Buffers.     (line  45)
* Buffer-menu-mark:                      Several Buffers.     (line 121)
* Buffer-menu-not-modified:              Several Buffers.     (line  73)
* buffer-menu-other-window:              Several Buffers.     (line  17)
* Buffer-menu-other-window:              Several Buffers.     (line  99)
* Buffer-menu-save:                      Several Buffers.     (line  39)
* Buffer-menu-select:                    Several Buffers.     (line 127)
* Buffer-menu-switch-other-window:       Several Buffers.     (line 103)
* Buffer-menu-this-window:               Several Buffers.     (line  95)
* Buffer-menu-toggle-files-only:         Several Buffers.     (line 139)
* Buffer-menu-toggle-read-only:          Several Buffers.     (line  78)
* Buffer-menu-unmark:                    Several Buffers.     (line  48)
* Buffer-menu-unmark-all:                Several Buffers.     (line  63)
* Buffer-menu-unmark-all-buffers:        Several Buffers.     (line  57)
* Buffer-menu-visit-tags-table:          Several Buffers.     (line  83)
* butterfly:                             Amusements.          (line  56)
* c-backslash-region:                    Other C Commands.    (line  47)
* c-backward-conditional:                Motion in C.         (line  28)
* c-beginning-of-defun:                  Motion in C.         (line  11)
* c-beginning-of-statement:              Motion in C.         (line  38)
* c-context-line-break:                  Other C Commands.    (line   7)
* c-end-of-defun:                        Motion in C.         (line  11)
* c-end-of-statement:                    Motion in C.         (line  48)
* c-fill-paragraph:                      Other C Commands.    (line  29)
* c-forward-conditional:                 Motion in C.         (line  33)
* c-guess:                               Custom C Indent.     (line  57)
* c-guess-install:                       Custom C Indent.     (line  57)
* c-hungry-delete-backwards:             Hungry Delete.       (line  13)
* c-hungry-delete-forward:               Hungry Delete.       (line  19)
* c-indent-command:                      C Indent.            (line  18)
* c-indent-defun:                        C Indent.            (line   9)
* c-indent-exp:                          C Indent.            (line  13)
* c-macro-expand:                        Other C Commands.    (line  36)
* c-mark-function:                       Moving by Defuns.    (line  29)
* c-set-style:                           Custom C Indent.     (line  26)
* c-show-syntactic-information:          Other C Commands.    (line  66)
* c-toggle-auto-newline:                 Electric C.          (line  29)
* c-toggle-electric-state:               Electric C.          (line  19)
* c-toggle-hungry-state:                 Hungry Delete.       (line  29)
* c-up-conditional:                      Motion in C.         (line  18)
* calendar:                              Calendar/Diary.      (line   6)
* calendar-astro-goto-day-number:        From Other Calendar. (line  11)
* calendar-astro-print-day-number:       To Other Calendar.   (line  18)
* calendar-backward-day:                 Calendar Unit Motion.
                                                              (line  26)
* calendar-backward-month:               Calendar Unit Motion.
                                                              (line  34)
* calendar-backward-week:                Calendar Unit Motion.
                                                              (line  26)
* calendar-backward-year:                Calendar Unit Motion.
                                                              (line  34)
* calendar-bahai-goto-date:              From Other Calendar. (line  11)
* calendar-bahai-print-date:             To Other Calendar.   (line  30)
* calendar-beginning-of-month:           Move to Beginning or End.
                                                              (line  13)
* calendar-beginning-of-week:            Move to Beginning or End.
                                                              (line  10)
* calendar-beginning-of-year:            Move to Beginning or End.
                                                              (line  17)
* calendar-chinese-goto-date:            From Other Calendar. (line  11)
* calendar-chinese-print-date:           To Other Calendar.   (line  33)
* calendar-coptic-goto-date:             From Other Calendar. (line  11)
* calendar-coptic-print-date:            To Other Calendar.   (line  36)
* calendar-count-days-region:            Counting Days.       (line  10)
* calendar-cursor-holidays:              Holidays.            (line  26)
* calendar-end-of-month:                 Move to Beginning or End.
                                                              (line  15)
* calendar-end-of-week:                  Move to Beginning or End.
                                                              (line  11)
* calendar-end-of-year:                  Move to Beginning or End.
                                                              (line  19)
* calendar-ethiopic-goto-date:           From Other Calendar. (line  11)
* calendar-ethiopic-print-date:          To Other Calendar.   (line  39)
* calendar-forward-day:                  Calendar Unit Motion.
                                                              (line  26)
* calendar-forward-month:                Calendar Unit Motion.
                                                              (line  34)
* calendar-forward-week:                 Calendar Unit Motion.
                                                              (line  26)
* calendar-forward-year:                 Calendar Unit Motion.
                                                              (line  34)
* calendar-french-goto-date:             From Other Calendar. (line  11)
* calendar-french-print-date:            To Other Calendar.   (line  27)
* calendar-goto-date:                    Specified Dates.     (line  21)
* calendar-goto-day-of-year:             Specified Dates.     (line  26)
* calendar-goto-today:                   Specified Dates.     (line  33)
* calendar-hebrew-goto-date:             From Other Calendar. (line  11)
* calendar-hebrew-list-yahrzeits:        From Other Calendar. (line  53)
* calendar-hebrew-print-date:            To Other Calendar.   (line  21)
* calendar-islamic-goto-date:            From Other Calendar. (line  11)
* calendar-islamic-print-date:           To Other Calendar.   (line  24)
* calendar-iso-goto-date:                From Other Calendar. (line  11)
* calendar-iso-goto-week:                Specified Dates.     (line  26)
* calendar-iso-print-date:               To Other Calendar.   (line  12)
* calendar-julian-goto-date:             From Other Calendar. (line  11)
* calendar-julian-print-date:            To Other Calendar.   (line  15)
* calendar-list-holidays:                Holidays.            (line  41)
* calendar-lunar-phases:                 Lunar Phases.        (line  18)
* calendar-mark-holidays:                Holidays.            (line  32)
* calendar-mark-today:                   Calendar Customizing.
                                                              (line  40)
* calendar-mayan-goto-long-count-date:   Mayan Calendar.      (line  36)
* calendar-mayan-next-calendar-round-date: Mayan Calendar.    (line  56)
* calendar-mayan-next-haab-date:         Mayan Calendar.      (line  49)
* calendar-mayan-next-tzolkin-date:      Mayan Calendar.      (line  42)
* calendar-mayan-previous-haab-date:     Mayan Calendar.      (line  49)
* calendar-mayan-previous-tzolkin-date:  Mayan Calendar.      (line  42)
* calendar-mayan-print-date:             To Other Calendar.   (line  45)
* calendar-other-month:                  Specified Dates.     (line  30)
* calendar-persian-goto-date:            From Other Calendar. (line  11)
* calendar-persian-print-date:           To Other Calendar.   (line  42)
* calendar-print-day-of-year:            General Calendar.    (line  19)
* calendar-print-other-dates:            To Other Calendar.   (line   9)
* calendar-redraw:                       General Calendar.    (line  24)
* calendar-scroll-left:                  Scroll Calendar.     (line  27)
* calendar-scroll-left-three-months:     Scroll Calendar.     (line  32)
* calendar-scroll-right:                 Scroll Calendar.     (line  27)
* calendar-scroll-right-three-months:    Scroll Calendar.     (line  32)
* calendar-set-date-style:               Date Formats.        (line  43)
* calendar-star-date:                    Calendar Customizing.
                                                              (line  34)
* calendar-sunrise-sunset:               Sunrise/Sunset.      (line  20)
* calendar-unmark:                       Holidays.            (line  32)
* capitalize-word:                       Case.                (line  20)
* cd:                                    File Names.          (line  33)
* center-line:                           Fill Commands.       (line  46)
* change-log-merge:                      Change Log Commands. (line  52)
* change-log-mode:                       Change Log Commands. (line  40)
* check-parens:                          Parentheses.         (line   6)
* choose-completion:                     Completion Commands. (line  47)
* clean-buffer-list:                     Kill Buffer.         (line  49)
* clear-rectangle:                       Rectangles.          (line  90)
* clipboard-kill-region:                 Clipboard.           (line  46)
* clipboard-kill-ring-save:              Clipboard.           (line  46)
* clipboard-yank:                        Clipboard.           (line  46)
* clone-indirect-buffer:                 Indirect Buffers.    (line  13)
* clone-indirect-buffer-other-window:    Indirect Buffers.    (line  17)
* column-number-mode:                    Optional Mode Line.  (line  22)
* comint-bol-or-process-mark:            Shell Mode.          (line  38)
* comint-continue-subjob:                Shell Mode.          (line 121)
* comint-copy-old-input:                 Shell History Copying.
                                                              (line  12)
* comint-delchar-or-maybe-eof:           Shell Mode.          (line  32)
* comint-delete-output:                  Shell Mode.          (line  76)
* comint-dynamic-list-filename...:       Shell Mode.          (line  28)
* comint-dynamic-list-input-ring:        Shell Ring.          (line  29)
* comint-get-next-from-history:          Shell Ring.          (line  21)
* comint-history-isearch-backward-regexp: Shell Ring.         (line  16)
* comint-input-previous-argument:        Shell Ring.          (line  25)
* comint-interrupt-subjob:               Shell Mode.          (line  61)
* comint-kill-input:                     Shell Mode.          (line  53)
* comint-magic-space:                    History References.  (line  16)
* comint-next-input:                     Shell Ring.          (line  11)
* comint-next-prompt:                    Shell History Copying.
                                                              (line   9)
* comint-previous-input:                 Shell Ring.          (line   6)
* comint-previous-prompt:                Shell History Copying.
                                                              (line   6)
* comint-quit-subjob:                    Shell Mode.          (line  71)
* comint-run:                            Shell Mode.          (line 152)
* comint-send-input:                     Shell Mode.          (line  12)
* comint-show-maximum-output:            Shell Mode.          (line  91)
* comint-show-output:                    Shell Mode.          (line  87)
* comint-stop-subjob:                    Shell Mode.          (line  66)
* comint-strip-ctrl-m:                   Shell Mode.          (line 125)
* comint-truncate-buffer:                Shell Mode.          (line 134)
* comint-write-output:                   Shell Mode.          (line  81)
* comment-dwim:                          Comment Commands.    (line  29)
* comment-indent-new-line:               Multi-Line Comments. (line   6)
* comment-kill:                          Comment Commands.    (line  72)
* comment-line:                          Comment Commands.    (line  63)
* comment-region:                        Comment Commands.    (line  79)
* comment-set-column:                    Options for Comments.
                                                              (line   6)
* compare-windows:                       Comparing Files.     (line  28)
* compilation-next-error:                Compilation Mode.    (line 110)
* compilation-next-file:                 Compilation Mode.    (line 110)
* compilation-previous-error:            Compilation Mode.    (line 110)
* compilation-previous-file:             Compilation Mode.    (line 110)
* compile:                               Compilation.         (line  22)
* compile (MS-DOS):                      MS-DOS Processes.    (line   6)
* compile-goto-error:                    Compilation Mode.    (line  13)
* completion-at-point, in programming language modes: Symbol Completion.
                                                              (line  15)
* completion-at-point, in Shell Mode:    Shell Mode.          (line  20)
* compose-mail:                          Sending Mail.        (line   6)
* compose-mail-other-frame:              Sending Mail.        (line  34)
* compose-mail-other-window:             Sending Mail.        (line  34)
* copy-dir-locals-to-file-locals:        Specifying File Variables.
                                                              (line  76)
* copy-dir-locals-to-file-locals-prop-line: Specifying File Variables.
                                                              (line  17)
* copy-directory:                        Copying and Naming.  (line  25)
* copy-file:                             Copying and Naming.  (line  22)
* copy-file-locals-to-dir-locals:        Directory Variables. (line  59)
* copy-rectangle-as-kill:                Rectangles.          (line  75)
* copy-rectangle-to-register:            Rectangle Registers. (line   9)
* copy-to-buffer:                        Accumulating Text.   (line   6)
* copy-to-register:                      Text Registers.      (line  26)
* count-lines-page:                      Pages.               (line  49)
* count-words:                           Position Info.       (line  50)
* count-words-region:                    Position Info.       (line  45)
* cpp-highlight-buffer:                  Other C Commands.    (line  57)
* create-fontset-from-fontset-spec:      Defining Fontsets.   (line 107)
* cua-mode:                              CUA Bindings.        (line   6)
* custom-prompt-customize-unsaved-options: Saving Customizations.
                                                              (line  45)
* Custom-save:                           Changing a Variable. (line 137)
* Custom-set:                            Changing a Variable. (line 137)
* customize:                             Easy Customization.  (line  15)
* customize-apropos:                     Specific Customization.
                                                              (line  50)
* customize-browse:                      Browsing Custom.     (line   6)
* customize-changed:                     Specific Customization.
                                                              (line  57)
* customize-create-theme:                Creating Custom Themes.
                                                              (line   6)
* customize-face:                        Specific Customization.
                                                              (line  46)
* customize-group:                       Specific Customization.
                                                              (line  46)
* customize-option:                      Specific Customization.
                                                              (line  40)
* customize-saved:                       Specific Customization.
                                                              (line  64)
* customize-themes:                      Custom Themes.       (line  16)
* customize-unsaved:                     Specific Customization.
                                                              (line  64)
* cwarn-mode:                            Other C Commands.    (line  72)
* cycle-spacing:                         Deletion.            (line  40)
* dabbrev-completion:                    Dynamic Abbrevs.     (line  12)
* dabbrev-expand:                        Dynamic Abbrevs.     (line  12)
* dbx:                                   Starting GUD.        (line  37)
* debug_print:                           Checklist.           (line 249)
* decipher:                              Amusements.          (line  18)
* default-value:                         Locals.              (line  71)
* define-abbrevs:                        Saving Abbrevs.      (line  45)
* define-global-abbrev:                  Defining Abbrevs.    (line  52)
* define-key:                            Init Rebinding.      (line  79)
* define-mode-abbrev:                    Defining Abbrevs.    (line  52)
* delete-backward-char:                  Deletion.            (line   6)
* delete-blank-lines:                    Blank Lines.         (line  13)
* delete-char:                           Deletion.            (line   6)
* delete-dir-local-variable:             Directory Variables. (line  59)
* delete-duplicate-lines:                Deletion.            (line  62)
* delete-file:                           Misc File Ops.       (line  10)
* delete-file-local-variable:            Specifying File Variables.
                                                              (line  76)
* delete-file-local-variable-prop-line:  Specifying File Variables.
                                                              (line  17)
* delete-frame:                          Frame Commands.      (line   9)
* delete-horizontal-space:               Deletion.            (line  40)
* delete-indentation:                    Indentation Commands.
                                                              (line  32)
* delete-other-frames:                   Frame Commands.      (line  21)
* delete-other-windows:                  Change Window.       (line  40)
* delete-rectangle:                      Rectangles.          (line  62)
* delete-selection-mode:                 Using Region.        (line  57)
* delete-trailing-whitespace:            Useless Whitespace.  (line  21)
* delete-whitespace-rectangle:           Rectangles.          (line  94)
* delete-window:                         Change Window.       (line  29)
* describe-bindings:                     Misc Help.           (line  40)
* describe-categories:                   Regexp Backslash.    (line 133)
* describe-character-set:                Charsets.            (line  24)
* describe-coding-system:                Coding Systems.      (line  46)
* describe-copying:                      Help Files.          (line  13)
* describe-distribution:                 Help Files.          (line  13)
* describe-fontset:                      Fontsets.            (line  48)
* describe-function:                     Name Help.           (line   6)
* describe-gnu-project:                  Help Files.          (line  13)
* describe-input-method:                 Select Input Method. (line  16)
* describe-key:                          Key Help.            (line   6)
* describe-key-briefly:                  Key Help.            (line   6)
* describe-language-environment:         Language Environments.
                                                              (line  76)
* describe-mode:                         Misc Help.           (line  35)
* describe-no-warranty:                  Help Files.          (line  13)
* describe-package:                      Package Keywords.    (line  19)
* describe-prefix-bindings:              Misc Help.           (line  47)
* describe-symbol:                       Name Help.           (line  51)
* describe-syntax:                       Misc Help.           (line  40)
* describe-text-properties:              Editing Format Info. (line  20)
* describe-theme:                        Custom Themes.       (line  77)
* describe-variable:                     Name Help.           (line  37)
* desktop-change-dir:                    Saving Emacs Sessions.
                                                              (line  39)
* desktop-clear:                         Saving Emacs Sessions.
                                                              (line  61)
* desktop-revert:                        Saving Emacs Sessions.
                                                              (line  39)
* desktop-save:                          Saving Emacs Sessions.
                                                              (line  29)
* diary:                                 Displaying the Diary.
                                                              (line  65)
* diary-anniversary:                     Special Diary Entries.
                                                              (line  33)
* diary-anniversary, and sexp diary entries: Sexp Diary Entries.
                                                              (line  16)
* diary-astro-day-number:                Sexp Diary Entries.  (line 110)
* diary-bahai-date:                      Sexp Diary Entries.  (line 110)
* diary-bahai-insert-entry:              Non-Gregorian Diary. (line  75)
* diary-bahai-insert-monthly-entry:      Non-Gregorian Diary. (line  75)
* diary-bahai-insert-yearly-entry:       Non-Gregorian Diary. (line  75)
* diary-bahai-list-entries:              Non-Gregorian Diary. (line  13)
* diary-bahai-mark-entries:              Non-Gregorian Diary. (line  13)
* diary-block:                           Special Diary Entries.
                                                              (line  44)
* diary-chinese-date:                    Sexp Diary Entries.  (line 110)
* diary-chinese-insert-anniversary-entry: Non-Gregorian Diary.
                                                              (line  75)
* diary-chinese-insert-entry:            Non-Gregorian Diary. (line  75)
* diary-chinese-insert-monthly-entry:    Non-Gregorian Diary. (line  75)
* diary-chinese-insert-yearly-entry:     Non-Gregorian Diary. (line  75)
* diary-chinese-list-entries:            Non-Gregorian Diary. (line  13)
* diary-chinese-mark-entries:            Non-Gregorian Diary. (line  13)
* diary-coptic-date:                     Sexp Diary Entries.  (line 110)
* diary-cyclic:                          Special Diary Entries.
                                                              (line  60)
* diary-cyclic, and sexp diary entries:  Sexp Diary Entries.  (line  34)
* diary-date:                            Sexp Diary Entries.  (line  52)
* diary-day-of-year:                     Sexp Diary Entries.  (line 110)
* diary-ethiopic-date:                   Sexp Diary Entries.  (line 110)
* diary-fancy-display:                   Diary Display.       (line   6)
* diary-float:                           Special Diary Entries.
                                                              (line  82)
* diary-float, and sexp diary entries:   Sexp Diary Entries.  (line  63)
* diary-french-date:                     Sexp Diary Entries.  (line 110)
* diary-hebrew-birthday:                 Sexp Diary Entries.  (line 159)
* diary-hebrew-date:                     Sexp Diary Entries.  (line 110)
* diary-hebrew-insert-entry:             Non-Gregorian Diary. (line  75)
* diary-hebrew-insert-monthly-entry:     Non-Gregorian Diary. (line  75)
* diary-hebrew-insert-yearly-entry:      Non-Gregorian Diary. (line  75)
* diary-hebrew-list-entries:             Non-Gregorian Diary. (line  13)
* diary-hebrew-mark-entries:             Non-Gregorian Diary. (line  13)
* diary-hebrew-omer:                     Sexp Diary Entries.  (line 159)
* diary-hebrew-parasha:                  Sexp Diary Entries.  (line 159)
* diary-hebrew-rosh-hodesh:              Sexp Diary Entries.  (line 159)
* diary-hebrew-sabbath-candles:          Sexp Diary Entries.  (line 159)
* diary-hebrew-yahrzeit:                 Sexp Diary Entries.  (line 159)
* diary-include-other-diary-files:       Fancy Diary Display. (line  38)
* diary-insert-anniversary-entry:        Special Diary Entries.
                                                              (line  27)
* diary-insert-block-entry:              Special Diary Entries.
                                                              (line  50)
* diary-insert-cyclic-entry:             Special Diary Entries.
                                                              (line  55)
* diary-insert-entry:                    Adding to Diary.     (line  25)
* diary-insert-monthly-entry:            Adding to Diary.     (line  31)
* diary-insert-weekly-entry:             Adding to Diary.     (line  31)
* diary-insert-yearly-entry:             Adding to Diary.     (line  31)
* diary-islamic-date:                    Sexp Diary Entries.  (line 110)
* diary-islamic-insert-entry:            Non-Gregorian Diary. (line  75)
* diary-islamic-insert-monthly-entry:    Non-Gregorian Diary. (line  75)
* diary-islamic-insert-yearly-entry:     Non-Gregorian Diary. (line  75)
* diary-islamic-list-entries:            Non-Gregorian Diary. (line  13)
* diary-islamic-mark-entries:            Non-Gregorian Diary. (line  13)
* diary-iso-date:                        Sexp Diary Entries.  (line 110)
* diary-julian-date:                     Sexp Diary Entries.  (line 110)
* diary-lunar-phases:                    Sexp Diary Entries.  (line 110)
* diary-mail-entries:                    Displaying the Diary.
                                                              (line  74)
* diary-mark-entries:                    Displaying the Diary.
                                                              (line  44)
* diary-mark-included-diary-files:       Fancy Diary Display. (line  38)
* diary-mayan-date:                      Sexp Diary Entries.  (line 110)
* diary-persian-date:                    Sexp Diary Entries.  (line 110)
* diary-print-entries:                   Diary Display.       (line  33)
* diary-remind:                          Sexp Diary Entries.  (line  47)
* diary-show-all-entries:                Displaying the Diary.
                                                              (line  62)
* diary-simple-display:                  Diary Display.       (line   6)
* diary-sort-entries:                    Fancy Diary Display. (line  11)
* diary-sunrise-sunset:                  Sexp Diary Entries.  (line 110)
* diary-view-entries:                    Displaying the Diary.
                                                              (line  29)
* diff:                                  Comparing Files.     (line   6)
* diff-add-change-log-entries-other-window: Diff Mode.        (line 116)
* diff-apply-hunk:                       Diff Mode.           (line  66)
* diff-auto-refine-mode:                 Diff Mode.           (line  35)
* diff-backup:                           Comparing Files.     (line  19)
* diff-buffer-with-file:                 Comparing Files.     (line  24)
* diff-context->unified:                 Diff Mode.           (line 106)
* diff-delete-trailing-whitespace:       Diff Mode.           (line 124)
* diff-ediff-patch:                      Diff Mode.           (line  79)
* diff-file-kill:                        Diff Mode.           (line  62)
* diff-file-next:                        Diff Mode.           (line  51)
* diff-file-prev:                        Diff Mode.           (line  55)
* diff-goto-source:                      Diff Mode.           (line  75)
* diff-hunk-kill:                        Diff Mode.           (line  59)
* diff-hunk-next:                        Diff Mode.           (line  33)
* diff-hunk-prev:                        Diff Mode.           (line  46)
* diff-ignore-whitespace-hunk:           Diff Mode.           (line 112)
* diff-mode:                             Diff Mode.           (line   6)
* diff-refine-hunk:                      Diff Mode.           (line  70)
* diff-restrict-view:                    Diff Mode.           (line  83)
* diff-reverse-direction:                Diff Mode.           (line  89)
* diff-split-hunk:                       Diff Mode.           (line  92)
* diff-unified->context:                 Diff Mode.           (line 101)
* digit-argument:                        Arguments.           (line  15)
* dir-locals-set-class-variables:        Directory Variables. (line  66)
* dir-locals-set-directory-class:        Directory Variables. (line  66)
* dired:                                 Dired Enter.         (line   6)
* dired-at-point:                        FFAP.                (line   6)
* dired-change-marks:                    Marks vs Flags.      (line  96)
* dired-clean-directory:                 Flagging Many Files. (line  38)
* dired-compare-directories:             Misc Dired Features. (line  49)
* dired-copy-filename-as-kill:           Misc Dired Features. (line  18)
* dired-create-directory:                Misc Dired Features. (line   6)
* dired-diff:                            Comparison in Dired. (line   6)
* dired-display-file:                    Dired Visiting.      (line  28)
* dired-do-byte-compile:                 Operating on Files.  (line 139)
* dired-do-chgrp:                        Operating on Files.  (line  81)
* dired-do-chmod:                        Operating on Files.  (line  76)
* dired-do-chown:                        Operating on Files.  (line  85)
* dired-do-compress:                     Operating on Files.  (line 106)
* dired-do-compress-to:                  Operating on Files.  (line 112)
* dired-do-copy:                         Operating on Files.  (line  32)
* dired-do-copy-regexp:                  Transforming File Names.
                                                              (line  35)
* dired-do-delete:                       Operating on Files.  (line  46)
* dired-do-find-regexp:                  Operating on Files.  (line 144)
* dired-do-find-regexp-and-replace:      Operating on Files.  (line 159)
* dired-do-flagged-delete:               Dired Deletion.      (line  44)
* dired-do-hardlink:                     Operating on Files.  (line  64)
* dired-do-hardlink-regexp:              Transforming File Names.
                                                              (line  36)
* dired-do-isearch:                      Misc Dired Features. (line  10)
* dired-do-isearch-regexp:               Misc Dired Features. (line  10)
* dired-do-kill-lines:                   Dired Updating.      (line  52)
* dired-do-load:                         Operating on Files.  (line 135)
* dired-do-print:                        Operating on Files.  (line  99)
* dired-do-redisplay:                    Dired Updating.      (line  35)
* dired-do-rename:                       Operating on Files.  (line  54)
* dired-do-rename-regexp:                Transforming File Names.
                                                              (line  34)
* dired-do-shell-command:                Shell Commands in Dired.
                                                              (line   6)
* dired-do-symlink:                      Operating on Files.  (line  70)
* dired-do-symlink-regexp:               Transforming File Names.
                                                              (line  37)
* dired-do-touch:                        Operating on Files.  (line  94)
* dired-downcase:                        Transforming File Names.
                                                              (line  29)
* dired-find-file:                       Dired Visiting.      (line  13)
* dired-find-file-other-window:          Dired Visiting.      (line  22)
* dired-flag-auto-save-files:            Flagging Many Files. (line  30)
* dired-flag-backup-files:               Flagging Many Files. (line  34)
* dired-flag-file-deletion:              Dired Deletion.      (line  22)
* dired-flag-files-regexp:               Flagging Many Files. (line  56)
* dired-flag-garbage-files:              Flagging Many Files. (line  50)
* dired-goto-file:                       Dired Navigation.    (line  17)
* dired-hide-all:                        Hiding Subdirectories.
                                                              (line  15)
* dired-hide-details-mode:               Misc Dired Features. (line  38)
* dired-hide-subdir:                     Hiding Subdirectories.
                                                              (line  10)
* dired-isearch-filenames:               Dired Navigation.    (line  21)
* dired-isearch-filenames-regexp:        Dired Navigation.    (line  21)
* dired-mark:                            Marks vs Flags.      (line  17)
* dired-mark-directories:                Marks vs Flags.      (line  36)
* dired-mark-executables:                Marks vs Flags.      (line  27)
* dired-mark-files-containing-regexp:    Marks vs Flags.      (line 127)
* dired-mark-files-regexp:               Marks vs Flags.      (line 117)
* dired-mark-subdir-files:               Marks vs Flags.      (line  41)
* dired-mark-symlinks:                   Marks vs Flags.      (line  31)
* dired-maybe-insert-subdir:             Subdirectories in Dired.
                                                              (line  18)
* dired-mouse-find-file-other-window:    Dired Visiting.      (line  34)
* dired-next-dirline:                    Subdirectory Motion. (line  35)
* dired-next-line:                       Dired Navigation.    (line   6)
* dired-next-marked-file:                Marks vs Flags.      (line  80)
* dired-next-subdir:                     Subdirectory Motion. (line  15)
* dired-other-frame:                     Dired Enter.         (line  51)
* dired-other-window:                    Dired Enter.         (line  51)
* dired-prev-dirline:                    Subdirectory Motion. (line  30)
* dired-prev-marked-file:                Marks vs Flags.      (line  86)
* dired-prev-subdir:                     Subdirectory Motion. (line  19)
* dired-previous-line:                   Dired Navigation.    (line   6)
* dired-sort-toggle-or-edit:             Dired Updating.      (line  68)
* dired-toggle-marks:                    Marks vs Flags.      (line  91)
* dired-tree-down:                       Subdirectory Motion. (line  26)
* dired-tree-up:                         Subdirectory Motion. (line  23)
* dired-undo:                            Marks vs Flags.      (line 145)
* dired-unmark:                          Marks vs Flags.      (line  46)
* dired-unmark-all-files:                Marks vs Flags.      (line  68)
* dired-unmark-all-marks:                Marks vs Flags.      (line  63)
* dired-unmark-backward:                 Marks vs Flags.      (line  54)
* dired-up-directory:                    Dired Visiting.      (line  45)
* dired-upcase:                          Transforming File Names.
                                                              (line  23)
* dired-view-file:                       Dired Visiting.      (line  39)
* dirs:                                  Directory Tracking.  (line  19)
* dirtrack-mode:                         Directory Tracking.  (line  25)
* disable-command:                       Disabling.           (line  33)
* disable-theme:                         Custom Themes.       (line  70)
* display-battery-mode:                  Optional Mode Line.  (line  70)
* display-buffer (command):              Pop Up Window.       (line  16)
* display-buffer, detailed description:  Window Choice.       (line   6)
* display-line-numbers-mode:             Display Custom.      (line  37)
* display-local-help:                    Help Echo.           (line  14)
* display-time:                          Optional Mode Line.  (line  47)
* dissociated-press:                     Amusements.          (line  21)
* do-auto-save:                          Auto Save Control.   (line  39)
* doc-view-clear-cache:                  DocView Conversion.  (line   6)
* doc-view-enlarge:                      DocView Navigation.  (line  30)
* doc-view-first-page:                   DocView Navigation.  (line  25)
* doc-view-goto-page:                    DocView Navigation.  (line  25)
* doc-view-kill-proc:                    DocView Conversion.  (line  12)
* doc-view-kill-proc-and-buffer:         DocView Conversion.  (line  12)
* doc-view-last-page:                    DocView Navigation.  (line  25)
* doc-view-minor-mode:                   Document View.       (line  13)
* doc-view-mode:                         Document View.       (line   6)
* doc-view-next-page:                    DocView Navigation.  (line  15)
* doc-view-open-text:                    Document View.       (line  22)
* doc-view-previous-page:                DocView Navigation.  (line  15)
* doc-view-reset-slice:                  DocView Slicing.     (line  27)
* doc-view-scroll-down-or-previous-page: DocView Navigation.  (line  20)
* doc-view-scroll-up-or-next-page:       DocView Navigation.  (line  20)
* doc-view-search:                       DocView Searching.   (line  11)
* doc-view-search-backward:              DocView Searching.   (line  11)
* doc-view-set-slice:                    DocView Slicing.     (line  10)
* doc-view-set-slice-using-mouse:        DocView Slicing.     (line  10)
* doc-view-show-tooltip:                 DocView Searching.   (line  11)
* doc-view-shrink:                       DocView Navigation.  (line  30)
* doc-view-toggle-display:               Document View.       (line  13)
* doctex-mode:                           TeX Mode.            (line   6)
* doctor:                                Amusements.          (line  60)
* dos-mode25:                            MS-DOS Display.      (line  43)
* dos-mode4350:                          MS-DOS Display.      (line  43)
* down-list:                             Moving by Parens.    (line  40)
* downcase-region:                       Case.                (line  40)
* downcase-word:                         Case.                (line  20)
* dunnet:                                Amusements.          (line  32)
* edit-abbrevs:                          Editing Abbrevs.     (line  41)
* edit-kbd-macro:                        Edit Keyboard Macro. (line  21)
* edit-tab-stops:                        Tab Stops.           (line  15)
* eldoc-mode:                            Lisp Doc.            (line  10)
* electric-indent-mode:                  Indent Convenience.  (line  15)
* electric-layout-mode:                  Misc for Programs.   (line  25)
* electric-pair-mode:                    Matching.            (line  63)
* electric-quote-mode:                   Quotation Marks.     (line   6)
* emacs-lisp-mode:                       Lisp Eval.           (line   6)
* emacs-version:                         Checklist.           (line  61)
* emerge-auto-advance:                   Submodes of Emerge.  (line  31)
* emerge-buffers:                        Overview of Emerge.  (line  16)
* emerge-buffers-with-ancestor:          Overview of Emerge.  (line  19)
* emerge-files:                          Overview of Emerge.  (line   9)
* emerge-files-with-ancestor:            Overview of Emerge.  (line  12)
* emerge-skip-prefers:                   Submodes of Emerge.  (line  31)
* enable-command:                        Disabling.           (line  33)
* enable-theme:                          Custom Themes.       (line  70)
* end-of-buffer:                         Moving Point.        (line  90)
* end-of-defun:                          Moving by Defuns.    (line  17)
* end-of-visual-line:                    Visual Line Mode.    (line  22)
* enlarge-window:                        Change Window.       (line  45)
* enlarge-window-horizontally:           Change Window.       (line  54)
* enriched-mode:                         Enriched Mode.       (line  13)
* epa-dired-do-decrypt:                  Operating on Files.  (line 118)
* epa-dired-do-encrypt:                  Operating on Files.  (line 131)
* epa-dired-do-sign:                     Operating on Files.  (line 127)
* epa-dired-do-verify:                   Operating on Files.  (line 122)
* eval-buffer:                           Lisp Eval.           (line  64)
* eval-defun:                            Lisp Eval.           (line  49)
* eval-expression:                       Lisp Eval.           (line  30)
* eval-last-sexp:                        Lisp Eval.           (line  35)
* eval-print-last-sexp:                  Lisp Interaction.    (line  11)
* eval-region:                           Lisp Eval.           (line  64)
* eww:                                   EWW.                 (line   6)
* eww-open-file:                         EWW.                 (line   6)
* eww-search-words:                      Word Search.         (line  53)
* exchange-point-and-mark:               Setting Mark.        (line  46)
* exchange-point-and-mark, in rectangle-mark-mode: Rectangles.
                                                              (line 123)
* execute-extended-command:              M-x.                 (line  71)
* exit-calendar:                         General Calendar.    (line  33)
* exit-recursive-edit:                   Recursive Edit.      (line  12)
* expand-abbrev:                         Expanding Abbrevs.   (line  25)
* expand-region-abbrevs:                 Expanding Abbrevs.   (line  59)
* f90-beginning-of-block:                Fortran Motion.      (line  41)
* f90-end-of-block:                      Fortran Motion.      (line  33)
* f90-mode:                              Fortran.             (line   6)
* f90-next-block:                        Fortran Motion.      (line  22)
* f90-next-statement:                    Fortran Motion.      (line  12)
* f90-previous-block:                    Fortran Motion.      (line  29)
* f90-previous-statement:                Fortran Motion.      (line  16)
* facemenu-remove-all:                   Editing Format Info. (line  16)
* facemenu-remove-face-props:            Editing Format Info. (line  12)
* facemenu-set-background:               Enriched Faces.      (line  35)
* facemenu-set-bold:                     Enriched Faces.      (line  15)
* facemenu-set-bold-italic:              Enriched Faces.      (line  21)
* facemenu-set-default:                  Enriched Faces.      (line  12)
* facemenu-set-face:                     Enriched Faces.      (line  28)
* facemenu-set-foreground:               Enriched Faces.      (line  31)
* facemenu-set-italic:                   Enriched Faces.      (line  18)
* facemenu-set-underline:                Enriched Faces.      (line  25)
* ff-find-related-file:                  Other C Commands.    (line  95)
* ffap:                                  FFAP.                (line   6)
* ffap-menu:                             FFAP.                (line   6)
* ffap-mode:                             FFAP.                (line  19)
* ffap-next:                             FFAP.                (line   6)
* file-cache-add-directory:              File Name Cache.     (line  17)
* file-cache-minibuffer-complete:        File Name Cache.     (line   6)
* file-name-shadow-mode:                 Minibuffer File.     (line  34)
* filesets-add-buffer:                   Filesets.            (line  13)
* filesets-init:                         Filesets.            (line   6)
* filesets-remove-buffer:                Filesets.            (line  13)
* fill-individual-paragraphs:            Fill Prefix.         (line  62)
* fill-nonuniform-paragraphs:            Fill Prefix.         (line  69)
* fill-paragraph:                        Fill Commands.       (line  17)
* fill-region:                           Fill Commands.       (line  21)
* fill-region-as-paragraph:              Fill Commands.       (line  27)
* find-alternate-file:                   Visiting.            (line  80)
* find-dired:                            Dired and Find.      (line  28)
* find-file:                             Visiting.            (line  27)
* find-file-at-point:                    FFAP.                (line   6)
* find-file-literally:                   Visiting.            (line 148)
* find-file-other-frame:                 Visiting.            (line 117)
* find-file-other-window:                Visiting.            (line 109)
* find-file-read-only:                   Visiting.            (line 105)
* find-file-read-only-other-frame:       Creating Frames.     (line  39)
* find-grep:                             Grep Searching.      (line  65)
* find-grep-dired:                       Dired and Find.      (line  17)
* find-name-dired:                       Dired and Find.      (line   9)
* find-tag-other-window:                 Pop Up Window.       (line  34)
* finder-by-keyword:                     Package Keywords.    (line  11)
* flush-lines:                           Other Repeating Search.
                                                              (line  92)
* flyspell-auto-correct-word:            Spelling.            (line 158)
* flyspell-correct-word:                 Spelling.            (line 158)
* flyspell-correct-word-before-point:    Spelling.            (line 158)
* flyspell-mode:                         Spelling.            (line 151)
* flyspell-prog-mode:                    Spelling.            (line 166)
* foldout-exit-fold:                     Foldout.             (line  43)
* foldout-zoom-subtree:                  Foldout.             (line  16)
* follow-mode:                           Follow Mode.         (line   6)
* font-lock-add-keywords:                Font Lock.           (line  64)
* font-lock-mode:                        Font Lock.           (line  13)
* font-lock-remove-keywords:             Font Lock.           (line  76)
* format-decode-buffer:                  Enriched Mode.       (line  25)
* fortran-beginning-of-block:            Fortran Motion.      (line  41)
* fortran-column-ruler:                  Fortran Columns.     (line  29)
* fortran-comment-region:                Fortran Comments.    (line  78)
* fortran-end-of-block:                  Fortran Motion.      (line  33)
* fortran-indent-subprogram:             ForIndent Commands.  (line  22)
* fortran-join-line:                     ForIndent Commands.  (line  31)
* fortran-mode:                          Fortran.             (line   6)
* fortran-next-statement:                Fortran Motion.      (line  12)
* fortran-previous-statement:            Fortran Motion.      (line  16)
* fortran-split-line:                    ForIndent Commands.  (line  26)
* fortran-strip-sequence-nos:            Fortran Columns.     (line  58)
* fortran-window-create:                 Fortran Columns.     (line  53)
* fortran-window-create-momentarily:     Fortran Columns.     (line  48)
* fortune-to-signature:                  Mail Amusements.     (line  18)
* forward-button:                        Help Mode.           (line  43)
* forward-char:                          Moving Point.        (line  19)
* forward-list:                          Moving by Parens.    (line  29)
* forward-page:                          Pages.               (line  29)
* forward-paragraph:                     Paragraphs.          (line  17)
* forward-sentence:                      Sentences.           (line  18)
* forward-sexp:                          Expressions.         (line  24)
* forward-word:                          Words.               (line  26)
* frameset-to-register:                  Configuration Registers.
                                                              (line   6)
* fringe-mode:                           Fringes.             (line   6)
* gdb:                                   Starting GUD.        (line  10)
* gdb-delete-breakpoint:                 Breakpoints Buffer.  (line  19)
* gdb-display-disassembly-for-thread:    Threads Buffer.      (line  31)
* gdb-display-locals-for-thread:         Threads Buffer.      (line  39)
* gdb-display-registers-for-thread:      Threads Buffer.      (line  43)
* gdb-display-stack-for-thread:          Threads Buffer.      (line  35)
* gdb-edit-value:                        Watch Expressions.   (line  27)
* gdb-frames-select:                     Stack Buffer.        (line  11)
* gdb-goto-breakpoint:                   Breakpoints Buffer.  (line  22)
* gdb-many-windows:                      GDB User Interface Layout.
                                                              (line  23)
* gdb-restore-windows:                   GDB User Interface Layout.
                                                              (line  23)
* gdb-select-thread:                     Threads Buffer.      (line   6)
* gdb-toggle-breakpoint:                 Breakpoints Buffer.  (line  13)
* gdb-var-delete:                        Watch Expressions.   (line  24)
* getenv:                                Environment.         (line  17)
* global-auto-revert-mode:               Reverting.           (line  35)
* global-cwarn-mode:                     Other C Commands.    (line  72)
* global-display-line-numbers-mode:      Display Custom.      (line  37)
* global-eldoc-mode:                     Lisp Doc.            (line  10)
* global-font-lock-mode:                 Font Lock.           (line  17)
* global-hl-line-mode:                   Cursor Display.      (line  49)
* global-set-key:                        Rebinding.           (line  17)
* global-unset-key:                      Rebinding.           (line  17)
* global-visual-line-mode:               Visual Line Mode.    (line  12)
* global-whitespace-mode:                Useless Whitespace.  (line  87)
* global-whitespace-toggle-options:      Useless Whitespace.  (line  87)
* gnus:                                  Gnus Startup.        (line   6)
* gnus-group-exit:                       Gnus Group Buffer.   (line  54)
* gnus-group-kill-group:                 Gnus Group Buffer.   (line  37)
* gnus-group-list-all-groups:            Gnus Group Buffer.   (line  18)
* gnus-group-list-groups:                Gnus Group Buffer.   (line  12)
* gnus-group-list-killed:                Gnus Group Buffer.   (line  24)
* gnus-group-list-zombies:               Gnus Group Buffer.   (line  27)
* gnus-group-next-unread-group:          Gnus Group Buffer.   (line  46)
* gnus-group-prev-unread-group:          Gnus Group Buffer.   (line  50)
* gnus-group-read-group:                 Gnus Group Buffer.   (line   8)
* gnus-group-unsubscribe-current-group:  Gnus Group Buffer.   (line  30)
* gnus-summary-isearch-article:          Gnus Summary Buffer. (line  30)
* gnus-summary-next-page:                Gnus Summary Buffer. (line   8)
* gnus-summary-next-unread-article:      Gnus Summary Buffer. (line  22)
* gnus-summary-prev-page:                Gnus Summary Buffer. (line  18)
* gnus-summary-prev-unread-article:      Gnus Summary Buffer. (line  26)
* gnus-summary-search-article-backward:  Gnus Summary Buffer. (line  40)
* gnus-summary-search-article-forward:   Gnus Summary Buffer. (line  36)
* gomoku:                                Amusements.          (line  34)
* goto-address-at-point:                 Goto Address mode.   (line   9)
* goto-address-mode:                     Goto Address mode.   (line   6)
* goto-char:                             Moving Point.        (line 108)
* goto-followup-to:                      Header Editing.      (line  30)
* goto-line:                             Moving Point.        (line 113)
* goto-line, with an argument:           Select Buffer.       (line  71)
* goto-reply-to:                         Header Editing.      (line  30)
* gpm-mouse-mode:                        Text-Only Mouse.     (line  18)
* grep:                                  Grep Searching.      (line  26)
* grep (MS-DOS):                         MS-DOS Processes.    (line   6)
* grep-find:                             Grep Searching.      (line  65)
* gud-cont:                              Commands of GUD.     (line  49)
* gud-def:                               GUD Customization.   (line  22)
* gud-down:                              Commands of GUD.     (line  72)
* gud-finish:                            Commands of GUD.     (line  84)
* gud-gdb:                               Starting GUD.        (line  15)
* gud-gdb-complete-command:              Commands of GUD.     (line  97)
* gud-jump:                              Commands of GUD.     (line  90)
* gud-next:                              Commands of GUD.     (line  35)
* gud-print:                             Commands of GUD.     (line  44)
* gud-refresh:                           Commands of GUD.     (line  25)
* gud-remove:                            Commands of GUD.     (line  55)
* gud-step:                              Commands of GUD.     (line  30)
* gud-stepi:                             Commands of GUD.     (line  40)
* gud-tbreak:                            Commands of GUD.     (line  61)
* gud-tooltip-mode:                      Debugger Operation.  (line  30)
* gud-until:                             Commands of GUD.     (line  77)
* gud-up:                                Commands of GUD.     (line  67)
* gud-watch:                             Watch Expressions.   (line   6)
* guiler:                                Starting GUD.        (line  33)
* handwrite:                             PostScript.          (line  56)
* hanoi:                                 Amusements.          (line  37)
* help-command:                          Help.                (line   6)
* help-follow:                           Help Mode.           (line  29)
* help-for-help:                         Help.                (line   6)
* help-go-back:                          Help Mode.           (line  29)
* help-go-forward:                       Help Mode.           (line  29)
* help-with-tutorial:                    Basic.               (line   6)
* hi-lock-find-patterns:                 Highlight Interactively.
                                                              (line  88)
* hi-lock-mode:                          Highlight Interactively.
                                                              (line  11)
* hi-lock-write-interactive-patterns:    Highlight Interactively.
                                                              (line  76)
* hide-ifdef-mode:                       Other C Commands.    (line  87)
* hide-sublevels:                        Outline Visibility.  (line  71)
* highlight-changes-mode:                Highlight Interactively.
                                                              (line   6)
* highlight-lines-matching-regexp:       Highlight Interactively.
                                                              (line  59)
* highlight-phrase:                      Highlight Interactively.
                                                              (line  64)
* highlight-regexp:                      Highlight Interactively.
                                                              (line  28)
* highlight-symbol-at-point:             Highlight Interactively.
                                                              (line  71)
* hl-line-mode:                          Cursor Display.      (line  49)
* holidays:                              Holidays.            (line  46)
* horizontal-scroll-bar-mode:            Scroll Bars.         (line  81)
* how-many:                              Other Repeating Search.
                                                              (line  87)
* hs-hide-all:                           Hideshow.            (line  20)
* hs-hide-block:                         Hideshow.            (line  20)
* hs-hide-level:                         Hideshow.            (line  20)
* hs-minor-mode:                         Hideshow.            (line   6)
* hs-show-all:                           Hideshow.            (line  20)
* hs-show-block:                         Hideshow.            (line  20)
* hs-show-region:                        Hideshow.            (line  20)
* html-mode:                             HTML Mode.           (line   6)
* htmlfontify-buffer:                    Printing.            (line  10)
* ibuffer:                               Buffer Menus.        (line  28)
* icalendar-export-file:                 Importing Diary.     (line  39)
* icalendar-export-region:               Importing Diary.     (line  39)
* icalendar-import-buffer:               Importing Diary.     (line  22)
* icalendar-import-file:                 Importing Diary.     (line  29)
* icomplete-mode:                        Icomplete.           (line   6)
* ielm:                                  Lisp Interaction.    (line  23)
* image-decrease-speed:                  File Conveniences.   (line  33)
* image-dired-display-thumbs:            Image-Dired.         (line  10)
* image-goto-frame:                      File Conveniences.   (line  33)
* image-increase-speed:                  File Conveniences.   (line  33)
* image-mode:                            File Conveniences.   (line  20)
* image-next-file:                       File Conveniences.   (line  20)
* image-next-frame:                      File Conveniences.   (line  33)
* image-previous-file:                   File Conveniences.   (line  20)
* image-previous-frame:                  File Conveniences.   (line  33)
* image-reset-speed:                     File Conveniences.   (line  33)
* image-reverse-speed:                   File Conveniences.   (line  33)
* image-toggle-animation:                File Conveniences.   (line  33)
* image-toggle-display:                  File Conveniences.   (line  20)
* imenu:                                 Imenu.               (line  11)
* imenu-add-menubar-index:               Imenu.               (line  15)
* increase-left-margin:                  Enriched Indentation.
                                                              (line  13)
* increment-register:                    Number Registers.    (line  13)
* indent-code-rigidly:                   Multi-line Indent.   (line  42)
* indent-for-tab-command:                Indentation.         (line  13)
* indent-line-function:                  Basic Indent.        (line  11)
* indent-pp-sexp:                        Multi-line Indent.   (line  25)
* indent-region:                         Indentation Commands.
                                                              (line  45)
* indent-relative:                       Indentation Commands.
                                                              (line  25)
* indent-rigidly:                        Indentation Commands.
                                                              (line  52)
* info:                                  Misc Help.           (line   6)
* Info-goto-emacs-command-node:          Name Help.           (line  46)
* Info-goto-emacs-key-command-node:      Key Help.            (line  16)
* info-lookup-file:                      Info Lookup.         (line   6)
* info-lookup-symbol:                    Misc Help.           (line  20)
* insert-abbrevs:                        Saving Abbrevs.      (line  45)
* insert-char:                           Inserting Text.      (line  58)
* insert-file:                           Misc File Ops.       (line  34)
* insert-file-literally:                 Misc File Ops.       (line  39)
* insert-kbd-macro:                      Save Keyboard Macro. (line  43)
* insert-register:                       Text Registers.      (line  49)
* inverse-add-global-abbrev:             Defining Abbrevs.    (line  46)
* inverse-add-mode-abbrev:               Defining Abbrevs.    (line  46)
* isearch-backward:                      Basic Isearch.       (line  58)
* isearch-backward-regexp:               Regexp Search.       (line  18)
* isearch-del-char:                      Isearch Yank.        (line  27)
* isearch-forward:                       Basic Isearch.       (line  11)
* isearch-forward-regexp:                Regexp Search.       (line  18)
* isearch-forward-symbol:                Symbol Search.       (line  26)
* isearch-forward-symbol-at-point:       Symbol Search.       (line  26)
* isearch-forward-word:                  Word Search.         (line  27)
* isearch-help-map:                      Special Isearch.     (line  90)
* isearch-highlight-regexp:              Special Isearch.     (line  82)
* isearch-occur:                         Special Isearch.     (line  65)
* isearch-toggle-case-fold:              Lax Search.          (line  59)
* isearch-toggle-char-fold:              Lax Search.          (line  87)
* isearch-toggle-input-method:           Special Isearch.     (line  49)
* isearch-toggle-invisible:              Special Isearch.     (line  24)
* isearch-toggle-lax-whitespace:         Lax Search.          (line  15)
* isearch-toggle-regexp:                 Special Isearch.     (line  28)
* isearch-toggle-specified-input-method: Special Isearch.     (line  49)
* isearch-toggle-symbol:                 Symbol Search.       (line  15)
* isearch-yank-char:                     Isearch Yank.        (line  27)
* isearch-yank-kill:                     Isearch Yank.        (line  19)
* isearch-yank-line:                     Isearch Yank.        (line  15)
* isearch-yank-pop:                      Isearch Yank.        (line  19)
* isearch-yank-word-or-char:             Isearch Yank.        (line  10)
* isearch-yank-x-selection:              Isearch Yank.        (line  19)
* iso-gtex2iso:                          TeX Misc.            (line  12)
* iso-iso2gtex:                          TeX Misc.            (line  12)
* iso-iso2tex:                           TeX Misc.            (line  12)
* iso-tex2iso:                           TeX Misc.            (line  12)
* ispell:                                Spelling.            (line  51)
* ispell-buffer:                         Spelling.            (line  51)
* ispell-change-dictionary:              Spelling.            (line 134)
* ispell-complete-word:                  Spelling.            (line 121)
* ispell-kill-ispell:                    Spelling.            (line 128)
* ispell-message:                        Mail Misc.           (line  34)
* ispell-region:                         Spelling.            (line  51)
* ispell-word:                           Spelling.            (line  44)
* jdb:                                   Starting GUD.        (line  27)
* jump-to-register:                      Position Registers.  (line  17)
* just-one-space:                        Deletion.            (line  40)
* kbd:                                   Init Rebinding.      (line  10)
* kbd-macro-query:                       Keyboard Macro Query.
                                                              (line  13)
* keep-lines:                            Other Repeating Search.
                                                              (line 105)
* keyboard-escape-quit:                  Quitting.            (line  72)
* keyboard-quit:                         Quitting.            (line  45)
* kill-all-abbrevs:                      Defining Abbrevs.    (line  61)
* kill-buffer:                           Kill Buffer.         (line  22)
* kill-buffer-and-window:                Change Window.       (line  36)
* kill-compilation:                      Compilation.         (line  71)
* kill-emacs:                            Exiting.             (line  44)
* kill-line:                             Killing by Lines.    (line  11)
* kill-local-variable:                   Locals.              (line  53)
* kill-matching-buffers:                 Kill Buffer.         (line  35)
* kill-rectangle:                        Rectangles.          (line  62)
* kill-region:                           Other Kill Commands. (line  26)
* kill-ring-save:                        Other Kill Commands. (line  26)
* kill-sentence:                         Sentences.           (line  29)
* kill-sexp:                             Expressions.         (line  43)
* kill-some-buffers:                     Kill Buffer.         (line  30)
* kill-whole-line:                       Killing by Lines.    (line  32)
* kill-word:                             Words.               (line  34)
* kmacro-add-counter:                    Keyboard Macro Counter.
                                                              (line  55)
* kmacro-bind-to-key:                    Save Keyboard Macro. (line  24)
* kmacro-cycle-ring-next:                Keyboard Macro Ring. (line  42)
* kmacro-cycle-ring-previous:            Keyboard Macro Ring. (line  42)
* kmacro-edit-lossage:                   Edit Keyboard Macro. (line  26)
* kmacro-edit-macro:                     Edit Keyboard Macro. (line  15)
* kmacro-end-and-call-macro:             Basic Keyboard Macro.
                                                              (line  23)
* kmacro-end-macro:                      Basic Keyboard Macro.
                                                              (line  79)
* kmacro-end-or-call-macro:              Basic Keyboard Macro.
                                                              (line  23)
* kmacro-end-or-call-macro-repeat:       Keyboard Macro Ring. (line  32)
* kmacro-insert-counter:                 Keyboard Macro Counter.
                                                              (line  27)
* kmacro-name-last-macro:                Save Keyboard Macro. (line  15)
* kmacro-set-counter:                    Keyboard Macro Counter.
                                                              (line  49)
* kmacro-set-format:                     Keyboard Macro Counter.
                                                              (line  60)
* kmacro-start-macro:                    Basic Keyboard Macro.
                                                              (line  79)
* kmacro-start-macro-or-insert-counter:  Basic Keyboard Macro.
                                                              (line  23)
* kmacro-step-edit-macro:                Keyboard Macro Step-Edit.
                                                              (line   6)
* kmacro-to-register:                    Keyboard Macro Registers.
                                                              (line   6)
* latex-electric-env-pair-mode:          LaTeX Editing.       (line  26)
* latex-mode:                            TeX Mode.            (line   6)
* left-char:                             Moving Point.        (line  30)
* left-char, and bidirectional text:     Bidirectional Editing.
                                                              (line  70)
* left-word:                             Moving Point.        (line  69)
* lgrep:                                 Grep Searching.      (line  71)
* life:                                  Amusements.          (line  41)
* line-number-mode:                      Optional Mode Line.  (line  16)
* lisp-eval-defun:                       External Lisp.       (line  25)
* lisp-interaction-mode:                 Lisp Interaction.    (line   6)
* list-abbrevs:                          Editing Abbrevs.     (line  13)
* list-bookmarks:                        Bookmarks.           (line  41)
* list-buffers:                          List Buffers.        (line   9)
* list-character-sets:                   Charsets.            (line  30)
* list-charset-chars:                    Charsets.            (line  24)
* list-coding-systems:                   Coding Systems.      (line  54)
* list-colors-display:                   Colors.              (line  12)
* list-command-history:                  Repetition.          (line  11)
* list-directory:                        Directories.         (line  24)
* list-faces-display:                    Faces.               (line  14)
* list-holidays:                         Holidays.            (line  57)
* list-input-methods:                    Select Input Method. (line  87)
* list-matching-lines:                   Other Repeating Search.
                                                              (line  75)
* list-packages:                         Package Menu.        (line   6)
* list-tags:                             List Identifiers.    (line  28)
* load:                                  Lisp Libraries.      (line  21)
* load-file:                             Lisp Libraries.      (line  15)
* load-library:                          Lisp Libraries.      (line  21)
* load-theme:                            Custom Themes.       (line  70)
* local-set-key:                         Rebinding.           (line  17)
* local-unset-key:                       Rebinding.           (line  17)
* locate:                                Dired and Find.      (line  40)
* locate-with-filter:                    Dired and Find.      (line  40)
* log-edit-done:                         Log Buffer.          (line   6)
* log-edit-insert-changelog:             Log Buffer.          (line  42)
* log-edit-show-diff:                    Log Buffer.          (line  33)
* log-edit-show-files:                   Log Buffer.          (line  33)
* log-view-toggle-entry-display:         VC Change Log.       (line  30)
* lpr-buffer:                            Printing.            (line  30)
* lpr-region:                            Printing.            (line  30)
* lunar-phases:                          Lunar Phases.        (line  21)
* mail-abbrev-insert-alias:              Mail Aliases.        (line  42)
* mail-add-attachment:                   Mail Misc.           (line  19)
* mail-fill-yanked-message:              Citing Mail.         (line  23)
* mail-text:                             Header Editing.      (line  35)
* make-frame-command:                    Creating Frames.     (line  18)
* make-frame-on-display:                 Multiple Displays.   (line  11)
* make-indirect-buffer:                  Indirect Buffers.    (line  11)
* make-local-variable:                   Locals.              (line  23)
* make-symbolic-link:                    Copying and Naming.  (line  49)
* make-variable-buffer-local:            Locals.              (line  28)
* man:                                   Man Page.            (line  11)
* mark-defun:                            Moving by Defuns.    (line  17)
* mark-page:                             Pages.               (line  35)
* mark-paragraph:                        Paragraphs.          (line  23)
* mark-sexp:                             Marking Objects.     (line  38)
* mark-whole-buffer:                     Marking Objects.     (line  52)
* mark-word:                             Marking Objects.     (line  29)
* menu-bar-mode:                         Menu Bars.           (line   6)
* menu-bar-open:                         Menu Bar.            (line  22)
* message-goto-bcc:                      Header Editing.      (line  30)
* message-goto-cc:                       Header Editing.      (line  30)
* message-goto-fcc:                      Header Editing.      (line  30)
* message-goto-subject:                  Header Editing.      (line  30)
* message-goto-to:                       Header Editing.      (line  30)
* message-insert-signature:              Mail Signature.      (line  19)
* message-send:                          Mail Sending.        (line  13)
* message-send-and-exit:                 Mail Sending.        (line  19)
* message-tab:                           Header Editing.      (line  38)
* message-yank-original:                 Citing Mail.         (line  13)
* message-yank-prefix:                   Citing Mail.         (line  13)
* minibuffer-complete:                   Completion Commands. (line  22)
* minibuffer-complete-and-exit:          Completion Exit.     (line   6)
* minibuffer-complete-word:              Completion Commands. (line  27)
* minibuffer-electric-default-mode:      Basic Minibuffer.    (line  23)
* minibuffer-inactive-mode:              Minibuffer Edit.     (line  61)
* mml-attach-file:                       Mail Misc.           (line   6)
* morse-region:                          Amusements.          (line  43)
* mouse-avoidance-mode:                  Mouse Avoidance.     (line  38)
* mouse-buffer-menu:                     Buffer Menus.        (line  22)
* mouse-save-then-kill:                  Mouse Commands.      (line  69)
* mouse-secondary-save-then-kill:        Secondary Selection. (line  24)
* mouse-set-point:                       Mouse Commands.      (line  25)
* mouse-set-region:                      Mouse Commands.      (line  40)
* mouse-set-secondary:                   Secondary Selection. (line  11)
* mouse-start-secondary:                 Secondary Selection. (line  21)
* mouse-wheel-mode:                      Mouse Commands.      (line 109)
* mouse-yank-at-click:                   Mouse Commands.      (line  57)
* mouse-yank-primary:                    Mouse Commands.      (line  57)
* mouse-yank-secondary:                  Secondary Selection. (line  30)
* move-beginning-of-line:                Moving Point.        (line  47)
* move-end-of-line:                      Moving Point.        (line  51)
* move-to-column:                        Moving Point.        (line 122)
* move-to-window-line-top-bottom:        Moving Point.        (line  74)
* mpuz:                                  Amusements.          (line   9)
* msb-mode:                              Buffer Menus.        (line  22)
* msdos-set-mouse-buttons:               MS-DOS Mouse.        (line  19)
* multi-isearch-buffers:                 Other Repeating Search.
                                                              (line  14)
* multi-isearch-buffers-regexp:          Other Repeating Search.
                                                              (line  22)
* multi-isearch-files:                   Other Repeating Search.
                                                              (line  26)
* multi-isearch-files-regexp:            Other Repeating Search.
                                                              (line  34)
* multi-occur:                           Other Repeating Search.
                                                              (line  77)
* multi-occur-in-matching-buffers:       Other Repeating Search.
                                                              (line  81)
* narrow-to-defun:                       Narrowing.           (line  39)
* narrow-to-page:                        Narrowing.           (line  39)
* narrow-to-region:                      Narrowing.           (line  34)
* nato-region:                           Amusements.          (line  43)
* negative-argument:                     Arguments.           (line  15)
* next-buffer:                           Select Buffer.       (line  48)
* next-completion:                       Completion Commands. (line  53)
* next-error:                            Compilation Mode.    (line  51)
* next-error-follow-minor-mode:          Compilation Mode.    (line 117)
* next-file:                             List Identifiers.    (line  35)
* next-history-element:                  Minibuffer History.  (line  30)
* next-line:                             Moving Point.        (line  36)
* next-line-or-history-element:          Minibuffer History.  (line  53)
* next-logical-line:                     Visual Line Mode.    (line  22)
* next-matching-history-element:         Minibuffer History.  (line  61)
* normal-erase-is-backspace-mode:        DEL Does Not Delete. (line  25)
* normal-mode:                           Choosing Modes.      (line 113)
* not-modified:                          Save Commands.       (line  71)
* nroff-backward-text-line:              Nroff Mode.          (line  16)
* nroff-count-text-lines:                Nroff Mode.          (line  16)
* nroff-electric-mode:                   Nroff Mode.          (line  25)
* nroff-forward-text-line:               Nroff Mode.          (line  16)
* nroff-mode:                            Nroff Mode.          (line   6)
* ns-popup-font-panel:                   Mac / GNUstep Customization.
                                                              (line  14)
* number-to-register:                    Number Registers.    (line  11)
* nxml-mode:                             HTML Mode.           (line  69)
* occur:                                 Other Repeating Search.
                                                              (line  42)
* open-dribble-file:                     Checklist.           (line 105)
* open-line:                             Blank Lines.         (line  13)
* open-rectangle:                        Rectangles.          (line  90)
* open-termscript:                       Checklist.           (line 112)
* org-agenda:                            Org Organizer.       (line  27)
* org-agenda-file-to-front:              Org Organizer.       (line  20)
* org-cycle:                             Org Mode.            (line  16)
* org-deadline:                          Org Organizer.       (line  13)
* org-export:                            Org Authoring.       (line   6)
* org-metadown:                          Org Mode.            (line  29)
* org-metaleft:                          Org Mode.            (line  29)
* org-metaright:                         Org Mode.            (line  29)
* org-metaup:                            Org Mode.            (line  29)
* org-mode:                              Org Mode.            (line   6)
* org-schedule:                          Org Organizer.       (line  13)
* org-shifttab:                          Org Mode.            (line  24)
* org-todo:                              Org Organizer.       (line   6)
* other-frame:                           Frame Commands.      (line  17)
* other-window:                          Other Window.        (line  15)
* outline-backward-same-level:           Outline Motion.      (line  19)
* outline-forward-same-level:            Outline Motion.      (line  16)
* outline-hide-body:                     Outline Visibility.  (line  71)
* outline-hide-entry:                    Outline Visibility.  (line  49)
* outline-hide-leaves:                   Outline Visibility.  (line  59)
* outline-hide-other:                    Outline Visibility.  (line  66)
* outline-hide-subtree:                  Outline Visibility.  (line  54)
* outline-minor-mode:                    Outline Mode.        (line   6)
* outline-mode:                          Outline Mode.        (line   6)
* outline-next-visible-heading:          Outline Motion.      (line  10)
* outline-previous-visible-heading:      Outline Motion.      (line  13)
* outline-show-all:                      Outline Visibility.  (line  71)
* outline-show-branches:                 Outline Visibility.  (line  59)
* outline-show-children:                 Outline Visibility.  (line  59)
* outline-show-entry:                    Outline Visibility.  (line  49)
* outline-show-subtree:                  Outline Visibility.  (line  54)
* outline-up-heading:                    Outline Motion.      (line  22)
* overwrite-mode:                        Minor Modes.         (line  88)
* package-initialize:                    Package Installation.
                                                              (line  93)
* package-install:                       Package Installation.
                                                              (line   6)
* package-install-file:                  Package Files.       (line   6)
* paragraph-indent-minor-mode:           Text Mode.           (line  27)
* paragraph-indent-text-mode:            Text Mode.           (line  27)
* pdb:                                   Starting GUD.        (line  30)
* perldb:                                Starting GUD.        (line  24)
* picture-backward-clear-column:         Basic Picture.       (line  26)
* picture-backward-column:               Basic Picture.       (line   6)
* picture-clear-column:                  Basic Picture.       (line  26)
* picture-clear-line:                    Basic Picture.       (line  26)
* picture-clear-rectangle:               Rectangles in Picture.
                                                              (line  26)
* picture-clear-rectangle-to-register:   Rectangles in Picture.
                                                              (line  26)
* picture-forward-column:                Basic Picture.       (line   6)
* picture-mode:                          Picture Mode.        (line   6)
* picture-motion:                        Insert in Picture.   (line  39)
* picture-motion-reverse:                Insert in Picture.   (line  39)
* picture-move-down:                     Basic Picture.       (line   6)
* picture-move-up:                       Basic Picture.       (line   6)
* picture-movement-down:                 Insert in Picture.   (line   6)
* picture-movement-left:                 Insert in Picture.   (line   6)
* picture-movement-ne:                   Insert in Picture.   (line   6)
* picture-movement-nw:                   Insert in Picture.   (line   6)
* picture-movement-right:                Insert in Picture.   (line   6)
* picture-movement-se:                   Insert in Picture.   (line   6)
* picture-movement-sw:                   Insert in Picture.   (line   6)
* picture-movement-up:                   Insert in Picture.   (line   6)
* picture-newline:                       Basic Picture.       (line  20)
* picture-open-line:                     Basic Picture.       (line  35)
* picture-set-tab-stops:                 Tabs in Picture.     (line  22)
* picture-tab:                           Tabs in Picture.     (line  17)
* picture-tab-search:                    Tabs in Picture.     (line   6)
* picture-yank-rectangle:                Rectangles in Picture.
                                                              (line  36)
* picture-yank-rectangle-from-register:  Rectangles in Picture.
                                                              (line  36)
* plain-tex-mode:                        TeX Mode.            (line   6)
* point-to-register:                     Position Registers.  (line  13)
* pong:                                  Amusements.          (line  48)
* pop-global-mark:                       Global Mark Ring.    (line  14)
* pr-interface:                          Printing Package.    (line  15)
* prefer-coding-system:                  Recognize Coding.    (line  29)
* prepend-to-buffer:                     Accumulating Text.   (line   6)
* prepend-to-register:                   Text Registers.      (line  34)
* prettify-symbols-mode:                 Misc for Programs.   (line  39)
* previous-buffer:                       Select Buffer.       (line  48)
* previous-completion:                   Completion Commands. (line  57)
* previous-history-element:              Minibuffer History.  (line  30)
* previous-line:                         Moving Point.        (line  42)
* previous-line-or-history-element:      Minibuffer History.  (line  53)
* previous-logical-line:                 Visual Line Mode.    (line  22)
* previous-matching-history-element:     Minibuffer History.  (line  61)
* print-buffer:                          Printing.            (line  30)
* print-buffer (MS-DOS):                 Windows Printing.    (line  64)
* print-region:                          Printing.            (line  30)
* print-region (MS-DOS):                 Windows Printing.    (line  64)
* ps-despool:                            PostScript.          (line  50)
* ps-print-buffer:                       PostScript.          (line  37)
* ps-print-buffer (MS-DOS):              Windows Printing.    (line  83)
* ps-print-buffer-with-faces:            PostScript.          (line  37)
* ps-print-region:                       PostScript.          (line  37)
* ps-print-region-with-faces:            PostScript.          (line  37)
* ps-spool-buffer:                       PostScript.          (line  47)
* ps-spool-buffer (MS-DOS):              Windows Printing.    (line  83)
* ps-spool-buffer-with-faces:            PostScript.          (line  47)
* ps-spool-region:                       PostScript.          (line  47)
* ps-spool-region-with-faces:            PostScript.          (line  47)
* pwd:                                   File Names.          (line  33)
* quail-set-keyboard-layout:             Select Input Method. (line  75)
* quail-show-key:                        Select Input Method. (line  82)
* quail-translation-keymap:              Input Methods.       (line  95)
* query-replace:                         Query Replace.       (line  11)
* query-replace-regexp:                  Query Replace.       (line  21)
* quietly-read-abbrev-file:              Saving Abbrevs.      (line  27)
* quit-window:                           Several Buffers.     (line  90)
* quit-window, in Dired buffers:         Dired Enter.         (line  55)
* quoted-insert:                         Inserting Text.      (line  30)
* re-search-backward:                    Regexp Search.       (line  63)
* re-search-forward:                     Regexp Search.       (line  63)
* read-abbrev-file:                      Saving Abbrevs.      (line  27)
* read-only-mode:                        Misc Buffer.         (line  26)
* recenter:                              Recentering.         (line  53)
* recenter-top-bottom:                   Recentering.         (line  20)
* recentf-edit-list:                     File Conveniences.   (line   9)
* recentf-mode:                          File Conveniences.   (line   9)
* recentf-save-list:                     File Conveniences.   (line   9)
* recode-file-name:                      File Name Coding.    (line  48)
* recode-region:                         Text Coding.         (line  76)
* recompile:                             Compilation.         (line  64)
* recover-file:                          Recover.             (line   6)
* recover-session:                       Recover.             (line  22)
* rectangle:                             Rectangles.          (line  98)
* rectangle-exchange-point-and-mark:     Rectangles.          (line 123)
* rectangle-mark-mode:                   Rectangles.          (line 112)
* remove-hook:                           Hooks.               (line  84)
* remove-untranslated-filesystem:        Text and Binary.     (line  72)
* rename-buffer:                         Misc Buffer.         (line  34)
* rename-file:                           Copying and Naming.  (line  31)
* rename-uniquely:                       Misc Buffer.         (line  38)
* repeat:                                Repeating.           (line  12)
* repeat-complex-command:                Repetition.          (line  19)
* replace-regexp:                        Regexp Replace.      (line   6)
* replace-string:                        Unconditional Replace.
                                                              (line   6)
* report-emacs-bug:                      Checklist.           (line  14)
* reposition-window:                     Recentering.         (line  56)
* reveal-mode:                           Outline Visibility.  (line  82)
* reverse-region:                        Sorting.             (line  61)
* revert-buffer:                         Reverting.           (line   6)
* revert-buffer (Dired):                 Dired Updating.      (line  30)
* revert-buffer-with-coding-system:      Text Coding.         (line  72)
* rgrep:                                 Grep Searching.      (line  71)
* right-char:                            Moving Point.        (line  22)
* right-char, and bidirectional text:    Bidirectional Editing.
                                                              (line  70)
* right-word:                            Moving Point.        (line  59)
* rmail:                                 Rmail.               (line   6)
* rmail-abort-edit:                      Rmail Editing.       (line  19)
* rmail-add-label:                       Rmail Labels.        (line  31)
* rmail-beginning-of-message:            Rmail Scrolling.     (line  27)
* rmail-bury:                            Rmail Basics.        (line  36)
* rmail-cease-edit:                      Rmail Editing.       (line  19)
* rmail-continue:                        Rmail Reply.         (line 106)
* rmail-delete-backward:                 Rmail Deletion.      (line  28)
* rmail-delete-forward:                  Rmail Deletion.      (line  28)
* rmail-edit-current-message:            Rmail Editing.       (line  15)
* rmail-end-of-message:                  Rmail Scrolling.     (line  27)
* rmail-epa-decrypt:                     Rmail Display.       (line  80)
* rmail-expunge:                         Rmail Deletion.      (line  43)
* rmail-expunge-and-save:                Rmail Basics.        (line  29)
* rmail-first-message:                   Rmail Motion.        (line  80)
* rmail-forward:                         Rmail Reply.         (line  69)
* rmail-get-new-mail:                    Rmail Files.         (line  51)
* rmail-input:                           Rmail Files.         (line  22)
* rmail-kill-label:                      Rmail Labels.        (line  31)
* rmail-last-message:                    Rmail Motion.        (line  80)
* rmail-mail:                            Rmail Reply.         (line 102)
* rmail-mime:                            Rmail Display.       (line  54)
* rmail-mime-next-item:                  Rmail Display.       (line  47)
* rmail-mime-previous-item:              Rmail Display.       (line  51)
* rmail-mime-toggle-hidden:              Rmail Display.       (line  43)
* rmail-mode:                            Rmail.               (line   6)
* rmail-next-labeled-message:            Rmail Labels.        (line  39)
* rmail-next-message:                    Rmail Motion.        (line  45)
* rmail-next-same-subject:               Rmail Motion.        (line  72)
* rmail-next-undeleted-message:          Rmail Motion.        (line  45)
* rmail-output:                          Rmail Output.        (line  21)
* rmail-output-as-seen:                  Rmail Output.        (line  21)
* rmail-output-body-to-file:             Rmail Output.        (line  33)
* rmail-previous-labeled-message:        Rmail Labels.        (line  39)
* rmail-previous-message:                Rmail Motion.        (line  45)
* rmail-previous-same-subject:           Rmail Motion.        (line  72)
* rmail-previous-undeleted-message:      Rmail Motion.        (line  45)
* rmail-quit:                            Rmail Basics.        (line  36)
* rmail-redecode-body:                   Rmail Coding.        (line  25)
* rmail-reply:                           Rmail Reply.         (line  28)
* rmail-resend:                          Rmail Reply.         (line  95)
* rmail-retry-failure:                   Rmail Reply.         (line  58)
* rmail-search:                          Rmail Motion.        (line  58)
* rmail-show-message:                    Rmail Motion.        (line  80)
* rmail-sort-by-author:                  Rmail Sorting.       (line  14)
* rmail-sort-by-correspondent:           Rmail Sorting.       (line  23)
* rmail-sort-by-date:                    Rmail Sorting.       (line   6)
* rmail-sort-by-labels:                  Rmail Sorting.       (line  32)
* rmail-sort-by-lines:                   Rmail Sorting.       (line  28)
* rmail-sort-by-recipient:               Rmail Sorting.       (line  18)
* rmail-sort-by-subject:                 Rmail Sorting.       (line  10)
* rmail-summary:                         Rmail Make Summary.  (line  31)
* rmail-summary-bury:                    Rmail Summary Edit.  (line  93)
* rmail-summary-by-labels:               Rmail Make Summary.  (line  36)
* rmail-summary-by-recipients:           Rmail Make Summary.  (line  40)
* rmail-summary-by-regexp:               Rmail Make Summary.  (line  50)
* rmail-summary-by-senders:              Rmail Make Summary.  (line  54)
* rmail-summary-by-topic:                Rmail Make Summary.  (line  45)
* rmail-summary-quit:                    Rmail Summary Edit.  (line  93)
* rmail-summary-undelete-many:           Rmail Summary Edit.  (line  29)
* rmail-summary-wipe:                    Rmail Summary Edit.  (line  93)
* rmail-toggle-header:                   Rmail Display.       (line  12)
* rmail-undelete-previous-message:       Rmail Deletion.      (line  43)
* rot13-other-window:                    Rmail Rot13.         (line  13)
* run-lisp:                              External Lisp.       (line  11)
* run-scheme:                            External Lisp.       (line  34)
* save-buffer:                           Save Commands.       (line  22)
* save-buffers-kill-terminal:            Exiting.             (line  13)
* save-some-buffers:                     Save Commands.       (line  39)
* scheme-mode:                           External Lisp.       (line  34)
* scroll-bar-mode:                       Scroll Bars.         (line  23)
* scroll-down-command:                   Scrolling.           (line  38)
* scroll-down-line:                      Scrolling.           (line  86)
* scroll-left:                           Horizontal Scrolling.
                                                              (line  38)
* scroll-other-window:                   Other Window.        (line  26)
* scroll-right:                          Horizontal Scrolling.
                                                              (line  38)
* scroll-up-command:                     Scrolling.           (line  38)
* scroll-up-line:                        Scrolling.           (line  86)
* sdb:                                   Starting GUD.        (line  43)
* search-backward:                       Nonincremental Search.
                                                              (line  28)
* search-forward:                        Nonincremental Search.
                                                              (line  28)
* select-frame-by-name:                  Non-Window Terminals.
                                                              (line  19)
* send-invisible:                        Shell Mode.          (line 109)
* serial-term:                           Serial Terminal.     (line   6)
* server-edit:                           Invoking emacsclient.
                                                              (line  34)
* server-eval-at:                        Emacs Server.        (line  83)
* server-generate-key:                   TCP Emacs server.    (line  27)
* server-start:                          Emacs Server.        (line  21)
* set-buffer-file-coding-system:         Text Coding.         (line  26)
* set-buffer-process-coding-system:      Communication Coding.
                                                              (line  43)
* set-face-background:                   Colors.              (line  32)
* set-face-foreground:                   Colors.              (line  32)
* set-file-modes:                        Misc File Ops.       (line  51)
* set-file-name-coding-system:           File Name Coding.    (line  10)
* set-fill-column:                       Fill Commands.       (line  39)
* set-fill-prefix:                       Fill Prefix.         (line  24)
* set-fontset-font:                      Modifying Fontsets.  (line   6)
* set-frame-name:                        Non-Window Terminals.
                                                              (line  19)
* set-fringe-style:                      Fringes.             (line   6)
* set-goal-column:                       Moving Point.        (line 127)
* set-input-method:                      Select Input Method. (line  25)
* set-justification-center:              Enriched Justification.
                                                              (line  21)
* set-justification-full:                Enriched Justification.
                                                              (line  17)
* set-justification-left:                Enriched Justification.
                                                              (line  11)
* set-justification-none:                Enriched Justification.
                                                              (line  25)
* set-justification-right:               Enriched Justification.
                                                              (line  14)
* set-keyboard-coding-system:            Terminal Coding.     (line  28)
* set-language-environment:              Language Environments.
                                                              (line  20)
* set-left-margin:                       Enriched Indentation.
                                                              (line  32)
* set-locale-environment:                Language Environments.
                                                              (line  46)
* set-mark-command:                      Setting Mark.        (line  25)
* set-next-selection-coding-system:      Communication Coding.
                                                              (line  24)
* set-right-margin:                      Enriched Indentation.
                                                              (line  32)
* set-selection-coding-system:           Communication Coding.
                                                              (line  24)
* set-selective-display:                 Selective Display.   (line   6)
* set-terminal-coding-system:            Terminal Coding.     (line  14)
* set-variable:                          Examining.           (line  37)
* set-visited-file-name:                 Save Commands.       (line  84)
* setenv:                                Environment.         (line  17)
* setq-default:                          Locals.              (line  59)
* sgml-attributes:                       HTML Mode.           (line  30)
* sgml-close-tag:                        HTML Mode.           (line  52)
* sgml-delete-tag:                       HTML Mode.           (line  43)
* sgml-mode:                             HTML Mode.           (line   6)
* sgml-name-8bit-mode:                   HTML Mode.           (line  57)
* sgml-name-char:                        HTML Mode.           (line  16)
* sgml-skip-tag-backward:                HTML Mode.           (line  38)
* sgml-skip-tag-forward:                 HTML Mode.           (line  33)
* sgml-tag:                              HTML Mode.           (line  20)
* sgml-tag-help:                         HTML Mode.           (line  48)
* sgml-tags-invisible:                   HTML Mode.           (line  66)
* sgml-validate:                         HTML Mode.           (line  61)
* shadow-initialize:                     File Shadowing.      (line   6)
* shell:                                 Interactive Shell.   (line   6)
* shell-backward-command:                Shell Mode.          (line 100)
* shell-command:                         Single Shell.        (line   6)
* shell-command-on-region:               Single Shell.        (line  55)
* shell-dynamic-complete-command:        Shell Options.       (line  51)
* shell-forward-command:                 Shell Mode.          (line  95)
* shell-pushd-dextract:                  Shell Options.       (line  54)
* shell-pushd-dunique:                   Shell Options.       (line  54)
* shell-pushd-tohome:                    Shell Options.       (line  54)
* show-paren-mode:                       Matching.            (line  33)
* shrink-window-horizontally:            Change Window.       (line  54)
* shrink-window-if-larger-than-buffer:   Change Window.       (line  64)
* size-indication-mode:                  Optional Mode Line.  (line   6)
* slitex-mode:                           TeX Mode.            (line   6)
* smerge-mode:                           Comparing Files.     (line  48)
* snake:                                 Amusements.          (line  48)
* solitaire:                             Amusements.          (line  51)
* sort-columns:                          Sorting.             (line  93)
* sort-fields:                           Sorting.             (line  23)
* sort-lines:                            Sorting.             (line  23)
* sort-numeric-fields:                   Sorting.             (line  23)
* sort-pages:                            Sorting.             (line  23)
* sort-paragraphs:                       Sorting.             (line  23)
* split-line:                            Indentation Commands.
                                                              (line  10)
* split-window-below:                    Split Window.        (line  13)
* split-window-right:                    Split Window.        (line  28)
* spook:                                 Mail Amusements.     (line   6)
* standard-display-8bit:                 Unibyte Mode.        (line  33)
* string-insert-rectangle:               Rectangles.          (line 109)
* string-rectangle:                      Rectangles.          (line 104)
* substitute-key-definition:             Init Examples.       (line 117)
* subword-mode:                          MixedCase Words.     (line  23)
* sunrise-sunset:                        Sunrise/Sunset.      (line  20)
* superword-mode:                        Misc for Programs.   (line  19)
* suspend-frame:                         Exiting.             (line  47)
* switch-to-buffer:                      Select Buffer.       (line  24)
* switch-to-buffer-other-frame:          Select Buffer.       (line  58)
* switch-to-buffer-other-window:         Select Buffer.       (line  53)
* switch-to-completions:                 Completion Commands. (line  38)
* tab-to-tab-stop:                       Indentation Commands.
                                                              (line  22)
* tabify:                                Just Spaces.         (line  26)
* table-backward-cell:                   Cell Commands.       (line   6)
* table-capture:                         Table Conversion.    (line   6)
* table-fixed-width-mode:                Text Based Tables.   (line  27)
* table-forward-cell:                    Cell Commands.       (line   6)
* table-generate-source:                 Table Misc.          (line  21)
* table-heighten-cell:                   Cell Commands.       (line  29)
* table-insert:                          Table Creation.      (line   6)
* table-insert-column:                   Table Rows and Columns.
                                                              (line  12)
* table-insert-row:                      Table Rows and Columns.
                                                              (line   6)
* table-insert-sequence:                 Table Misc.          (line  14)
* table-justify:                         Cell Justification.  (line  11)
* table-narrow-cell:                     Cell Commands.       (line  38)
* table-query-dimension:                 Table Misc.          (line   6)
* table-recognize:                       Table Recognition.   (line   6)
* table-recognize-cell:                  Table Recognition.   (line  30)
* table-recognize-region:                Table Recognition.   (line  18)
* table-recognize-table:                 Table Recognition.   (line  24)
* table-release:                         Table Conversion.    (line  29)
* table-shorten-cell:                    Cell Commands.       (line  32)
* table-span-cell:                       Cell Commands.       (line  12)
* table-split-cell:                      Cell Commands.       (line  16)
* table-split-cell-horizontally:         Cell Commands.       (line  16)
* table-split-cell-vertically:           Cell Commands.       (line  16)
* table-unrecognize:                     Table Recognition.   (line   6)
* table-unrecognize-cell:                Table Recognition.   (line  33)
* table-unrecognize-region:              Table Recognition.   (line  21)
* table-unrecognize-table:               Table Recognition.   (line  27)
* table-widen-cell:                      Cell Commands.       (line  35)
* tabulated-list-sort:                   Several Buffers.     (line 134)
* tags-loop-continue:                    Identifier Search.   (line  48)
* tags-query-replace:                    Identifier Search.   (line  53)
* tags-search:                           Identifier Search.   (line  41)
* temp-buffer-resize-mode:               Temporary Displays.  (line  28)
* term:                                  Terminal emulator.   (line   6)
* term-char-mode:                        Term Mode.           (line  13)
* term-line-mode:                        Term Mode.           (line   9)
* term-pager-toggle:                     Term Mode.           (line  30)
* tetris:                                Amusements.          (line  48)
* tex-bibtex-file:                       TeX Print.           (line 136)
* tex-buffer:                            TeX Print.           (line  38)
* tex-close-latex-block:                 LaTeX Editing.       (line  26)
* tex-compile:                           TeX Print.           (line 147)
* tex-file:                              TeX Print.           (line 106)
* tex-insert-braces:                     TeX Editing.         (line  40)
* tex-insert-quote:                      TeX Editing.         (line  22)
* tex-kill-job:                          TeX Print.           (line  75)
* tex-latex-block:                       LaTeX Editing.       (line  15)
* tex-mode:                              TeX Mode.            (line   6)
* tex-print:                             TeX Print.           (line  38)
* tex-recenter-output-buffer:            TeX Print.           (line  75)
* tex-region:                            TeX Print.           (line  86)
* tex-terminate-paragraph:               TeX Editing.         (line  49)
* tex-validate-region:                   TeX Editing.         (line  49)
* tex-view:                              TeX Print.           (line  38)
* text-mode:                             Text Mode.           (line   6)
* text-scale-adjust:                     Text Scale.          (line   6)
* text-scale-decrease:                   Text Scale.          (line  19)
* text-scale-increase:                   Text Scale.          (line  19)
* text-scale-mode:                       Text Scale.          (line  27)
* text-scale-set:                        Text Scale.          (line  24)
* thumbs-mode:                           File Conveniences.   (line  60)
* time-stamp:                            Time Stamps.         (line  16)
* timeclock-change:                      Time Intervals.      (line  11)
* timeclock-in:                          Time Intervals.      (line  11)
* timeclock-modeline-display:            Time Intervals.      (line  21)
* timeclock-out:                         Time Intervals.      (line  11)
* timeclock-reread-log:                  Time Intervals.      (line  32)
* timeclock-when-to-leave:               Time Intervals.      (line  11)
* timeclock-workday-remaining:           Time Intervals.      (line  11)
* tmm-menubar:                           Menu Bar.            (line  31)
* toggle-debug-on-error:                 Checklist.           (line 181)
* toggle-frame-fullscreen:               Frame Commands.      (line  29)
* toggle-frame-maximized:                Frame Commands.      (line  25)
* toggle-gdb-all-registers:              Other GDB Buffers.   (line  20)
* toggle-input-method:                   Select Input Method. (line  31)
* toggle-scroll-bar:                     Scroll Bars.         (line  23)
* toggle-truncate-lines:                 Line Truncation.     (line  12)
* tool-bar-mode:                         Tool Bars.           (line  16)
* tooltip-mode:                          Tooltips.            (line  11)
* top-level:                             Quitting.            (line  83)
* transient-mark-mode:                   Disabled Transient Mark.
                                                              (line   6)
* transpose-chars:                       Transpose.           (line  15)
* transpose-lines:                       Transpose.           (line  27)
* transpose-sexps:                       Expressions.         (line  46)
* transpose-words:                       Transpose.           (line  27)
* tty-suppress-bold-inverse-default-colors: Display Custom.   (line 112)
* uncomment-region:                      Comment Commands.    (line  79)
* undigestify-rmail-message:             Rmail Digest.        (line  15)
* undo:                                  Undo.                (line  21)
* undo-only:                             Undo.                (line  28)
* unexpand-abbrev:                       Expanding Abbrevs.   (line  29)
* unforward-rmail-message:               Rmail Reply.         (line  79)
* unhighlight-regexp:                    Highlight Interactively.
                                                              (line  48)
* universal-argument:                    Arguments.           (line  40)
* universal-coding-system-argument:      Text Coding.         (line  42)
* unmorse-region:                        Amusements.          (line  43)
* untabify:                              Just Spaces.         (line  26)
* up-list:                               TeX Editing.         (line  40)
* upcase-region:                         Case.                (line  40)
* upcase-word:                           Case.                (line  20)
* use-hard-newlines:                     Hard and Soft Newlines.
                                                              (line   6)
* vc-annotate:                           Old Revisions.       (line  80)
* vc-create-tag:                         Revision Tags.       (line  18)
* vc-delete-file:                        VC Delete/Rename.    (line  16)
* vc-diff:                               Old Revisions.       (line  30)
* vc-dir:                                VC Directory Mode.   (line  15)
* vc-dir-mark:                           VC Directory Commands.
                                                              (line  69)
* vc-dir-mark-all-files:                 VC Directory Commands.
                                                              (line  69)
* vc-ediff:                              Old Revisions.       (line  56)
* vc-ignore:                             VC Ignore.           (line  10)
* vc-insert-headers:                     Version Headers.     (line  20)
* vc-next-action:                        Basic VC Editing.    (line  27)
* vc-print-log:                          VC Change Log.       (line  18)
* vc-print-root-log:                     VC Change Log.       (line  30)
* vc-pull:                               Pulling / Pushing.   (line  39)
* vc-push:                               Pulling / Pushing.   (line  19)
* vc-refresh-state:                      Version Control.     (line  22)
* vc-region-history:                     VC Change Log.       (line 107)
* vc-register:                           Registering.         (line   9)
* vc-rename-file:                        VC Delete/Rename.    (line  23)
* vc-retrieve-tag:                       Revision Tags.       (line  23)
* vc-revert:                             VC Undo.             (line  10)
* vc-revision-other-window:              Old Revisions.       (line  75)
* vc-root-diff:                          Old Revisions.       (line  59)
* vc-state-refresh:                      Version Control.     (line  22)
* vc-update-change-log:                  Change Logs and VC.  (line  19)
* view-buffer:                           View Mode.           (line  16)
* view-echo-area-messages:               Misc Help.           (line  31)
* view-emacs-debugging:                  Help Files.          (line  13)
* view-emacs-FAQ:                        Help Files.          (line  13)
* view-emacs-news:                       Help Files.          (line  13)
* view-emacs-problems:                   Help Files.          (line  13)
* view-emacs-todo:                       Help Files.          (line  13)
* View-exit:                             View Mode.           (line  12)
* view-external-packages:                Help Files.          (line  13)
* view-file:                             View Mode.           (line  16)
* view-hello-file:                       International Chars. (line  19)
* view-lossage:                          Misc Help.           (line  25)
* view-order-manuals:                    Help Files.          (line  13)
* View-quit:                             View Mode.           (line  12)
* view-register:                         Registers.           (line  18)
* visit-tags-table:                      Select Tags Table.   (line   6)
* visual-line-mode:                      Visual Line Mode.    (line  12)
* w32-register-hot-key:                  Windows Keyboard.    (line  22)
* w32-shell-execute:                     Windows Processes.   (line  63)
* w32-unregister-hot-key:                Windows Keyboard.    (line  22)
* wdired-change-to-wdired-mode:          Wdired.              (line   6)
* wdired-finish-edit:                    Wdired.              (line  12)
* what-cursor-position:                  Position Info.       (line  54)
* what-cursor-position, and international characters: International Chars.
                                                              (line  37)
* what-line:                             Position Info.       (line  37)
* what-page:                             Pages.               (line  26)
* where-is:                              Key Help.            (line  25)
* which-function-mode:                   Which Function.      (line  10)
* whitespace-mode:                       Useless Whitespace.  (line  37)
* whitespace-toggle-options:             Useless Whitespace.  (line  37)
* widen:                                 Narrowing.           (line  44)
* widget-backward:                       Customization Groups.
                                                              (line  49)
* widget-complete:                       Changing a Variable. (line  53)
* widget-forward:                        Customization Groups.
                                                              (line  49)
* windmove-default-keybindings:          Window Convenience.  (line  18)
* windmove-right:                        Window Convenience.  (line  18)
* window-configuration-to-register:      Configuration Registers.
                                                              (line   6)
* window-divider-mode:                   Window Dividers.     (line  10)
* winner-mode:                           Window Convenience.  (line   6)
* woman:                                 Man Page.            (line  39)
* word-search-backward:                  Word Search.         (line  34)
* word-search-forward:                   Word Search.         (line  34)
* write-abbrev-file:                     Saving Abbrevs.      (line  21)
* write-file:                            Save Commands.       (line  93)
* write-region:                          Misc File Ops.       (line  44)
* xdb:                                   Starting GUD.        (line  40)
* xref-etags-mode:                       Looking Up Identifiers.
                                                              (line  64)
* xref-find-apropos:                     Looking Up Identifiers.
                                                              (line  48)
* xref-find-definitions:                 Looking Up Identifiers.
                                                              (line  25)
* xref-find-definitions-other-frame:     Looking Up Identifiers.
                                                              (line  41)
* xref-find-definitions-other-window:    Looking Up Identifiers.
                                                              (line  41)
* xref-find-references:                  Identifier Search.   (line  26)
* xref-next-line:                        Xref Commands.       (line  15)
* xref-pop-marker-stack:                 Looking Up Identifiers.
                                                              (line  57)
* xref-prev-line:                        Xref Commands.       (line  20)
* xref-query-replace-in-results:         Identifier Search.   (line  33)
* xref-quit:                             Xref Commands.       (line  36)
* xref-quit-and-goto-xref:               Xref Commands.       (line  28)
* xref-show-location-at-point:           Xref Commands.       (line  24)
* xwidget-webkit-browse-url:             Embedded WebKit Widgets.
                                                              (line   6)
* xwidget-webkit-mode:                   Embedded WebKit Widgets.
                                                              (line   6)
* yank:                                  Yanking.             (line  20)
* yank-pop:                              Earlier Kills.       (line  11)
* yank-rectangle:                        Rectangles.          (line  79)
* zap-to-char:                           Other Kill Commands. (line  40)
* zone:                                  Amusements.          (line  54)
* zrgrep:                                Grep Searching.      (line  71)


File: emacs-ja.info,  Node: Variable Index,  Next: Concept Index,  Prev: Command Index,  Up: Top

Variable Index
**************

 [index ]
* Menu:

* abbrev-all-caps:                       Expanding Abbrevs.   (line  13)
* abbrev-file-name:                      Saving Abbrevs.      (line  27)
* adaptive-fill-first-line-regexp:       Adaptive Fill.       (line  29)
* adaptive-fill-function:                Adaptive Fill.       (line  47)
* adaptive-fill-mode:                    Adaptive Fill.       (line  42)
* adaptive-fill-regexp:                  Adaptive Fill.       (line  42)
* add-log-always-start-new-record:       Change Log Commands. (line  31)
* add-log-keep-changes-together:         Change Log Commands. (line  24)
* ange-ftp-default-user:                 Remote Files.        (line  35)
* ange-ftp-gateway-host:                 Remote Files.        (line  59)
* ange-ftp-generate-anonymous-password:  Remote Files.        (line  50)
* ange-ftp-make-backup-files:            Remote Files.        (line  41)
* ange-ftp-smart-gateway:                Remote Files.        (line  59)
* appt-audible:                          Appointments.        (line   6)
* appt-delete-window-function:           Appointments.        (line  15)
* appt-disp-window-function:             Appointments.        (line  15)
* appt-display-diary:                    Appointments.        (line  46)
* appt-display-duration:                 Appointments.        (line  15)
* appt-display-format:                   Appointments.        (line   6)
* appt-display-mode-line:                Appointments.        (line   6)
* appt-message-warning-time:             Appointments.        (line  33)
* appt-warning-time-regexp:              Appointments.        (line  33)
* apropos-do-all:                        Apropos.             (line  79)
* apropos-documentation-sort-by-scores:  Apropos.             (line  84)
* apropos-sort-by-scores:                Apropos.             (line  84)
* async-shell-command-buffer:            Single Shell.        (line  45)
* async-shell-command-display-buffer:    Single Shell.        (line  51)
* auto-coding-alist:                     Recognize Coding.    (line  78)
* auto-coding-functions:                 Recognize Coding.    (line  86)
* auto-coding-regexp-alist:              Recognize Coding.    (line  78)
* auto-compression-mode:                 Compressed Files.    (line  16)
* auto-hscroll-mode:                     Horizontal Scrolling.
                                                              (line   6)
* auto-mode-alist:                       Choosing Modes.      (line   6)
* auto-mode-case-fold:                   Choosing Modes.      (line  98)
* auto-revert-check-vc-info:             VC Mode Line.        (line  31)
* auto-revert-interval:                  Reverting.           (line  35)
* auto-revert-remote-files:              Reverting.           (line  35)
* auto-revert-use-notify:                Reverting.           (line  45)
* auto-revert-verbose:                   Reverting.           (line  35)
* auto-save-default:                     Auto Save Control.   (line   6)
* auto-save-file-name-transforms:        Auto Save Files.     (line  24)
* auto-save-interval:                    Auto Save Control.   (line  14)
* auto-save-list-file-prefix:            Recover.             (line  36)
* auto-save-timeout:                     Auto Save Control.   (line  20)
* auto-save-visited-interval:            Auto Save Control.   (line  31)
* auto-save-visited-mode:                Auto Save Files.     (line  36)
* backup-by-copying:                     Backup Copying.      (line  20)
* backup-by-copying-when-linked:         Backup Copying.      (line  20)
* backup-by-copying-when-mismatch:       Backup Copying.      (line  20)
* backup-by-copying-when-privileged-mismatch: Backup Copying. (line  20)
* backup-directory-alist:                Backup.              (line  45)
* backup-enable-predicate:               Backup.              (line  32)
* battery-mode-line-format:              Optional Mode Line.  (line  70)
* bdf-directory-list:                    PostScript Variables.
                                                              (line  66)
* bidi-display-reordering:               Bidirectional Editing.
                                                              (line  28)
* bidi-paragraph-direction:              Bidirectional Editing.
                                                              (line  45)
* bidi-paragraph-separate-re:            Bidirectional Editing.
                                                              (line  33)
* bidi-paragraph-start-re:               Bidirectional Editing.
                                                              (line  33)
* blink-cursor-alist:                    Cursor Display.      (line  23)
* blink-cursor-blinks:                   Cursor Display.      (line  23)
* blink-cursor-mode:                     Cursor Display.      (line  23)
* blink-matching-delay:                  Matching.            (line  17)
* blink-matching-paren:                  Matching.            (line  17)
* blink-matching-paren-distance:         Matching.            (line  17)
* bookmark-default-file:                 Bookmarks.           (line  63)
* bookmark-save-flag:                    Bookmarks.           (line  56)
* bookmark-search-size:                  Bookmarks.           (line  66)
* browse-url-browser-function:           Browse-URL.          (line  20)
* browse-url-mailto-function:            Browse-URL.          (line  20)
* buffer-file-coding-system:             Output Coding.       (line   6)
* buffer-read-only:                      Misc Buffer.         (line  16)
* c-default-style:                       Custom C Indent.     (line  33)
* c-hungry-delete-key:                   Hungry Delete.       (line  33)
* c-mode-hook:                           Program Modes.       (line  38)
* c-tab-always-indent:                   C Indent.            (line  21)
* cal-html-css-default:                  Writing Calendar Files.
                                                              (line  16)
* calendar-bahai-all-holidays-flag:      Holiday Customizing. (line  23)
* calendar-christian-all-holidays-flag:  Holiday Customizing. (line  23)
* calendar-date-display-form:            Date Display Format. (line   6)
* calendar-date-style:                   Date Formats.        (line  43)
* calendar-day-header-array:             Calendar Customizing.
                                                              (line  15)
* calendar-daylight-savings-ends:        Daylight Saving.     (line  11)
* calendar-daylight-savings-ends-time:   Daylight Saving.     (line  47)
* calendar-daylight-savings-starts:      Daylight Saving.     (line  11)
* calendar-daylight-time-offset:         Daylight Saving.     (line  44)
* calendar-daylight-time-zone-name:      Sunrise/Sunset.      (line  51)
* calendar-hebrew-all-holidays-flag:     Holiday Customizing. (line  23)
* calendar-holiday-marker:               Calendar Customizing.
                                                              (line  20)
* calendar-holidays:                     Holiday Customizing. (line   6)
* calendar-initial-window-hook:          Calendar Customizing.
                                                              (line  29)
* calendar-intermonth-text:              Calendar Customizing.
                                                              (line   6)
* calendar-islamic-all-holidays-flag:    Holiday Customizing. (line  23)
* calendar-latitude:                     Sunrise/Sunset.      (line  38)
* calendar-location-name:                Sunrise/Sunset.      (line  38)
* calendar-longitude:                    Sunrise/Sunset.      (line  38)
* calendar-mark-diary-entries-flag:      Displaying the Diary.
                                                              (line  44)
* calendar-mark-holidays-flag:           Holidays.            (line  32)
* calendar-month-header:                 Calendar Customizing.
                                                              (line  15)
* calendar-move-hook:                    Calendar Customizing.
                                                              (line  45)
* calendar-remove-frame-by-deleting:     General Calendar.    (line  33)
* calendar-standard-time-zone-name:      Sunrise/Sunset.      (line  51)
* calendar-time-display-form:            Time Display Format. (line   6)
* calendar-time-zone:                    Sunrise/Sunset.      (line  51)
* calendar-today-invisible-hook:         Calendar Customizing.
                                                              (line  42)
* calendar-today-marker:                 Calendar Customizing.
                                                              (line  20)
* calendar-today-visible-hook:           Calendar Customizing.
                                                              (line  34)
* calendar-view-diary-initially-flag:    Displaying the Diary.
                                                              (line  29)
* calendar-view-holidays-initially-flag: Holidays.            (line  26)
* calendar-week-start-day:               Move to Beginning or End.
                                                              (line  26)
* calendar-weekend-days:                 Move to Beginning or End.
                                                              (line  26)
* case-fold-search:                      Lax Search.          (line  51)
* case-replace:                          Replacement and Lax Matches.
                                                              (line  26)
* CDPATH, environment variable:          General Variables.   (line  12)
* change-log-version-info-enabled:       Change Log Commands. (line  35)
* change-log-version-number-regexp-list: Change Log Commands. (line  35)
* change-major-mode-with-file-name:      Choosing Modes.      (line 119)
* clone-indirect-buffer-hook:            Indirect Buffers.    (line  36)
* coding:                                Specify Coding.      (line  13)
* colon-double-space:                    Fill Commands.       (line  61)
* column-number-indicator-zero-based:    Optional Mode Line.  (line  28)
* comint-completion-addsuffix:           Shell Options.       (line  32)
* comint-completion-autolist:            Shell Options.       (line  32)
* comint-completion-fignore:             Shell Options.       (line  45)
* comint-completion-recexact:            Shell Options.       (line  32)
* comint-input-autoexpand:               History References.  (line  16)
* comint-input-ignoredups:               Shell Options.       (line  27)
* comint-move-point-for-output:          Shell Options.       (line  15)
* comint-prompt-read-only:               Shell Options.       (line  24)
* comint-scroll-show-maximum-output:     Shell Options.       (line  10)
* comint-scroll-to-bottom-on-input:      Shell Options.       (line   6)
* comint-terminfo-terminal:              Shell Options.       (line  61)
* comint-use-prompt-regexp:              Shell Prompts.       (line  22)
* command-history:                       Repetition.          (line  43)
* command-line-args:                     Emacs Invocation.    (line  38)
* comment-column:                        Options for Comments.
                                                              (line   6)
* comment-end:                           Options for Comments.
                                                              (line  28)
* comment-fill-column:                   Options for Comments.
                                                              (line   6)
* comment-indent-function:               Options for Comments.
                                                              (line  43)
* comment-multi-line:                    Multi-Line Comments. (line   6)
* comment-padding:                       Options for Comments.
                                                              (line  34)
* comment-start:                         Options for Comments.
                                                              (line  28)
* comment-start-skip:                    Options for Comments.
                                                              (line  18)
* compare-ignore-case:                   Comparing Files.     (line  42)
* compare-ignore-whitespace:             Comparing Files.     (line  42)
* compilation-always-kill:               Compilation.         (line  71)
* compilation-auto-jump-to-first-error:  Compilation Mode.    (line  13)
* compilation-context-lines:             Compilation Mode.    (line  94)
* compilation-environment:               Compilation.         (line  84)
* compilation-error-regexp-alist:        Compilation Mode.    (line 104)
* compilation-scroll-output:             Compilation.         (line  58)
* compilation-skip-threshold:            Compilation Mode.    (line  84)
* compile-command:                       Compilation.         (line  30)
* completion-auto-help:                  Completion Options.  (line  34)
* completion-category-overrides:         Completion Styles.   (line  63)
* completion-cycle-threshold:            Completion Options.  (line  41)
* completion-ignored-extensions:         Completion Options.  (line  19)
* completion-styles:                     Completion Styles.   (line  19)
* COMSPEC:                               Misc Variables.      (line   8)
* confirm-kill-emacs:                    Exiting.             (line  31)
* confirm-kill-processes:                Exiting.             (line  37)
* confirm-nonexistent-file-or-buffer:    Completion Exit.     (line  43)
* create-lockfiles:                      Interlocking.        (line  24)
* ctl-arrow:                             Text Display.        (line  24)
* ctl-x-4-map:                           Prefix Keymaps.      (line  36)
* ctl-x-map:                             Prefix Keymaps.      (line  31)
* cua-enable-cua-keys:                   CUA Bindings.        (line   6)
* cua-mode:                              CUA Bindings.        (line   6)
* current-input-method:                  Select Input Method. (line  25)
* current-language-environment:          Language Environments.
                                                              (line  20)
* cursor-in-non-selected-windows:        Cursor Display.      (line  44)
* cursor-type:                           Cursor Display.      (line  13)
* custom-buffer-done-kill:               Changing a Variable. (line 141)
* custom-enabled-themes:                 Custom Themes.       (line  54)
* custom-file:                           Saving Customizations.
                                                              (line  16)
* custom-safe-themes:                    Custom Themes.       (line  44)
* custom-search-field:                   Browsing Custom.     (line  19)
* custom-theme-directory:                Custom Themes.       (line  16)
* custom-theme-directory, saving theme files: Creating Custom Themes.
                                                              (line  28)
* custom-theme-load-path:                Custom Themes.       (line  28)
* dabbrev-abbrev-char-regexp:            Dabbrev Customization.
                                                              (line  33)
* dabbrev-abbrev-skip-leading-regexp:    Dabbrev Customization.
                                                              (line  45)
* dabbrev-case-fold-search:              Dabbrev Customization.
                                                              (line   9)
* dabbrev-case-replace:                  Dabbrev Customization.
                                                              (line  19)
* dabbrev-check-all-buffers:             Dynamic Abbrevs.     (line  29)
* dabbrev-check-other-buffers:           Dynamic Abbrevs.     (line  29)
* dabbrev-ignored-buffer-names:          Dynamic Abbrevs.     (line  33)
* dabbrev-ignored-buffer-regexps:        Dynamic Abbrevs.     (line  33)
* dabbrev-limit:                         Dynamic Abbrevs.     (line  20)
* DBUS_SESSION_BUS_ADDRESS, environment variable: General Variables.
                                                              (line  15)
* dbx-mode-hook:                         GUD Customization.   (line   6)
* debug-on-event:                        Checklist.           (line 199)
* debug-on-quit:                         Checklist.           (line 193)
* default-directory:                     File Names.          (line  24)
* default-frame-alist:                   Frame Parameters.    (line   6)
* default-input-method:                  Select Input Method. (line  44)
* default-justification:                 Enriched Justification.
                                                              (line  30)
* delete-active-region:                  Using Region.        (line  39)
* delete-auto-save-files:                Auto Save Files.     (line  51)
* delete-by-moving-to-trash:             Misc File Ops.       (line  20)
* delete-by-moving-to-trash, and Dired:  Dired Deletion.      (line  71)
* delete-old-versions:                   Backup Deletion.     (line  21)
* delete-trailing-lines:                 Useless Whitespace.  (line  21)
* desktop-auto-save-timeout:             Saving Emacs Sessions.
                                                              (line  71)
* desktop-clear-preserve-buffers-regexp: Saving Emacs Sessions.
                                                              (line  61)
* desktop-files-not-to-save:             Saving Emacs Sessions.
                                                              (line  15)
* desktop-globals-to-clear:              Saving Emacs Sessions.
                                                              (line  61)
* desktop-load-locked-desktop:           Saving Emacs Sessions.
                                                              (line  76)
* desktop-path:                          Saving Emacs Sessions.
                                                              (line  39)
* desktop-restore-eager:                 Saving Emacs Sessions.
                                                              (line  55)
* desktop-restore-frames:                Saving Emacs Sessions.
                                                              (line   6)
* desktop-save-mode:                     Saving Emacs Sessions.
                                                              (line  29)
* diary-bahai-entry-symbol:              Non-Gregorian Diary. (line  21)
* diary-chinese-entry-symbol:            Non-Gregorian Diary. (line  21)
* diary-comment-start:                   Fancy Diary Display. (line  19)
* diary-date-forms:                      Diary Customizing.   (line  22)
* diary-display-function:                Diary Display.       (line   6)
* diary-entry-marker:                    Calendar Customizing.
                                                              (line  20)
* diary-file:                            Format of Diary File.
                                                              (line   6)
* diary-hebrew-entry-symbol:             Non-Gregorian Diary. (line  21)
* diary-include-string:                  Fancy Diary Display. (line  25)
* diary-islamic-entry-symbol:            Non-Gregorian Diary. (line  21)
* diary-list-entries-hook:               Fancy Diary Display. (line  38)
* diary-list-include-blanks:             Diary Display.       (line  14)
* diary-mail-days:                       Displaying the Diary.
                                                              (line  74)
* diary-mark-entries-hook:               Fancy Diary Display. (line  38)
* diary-nongregorian-listing-hook:       Non-Gregorian Diary. (line  13)
* diary-nongregorian-marking-hook:       Non-Gregorian Diary. (line  13)
* diary-nonmarking-symbol:               Displaying the Diary.
                                                              (line  55)
* diary-number-of-entries:               Diary Customizing.   (line  12)
* diary-outlook-formats:                 Importing Diary.     (line   9)
* diary-print-entries-hook:              Diary Display.       (line  33)
* diary-sexp-entry-symbol:               Sexp Diary Entries.  (line   6)
* diary-show-holidays-flag:              Diary Customizing.   (line   6)
* diff-switches:                         Comparing Files.     (line   6)
* diff-update-on-the-fly:                Diff Mode.           (line  18)
* directory-abbrev-alist:                File Aliases.        (line  32)
* directory-free-space-args:             Directories.         (line  47)
* directory-free-space-program:          Directories.         (line  47)
* dired-auto-revert-buffer:              Dired Updating.      (line  45)
* dired-chown-program:                   Operating on Files.  (line  90)
* dired-copy-preserve-time:              Operating on Files.  (line  37)
* dired-dwim-target:                     Operating on Files.  (line  23)
* dired-garbage-files-regexp:            Flagging Many Files. (line  50)
* dired-hide-details-hide-information-lines: Misc Dired Features.
                                                              (line  38)
* dired-hide-details-hide-symlink-targets: Misc Dired Features.
                                                              (line  38)
* dired-isearch-filenames:               Dired Navigation.    (line  21)
* dired-kept-versions:                   Flagging Many Files. (line  38)
* dired-listing-switches:                Dired Enter.         (line   6)
* dired-listing-switches (MS-DOS):       MS-DOS Processes.    (line  47)
* dired-recursive-copies:                Operating on Files.  (line  41)
* dired-recursive-deletes:               Dired Deletion.      (line  55)
* dired-use-ls-dired:                    Dired Enter.         (line  35)
* dirtrack-list:                         Directory Tracking.  (line  25)
* display-battery-mode:                  Optional Mode Line.  (line  70)
* display-hourglass:                     Display Custom.      (line  81)
* display-line-numbers:                  Display Custom.      (line   9)
* display-line-numbers-current-absolute: Display Custom.      (line  46)
* display-line-numbers-grow-only:        Display Custom.      (line  59)
* display-line-numbers-type:             Display Custom.      (line  37)
* display-line-numbers-widen:            Display Custom.      (line  54)
* display-line-numbers-width:            Display Custom.      (line  59)
* display-line-numbers-width-start:      Display Custom.      (line  59)
* display-raw-bytes-as-hex:              Display Custom.      (line 116)
* display-time-24hr-format:              Optional Mode Line.  (line  54)
* display-time-mail-directory:           Optional Mode Line.  (line  60)
* display-time-mail-face:                Optional Mode Line.  (line  60)
* display-time-mail-file:                Optional Mode Line.  (line  60)
* display-time-use-mail-icon:            Optional Mode Line.  (line  60)
* dnd-open-file-other-window:            Drag and Drop.       (line  14)
* doc-view-cache-directory:              DocView Conversion.  (line   6)
* doc-view-continuous:                   DocView Navigation.  (line   9)
* doc-view-resolution:                   DocView Navigation.  (line  30)
* doctex-mode-hook:                      TeX Misc.            (line   6)
* dos-codepage:                          MS-DOS and MULE.     (line  33)
* dos-display-scancodes:                 MS-DOS Mouse.        (line  50)
* dos-hyper-key:                         MS-DOS Keyboard.     (line  21)
* dos-keypad-mode:                       MS-DOS Keyboard.     (line  32)
* dos-printer:                           MS-DOS Printing.     (line  26)
* dos-ps-printer:                        MS-DOS Printing.     (line  26)
* dos-super-key:                         MS-DOS Keyboard.     (line  21)
* double-click-fuzz:                     Mouse Buttons.       (line  74)
* double-click-time:                     Mouse Buttons.       (line  69)
* echo-keystrokes:                       Display Custom.      (line  76)
* electric-pair-delete-adjacent-pairs:   Matching.            (line  78)
* electric-pair-open-newline-between-pairs: Matching.         (line  81)
* electric-pair-preserve-balance:        Matching.            (line  75)
* electric-pair-skip-whitespace:         Matching.            (line  85)
* electric-quote-chars:                  Quotation Marks.     (line  15)
* electric-quote-comment:                Quotation Marks.     (line  22)
* electric-quote-paragraph:              Quotation Marks.     (line  22)
* electric-quote-string:                 Quotation Marks.     (line  22)
* emacs-lisp-mode-hook:                  Program Modes.       (line  38)
* EMACSCLIENT_TRAMP, environment variable: emacsclient Options.
                                                              (line 140)
* EMACSCOLORS:                           Misc Variables.      (line  20)
* EMACSDATA, environment variable:       General Variables.   (line  21)
* EMACSDOC, environment variable:        General Variables.   (line  24)
* EMACSLOADPATH, environment variable:   General Variables.   (line  27)
* EMACSPATH, environment variable:       General Variables.   (line  35)
* EMACSTEST:                             Misc Variables.      (line  16)
* emacs_dir:                             Misc Variables.      (line  42)
* EMACS_SERVER_FILE, environment variable: TCP Emacs server.  (line  40)
* EMAIL, environment variable:           General Variables.   (line  40)
* emerge-combine-versions-template:      Combining in Emerge. (line  15)
* emerge-startup-hook:                   Fine Points of Emerge.
                                                              (line  20)
* enable-local-eval:                     Safe File Variables. (line  45)
* enable-local-variables:                Safe File Variables. (line  38)
* enable-recursive-minibuffers:          Minibuffer Edit.     (line  56)
* enriched-allow-eval-in-display-props:  Enriched Properties. (line  15)
* enriched-translations:                 Enriched Mode.       (line  21)
* eol-mnemonic-dos:                      Optional Mode Line.  (line  95)
* eol-mnemonic-mac:                      Optional Mode Line.  (line  95)
* eol-mnemonic-undecided:                Optional Mode Line.  (line  95)
* eol-mnemonic-unix:                     Optional Mode Line.  (line  95)
* esc-map:                               Prefix Keymaps.      (line  34)
* ESHELL, environment variable:          General Variables.   (line  45)
* eval-expression-debug-on-error:        Lisp Eval.           (line  68)
* eval-expression-print-length:          Lisp Eval.           (line  68)
* eval-expression-print-level:           Lisp Eval.           (line  68)
* eval-expression-print-maximum-character: Lisp Eval.         (line  68)
* eww-search-prefix:                     Word Search.         (line  53)
* exec-path:                             Shell.               (line  26)
* exit-language-environment-hook:        Language Environments.
                                                              (line  91)
* explicit-shell-file-name:              Interactive Shell.   (line  37)
* extended-command-suggest-shorter:      M-x.                 (line  60)
* face-ignored-fonts:                    Modifying Fontsets.  (line  35)
* fast-but-imprecise-scrolling:          Scrolling.           (line  74)
* ff-related-file-alist:                 Other C Commands.    (line  95)
* file-coding-system-alist:              Recognize Coding.    (line  39)
* file-name-at-point-functions:          Minibuffer History.  (line  42)
* file-name-coding-system:               File Name Coding.    (line  14)
* fill-column:                           Fill Commands.       (line  39)
* fill-nobreak-predicate:                Fill Commands.       (line  64)
* fill-prefix:                           Fill Prefix.         (line  77)
* find-file-existing-other-name:         File Aliases.        (line  15)
* find-file-hook:                        Visiting.            (line 158)
* find-file-not-found-functions:         Visiting.            (line 158)
* find-file-run-dired:                   Visiting.            (line  88)
* find-file-suppress-same-file-warnings: File Aliases.        (line  15)
* find-file-visit-truename:              File Aliases.        (line  26)
* find-file-wildcards:                   Visiting.            (line  70)
* find-ls-option:                        Dired and Find.      (line  35)
* focus-follows-mouse:                   Frame Commands.      (line  53)
* foldout-mouse-modifiers:               Foldout.             (line  74)
* font-lock-maximum-decoration:          Font Lock.           (line  39)
* font-slant-table (MS-Windows):         Windows Fonts.       (line  41)
* font-weight-table (MS-Windows):        Windows Fonts.       (line  34)
* fortran-analyze-depth:                 ForIndent Cont.      (line  17)
* fortran-break-before-delimiters:       Fortran Autofill.    (line  14)
* fortran-check-all-num...:              ForIndent Vars.      (line   6)
* fortran-column-ruler-fixed:            Fortran Columns.     (line  42)
* fortran-column-ruler-tabs:             Fortran Columns.     (line  42)
* fortran-comment-indent-char:           Fortran Comments.    (line  63)
* fortran-comment-indent-style:          Fortran Comments.    (line  46)
* fortran-comment-line-extra-indent:     Fortran Comments.    (line  46)
* fortran-comment-line-start:            Fortran Comments.    (line  11)
* fortran-comment-region:                Fortran Comments.    (line  78)
* fortran-continuation-indent:           ForIndent Vars.      (line   6)
* fortran-continuation-string:           ForIndent Cont.      (line   6)
* fortran-directive-re:                  Fortran Comments.    (line  67)
* fortran-do-indent:                     ForIndent Vars.      (line   6)
* fortran-electric-line-number:          ForIndent Num.       (line  18)
* fortran-if-indent:                     ForIndent Vars.      (line   6)
* fortran-line-length:                   Fortran Columns.     (line   6)
* fortran-line-number-indent:            ForIndent Num.       (line  11)
* fortran-minimum-statement-indent...:   ForIndent Vars.      (line   6)
* fortran-structure-indent:              ForIndent Vars.      (line   6)
* fortran-tab-mode-default:              ForIndent Cont.      (line  17)
* frame-background-mode:                 Faces.               (line  19)
* frame-resize-pixelwise:                Frame Commands.      (line  33)
* frameset-filter-alist:                 Saving Emacs Sessions.
                                                              (line  19)
* fringe-mode (variable):                Fringes.             (line   6)
* gdb-delete-out-of-scope:               Watch Expressions.   (line  37)
* gdb-gud-control-all-threads:           Multithreaded Debugging.
                                                              (line  39)
* gdb-many-windows:                      GDB User Interface Layout.
                                                              (line   6)
* gdb-mode-hook:                         GUD Customization.   (line   6)
* gdb-non-stop-setting:                  Multithreaded Debugging.
                                                              (line  16)
* gdb-show-changed-values:               Watch Expressions.   (line  32)
* gdb-show-threads-by-default:           Breakpoints Buffer.  (line  29)
* gdb-speedbar-auto-raise:               Watch Expressions.   (line  46)
* gdb-stopped-functions:                 Multithreaded Debugging.
                                                              (line  33)
* gdb-switch-reasons:                    Multithreaded Debugging.
                                                              (line  29)
* gdb-switch-when-another-stopped:       Multithreaded Debugging.
                                                              (line  24)
* gdb-thread-buffer-addresses:           Threads Buffer.      (line  25)
* gdb-thread-buffer-arguments:           Threads Buffer.      (line  19)
* gdb-thread-buffer-locations:           Threads Buffer.      (line  22)
* gdb-thread-buffer-verbose-names:       Threads Buffer.      (line  16)
* gdb-use-colon-colon-notation:          Watch Expressions.   (line  42)
* global-cwarn-mode:                     Other C Commands.    (line  72)
* global-font-lock-mode:                 Font Lock.           (line  17)
* global-mark-ring-max:                  Global Mark Ring.    (line   6)
* grep-find-ignored-directories:         Grep Searching.      (line  84)
* grep-find-ignored-directories (Dired): Operating on Files.  (line 153)
* grep-find-ignored-files (Dired):       Operating on Files.  (line 153)
* grep-regexp-alist:                     Compilation Mode.    (line 104)
* gud-gdb-command-name:                  GDB Graphical Interface.
                                                              (line  12)
* gud-tooltip-echo-area:                 Debugger Operation.  (line  30)
* gud-xdb-directories:                   Starting GUD.        (line  40)
* guiler-mode-hook:                      GUD Customization.   (line   6)
* help-at-pt-display-when-idle:          Help Echo.           (line  14)
* help-enable-auto-load:                 Lisp Libraries.      (line  71)
* help-map:                              Prefix Keymaps.      (line  33)
* hi-lock-auto-select-face:              Highlight Interactively.
                                                              (line  38)
* hi-lock-exclude-modes:                 Highlight Interactively.
                                                              (line 105)
* hi-lock-file-patterns-policy:          Highlight Interactively.
                                                              (line  96)
* hide-ifdef-shadow:                     Other C Commands.    (line  87)
* highlight-nonselected-windows:         Mark.                (line  31)
* HISTFILE, environment variable:        General Variables.   (line  48)
* history-delete-duplicates:             Minibuffer History.  (line  85)
* history-length:                        Minibuffer History.  (line  81)
* holiday-bahai-holidays:                Holiday Customizing. (line  23)
* holiday-christian-holidays:            Holiday Customizing. (line  23)
* holiday-general-holidays:              Holiday Customizing. (line  18)
* holiday-hebrew-holidays:               Holiday Customizing. (line  23)
* holiday-islamic-holidays:              Holiday Customizing. (line  23)
* holiday-local-holidays:                Holiday Customizing. (line  18)
* holiday-oriental-holidays:             Holiday Customizing. (line   6)
* holiday-other-holidays:                Holiday Customizing. (line  18)
* holiday-solar-holidays:                Holiday Customizing. (line   6)
* HOME, environment variable:            General Variables.   (line  52)
* horizontal-scroll-bar-mode:            Scroll Bars.         (line  87)
* HOSTNAME, environment variable:        General Variables.   (line  62)
* hourglass-delay:                       Display Custom.      (line  81)
* hs-hide-comments-when-hiding-all:      Hideshow.            (line  41)
* hs-isearch-open:                       Hideshow.            (line  41)
* hs-special-modes-alist:                Hideshow.            (line  41)
* hscroll-margin:                        Horizontal Scrolling.
                                                              (line  20)
* hscroll-step:                          Horizontal Scrolling.
                                                              (line  25)
* image-animate-loop:                    File Conveniences.   (line  33)
* image-dired-external-viewer:           Image-Dired.         (line  32)
* imagemagick-enabled-types:             File Conveniences.   (line  46)
* imagemagick-types-inhibit:             File Conveniences.   (line  46)
* imenu-auto-rescan:                     Imenu.               (line  24)
* imenu-sort-function:                   Imenu.               (line  30)
* indent-tabs-mode:                      Just Spaces.         (line  12)
* indent-tabs-mode (Fortran mode):       ForIndent Cont.      (line  17)
* indicate-buffer-boundaries:            Displaying Boundaries.
                                                              (line   6)
* indicate-empty-lines:                  Useless Whitespace.  (line  28)
* inferior-lisp-program:                 External Lisp.       (line  11)
* INFOPATH, environment variable:        General Variables.   (line  64)
* inhibit-eol-conversion:                Recognize Coding.    (line  52)
* inhibit-iso-escape-detection:          Recognize Coding.    (line  60)
* inhibit-startup-buffer-menu:           Action Arguments.    (line  12)
* inhibit-startup-screen:                Entering Emacs.      (line  45)
* initial-environment:                   Environment.         (line  17)
* initial-frame-alist:                   Frame Parameters.    (line  24)
* initial-scratch-message:               Lisp Interaction.    (line  18)
* input-method-highlight-flag:           Input Methods.       (line  87)
* input-method-verbose-flag:             Input Methods.       (line  87)
* insert-default-directory:              Minibuffer File.     (line  62)
* interpreter-mode-alist:                Choosing Modes.      (line  42)
* isearch-allow-prefix:                  Not Exiting Isearch. (line  22)
* isearch-allow-scroll:                  Not Exiting Isearch. (line  37)
* isearch-hide-immediately:              Search Customizations.
                                                              (line  47)
* isearch-lazy-highlight:                Search Customizations.
                                                              (line  23)
* isearch-mode-map:                      Special Isearch.     (line  90)
* isearch-resume-in-command-history:     Repetition.          (line  36)
* ispell-complete-word-dict:             Spelling.            (line 144)
* ispell-dictionary:                     Spelling.            (line 134)
* ispell-local-dictionary:               Spelling.            (line 134)
* ispell-personal-dictionary:            Spelling.            (line 134)
* jdb-mode-hook:                         GUD Customization.   (line   6)
* kept-new-versions:                     Backup Deletion.     (line  11)
* kept-old-versions:                     Backup Deletion.     (line  11)
* keyboard-coding-system:                Terminal Coding.     (line  28)
* kill-buffer-hook:                      Kill Buffer.         (line  45)
* kill-do-not-save-duplicates:           Kill Options.        (line  14)
* kill-read-only-ok:                     Kill Options.        (line   6)
* kill-ring:                             Kill Ring.           (line  18)
* kill-ring-max:                         Kill Ring.           (line  14)
* kill-whole-line:                       Killing by Lines.    (line  29)
* kmacro-ring-max:                       Keyboard Macro Ring. (line  54)
* LANG, environment variable:            General Variables.   (line  74)
* large-file-warning-threshold:          Visiting.            (line  62)
* latex-block-names:                     LaTeX Editing.       (line  20)
* latex-mode-hook:                       TeX Misc.            (line   6)
* latex-run-command:                     TeX Print.           (line  53)
* latin1-display:                        Undisplayable Characters.
                                                              (line  20)
* LC_ALL, environment variable:          General Variables.   (line  67)
* LC_COLLATE, environment variable:      General Variables.   (line  68)
* LC_CTYPE, environment variable:        General Variables.   (line  69)
* LC_MESSAGES, environment variable:     General Variables.   (line  70)
* LC_MONETARY, environment variable:     General Variables.   (line  71)
* LC_NUMERIC, environment variable:      General Variables.   (line  72)
* LC_TIME, environment variable:         General Variables.   (line  73)
* line-move-visual:                      Moving Point.        (line 137)
* line-number-display-limit:             Optional Mode Line.  (line  37)
* line-number-display-limit-width:       Optional Mode Line.  (line  42)
* lisp-body-indent:                      Lisp Indent.         (line  19)
* lisp-indent-offset:                    Lisp Indent.         (line  15)
* lisp-interaction-mode-hook:            Program Modes.       (line  38)
* lisp-mode-hook:                        Program Modes.       (line  38)
* list-colors-sort:                      Colors.              (line  12)
* list-directory-brief-switches:         Directories.         (line  40)
* list-directory-verbose-switches:       Directories.         (line  40)
* list-matching-lines-default-context-lines: Other Repeating Search.
                                                              (line  42)
* list-matching-lines-jump-to-current-line: Other Repeating Search.
                                                              (line  42)
* load-dangerous-libraries:              Lisp Libraries.      (line  78)
* load-path:                             Lisp Libraries.      (line  43)
* load-prefer-newer:                     Lisp Libraries.      (line  21)
* locale-charset-language-names:         Language Environments.
                                                              (line  46)
* locale-coding-system:                  Communication Coding.
                                                              (line  57)
* locale-language-names:                 Language Environments.
                                                              (line  46)
* locale-preferred-coding-systems:       Language Environments.
                                                              (line  63)
* locate-command:                        Dired and Find.      (line  40)
* LOGNAME, environment variable:         General Variables.   (line  95)
* lpr-add-switches:                      Printing.            (line  44)
* lpr-command (MS-DOS):                  Windows Printing.    (line  75)
* lpr-commands:                          Printing.            (line  30)
* lpr-headers-switches:                  Printing.            (line  44)
* lpr-headers-switches (MS-DOS):         Windows Printing.    (line  64)
* lpr-printer-switch:                    Printing.            (line  38)
* lpr-switches:                          Printing.            (line  30)
* lpr-switches (MS-DOS):                 Windows Printing.    (line  75)
* ls-lisp-dirs-first:                    ls in Lisp.          (line  48)
* ls-lisp-emulation:                     ls in Lisp.          (line  63)
* ls-lisp-format-time-list:              ls in Lisp.          (line  99)
* ls-lisp-ignore-case:                   ls in Lisp.          (line  42)
* ls-lisp-support-shell-wildcards:       ls in Lisp.          (line  94)
* ls-lisp-UCA-like-collation:            ls in Lisp.          (line  35)
* ls-lisp-use-insert-directory-program:  ls in Lisp.          (line  22)
* ls-lisp-use-localized-time-format:     ls in Lisp.          (line 115)
* ls-lisp-use-string-collate:            ls in Lisp.          (line  31)
* ls-lisp-verbosity:                     ls in Lisp.          (line  54)
* magic-fallback-mode-alist:             Choosing Modes.      (line 105)
* magic-mode-alist:                      Choosing Modes.      (line  58)
* MAIL, environment variable:            General Variables.   (line  97)
* mail-citation-hook:                    Citing Mail.         (line  31)
* mail-default-headers:                  Mail Headers.        (line 101)
* mail-dont-reply-to-names:              Rmail Reply.         (line  37)
* mail-from-style:                       Mail Headers.        (line  24)
* mail-personal-alias-file:              Mail Aliases.        (line   6)
* mail-signature:                        Mail Signature.      (line  24)
* mail-signature-file:                   Mail Signature.      (line  24)
* mail-user-agent:                       Mail Methods.        (line  13)
* major-mode:                            Major Modes.         (line  39)
* make-backup-file-name-function:        Backup Names.        (line  48)
* make-backup-files:                     Backup.              (line   6)
* make-pointer-invisible:                Display Custom.      (line  87)
* Man-switches:                          Man Page.            (line  31)
* mark-even-if-inactive:                 Using Region.        (line  48)
* mark-ring-max:                         Mark Ring.           (line  42)
* max-mini-window-height:                Minibuffer Edit.     (line  44)
* maximum-scroll-margin:                 Auto Scrolling.      (line  51)
* menu-bar-mode:                         Menu Bars.           (line   6)
* message-kill-buffer-on-exit:           Mail Sending.        (line  13)
* message-log-max:                       Echo Area.           (line  32)
* message-mode-hook:                     Mail Misc.           (line  41)
* message-send-hook:                     Mail Sending.        (line  23)
* message-setup-hook:                    Mail Misc.           (line  41)
* message-signature:                     Mail Signature.      (line   6)
* message-signature-file:                Mail Signature.      (line   6)
* MH, environment variable:              General Variables.   (line  99)
* midnight-hook:                         Kill Buffer.         (line  59)
* midnight-mode:                         Kill Buffer.         (line  59)
* minibuffer-eldef-shorten-default:      Basic Minibuffer.    (line  23)
* minibuffer-local-completion-map:       Minibuffer Maps.     (line   6)
* minibuffer-local-filename-completion-map: Minibuffer Maps.  (line   6)
* minibuffer-local-filename-must-match-map: Minibuffer Maps.  (line   6)
* minibuffer-local-map:                  Minibuffer Maps.     (line   6)
* minibuffer-local-must-match-map:       Minibuffer Maps.     (line   6)
* minibuffer-local-ns-map:               Minibuffer Maps.     (line   6)
* minibuffer-prompt-properties:          Standard Faces.      (line 117)
* mode-line-in-non-selected-windows:     Optional Mode Line.  (line  91)
* mode-require-final-newline:            Customize Save.      (line  15)
* mode-specific-map:                     Prefix Keymaps.      (line  37)
* mouse-1-click-in-non-selected-windows: Mouse References.    (line  38)
* mouse-autoselect-window:               Other Window.        (line  34)
* mouse-avoidance-mode:                  Mouse Avoidance.     (line  16)
* mouse-drag-and-drop-region:            Drag and Drop.       (line  21)
* mouse-drag-and-drop-region-cut-when-buffers-differ: Drag and Drop.
                                                              (line  30)
* mouse-drag-and-drop-region-show-cursor: Drag and Drop.      (line  30)
* mouse-drag-and-drop-region-show-tooltip: Drag and Drop.     (line  30)
* mouse-drag-copy-region:                Mouse Commands.      (line  46)
* mouse-highlight:                       Mouse References.    (line   6)
* mouse-scroll-min-lines:                Mouse Commands.      (line  50)
* mouse-wheel-flip-direction:            Mouse Commands.      (line 118)
* mouse-wheel-follow-mouse:              Mouse Commands.      (line 109)
* mouse-wheel-progressive-speed:         Mouse Commands.      (line 109)
* mouse-wheel-scroll-amount:             Mouse Commands.      (line 109)
* mouse-wheel-tilt-scroll:               Mouse Commands.      (line 118)
* mouse-yank-at-point:                   Mouse Commands.      (line  64)
* NAME:                                  Misc Variables.      (line  13)
* NAME, environment variable:            General Variables.   (line 102)
* network-security-level:                Network Security.    (line  11)
* next-error-highlight:                  Compilation Mode.    (line  51)
* next-line-add-newlines:                Moving Point.        (line 157)
* next-screen-context-lines:             Scrolling.           (line  47)
* NNTPSERVER, environment variable:      General Variables.   (line 105)
* nobreak-char-display:                  Text Display.        (line  31)
* normal-erase-is-backspace:             DEL Does Not Delete. (line  44)
* nroff-mode-hook:                       Nroff Mode.          (line   6)
* ns-alternate-modifier:                 Mac / GNUstep Basics.
                                                              (line  12)
* ns-pop-up-frames:                      Mac / GNUstep Events.
                                                              (line  13)
* ns-right-alternate-modifier:           Mac / GNUstep Basics.
                                                              (line  12)
* ns-standard-fontset-spec:              Defining Fontsets.   (line   6)
* nsm-save-host-names:                   Network Security.    (line  91)
* nsm-settings-file:                     Network Security.    (line  87)
* open-paren-in-column-0-is-defun-start: Left Margin Paren.   (line  36)
* org-agenda-files:                      Org Organizer.       (line  20)
* org-publish-project-alist:             Org Authoring.       (line  14)
* org-todo-keywords:                     Org Organizer.       (line   6)
* ORGANIZATION, environment variable:    General Variables.   (line 107)
* outline-level:                         Outline Format.      (line  55)
* outline-minor-mode-prefix:             Outline Mode.        (line   6)
* outline-mode-hook:                     Outline Mode.        (line   6)
* outline-regexp:                        Outline Format.      (line  37)
* overflow-newline-into-fringe:          Fringes.             (line  31)
* overline-margin:                       Display Custom.      (line 108)
* package-archive-priorities:            Package Installation.
                                                              (line  66)
* package-archives:                      Package Installation.
                                                              (line  21)
* package-check-signature:               Package Installation.
                                                              (line  51)
* package-directory-list:                Package Files.       (line  20)
* package-enable-at-startup:             Package Installation.
                                                              (line  90)
* package-load-list:                     Package Installation.
                                                              (line 107)
* package-menu-async:                    Package Menu.        (line  77)
* package-menu-hide-low-priority:        Package Installation.
                                                              (line  66)
* package-pinned-packages:               Package Installation.
                                                              (line  61)
* package-unsigned-archives:             Package Installation.
                                                              (line  51)
* package-user-dir:                      Package Files.       (line  15)
* page-delimiter:                        Pages.               (line  58)
* paragraph-separate:                    Paragraphs.          (line  51)
* paragraph-start:                       Paragraphs.          (line  51)
* PATH, environment variable:            General Variables.   (line 110)
* pdb-mode-hook:                         GUD Customization.   (line   6)
* perldb-mode-hook:                      GUD Customization.   (line   6)
* picture-mode-hook:                     Picture Mode.        (line  38)
* picture-tab-chars:                     Tabs in Picture.     (line   6)
* plain-tex-mode-hook:                   TeX Misc.            (line   6)
* pop-up-frames:                         Window Choice.       (line  23)
* PRELOAD_WINSOCK:                       Misc Variables.      (line  37)
* print-region-function (MS-DOS):        Windows Printing.    (line  75)
* printer-name:                          Printing.            (line  38)
* printer-name, (MS-DOS/MS-Windows):     Windows Printing.    (line  19)
* prog-mode-hook:                        Major Modes.         (line  72)
* ps-font-family:                        PostScript Variables.
                                                              (line  45)
* ps-font-info-database:                 PostScript Variables.
                                                              (line  45)
* ps-font-size:                          PostScript Variables.
                                                              (line  45)
* ps-landscape-mode:                     PostScript Variables.
                                                              (line  38)
* ps-lpr-command:                        PostScript Variables.
                                                              (line   6)
* ps-lpr-command (MS-DOS):               Windows Printing.    (line  83)
* ps-lpr-switches:                       PostScript Variables.
                                                              (line   6)
* ps-lpr-switches (MS-DOS):              Windows Printing.    (line  83)
* ps-multibyte-buffer:                   PostScript Variables.
                                                              (line  53)
* ps-number-of-columns:                  PostScript Variables.
                                                              (line  42)
* ps-page-dimensions-database:           PostScript Variables.
                                                              (line  32)
* ps-paper-type:                         PostScript Variables.
                                                              (line  32)
* ps-print-color-p:                      PostScript Variables.
                                                              (line  17)
* ps-print-header:                       PostScript Variables.
                                                              (line  14)
* ps-printer-name:                       PostScript Variables.
                                                              (line   6)
* ps-printer-name (MS-DOS):              Windows Printing.    (line  83)
* ps-use-face-background:                PostScript Variables.
                                                              (line  27)
* PWD, environment variable:             General Variables.   (line 114)
* quail-activate-hook:                   Input Methods.       (line  95)
* query-replace-from-to-separator:       Query Replace.       (line  25)
* query-replace-highlight:               Query Replace.       (line  34)
* query-replace-lazy-highlight:          Query Replace.       (line  34)
* query-replace-show-replacement:        Query Replace.       (line  34)
* query-replace-skip-read-only:          Query Replace.       (line  45)
* read-buffer-completion-ignore-case:    Completion Options.  (line  11)
* read-file-name-completion-ignore-case: Completion Options.  (line  11)
* read-mail-command:                     Mail Methods.        (line  26)
* read-quoted-char-radix:                Inserting Text.      (line  54)
* recenter-positions:                    Recentering.         (line  29)
* recenter-redisplay:                    Recentering.         (line  47)
* recentf-mode:                          File Conveniences.   (line   9)
* regexp-search-ring-max:                Regexp Search.       (line  29)
* register-preview-delay:                Registers.           (line  26)
* register-separator:                    Text Registers.      (line  40)
* replace-lax-whitespace:                Replacement and Lax Matches.
                                                              (line  10)
* replace-regexp-lax-whitespace:         Replacement and Lax Matches.
                                                              (line  17)
* REPLYTO, environment variable:         General Variables.   (line 117)
* require-final-newline:                 Customize Save.      (line   6)
* resize-mini-windows:                   Minibuffer Edit.     (line  34)
* revert-without-query:                  Reverting.           (line  27)
* rmail-automatic-folder-directives:     Rmail Output.        (line  74)
* rmail-delete-after-output:             Rmail Output.        (line  52)
* rmail-delete-message-hook:             Rmail Deletion.      (line  38)
* rmail-displayed-headers:               Rmail Display.       (line  20)
* rmail-edit-mode-hook:                  Rmail Editing.       (line  25)
* rmail-enable-mime:                     Rmail Display.       (line  36)
* rmail-enable-mime-composing:           Rmail Reply.         (line  79)
* rmail-file-coding-system:              Rmail Coding.        (line  32)
* rmail-file-name:                       Rmail Basics.        (line   6)
* rmail-highlighted-headers:             Rmail Display.       (line  29)
* rmail-ignored-headers:                 Rmail Display.       (line  20)
* rmail-inbox-list:                      Rmail Files.         (line  46)
* rmail-mail-new-frame:                  Rmail Reply.         (line 110)
* rmail-mbox-format:                     Rmail Inbox.         (line  41)
* rmail-mime-prefer-html:                Rmail Display.       (line  71)
* rmail-mode-hook:                       Rmail.               (line   6)
* rmail-movemail-flags:                  Remote Mailboxes.    (line  44)
* rmail-movemail-program:                Movemail.            (line  97)
* rmail-movemail-search-path:            Movemail.            (line  97)
* rmail-nonignored-headers:              Rmail Display.       (line  20)
* rmail-output-file-alist:               Rmail Output.        (line  61)
* rmail-preserve-inbox:                  Rmail Inbox.         (line  48)
* rmail-primary-inbox-list:              Rmail Inbox.         (line  15)
* rmail-redisplay-summary:               Rmail Summary Edit.  (line  88)
* rmail-remote-password:                 Remote Mailboxes.    (line  35)
* rmail-remote-password-required:        Remote Mailboxes.    (line  35)
* rmail-retry-ignored-headers:           Rmail Reply.         (line  58)
* rmail-secondary-file-directory:        Rmail Files.         (line  36)
* rmail-secondary-file-regexp:           Rmail Files.         (line  36)
* rmail-summary-line-count-flag:         Rmail Make Summary.  (line  62)
* rmail-summary-scroll-between-messages: Rmail Summary Edit.  (line  16)
* rmail-summary-window-size:             Rmail Make Summary.  (line  62)
* safe-local-eval-forms:                 Safe File Variables. (line  45)
* safe-local-variable-values:            Safe File Variables. (line  27)
* same-window-buffer-names:              Window Choice.       (line  11)
* same-window-regexps:                   Window Choice.       (line  11)
* save-abbrevs:                          Saving Abbrevs.      (line  39)
* save-interprogram-paste-before-kill:   Clipboard.           (line  14)
* save-some-buffers-default-predicate:   Save Commands.       (line  65)
* SAVEDIR, environment variable:         General Variables.   (line 120)
* scheme-mode-hook:                      Program Modes.       (line  38)
* scroll-all-mode:                       Window Convenience.  (line  28)
* scroll-bar-adjust-thumb-portion:       Scroll Bars.         (line  43)
* scroll-bar-height:                     Scroll Bars.         (line  90)
* scroll-bar-mode:                       Scroll Bars.         (line  28)
* scroll-bar-width:                      Scroll Bars.         (line  38)
* scroll-conservatively:                 Auto Scrolling.      (line  11)
* scroll-down:                           Scrolling.           (line  86)
* scroll-down-aggressively:              Auto Scrolling.      (line  28)
* scroll-error-top-bottom:               Scrolling.           (line  53)
* scroll-margin:                         Auto Scrolling.      (line  51)
* scroll-preserve-screen-position:       Scrolling.           (line  60)
* scroll-step:                           Auto Scrolling.      (line  22)
* scroll-up:                             Scrolling.           (line  86)
* scroll-up-aggressively:                Auto Scrolling.      (line  28)
* sdb-mode-hook:                         GUD Customization.   (line   6)
* search-exit-option:                    Not Exiting Isearch. (line  12)
* search-highlight:                      Search Customizations.
                                                              (line  19)
* search-invisible:                      Outline Visibility.  (line  82)
* search-nonincremental-instead:         Search Customizations.
                                                              (line  41)
* search-ring-max:                       Repeat Isearch.      (line  41)
* search-slow-speed:                     Search Customizations.
                                                              (line  54)
* search-slow-window-lines:              Search Customizations.
                                                              (line  54)
* search-upper-case:                     Lax Search.          (line  43)
* search-whitespace-regexp:              Lax Search.          (line  15)
* select-active-regions:                 Primary Selection.   (line  22)
* select-enable-clipboard:               Clipboard.           (line  30)
* select-enable-primary:                 Clipboard.           (line  46)
* selective-display-ellipses:            Selective Display.   (line  27)
* send-mail-function:                    Mail Sending.        (line  29)
* sendmail-coding-system:                Output Coding.       (line  39)
* sentence-end:                          Sentences.           (line  54)
* sentence-end-double-space:             Sentences.           (line  46)
* sentence-end-without-period:           Sentences.           (line  60)
* server-auth-dir:                       TCP Emacs server.    (line  33)
* server-auth-key:                       TCP Emacs server.    (line  21)
* server-host:                           TCP Emacs server.    (line  16)
* server-kill-new-buffers:               Invoking emacsclient.
                                                              (line  48)
* server-name:                           Emacs Server.        (line  71)
* server-port:                           TCP Emacs server.    (line  16)
* server-temp-file-regexp:               Invoking emacsclient.
                                                              (line  48)
* server-use-tcp:                        TCP Emacs server.    (line   6)
* server-window:                         Invoking emacsclient.
                                                              (line  61)
* set-language-environment-hook:         Language Environments.
                                                              (line  83)
* set-mark-command-repeat-pop:           Mark Ring.           (line  34)
* sgml-xml-mode:                         HTML Mode.           (line  81)
* SHELL, environment variable:           General Variables.   (line 123)
* shell-cd-regexp:                       Directory Tracking.  (line   6)
* shell-command-default-error-buffer:    Single Shell.        (line  74)
* shell-command-dont-erase-buffer:       Single Shell.        (line  78)
* shell-command-regexp:                  Shell Mode.          (line  95)
* shell-completion-execonly:             Shell Options.       (line  41)
* shell-completion-fignore:              Shell Options.       (line  45)
* shell-file-name:                       Single Shell.        (line  65)
* shell-input-ring-file-name:            Shell Ring.          (line  77)
* shell-popd-regexp:                     Directory Tracking.  (line   6)
* shell-prompt-pattern:                  Shell Prompts.       (line  22)
* shell-pushd-regexp:                    Directory Tracking.  (line   6)
* show-paren-highlight-openparen:        Matching.            (line  41)
* show-paren-style:                      Matching.            (line  46)
* show-paren-when-point-in-periphery:    Matching.            (line  56)
* show-paren-when-point-inside-paren:    Matching.            (line  53)
* show-trailing-whitespace:              Useless Whitespace.  (line   6)
* slitex-mode-hook:                      TeX Misc.            (line   6)
* small-temporary-file-directory:        Backup.              (line  32)
* SMTPSERVER, environment variable:      General Variables.   (line 126)
* sort-fold-case:                        Sorting.             (line 110)
* sort-numeric-base:                     Sorting.             (line  23)
* split-height-threshold:                Window Choice.       (line  33)
* split-width-threshold:                 Window Choice.       (line  33)
* split-window-keep-point:               Split Window.        (line  22)
* standard-fontset-spec:                 Defining Fontsets.   (line   6)
* standard-indent:                       Enriched Indentation.
                                                              (line  28)
* suggest-key-bindings:                  M-x.                 (line  52)
* tab-always-indent:                     Indent Convenience.  (line   6)
* tab-stop-list:                         Tab Stops.           (line   6)
* tab-width:                             Text Display.        (line  10)
* table-cell-horizontal-chars:           Table Definition.    (line  17)
* table-cell-intersection-char:          Table Definition.    (line  20)
* table-cell-vertical-char:              Table Definition.    (line  14)
* table-detect-cell-alignment:           Cell Justification.  (line  23)
* tags-case-fold-search:                 Identifier Search.   (line  60)
* tags-file-name:                        Select Tags Table.   (line  12)
* tags-table-list:                       Select Tags Table.   (line  26)
* TEMP, environment variable:            General Variables.   (line 141)
* temp-buffer-max-height:                Temporary Displays.  (line  35)
* temp-buffer-max-width:                 Temporary Displays.  (line  35)
* temporary-file-directory:              Backup.              (line  32)
* TERM, environment variable:            General Variables.   (line 130)
* TERM, environment variable, and display bugs: Checklist.    (line 112)
* TERM, environment variable, in compilation mode: Compilation Shell.
                                                              (line  30)
* TERM, environment variable, in sub-shell: Shell Options.    (line  61)
* term-file-aliases:                     Terminal Init.       (line   6)
* term-file-prefix:                      Terminal Init.       (line  30)
* TERMCAP, environment variable:         General Variables.   (line 135)
* tex-bibtex-command:                    TeX Print.           (line 136)
* tex-default-mode:                      TeX Mode.            (line  13)
* tex-directory:                         TeX Print.           (line  45)
* tex-dvi-print-command:                 TeX Print.           (line  53)
* tex-dvi-view-command:                  TeX Print.           (line  53)
* tex-main-file:                         TeX Print.           (line 125)
* tex-mode-hook:                         TeX Misc.            (line   6)
* tex-print-file-extension:              TeX Print.           (line  53)
* tex-run-command:                       TeX Print.           (line  53)
* tex-shell-hook:                        TeX Misc.            (line   6)
* tex-start-commands:                    TeX Print.           (line 121)
* tex-start-options:                     TeX Print.           (line 118)
* text-mode-hook:                        Text Mode.           (line  42)
* timeclock-ask-before-exiting:          Time Intervals.      (line  25)
* timeclock-file:                        Time Intervals.      (line  32)
* timeclock-modeline-display:            Time Intervals.      (line  21)
* TMP, environment variable:             General Variables.   (line 140)
* TMPDIR, environment variable:          General Variables.   (line 139)
* tool-bar-mode:                         Tool Bars.           (line  16)
* tool-bar-style:                        Tool Bars.           (line  21)
* tooltip-delay:                         Tooltips.            (line  19)
* tooltip-frame-parameters:              Tooltips.            (line  40)
* tooltip-hide-delay:                    Tooltips.            (line  28)
* tooltip-short-delay:                   Tooltips.            (line  23)
* tooltip-x-offset:                      Tooltips.            (line  31)
* tooltip-y-offset:                      Tooltips.            (line  32)
* track-eol:                             Moving Point.        (line 153)
* truncate-lines:                        Line Truncation.     (line  12)
* truncate-partial-width-windows:        Split Window.        (line  34)
* tty-menu-open-use-tmm:                 Menu Bar.            (line  31)
* tty-setup-hook:                        Terminal Init.       (line  34)
* TZ, environment variable:              General Variables.   (line 148)
* underline-minimum-offset:              Display Custom.      (line  95)
* undo-limit:                            Undo.                (line  66)
* undo-outer-limit:                      Undo.                (line  66)
* undo-strong-limit:                     Undo.                (line  66)
* unibyte-display-via-language-environment: Unibyte Mode.     (line  17)
* uniquify-buffer-name-style:            Uniquify.            (line  14)
* use-dialog-box:                        Dialog Boxes.        (line   6)
* use-file-dialog:                       Dialog Boxes.        (line  18)
* USER, environment variable:            General Variables.   (line 154)
* user-full-name:                        Mail Headers.        (line  14)
* user-mail-address:                     Mail Headers.        (line  14)
* user-mail-address, in init file:       Init Examples.       (line  34)
* user-mail-address, initialization:     General Variables.   (line  40)
* vc-annotate-background-mode:           Old Revisions.       (line  80)
* vc-BACKEND-header:                     Version Headers.     (line  20)
* vc-command-messages:                   General VC Options.  (line  24)
* vc-consult-headers:                    Version Headers.     (line  12)
* vc-cvs-global-switches:                CVS Options.         (line   6)
* vc-cvs-stay-local:                     CVS Options.         (line  10)
* vc-diff-switches:                      Old Revisions.       (line  64)
* vc-directory-exclusion-list:           VC Directory Buffer. (line  48)
* vc-follow-symlinks:                    General VC Options.  (line  11)
* vc-handled-backends:                   Customizing VC.      (line   6)
* vc-log-mode-hook:                      Log Buffer.          (line  12)
* vc-log-show-limit:                     VC Change Log.       (line  99)
* vc-make-backup-files:                  General VC Options.  (line   6)
* vc-revert-show-diff:                   VC Undo.             (line  10)
* vc-static-header-alist:                Version Headers.     (line  30)
* vc-suppress-confirm:                   General VC Options.  (line  20)
* version-control:                       Backup Names.        (line  20)
* VERSION_CONTROL, environment variable: General Variables.   (line 157)
* view-read-only:                        Misc Buffer.         (line  26)
* visible-bell:                          Display Custom.      (line  72)
* visible-cursor:                        Cursor Display.      (line   6)
* visual-order-cursor-movement:          Bidirectional Editing.
                                                              (line  83)
* w32-alt-is-meta:                       Windows Keyboard.    (line  18)
* w32-apps-modifier:                     Windows Keyboard.    (line  85)
* w32-capslock-is-shiftlock:             Windows Keyboard.    (line  71)
* w32-charset-info-alist:                Windows Fonts.       (line  63)
* w32-enable-caps-lock:                  Windows Keyboard.    (line  77)
* w32-enable-num-lock:                   Windows Keyboard.    (line  81)
* w32-get-true-file-attributes:          Windows Files.       (line  17)
* w32-grab-focus-on-raise:               Windows Misc.        (line  18)
* w32-lwindow-modifier:                  Windows Keyboard.    (line  91)
* w32-mouse-button-tolerance:            Windows Mouse.       (line   9)
* w32-pass-alt-to-system:                Windows Keyboard.    (line 104)
* w32-pass-extra-mouse-buttons-to-system: Windows Mouse.      (line  15)
* w32-pass-lwindow-to-system:            Windows Keyboard.    (line 115)
* w32-pass-rwindow-to-system:            Windows Keyboard.    (line 115)
* w32-pipe-buffer-size:                  Windows Processes.   (line  56)
* w32-quote-process-args:                Windows Processes.   (line  50)
* w32-recognize-altgr:                   Windows Keyboard.    (line 122)
* w32-rwindow-modifier:                  Windows Keyboard.    (line  91)
* w32-scroll-lock-modifier:              Windows Keyboard.    (line  91)
* w32-standard-fontset-spec:             Defining Fontsets.   (line   6)
* w32-swap-mouse-buttons:                Windows Mouse.       (line  18)
* w32-unicode-filenames:                 File Name Coding.    (line  27)
* w32-use-visible-system-caret:          Windows Misc.        (line   9)
* which-func-modes:                      Which Function.      (line  10)
* whitespace-big-indent-regexp:          Useless Whitespace.  (line  73)
* whitespace-line-column:                Useless Whitespace.  (line  63)
* whitespace-style:                      Useless Whitespace.  (line  37)
* window-divider-default-bottom-width:   Window Dividers.     (line  19)
* window-divider-default-places:         Window Dividers.     (line  13)
* window-divider-default-right-width:    Window Dividers.     (line  19)
* window-min-height:                     Change Window.       (line  45)
* window-min-width:                      Change Window.       (line  54)
* window-resize-pixelwise:               Split Window.        (line  59)
* write-region-inhibit-fsync:            Customize Save.      (line  21)
* x-gtk-file-dialog-help-text:           Dialog Boxes.        (line  24)
* x-gtk-show-hidden-files:               Dialog Boxes.        (line  24)
* x-gtk-use-system-tooltips:             Tooltips.            (line  48)
* x-mouse-click-focus-ignore-position:   Mouse Commands.      (line  32)
* x-select-enable-clipboard-manager:     Clipboard.           (line  33)
* x-select-request-type:                 Communication Coding.
                                                              (line  32)
* x-stretch-cursor:                      Cursor Display.      (line  40)
* x-underline-at-descent-line:           Display Custom.      (line  95)
* xdb-mode-hook:                         GUD Customization.   (line   6)
* xref-marker-ring-length:               Looking Up Identifiers.
                                                              (line  57)
* xref-prompt-for-identifier:            Looking Up Identifiers.
                                                              (line  25)
* yank-pop-change-selection:             Clipboard.           (line  26)


File: emacs-ja.info,  Node: Concept Index,  Prev: Variable Index,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* $ in file names:                       File Names.         (line   55)
* ( in leftmost column:                  Left Margin Paren.  (line    6)
* *Messages* buffer:                     Echo Area.          (line   32)
* –/—/.-./.../.:                         Amusements.         (line   43)
* .dir-locals.el file:                   Directory Variables.
                                                             (line   11)
* .emacs file:                           Init File.          (line    6)
* .mailrc file:                          Mail Aliases.       (line    6)
* .newsrc file:                          Gnus Startup.       (line    6)
* // in file name:                       Minibuffer File.    (line   34)
* 7z:                                    File Archives.      (line   45)
* 8-bit display:                         Unibyte Mode.       (line   33)
* 8-bit input:                           Unibyte Mode.       (line   40)
* ? in display:                          International Chars.
                                                             (line   19)
* _emacs init file, MS-Windows:          Windows HOME.       (line   44)
* ~, in names of backup files:           Backup Names.       (line    6)
* ~/.emacs file:                         Init File.          (line    6)
* ~/.emacs.d/%backup%~:                  Backup Names.       (line   10)
* ~/.emacs.d/gtkrc file:                 GTK resources.      (line    6)
* ~/.gtkrc-2.0 file:                     GTK resources.      (line    6)
* ~/.Xdefaults file:                     Resources.          (line    6)
* ~/.Xresources file:                    Resources.          (line    6)
* A and B buffers (Emerge):              Overview of Emerge. (line   22)
* abbrev file:                           Saving Abbrevs.     (line   27)
* Abbrev mode:                           Abbrev Concepts.    (line   12)
* abbrevs:                               Abbrevs.            (line    6)
* abnormal hook:                         Hooks.              (line   19)
* aborting recursive edit:               Quitting.           (line   64)
* accented characters:                   Unibyte Mode.       (line    6)
* accessible portion:                    Narrowing.          (line    6)
* accumulating scattered text:           Accumulating Text.  (line    6)
* action options (command line):         Emacs Invocation.   (line   38)
* active region:                         Mark.               (line   14)
* active text:                           Help Echo.          (line    6)
* adaptive filling:                      Adaptive Fill.      (line    6)
* adding to the kill ring in Dired:      Misc Dired Features.
                                                             (line   18)
* addpm, MS-Windows installation program: MS-Windows Registry.
                                                             (line    6)
* adjust buffer face height:             Text Scale.         (line    6)
* aggressive scrolling:                  Auto Scrolling.     (line   28)
* alarm clock:                           Appointments.       (line   57)
* alignment for comments:                Comment Commands.   (line    6)
* Alt key (MS-Windows):                  Windows Keyboard.   (line   18)
* Alt key invokes menu (Windows):        Windows Keyboard.   (line  104)
* <Alt>-<TAB> vs M-<TAB> (MS-Windows):   Windows Keyboard.   (line   44)
* ALTERNATE_EDITOR environment variable: emacsclient Options.
                                                             (line   29)
* <AltGr> key (MS-Windows):              Windows Keyboard.   (line  122)
* ange-ftp:                              Remote Files.       (line   30)
* animate:                               Amusements.         (line    6)
* animated images:                       File Conveniences.  (line   33)
* anonymous FTP:                         Remote Files.       (line   50)
* appending kills in the ring:           Appending Kills.    (line    6)
* appointment notification:              Appointments.       (line    6)
* apropos:                               Apropos.            (line    6)
* apropos search results, order by score: Apropos.           (line   84)
* Arabic:                                Language Environments.
                                                             (line   29)
* arc:                                   File Archives.      (line   45)
* Archive mode:                          File Archives.      (line   45)
* arguments (command line):              Emacs Invocation.   (line    6)
* arguments to commands:                 Arguments.          (line    6)
* arrow keys:                            Moving Point.       (line    6)
* ASCII:                                 User Input.         (line    6)
* ASCII (language environment):          Language Environments.
                                                             (line   29)
* ASCII art:                             Text.               (line   32)
* Asm mode:                              Asm Mode.           (line    6)
* assembler mode:                        Asm Mode.           (line    6)
* astronomical day numbers:              Calendar Systems.   (line   12)
* attached frame (of speedbar):          Speedbar.           (line    6)
* attribute (Rmail):                     Rmail Labels.       (line    6)
* attributes of mode line, changing:     Optional Mode Line. (line   78)
* Auto Compression mode:                 Compressed Files.   (line    6)
* Auto Fill mode:                        Auto Fill.          (line    6)
* Auto Revert mode:                      Reverting.          (line   35)
* Auto Save mode:                        Auto Save.          (line    6)
* auto-save for remote files:            Auto Save Files.    (line   24)
* autoload:                              Lisp Libraries.     (line   63)
* autoload Lisp libraries:               Init Examples.      (line   83)
* automatic scrolling:                   Auto Scrolling.     (line    6)
* automatic typing:                      Text.               (line   36)
* automatic version backups:             CVS Options.        (line   27)
* autotyping:                            Text.               (line   36)
* avoiding mouse in the way of your typing: Mouse Avoidance. (line    6)
* Awk mode:                              Program Modes.      (line   14)
* AWK mode:                              C Modes.            (line    6)
* back end (version control):            Version Control Systems.
                                                             (line    6)
* back reference, in regexp:             Regexp Backslash.   (line   54)
* back reference, in regexp replacement: Regexp Replace.     (line   13)
* background color:                      Faces.              (line   31)
* background color, command-line argument: Colors X.         (line   18)
* background for menus:                  Table of Resources. (line   87)
* background mode, on xterm:             General Variables.  (line  128)
* background syntax highlighting:        Font Lock.          (line   80)
* <BACKSPACE> vs <DEL>:                  DEL Does Not Delete.
                                                             (line    6)
* backtrace:                             Crashing.           (line    6)
* backtrace for bug reports:             Checklist.          (line  241)
* backup file:                           Backup.             (line    6)
* backup file names:                     Backup Names.       (line    6)
* backup file names on MS-DOS:           MS-DOS File Names.  (line   19)
* backup, and user-id:                   Backup Copying.     (line   20)
* backups for remote files:              Remote Files.       (line   41)
* Bahá’í calendar:                       Calendar Systems.   (line   62)
* balanced expression:                   Expressions.        (line    6)
* balloon help:                          Help Echo.          (line    6)
* base buffer:                           Indirect Buffers.   (line    6)
* base direction of paragraphs:          Bidirectional Editing.
                                                             (line   33)
* basic, completion style:               Completion Styles.  (line   25)
* batch mode:                            Initial Options.    (line   42)
* battery status (on mode line):         Optional Mode Line. (line   70)
* Bazaar:                                Version Control Systems.
                                                             (line   47)
* Belarusian:                            Language Environments.
                                                             (line   29)
* Bengali:                               Language Environments.
                                                             (line   29)
* bidirectional editing:                 Bidirectional Editing.
                                                             (line    6)
* binding:                               Commands.           (line    6)
* binding keyboard macros:               Save Keyboard Macro.
                                                             (line   24)
* binding keys:                          Rebinding.          (line    6)
* blank lines:                           Blank Lines.        (line   13)
* blank lines in programs:               Multi-Line Comments.
                                                             (line    6)
* blinking cursor:                       Cursor Display.     (line   23)
* blinking cursor disable, command-line argument: Misc X.    (line   21)
* body lines (Outline mode):             Outline Format.     (line    6)
* bookmarks:                             Bookmarks.          (line    6)
* border color, command-line argument:   Colors X.           (line   22)
* borders (X Window System):             Borders X.          (line    6)
* boredom:                               Amusements.         (line    6)
* bound branch (Bazaar VCS):             Pulling / Pushing.  (line   31)
* brace in column zero and fontification: Font Lock.         (line   55)
* braces, moving across:                 Moving by Parens.   (line    6)
* branch (version control):              Branches.           (line    6)
* Brazilian Portuguese:                  Language Environments.
                                                             (line   29)
* Browse-URL:                            Browse-URL.         (line    6)
* bubbles:                               Amusements.         (line   15)
* buffer contents:                       Buffers.            (line   33)
* buffer definitions index:              Imenu.              (line    6)
* buffer list, customizable:             Buffer Menus.       (line    6)
* Buffer Menu:                           Several Buffers.    (line    6)
* buffer size display:                   Optional Mode Line. (line    6)
* buffer size, maximum:                  Buffers.            (line   45)
* buffer text garbled:                   Text Garbled.       (line    6)
* buffer-local hooks:                    Hooks.              (line   90)
* buffers:                               Buffers.            (line    6)
* bug criteria:                          Bug Criteria.       (line    6)
* bug reporting:                         Understanding Bug Reporting.
                                                             (line    6)
* bug reporting, checklist:              Checklist.          (line    6)
* bug tracker:                           Known Problems.     (line   16)
* bugs:                                  Bugs.               (line    6)
* build details:                         Initial Options.    (line   80)
* building programs:                     Building.           (line    6)
* built-in package:                      Package Menu.       (line    6)
* Bulgarian:                             Language Environments.
                                                             (line   29)
* Burmese:                               Language Environments.
                                                             (line   30)
* butterfly:                             Amusements.         (line   56)
* button-down events:                    Mouse Buttons.      (line    6)
* buttons:                               Mouse References.   (line    6)
* buttons (customization buffer):        Customization Groups.
                                                             (line   39)
* buttons at buffer position:            Editing Format Info.
                                                             (line   20)
* bypassing init and default.el file:    Initial Options.    (line   85)
* byte code:                             Lisp Libraries.     (line    9)
* byte-compiling several files (in Dired): Operating on Files.
                                                             (line  139)
* bzr:                                   Version Control Systems.
                                                             (line   47)
* C editing:                             Programs.           (line    6)
* C mode:                                C Modes.            (line    6)
* C++ class browser, tags:               Tags Tables.        (line   27)
* C++ mode:                              C Modes.            (line    6)
* C-:                                    User Input.         (line   18)
* cache of file names:                   File Name Cache.    (line    6)
* calendar:                              Calendar/Diary.     (line    6)
* calendar and HTML:                     Writing Calendar Files.
                                                             (line    9)
* calendar and LaTeX:                    Writing Calendar Files.
                                                             (line   35)
* calendar layout:                       Calendar Customizing.
                                                             (line    6)
* calendar week numbers:                 Calendar Customizing.
                                                             (line    6)
* calendar, first day of week:           Move to Beginning or End.
                                                             (line   26)
* call Lisp functions, command-line argument: Action Arguments.
                                                             (line   59)
* camel case:                            MixedCase Words.    (line    6)
* candle lighting times:                 Sexp Diary Entries. (line  159)
* capitalizing words:                    Case.               (line   20)
* case conversion:                       Case.               (line    6)
* case folding in replace commands:      Replacement and Lax Matches.
                                                             (line   21)
* case folding in search:                Lax Search.         (line   36)
* case in completion:                    Completion Options. (line    6)
* case-sensitivity and completion:       Completion Options. (line    6)
* case-sensitivity and search:           Lax Search.         (line   36)
* case-sensitivity and tags search:      Identifier Search.  (line   60)
* categories of characters:              Regexp Backslash.   (line  133)
* cells, for text-based tables:          Table Definition.   (line    6)
* centering:                             Fill Commands.      (line   46)
* centralized version control:           VCS Repositories.   (line    6)
* Cham:                                  Language Environments.
                                                             (line   30)
* change buffers:                        Select Buffer.      (line    6)
* change Emacs directory:                Initial Options.    (line   20)
* change log:                            Change Log.         (line    6)
* Change Log mode:                       Change Log Commands.
                                                             (line   40)
* changes, undoing:                      Undo.               (line    6)
* changeset-based version control:       VCS Changesets.     (line   14)
* changing file group (in Dired):        Operating on Files. (line   81)
* changing file owner (in Dired):        Operating on Files. (line   85)
* changing file permissions (in Dired):  Operating on Files. (line   76)
* changing file time (in Dired):         Operating on Files. (line   94)
* char mode (terminal emulator):         Terminal emulator.  (line   11)
* character equivalence in search:       Lax Search.         (line    6)
* character folding in replace commands: Replacement and Lax Matches.
                                                             (line   43)
* character folding in search:           Lax Search.         (line   71)
* character set (keyboard):              User Input.         (line    6)
* character set of character at point:   International Chars.
                                                             (line   59)
* character syntax:                      Init Syntax.        (line   49)
* characters (in text):                  Text Display.       (line    6)
* characters in a certain charset:       Charsets.           (line   24)
* characters which belong to a specific language: Regexp Backslash.
                                                             (line  133)
* characters with no font glyphs:        Text Display.       (line   47)
* characters, inserting by name or code-point: Inserting Text.
                                                             (line   58)
* charsets:                              Charsets.           (line    6)
* checking out files:                    VCS Concepts.       (line   14)
* checking spelling:                     Spelling.           (line    6)
* checking syntax:                       Flymake.            (line    6)
* checklist before reporting a bug:      Checklist.          (line    6)
* Chinese:                               Language Environments.
                                                             (line   30)
* Chinese calendar:                      Calendar Systems.   (line   56)
* choosing a major mode:                 Choosing Modes.     (line    6)
* choosing a minor mode:                 Choosing Modes.     (line    6)
* ciphers:                               Amusements.         (line   18)
* citing mail:                           Citing Mail.        (line    6)
* class browser, C++:                    Tags Tables.        (line   27)
* click events:                          Mouse Buttons.      (line    6)
* client frame:                          emacsclient Options.
                                                             (line   32)
* client-side fonts:                     Fonts.              (line  191)
* clipboard:                             Clipboard.          (line    6)
* clipboard manager:                     Clipboard.          (line   33)
* clocking time:                         Time Intervals.     (line    6)
* close buffer:                          Kill Buffer.        (line    6)
* close file:                            Kill Buffer.        (line    6)
* codepage, MS-DOS:                      MS-DOS and MULE.    (line   20)
* coding standards:                      Coding Standards.   (line    6)
* coding systems:                        Coding Systems.     (line    6)
* collision:                             Interlocking.       (line   28)
* color emulation on black-and-white printers: PostScript Variables.
                                                             (line   17)
* color name:                            Colors.             (line    6)
* color of window, from command line:    Colors X.           (line    6)
* color scheme:                          Custom Themes.      (line   16)
* Column Number mode:                    Optional Mode Line. (line   22)
* columns (and rectangles):              Rectangles.         (line    6)
* columns (indentation):                 Indentation.        (line    6)
* columns, splitting:                    Two-Column.         (line    6)
* Comint mode:                           Shell Mode.         (line  142)
* comint-highlight-input face:           Interactive Shell.  (line   25)
* comint-highlight-prompt face:          Interactive Shell.  (line   25)
* command:                               Commands.           (line    6)
* command history:                       Repetition.         (line    6)
* command line arguments:                Emacs Invocation.   (line    6)
* commands in *xref* buffers:            Xref Commands.      (line    6)
* comments:                              Comments.           (line    6)
* comments on customized settings:       Changing a Variable.
                                                             (line  121)
* Common Lisp:                           External Lisp.      (line    6)
* compare files (in Dired):              Comparison in Dired.
                                                             (line    6)
* comparing 3 files (diff3):             Comparing Files.    (line   48)
* comparing files:                       Comparing Files.    (line    6)
* compilation buffer, keeping point at end: Compilation.     (line   58)
* compilation errors:                    Compilation.        (line    6)
* Compilation mode:                      Compilation Mode.   (line    6)
* compilation under MS-DOS:              MS-DOS Processes.   (line    6)
* complete key:                          Keys.               (line   11)
* completion:                            Completion.         (line    6)
* completion (Lisp symbols):             Symbol Completion.  (line   15)
* completion (symbol names):             Symbol Completion.  (line    6)
* completion alternative:                Completion.         (line   10)
* completion list:                       Completion Commands.
                                                             (line   33)
* completion style:                      Completion Styles.  (line    6)
* compose character:                     Unibyte Mode.       (line   60)
* compressing files (in Dired):          Operating on Files. (line  106)
* compression:                           Compressed Files.   (line    6)
* Conf mode:                             Program Modes.      (line   14)
* confirming in the minibuffer:          Completion Exit.    (line   34)
* conflicts:                             Merging.            (line   31)
* connecting to remote host:             Remote Host.        (line    6)
* contents of a buffer:                  Buffers.            (line   33)
* continuation line:                     Continuation Lines. (line    6)
* contributing to Emacs:                 Contributing.       (line    6)
* Control:                               User Input.         (line   18)
* control character:                     User Input.         (line   11)
* control characters on display:         Text Display.       (line   10)
* converting text to upper or lower case: Case.              (line   20)
* Coptic calendar:                       Calendar Systems.   (line   40)
* copy:                                  Cut and Paste.      (line    6)
* copy/paste to/from primary selection (macOS): Mac / GNUstep Basics.
                                                             (line   33)
* copying files:                         Copying and Naming. (line   22)
* copying files (in Dired):              Operating on Files. (line   32)
* copying text:                          Yanking.            (line    6)
* copyright assignment:                  Copyright Assignment.
                                                             (line    6)
* CORBA IDL mode:                        C Modes.            (line    6)
* core dump:                             Crashing.           (line   48)
* Core Text, on macOS:                   Mac / GNUstep Customization.
                                                             (line   18)
* correcting spelling:                   Spelling.           (line    6)
* CPerl mode:                            Program Modes.      (line   14)
* crash report:                          Crashing.           (line    6)
* crashes:                               Auto Save.          (line    6)
* create a text-based table:             Table Creation.     (line    6)
* creating files:                        Visiting.           (line   45)
* creating frames:                       Creating Frames.    (line    6)
* Croatian:                              Language Environments.
                                                             (line   31)
* cryptanalysis:                         Amusements.         (line   18)
* CSSC:                                  Version Control Systems.
                                                             (line   15)
* CUA key bindings:                      CUA Bindings.       (line    6)
* curly quotes:                          Quotation Marks.    (line    6)
* curly quotes, and terminal capabilities: Text Display.     (line   57)
* curly quotes, inserting:               Inserting Text.     (line   58)
* current buffer:                        Buffers.            (line   24)
* current function name in mode line:    Which Function.     (line    6)
* current message (Rmail):               Rmail Basics.       (line   13)
* cursor:                                Point.              (line    6)
* cursor color, command-line argument:   Colors X.           (line   26)
* cursor face:                           Faces.              (line   39)
* cursor in non-selected windows:        Cursor Display.     (line   44)
* cursor location:                       Position Info.      (line   37)
* cursor location, on MS-DOS:            Text and Binary.    (line   19)
* cursor motion:                         Moving Point.       (line    6)
* cursor shape on MS-DOS:                MS-DOS Display.     (line   20)
* cursor, blinking:                      Cursor Display.     (line   23)
* cursor, visual-order motion:           Bidirectional Editing.
                                                             (line   83)
* curved quotes:                         Quotation Marks.    (line    6)
* curved quotes, and terminal capabilities: Text Display.    (line   57)
* curved quotes, inserting:              Inserting Text.     (line   58)
* custom themes:                         Custom Themes.      (line    6)
* custom themes, creating:               Creating Custom Themes.
                                                             (line    6)
* customizable variable:                 Easy Customization. (line    6)
* customization:                         Customization.      (line    6)
* customization buffer:                  Easy Customization. (line   15)
* customization groups:                  Customization Groups.
                                                             (line    6)
* customization of menu face:            Standard Faces.     (line  149)
* customizing faces:                     Face Customization. (line    6)
* customizing Lisp indentation:          Lisp Indent.        (line    6)
* customizing variables:                 Changing a Variable.
                                                             (line   35)
* cut:                                   Cut and Paste.      (line    6)
* cut and paste:                         Glossary.           (line  339)
* cutting text:                          Deletion and Killing.
                                                             (line    6)
* cvs:                                   VC Directory Mode.  (line   28)
* CVS:                                   Version Control Systems.
                                                             (line   24)
* CVS directory mode:                    VC Directory Mode.  (line   28)
* CWarn mode:                            Other C Commands.   (line   72)
* Cyrillic:                              Language Environments.
                                                             (line   31)
* Czech:                                 Language Environments.
                                                             (line   32)
* daemon, Emacs:                         Emacs Server.       (line   27)
* day of year:                           General Calendar.   (line   19)
* daylight saving time:                  Daylight Saving.    (line    6)
* DBX:                                   Debuggers.          (line    6)
* dead character:                        Unibyte Mode.       (line   60)
* debbugs package:                       Known Problems.     (line   22)
* debuggers:                             Debuggers.          (line    6)
* debugging Emacs, tricks and techniques: Checklist.         (line  275)
* debugging X problems:                  Table of Resources. (line  151)
* decentralized version control:         VCS Repositories.   (line    6)
* decoding mail messages (Rmail):        Rmail Coding.       (line    6)
* decoding non-ASCII keyboard input on X: Communication Coding.
                                                             (line   57)
* decrease buffer face height:           Text Scale.         (line   19)
* decrypting files (in Dired):           Operating on Files. (line  118)
* default argument:                      Basic Minibuffer.   (line   17)
* default directory:                     Minibuffer File.    (line    6)
* default directory, of a buffer:        File Names.         (line   24)
* default face:                          Faces.              (line   31)
* default file name:                     File Names.         (line    6)
* default search mode:                   Search Customizations.
                                                             (line    9)
* default.el file, not loading:          Initial Options.    (line   85)
* default.el, the default init file:     Init File.          (line   18)
* defining keyboard macros:              Keyboard Macros.    (line    6)
* defuns:                                Moving by Defuns.   (line    6)
* <DEL> does not delete:                 DEL Does Not Delete.
                                                             (line    6)
* <DEL> vs <BACKSPACE>:                  DEL Does Not Delete.
                                                             (line    6)
* Delete Selection mode:                 Using Region.       (line   57)
* delete window:                         Change Window.      (line    6)
* deleting auto-save files:              Flagging Many Files.
                                                             (line   30)
* deleting blank lines:                  Blank Lines.        (line    6)
* deleting characters and lines:         Erasing.            (line    6)
* deleting files (in Dired):             Dired Deletion.     (line    6)
* deleting rows and column in text-based tables: Table Rows and Columns.
                                                             (line   17)
* deleting some backup files:            Flagging Many Files.
                                                             (line   50)
* deleting windows:                      Change Window.      (line    6)
* deletion:                              Deletion and Killing.
                                                             (line    6)
* deletion (of files):                   Misc File Ops.      (line   10)
* deletion (Rmail):                      Rmail Deletion.     (line    6)
* desktop:                               Saving Emacs Sessions.
                                                             (line    6)
* desktop restore in daemon mode:        Saving Emacs Sessions.
                                                             (line   85)
* desktop shortcut, MS-Windows:          Windows Startup.    (line    8)
* deterministic build:                   Initial Options.    (line   80)
* Devanagari:                            Language Environments.
                                                             (line   32)
* device for Emacs terminal I/O:         Initial Options.    (line   27)
* dialog boxes:                          Dialog Boxes.       (line    6)
* Dialog X Resources (Lucid widgets):    Lucid Resources.    (line    6)
* diary:                                 Diary.              (line    6)
* diary buffer:                          Diary Display.      (line    6)
* diary file:                            Format of Diary File.
                                                             (line    6)
* Diff Auto-Refine mode:                 Diff Mode.          (line   35)
* Diff mode:                             Diff Mode.          (line    6)
* digest message:                        Rmail Digest.       (line    6)
* directional window selection:          Window Convenience. (line   18)
* directories in buffer names:           Uniquify.           (line    6)
* directory header lines:                Subdirectory Motion.
                                                             (line   10)
* directory listing:                     Directories.        (line    6)
* directory listing on MS-DOS:           MS-DOS Processes.   (line   47)
* directory name abbreviation:           File Aliases.       (line   32)
* directory tracking:                    Directory Tracking. (line    6)
* directory where Emacs starts on MS-Windows: Windows Startup.
                                                             (line    8)
* directory-local variables:             Directory Variables.
                                                             (line    6)
* Dired:                                 Dired.              (line    6)
* Dired and version control:             Misc Dired Features.
                                                             (line   45)
* Dired sorting:                         Dired Updating.     (line   68)
* Dired sorting order, on MS-Windows/MS-DOS: ls in Lisp.     (line   28)
* Dired, and MS-Windows/MS-DOS:          ls in Lisp.         (line    6)
* Dirtrack mode:                         Directory Tracking. (line   25)
* disable window system:                 Initial Options.    (line   38)
* disabled command:                      Disabling.          (line    6)
* disabling remote files:                Remote Files.       (line   25)
* DISPLAY environment variable:          Display X.          (line    6)
* display for Emacs frame:               Initial Options.    (line   32)
* display line numbers:                  Display Custom.     (line    9)
* display name (X Window System):        Display X.          (line    6)
* display of buffer size:                Optional Mode Line. (line    6)
* display of current line number:        Optional Mode Line. (line   16)
* display, incorrect:                    Screen Garbled.     (line    6)
* distributed version control:           VCS Repositories.   (line    6)
* DNS mode:                              Program Modes.      (line   14)
* DocTeX mode:                           TeX Mode.           (line    6)
* document viewer (DocView):             Document View.      (line    6)
* documentation string:                  Key Help.           (line   12)
* DocView mode:                          Document View.      (line    6)
* DOS applications, running from Emacs:  Windows Processes.  (line    6)
* DOS codepages:                         MS-DOS and MULE.    (line   20)
* DOS-style end-of-line display:         Recognize Coding.   (line   52)
* DOS-to-Unix conversion of files:       Text and Binary.    (line   38)
* double clicks:                         Mouse Buttons.      (line   28)
* double slash in file name:             Minibuffer File.    (line   34)
* down events:                           Mouse Buttons.      (line    6)
* downcase file names:                   Transforming File Names.
                                                             (line   29)
* drag and drop:                         Drag and Drop.      (line    6)
* drag and drop, Dired:                  Misc Dired Features.
                                                             (line   70)
* drag events:                           Mouse Buttons.      (line    6)
* drastic changes:                       Reverting.          (line    6)
* dribble file:                          Checklist.          (line  105)
* DSSSL mode:                            Program Modes.      (line   14)
* dunnet:                                Amusements.         (line   32)
* Dutch:                                 Language Environments.
                                                             (line   33)
* DVI file:                              Document View.      (line    6)
* Ebrowse:                               Tags Tables.        (line   27)
* echo area:                             Echo Area.          (line    6)
* echo area message:                     Echo Area.          (line   19)
* echoing:                               Echo Area.          (line    9)
* EDE (Emacs Development Environment):   EDE.                (line    6)
* Edebug:                                Checklist.          (line  181)
* editable fields (customization buffer): Customization Groups.
                                                             (line   39)
* editing binary files:                  Editing Binary Files.
                                                             (line    6)
* editing in Picture mode:               Basic Picture.      (line    6)
* editing level, recursive:              Recursive Edit.     (line    6)
* EDITOR environment variable:           Emacs Server.       (line    6)
* Eldoc mode:                            Lisp Doc.           (line   10)
* Electric Indent mode:                  Indent Convenience. (line   15)
* Electric Pair mode:                    Matching.           (line   63)
* Electric Quote mode:                   Quotation Marks.    (line    6)
* Eliza:                                 Amusements.         (line   60)
* Emacs as a server:                     Emacs Server.       (line    6)
* Emacs Development Environment:         EDE.                (line    6)
* Emacs icon, a gnu:                     Icons X.            (line   12)
* Emacs initialization file:             Init File.          (line    6)
* Emacs Lisp package archive:            Packages.           (line    6)
* Emacs Lispモード:                      Lisp Eval.          (line    6)
* emacs-internal, coding system:         Coding Systems.     (line  110)
* emacs22, completion style:             Completion Styles.  (line   39)
* emacsclient:                           Emacs Server.       (line    6)
* emacsclient invocation:                Invoking emacsclient.
                                                             (line    6)
* emacsclient options:                   emacsclient Options.
                                                             (line    6)
* emacsclient, on MS-Windows:            Windows Startup.    (line   73)
* emacsclient.exe:                       Windows Startup.    (line   49)
* emacsclientw.exe:                      Windows Startup.    (line   49)
* emacs_backtrace.txt file, MS-Windows:  Crashing.           (line    6)
* email:                                 Sending Mail.       (line    6)
* embedded widgets:                      Embedded WebKit Widgets.
                                                             (line    6)
* Emerge:                                Emerge.             (line    6)
* emergency escape:                      Emergency Escape.   (line    6)
* encoding of characters:                International.      (line    6)
* encrypted mails (reading in Rmail):    Rmail Display.      (line   80)
* encrypting files (in Dired):           Operating on Files. (line  131)
* encryption:                            Network Security.   (line    6)
* end-of-line convention, mode-line indication: Mode Line.   (line   38)
* end-of-line conversion:                Coding Systems.     (line   58)
* end-of-line conversion on MS-DOS/MS-Windows: Text and Binary.
                                                             (line    9)
* English:                               Language Environments.
                                                             (line   33)
* Enriched mode:                         Enriched Text.      (line    6)
* enriched text:                         Enriched Text.      (line    6)
* entering Emacs:                        Entering Emacs.     (line    6)
* environment variables:                 Environment.        (line    6)
* environment variables (macOS):         Mac / GNUstep Basics.
                                                             (line   42)
* environment variables for subshells:   Interactive Shell.  (line   37)
* environment variables in file names:   File Names.         (line   55)
* equivalent character sequences:        Lax Search.         (line   71)
* erasing characters and lines:          Erasing.            (line    6)
* error log:                             Compilation.        (line    6)
* error message:                         Echo Area.          (line   19)
* errors in init file:                   Initial Options.    (line  134)
* <ESC> replacing <Meta> key:            User Input.         (line   25)
* escape sequences in files:             Recognize Coding.   (line   60)
* escape-glyph face:                     Text Display.       (line   31)
* ESHELL environment variable:           Interactive Shell.  (line   37)
* Esperanto:                             Language Environments.
                                                             (line   33)
* etags:                                 Tags Tables.        (line   14)
* etags program:                         Create Tags Table.  (line    6)
* Ethiopic:                              Language Environments.
                                                             (line   33)
* Ethiopic calendar:                     Calendar Systems.   (line   40)
* European character sets:               Unibyte Mode.       (line    6)
* evaluate expression, command-line argument: Action Arguments.
                                                             (line   66)
* evaluation, Emacs Lisp:                Lisp Eval.          (line    6)
* events on macOS:                       Mac / GNUstep Events.
                                                             (line    6)
* exit incremental search:               Basic Isearch.      (line   31)
* exiting:                               Exiting.            (line    6)
* exiting recursive edit:                Recursive Edit.     (line   12)
* expanding subdirectories in Dired:     Subdirectories in Dired.
                                                             (line    6)
* expansion (of abbrevs):                Abbrevs.            (line    6)
* expansion of C macros:                 Other C Commands.   (line   36)
* expansion of environment variables:    File Names.         (line   55)
* expression:                            Expressions.        (line    6)
* expunging (Rmail):                     Rmail Deletion.     (line   11)
* face at point:                         International Chars.
                                                             (line   59)
* face colors, setting:                  Colors.             (line   32)
* faces:                                 Faces.              (line    6)
* faces for highlighting query replace:  Query Replace.      (line   34)
* faces for highlighting search matches: Basic Isearch.      (line   21)
* faces for mode lines:                  Standard Faces.     (line   84)
* faces for text-mode menus:             Standard Faces.     (line  152)
* faces under MS-DOS:                    MS-DOS Display.     (line    6)
* faces, customizing:                    Face Customization. (line    6)
* failed merges:                         Comparing Files.    (line   48)
* Feedmail:                              Mail Sending.       (line   29)
* FFAP minor mode:                       FFAP.               (line   19)
* file archives:                         File Archives.      (line    6)
* file comparison (in Dired):            Comparison in Dired.
                                                             (line    6)
* file database (locate):                Dired and Find.     (line   40)
* file dates:                            Interlocking.       (line    6)
* file directory:                        Directories.        (line    6)
* file local variables:                  File Variables.     (line    6)
* file management:                       Dired.              (line    6)
* file modes:                            Misc File Ops.      (line   51)
* file name caching:                     File Name Cache.    (line    6)
* file names:                            File Names.         (line    6)
* file names on MS-Windows:              Windows Files.      (line    6)
* file names under MS-DOS:               MS-DOS File Names.  (line    6)
* file names under Windows 95/NT:        MS-DOS File Names.  (line   25)
* file names with non-ASCII characters:  File Name Coding.   (line   10)
* file names, invalid characters on MS-Windows: Windows Files.
                                                             (line   35)
* file names, quote special characters:  Quoted File Names.  (line    6)
* file notifications:                    Reverting.          (line   45)
* file ownership, and backup:            Backup Copying.     (line   20)
* file permissions:                      Misc File Ops.      (line   51)
* file selection dialog:                 Visiting.           (line  121)
* file selection dialog, how to disable: Dialog Boxes.       (line   18)
* file shadows:                          File Shadowing.     (line    6)
* file truenames:                        File Aliases.       (line   26)
* file version in change log entries:    Change Log Commands.
                                                             (line   35)
* file, warning when size is large:      Visiting.           (line   62)
* file-based version control:            VCS Changesets.     (line    6)
* file-name completion, on MS-Windows:   Windows Files.      (line   11)
* file-name encoding, MS-Windows:        File Name Coding.   (line   27)
* files:                                 Files.              (line    6)
* files, visiting and saving:            Visiting.           (line   23)
* filesets:                              Filesets.           (line    6)
* filesets, VC:                          Basic VC Editing.   (line    6)
* fill prefix:                           Fill Prefix.        (line    6)
* filling text:                          Filling.            (line    6)
* find:                                  File Name Cache.    (line    6)
* find and Dired:                        Dired and Find.     (line    6)
* find definition of symbols:            Looking Up Identifiers.
                                                             (line    6)
* find Info manual by its file name:     Misc Help.          (line   11)
* find references to symbols:            Looking Up Identifiers.
                                                             (line    6)
* finder:                                Package Keywords.   (line    6)
* finding file at point:                 FFAP.               (line    6)
* finding files containing regexp matches (in Dired): Marks vs Flags.
                                                             (line  127)
* finding strings within text:           Search.             (line    6)
* firewall, and accessing remote files:  Remote Files.       (line   59)
* fixing incorrectly decoded mail messages: Rmail Coding.    (line   17)
* flagging files (in Dired):             Dired Deletion.     (line    6)
* flagging many files for deletion (in Dired): Flagging Many Files.
                                                             (line    6)
* Flyspell mode:                         Spelling.           (line  151)
* folding editing:                       Foldout.            (line    6)
* Follow mode:                           Follow Mode.        (line    6)
* font antialiasing (MS Windows):        Windows Fonts.      (line   97)
* font backend selection (MS-Windows):   Windows Fonts.      (line   15)
* font backend, on macOS:                Mac / GNUstep Customization.
                                                             (line   18)
* font for menus:                        Table of Resources. (line  100)
* Font Lock mode:                        Font Lock.          (line    6)
* font name (X Window System):           Font X.             (line    6)
* font of character at point:            International Chars.
                                                             (line   59)
* font properties (MS Windows gdi backend): Windows Fonts.   (line   81)
* font properties (MS Windows):          Windows Fonts.      (line   31)
* font scripts (MS Windows):             Windows Fonts.      (line   83)
* font specification (MS Windows):       Windows Fonts.      (line    6)
* font Unicode subranges (MS Windows):   Windows Fonts.      (line   83)
* fontconfig:                            Fonts.              (line   46)
* fonts:                                 Fonts.              (line    6)
* fonts and faces:                       Face Customization. (line    6)
* fonts for PostScript printing:         PostScript Variables.
                                                             (line   53)
* fonts for various scripts:             Fontsets.           (line   14)
* fonts, emulating under MS-DOS:         MS-DOS Display.     (line    6)
* fonts, how to ignore:                  Modifying Fontsets. (line   35)
* fontsets:                              Fontsets.           (line    6)
* fontsets, modifying:                   Modifying Fontsets. (line    6)
* foreground color, command-line argument: Colors X.         (line   13)
* foreground for menus:                  Table of Resources. (line  105)
* formfeed character:                    Pages.              (line    6)
* Fortran 77 and Fortran 90, 95, 2003, 2008: Fortran.        (line    6)
* Fortran continuation lines:            ForIndent Cont.     (line    6)
* Fortran fixed form and free form:      Fortran.            (line    6)
* Fortran mode:                          Fortran.            (line    6)
* fortune cookies:                       Mail Amusements.    (line   18)
* forwarding a message:                  Rmail Reply.        (line   69)
* frame:                                 Screen.             (line    6)
* frame focus policy, MS-Windows:        Windows Misc.       (line   18)
* frame size under MS-DOS:               MS-DOS Display.     (line   43)
* frame size, specifying default:        Frame Parameters.   (line   13)
* frame title, command-line argument:    Title X.            (line   16)
* frames:                                Frames.             (line    6)
* frames on MS-DOS:                      MS-DOS Display.     (line   37)
* French:                                Language Environments.
                                                             (line   33)
* French Revolutionary calendar:         Calendar Systems.   (line   28)
* fringe face:                           Standard Faces.     (line  123)
* fringes:                               Fringes.            (line    6)
* fringes, and continuation lines:       Continuation Lines. (line    6)
* fringes, and unused line indication:   Useless Whitespace. (line   28)
* fringes, for debugging:                Source Buffers.     (line    6)
* FTP:                                   Remote Files.       (line    6)
* fullheight, command-line argument:     Window Size X.      (line   32)
* fullscreen, command-line argument:     Window Size X.      (line   18)
* fullwidth, command-line argument:      Window Size X.      (line   36)
* function key:                          Keymaps.            (line   37)
* function, move to beginning or end:    Moving by Defuns.   (line   17)
* future history for file names:         Minibuffer History. (line   42)
* games:                                 Amusements.         (line    6)
* gamma correction:                      Table of Resources. (line  123)
* garbled display:                       Screen Garbled.     (line    6)
* garbled text:                          Text Garbled.       (line    6)
* gateway, and remote file access with ange-ftp: Remote Files.
                                                             (line   59)
* GDB:                                   Debuggers.          (line    6)
* GDB User Interface layout:             GDB User Interface Layout.
                                                             (line    6)
* geometry of Emacs window:              Window Size X.      (line    6)
* geometry, command-line argument:       Window Size X.      (line   11)
* Georgian:                              Language Environments.
                                                             (line   33)
* German:                                Language Environments.
                                                             (line   34)
* getting help with keys:                Basic Help.         (line    6)
* Ghostscript, use for PostScript printing: Windows Printing.
                                                             (line   93)
* git:                                   Version Control Systems.
                                                             (line   38)
* Glasses mode:                          MixedCase Words.    (line   12)
* Global Auto Revert mode:               Reverting.          (line   35)
* global keymap:                         Keymaps.            (line   21)
* global mark:                           CUA Bindings.       (line   47)
* global mark ring:                      Global Mark Ring.   (line    6)
* global substitution:                   Replace.            (line    6)
* glossary:                              Glossary.           (line    6)
* glyphless characters:                  Text Display.       (line   47)
* glyphless-char face:                   Text Display.       (line   47)
* gnu.emacs.help newsgroup:              Service.            (line    6)
* Gnus:                                  Gnus.               (line    6)
* GNUstep:                               Mac OS / GNUstep.   (line    6)
* Go Moku:                               Amusements.         (line   34)
* Goto Address mode:                     Goto Address mode.  (line    6)
* graphic characters:                    Inserting Text.     (line    6)
* Greek:                                 Language Environments.
                                                             (line   34)
* Gregorian calendar:                    Other Calendars.    (line    6)
* growing minibuffer:                    Minibuffer Edit.    (line   26)
* GTK font pattern:                      Fonts.              (line   95)
* GTK+ resources:                        GTK resources.      (line    6)
* GTK+ styles:                           GTK styles.         (line    6)
* GTK+ widget classes:                   GTK Names in Emacs. (line    6)
* GTK+ widget names:                     GTK Widget Names.   (line    6)
* GTK+ widget names in Emacs:            GTK Names in Emacs. (line    6)
* GUD interaction buffer:                Debugger Operation. (line    6)
* GUD library:                           Debuggers.          (line    6)
* GUD Tooltip mode:                      Debugger Operation. (line   30)
* guillemets:                            Quotation Marks.    (line    6)
* Gujarati:                              Language Environments.
                                                             (line   34)
* gzip:                                  Compressed Files.   (line    6)
* Han:                                   International.      (line    6)
* handwriting:                           PostScript.         (line   56)
* Hangul:                                International.      (line    6)
* hard links (creation):                 Copying and Naming. (line   42)
* hard links (in Dired):                 Operating on Files. (line   64)
* hard links (visiting):                 File Aliases.       (line    6)
* hard newline:                          Hard and Soft Newlines.
                                                             (line    6)
* hardcopy:                              Printing.           (line    6)
* header (TeX mode):                     TeX Print.          (line   94)
* header line (Dired):                   Subdirectory Motion.
                                                             (line   10)
* header-line face:                      Standard Faces.     (line  103)
* header-line-highlight face:            Standard Faces.     (line  109)
* headers (of mail message):             Mail Headers.       (line    6)
* heading lines (Outline mode):          Outline Format.     (line    6)
* Hebrew:                                Language Environments.
                                                             (line   34)
* Hebrew calendar:                       Calendar Systems.   (line   16)
* height of minibuffer:                  Minibuffer Edit.    (line   26)
* height of the horizontal scroll bar:   Scroll Bars.        (line   90)
* help:                                  Help.               (line    6)
* help in using Emacs:                   Service.            (line    6)
* help text, in GTK+ file chooser:       Dialog Boxes.       (line   24)
* help, viewing web pages:               Help Mode.          (line   38)
* help-gnu-emacs mailing list:           Service.            (line    6)
* hex editing:                           Editing Binary Files.
                                                             (line    6)
* Hexl mode:                             Editing Binary Files.
                                                             (line    6)
* hg:                                    Version Control Systems.
                                                             (line   43)
* Hi Lock mode:                          Highlight Interactively.
                                                             (line   11)
* hidden files, in GTK+ file chooser:    Dialog Boxes.       (line   24)
* Hide-ifdef mode:                       Other C Commands.   (line   87)
* Hideshow mode:                         Hideshow.           (line    6)
* hiding details in Dired:               Misc Dired Features.
                                                             (line   38)
* hiding subdirectories (Dired):         Hiding Subdirectories.
                                                             (line    6)
* Highlight Changes mode:                Highlight Interactively.
                                                             (line    6)
* highlight current line:                Cursor Display.     (line   49)
* highlighting by matching:              Highlight Interactively.
                                                             (line    6)
* highlighting lines of text:            Highlight Interactively.
                                                             (line   59)
* highlighting matching parentheses:     Matching.           (line   33)
* highlighting phrase:                   Highlight Interactively.
                                                             (line   64)
* highlighting region:                   Disabled Transient Mark.
                                                             (line    6)
* highlighting symbol at point:          Highlight Interactively.
                                                             (line   71)
* Hindi:                                 International.      (line    6)
* history of commands:                   Repetition.         (line    6)
* history of minibuffer input:           Minibuffer History. (line    6)
* history reference:                     History References. (line    6)
* holiday forms:                         Holiday Customizing.
                                                             (line   31)
* holidays:                              Holidays.           (line    6)
* HOME directory on MS-Windows:          Windows HOME.       (line    6)
* home directory shorthand:              Minibuffer File.    (line   49)
* HOME directory under MS-DOS:           MS-DOS File Names.  (line   34)
* homoglyph face:                        Text Display.       (line   57)
* hook:                                  Hooks.              (line    6)
* Horizontal Scroll Bar:                 Scroll Bars.        (line   67)
* Horizontal Scroll Bar mode:            Scroll Bars.        (line   67)
* horizontal scrolling:                  Horizontal Scrolling.
                                                             (line    6)
* hourglass pointer display:             Display Custom.     (line   81)
* HTML mode:                             HTML Mode.          (line    6)
* hungry deletion (C Mode):              Hungry Delete.      (line    6)
* hunk, diff:                            Diff Mode.          (line   11)
* Hyper (under MS-DOS):                  MS-DOS Keyboard.    (line   21)
* hyperlink:                             Help Mode.          (line   29)
* hyperlinks:                            Mouse References.   (line    6)
* iCalendar support:                     Importing Diary.    (line   17)
* Icomplete mode:                        Icomplete.          (line    6)
* Icon mode:                             Program Modes.      (line   14)
* iconifying:                            Exiting.            (line   47)
* icons (X Window System):               Icons X.            (line    6)
* icons, toolbar:                        Tool Bars.          (line    6)
* identifier, finding definition of:     Looking Up Identifiers.
                                                             (line    6)
* IDL mode:                              C Modes.            (line    6)
* ignore font:                           Modifying Fontsets. (line   35)
* ignored file names, in completion:     Completion Options. (line   19)
* image animation:                       File Conveniences.  (line   33)
* image-dired:                           Image-Dired.        (line    6)
* image-dired mode:                      Image-Dired.        (line    6)
* ImageMagick support:                   File Conveniences.  (line   46)
* images, viewing:                       File Conveniences.  (line   20)
* IMAP mailboxes:                        Remote Mailboxes.   (line   29)
* in-situ subdirectory (Dired):          Subdirectories in Dired.
                                                             (line   19)
* inbox file:                            Rmail Inbox.        (line    6)
* incorrect fontification:               Font Lock.          (line   55)
* increase buffer face height:           Text Scale.         (line   19)
* incremental search:                    Incremental Search. (line    6)
* incremental search, edit search string: Repeat Isearch.    (line   49)
* incremental search, exiting:           Basic Isearch.      (line   31)
* incremental search, help on special keys: Special Isearch. (line   90)
* incremental search, input method interference: Input Methods.
                                                             (line   79)
* indentation:                           Indentation.        (line    6)
* indentation for comments:              Comment Commands.   (line    6)
* indentation for programs:              Program Indent.     (line    6)
* index of buffer definitions:           Imenu.              (line    6)
* indirect buffer:                       Indirect Buffers.   (line    6)
* indirect buffers and outlines:         Outline Views.      (line    6)
* inferior process:                      Compilation.        (line    6)
* inferior processes under MS-DOS:       MS-DOS Processes.   (line    6)
* Info:                                  Misc Help.          (line    6)
* init file:                             Init File.          (line    6)
* init file .emacs on MS-Windows:        Windows HOME.       (line   41)
* init file, default name under MS-DOS:  MS-DOS File Names.  (line    6)
* init file, not loading:                Initial Options.    (line   85)
* initial options (command line):        Emacs Invocation.   (line   38)
* initials, completion style:            Completion Styles.  (line   55)
* input event:                           User Input.         (line   38)
* input methods:                         Input Methods.      (line    6)
* input methods, X:                      Table of Resources. (line  162)
* input with the keyboard:               User Input.         (line    6)
* insert file contents, command-line argument: Action Arguments.
                                                             (line   69)
* insert Unicode character:              Inserting Text.     (line   58)
* inserted subdirectory (Dired):         Subdirectories in Dired.
                                                             (line   19)
* inserting blank lines:                 Blank Lines.        (line    6)
* inserting matching parentheses:        Matching.           (line   63)
* inserting rows and columns in text-based tables: Table Rows and Columns.
                                                             (line    6)
* insertion:                             Inserting Text.     (line    6)
* INSIDE_EMACS environment variable:     Interactive Shell.  (line   57)
* Integrated development environment:    EDE.                (line    6)
* interactive highlighting:              Highlight Interactively.
                                                             (line    6)
* interactively edit search string:      Repeat Isearch.     (line   49)
* internal border width, command-line argument: Borders X.   (line   16)
* international characters in .emacs:    Init Non-ASCII.     (line    6)
* international files from DOS/Windows systems: Coding Systems.
                                                             (line   21)
* international scripts:                 International.      (line    6)
* international support (MS-DOS):        MS-DOS and MULE.    (line    6)
* Intlfonts for PostScript printing:     PostScript Variables.
                                                             (line   53)
* Intlfonts package, installation:       Fontsets.           (line   14)
* invisible lines:                       Outline Mode.       (line    6)
* invisible text, and query-replace:     Query Replace.      (line  143)
* invisible text, searching for:         Special Isearch.    (line   24)
* invocation (command line arguments):   Emacs Invocation.   (line    6)
* invoking Emacs from Windows Explorer:  Windows Startup.    (line   49)
* IPA:                                   Language Environments.
                                                             (line   34)
* isearch:                               Incremental Search. (line    6)
* isearch face:                          Basic Isearch.      (line   21)
* isearch multiple buffers:              Other Repeating Search.
                                                             (line   14)
* isearch multiple files:                Other Repeating Search.
                                                             (line   26)
* isearch-fail face:                     Error in Isearch.   (line    6)
* Islamic calendar:                      Calendar Systems.   (line   20)
* ISO commercial calendar:               Calendar Systems.   (line    6)
* ISO Latin character sets:              Unibyte Mode.       (line    6)
* iso-ascii library:                     Unibyte Mode.       (line   27)
* iso-transl library:                    Unibyte Mode.       (line   60)
* ispell program:                        Spelling.           (line  128)
* Italian:                               Language Environments.
                                                             (line   34)
* Japanese:                              Language Environments.
                                                             (line   34)
* jar:                                   File Archives.      (line   45)
* Java class archives:                   File Archives.      (line   45)
* Java mode:                             C Modes.            (line    6)
* Javascript mode:                       Program Modes.      (line   14)
* JDB:                                   Debuggers.          (line    6)
* Julian calendar:                       Calendar Systems.   (line    8)
* Julian day numbers:                    Calendar Systems.   (line   12)
* just-in-time (JIT) font-lock:          Font Lock.          (line   80)
* justification:                         Fill Commands.      (line   34)
* justification in text-based tables:    Cell Justification. (line    6)
* justification style:                   Enriched Justification.
                                                             (line    6)
* Kannada:                               Language Environments.
                                                             (line   34)
* Kerberos POP3 authentication:          Remote Mailboxes.   (line   49)
* key:                                   Keys.               (line   11)
* key bindings:                          Key Bindings.       (line    6)
* key rebinding, permanent:              Init Rebinding.     (line    6)
* key rebinding, this session:           Rebinding.          (line    6)
* key sequence:                          Keys.               (line   11)
* keyboard input:                        User Input.         (line    6)
* keyboard macro:                        Keyboard Macros.    (line    6)
* keyboard macros, in registers:         Keyboard Macro Registers.
                                                             (line    6)
* keyboard shortcuts:                    Glossary.           (line  781)
* keyboard, MS-Windows:                  Windows Keyboard.   (line    6)
* keymap:                                Keymaps.            (line    6)
* keypad:                                Function Keys.      (line   49)
* keypad keys (MS-Windows):              Windows Keyboard.   (line   81)
* keys stolen by window manager:         User Input.         (line   32)
* keys, reserved:                        Key Bindings.       (line   11)
* Khmer:                                 Language Environments.
                                                             (line   35)
* kill DOS application:                  Windows Processes.  (line   36)
* kill ring:                             Yanking.            (line    6)
* killing buffers:                       Kill Buffer.        (line    6)
* killing characters and lines:          Erasing.            (line    6)
* killing Emacs:                         Exiting.            (line    6)
* killing expressions:                   Expressions.        (line   43)
* killing rectangular areas of text:     Rectangles.         (line    6)
* killing text:                          Deletion and Killing.
                                                             (line    6)
* Korean:                                Language Environments.
                                                             (line   35)
* label (Rmail):                         Rmail Labels.       (line    6)
* language environment, automatic selection on MS-DOS: MS-DOS and MULE.
                                                             (line   42)
* language environments:                 Language Environments.
                                                             (line    6)
* Lao:                                   Language Environments.
                                                             (line   35)
* LaTeX mode:                            TeX Mode.           (line    6)
* Latin:                                 Language Environments.
                                                             (line   35)
* Latin-1 TeX encoding:                  TeX Misc.           (line   12)
* Latvian:                               Language Environments.
                                                             (line   36)
* lax search:                            Lax Search.         (line    6)
* lax space matching in replace commands: Replacement and Lax Matches.
                                                             (line   10)
* lax space matching in search:          Lax Search.         (line   15)
* lazy highlighting customizations:      Search Customizations.
                                                             (line   23)
* lazy search highlighting:              Repeat Isearch.     (line   13)
* lazy-highlight face:                   Search Customizations.
                                                             (line   23)
* lazy-highlight face, in replace:       Query Replace.      (line   34)
* leaving Emacs:                         Exiting.            (line    6)
* libraries:                             Lisp Libraries.     (line    6)
* Life:                                  Amusements.         (line   41)
* line endings:                          Coding Systems.     (line   58)
* line mode (terminal emulator):         Terminal emulator.  (line   11)
* line number commands:                  Position Info.      (line   37)
* line number display:                   Optional Mode Line. (line   16)
* line spacing:                          Table of Resources. (line   84)
* line spacing, command-line argument:   Misc X.             (line   17)
* line truncation:                       Line Truncation.    (line    6)
* line truncation, and fringes:          Continuation Lines. (line   20)
* line wrapping:                         Continuation Lines. (line    6)
* line-number face:                      Display Custom.     (line   67)
* lines, highlighting:                   Highlight Interactively.
                                                             (line   59)
* links:                                 Mouse References.   (line    6)
* links (customization buffer):          Customization Groups.
                                                             (line   39)
* Lisp character syntax:                 Init Syntax.        (line   49)
* Lisp editing:                          Programs.           (line    6)
* Lisp files byte-compiled by XEmacs:    Lisp Libraries.     (line   78)
* Lisp object syntax:                    Init Syntax.        (line   65)
* Lisp string syntax:                    Init Syntax.        (line   30)
* Lisp symbol completion:                Symbol Completion.  (line   15)
* lisp-indent-function property:         Lisp Indent.        (line   23)
* Lispモード:                            External Lisp.      (line    6)
* list commands:                         Moving by Parens.   (line    6)
* listing current buffers:               List Buffers.       (line    9)
* listing system fonts:                  Fonts.              (line  199)
* Lithuanian:                            Language Environments.
                                                             (line   36)
* load init file of another user:        Initial Options.    (line  130)
* load path for Emacs Lisp:              Lisp Libraries.     (line   21)
* loading Lisp code:                     Lisp Libraries.     (line    6)
* loading Lisp libraries automatically:  Init Examples.      (line   83)
* loading Lisp libraries, command-line argument: Action Arguments.
                                                             (line   38)
* loading several files (in Dired):      Operating on Files. (line  135)
* local keymap:                          Local Keymaps.      (line    6)
* local variables:                       Locals.             (line   16)
* local variables in files:              File Variables.     (line    6)
* local variables, for all files in a directory: Directory Variables.
                                                             (line    6)
* locale, date format:                   Time Stamps.        (line    6)
* locales:                               Language Environments.
                                                             (line   46)
* location of point:                     Position Info.      (line   37)
* locking (CVS):                         CVS Options.        (line   47)
* locking files:                         Interlocking.       (line   17)
* locking, non-strict (RCS):             RCS and SCCS.       (line    6)
* locking-based version:                 VCS Merging.        (line   15)
* locus:                                 Compilation Mode.   (line    6)
* Log Edit mode:                         Log Buffer.         (line   12)
* log File, types of:                    Types of Log File.  (line    6)
* logging keystrokes:                    Checklist.          (line  105)
* logical order:                         Bidirectional Editing.
                                                             (line   18)
* long file names in DOS box under Windows 95/NT: MS-DOS File Names.
                                                             (line   25)
* looking for a subject in documentation: Help.              (line   18)
* lpr usage under MS-DOS:                Windows Printing.   (line   75)
* LRM:                                   Bidirectional Editing.
                                                             (line   53)
* ls emulation:                          ls in Lisp.         (line    6)
* Lucid Widget X Resources:              Lucid Resources.    (line    6)
* lzh:                                   File Archives.      (line   45)
* M-:                                    User Input.         (line   18)
* M-<TAB> vs <Alt>-<TAB> (MS-Windows):   Windows Keyboard.   (line   44)
* M4 mode:                               Program Modes.      (line   14)
* Macintosh:                             Mac OS / GNUstep.   (line    6)
* Macintosh end-of-line conversion:      Coding Systems.     (line   58)
* macOS:                                 Mac OS / GNUstep.   (line    6)
* macro expansion in C:                  Other C Commands.   (line   36)
* mail:                                  Sending Mail.       (line    6)
* mail (on mode line):                   Optional Mode Line. (line   60)
* mail aliases:                          Mail Aliases.       (line    6)
* MAIL environment variable:             Rmail Inbox.        (line   15)
* Mail mode:                             Mail Methods.       (line    6)
* mail signature:                        Mail Signature.     (line    6)
* mail-composition methods:              Mail Methods.       (line    6)
* Mailclient:                            Mail Sending.       (line   29)
* MAILHOST environment variable:         Remote Mailboxes.   (line   14)
* mailrc file:                           Mail Aliases.       (line    6)
* main border width, command-line argument: Borders X.       (line   21)
* major modes:                           Major Modes.        (line    6)
* make:                                  Compilation.        (line    6)
* Makefile mode:                         Program Modes.      (line   14)
* making pictures out of text characters: Picture Mode.      (line    6)
* Malayalam:                             Language Environments.
                                                             (line   37)
* man page:                              Man Page.           (line    6)
* man pages, and local file variables:   Specifying File Variables.
                                                             (line   34)
* manipulating paragraphs:               Paragraphs.         (line    6)
* manipulating sentences:                Sentences.          (line    6)
* manipulating text:                     Text.               (line    6)
* manual pages, on MS-DOS/MS-Windows:    Man Page.           (line   39)
* manual version backups:                CVS Options.        (line   39)
* manuals, included:                     Misc Help.          (line    6)
* mark:                                  Mark.               (line    6)
* mark rectangle:                        Rectangles.         (line   13)
* mark ring:                             Mark Ring.          (line    6)
* marking executable files (in Dired):   Marks vs Flags.     (line   27)
* marking many files (in Dired):         Marks vs Flags.     (line    6)
* marking sections of text:              Marking Objects.    (line    6)
* marking subdirectories (in Dired):     Marks vs Flags.     (line   36)
* marking symbolic links (in Dired):     Marks vs Flags.     (line   31)
* match (face name):                     Other Repeating Search.
                                                             (line   42)
* matching parentheses:                  Matching.           (line    6)
* matching parenthesis and braces, moving to: Moving by Parens.
                                                             (line    6)
* maximized, command-line argument:      Window Size X.      (line   25)
* maximum buffer size exceeded, error message: Visiting.     (line   62)
* Mayan calendar:                        Mayan Calendar.     (line    6)
* Mayan calendar round:                  Mayan Calendar.     (line   56)
* Mayan calendars:                       Calendar Systems.   (line   34)
* Mayan haab calendar:                   Mayan Calendar.     (line   49)
* Mayan long count:                      Mayan Calendar.     (line   30)
* Mayan tzolkin calendar:                Mayan Calendar.     (line   42)
* mbox files:                            Rmail Inbox.        (line   41)
* memory full:                           Memory Full.        (line    6)
* menu bar:                              Menu Bar.           (line    6)
* menu bar (X resource):                 Table of Resources. (line   92)
* menu bar access using keyboard:        Menu Bar.           (line   22)
* menu bar appearance:                   Standard Faces.     (line  149)
* Menu Bar mode:                         Menu Bars.          (line    6)
* menu face, no effect if customized:    Standard Faces.     (line  149)
* Menu X Resources (Lucid widgets):      Lucid Resources.    (line    6)
* Menu X Resources (Motif widgets):      Motif Resources.    (line    6)
* Mercurial:                             Version Control Systems.
                                                             (line   43)
* merge buffer (Emerge):                 Overview of Emerge. (line   22)
* merge mail from file (Rmail):          Rmail Files.        (line   56)
* merges, failed:                        Comparing Files.    (line   48)
* merging changes:                       Merging.            (line    6)
* merging files:                         Emerge.             (line    6)
* merging-based version:                 VCS Merging.        (line   10)
* message:                               Sending Mail.       (line    6)
* Message mode:                          Mail Commands.      (line    6)
* Message mode for sending mail:         Mail Methods.       (line    6)
* message number (Rmail):                Rmail Basics.       (line   21)
* messages saved from echo area:         Echo Area.          (line   32)
* META:                                  User Input.         (line   18)
* Meta (under MS-DOS):                   MS-DOS Keyboard.    (line   21)
* Meta commands and words:               Words.              (line    6)
* Metafont mode:                         Program Modes.      (line   14)
* MH mail interface:                     Mail Methods.       (line    6)
* Microsoft Office file:                 Document View.      (line    6)
* Microsoft Windows:                     Microsoft Windows.  (line    6)
* Midnight mode:                         Kill Buffer.        (line   59)
* MIME:                                  Mail Misc.          (line    6)
* MIME messages (Rmail):                 Rmail Display.      (line   36)
* minibuffer:                            Minibuffer.         (line    6)
* minibuffer confirmation:               Completion Exit.    (line   34)
* minibuffer defaults for file names:    Minibuffer History. (line   42)
* Minibuffer Electric Default mode:      Basic Minibuffer.   (line   23)
* minibuffer history:                    Minibuffer History. (line    6)
* minibuffer history, searching:         Isearch Minibuffer. (line    6)
* minibuffer keymaps:                    Minibuffer Maps.    (line    6)
* minibuffer-prompt face:                Standard Faces.     (line  117)
* minimizing:                            Exiting.            (line   47)
* minimizing a frame at startup:         Icons X.            (line    6)
* minor mode keymap:                     Local Keymaps.      (line    6)
* minor modes:                           Minor Modes.        (line    6)
* mistakes, correcting:                  Fixit.              (line    6)
* mode commands for minor modes:         Minor Modes.        (line   20)
* mode hook:                             Major Modes.        (line   72)
* mode hook, and major modes:            Program Modes.      (line   38)
* mode line:                             Mode Line.          (line    6)
* mode line (MS-DOS):                    MS-DOS and MULE.    (line   59)
* mode line, 3D appearance:              Optional Mode Line. (line   78)
* mode line, mouse:                      Mode Line Mouse.    (line    6)
* mode, Abbrev:                          Abbrev Concepts.    (line   12)
* mode, archive:                         File Archives.      (line   45)
* mode, Auto Compression:                Compressed Files.   (line    6)
* mode, Auto Fill:                       Auto Fill.          (line    6)
* mode, Auto Revert:                     Reverting.          (line   35)
* mode, Auto Save:                       Auto Save.          (line    6)
* mode, AWK:                             C Modes.            (line    6)
* mode, C:                               C Modes.            (line    6)
* mode, C++:                             C Modes.            (line    6)
* mode, Column Number:                   Optional Mode Line. (line   22)
* mode, Comint:                          Shell Mode.         (line  142)
* mode, Compilation:                     Compilation Mode.   (line    6)
* mode, CORBA IDL:                       C Modes.            (line    6)
* mode, Delete Selection:                Using Region.       (line   57)
* mode, Diff Auto-Refine:                Diff Mode.          (line   35)
* mode, Dirtrack:                        Directory Tracking. (line   25)
* mode, DocTeX:                          TeX Mode.           (line    6)
* mode, DocView:                         Document View.      (line    6)
* mode, Electric Indent:                 Indent Convenience. (line   15)
* mode, Electric Quote:                  Quotation Marks.    (line    6)
* mode, Emacs Lisp:                      Lisp Eval.          (line    6)
* mode, Enriched:                        Enriched Text.      (line    6)
* mode, Flyspell:                        Spelling.           (line  151)
* mode, Follow:                          Follow Mode.        (line    6)
* mode, Font Lock:                       Font Lock.          (line    6)
* mode, Fortran:                         Fortran.            (line    6)
* mode, Glasses:                         MixedCase Words.    (line   12)
* mode, Global Auto Revert:              Reverting.          (line   35)
* mode, Goto Address:                    Goto Address mode.  (line    6)
* mode, GUD Tooltip:                     Debugger Operation. (line   30)
* mode, Hexl:                            Editing Binary Files.
                                                             (line    6)
* mode, Hideshow:                        Hideshow.           (line    6)
* mode, HTML:                            HTML Mode.          (line    6)
* mode, Java:                            C Modes.            (line    6)
* mode, LaTeX:                           TeX Mode.           (line    6)
* mode, Lisp:                            External Lisp.      (line    6)
* mode, Log Edit:                        Log Buffer.         (line   12)
* mode, Mail:                            Mail Methods.       (line    6)
* mode, major:                           Major Modes.        (line    6)
* mode, Menu Bar:                        Menu Bars.          (line    6)
* mode, Message:                         Mail Commands.      (line    6)
* mode, Minibuffer Electric Default:     Basic Minibuffer.   (line   23)
* mode, minor:                           Minor Modes.        (line    6)
* mode, Mouse Wheel:                     Mouse Commands.     (line  109)
* mode, MSB:                             Buffer Menus.       (line   22)
* mode, nXML:                            HTML Mode.          (line   69)
* mode, Objective C:                     C Modes.            (line    6)
* mode, Occur:                           Other Repeating Search.
                                                             (line   42)
* mode, Occur Edit:                      Other Repeating Search.
                                                             (line   70)
* mode, Org:                             Org Mode.           (line    6)
* mode, Outline:                         Outline Mode.       (line    6)
* mode, Overwrite:                       Minor Modes.        (line   88)
* mode, Paragraph-Indent Text:           Text Mode.          (line   27)
* mode, Pike:                            C Modes.            (line    6)
* mode, Scheme:                          External Lisp.      (line   34)
* mode, Scroll Bar:                      Scroll Bars.        (line    6)
* mode, Scroll-all:                      Window Convenience. (line   28)
* mode, Semantic:                        Semantic.           (line   19)
* mode, SGML:                            HTML Mode.          (line    6)
* mode, Shell:                           Shell Mode.         (line    6)
* mode, SliTeX:                          TeX Mode.           (line    6)
* mode, tar:                             File Archives.      (line    6)
* mode, Term:                            Term Mode.          (line    6)
* mode, TeX:                             TeX Mode.           (line    6)
* mode, Text:                            Text Mode.          (line    6)
* mode, Thumbs:                          File Conveniences.  (line   60)
* mode, Tool Bar:                        Tool Bars.          (line    6)
* mode, Transient Mark:                  Disabled Transient Mark.
                                                             (line    6)
* mode, View:                            View Mode.          (line    6)
* mode, Visual Line:                     Visual Line Mode.   (line   12)
* mode, Whitespace:                      Useless Whitespace. (line   37)
* mode, Window Divider:                  Window Dividers.    (line    6)
* mode, Winner:                          Window Convenience. (line    6)
* mode, XML:                             HTML Mode.          (line   69)
* mode-line face:                        Standard Faces.     (line   84)
* mode-line-buffer-id face:              Standard Faces.     (line  100)
* mode-line-highlight face:              Standard Faces.     (line   95)
* mode-line-inactive face:               Standard Faces.     (line   90)
* modes for editing programs:            Hooks.              (line   69)
* modes for programming languages:       Program Modes.      (line    6)
* modification dates:                    Time Stamps.        (line    6)
* modified (buffer):                     Visiting.           (line   49)
* modifier keys:                         User Input.         (line   18)
* modifier keys (macOS):                 Mac / GNUstep Basics.
                                                             (line    6)
* modifier keys, and key rebinding:      Modifier Keys.      (line    6)
* Modula2 mode:                          Program Modes.      (line   14)
* module verification:                   Initial Options.    (line  139)
* moon, phases of:                       Lunar Phases.       (line    6)
* Morse code:                            Amusements.         (line   43)
* Motif Widget X Resources:              Motif Resources.    (line    6)
* mouse avoidance:                       Mouse Avoidance.    (line    6)
* mouse button events:                   Mouse Buttons.      (line    6)
* mouse buttons (what they do):          Mouse Commands.     (line    6)
* mouse on mode line:                    Mode Line Mouse.    (line    6)
* mouse pointer:                         Display Custom.     (line   81)
* mouse pointer color, command-line argument: Colors X.      (line   29)
* mouse support:                         Text-Only Mouse.    (line    6)
* mouse support under MS-DOS:            MS-DOS Mouse.       (line    6)
* mouse wheel:                           Mouse Commands.     (line  109)
* Mouse Wheel minor mode:                Mouse Commands.     (line  109)
* mouse, and MS-Windows:                 Windows Mouse.      (line    6)
* mouse, dragging:                       Mouse Commands.     (line   40)
* mouse, selecting text using:           Mouse Commands.     (line    6)
* mouse, set number of buttons:          MS-DOS Mouse.       (line   19)
* move to beginning or end of function:  Moving by Defuns.   (line   17)
* movemail:                              Remote Mailboxes.   (line    6)
* movemail program:                      Movemail.           (line    6)
* movement:                              Moving Point.       (line    6)
* moving files (in Dired):               Operating on Files. (line   54)
* moving inside the calendar:            Calendar Motion.    (line    6)
* moving point:                          Moving Point.       (line    6)
* moving text:                           Yanking.            (line    6)
* moving the cursor:                     Moving Point.       (line    6)
* MS-DOS end-of-line conversion:         Coding Systems.     (line   58)
* MS-DOS peculiarities:                  MS-DOS.             (line    6)
* MS-Windows codepages:                  MS-DOS and MULE.    (line   83)
* MS-Windows keyboard shortcuts:         Windows Keyboard.   (line    9)
* MS-Windows, and primary selection:     Primary Selection.  (line   32)
* MS-Windows, Emacs peculiarities:       Microsoft Windows.  (line    6)
* MSB mode:                              Buffer Menus.       (line   22)
* MULE:                                  Glossary.           (line  973)
* multibyte characters:                  International.      (line    6)
* multiple displays:                     Multiple Displays.  (line    6)
* multiple source file search and replace: Identifier Search.
                                                             (line    6)
* multiple views of outline:             Outline Views.      (line    6)
* multiple windows in Emacs:             Windows.            (line    6)
* multiple-buffer isearch:               Other Repeating Search.
                                                             (line   14)
* multiple-file isearch:                 Other Repeating Search.
                                                             (line   26)
* Multipurpose Internet Mail Extensions: Mail Misc.          (line    6)
* Multithreaded debugging in GDB:        Multithreaded Debugging.
                                                             (line    6)
* names of backup files:                 Backup Names.       (line    6)
* narrowing:                             Narrowing.          (line    6)
* narrowing, and line number display:    Optional Mode Line. (line   32)
* net use, and printing on MS-Windows:   Windows Printing.   (line   38)
* network security manager:              Network Security.   (line    6)
* networked printers (MS-Windows):       Windows Printing.   (line   38)
* newline:                               Inserting Text.     (line   12)
* newlines, hard and soft:               Hard and Soft Newlines.
                                                             (line    6)
* newsreader:                            Gnus.               (line    6)
* Next Error Follow mode:                Compilation Mode.   (line  117)
* NFS and quitting:                      Quitting.           (line   55)
* nil:                                   Glossary.           (line 1004)
* no-conversion, coding system:          Coding Systems.     (line   98)
* nobreak-space face:                    Text Display.       (line   31)
* non-ASCII characters in .emacs:        Init Non-ASCII.     (line    6)
* non-ASCII keys, binding:               Init Non-ASCII.     (line    6)
* non-breaking hyphen:                   Text Display.       (line   31)
* non-breaking space:                    Text Display.       (line   31)
* non-greedy regexp matching:            Regexps.            (line   66)
* non-integral number of lines in a window: Optional Mode Line.
                                                             (line   78)
* non-selected windows, mode line appearance: Optional Mode Line.
                                                             (line   83)
* Non-stop debugging in GDB:             Multithreaded Debugging.
                                                             (line    6)
* non-strict locking (RCS):              RCS and SCCS.       (line    6)
* nonincremental search:                 Nonincremental Search.
                                                             (line    6)
* normal hook:                           Hooks.              (line   13)
* nroff:                                 Nroff Mode.         (line    6)
* NSA:                                   Mail Amusements.    (line    6)
* NSM:                                   Network Security.   (line    6)
* number lines in a buffer:              Display Custom.     (line    9)
* numeric arguments:                     Arguments.          (line    6)
* nXML mode:                             HTML Mode.          (line   69)
* Objective C mode:                      C Modes.            (line    6)
* obsolete command:                      M-x.                (line   37)
* Occur Edit mode:                       Other Repeating Search.
                                                             (line   70)
* Occur mode:                            Other Repeating Search.
                                                             (line   42)
* octal escapes:                         Text Display.       (line   24)
* Octave mode:                           Program Modes.      (line   14)
* omer count:                            Sexp Diary Entries. (line  159)
* OPascal mode:                          Program Modes.      (line   14)
* open file:                             Visiting.           (line    6)
* open-parenthesis in leftmost column:   Left Margin Paren.  (line    6)
* OpenDocument file:                     Document View.      (line    6)
* operating on files in Dired:           Operating on Files. (line    6)
* operations on a marked region:         Using Region.       (line    6)
* options (command line):                Emacs Invocation.   (line    6)
* Org agenda:                            Org Organizer.      (line    6)
* Org exporting:                         Org Authoring.      (line    6)
* Org mode:                              Org Mode.           (line    6)
* organizer:                             Org Mode.           (line    6)
* Oriya:                                 Language Environments.
                                                             (line   37)
* out of memory:                         Memory Full.        (line    6)
* outer border width, command-line argument: Borders X.      (line   21)
* Outline mode:                          Outline Mode.       (line    6)
* outline with multiple views:           Outline Views.      (line    6)
* overlays at character position:        Editing Format Info.
                                                             (line   20)
* override character terminal color support: Colors X.       (line   37)
* overscrolling:                         Scroll Bars.        (line   43)
* overwrapped search:                    Repeat Isearch.     (line   34)
* Overwrite mode:                        Minor Modes.        (line   88)
* Package:                               Packages.           (line    6)
* Package archive:                       Packages.           (line    6)
* package directory:                     Package Files.      (line    6)
* package file:                          Package Files.      (line    6)
* package menu:                          Package Menu.       (line    6)
* package requirements:                  Package Installation.
                                                             (line   12)
* package security:                      Package Installation.
                                                             (line   30)
* package signing:                       Package Installation.
                                                             (line   30)
* pages:                                 Pages.              (line    6)
* paging in Term mode:                   Term Mode.          (line   27)
* paragraph, base direction:             Bidirectional Editing.
                                                             (line   33)
* Paragraph-Indent Text mode:            Text Mode.          (line   27)
* paragraphs:                            Paragraphs.         (line    6)
* parasha, weekly:                       Sexp Diary Entries. (line  159)
* parentheses, displaying matches:       Matching.           (line    6)
* parentheses, moving across:            Moving by Parens.   (line    6)
* parenthesis in column zero and fontification: Font Lock.   (line   55)
* parenthetical groupings:               Moving by Parens.   (line    6)
* partial completion:                    Completion Styles.  (line   29)
* partial-completion, completion style:  Completion Styles.  (line   29)
* paste:                                 Cut and Paste.      (line    6)
* pasting:                               Yanking.            (line    6)
* patches, applying:                     Diff Mode.          (line   66)
* patches, editing:                      Diff Mode.          (line    6)
* patches, sending:                      Sending Patches.    (line    6)
* PCL-CVS:                               VC Directory Mode.  (line   28)
* PDB:                                   Debuggers.          (line    6)
* PDF file:                              Document View.      (line    6)
* per-buffer variables:                  Locals.             (line   28)
* per-directory local variables:         Directory Variables.
                                                             (line    6)
* Perl mode:                             Program Modes.      (line   14)
* Perldb:                                Debuggers.          (line    6)
* Persian:                               Language Environments.
                                                             (line   37)
* Persian calendar:                      Calendar Systems.   (line   46)
* phases of the moon:                    Lunar Phases.       (line    6)
* phrase, highlighting:                  Highlight Interactively.
                                                             (line   64)
* Picture mode and rectangles:           Rectangles in Picture.
                                                             (line    6)
* pictures:                              Picture Mode.       (line    6)
* Pike mode:                             C Modes.            (line    6)
* pinning Emacs to Windows task bar:     Windows Startup.    (line   20)
* planner:                               Org Mode.           (line    6)
* point:                                 Point.              (line    6)
* point location:                        Position Info.      (line   37)
* point location, on MS-DOS:             Text and Binary.    (line   19)
* Polish:                                Language Environments.
                                                             (line   37)
* Pong game:                             Amusements.         (line   48)
* pop-up windows:                        Temporary Displays. (line    6)
* POP3 mailboxes:                        Remote Mailboxes.   (line   14)
* position and size of Emacs frame:      Window Size X.      (line    6)
* PostScript file:                       Document View.      (line    6)
* PostScript mode:                       Program Modes.      (line   14)
* prefix argument commands, during incremental search: Not Exiting Isearch.
                                                             (line   22)
* prefix arguments:                      Arguments.          (line    6)
* prefix key:                            Keys.               (line   11)
* preprocessor highlighting:             Other C Commands.   (line   57)
* pretty-printer:                        Program Indent.     (line   23)
* prevent commands from exiting incremental search: Not Exiting Isearch.
                                                             (line   53)
* preview of registers:                  Registers.          (line   26)
* primary Rmail file:                    Rmail Basics.       (line    6)
* primary selection:                     Primary Selection.  (line    6)
* primary selection, when active region changes: Setting Mark.
                                                             (line   80)
* printing:                              Printing.           (line    6)
* printing character:                    Text Display.       (line    6)
* printing files (in Dired):             Operating on Files. (line   99)
* Printing package:                      Printing Package.   (line    6)
* printing under MS-DOS:                 MS-DOS Processes.   (line   30)
* Prog mode:                             Hooks.              (line   69)
* program building:                      Building.           (line    6)
* program editing:                       Programs.           (line    6)
* Prolog mode:                           Program Modes.      (line   14)
* prompt:                                Basic Minibuffer.   (line    6)
* prompt, shell:                         Shell Prompts.      (line    6)
* PS file:                               Document View.      (line    6)
* Punjabi:                               Language Environments.
                                                             (line   37)
* puzzles:                               Amusements.         (line    9)
* Python mode:                           Program Modes.      (line   14)
* query replace:                         Query Replace.      (line    6)
* query-replace face:                    Query Replace.      (line   34)
* quitting:                              Quitting.           (line   29)
* quitting (in search):                  Error in Isearch.   (line   21)
* quitting Emacs:                        Exiting.            (line    6)
* quitting on MS-DOS:                    MS-DOS Keyboard.    (line   12)
* Quotation marks:                       Quotation Marks.    (line    6)
* quoting:                               Inserting Text.     (line   30)
* quoting file names:                    Quoted File Names.  (line    6)
* rar:                                   File Archives.      (line   45)
* raw-text, coding system:               Coding Systems.     (line   90)
* RCS:                                   Version Control Systems.
                                                             (line   19)
* read-only buffer:                      Misc Buffer.        (line   16)
* read-only text, killing:               Kill Options.       (line    6)
* reading mail:                          Rmail.              (line    6)
* rebinding keys, permanently:           Init Rebinding.     (line    6)
* rebinding major mode keys:             Init Rebinding.     (line    6)
* rebinding mouse buttons:               Mouse Buttons.      (line    6)
* rebinding non-ASCII keys:              Init Non-ASCII.     (line    6)
* recovering crashed session:            After a Crash.      (line    6)
* rectangle:                             Rectangles.         (line    6)
* rectangle highlighting:                CUA Bindings.       (line   31)
* rectangles and Picture mode:           Rectangles in Picture.
                                                             (line    6)
* recursive copying:                     Operating on Files. (line   41)
* recursive deletion:                    Dired Deletion.     (line   55)
* recursive editing level:               Recursive Edit.     (line    6)
* recursive editing, cannot exit:        Stuck Recursive.    (line    6)
* recycle bin:                           Misc File Ops.      (line   15)
* redefining keys, this session:         Rebinding.          (line    6)
* redo:                                  Undo.               (line   28)
* refreshing displayed files:            Dired Updating.     (line    6)
* regexp:                                Regexps.            (line    6)
* regexp search:                         Regexp Search.      (line    6)
* region:                                Mark.               (line    6)
* region highlighting:                   Disabled Transient Mark.
                                                             (line    6)
* registered file:                       VCS Concepts.       (line    6)
* registers:                             Registers.          (line    6)
* registry, setting environment variables (MS-Windows): MS-Windows Registry.
                                                             (line    6)
* registry, setting resources (MS-Windows): Resources.       (line   14)
* regular expression:                    Regexps.            (line    6)
* related files:                         Other C Commands.   (line   95)
* reload files:                          Saving Emacs Sessions.
                                                             (line    6)
* remember editing session:              Saving Emacs Sessions.
                                                             (line    6)
* remote file access:                    Remote Files.       (line    6)
* remote host:                           Remote Host.        (line    6)
* remote host, debugging on:             Starting GUD.       (line   52)
* remote repositories (CVS):             CVS Options.        (line   10)
* remove indentation:                    Indentation Commands.
                                                             (line   52)
* renaming files:                        Copying and Naming. (line   31)
* renaming files (in Dired):             Operating on Files. (line   54)
* renaming version-controlled files:     VC Delete/Rename.   (line    6)
* repeating a command:                   Repeating.          (line    6)
* replacement:                           Replace.            (line    6)
* reply to a message:                    Rmail Reply.        (line   28)
* report an Emacs bug, how to:           Understanding Bug Reporting.
                                                             (line    6)
* repository:                            VCS Concepts.       (line    6)
* reread a file:                         Reverting.          (line    6)
* reserved key bindings:                 Key Bindings.       (line   11)
* resize window:                         Change Window.      (line   45)
* resizing minibuffer:                   Minibuffer Edit.    (line   26)
* resizing windows:                      Change Window.      (line   45)
* resolving conflicts:                   Merging.            (line   31)
* resource files for GTK+:               GTK resources.      (line    6)
* resource name, command-line argument:  Resources.          (line   60)
* resource values, command-line argument: Resources.         (line   77)
* resources:                             Resources.          (line    6)
* restore session:                       Saving Emacs Sessions.
                                                             (line    6)
* restriction:                           Narrowing.          (line    6)
* retrying a failed message:             Rmail Reply.        (line   58)
* reverse order in POP3 inboxes:         Remote Mailboxes.   (line   55)
* reverse video, command-line argument:  Colors X.           (line   34)
* revision:                              VCS Concepts.       (line   23)
* revision ID:                           VCS Concepts.       (line   23)
* revision ID in version control:        Advanced C-x v v.   (line    6)
* revision tag:                          Revision Tags.      (line    6)
* RGB triplet:                           Colors.             (line    6)
* right-to-left text:                    Bidirectional Editing.
                                                             (line    6)
* risky variable:                        Safe File Variables.
                                                             (line   27)
* RLM:                                   Bidirectional Editing.
                                                             (line   53)
* Rlogin:                                Remote Host.        (line    6)
* Rmail:                                 Rmail.              (line    6)
* Rmail file sorting:                    Rmail Sorting.      (line    6)
* Romanian:                              Language Environments.
                                                             (line   37)
* rosh hodesh:                           Sexp Diary Entries. (line  159)
* rot13 code:                            Rmail Rot13.        (line    6)
* Ruby mode:                             Program Modes.      (line   14)
* runemacs.exe:                          Windows Startup.    (line    8)
* running a hook:                        Hooks.              (line    6)
* running Lisp functions:                Building.           (line    6)
* Russian:                               Language Environments.
                                                             (line   38)
* saved echo area messages:              Echo Area.          (line   32)
* saving a setting:                      Changing a Variable.
                                                             (line   93)
* saving file name in a register:        File Registers.     (line    6)
* saving files:                          Visiting.           (line   23)
* saving keyboard macro in a register:   Keyboard Macro Registers.
                                                             (line    6)
* saving keyboard macros:                Save Keyboard Macro.
                                                             (line   15)
* saving number in a register:           Number Registers.   (line    6)
* saving position in a register:         Position Registers. (line    6)
* saving rectangle in a register:        Rectangle Registers.
                                                             (line    6)
* saving sessions:                       Saving Emacs Sessions.
                                                             (line    6)
* saving text in a register:             Text Registers.     (line    6)
* saving window configuration in a register: Configuration Registers.
                                                             (line    6)
* SCCS:                                  Version Control Systems.
                                                             (line    9)
* Schemeモード:                          External Lisp.      (line   34)
* screen:                                Screen.             (line    6)
* screen display, wrong:                 Screen Garbled.     (line    6)
* screen reader software, MS-Windows:    Windows Misc.       (line    9)
* script mode:                           Initial Options.    (line   68)
* scroll bar:                            Table of Resources. (line  127)
* Scroll Bar mode:                       Scroll Bars.        (line    6)
* Scroll-all mode:                       Window Convenience. (line   28)
* scroll-bar face:                       Scroll Bars.        (line   52)
* scroll-command property:               Scrolling.          (line   60)
* scrollbar width:                       Table of Resources. (line  131)
* scrolling:                             Scrolling.          (line    6)
* scrolling commands, during incremental search: Not Exiting Isearch.
                                                             (line   37)
* scrolling in the calendar:             Scroll Calendar.    (line    6)
* scrolling windows together:            Window Convenience. (line   28)
* SDB:                                   Debuggers.          (line    6)
* search and replace in multiple files (in Dired): Operating on Files.
                                                             (line  159)
* search and replace in multiple source files: Identifier Search.
                                                             (line    6)
* search customizations:                 Search Customizations.
                                                             (line    6)
* search display on slow terminals:      Search Customizations.
                                                             (line   54)
* search for a regular expression:       Regexp Search.      (line    6)
* search mode, default:                  Search Customizations.
                                                             (line    9)
* search multiple files (in Dired):      Operating on Files. (line  144)
* search ring:                           Repeat Isearch.     (line   41)
* search, overwrapped:                   Repeat Isearch.     (line   34)
* search, wrapping around:               Repeat Isearch.     (line   34)
* search-and-replace commands:           Replace.            (line    6)
* searching:                             Search.             (line    6)
* searching Dired buffers:               Dired Navigation.   (line   21)
* searching documentation efficiently:   Help.               (line   18)
* searching in Rmail:                    Rmail Motion.       (line   58)
* searching multiple files via Dired:    Misc Dired Features.
                                                             (line   10)
* secondary selection:                   Secondary Selection.
                                                             (line    6)
* secondary-selection face:              Secondary Selection.
                                                             (line   11)
* sections of manual pages:              Man Page.           (line   22)
* security:                              Host Security.      (line    6)
* security, when displaying enriched text: Enriched Properties.
                                                             (line   15)
* select all:                            Marking Objects.    (line   52)
* selected buffer:                       Buffers.            (line   24)
* selected window:                       Basic Window.       (line   12)
* selecting buffers in other windows:    Pop Up Window.      (line    6)
* selection, primary:                    Primary Selection.  (line    6)
* selective display:                     Selective Display.  (line    6)
* selective undo:                        Undo.               (line   52)
* self-documentation:                    Help.               (line    6)
* Semantic mode:                         Semantic.           (line   19)
* Semantic package:                      Semantic.           (line    6)
* sending mail:                          Sending Mail.       (line    6)
* sending patches for GNU Emacs:         Sending Patches.    (line    6)
* Sendmail:                              Mail Sending.       (line   29)
* sentences:                             Sentences.          (line    6)
* server file:                           TCP Emacs server.   (line   33)
* server, using Emacs as:                Emacs Server.       (line    6)
* server-side fonts:                     Fonts.              (line  191)
* set buffer face height:                Text Scale.         (line   24)
* sets of files:                         Filesets.           (line    6)
* setting a mark:                        Mark.               (line    6)
* setting variables:                     Examining.          (line    6)
* settings:                              Easy Customization. (line    6)
* settings, how to save:                 Changing a Variable.
                                                             (line   93)
* sexp:                                  Expressions.        (line    6)
* sexp diary entries:                    Sexp Diary Entries. (line    6)
* SGML mode:                             HTML Mode.          (line    6)
* shadow cluster:                        File Shadowing.     (line   19)
* shadow face:                           Standard Faces.     (line   32)
* shadow files:                          File Shadowing.     (line    6)
* shell commands:                        Shell.              (line    6)
* shell commands, Dired:                 Shell Commands in Dired.
                                                             (line    6)
* shell completion:                      Shell Mode.         (line   20)
* SHELL environment variable:            Interactive Shell.  (line   37)
* Shell mode:                            Shell Mode.         (line    6)
* shell scripts, and local file variables: Specifying File Variables.
                                                             (line   34)
* Shell-script mode:                     Program Modes.      (line   14)
* shelves in version control:            VC Directory Commands.
                                                             (line  127)
* shift-selection:                       Shift Selection.    (line    6)
* Show Paren mode:                       Matching.           (line   33)
* showing hidden subdirectories (Dired): Hiding Subdirectories.
                                                             (line    6)
* shy group, in regexp:                  Regexp Backslash.   (line   47)
* signing files (in Dired):              Operating on Files. (line  127)
* Simula mode:                           Program Modes.      (line   14)
* simulation of middle mouse button:     Windows Mouse.      (line    9)
* simultaneous editing:                  Interlocking.       (line    6)
* Sinhala:                               Language Environments.
                                                             (line   38)
* site init file:                        Init File.          (line   28)
* site-lisp directories:                 Init File.          (line   38)
* site-lisp files, not loading:          Initial Options.    (line   96)
* site-start.el file, not loading:       Initial Options.    (line   91)
* site-start.el, the site startup file:  Init File.          (line   28)
* size of file, warning when visiting:   Visiting.           (line   62)
* size of minibuffer:                    Minibuffer Edit.    (line   26)
* skeletons:                             Text.               (line   36)
* slashes repeated in file name:         Minibuffer File.    (line   34)
* SliTeX mode:                           TeX Mode.           (line    6)
* Slovak:                                Language Environments.
                                                             (line   38)
* Slovenian:                             Language Environments.
                                                             (line   38)
* Smerge mode:                           Comparing Files.    (line   48)
* SMTP:                                  Mail Sending.       (line   29)
* Snake:                                 Amusements.         (line   48)
* socket activation, systemd, Emacs:     Emacs Server.       (line   42)
* soft hyphen:                           Text Display.       (line   31)
* soft newline:                          Hard and Soft Newlines.
                                                             (line    6)
* solitaire:                             Amusements.         (line   51)
* sorting:                               Sorting.            (line    6)
* sorting diary entries:                 Fancy Diary Display.
                                                             (line    8)
* sorting Dired buffer:                  Dired Updating.     (line   68)
* sorting Rmail file:                    Rmail Sorting.      (line    6)
* Spanish:                               Language Environments.
                                                             (line   38)
* specific version control system:       Advanced C-x v v.   (line   11)
* specify default font from the command line: Font X.        (line   11)
* specify end-of-line conversion:        Text Coding.        (line   37)
* specifying fullscreen for Emacs frame: Window Size X.      (line    6)
* speedbar:                              Speedbar.           (line    6)
* spell-checking the active region:      Spelling.           (line   51)
* spelling, checking and correcting:     Spelling.           (line    6)
* splash screen:                         Initial Options.    (line  100)
* splitting columns:                     Two-Column.         (line    6)
* splitting table cells:                 Cell Commands.      (line   16)
* SRC:                                   Version Control Systems.
                                                             (line   51)
* src:                                   Version Control Systems.
                                                             (line   51)
* SSL:                                   Network Security.   (line    6)
* standard colors on a character terminal: Colors X.         (line   37)
* standard faces:                        Standard Faces.     (line    6)
* standard fontset:                      Defining Fontsets.  (line    6)
* start directory, MS-Windows:           Windows Startup.    (line    8)
* start iconified, command-line argument: Icons X.           (line    8)
* starting Emacs:                        Entering Emacs.     (line    6)
* starting Emacs on MS-Windows:          Windows Startup.    (line    6)
* STARTTLS:                              Network Security.   (line    6)
* startup (command line arguments):      Emacs Invocation.   (line    6)
* startup (init file):                   Init File.          (line    6)
* startup fontset:                       Defining Fontsets.  (line   21)
* startup message:                       Initial Options.    (line  100)
* startup screen:                        Entering Emacs.     (line   12)
* stashes in version control:            VC Directory Commands.
                                                             (line  127)
* string substitution:                   Replace.            (line    6)
* string syntax:                         Init Syntax.        (line   30)
* stuck in recursive editing:            Stuck Recursive.    (line    6)
* style (for indentation):               Custom C Indent.    (line    6)
* subdirectories in Dired:               Subdirectories in Dired.
                                                             (line    6)
* subprocesses on MS-Windows:            Windows Processes.  (line    6)
* subscribe groups:                      Gnus Group Buffer.  (line   30)
* subshell:                              Shell.              (line    6)
* substring, completion style:           Completion Styles.  (line   47)
* subtree (Outline mode):                Outline Visibility. (line   54)
* Subversion:                            Version Control Systems.
                                                             (line   32)
* Subword mode:                          MixedCase Words.    (line   23)
* summary (Rmail):                       Rmail Summary.      (line    6)
* summing time intervals:                Time Intervals.     (line    6)
* sunrise and sunset:                    Sunrise/Sunset.     (line    6)
* Super (under MS-DOS):                  MS-DOS Keyboard.    (line   21)
* suspending:                            Exiting.            (line   47)
* suspicious constructions in C, C++:    Other C Commands.   (line   72)
* SVN:                                   Version Control Systems.
                                                             (line   32)
* Swedish:                               Language Environments.
                                                             (line   38)
* switch buffers:                        Select Buffer.      (line    6)
* switches (command line):               Emacs Invocation.   (line    6)
* symbol search:                         Symbol Search.      (line    6)
* symbol, highlighting:                  Highlight Interactively.
                                                             (line   71)
* symbolic links (and version control):  General VC Options. (line   11)
* symbolic links (creation in Dired):    Operating on Files. (line   70)
* symbolic links (creation):             Copying and Naming. (line   49)
* symbolic links (visiting):             File Aliases.       (line    6)
* synchronizing windows:                 Follow Mode.        (line    6)
* synchronous X mode:                    Table of Resources. (line  151)
* syntax highlighting and coloring:      Font Lock.          (line    6)
* syntax of regexps:                     Regexps.            (line    6)
* system-wide packages:                  Package Files.      (line   20)
* systemd unit file:                     Emacs Server.       (line   33)
* t:                                     Glossary.           (line 1004)
* tab stops:                             Tab Stops.          (line    6)
* table creation:                        Table Creation.     (line    6)
* table dimensions:                      Table Misc.         (line    6)
* table for HTML and LaTeX:              Table Misc.         (line   21)
* table mode:                            Text Based Tables.  (line    6)
* table recognition:                     Table Recognition.  (line    6)
* table to text:                         Table Conversion.   (line    6)
* tabs:                                  Indentation.        (line    6)
* tags and tag tables:                   Tags Tables.        (line    6)
* tags for version control:              Revision Tags.      (line    6)
* tags, C++:                             Tags Tables.        (line   27)
* tags-based completion:                 Symbol Completion.  (line   15)
* TaiViet:                               Language Environments.
                                                             (line   38)
* Tajik:                                 Language Environments.
                                                             (line   39)
* Tamil:                                 Language Environments.
                                                             (line   39)
* Tar mode:                              File Archives.      (line    6)
* Tcl mode:                              Program Modes.      (line   14)
* TCP Emacs server:                      TCP Emacs server.   (line    6)
* Telnet:                                Remote Host.        (line    6)
* Telugu:                                Language Environments.
                                                             (line   39)
* templates:                             Text.               (line   36)
* temporary windows:                     Temporary Displays. (line    6)
* Term mode:                             Term Mode.          (line    6)
* terminal emulators, mouse support:     Text-Only Mouse.    (line    6)
* terminal, serial:                      Serial Terminal.    (line    6)
* termscript file:                       Checklist.          (line  112)
* Tetris:                                Amusements.         (line   48)
* TeX encoding:                          TeX Misc.           (line   12)
* TeX mode:                              TeX Mode.           (line    6)
* TEXEDIT environment variable:          Emacs Server.       (line   66)
* TEXINPUTS environment variable:        TeX Print.          (line   45)
* text:                                  Text.               (line    6)
* text and binary files on MS-DOS/MS-Windows: Text and Binary.
                                                             (line    6)
* text buttons:                          Mouse References.   (line    6)
* text colors, from command line:        Colors X.           (line    6)
* text cursor:                           Cursor Display.     (line    6)
* Text mode:                             Text Mode.          (line    6)
* text properties at point:              International Chars.
                                                             (line   59)
* text properties of characters:         Editing Format Info.
                                                             (line   20)
* text terminal:                         Non-Window Terminals.
                                                             (line    6)
* text to table:                         Table Conversion.   (line    6)
* text-based tables:                     Text Based Tables.  (line    6)
* text-based tables, splitting cells:    Cell Commands.      (line   16)
* text/enriched MIME format:             Enriched Text.      (line    6)
* Thai:                                  Language Environments.
                                                             (line   39)
* Tibetan:                               Language Environments.
                                                             (line   39)
* tilde (~) at end of backup file name:  Backup Names.       (line    6)
* time (on mode line):                   Optional Mode Line. (line   47)
* time intervals, summing:               Time Intervals.     (line    6)
* time stamps:                           Time Stamps.        (line    6)
* timeclock:                             Time Intervals.     (line    6)
* timelog file:                          Time Intervals.     (line   32)
* TLS:                                   Network Security.   (line    6)
* TLS encryption (Rmail):                Remote Mailboxes.   (line   60)
* TODO item:                             Org Organizer.      (line    6)
* toggling marks (in Dired):             Marks vs Flags.     (line   91)
* tool bar:                              Table of Resources. (line  158)
* Tool Bar mode:                         Tool Bars.          (line    6)
* Tool Bar position:                     Tool Bars.          (line   28)
* Tool Bar style:                        Tool Bars.          (line   21)
* tooltip help:                          Help Echo.          (line    6)
* tooltips:                              Tooltips.           (line    6)
* top level:                             Mode Line.          (line    6)
* tower of Hanoi:                        Amusements.         (line   37)
* trailing whitespace:                   Useless Whitespace. (line    6)
* trailing whitespace, in patches:       Diff Mode.          (line  124)
* trailing-whitespace face:              Useless Whitespace. (line   11)
* Tramp:                                 Remote Files.       (line    6)
* Transient Mark mode:                   Disabled Transient Mark.
                                                             (line    6)
* Transport Layer Security:              Network Security.   (line    6)
* transposition of expressions:          Expressions.        (line   46)
* trash:                                 Misc File Ops.      (line   15)
* triple clicks:                         Mouse Buttons.      (line   28)
* troubleshooting Emacs:                 Lossage.            (line    6)
* truenames of files:                    File Aliases.       (line   26)
* truncation:                            Line Truncation.    (line    6)
* TTY menu faces:                        Standard Faces.     (line  152)
* Turkish:                               Language Environments.
                                                             (line   39)
* two directories (in Dired):            Operating on Files. (line   23)
* two-column editing:                    Two-Column.         (line    6)
* types of log file:                     Types of Log File.  (line    6)
* typos, fixing:                         Fixit.              (line    6)
* Ukrainian:                             Language Environments.
                                                             (line   39)
* unbalanced parentheses and quotes:     Parentheses.        (line    6)
* uncompression:                         Compressed Files.   (line    6)
* undecided, coding system:              Coding Systems.     (line   85)
* undeletion (Rmail):                    Rmail Deletion.     (line   43)
* undigestify:                           Rmail Digest.       (line    6)
* undisplayable characters:              International Chars.
                                                             (line   19)
* undo:                                  Undo.               (line    6)
* undo limit:                            Undo.               (line   66)
* undoing window configuration changes:  Window Convenience. (line    6)
* Unibyte operation:                     Unibyte Mode.       (line    6)
* Unicode:                               International Chars.
                                                             (line   12)
* Unicode characters, inserting:         Inserting Text.     (line   58)
* Unicode Collation Algorithm (UCA), and ls-lisp.el: ls in Lisp.
                                                             (line   35)
* unique buffer names:                   Uniquify.           (line    6)
* unmarking files (in Dired):            Marks vs Flags.     (line   54)
* unsaved customizations, reminder to save: Saving Customizations.
                                                             (line   45)
* unsubscribe groups:                    Gnus Group Buffer.  (line   30)
* untranslated file system:              Text and Binary.    (line   49)
* unused lines:                          Useless Whitespace. (line   28)
* unzip archives:                        File Archives.      (line   45)
* upcase file names:                     Transforming File Names.
                                                             (line   23)
* updating Dired buffer:                 Dired Updating.     (line    6)
* URL, viewing in help:                  Help Mode.          (line   38)
* URLs:                                  Browse-URL.         (line    6)
* URLs, activating:                      Goto Address mode.  (line    6)
* Usenet news:                           Gnus.               (line    6)
* user name for remote file access:      Remote Files.       (line   35)
* user option:                           Easy Customization. (line    6)
* user options, changing:                Changing a Variable.
                                                             (line   35)
* using Nextstep services (macOS):       Mac / GNUstep Events.
                                                             (line   60)
* UTF-8:                                 Language Environments.
                                                             (line   39)
* variable:                              Variables.          (line    6)
* variable-pitch face:                   Standard Faces.     (line   29)
* variables, changing:                   Changing a Variable.
                                                             (line   35)
* VC:                                    Version Control.    (line   11)
* VC Directory buffer:                   VC Directory Mode.  (line    6)
* VC filesets:                           Basic VC Editing.   (line    6)
* VC mode line indicator:                VC Mode Line.       (line    6)
* verifying digital signatures on files (in Dired): Operating on Files.
                                                             (line  122)
* Verilog mode:                          Program Modes.      (line   14)
* version control:                       Version Control.    (line    6)
* version control log:                   Types of Log File.  (line    6)
* version control status:                VC Mode Line.       (line   10)
* VERSION_CONTROL environment variable:  Backup Names.       (line   41)
* vertical border:                       Scroll Bars.        (line   55)
* Vertical Scroll Bar:                   Scroll Bars.        (line    6)
* vertical scroll bars, command-line argument: Misc X.       (line   13)
* vertical-border face:                  Standard Faces.     (line  114)
* VHDL mode:                             Program Modes.      (line   14)
* Vietnamese:                            Language Environments.
                                                             (line   40)
* View mode:                             View Mode.          (line    6)
* viewing web pages in help:             Help Mode.          (line   38)
* views of an outline:                   Outline Views.      (line    6)
* visiting files:                        Visiting.           (line    6)
* visiting files, command-line argument: Action Arguments.   (line   12)
* Visual Line mode:                      Visual Line Mode.   (line   12)
* visual order:                          Bidirectional Editing.
                                                             (line   18)
* Watching expressions in GDB:           Watch Expressions.  (line    6)
* wdired mode:                           Wdired.             (line    6)
* Web:                                   Browse-URL.         (line    6)
* web pages, viewing in help:            Help Mode.          (line   38)
* webkit widgets:                        Embedded WebKit Widgets.
                                                             (line    6)
* weeks, which day they start on:        Move to Beginning or End.
                                                             (line   26)
* Welsh:                                 Language Environments.
                                                             (line   40)
* what constitutes an Emacs bug:         Bug Criteria.       (line    6)
* whitespace character:                  Indentation.        (line    6)
* Whitespace mode:                       Useless Whitespace. (line   37)
* whitespace, trailing:                  Useless Whitespace. (line    6)
* wide block cursor:                     Cursor Display.     (line   40)
* widening:                              Narrowing.          (line    6)
* widgets at buffer position:            Editing Format Info.
                                                             (line   20)
* width and height of Emacs frame:       Window Size X.      (line    6)
* width of the vertical scroll bar:      Scroll Bars.        (line   38)
* wildcard characters in file names:     Visiting.           (line   70)
* Windmove package:                      Window Convenience. (line   18)
* window configuration changes, undoing: Window Convenience. (line    6)
* Window Divider mode:                   Window Dividers.    (line    6)
* window manager, keys stolen by:        User Input.         (line   32)
* Windows clipboard support:             MS-DOS Mouse.       (line   30)
* windows in Emacs:                      Windows.            (line    6)
* Windows system menu:                   Windows Keyboard.   (line  104)
* windows, synchronizing:                Follow Mode.        (line    6)
* Windows-1255:                          Language Environments.
                                                             (line   40)
* Winner mode:                           Window Convenience. (line    6)
* word processing:                       Enriched Text.      (line    6)
* word search:                           Word Search.        (line    6)
* word wrap:                             Visual Line Mode.   (line    6)
* words:                                 Words.              (line    6)
* words, case conversion:                Case.               (line   20)
* work file:                             VCS Concepts.       (line   14)
* working tree:                          VCS Concepts.       (line   20)
* World Wide Web:                        Browse-URL.         (line    6)
* wrapped search:                        Repeat Isearch.     (line   34)
* wrapping:                              Continuation Lines. (line    6)
* WYSIWYG:                               Enriched Text.      (line    6)
* X cutting and pasting:                 Primary Selection.  (line    6)
* X defaults file:                       Fonts.              (line   24)
* X input methods:                       Table of Resources. (line  162)
* X Logical Font Description:            Fonts.              (line  117)
* X resources:                           Resources.          (line    6)
* X resources file:                      Fonts.              (line   24)
* X selection:                           Primary Selection.  (line    6)
* XDB:                                   Debuggers.          (line    6)
* XIM:                                   Table of Resources. (line  162)
* XLFD:                                  Fonts.              (line  117)
* XML schema:                            HTML Mode.          (line   69)
* xref:                                  Xref.               (line    6)
* xref backend:                          Xref.               (line   25)
* XREF mode:                             Xref Commands.      (line    6)
* xterm:                                 Text-Only Mouse.    (line    9)
* xwidget:                               Embedded WebKit Widgets.
                                                             (line    6)
* Xwidget-WebKit mode:                   Embedded WebKit Widgets.
                                                             (line    6)
* y or n prompt:                         Yes or No Prompts.  (line    9)
* yahrzeits:                             From Other Calendar.
                                                             (line   53)
* yahrzeits, and sexp diary entries:     Sexp Diary Entries. (line  159)
* yanking:                               Yanking.            (line    6)
* yanking previous kills:                Earlier Kills.      (line    6)
* yes or no prompt:                      Yes or No Prompts.  (line   27)
* zip:                                   File Archives.      (line   45)
* Zmacs mode:                            Disabled Transient Mark.
                                                             (line    6)
* zone:                                  Amusements.         (line   54)
* zoo:                                   File Archives.      (line   45)



Tag Table:
Node: Top1217
Node: Distrib67389
Ref: Printed Books70387
Ref: Distrib-Footnote-171194
Node: Intro71497
Node: Screen74309
Node: Point78715
Ref: Point-Footnote-180626
Node: Echo Area80864
Node: Mode Line84867
Node: Menu Bar93812
Node: User Input97036
Ref: User Input-Footnote-1100211
Node: Keys100309
Node: Commands104078
Node: Entering Emacs107361
Ref: Entering Emacs-Footnote-1112020
Node: Exiting112352
Node: Basic116605
Node: Inserting Text118005
Node: Moving Point124580
Node: Erasing133288
Node: Basic Undo136260
Node: Basic Files137996
Node: Basic Help140063
Node: Blank Lines140732
Node: Continuation Lines142589
Node: Position Info145649
Node: Arguments150455
Node: Repeating156517
Node: Minibuffer158053
Node: Basic Minibuffer159366
Node: Minibuffer File162213
Node: Minibuffer Edit166855
Node: Completion171676
Node: Completion Example173254
Node: Completion Commands175206
Node: Completion Exit178317
Node: Completion Styles181874
Node: Completion Options186118
Node: Minibuffer History189686
Node: Repetition195892
Node: Passwords199103
Node: Yes or No Prompts200954
Node: M-x203697
Node: Help208501
Node: Help Summary212387
Node: Key Help217454
Node: Name Help219199
Node: Apropos222993
Node: Help Mode228464
Node: Package Keywords231569
Node: Language Help233286
Node: Misc Help234695
Node: Help Files238529
Node: Help Echo240789
Node: Mark242203
Node: Setting Mark245796
Ref: Setting Mark-Footnote-1251636
Node: Marking Objects252048
Node: Using Region255340
Node: Mark Ring259839
Node: Global Mark Ring263070
Node: Shift Selection264275
Node: Disabled Transient Mark266776
Node: Killing270375
Node: Deletion and Killing271933
Node: Deletion274272
Node: Killing by Lines278389
Node: Other Kill Commands280520
Node: Kill Options283021
Node: Yanking284015
Node: Kill Ring286671
Node: Earlier Kills288009
Node: Appending Kills291213
Node: Cut and Paste294679
Node: Clipboard296379
Node: Primary Selection300408
Node: Secondary Selection303214
Node: Accumulating Text305495
Node: Rectangles309860
Node: CUA Bindings318234
Node: Registers322426
Node: Position Registers325499
Node: Text Registers326819
Node: Rectangle Registers330316
Node: Configuration Registers331327
Node: Number Registers332621
Node: File Registers333979
Node: Keyboard Macro Registers334916
Node: Bookmarks335749
Node: Display341050
Node: Scrolling343525
Node: Recentering350266
Node: Auto Scrolling354261
Node: Horizontal Scrolling359032
Node: Narrowing363311
Node: View Mode366974
Node: Follow Mode368155
Node: Faces369363
Node: Colors373429
Node: Standard Faces376514
Node: Text Scale386513
Node: Font Lock388400
Node: Highlight Interactively394251
Node: Fringes401419
Node: Displaying Boundaries405460
Node: Useless Whitespace407298
Node: Selective Display412492
Node: Optional Mode Line414560
Node: Text Display421590
Node: Cursor Display426656
Node: Line Truncation430684
Node: Visual Line Mode432357
Node: Display Custom435020
Node: Search443363
Node: Incremental Search445170
Node: Basic Isearch446921
Node: Repeat Isearch451411
Node: Isearch Yank455832
Node: Error in Isearch458675
Node: Special Isearch460957
Node: Not Exiting Isearch467380
Node: Isearch Minibuffer472213
Node: Nonincremental Search473959
Node: Word Search475877
Node: Symbol Search480205
Node: Regexp Search483568
Node: Regexps488789
Node: Regexp Backslash501532
Node: Regexp Example509586
Node: Lax Search510213
Node: Replace518021
Node: Unconditional Replace519356
Node: Regexp Replace520994
Node: Replacement and Lax Matches525124
Node: Query Replace528415
Node: Other Repeating Search537103
Node: Search Customizations544699
Node: Fixit549485
Node: Undo550945
Ref: Undo-Footnote-1557448
Node: Transpose557888
Node: Fixing Case561301
Node: Spelling562326
Node: Keyboard Macros572876
Node: Basic Keyboard Macro575331
Node: Keyboard Macro Ring581991
Node: Keyboard Macro Counter585661
Node: Keyboard Macro Query591612
Node: Save Keyboard Macro593885
Node: Edit Keyboard Macro597943
Node: Keyboard Macro Step-Edit599545
Node: Files603600
Node: File Names606389
Ref: File Names with $610423
Node: Visiting611951
Node: Saving624991
Node: Save Commands625909
Node: Backup633284
Node: Backup Names637741
Node: Backup Deletion641090
Node: Backup Copying643017
Node: Customize Save646260
Node: Interlocking649550
Ref: Interlocking-Footnote-1654193
Node: File Shadowing654326
Node: Time Stamps657291
Node: Reverting658556
Node: Autorevert664362
Node: Auto Reverting the Buffer Menu667020
Node: Auto Reverting Dired668145
Node: Auto Save671099
Node: Auto Save Files672592
Node: Auto Save Control676920
Node: Recover679781
Node: File Aliases682225
Node: Directories685861
Node: Comparing Files690046
Node: Diff Mode694007
Node: Copying and Naming701868
Node: Misc File Ops706109
Node: Compressed Files710341
Node: File Archives711470
Node: Remote Files715871
Node: Quoted File Names720512
Node: File Name Cache723161
Node: File Conveniences725713
Node: Filesets730504
Node: Buffers733361
Node: Select Buffer738245
Node: List Buffers744431
Node: Misc Buffer747470
Node: Kill Buffer751297
Node: Several Buffers756056
Node: Indirect Buffers764014
Node: Buffer Convenience767618
Node: Uniquify768223
Node: Icomplete771084
Node: Buffer Menus772844
Node: Windows774898
Node: Basic Window776073
Node: Split Window779035
Node: Other Window784186
Node: Pop Up Window786850
Node: Change Window789030
Node: Displaying Buffers793631
Node: Window Choice796590
Node: Temporary Displays800572
Node: Window Convenience803165
Node: Frames805195
Node: Mouse Commands809668
Node: Word and Line Mouse818414
Node: Mouse References820910
Node: Menu Mouse Clicks824310
Node: Mode Line Mouse826709
Node: Creating Frames829084
Node: Frame Commands831825
Node: Fonts835513
Node: Speedbar847673
Node: Multiple Displays852176
Node: Frame Parameters853595
Node: Scroll Bars856145
Node: Window Dividers863408
Node: Drag and Drop865023
Node: Menu Bars867808
Node: Tool Bars869150
Node: Dialog Boxes871588
Node: Tooltips873840
Node: Mouse Avoidance877283
Node: Non-Window Terminals879617
Node: Text-Only Mouse881189
Node: International882888
Node: International Chars888361
Node: Language Environments895299
Node: Input Methods902704
Node: Select Input Method910635
Node: Coding Systems916147
Ref: Coding Systems-Footnote-1923940
Node: Recognize Coding924206
Node: Specify Coding930984
Node: Output Coding932747
Node: Text Coding936584
Node: Communication Coding942290
Node: File Name Coding947061
Node: Terminal Coding950935
Node: Fontsets954196
Ref: Fontsets-Footnote-1958883
Node: Defining Fontsets959130
Node: Modifying Fontsets965645
Node: Undisplayable Characters968015
Node: Unibyte Mode969670
Node: Charsets975129
Node: Bidirectional Editing978256
Node: Modes985161
Node: Major Modes986925
Ref: Major Modes-Footnote-1993913
Node: Minor Modes994061
Node: Choosing Modes1003580
Node: Indentation1012162
Node: Indentation Commands1015244
Node: Tab Stops1019348
Node: Just Spaces1022659
Node: Indent Convenience1024985
Node: Text1026325
Node: Words1030172
Node: Sentences1034252
Node: Paragraphs1038443
Node: Pages1042917
Node: Quotation Marks1046654
Ref: Quotation Marks-Footnote-11049801
Node: Filling1050196
Node: Auto Fill1051194
Node: Fill Commands1054024
Node: Fill Prefix1059093
Node: Adaptive Fill1064553
Node: Case1068078
Node: Text Mode1071250
Node: Outline Mode1074692
Node: Outline Format1077909
Node: Outline Motion1081662
Node: Outline Visibility1083060
Ref: Outline Search1088472
Node: Outline Views1089430
Node: Foldout1090750
Node: Org Mode1096486
Node: Org Organizer1099377
Node: Org Authoring1101665
Node: TeX Mode1103405
Ref: TeX Mode-Footnote-11106747
Node: TeX Editing1106858
Node: LaTeX Editing1111466
Node: TeX Print1113547
Node: TeX Misc1124065
Node: HTML Mode1124850
Node: Nroff Mode1130208
Node: Enriched Text1132213
Node: Enriched Mode1134292
Node: Hard and Soft Newlines1137071
Node: Editing Format Info1138729
Node: Enriched Faces1140370
Node: Enriched Indentation1143020
Node: Enriched Justification1145366
Node: Enriched Properties1147167
Node: Text Based Tables1149246
Node: Table Definition1151716
Node: Table Creation1153369
Node: Table Recognition1154841
Node: Cell Commands1156750
Node: Cell Justification1159151
Node: Table Rows and Columns1161216
Node: Table Conversion1162499
Node: Table Misc1166009
Node: Two-Column1167684
Node: Programs1171566
Node: Program Modes1173584
Node: Defuns1177244
Node: Left Margin Paren1178125
Node: Moving by Defuns1181451
Node: Imenu1184810
Node: Which Function1187583
Node: Program Indent1188698
Node: Basic Indent1190186
Node: Multi-line Indent1192281
Node: Lisp Indent1195504
Node: C Indent1197298
Node: Custom C Indent1199346
Node: Parentheses1203666
Node: Expressions1205125
Ref: Expressions-Footnote-11209922
Node: Moving by Parens1210002
Node: Matching1212651
Node: Comments1218987
Node: Comment Commands1220604
Node: Multi-Line Comments1227260
Node: Options for Comments1228965
Node: Documentation1233198
Node: Info Lookup1233812
Node: Man Page1235233
Node: Lisp Doc1239566
Node: Hideshow1240874
Node: Symbol Completion1243583
Node: MixedCase Words1245751
Node: Semantic1247754
Ref: Semantic-Footnote-11251078
Node: Misc for Programs1251123
Node: C Modes1255274
Node: Motion in C1256138
Node: Electric C1258870
Node: Hungry Delete1261259
Node: Other C Commands1263011
Node: Asm Mode1268949
Node: Fortran1269772
Node: Fortran Motion1272343
Node: Fortran Indent1275231
Node: ForIndent Commands1276156
Node: ForIndent Cont1278014
Node: ForIndent Num1280993
Node: ForIndent Conv1282408
Node: ForIndent Vars1283705
Node: Fortran Comments1286409
Node: Fortran Autofill1291956
Node: Fortran Columns1293560
Node: Fortran Abbrev1297424
Node: Building1298553
Node: Compilation1300010
Node: Compilation Mode1306401
Node: Compilation Shell1314862
Node: Grep Searching1318261
Node: Flymake1324039
Node: Debuggers1325876
Node: Starting GUD1327389
Node: Debugger Operation1330075
Node: Commands of GUD1334505
Node: GUD Customization1339772
Node: GDB Graphical Interface1342989
Node: GDB User Interface Layout1345083
Node: Source Buffers1348657
Node: Breakpoints Buffer1351191
Node: Threads Buffer1353022
Node: Stack Buffer1355933
Node: Other GDB Buffers1357057
Node: Watch Expressions1359997
Node: Multithreaded Debugging1363479
Node: Executing Lisp1367811
Node: Lisp Libraries1369703
Node: Lisp Eval1376134
Node: Lisp Interaction1381319
Node: External Lisp1383265
Node: Maintaining1386172
Node: Version Control1387959
Node: Introduction to VC1390854
Node: Why Version Control?1392615
Node: Version Control Systems1393655
Node: VCS Concepts1397942
Node: VCS Merging1400640
Node: VCS Changesets1404379
Node: VCS Repositories1405678
Node: Types of Log File1407188
Node: VC Mode Line1410092
Node: Basic VC Editing1413283
Node: VC With A Merging VCS1416501
Node: VC With A Locking VCS1420465
Node: Advanced C-x v v1422881
Node: Log Buffer1424946
Node: Registering1429299
Node: Old Revisions1432476
Node: VC Change Log1441738
Node: VC Undo1449111
Node: VC Ignore1450660
Node: VC Directory Mode1451853
Node: VC Directory Buffer1453916
Node: VC Directory Commands1457287
Node: Branches1464333
Node: Switching Branches1465874
Node: Pulling / Pushing1468803
Node: Merging1473302
Node: Creating Branches1476186
Node: Miscellaneous VC1478625
Node: Change Logs and VC1479345
Node: VC Delete/Rename1482341
Node: Revision Tags1484863
Node: Version Headers1489275
Node: Customizing VC1491929
Node: General VC Options1493295
Node: RCS and SCCS1495186
Node: CVS Options1497368
Node: Change Log1501175
Node: Change Log Commands1502221
Node: Format of ChangeLog1506396
Node: Xref1508404
Node: Find Identifiers1513273
Node: Looking Up Identifiers1514307
Node: Xref Commands1519185
Node: Identifier Search1520850
Node: List Identifiers1526608
Node: Tags Tables1529067
Ref: Tags Tables-Footnote-11531624
Node: Tag Syntax1531925
Node: Create Tags Table1540495
Node: Etags Regexps1547498
Node: Select Tags Table1554428
Node: EDE1556774
Node: Emerge1560366
Node: Overview of Emerge1561683
Node: Submodes of Emerge1566250
Node: State of Difference1568737
Node: Merge Commands1572062
Node: Exiting Emerge1575650
Node: Combining in Emerge1576789
Node: Fine Points of Emerge1577831
Node: Abbrevs1579180
Node: Abbrev Concepts1581050
Node: Defining Abbrevs1583073
Node: Expanding Abbrevs1586634
Node: Editing Abbrevs1591337
Node: Saving Abbrevs1594252
Node: Dynamic Abbrevs1597459
Node: Dabbrev Customization1601601
Node: Dired1605579
Node: Dired Enter1609090
Node: Dired Navigation1613112
Node: Dired Deletion1615415
Node: Flagging Many Files1620889
Node: Dired Visiting1624626
Node: Marks vs Flags1627005
Node: Operating on Files1636384
Node: Shell Commands in Dired1646767
Node: Transforming File Names1651422
Node: Comparison in Dired1655943
Node: Subdirectories in Dired1657383
Node: Subdir Switches1659906
Node: Subdirectory Motion1663136
Node: Hiding Subdirectories1664958
Node: Dired Updating1666824
Node: Dired and Find1671355
Node: Wdired1674634
Node: Image-Dired1677103
Node: Misc Dired Features1682348
Node: Calendar/Diary1688088
Node: Calendar Motion1690475
Node: Calendar Unit Motion1691492
Node: Move to Beginning or End1694390
Node: Specified Dates1695959
Node: Scroll Calendar1697598
Node: Counting Days1699927
Node: General Calendar1700552
Node: Writing Calendar Files1702736
Node: Holidays1708204
Node: Sunrise/Sunset1712332
Node: Lunar Phases1716361
Node: Other Calendars1717880
Node: Calendar Systems1719222
Node: To Other Calendar1723856
Node: From Other Calendar1726839
Node: Diary1730075
Node: Format of Diary File1731549
Node: Displaying the Diary1734288
Node: Date Formats1739506
Node: Adding to Diary1743138
Node: Special Diary Entries1746325
Node: Appointments1752612
Node: Importing Diary1757035
Node: Daylight Saving1759661
Node: Time Intervals1762724
Node: Advanced Calendar/Diary Usage1765218
Node: Calendar Customizing1766505
Node: Holiday Customizing1769543
Node: Mayan Calendar1776275
Node: Date Display Format1780145
Node: Time Display Format1781361
Node: Diary Customizing1782668
Node: Non-Gregorian Diary1787710
Node: Diary Display1792254
Node: Fancy Diary Display1797333
Node: Sexp Diary Entries1799971
Node: Sending Mail1809944
Node: Mail Format1813097
Node: Mail Headers1815009
Node: Mail Aliases1821571
Node: Mail Commands1824389
Node: Mail Sending1825545
Node: Header Editing1830040
Node: Citing Mail1832738
Node: Mail Misc1834895
Node: Mail Signature1838907
Node: Mail Amusements1840780
Ref: Mail Amusements-Footnote-11842427
Node: Mail Methods1842468
Node: Rmail1844451
Node: Rmail Basics1847087
Node: Rmail Scrolling1850637
Node: Rmail Motion1852567
Node: Rmail Deletion1857888
Node: Rmail Inbox1862734
Node: Rmail Files1868313
Node: Rmail Output1872335
Node: Rmail Labels1878529
Node: Rmail Attributes1881935
Node: Rmail Reply1884449
Node: Rmail Summary1893075
Node: Rmail Make Summary1894455
Node: Rmail Summary Edit1898174
Node: Rmail Sorting1905045
Node: Rmail Display1907995
Ref: Rmail Display-Footnote-11914111
Node: Rmail Coding1914290
Node: Rmail Editing1917520
Node: Rmail Digest1919399
Node: Rmail Rot131921107
Node: Movemail1922182
Node: Remote Mailboxes1927657
Node: Other Mailbox Formats1932137
Node: Gnus1932896
Node: Buffers of Gnus1933909
Node: Gnus Startup1935949
Node: Gnus Group Buffer1938753
Node: Gnus Summary Buffer1940972
Node: Host Security1942963
Node: Network Security1944282
Node: Document View1950718
Ref: Document View-Footnote-11954070
Ref: Document View-Footnote-21954354
Node: DocView Navigation1954709
Node: DocView Searching1956871
Node: DocView Slicing1958318
Node: DocView Conversion1960217
Node: Shell1961164
Node: Single Shell1964309
Node: Interactive Shell1970453
Node: Shell Mode1974858
Ref: Shell Mode-Footnote-11983611
Node: Shell Prompts1983995
Node: Shell History1986655
Node: Shell Ring1987788
Node: Shell History Copying1993184
Node: History References1995133
Node: Directory Tracking1996703
Node: Shell Options1999103
Node: Terminal emulator2004052
Node: Term Mode2007306
Node: Remote Host2009054
Node: Serial Terminal2010505
Node: Emacs Server2011898
Ref: Emacs Server-Footnote-12018177
Node: TCP Emacs server2018406
Node: Invoking emacsclient2021781
Node: emacsclient Options2026559
Node: Printing2037650
Node: PostScript2041309
Node: PostScript Variables2044989
Node: Printing Package2050393
Node: Sorting2052292
Node: Picture Mode2059522
Node: Basic Picture2062713
Node: Insert in Picture2066081
Node: Tabs in Picture2068001
Node: Rectangles in Picture2070471
Node: Editing Binary Files2072954
Node: Saving Emacs Sessions2075119
Node: Recursive Edit2082474
Node: Hyperlinking2087138
Node: EWW2087899
Node: Embedded WebKit Widgets2088655
Node: Browse-URL2090032
Node: Goto Address mode2091644
Node: FFAP2093111
Node: Amusements2096476
Node: Packages2100327
Node: Package Menu2102275
Node: Package Installation2107996
Ref: Package Signing2110126
Node: Package Files2118314
Node: Customization2120745
Node: Easy Customization2122043
Node: Customization Groups2124142
Node: Browsing Custom2127180
Node: Changing a Variable2130859
Node: Saving Customizations2139993
Node: Face Customization2142836
Node: Specific Customization2147492
Node: Custom Themes2151699
Node: Creating Custom Themes2158038
Node: Variables2161395
Node: Examining2165006
Node: Hooks2167893
Node: Locals2174311
Node: File Variables2179763
Node: Specifying File Variables2180563
Node: Safe File Variables2189365
Node: Directory Variables2193397
Ref: Directory Variables-Footnote-12199699
Node: Key Bindings2200014
Node: Keymaps2202344
Node: Prefix Keymaps2206097
Node: Local Keymaps2208853
Node: Minibuffer Maps2211638
Node: Rebinding2212753
Node: Init Rebinding2217405
Node: Modifier Keys2222543
Node: Function Keys2225025
Node: Named ASCII Chars2229203
Node: Mouse Buttons2231253
Node: Disabling2239077
Node: Init File2242106
Node: Init Syntax2246745
Node: Init Examples2250800
Node: Terminal Init2258648
Node: Find Init2261452
Node: Init Non-ASCII2263042
Node: Quitting2264806
Node: Lossage2271842
Node: DEL Does Not Delete2273042
Node: Stuck Recursive2276001
Node: Screen Garbled2276879
Node: Text Garbled2278193
Node: Memory Full2279233
Node: Crashing2280828
Node: After a Crash2284341
Node: Emergency Escape2288053
Node: Bugs2291260
Node: Known Problems2292231
Node: Bug Criteria2296032
Node: Understanding Bug Reporting2300018
Node: Checklist2303878
Node: Sending Patches2328789
Node: Contributing2338183
Node: Coding Standards2342155
Node: Copyright Assignment2343477
Node: Service2345720
Node: Copying2346555
Node: GNU Free Documentation License2384341
Node: Emacs Invocation2409701
Node: Action Arguments2414579
Node: Initial Options2419101
Ref: Initial Options-Footnote-12427414
Node: Command Example2427490
Node: Environment2428665
Node: General Variables2431115
Ref: General Variables-Footnote-12441238
Node: Misc Variables2441614
Node: MS-Windows Registry2445088
Node: Display X2447276
Node: Font X2449820
Node: Colors X2450752
Node: Window Size X2454983
Node: Borders X2461562
Node: Title X2463255
Node: Icons X2464203
Node: Misc X2465827
Node: X Resources2467048
Node: Resources2468488
Node: Table of Resources2474018
Node: Lucid Resources2484539
Node: Motif Resources2487272
Node: GTK resources2491511
Node: GTK Resource Basics2494405
Node: GTK Widget Names2496656
Node: GTK Names in Emacs2499113
Node: GTK styles2501356
Node: Antinews2507477
Node: Mac OS / GNUstep2518055
Node: Mac / GNUstep Basics2520772
Node: Mac / GNUstep Customization2524435
Node: Mac / GNUstep Events2525613
Node: GNUstep Support2530426
Node: Microsoft Windows2530804
Node: Windows Startup2533332
Node: Text and Binary2540597
Node: Windows Files2546238
Node: ls in Lisp2549929
Node: Windows HOME2559093
Ref: Windows HOME-Footnote-12562823
Node: Windows Keyboard2562952
Ref: Windows Keyboard-Footnote-12572834
Node: Windows Mouse2573218
Node: Windows Processes2574495
Node: Windows Printing2579927
Ref: Windows Printing-Footnote-12588744
Node: Windows Fonts2589030
Node: Windows Misc2595893
Node: MS-DOS2597280
Node: MS-DOS Keyboard2598723
Node: MS-DOS Mouse2601438
Node: MS-DOS Display2605377
Node: MS-DOS File Names2611027
Node: MS-DOS Printing2615004
Node: MS-DOS and MULE2616959
Ref: MS-DOS and MULE-Footnote-12623670
Ref: MS-DOS and MULE-Footnote-22624153
Node: MS-DOS Processes2624612
Node: Manifesto2628021
Ref: Manifesto-Footnote-12652382
Ref: Manifesto-Footnote-22653282
Ref: Manifesto-Footnote-32653559
Ref: Manifesto-Footnote-42653601
Ref: Manifesto-Footnote-52654121
Ref: Manifesto-Footnote-62654227
Ref: Manifesto-Footnote-72654840
Node: Glossary2655204
Ref: Glossary---Abbrev2655315
Ref: Glossary---Balanced Expression2658462
Ref: Glossary---Bind2659147
Ref: Glossary---Binding2659236
Ref: Glossary---C-2661832
Ref: Glossary---Command Name2664465
Ref: Glossary---Compilation2665165
Ref: Glossary---Continuation Line2666386
Ref: Glossary---Daemon2669094
Ref: Glossary---Default2669660
Ref: Glossary---Deletion of Files2670726
Ref: Glossary---Directory Local Variable2671736
Ref: Glossary---End Of Line2674225
Ref: Glossary---File Locking2676770
Ref: Glossary---Filling2678345
Ref: Glossary---Font Lock2678606
Ref: Glossary---Free Software Foundation2679948
Ref: Glossary---Global Substitution2681792
Ref: Glossary---Incremental Search2685687
Ref: Glossary---Killing2688874
Ref: Glossary---Mail2691596
Ref: Glossary---Minibuffer History2694154
Ref: Glossary---Numeric Argument2697059
Ref: Glossary---Page2697669
Ref: Glossary---Quitting2699889
Ref: Glossary---Regular Expression2702367
Ref: Glossary---Server2706416
Ref: Glossary---Tags Table2709661
Ref: Glossary---Text Terminal2710539
Ref: Glossary---Tooltips2711509
Ref: Glossary---Truncation2712688
Ref: Glossary---Yanking2715516
Node: Acknowledgments2715732
Node: Key Index2771382
Node: Option Index2849980
Node: Command Index2856429
Node: Variable Index2980655
Node: Concept Index3055823

End Tag Table


Local Variables:
coding: utf-8
End:
