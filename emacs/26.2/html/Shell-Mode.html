<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This is the GNU Emacs Manual,
updated for Emacs version 26.2.

Copyright (C) 2016-2019 ayatakesi
<ayanokoji.takesi@gmail.com>
Copyright (C) 1985-1987, 1993-2019
Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "The GNU Manifesto," "Distribution" and "GNU GENERAL
PUBLIC LICENSE," with the Front-Cover Texts being "A GNU Manual," and
with the Back-Cover Texts as in (a) below.  A copy of the license is
included in the section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<!-- Created by GNU Texinfo 6.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>GNU Emacs Manual
(Japanese Translation): Shell Mode</title>

<meta name="description" content="GNU Emacs Manual
(Japanese Translation): Shell Mode">
<meta name="keywords" content="GNU Emacs Manual
(Japanese Translation): Shell Mode">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Key-Index.html#Key-Index" rel="index" title="Key Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Shell.html#Shell" rel="up" title="Shell">
<link href="Shell-Prompts.html#Shell-Prompts" rel="next" title="Shell Prompts">
<link href="Interactive-Shell.html#Interactive-Shell" rel="prev" title="Interactive Shell">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="Shell-Mode"></a>
<div class="header">
<p>
Next: <a href="Shell-Prompts.html#Shell-Prompts" accesskey="n" rel="next">Shell Prompts</a>, Previous: <a href="Interactive-Shell.html#Interactive-Shell" accesskey="p" rel="prev">Interactive Shell</a>, Up: <a href="Shell.html#Shell" accesskey="u" rel="up">Shell</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Key-Index.html#Key-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Shellmodo"></a>
<h3 class="section">38.3 Shellモード</h3>
<a name="index-Shell-mode"></a>
<a name="index-mode_002c-Shell"></a>

<p>ShellバッファーのためのメジャーモードはShellモードです。このモードの特別なコマンドは<kbd>C-c</kbd>プレフィクスにバインドされており、最初に<kbd>C-c</kbd>をタイプしなければならない点を除けば、通常のシェルでの編集やジョブ制御文字と共通点があります。以下はShellモードのコマンドのリストです:
</p>
<dl compact="compact">
<dt><kbd><span class="key">RET</span></kbd></dt>
<dd><a name="index-RET-_0028Shell-mode_0029"></a>
<a name="index-comint_002dsend_002dinput"></a>
<p>サブシェルの入力にカレント行を送ります(<code>comint-send-input</code>)。行頭のシェルプロンプトは省略されます(<a href="Shell-Prompts.html#Shell-Prompts">Shell Prompts</a>を参照してください)。ポイントがバッファーの最後にある場合、これは通常の対話的なシェルにおいてコマンド行をサブミットするのに似ています。しかし、シェルバッファーの他の場所でも、<tt class="key">RET</tt>を呼び出してカレント行を入力としてサブミットできます。
</p>
</dd>
<dt><kbd><span class="key">TAB</span></kbd></dt>
<dd><a name="index-TAB-_0028Shell-mode_0029"></a>
<a name="index-completion_002dat_002dpoint_002c-in-Shell-Mode"></a>
<a name="index-shell-completion"></a>
<p>シェルバッファーのポイントの前のコマンド名、またはファイル名を補完します(<code>completion-at-point</code>)。これは通常のEmacs補完ルールを使用します(<a href="Completion.html#Completion">Completion</a>を参照してください)。ファイル名、環境変数名、シェルコマンドヒストリー、ヒストリー参照が補完候補になります(<a href="History-References.html#History-References">History References</a>を参照してください)。補完を制御するオプションについては、<a href="Shell-Options.html#Shell-Options">Shell Options</a>を参照してください。
</p>
</dd>
<dt><kbd>M-?</kbd></dt>
<dd><a name="index-M_002d_003f-_0028Shell-mode_0029"></a>
<a name="index-comint_002ddynamic_002dlist_002dfilename_2026"></a>
<p>ポイントの前のファイル名にたいして、可能性のある補完リストを一時的に表示します(<code>comint-dynamic-list-filename-completions</code>)。
</p>
</dd>
<dt><kbd>C-d</kbd></dt>
<dd><a name="index-C_002dd-_0028Shell-mode_0029"></a>
<a name="index-comint_002ddelchar_002dor_002dmaybe_002deof"></a>
<p>delete文字、または<acronym>EOF</acronym>文字を送ります(<code>comint-delchar-or-maybe-eof</code>)。シェルバッファーの最後でこれをタイプすると、サブシェルに<acronym>EOF</acronym>が送られます。バッファーの他の場所でタイプすると、通常どおり文字を削除します。
</p>
</dd>
<dt><kbd>C-c C-a</kbd></dt>
<dd><a name="index-C_002dc-C_002da-_0028Shell-mode_0029"></a>
<a name="index-comint_002dbol_002dor_002dprocess_002dmark"></a>
<p>行の先頭に移動しますが、プロンプトがある場合はプロンプトの後に移動します(<code>comint-bol-or-process-mark</code>)。このコマンドを連続して繰り返すと、2回目はプロセスマーク(process
mark)に戻ります。これはサブシェルにまだ送信されていない入力の開始位置のことです(通常これは同じ場所 &mdash; その行のプロンプトの最後 &mdash;
ですが、<kbd>C-c <span class="key">SPC</span></kbd>の後では、プロセスマークは前の行にあるかもしれません)。
</p>
</dd>
<dt><kbd>C-c <span class="key">SPC</span></kbd></dt>
<dd><p>複数行の入力を累積して、それらを合わせて送ります(<code>comint-accumulate</code>)。このコマンドはポイントの前に改行を挿入しますが、その前のテキストをサブシェルの入力として
&mdash; 少なくともその時点では &mdash;
送りません。改行の前後の行は両方、(それらを分割する改行も含めて)<tt class="key">RET</tt>をタイプしたとき一緒に送られます。
</p>
</dd>
<dt><kbd>C-c C-u</kbd></dt>
<dd><a name="index-C_002dc-C_002du-_0028Shell-mode_0029"></a>
<a name="index-comint_002dkill_002dinput"></a>
<p>まだ入力として送られていない、バッファーの最後のすべてのテキストをkillします(<code>comint-kill-input</code>)。ポイントがバッファーの最後にない場合、これはポイントの前のテキストだけをkillします。
</p>
</dd>
<dt><kbd>C-c C-w</kbd></dt>
<dd><a name="index-C_002dc-C_002dw-_0028Shell-mode_0029"></a>
<p>ポイントの前の単語をkillします(<code>backward-kill-word</code>)。
</p>
</dd>
<dt><kbd>C-c C-c</kbd></dt>
<dd><a name="index-C_002dc-C_002dc-_0028Shell-mode_0029"></a>
<a name="index-comint_002dinterrupt_002dsubjob"></a>
<p>シェルまたは(もしあれば)カレントのサブジョブに割り込み(interrupt)ます(<code>comint-interrupt-subjob</code>)。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。
</p>
</dd>
<dt><kbd>C-c C-z</kbd></dt>
<dd><a name="index-C_002dc-C_002dz-_0028Shell-mode_0029"></a>
<a name="index-comint_002dstop_002dsubjob"></a>
<p>シェルまたは(もしあれば)カレントのサブジョブを停止(stop)します。(<code>comint-stop-subjob</code>)。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。
</p>
</dd>
<dt><kbd>C-c C-\</kbd></dt>
<dd><a name="index-comint_002dquit_002dsubjob"></a>
<a name="index-C_002dc-C_002d_005c-_0028Shell-mode_0029"></a>
<p>シェルまたは(もしあれば)カレントのサブジョブに、シグナルQUITを送ります(<code>comint-quit-subjob</code>)。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。
</p>
</dd>
<dt><kbd>C-c C-o</kbd></dt>
<dd><a name="index-C_002dc-C_002do-_0028Shell-mode_0029"></a>
<a name="index-comint_002ddelete_002doutput"></a>
<p>前のシェルコマンドからの出力の一群を削除します(<code>comint-delete-output</code>)。これはシェルコマンドが大量の出力を吐くときに便利です。
</p>
</dd>
<dt><kbd>C-c C-s</kbd></dt>
<dd><a name="index-C_002dc-C_002ds-_0028Shell-mode_0029"></a>
<a name="index-comint_002dwrite_002doutput"></a>
<p>前のシェルコマンドからの出力の一群をファイルに書き込みます(<code>comint-write-output</code>)。プレフィクス引数を指定した場合は、ファイルに追加で書き込みます。出力の最後のプロンプトは書き込まれません。
</p>
</dd>
<dt><kbd>C-c C-r</kbd></dt>
<dt><kbd>C-M-l</kbd></dt>
<dd><a name="index-C_002dc-C_002dr-_0028Shell-mode_0029"></a>
<a name="index-C_002dM_002dl-_0028Shell-mode_0029"></a>
<a name="index-comint_002dshow_002doutput"></a>
<p>前の一群の出力の最初がウィンドウの最上部になるようにスクロールし、カーソルもそこに移動します(<code>comint-show-output</code>)。
</p>
</dd>
<dt><kbd>C-c C-e</kbd></dt>
<dd><a name="index-C_002dc-C_002de-_0028Shell-mode_0029"></a>
<a name="index-comint_002dshow_002dmaximum_002doutput"></a>
<p>バッファーの最後の行がウィンドウの最下部になるようにスクロールします(<code>comint-show-maximum-output</code>)。
</p>
</dd>
<dt><kbd>C-c C-f</kbd></dt>
<dd><a name="index-C_002dc-C_002df-_0028Shell-mode_0029"></a>
<a name="index-shell_002dforward_002dcommand"></a>
<a name="index-shell_002dcommand_002dregexp"></a>
<p>シェルコマンド1つ分、前方に移動しますが、カレント行を超えては移動しません(<code>shell-forward-command</code>)。変数<code>shell-command-regexp</code>は、コマンドの最後を認識する方法を指定します。
</p>
</dd>
<dt><kbd>C-c C-b</kbd></dt>
<dd><a name="index-C_002dc-C_002db-_0028Shell-mode_0029"></a>
<a name="index-shell_002dbackward_002dcommand"></a>
<p>シェルコマンド1つ分、後方に移動しますが、カレント行を超えて移動はしません(<code>shell-backward-command</code>)。
</p>
</dd>
<dt><kbd>M-x dirs</kbd></dt>
<dd><p>シェルに作業ディレクトリーを尋ね、Shellバッファーのデフォルトディレクトリーを更新します。<a href="Directory-Tracking.html#Directory-Tracking">Directory Tracking</a>を参照してください。
</p>
</dd>
<dt><kbd>M-x send-invisible <span class="key">RET</span> <var>text</var> <span class="key">RET</span></kbd></dt>
<dd><a name="index-send_002dinvisible"></a>
<p>エコーなしで<var>text</var>を読み取った後、それをシェルの入力として送ります。これはシェルコマンドでパスワードを尋ねるプログラムを実行するとき便利です。
</p>
<p>デフォルトではEmacsはパスワードをエコーしないことに注意してください。もし本当にエコーさせたいときは、以下のLisp式を評価します(<a href="Lisp-Eval.html#Lisp-Eval">Lisp Eval</a>を参照してください):
</p>
<div class="example">
<pre class="example">(remove-hook 'comint-output-filter-functions
             'comint-watch-for-password-prompt)
</pre></div>

</dd>
<dt><kbd>M-x comint-continue-subjob</kbd></dt>
<dd><a name="index-comint_002dcontinue_002dsubjob"></a>
<p>シェルプロセスを継続します。これは間違ってシェルプロセスをサスペンドしてしまったときなどに便利です。<a name="DOCF20" href="#FOOT20"><sup>20</sup></a>
</p>
</dd>
<dt><kbd>M-x comint-strip-ctrl-m</kbd></dt>
<dd><a name="index-comint_002dstrip_002dctrl_002dm"></a>
<p>シェル出力のカレントグループから、すべてのcontrol-M文字を破棄します。このコマンドを使うもっとも便利な方法は、サブシェルからの出力を受け取ったときに自動的に実行されるようにする方法です。これを行なうには、以下のLisp式を評価します:
</p>
<div class="example">
<pre class="example">(add-hook 'comint-output-filter-functions
          'comint-strip-ctrl-m)
</pre></div>

</dd>
<dt><kbd>M-x comint-truncate-buffer</kbd></dt>
<dd><a name="index-comint_002dtruncate_002dbuffer"></a>
<p>このコマンドはシェルバッファーを、変数<code>comint-buffer-maximum-size</code>により指定される、特定の最大行数に切り詰めます。以下は、サブシェルから出力を受けとるとき、毎回自動的にこれを行なう方法です:
</p>
<div class="example">
<pre class="example">(add-hook 'comint-output-filter-functions
          'comint-truncate-buffer)
</pre></div>
</dd>
</dl>

<a name="index-Comint-mode"></a>
<a name="index-mode_002c-Comint"></a>
<p>Shellモードは、サブプロセスと対話的に通信を行なう一般的な用途向けのComintモードから派生したモードです。上記のコマンド名からも判るとおり、Shellモードのほとんどの機能は、実際にはComintモードが由来です。Shellモードの特別な機能には、ディレクトリー追跡機能、およびいくつかのユーザーコマンドが含まれます。
</p>
<p>Comintモードの変種を使う他のEmacs機能には、GUD (<a href="Debuggers.html#Debuggers">Debuggers</a>を参照してください)や、<kbd>M-x
run-lisp</kbd> (<a href="External-Lisp.html#External-Lisp">External Lisp</a>を参照してください)が含まれます。
</p>
<a name="index-comint_002drun"></a>
<p>サブプロセスとして選択した任意のプログラムを実行するために、Shellモードに特化しない未修正のComintモードを使用するには、<kbd>M-x
comint-run</kbd>を使用することができます。
</p>
<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h3><a name="FOOT20" href="#DOCF20">(20)</a></h3>
<p>シェルプロセスをサスペンドするべきではありません。これはシェルのサブジョブのサスペンドとはまったく違います。サブジョブのサスペンドは通常行なわれますが、サブジョブを継続するためにはシェルを使用しなければなりません。このコマンドはそれを行ないません。</p>
</div>
<hr>
<div class="header">
<p>
Next: <a href="Shell-Prompts.html#Shell-Prompts" accesskey="n" rel="next">Shell Prompts</a>, Previous: <a href="Interactive-Shell.html#Interactive-Shell" accesskey="p" rel="prev">Interactive Shell</a>, Up: <a href="Shell.html#Shell" accesskey="u" rel="up">Shell</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Key-Index.html#Key-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
