<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>log</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.7' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/2824.html#L1497'>log</a>              1497 lib/math.in.h  _GL_FUNCDECL_RPL (log, double, (double x));</span>
<span class='curline'><a href='../S/2824.html#L1498'>log</a>              1498 lib/math.in.h  _GL_CXXALIAS_RPL (log, double, (double x));</span>
<span class='curline'><a href='../S/2824.html#L1500'>log</a>              1500 lib/math.in.h  _GL_CXXALIAS_SYS (log, double, (double x));</span>
<span class='curline'><a href='../S/2824.html#L1503'>log</a>              1503 lib/math.in.h  _GL_CXXALIASWARN1 (log, double, (double x));</span>
<span class='curline'><a href='../S/2824.html#L1508'>log</a>              1508 lib/math.in.h  _GL_WARN_ON_USE (log, "log has portability problems - "</span>
<span class='curline'><a href='../S/2109.html#L242'>log</a>               242 src/floatfns.c     d = log (d);</span>
<span class='curline'><a href='../S/2109.html#L254'>log</a>               254 src/floatfns.c 	d = log (d) / log (b);</span>
<span class='curline'><a href='../S/2125.html#L721'>log</a>               721 src/gmalloc.c        register size_t log = 1;</span>
<span class='curline'><a href='../S/2125.html#L724'>log</a>               724 src/gmalloc.c  	++log;</span>
<span class='curline'><a href='../S/2125.html#L728'>log</a>               728 src/gmalloc.c        next = _fraghead[log].next;</span>
<span class='curline'><a href='../S/2125.html#L741'>log</a>               741 src/gmalloc.c  	      (uintptr_t) next-&gt;next % BLOCKSIZE &gt;&gt; log;</span>
<span class='curline'><a href='../S/2125.html#L745'>log</a>               745 src/gmalloc.c  	  _bytes_used += 1 &lt;&lt; log;</span>
<span class='curline'><a href='../S/2125.html#L747'>log</a>               747 src/gmalloc.c  	  _bytes_free -= 1 &lt;&lt; log;</span>
<span class='curline'><a href='../S/2125.html#L768'>log</a>               768 src/gmalloc.c  	  next = (struct list *) ((char *) result + (1 &lt;&lt; log));</span>
<span class='curline'><a href='../S/2125.html#L770'>log</a>               770 src/gmalloc.c  	  next-&gt;prev = &amp;_fraghead[log];</span>
<span class='curline'><a href='../S/2125.html#L771'>log</a>               771 src/gmalloc.c  	  _fraghead[log].next = next;</span>
<span class='curline'><a href='../S/2125.html#L773'>log</a>               773 src/gmalloc.c  	  for (i = 2; i &lt; (size_t) (BLOCKSIZE &gt;&gt; log); ++i)</span>
<span class='curline'><a href='../S/2125.html#L775'>log</a>               775 src/gmalloc.c  	      next = (struct list *) ((char *) result + (i &lt;&lt; log));</span>
<span class='curline'><a href='../S/2125.html#L776'>log</a>               776 src/gmalloc.c  	      next-&gt;next = _fraghead[log].next;</span>
<span class='curline'><a href='../S/2125.html#L777'>log</a>               777 src/gmalloc.c  	      next-&gt;prev = &amp;_fraghead[log];</span>
<span class='curline'><a href='../S/2125.html#L784'>log</a>               784 src/gmalloc.c  	  _heapinfo[block].busy.type = log;</span>
<span class='curline'><a href='../S/2125.html#L788'>log</a>               788 src/gmalloc.c  	  _chunks_free += (BLOCKSIZE &gt;&gt; log) - 1;</span>
<span class='curline'><a href='../S/2125.html#L789'>log</a>               789 src/gmalloc.c  	  _bytes_free += BLOCKSIZE - (1 &lt;&lt; log);</span>
<span class='curline'><a href='../S/2125.html#L790'>log</a>               790 src/gmalloc.c  	  _bytes_used -= BLOCKSIZE - (1 &lt;&lt; log);</span>
<span class='curline'><a href='../S/2271.html#L201'>log</a>               201 src/itree.c      return 2 * log (tree-&gt;size + 1) / log (2) + 0.5;</span>
<span class='curline'><a href='../S/2292.html#L300'>log</a>               300 src/lcms.c       double Mp = 43.86 * log (1.0 + c2 * (jch-&gt;C * sqrt (sqrt (FL))));</span>
<span class='curline'><a href='../S/2235.html#L384'>log</a>               384 src/process.c    p-&gt;log = val;</span>
<span class='curline'><a href='../S/2235.html#L2463'>log</a>              2463 src/process.c    eassert (NILP (p-&gt;log));</span>
<span class='curline'><a href='../S/2235.html#L3198'>log</a>              3198 src/process.c    eassert (NILP (p-&gt;log));</span>
<span class='curline'><a href='../S/2235.html#L4932'>log</a>              4932 src/process.c        if (!would_block (code) &amp;&amp; !NILP (ps-&gt;log))</span>
<span class='curline'><a href='../S/2235.html#L4933'>log</a>              4933 src/process.c  	call3 (ps-&gt;log, server, Qnil,</span>
<span class='curline'><a href='../S/2235.html#L5092'>log</a>              5092 src/process.c    if (!NILP (ps-&gt;log))</span>
<span class='curline'><a href='../S/2235.html#L5095'>log</a>              5095 src/process.c        call3 (ps-&gt;log, server, proc, concat3 (accept_from, host_string, nl));</span>
<span class='curline'><a href='../S/2323.html#L65'>log</a>                65 src/process.h      Lisp_Object log;</span>
<span class='curline'><a href='../S/2260.html#L53'>log</a>                53 src/profiler.c   Lisp_Object log;</span>
<span class='curline'><a href='../S/2260.html#L69'>log</a>                69 src/profiler.c   struct profiler_log log</span>
<span class='curline'><a href='../S/2260.html#L75'>log</a>                75 src/profiler.c   struct Lisp_Hash_Table *h = XHASH_TABLE (log.log);</span>
<span class='curline'><a href='../S/2260.html#L82'>log</a>                82 src/profiler.c   return log;</span>
<span class='curline'><a href='../S/2260.html#L101'>log</a>               101 src/profiler.c static EMACS_INT approximate_median (log_t *log,</span>
<span class='curline'><a href='../S/2260.html#L106'>log</a>               106 src/profiler.c     return XFIXNUM (HASH_VALUE (log, start));</span>
<span class='curline'><a href='../S/2260.html#L110'>log</a>               110 src/profiler.c     return ((XFIXNUM (HASH_VALUE (log, start))</span>
<span class='curline'><a href='../S/2260.html#L111'>log</a>               111 src/profiler.c 	     + XFIXNUM (HASH_VALUE (log, start + 1)))</span>
<span class='curline'><a href='../S/2260.html#L117'>log</a>               117 src/profiler.c       EMACS_INT i1 = approximate_median (log, start, newsize);</span>
<span class='curline'><a href='../S/2260.html#L118'>log</a>               118 src/profiler.c       EMACS_INT i2 = approximate_median (log, start2, newsize);</span>
<span class='curline'><a href='../S/2260.html#L119'>log</a>               119 src/profiler.c       EMACS_INT i3 = approximate_median (log, start2 + newsize,</span>
<span class='curline'><a href='../S/2260.html#L129'>log</a>               129 src/profiler.c   log_t *log = XHASH_TABLE (plog-&gt;log);</span>
<span class='curline'><a href='../S/2260.html#L130'>log</a>               130 src/profiler.c   ptrdiff_t size = ASIZE (log-&gt;key_and_value) / 2;</span>
<span class='curline'><a href='../S/2260.html#L131'>log</a>               131 src/profiler.c   EMACS_INT median = approximate_median (log, 0, size);</span>
<span class='curline'><a href='../S/2260.html#L136'>log</a>               136 src/profiler.c     if (XFIXNUM (HASH_VALUE (log, i)) &lt;= median)</span>
<span class='curline'><a href='../S/2260.html#L138'>log</a>               138 src/profiler.c 	Lisp_Object key = HASH_KEY (log, i);</span>
<span class='curline'><a href='../S/2260.html#L139'>log</a>               139 src/profiler.c 	EMACS_INT count = XFIXNUM (HASH_VALUE (log, i));</span>
<span class='curline'><a href='../S/2260.html#L143'>log</a>               143 src/profiler.c 	  XSET_HASH_TABLE (tmp, log); /* FIXME: Use make_lisp_ptr.  */</span>
<span class='curline'><a href='../S/2260.html#L146'>log</a>               146 src/profiler.c         eassert (BASE_EQ (Qunbound, HASH_KEY (log, i)));</span>
<span class='curline'><a href='../S/2260.html#L147'>log</a>               147 src/profiler.c 	eassert (log-&gt;next_free == i);</span>
<span class='curline'><a href='../S/2260.html#L153'>log</a>               153 src/profiler.c 	set_hash_value_slot (log, i, key);</span>
<span class='curline'><a href='../S/2260.html#L164'>log</a>               164 src/profiler.c   eassert (HASH_TABLE_P (plog-&gt;log));</span>
<span class='curline'><a href='../S/2260.html#L165'>log</a>               165 src/profiler.c   log_t *log = XHASH_TABLE (plog-&gt;log);</span>
<span class='curline'><a href='../S/2260.html#L166'>log</a>               166 src/profiler.c   if (log-&gt;next_free &lt; 0)</span>
<span class='curline'><a href='../S/2260.html#L168'>log</a>               168 src/profiler.c   ptrdiff_t index = log-&gt;next_free;</span>
<span class='curline'><a href='../S/2260.html#L171'>log</a>               171 src/profiler.c   Lisp_Object backtrace = HASH_VALUE (log, index);</span>
<span class='curline'><a href='../S/2260.html#L172'>log</a>               172 src/profiler.c   eassert (BASE_EQ (Qunbound, HASH_KEY (log, index)));</span>
<span class='curline'><a href='../S/2260.html#L180'>log</a>               180 src/profiler.c     ptrdiff_t j = hash_lookup (log, backtrace, &amp;hash);</span>
<span class='curline'><a href='../S/2260.html#L183'>log</a>               183 src/profiler.c 	EMACS_INT old_val = XFIXNUM (HASH_VALUE (log, j));</span>
<span class='curline'><a href='../S/2260.html#L185'>log</a>               185 src/profiler.c 	set_hash_value_slot (log, j, make_fixnum (new_val));</span>
<span class='curline'><a href='../S/2260.html#L190'>log</a>               190 src/profiler.c 	eassert (0 &lt;= log-&gt;next_free);</span>
<span class='curline'><a href='../S/2260.html#L191'>log</a>               191 src/profiler.c 	ptrdiff_t j = hash_put (log, backtrace, make_fixnum (count), hash);</span>
<span class='curline'><a href='../S/2260.html#L361'>log</a>               361 src/profiler.c   if (NILP (cpu.log))</span>
<span class='curline'><a href='../S/2260.html#L425'>log</a>               425 src/profiler.c export_log (struct profiler_log *log)</span>
<span class='curline'><a href='../S/2260.html#L427'>log</a>               427 src/profiler.c   Lisp_Object result = log-&gt;log;</span>
<span class='curline'><a href='../S/2260.html#L428'>log</a>               428 src/profiler.c   if (log-&gt;gc_count)</span>
<span class='curline'><a href='../S/2260.html#L430'>log</a>               430 src/profiler.c 	      make_fixnum (log-&gt;gc_count),</span>
<span class='curline'><a href='../S/2260.html#L432'>log</a>               432 src/profiler.c   if (log-&gt;discarded)</span>
<span class='curline'><a href='../S/2260.html#L434'>log</a>               434 src/profiler.c 	      make_fixnum (log-&gt;discarded),</span>
<span class='curline'><a href='../S/2260.html#L440'>log</a>               440 src/profiler.c     *log = make_log ();</span>
<span class='curline'><a href='../S/2260.html#L474'>log</a>               474 src/profiler.c   if (NILP (memory.log))</span>
<span class='curline'><a href='../S/2260.html#L610'>log</a>               610 src/profiler.c   cpu.log = Qnil;</span>
<span class='curline'><a href='../S/2260.html#L611'>log</a>               611 src/profiler.c   staticpro (&amp;cpu.log);</span>
<span class='curline'><a href='../S/2260.html#L618'>log</a>               618 src/profiler.c   memory.log = Qnil;</span>
<span class='curline'><a href='../S/2260.html#L619'>log</a>               619 src/profiler.c   staticpro (&amp;memory.log);</span>
<span class='curline'><a href='../S/2260.html#L634'>log</a>               634 src/profiler.c       cpu.log = Qnil;</span>
<span class='curline'><a href='../S/2260.html#L636'>log</a>               636 src/profiler.c       memory.log = Qnil;</span>
<span class='curline'><a href='../S/2260.html#L641'>log</a>               641 src/profiler.c       eassert (NILP (cpu.log));</span>
<span class='curline'><a href='../S/2260.html#L643'>log</a>               643 src/profiler.c       eassert (NILP (memory.log));</span>
<span class='curline'><a href='../S/2286.html#L4002'>log</a>              4002 src/sysdep.c   		  / (1 - exp (proc.ki_swtime * log ((double) ccpu / fscale))));</span>
<span class='curline'><a href='../S/2224.html#L12140'>log</a>              12140 src/xdisp.c    message_with_string (const char *m, Lisp_Object string, bool log)</span>
<span class='curline'><a href='../S/2224.html#L12177'>log</a>              12177 src/xdisp.c    	  if (log)</span>
<span class='curline'><a href='../S/4043.html#L751'>log</a>               751 test/manual/etags/c-src/emacs/src/gmalloc.c       register size_t log = 1;</span>
<span class='curline'><a href='../S/4043.html#L754'>log</a>               754 test/manual/etags/c-src/emacs/src/gmalloc.c 	++log;</span>
<span class='curline'><a href='../S/4043.html#L758'>log</a>               758 test/manual/etags/c-src/emacs/src/gmalloc.c       next = _fraghead[log].next;</span>
<span class='curline'><a href='../S/4043.html#L771'>log</a>               771 test/manual/etags/c-src/emacs/src/gmalloc.c 	      (uintptr_t) next-&gt;next % BLOCKSIZE &gt;&gt; log;</span>
<span class='curline'><a href='../S/4043.html#L775'>log</a>               775 test/manual/etags/c-src/emacs/src/gmalloc.c 	  _bytes_used += 1 &lt;&lt; log;</span>
<span class='curline'><a href='../S/4043.html#L777'>log</a>               777 test/manual/etags/c-src/emacs/src/gmalloc.c 	  _bytes_free -= 1 &lt;&lt; log;</span>
<span class='curline'><a href='../S/4043.html#L798'>log</a>               798 test/manual/etags/c-src/emacs/src/gmalloc.c 	  next = (struct list *) ((char *) result + (1 &lt;&lt; log));</span>
<span class='curline'><a href='../S/4043.html#L800'>log</a>               800 test/manual/etags/c-src/emacs/src/gmalloc.c 	  next-&gt;prev = &amp;_fraghead[log];</span>
<span class='curline'><a href='../S/4043.html#L801'>log</a>               801 test/manual/etags/c-src/emacs/src/gmalloc.c 	  _fraghead[log].next = next;</span>
<span class='curline'><a href='../S/4043.html#L803'>log</a>               803 test/manual/etags/c-src/emacs/src/gmalloc.c 	  for (i = 2; i &lt; (size_t) (BLOCKSIZE &gt;&gt; log); ++i)</span>
<span class='curline'><a href='../S/4043.html#L805'>log</a>               805 test/manual/etags/c-src/emacs/src/gmalloc.c 	      next = (struct list *) ((char *) result + (i &lt;&lt; log));</span>
<span class='curline'><a href='../S/4043.html#L806'>log</a>               806 test/manual/etags/c-src/emacs/src/gmalloc.c 	      next-&gt;next = _fraghead[log].next;</span>
<span class='curline'><a href='../S/4043.html#L807'>log</a>               807 test/manual/etags/c-src/emacs/src/gmalloc.c 	      next-&gt;prev = &amp;_fraghead[log];</span>
<span class='curline'><a href='../S/4043.html#L814'>log</a>               814 test/manual/etags/c-src/emacs/src/gmalloc.c 	  _heapinfo[block].busy.type = log;</span>
<span class='curline'><a href='../S/4043.html#L818'>log</a>               818 test/manual/etags/c-src/emacs/src/gmalloc.c 	  _chunks_free += (BLOCKSIZE &gt;&gt; log) - 1;</span>
<span class='curline'><a href='../S/4043.html#L819'>log</a>               819 test/manual/etags/c-src/emacs/src/gmalloc.c 	  _bytes_free += BLOCKSIZE - (1 &lt;&lt; log);</span>
<span class='curline'><a href='../S/4043.html#L820'>log</a>               820 test/manual/etags/c-src/emacs/src/gmalloc.c 	  _bytes_used -= BLOCKSIZE - (1 &lt;&lt; log);</span>
</pre>
</body>
</html>
