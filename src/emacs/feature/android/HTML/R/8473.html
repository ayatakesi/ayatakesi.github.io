<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>buffer</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.7' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/90.html#L167'>buffer</a>            167 exec/exec.c      static char buffer[PATH_MAX], *start;</span>
<span class='curline'><a href='../S/90.html#L180'>buffer</a>            180 exec/exec.c      rc = read (fd, buffer, PATH_MAX);</span>
<span class='curline'><a href='../S/90.html#L186'>buffer</a>            186 exec/exec.c      start = buffer;</span>
<span class='curline'><a href='../S/90.html#L554'>buffer</a>            554 exec/exec.c      char buffer[PATH_MAX + 1];</span>
<span class='curline'><a href='../S/90.html#L561'>buffer</a>            561 exec/exec.c      rc = pread (fd, buffer, size, prog_header-&gt;p_offset);</span>
<span class='curline'><a href='../S/90.html#L566'>buffer</a>            566 exec/exec.c      buffer[size] = '\0';</span>
<span class='curline'><a href='../S/90.html#L571'>buffer</a>            571 exec/exec.c      if (access (buffer, X_OK))</span>
<span class='curline'><a href='../S/90.html#L580'>buffer</a>            580 exec/exec.c      fd = open (buffer, O_RDONLY);</span>
<span class='curline'><a href='../S/90.html#L633'>buffer</a>            633 exec/exec.c      if (write_open_command (buffer, true))</span>
<span class='curline'><a href='../S/90.html#L642'>buffer</a>            642 exec/exec.c          if (process_interpreter_1 (buffer, fd, &amp;program,</span>
<span class='curline'><a href='../S/90.html#L993'>buffer</a>            993 exec/exec.c      char buffer[80], buffer1[PATH_MAX + 80], *rewrite;</span>
<span class='curline'><a href='../S/90.html#L1013'>buffer</a>           1013 exec/exec.c    	  memset (buffer, 0, sizeof buffer);</span>
<span class='curline'><a href='../S/90.html#L1014'>buffer</a>           1014 exec/exec.c    	  memset (buffer1, 0, sizeof buffer);</span>
<span class='curline'><a href='../S/90.html#L1017'>buffer</a>           1017 exec/exec.c    	  rewrite = stpcpy (buffer, "/proc/");</span>
<span class='curline'><a href='../S/90.html#L1023'>buffer</a>           1023 exec/exec.c    	  link_size = readlink (buffer, buffer1,</span>
<span class='curline'><a href='../S/93.html#L143'>buffer</a>            143 exec/trace.c   read_memory (struct exec_tracee *tracee, char *buffer,</span>
<span class='curline'><a href='../S/93.html#L153'>buffer</a>            153 exec/trace.c     iov.iov_base = buffer;</span>
<span class='curline'><a href='../S/93.html#L182'>buffer</a>            182 exec/trace.c         memcpy (buffer, &amp;word, sizeof word);</span>
<span class='curline'><a href='../S/93.html#L183'>buffer</a>            183 exec/trace.c         buffer += sizeof word;</span>
<span class='curline'><a href='../S/93.html#L198'>buffer</a>            198 exec/trace.c         memcpy (buffer, &amp;word, n_bytes);</span>
<span class='curline'><a href='../S/93.html#L280'>buffer</a>            280 exec/trace.c   user_copy (struct exec_tracee *tracee, const unsigned char *buffer,</span>
<span class='curline'><a href='../S/93.html#L291'>buffer</a>            291 exec/trace.c     iov.iov_base = (void *) buffer;</span>
<span class='curline'><a href='../S/93.html#L314'>buffer</a>            314 exec/trace.c   	  memcpy (&amp;word, buffer, sizeof word);</span>
<span class='curline'><a href='../S/93.html#L315'>buffer</a>            315 exec/trace.c   	  buffer += sizeof word;</span>
<span class='curline'><a href='../S/93.html#L332'>buffer</a>            332 exec/trace.c   	  memcpy (bytes, buffer, end - start);</span>
<span class='curline'><a href='../S/93.html#L686'>buffer</a>            686 exec/trace.c     char buffer[PATH_MAX + 80], *area;</span>
<span class='curline'><a href='../S/93.html#L697'>buffer</a>            697 exec/trace.c     read_memory (tracee, buffer, PATH_MAX,</span>
<span class='curline'><a href='../S/93.html#L702'>buffer</a>            702 exec/trace.c     if (!memchr (buffer, '\0', PATH_MAX))</span>
<span class='curline'><a href='../S/93.html#L713'>buffer</a>            713 exec/trace.c     area = exec_0 (buffer, tracee, &amp;size, regs);</span>
<span class='curline'><a href='../S/93.html#L780'>buffer</a>            780 exec/trace.c     tracee-&gt;exec_file = strdup (buffer);</span>
<span class='curline'><a href='../S/93.html#L924'>buffer</a>            924 exec/trace.c     char buffer[PATH_MAX + 1];</span>
<span class='curline'><a href='../S/93.html#L945'>buffer</a>            945 exec/trace.c     read_memory (tracee, buffer, PATH_MAX, address);</span>
<span class='curline'><a href='../S/93.html#L949'>buffer</a>            949 exec/trace.c     if (!memchr (buffer, '\0', PATH_MAX))</span>
<span class='curline'><a href='../S/93.html#L960'>buffer</a>            960 exec/trace.c     if (strcmp (buffer, "/proc/self/exe") || !tracee-&gt;exec_file)</span>
<span class='curline'><a href='../S/93.html#L968'>buffer</a>            968 exec/trace.c     strncpy (buffer, tracee-&gt;exec_file, length);</span>
<span class='curline'><a href='../S/93.html#L970'>buffer</a>            970 exec/trace.c     if (user_copy (tracee, (unsigned char *) buffer,</span>
<span class='curline'><a href='../S/135.html#L501'>buffer</a>            501 java/org/gnu/emacs/EmacsDocumentsProvider.java     byte buffer[];</span>
<span class='curline'><a href='../S/135.html#L540'>buffer</a>            540 java/org/gnu/emacs/EmacsDocumentsProvider.java 	buffer = new byte[4096];</span>
<span class='curline'><a href='../S/135.html#L542'>buffer</a>            542 java/org/gnu/emacs/EmacsDocumentsProvider.java 	while ((length = inputStream.read (buffer)) &gt; 0)</span>
<span class='curline'><a href='../S/135.html#L543'>buffer</a>            543 java/org/gnu/emacs/EmacsDocumentsProvider.java 	  outputStream.write (buffer, 0, length);</span>
<span class='curline'><a href='../S/119.html#L147'>buffer</a>            147 java/org/gnu/emacs/EmacsOpenActivity.java     char[] buffer;</span>
<span class='curline'><a href='../S/119.html#L169'>buffer</a>            169 java/org/gnu/emacs/EmacsOpenActivity.java 	buffer = new char[2048];</span>
<span class='curline'><a href='../S/119.html#L171'>buffer</a>            171 java/org/gnu/emacs/EmacsOpenActivity.java 	while ((rc = reader.read (buffer, 0, 2048)) != -1)</span>
<span class='curline'><a href='../S/119.html#L172'>buffer</a>            172 java/org/gnu/emacs/EmacsOpenActivity.java 	  builder.append (buffer, 0, rc);</span>
<span class='curline'><a href='../S/119.html#L231'>buffer</a>            231 java/org/gnu/emacs/EmacsOpenActivity.java     byte buffer[];</span>
<span class='curline'><a href='../S/119.html#L263'>buffer</a>            263 java/org/gnu/emacs/EmacsOpenActivity.java     buffer = new byte[4098];</span>
<span class='curline'><a href='../S/119.html#L274'>buffer</a>            274 java/org/gnu/emacs/EmacsOpenActivity.java 	while ((read = stream.read (buffer)) &gt;= 0)</span>
<span class='curline'><a href='../S/119.html#L275'>buffer</a>            275 java/org/gnu/emacs/EmacsOpenActivity.java 	  outStream.write (buffer, 0, read);</span>
<span class='curline'><a href='../S/2975.html#L3558'>buffer</a>           3558 lib-src/ebrowse.c   static char *buffer;</span>
<span class='curline'><a href='../S/2975.html#L3572'>buffer</a>           3572 lib-src/ebrowse.c 	  buffer = (char *) xrealloc (buffer, buffer_size);</span>
<span class='curline'><a href='../S/2975.html#L3575'>buffer</a>           3575 lib-src/ebrowse.c       char *z = stpcpy (buffer, path-&gt;path);</span>
<span class='curline'><a href='../S/2975.html#L3578'>buffer</a>           3578 lib-src/ebrowse.c       fp = fopen (buffer, "r");</span>
<span class='curline'><a href='../S/2975.html#L3701'>buffer</a>           3701 lib-src/ebrowse.c   static char *buffer;</span>
<span class='curline'><a href='../S/2975.html#L3710'>buffer</a>           3710 lib-src/ebrowse.c 	  buffer = (char *) xrealloc (buffer, buffer_size);</span>
<span class='curline'><a href='../S/2975.html#L3713'>buffer</a>           3713 lib-src/ebrowse.c       buffer[i++] = c;</span>
<span class='curline'><a href='../S/2975.html#L3722'>buffer</a>           3722 lib-src/ebrowse.c       buffer = (char *) xrealloc (buffer, buffer_size);</span>
<span class='curline'><a href='../S/2975.html#L3725'>buffer</a>           3725 lib-src/ebrowse.c   buffer[i] = '\0';</span>
<span class='curline'><a href='../S/2975.html#L3726'>buffer</a>           3726 lib-src/ebrowse.c   if (i &gt; 0 &amp;&amp; buffer[i - 1] == '\r')</span>
<span class='curline'><a href='../S/2975.html#L3727'>buffer</a>           3727 lib-src/ebrowse.c     buffer[i - 1] = '\0';</span>
<span class='curline'><a href='../S/2975.html#L3728'>buffer</a>           3728 lib-src/ebrowse.c   return buffer;</span>
<span class='curline'><a href='../S/2979.html#L377'>buffer</a>            377 lib-src/emacsclient.c 	  char *buffer = xmalloc (size);</span>
<span class='curline'><a href='../S/2979.html#L378'>buffer</a>            378 lib-src/emacsclient.c 	  if (ExpandEnvironmentStrings (value, buffer, size))</span>
<span class='curline'><a href='../S/2979.html#L382'>buffer</a>            382 lib-src/emacsclient.c 	      return buffer;</span>
<span class='curline'><a href='../S/2979.html#L386'>buffer</a>            386 lib-src/emacsclient.c 	  free (buffer);</span>
<span class='curline'><a href='../S/2966.html#L310'>buffer</a>            310 lib-src/etags.c   char *buffer;</span>
<span class='curline'><a href='../S/2966.html#L1342'>buffer</a>           1342 lib-src/etags.c 		    process_file_name (filename_lb.buffer, lang);</span>
<span class='curline'><a href='../S/2966.html#L1357'>buffer</a>           1357 lib-src/etags.c   free (lb.buffer);</span>
<span class='curline'><a href='../S/2966.html#L1358'>buffer</a>           1358 lib-src/etags.c   free (filebuf.buffer);</span>
<span class='curline'><a href='../S/2966.html#L1359'>buffer</a>           1359 lib-src/etags.c   free (token_name.buffer);</span>
<span class='curline'><a href='../S/2966.html#L1471'>buffer</a>           1471 lib-src/etags.c       if (strstr (line.buffer, buf) == NULL)</span>
<span class='curline'><a href='../S/2966.html#L1473'>buffer</a>           1473 lib-src/etags.c           fprintf (otags_f, "%s\n", line.buffer);</span>
<span class='curline'><a href='../S/2966.html#L1479'>buffer</a>           1479 lib-src/etags.c   free (line.buffer);</span>
<span class='curline'><a href='../S/2966.html#L1887'>buffer</a>           1887 lib-src/etags.c       &amp;&amp; lb.buffer[0] == '#'</span>
<span class='curline'><a href='../S/2966.html#L1888'>buffer</a>           1888 lib-src/etags.c       &amp;&amp; lb.buffer[1] == '!')</span>
<span class='curline'><a href='../S/2966.html#L1895'>buffer</a>           1895 lib-src/etags.c       lp = strrchr (lb.buffer+2, '/');</span>
<span class='curline'><a href='../S/2966.html#L1899'>buffer</a>           1899 lib-src/etags.c 	lp = skip_spaces (lb.buffer + 2);</span>
<span class='curline'><a href='../S/2966.html#L2952'>buffer</a>           2952 lib-src/etags.c       cn-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/2966.html#L2958'>buffer</a>           2958 lib-src/etags.c       strcpy (cn-&gt;buffer, cstack.cname[0]);</span>
<span class='curline'><a href='../S/2966.html#L2968'>buffer</a>           2968 lib-src/etags.c       memcpyz (stpcpy (cn-&gt;buffer + len, qualifier), s, slen);</span>
<span class='curline'><a href='../S/2966.html#L3203'>buffer</a>           3203 lib-src/etags.c 	   memcpyz (token_name.buffer, str, len);</span>
<span class='curline'><a href='../S/2966.html#L3220'>buffer</a>           3220 lib-src/etags.c 	       memcpyz (token_name.buffer + oldlen, str, len);</span>
<span class='curline'><a href='../S/2966.html#L3351'>buffer</a>           3351 lib-src/etags.c   lp = curlb.buffer;							\</span>
<span class='curline'><a href='../S/2966.html#L3374'>buffer</a>           3374 lib-src/etags.c     make_tag (token_name.buffer, token_name.len, isfun, token.line,</span>
<span class='curline'><a href='../S/2966.html#L3378'>buffer</a>           3378 lib-src/etags.c       make_tag (concat ("INVALID TOKEN:--&gt;", token_name.buffer, ""),</span>
<span class='curline'><a href='../S/2966.html#L3434'>buffer</a>           3434 lib-src/etags.c   lp = curlb.buffer;</span>
<span class='curline'><a href='../S/2966.html#L3584'>buffer</a>           3584 lib-src/etags.c 	      for (cp = newlb.buffer; cp &lt; lp-1; cp++)</span>
<span class='curline'><a href='../S/2966.html#L3658'>buffer</a>           3658 lib-src/etags.c 			  || consider_token (newlb.buffer + tokoff, toklen, c,</span>
<span class='curline'><a href='../S/2966.html#L3685'>buffer</a>           3685 lib-src/etags.c 				  memcpyz (stpcpy (token_name.buffer + len,</span>
<span class='curline'><a href='../S/2966.html#L3687'>buffer</a>           3687 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/2966.html#L3692'>buffer</a>           3692 lib-src/etags.c 				  memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/2966.html#L3693'>buffer</a>           3693 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/2966.html#L3704'>buffer</a>           3704 lib-src/etags.c 				  char *p1 = stpcpy (token_name.buffer, objtag);</span>
<span class='curline'><a href='../S/2966.html#L3706'>buffer</a>           3706 lib-src/etags.c 				  char *p3 = mempcpy (p2, newlb.buffer + tokoff,</span>
<span class='curline'><a href='../S/2966.html#L3713'>buffer</a>           3713 lib-src/etags.c 				  memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/2966.html#L3714'>buffer</a>           3714 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/2966.html#L3727'>buffer</a>           3727 lib-src/etags.c 			      bool defun = (newlb.buffer[tokoff] == 'F');</span>
<span class='curline'><a href='../S/2966.html#L3738'>buffer</a>           3738 lib-src/etags.c 				  memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/2966.html#L3739'>buffer</a>           3739 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/2966.html#L3744'>buffer</a>           3744 lib-src/etags.c 				  token.line = newlb.buffer;</span>
<span class='curline'><a href='../S/2966.html#L3752'>buffer</a>           3752 lib-src/etags.c 			      memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/2966.html#L3753'>buffer</a>           3753 lib-src/etags.c 				       newlb.buffer + off, len);</span>
<span class='curline'><a href='../S/2966.html#L3756'>buffer</a>           3756 lib-src/etags.c 				  if (token_name.buffer[len] == '_')</span>
<span class='curline'><a href='../S/2966.html#L3757'>buffer</a>           3757 lib-src/etags.c 				    token_name.buffer[len] = '-';</span>
<span class='curline'><a href='../S/2966.html#L3763'>buffer</a>           3763 lib-src/etags.c 			      memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/2966.html#L3764'>buffer</a>           3764 lib-src/etags.c 				       newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/2966.html#L3779'>buffer</a>           3779 lib-src/etags.c 			  token.line = newlb.buffer;</span>
<span class='curline'><a href='../S/2966.html#L3854'>buffer</a>           3854 lib-src/etags.c 	      if (!yacc_rules || lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/2966.html#L3856'>buffer</a>           3856 lib-src/etags.c 		  tokoff = lp - 1 - newlb.buffer;</span>
<span class='curline'><a href='../S/2966.html#L3892'>buffer</a>           3892 lib-src/etags.c 		  strcpy (token_name.buffer + toklen, ":");</span>
<span class='curline'><a href='../S/2966.html#L4148'>buffer</a>           4148 lib-src/etags.c 		  char *cc, *uqname = token_name.buffer;</span>
<span class='curline'><a href='../S/2966.html#L4149'>buffer</a>           4149 lib-src/etags.c 		  char *tok_end = token_name.buffer + token_name.len;</span>
<span class='curline'><a href='../S/2966.html#L4151'>buffer</a>           4151 lib-src/etags.c 		  for (cc = token_name.buffer; cc &lt; tok_end; cc++)</span>
<span class='curline'><a href='../S/2966.html#L4159'>buffer</a>           4159 lib-src/etags.c 		  if (uqname &gt; token_name.buffer)</span>
<span class='curline'><a href='../S/2966.html#L4163'>buffer</a>           4163 lib-src/etags.c 		      memmove (token_name.buffer, uqname, uqlen + 1);</span>
<span class='curline'><a href='../S/2966.html#L4226'>buffer</a>           4226 lib-src/etags.c 	  if (!ignoreindent &amp;&amp; lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/2966.html#L4324'>buffer</a>           4324 lib-src/etags.c   free (lbs[0].lb.buffer);</span>
<span class='curline'><a href='../S/2966.html#L4325'>buffer</a>           4325 lib-src/etags.c   free (lbs[1].lb.buffer);</span>
<span class='curline'><a href='../S/2966.html#L4378'>buffer</a>           4378 lib-src/etags.c 	     (char_pointer) = (line_buffer).buffer,			\</span>
<span class='curline'><a href='../S/2966.html#L4442'>buffer</a>           4442 lib-src/etags.c       dbp = lb.buffer;</span>
<span class='curline'><a href='../S/2966.html#L4453'>buffer</a>           4453 lib-src/etags.c 	    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L4530'>buffer</a>           4530 lib-src/etags.c 			  lb.buffer, dbp - lb.buffer, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L4558'>buffer</a>           4558 lib-src/etags.c 	  make_tag (name, cp - name, false, lb.buffer,</span>
<span class='curline'><a href='../S/2966.html#L4559'>buffer</a>           4559 lib-src/etags.c 		    cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L4581'>buffer</a>           4581 lib-src/etags.c 	      make_tag (name, cp - name, true, lb.buffer,</span>
<span class='curline'><a href='../S/2966.html#L4582'>buffer</a>           4582 lib-src/etags.c 			cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L4600'>buffer</a>           4600 lib-src/etags.c 	  make_tag (name, cp - name, false, lb.buffer,</span>
<span class='curline'><a href='../S/2966.html#L4601'>buffer</a>           4601 lib-src/etags.c 		    cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L4629'>buffer</a>           4629 lib-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/2966.html#L4669'>buffer</a>           4669 lib-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L4807'>buffer</a>           4807 lib-src/etags.c 	    make_tag (lb.buffer, cp - lb.buffer, true,</span>
<span class='curline'><a href='../S/2966.html#L4808'>buffer</a>           4808 lib-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L4862'>buffer</a>           4862 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L4874'>buffer</a>           4874 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L4879'>buffer</a>           4879 lib-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L4920'>buffer</a>           4920 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L4947'>buffer</a>           4947 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L4990'>buffer</a>           4990 lib-src/etags.c 			    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L5031'>buffer</a>           5031 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L5073'>buffer</a>           5073 lib-src/etags.c 				  lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/2966.html#L5083'>buffer</a>           5083 lib-src/etags.c 			pfnote (wr_name, true, lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/2966.html#L5087'>buffer</a>           5087 lib-src/etags.c 				   curfdp-&gt;taggedfname, lineno, lb.buffer);</span>
<span class='curline'><a href='../S/2966.html#L5094'>buffer</a>           5094 lib-src/etags.c 				    lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/2966.html#L5159'>buffer</a>           5159 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/2966.html#L5193'>buffer</a>           5193 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L5206'>buffer</a>           5206 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L5219'>buffer</a>           5219 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L5234'>buffer</a>           5234 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L5244'>buffer</a>           5244 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L5275'>buffer</a>           5275 lib-src/etags.c 		  lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L5299'>buffer</a>           5299 lib-src/etags.c 	  char * namestart = skip_spaces (lb.buffer);</span>
<span class='curline'><a href='../S/2966.html#L5304'>buffer</a>           5304 lib-src/etags.c 		    lb.buffer, bp - lb.buffer + 2, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L5341'>buffer</a>           5341 lib-src/etags.c   dbp = lb.buffer;</span>
<span class='curline'><a href='../S/2966.html#L5358'>buffer</a>           5358 lib-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/2966.html#L5440'>buffer</a>           5440 lib-src/etags.c 			tline.buffer, taglen, save_lineno, save_lcno);</span>
<span class='curline'><a href='../S/2966.html#L5457'>buffer</a>           5457 lib-src/etags.c 	  strcpy (tline.buffer, lb.buffer);</span>
<span class='curline'><a href='../S/2966.html#L5460'>buffer</a>           5460 lib-src/etags.c 	  name = tline.buffer + (dbp - lb.buffer);</span>
<span class='curline'><a href='../S/2966.html#L5462'>buffer</a>           5462 lib-src/etags.c 	  taglen = cp - lb.buffer + 1;</span>
<span class='curline'><a href='../S/2966.html#L5488'>buffer</a>           5488 lib-src/etags.c   free (tline.buffer);</span>
<span class='curline'><a href='../S/2966.html#L5631'>buffer</a>           5631 lib-src/etags.c 		    lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L5687'>buffer</a>           5687 lib-src/etags.c 		      true, lb.buffer, name_end - lb.buffer,</span>
<span class='curline'><a href='../S/2966.html#L5797'>buffer</a>           5797 lib-src/etags.c 	  for (key = TEX_toktab; key-&gt;buffer != NULL; key++)</span>
<span class='curline'><a href='../S/2966.html#L5798'>buffer</a>           5798 lib-src/etags.c 	    if (strneq (cp, key-&gt;buffer, key-&gt;len))</span>
<span class='curline'><a href='../S/2966.html#L5821'>buffer</a>           5821 lib-src/etags.c 		    linelen = p - lb.buffer + 1;</span>
<span class='curline'><a href='../S/2966.html#L5824'>buffer</a>           5824 lib-src/etags.c 			  lb.buffer, linelen, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L5868'>buffer</a>           5868 lib-src/etags.c 	  TEX_toktab[i].buffer = savenstr (env, p - env);</span>
<span class='curline'><a href='../S/2966.html#L5876'>buffer</a>           5876 lib-src/etags.c 	  TEX_toktab[i].buffer = NULL; /* Mark end of table. */</span>
<span class='curline'><a href='../S/2966.html#L5896'>buffer</a>           5896 lib-src/etags.c 		  lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L5961'>buffer</a>           5961 lib-src/etags.c 		memcpyz (token_name.buffer, dbp, end - dbp);</span>
<span class='curline'><a href='../S/2966.html#L5986'>buffer</a>           5986 lib-src/etags.c 	    make_tag (token_name.buffer, token_name.len, true,</span>
<span class='curline'><a href='../S/2966.html#L6074'>buffer</a>           6074 lib-src/etags.c       for (cp = plb-&gt;buffer; *cp != '\0'; cp++)</span>
<span class='curline'><a href='../S/2966.html#L6395'>buffer</a>           6395 lib-src/etags.c       for (cp = plb-&gt;buffer; *cp != '\0'; ++cp)</span>
<span class='curline'><a href='../S/2966.html#L6933'>buffer</a>           6933 lib-src/etags.c 	  analyze_regex (regexbuf.buffer);</span>
<span class='curline'><a href='../S/2966.html#L6934'>buffer</a>           6934 lib-src/etags.c 	free (regexbuf.buffer);</span>
<span class='curline'><a href='../S/2966.html#L7153'>buffer</a>           7153 lib-src/etags.c   char *buffer = filebuf.buffer;</span>
<span class='curline'><a href='../S/2966.html#L7175'>buffer</a>           7175 lib-src/etags.c 	  match = re_search (rp-&gt;pat, buffer, filebuf.len, charno,</span>
<span class='curline'><a href='../S/2966.html#L7206'>buffer</a>           7206 lib-src/etags.c 		if (buffer[charno++] == '\n')</span>
<span class='curline'><a href='../S/2966.html#L7212'>buffer</a>           7212 lib-src/etags.c 		name = substitute (buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/2966.html#L7215'>buffer</a>           7215 lib-src/etags.c 	      pfnote (name, true, buffer + linecharno,</span>
<span class='curline'><a href='../S/2966.html#L7221'>buffer</a>           7221 lib-src/etags.c 			 lineno, buffer + linecharno);</span>
<span class='curline'><a href='../S/2966.html#L7255'>buffer</a>           7255 lib-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L7274'>buffer</a>           7274 lib-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L7297'>buffer</a>           7297 lib-src/etags.c   char *buffer = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/2966.html#L7298'>buffer</a>           7298 lib-src/etags.c   char *p = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/2966.html#L7310'>buffer</a>           7310 lib-src/etags.c 	  xrnew (buffer, lbp-&gt;size, 2);</span>
<span class='curline'><a href='../S/2966.html#L7311'>buffer</a>           7311 lib-src/etags.c 	  p = buffer + lbp-&gt;size;</span>
<span class='curline'><a href='../S/2966.html#L7313'>buffer</a>           7313 lib-src/etags.c 	  pend = buffer + lbp-&gt;size;</span>
<span class='curline'><a href='../S/2966.html#L7314'>buffer</a>           7314 lib-src/etags.c 	  lbp-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/2966.html#L7326'>buffer</a>           7326 lib-src/etags.c           if (!leave_cr &amp;&amp; p &gt; buffer &amp;&amp; p[-1] == '\r')</span>
<span class='curline'><a href='../S/2966.html#L7340'>buffer</a>           7340 lib-src/etags.c   lbp-&gt;len = p - buffer;</span>
<span class='curline'><a href='../S/2966.html#L7348'>buffer</a>           7348 lib-src/etags.c 	  xrnew (filebuf.buffer, filebuf.size, 2);</span>
<span class='curline'><a href='../S/2966.html#L7351'>buffer</a>           7351 lib-src/etags.c       strcpy (mempcpy (filebuf.buffer + filebuf.len, lbp-&gt;buffer, lbp-&gt;len),</span>
<span class='curline'><a href='../S/2966.html#L7378'>buffer</a>           7378 lib-src/etags.c       if (result &gt; 12 &amp;&amp; strneq (lbp-&gt;buffer, "#line ", 6))</span>
<span class='curline'><a href='../S/2966.html#L7383'>buffer</a>           7383 lib-src/etags.c 	  if (sscanf (lbp-&gt;buffer, "#line %"SCNdMAX" \"%n", &amp;lno, &amp;start) &gt;= 1</span>
<span class='curline'><a href='../S/2966.html#L7386'>buffer</a>           7386 lib-src/etags.c 	      char *endp = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/2966.html#L7399'>buffer</a>           7399 lib-src/etags.c 		  name = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/2966.html#L7508'>buffer</a>           7508 lib-src/etags.c 	  match = re_match (rp-&gt;pat, lbp-&gt;buffer, lbp-&gt;len, 0, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/2966.html#L7537'>buffer</a>           7537 lib-src/etags.c 		name = substitute (lbp-&gt;buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/2966.html#L7540'>buffer</a>           7540 lib-src/etags.c 	      pfnote (name, true, lbp-&gt;buffer, match, lineno, linecharno);</span>
<span class='curline'><a href='../S/2966.html#L7545'>buffer</a>           7545 lib-src/etags.c 			 lineno, lbp-&gt;buffer);</span>
<span class='curline'><a href='../S/2966.html#L7999'>buffer</a>           7999 lib-src/etags.c   lbp-&gt;buffer = xnew (lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/2966.html#L8000'>buffer</a>           8000 lib-src/etags.c   lbp-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/2966.html#L8011'>buffer</a>           8011 lib-src/etags.c       xrnew (lbp-&gt;buffer, lbp-&gt;size, multiplier);</span>
<span class='curline'><a href='../S/2970.html#L267'>buffer</a>            267 lib-src/pop.c    server-&gt;buffer = (char *) malloc (GETLINE_MIN);</span>
<span class='curline'><a href='../S/2970.html#L268'>buffer</a>            268 lib-src/pop.c    if (! server-&gt;buffer)</span>
<span class='curline'><a href='../S/2970.html#L950'>buffer</a>            950 lib-src/pop.c    free (server-&gt;buffer);</span>
<span class='curline'><a href='../S/2970.html#L1237'>buffer</a>           1237 lib-src/pop.c        char *cp = find_crlf (server-&gt;buffer + server-&gt;buffer_index,</span>
<span class='curline'><a href='../S/2970.html#L1245'>buffer</a>           1245 lib-src/pop.c  	  data_used = (cp + 2) - server-&gt;buffer - found;</span>
<span class='curline'><a href='../S/2970.html#L1254'>buffer</a>           1254 lib-src/pop.c  	    fprintf (stderr, "&lt;&lt;&lt; %s\n", server-&gt;buffer + found);</span>
<span class='curline'><a href='../S/2970.html#L1255'>buffer</a>           1255 lib-src/pop.c  	  *line = server-&gt;buffer + found;</span>
<span class='curline'><a href='../S/2970.html#L1260'>buffer</a>           1260 lib-src/pop.c  	  memmove (server-&gt;buffer, server-&gt;buffer + server-&gt;buffer_index,</span>
<span class='curline'><a href='../S/2970.html#L1286'>buffer</a>           1286 lib-src/pop.c  	  server-&gt;buffer = (char *)realloc (server-&gt;buffer, server-&gt;buffer_size);</span>
<span class='curline'><a href='../S/2970.html#L1287'>buffer</a>           1287 lib-src/pop.c  	  if (! server-&gt;buffer)</span>
<span class='curline'><a href='../S/2970.html#L1294'>buffer</a>           1294 lib-src/pop.c        ret = RECV (server-&gt;file, server-&gt;buffer + server-&gt;data,</span>
<span class='curline'><a href='../S/2970.html#L1313'>buffer</a>           1313 lib-src/pop.c  	  server-&gt;buffer[server-&gt;data] = '\0';</span>
<span class='curline'><a href='../S/2970.html#L1315'>buffer</a>           1315 lib-src/pop.c  	  cp = find_crlf (server-&gt;buffer + search_offset,</span>
<span class='curline'><a href='../S/2970.html#L1319'>buffer</a>           1319 lib-src/pop.c  	      int data_used = (cp + 2) - server-&gt;buffer;</span>
<span class='curline'><a href='../S/2970.html#L1325'>buffer</a>           1325 lib-src/pop.c  		fprintf (stderr, "&lt;&lt;&lt; %s\n", server-&gt;buffer);</span>
<span class='curline'><a href='../S/2970.html#L1326'>buffer</a>           1326 lib-src/pop.c  	      *line = server-&gt;buffer;</span>
<span class='curline'><a href='../S/2970.html#L1531'>buffer</a>           1531 lib-src/pop.c        if (server-&gt;buffer)</span>
<span class='curline'><a href='../S/2970.html#L1533'>buffer</a>           1533 lib-src/pop.c  	  free (server-&gt;buffer);</span>
<span class='curline'><a href='../S/2970.html#L1534'>buffer</a>           1534 lib-src/pop.c  	  server-&gt;buffer = 0;</span>
<span class='curline'><a href='../S/2973.html#L35'>buffer</a>             35 lib-src/pop.h    char *buffer;</span>
<span class='curline'><a href='../S/2737.html#L61'>buffer</a>             61 lib/af_alg.h   afalg_buffer (const char *buffer, size_t len, const char *alg,</span>
<span class='curline'><a href='../S/2737.html#L96'>buffer</a>             96 lib/af_alg.h   afalg_buffer (const char *buffer, size_t len, const char *alg,</span>
<span class='curline'><a href='../S/2875.html#L64'>buffer</a>             64 lib/careadlinkat.c               char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2875.html#L72'>buffer</a>             72 lib/careadlinkat.c   if (!buffer)</span>
<span class='curline'><a href='../S/2875.html#L74'>buffer</a>             74 lib/careadlinkat.c       buffer = stack_buf;</span>
<span class='curline'><a href='../S/2875.html#L78'>buffer</a>             78 lib/careadlinkat.c   char *buf = buffer;</span>
<span class='curline'><a href='../S/2875.html#L88'>buffer</a>             88 lib/careadlinkat.c           if (buf != buffer)</span>
<span class='curline'><a href='../S/2875.html#L112'>buffer</a>            112 lib/careadlinkat.c           if (link_size &lt; buf_size &amp;&amp; buf != buffer &amp;&amp; alloc-&gt;reallocate)</span>
<span class='curline'><a href='../S/2875.html#L123'>buffer</a>            123 lib/careadlinkat.c       if (buf != buffer)</span>
<span class='curline'><a href='../S/2875.html#L167'>buffer</a>            167 lib/careadlinkat.c               char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2875.html#L180'>buffer</a>            180 lib/careadlinkat.c   return readlink_stk (fd, filename, buffer, buffer_size, alloc,</span>
<span class='curline'><a href='../S/2786.html#L55'>buffer</a>             55 lib/careadlinkat.h                     char *restrict buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2761.html#L34'>buffer</a>             34 lib/execinfo.in.h backtrace (void **buffer, int size)</span>
<span class='curline'><a href='../S/2761.html#L36'>buffer</a>             36 lib/execinfo.in.h   (void) buffer;</span>
<span class='curline'><a href='../S/2761.html#L42'>buffer</a>             42 lib/execinfo.in.h backtrace_symbols (void *const *buffer, int size)</span>
<span class='curline'><a href='../S/2761.html#L44'>buffer</a>             44 lib/execinfo.in.h   (void) buffer;</span>
<span class='curline'><a href='../S/2761.html#L50'>buffer</a>             50 lib/execinfo.in.h backtrace_symbols_fd (void *const *buffer, int size, int fd)</span>
<span class='curline'><a href='../S/2761.html#L52'>buffer</a>             52 lib/execinfo.in.h   (void) buffer;</span>
<span class='curline'><a href='../S/2914.html#L112'>buffer</a>            112 lib/getrandom.c getrandom (void *buffer, size_t length, unsigned int flags)</span>
<span class='curline'><a href='../S/2914.html#L128'>buffer</a>            128 lib/getrandom.c           &amp;&amp; BCryptGenRandomFunc (NULL, buffer, length,</span>
<span class='curline'><a href='../S/2914.html#L153'>buffer</a>            153 lib/getrandom.c         if (!CryptGenRandom (provider, length, buffer))</span>
<span class='curline'><a href='../S/2914.html#L165'>buffer</a>            165 lib/getrandom.c   return getrandom (buffer, length, flags);</span>
<span class='curline'><a href='../S/2914.html#L188'>buffer</a>            188 lib/getrandom.c   return read (fd, buffer, length);</span>
<span class='curline'><a href='../S/2925.html#L75'>buffer</a>             75 lib/malloc/scratch_buffer.h scratch_buffer_init (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2925.html#L77'>buffer</a>             77 lib/malloc/scratch_buffer.h   buffer-&gt;data = buffer-&gt;__space.__c;</span>
<span class='curline'><a href='../S/2925.html#L78'>buffer</a>             78 lib/malloc/scratch_buffer.h   buffer-&gt;length = sizeof (buffer-&gt;__space);</span>
<span class='curline'><a href='../S/2925.html#L83'>buffer</a>             83 lib/malloc/scratch_buffer.h scratch_buffer_free (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2925.html#L85'>buffer</a>             85 lib/malloc/scratch_buffer.h   if (buffer-&gt;data != buffer-&gt;__space.__c)</span>
<span class='curline'><a href='../S/2925.html#L86'>buffer</a>             86 lib/malloc/scratch_buffer.h     free (buffer-&gt;data);</span>
<span class='curline'><a href='../S/2925.html#L94'>buffer</a>             94 lib/malloc/scratch_buffer.h bool __libc_scratch_buffer_grow (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2925.html#L99'>buffer</a>             99 lib/malloc/scratch_buffer.h scratch_buffer_grow (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2925.html#L101'>buffer</a>            101 lib/malloc/scratch_buffer.h   return __glibc_likely (__libc_scratch_buffer_grow (buffer));</span>
<span class='curline'><a href='../S/2925.html#L106'>buffer</a>            106 lib/malloc/scratch_buffer.h bool __libc_scratch_buffer_grow_preserve (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2925.html#L111'>buffer</a>            111 lib/malloc/scratch_buffer.h scratch_buffer_grow_preserve (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2925.html#L113'>buffer</a>            113 lib/malloc/scratch_buffer.h   return __glibc_likely (__libc_scratch_buffer_grow_preserve (buffer));</span>
<span class='curline'><a href='../S/2925.html#L122'>buffer</a>            122 lib/malloc/scratch_buffer.h bool __libc_scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2925.html#L128'>buffer</a>            128 lib/malloc/scratch_buffer.h scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2925.html#L132'>buffer</a>            132 lib/malloc/scratch_buffer.h 			 (buffer, nelem, size));</span>
<span class='curline'><a href='../S/2931.html#L27'>buffer</a>             27 lib/malloc/scratch_buffer_dupfree.c __libc_scratch_buffer_dupfree (struct scratch_buffer *buffer, size_t size)</span>
<span class='curline'><a href='../S/2931.html#L29'>buffer</a>             29 lib/malloc/scratch_buffer_dupfree.c   void *data = buffer-&gt;data;</span>
<span class='curline'><a href='../S/2931.html#L30'>buffer</a>             30 lib/malloc/scratch_buffer_dupfree.c   if (data == buffer-&gt;__space.__c)</span>
<span class='curline'><a href='../S/2929.html#L27'>buffer</a>             27 lib/malloc/scratch_buffer_grow.c __libc_scratch_buffer_grow (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2929.html#L30'>buffer</a>             30 lib/malloc/scratch_buffer_grow.c   size_t new_length = buffer-&gt;length * 2;</span>
<span class='curline'><a href='../S/2929.html#L33'>buffer</a>             33 lib/malloc/scratch_buffer_grow.c   scratch_buffer_free (buffer);</span>
<span class='curline'><a href='../S/2929.html#L36'>buffer</a>             36 lib/malloc/scratch_buffer_grow.c   if (__glibc_likely (new_length &gt;= buffer-&gt;length))</span>
<span class='curline'><a href='../S/2929.html#L47'>buffer</a>             47 lib/malloc/scratch_buffer_grow.c       scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2929.html#L52'>buffer</a>             52 lib/malloc/scratch_buffer_grow.c   buffer-&gt;data = new_ptr;</span>
<span class='curline'><a href='../S/2929.html#L53'>buffer</a>             53 lib/malloc/scratch_buffer_grow.c   buffer-&gt;length = new_length;</span>
<span class='curline'><a href='../S/2920.html#L28'>buffer</a>             28 lib/malloc/scratch_buffer_grow_preserve.c __libc_scratch_buffer_grow_preserve (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2920.html#L30'>buffer</a>             30 lib/malloc/scratch_buffer_grow_preserve.c   size_t new_length = 2 * buffer-&gt;length;</span>
<span class='curline'><a href='../S/2920.html#L33'>buffer</a>             33 lib/malloc/scratch_buffer_grow_preserve.c   if (buffer-&gt;data == buffer-&gt;__space.__c)</span>
<span class='curline'><a href='../S/2920.html#L40'>buffer</a>             40 lib/malloc/scratch_buffer_grow_preserve.c       memcpy (new_ptr, buffer-&gt;__space.__c, buffer-&gt;length);</span>
<span class='curline'><a href='../S/2920.html#L45'>buffer</a>             45 lib/malloc/scratch_buffer_grow_preserve.c       if (__glibc_likely (new_length &gt;= buffer-&gt;length))</span>
<span class='curline'><a href='../S/2920.html#L46'>buffer</a>             46 lib/malloc/scratch_buffer_grow_preserve.c 	new_ptr = realloc (buffer-&gt;data, new_length);</span>
<span class='curline'><a href='../S/2920.html#L56'>buffer</a>             56 lib/malloc/scratch_buffer_grow_preserve.c 	  free (buffer-&gt;data);</span>
<span class='curline'><a href='../S/2920.html#L57'>buffer</a>             57 lib/malloc/scratch_buffer_grow_preserve.c 	  scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2920.html#L63'>buffer</a>             63 lib/malloc/scratch_buffer_grow_preserve.c   buffer-&gt;data = new_ptr;</span>
<span class='curline'><a href='../S/2920.html#L64'>buffer</a>             64 lib/malloc/scratch_buffer_grow_preserve.c   buffer-&gt;length = new_length;</span>
<span class='curline'><a href='../S/2928.html#L28'>buffer</a>             28 lib/malloc/scratch_buffer_set_array_size.c __libc_scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2928.html#L39'>buffer</a>             39 lib/malloc/scratch_buffer_set_array_size.c       scratch_buffer_free (buffer);</span>
<span class='curline'><a href='../S/2928.html#L40'>buffer</a>             40 lib/malloc/scratch_buffer_set_array_size.c       scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2928.html#L45'>buffer</a>             45 lib/malloc/scratch_buffer_set_array_size.c   if (new_length &lt;= buffer-&gt;length)</span>
<span class='curline'><a href='../S/2928.html#L49'>buffer</a>             49 lib/malloc/scratch_buffer_set_array_size.c   scratch_buffer_free (buffer);</span>
<span class='curline'><a href='../S/2928.html#L55'>buffer</a>             55 lib/malloc/scratch_buffer_set_array_size.c       scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2928.html#L60'>buffer</a>             60 lib/malloc/scratch_buffer_set_array_size.c   buffer-&gt;data = new_ptr;</span>
<span class='curline'><a href='../S/2928.html#L61'>buffer</a>             61 lib/malloc/scratch_buffer_set_array_size.c   buffer-&gt;length = new_length;</span>
<span class='curline'><a href='../S/2910.html#L69'>buffer</a>             69 lib/md5-stream.c   char *buffer = malloc (BLOCKSIZE + 72);</span>
<span class='curline'><a href='../S/2910.html#L70'>buffer</a>             70 lib/md5-stream.c   if (!buffer)</span>
<span class='curline'><a href='../S/2910.html#L97'>buffer</a>             97 lib/md5-stream.c           n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);</span>
<span class='curline'><a href='../S/2910.html#L111'>buffer</a>            111 lib/md5-stream.c                   free (buffer);</span>
<span class='curline'><a href='../S/2910.html#L121'>buffer</a>            121 lib/md5-stream.c       md5_process_block (buffer, BLOCKSIZE, &amp;ctx);</span>
<span class='curline'><a href='../S/2910.html#L128'>buffer</a>            128 lib/md5-stream.c     md5_process_bytes (buffer, sum, &amp;ctx);</span>
<span class='curline'><a href='../S/2910.html#L132'>buffer</a>            132 lib/md5-stream.c   free (buffer);</span>
<span class='curline'><a href='../S/2874.html#L115'>buffer</a>            115 lib/md5.c        ctx-&gt;buffer[size - 2] = SWAP (ctx-&gt;total[0] &lt;&lt; 3);</span>
<span class='curline'><a href='../S/2874.html#L116'>buffer</a>            116 lib/md5.c        ctx-&gt;buffer[size - 1] = SWAP ((ctx-&gt;total[1] &lt;&lt; 3) | (ctx-&gt;total[0] &gt;&gt; 29));</span>
<span class='curline'><a href='../S/2874.html#L118'>buffer</a>            118 lib/md5.c        memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);</span>
<span class='curline'><a href='../S/2874.html#L121'>buffer</a>            121 lib/md5.c        md5_process_block (ctx-&gt;buffer, size * 4, ctx);</span>
<span class='curline'><a href='../S/2874.html#L131'>buffer</a>            131 lib/md5.c      md5_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2874.html#L139'>buffer</a>            139 lib/md5.c        md5_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2874.html#L147'>buffer</a>            147 lib/md5.c      md5_process_bytes (const void *buffer, size_t len, struct md5_ctx *ctx)</span>
<span class='curline'><a href='../S/2874.html#L156'>buffer</a>            156 lib/md5.c            memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2874.html#L161'>buffer</a>            161 lib/md5.c                md5_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2874.html#L166'>buffer</a>            166 lib/md5.c                memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2874.html#L167'>buffer</a>            167 lib/md5.c                        &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~63],</span>
<span class='curline'><a href='../S/2874.html#L171'>buffer</a>            171 lib/md5.c            buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2874.html#L180'>buffer</a>            180 lib/md5.c            if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2874.html#L183'>buffer</a>            183 lib/md5.c                  md5_process_block (memcpy (ctx-&gt;buffer, buffer, 64), 64, ctx);</span>
<span class='curline'><a href='../S/2874.html#L184'>buffer</a>            184 lib/md5.c                  buffer = (const char *) buffer + 64;</span>
<span class='curline'><a href='../S/2874.html#L190'>buffer</a>            190 lib/md5.c                md5_process_block (buffer, len &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2874.html#L191'>buffer</a>            191 lib/md5.c                buffer = (const char *) buffer + (len &amp; ~63);</span>
<span class='curline'><a href='../S/2874.html#L201'>buffer</a>            201 lib/md5.c            memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2874.html#L205'>buffer</a>            205 lib/md5.c                md5_process_block (ctx-&gt;buffer, 64, ctx);</span>
<span class='curline'><a href='../S/2874.html#L209'>buffer</a>            209 lib/md5.c                memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2874.html#L229'>buffer</a>            229 lib/md5.c      md5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)</span>
<span class='curline'><a href='../S/2874.html#L232'>buffer</a>            232 lib/md5.c        const uint32_t *words = buffer;</span>
<span class='curline'><a href='../S/2791.html#L86'>buffer</a>             86 lib/md5.h        uint32_t buffer[32]; /* 128 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2791.html#L102'>buffer</a>            102 lib/md5.h      extern void __md5_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2791.html#L109'>buffer</a>            109 lib/md5.h      extern void __md5_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2791.html#L131'>buffer</a>            131 lib/md5.h      extern void *__md5_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2954.html#L253'>buffer</a>            253 lib/regcomp.c    re_dfa_t *dfa = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2954.html#L284'>buffer</a>            284 lib/regcomp.c    re_dfa_t *dfa = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2954.html#L445'>buffer</a>            445 lib/regcomp.c    preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2954.html#L609'>buffer</a>            609 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2954.html#L615'>buffer</a>            615 lib/regcomp.c    preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2954.html#L649'>buffer</a>            649 lib/regcomp.c        if (!re_comp_buf.buffer)</span>
<span class='curline'><a href='../S/2954.html#L654'>buffer</a>            654 lib/regcomp.c    if (re_comp_buf.buffer)</span>
<span class='curline'><a href='../S/2954.html#L717'>buffer</a>            717 lib/regcomp.c    dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2954.html#L724'>buffer</a>            724 lib/regcomp.c        dfa = re_realloc (preg-&gt;buffer, re_dfa_t, 1);</span>
<span class='curline'><a href='../S/2954.html#L728'>buffer</a>            728 lib/regcomp.c        preg-&gt;buffer = dfa;</span>
<span class='curline'><a href='../S/2954.html#L738'>buffer</a>            738 lib/regcomp.c        preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2954.html#L757'>buffer</a>            757 lib/regcomp.c        preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2954.html#L788'>buffer</a>            788 lib/regcomp.c        preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2954.html#L944'>buffer</a>            944 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2954.html#L1127'>buffer</a>           1127 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2954.html#L1308'>buffer</a>           1308 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2954.html#L2084'>buffer</a>           2084 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2954.html#L2118'>buffer</a>           2118 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2954.html#L2168'>buffer</a>           2168 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2954.html#L2212'>buffer</a>           2212 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2954.html#L2444'>buffer</a>           2444 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2853.html#L417'>buffer</a>            417 lib/regex.h      struct re_dfa_t *__REPB_PREFIX(buffer);</span>
<span class='curline'><a href='../S/2933.html#L192'>buffer</a>            192 lib/regexec.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2933.html#L372'>buffer</a>            372 lib/regexec.c    re_dfa_t *dfa = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2933.html#L585'>buffer</a>            585 lib/regexec.c    const re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2933.html#L1368'>buffer</a>           1368 lib/regexec.c    const re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2744.html#L67'>buffer</a>             67 lib/scratch_buffer.h extern void scratch_buffer_init (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2744.html#L72'>buffer</a>             72 lib/scratch_buffer.h extern void scratch_buffer_free (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2744.html#L81'>buffer</a>             81 lib/scratch_buffer.h extern bool scratch_buffer_grow (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2744.html#L87'>buffer</a>             87 lib/scratch_buffer.h extern bool scratch_buffer_grow_preserve (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2744.html#L97'>buffer</a>             97 lib/scratch_buffer.h extern bool scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2899.html#L104'>buffer</a>            104 lib/sha1.c       ctx-&gt;buffer[size - 2] = SWAP ((ctx-&gt;total[1] &lt;&lt; 3) | (ctx-&gt;total[0] &gt;&gt; 29));</span>
<span class='curline'><a href='../S/2899.html#L105'>buffer</a>            105 lib/sha1.c       ctx-&gt;buffer[size - 1] = SWAP (ctx-&gt;total[0] &lt;&lt; 3);</span>
<span class='curline'><a href='../S/2899.html#L107'>buffer</a>            107 lib/sha1.c       memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);</span>
<span class='curline'><a href='../S/2899.html#L110'>buffer</a>            110 lib/sha1.c       sha1_process_block (ctx-&gt;buffer, size * 4, ctx);</span>
<span class='curline'><a href='../S/2899.html#L120'>buffer</a>            120 lib/sha1.c     sha1_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2899.html#L128'>buffer</a>            128 lib/sha1.c       sha1_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2899.html#L135'>buffer</a>            135 lib/sha1.c     sha1_process_bytes (const void *buffer, size_t len, struct sha1_ctx *ctx)</span>
<span class='curline'><a href='../S/2899.html#L144'>buffer</a>            144 lib/sha1.c           memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2899.html#L149'>buffer</a>            149 lib/sha1.c               sha1_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2899.html#L154'>buffer</a>            154 lib/sha1.c               memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2899.html#L155'>buffer</a>            155 lib/sha1.c                       &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~63],</span>
<span class='curline'><a href='../S/2899.html#L159'>buffer</a>            159 lib/sha1.c           buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2899.html#L168'>buffer</a>            168 lib/sha1.c           if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2899.html#L171'>buffer</a>            171 lib/sha1.c                 sha1_process_block (memcpy (ctx-&gt;buffer, buffer, 64), 64, ctx);</span>
<span class='curline'><a href='../S/2899.html#L172'>buffer</a>            172 lib/sha1.c                 buffer = (const char *) buffer + 64;</span>
<span class='curline'><a href='../S/2899.html#L178'>buffer</a>            178 lib/sha1.c               sha1_process_block (buffer, len &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2899.html#L179'>buffer</a>            179 lib/sha1.c               buffer = (const char *) buffer + (len &amp; ~63);</span>
<span class='curline'><a href='../S/2899.html#L189'>buffer</a>            189 lib/sha1.c           memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2899.html#L193'>buffer</a>            193 lib/sha1.c               sha1_process_block (ctx-&gt;buffer, 64, ctx);</span>
<span class='curline'><a href='../S/2899.html#L197'>buffer</a>            197 lib/sha1.c               memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2899.html#L222'>buffer</a>            222 lib/sha1.c     sha1_process_block (const void *buffer, size_t len, struct sha1_ctx *ctx)</span>
<span class='curline'><a href='../S/2899.html#L224'>buffer</a>            224 lib/sha1.c       const uint32_t *words = buffer;</span>
<span class='curline'><a href='../S/2890.html#L58'>buffer</a>             58 lib/sha1.h       uint32_t buffer[32]; /* 128 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2890.html#L68'>buffer</a>             68 lib/sha1.h     extern void sha1_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2890.html#L75'>buffer</a>             75 lib/sha1.h     extern void sha1_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2890.html#L95'>buffer</a>             95 lib/sha1.h     extern void *sha1_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2843.html#L137'>buffer</a>            137 lib/sha256.c     set_uint32 ((char *) &amp;ctx-&gt;buffer[size - 2],</span>
<span class='curline'><a href='../S/2843.html#L139'>buffer</a>            139 lib/sha256.c     set_uint32 ((char *) &amp;ctx-&gt;buffer[size - 1],</span>
<span class='curline'><a href='../S/2843.html#L142'>buffer</a>            142 lib/sha256.c     memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);</span>
<span class='curline'><a href='../S/2843.html#L145'>buffer</a>            145 lib/sha256.c     sha256_process_block (ctx-&gt;buffer, size * 4, ctx);</span>
<span class='curline'><a href='../S/2843.html#L167'>buffer</a>            167 lib/sha256.c   sha256_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2843.html#L175'>buffer</a>            175 lib/sha256.c     sha256_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2843.html#L182'>buffer</a>            182 lib/sha256.c   sha224_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2843.html#L190'>buffer</a>            190 lib/sha256.c     sha256_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2843.html#L197'>buffer</a>            197 lib/sha256.c   sha256_process_bytes (const void *buffer, size_t len, struct sha256_ctx *ctx)</span>
<span class='curline'><a href='../S/2843.html#L206'>buffer</a>            206 lib/sha256.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2843.html#L211'>buffer</a>            211 lib/sha256.c             sha256_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2843.html#L216'>buffer</a>            216 lib/sha256.c             memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2843.html#L217'>buffer</a>            217 lib/sha256.c                     &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~63],</span>
<span class='curline'><a href='../S/2843.html#L221'>buffer</a>            221 lib/sha256.c         buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2843.html#L230'>buffer</a>            230 lib/sha256.c         if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2843.html#L233'>buffer</a>            233 lib/sha256.c               sha256_process_block (memcpy (ctx-&gt;buffer, buffer, 64), 64, ctx);</span>
<span class='curline'><a href='../S/2843.html#L234'>buffer</a>            234 lib/sha256.c               buffer = (const char *) buffer + 64;</span>
<span class='curline'><a href='../S/2843.html#L240'>buffer</a>            240 lib/sha256.c             sha256_process_block (buffer, len &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2843.html#L241'>buffer</a>            241 lib/sha256.c             buffer = (const char *) buffer + (len &amp; ~63);</span>
<span class='curline'><a href='../S/2843.html#L251'>buffer</a>            251 lib/sha256.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2843.html#L255'>buffer</a>            255 lib/sha256.c             sha256_process_block (ctx-&gt;buffer, 64, ctx);</span>
<span class='curline'><a href='../S/2843.html#L259'>buffer</a>            259 lib/sha256.c             memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2843.html#L297'>buffer</a>            297 lib/sha256.c   sha256_process_block (const void *buffer, size_t len, struct sha256_ctx *ctx)</span>
<span class='curline'><a href='../S/2843.html#L299'>buffer</a>            299 lib/sha256.c     const uint32_t *words = buffer;</span>
<span class='curline'><a href='../S/2749.html#L56'>buffer</a>             56 lib/sha256.h     uint32_t buffer[32]; /* 128 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2749.html#L67'>buffer</a>             67 lib/sha256.h   extern void sha256_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2749.html#L74'>buffer</a>             74 lib/sha256.h   extern void sha256_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2749.html#L98'>buffer</a>             98 lib/sha256.h   extern void *sha256_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2749.html#L100'>buffer</a>            100 lib/sha256.h   extern void *sha224_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2813.html#L137'>buffer</a>            137 lib/sha512.c     set_uint64 ((char *) &amp;ctx-&gt;buffer[size - 2],</span>
<span class='curline'><a href='../S/2813.html#L140'>buffer</a>            140 lib/sha512.c     set_uint64 ((char *) &amp;ctx-&gt;buffer[size - 1],</span>
<span class='curline'><a href='../S/2813.html#L143'>buffer</a>            143 lib/sha512.c     memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 8 - bytes);</span>
<span class='curline'><a href='../S/2813.html#L146'>buffer</a>            146 lib/sha512.c     sha512_process_block (ctx-&gt;buffer, size * 8, ctx);</span>
<span class='curline'><a href='../S/2813.html#L168'>buffer</a>            168 lib/sha512.c   sha512_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2813.html#L176'>buffer</a>            176 lib/sha512.c     sha512_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2813.html#L183'>buffer</a>            183 lib/sha512.c   sha384_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2813.html#L191'>buffer</a>            191 lib/sha512.c     sha512_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2813.html#L198'>buffer</a>            198 lib/sha512.c   sha512_process_bytes (const void *buffer, size_t len, struct sha512_ctx *ctx)</span>
<span class='curline'><a href='../S/2813.html#L207'>buffer</a>            207 lib/sha512.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2813.html#L212'>buffer</a>            212 lib/sha512.c             sha512_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~127, ctx);</span>
<span class='curline'><a href='../S/2813.html#L217'>buffer</a>            217 lib/sha512.c             memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2813.html#L218'>buffer</a>            218 lib/sha512.c                     &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~127],</span>
<span class='curline'><a href='../S/2813.html#L222'>buffer</a>            222 lib/sha512.c         buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2813.html#L231'>buffer</a>            231 lib/sha512.c         if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2813.html#L234'>buffer</a>            234 lib/sha512.c               sha512_process_block (memcpy (ctx-&gt;buffer, buffer, 128), 128, ctx);</span>
<span class='curline'><a href='../S/2813.html#L235'>buffer</a>            235 lib/sha512.c               buffer = (const char *) buffer + 128;</span>
<span class='curline'><a href='../S/2813.html#L241'>buffer</a>            241 lib/sha512.c             sha512_process_block (buffer, len &amp; ~127, ctx);</span>
<span class='curline'><a href='../S/2813.html#L242'>buffer</a>            242 lib/sha512.c             buffer = (const char *) buffer + (len &amp; ~127);</span>
<span class='curline'><a href='../S/2813.html#L252'>buffer</a>            252 lib/sha512.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2813.html#L256'>buffer</a>            256 lib/sha512.c             sha512_process_block (ctx-&gt;buffer, 128, ctx);</span>
<span class='curline'><a href='../S/2813.html#L260'>buffer</a>            260 lib/sha512.c             memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2813.html#L322'>buffer</a>            322 lib/sha512.c   sha512_process_block (const void *buffer, size_t len, struct sha512_ctx *ctx)</span>
<span class='curline'><a href='../S/2813.html#L324'>buffer</a>            324 lib/sha512.c     u64 const *words = buffer;</span>
<span class='curline'><a href='../S/2821.html#L56'>buffer</a>             56 lib/sha512.h     u64 buffer[32]; /* 256 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2821.html#L67'>buffer</a>             67 lib/sha512.h   extern void sha512_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2821.html#L74'>buffer</a>             74 lib/sha512.h   extern void sha512_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2821.html#L101'>buffer</a>            101 lib/sha512.h   extern void *sha512_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2821.html#L103'>buffer</a>            103 lib/sha512.h   extern void *sha384_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2912.html#L79'>buffer</a>             79 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags)</span>
<span class='curline'><a href='../S/2912.html#L82'>buffer</a>             82 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags));</span>
<span class='curline'><a href='../S/2912.html#L86'>buffer</a>             86 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags)</span>
<span class='curline'><a href='../S/2912.html#L90'>buffer</a>             90 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags));</span>
<span class='curline'><a href='../S/2935.html#L1236'>buffer</a>           1236 lib/unistd.in.h _GL_FUNCDECL_RPL (getentropy, int, (void *buffer, size_t length));</span>
<span class='curline'><a href='../S/2935.html#L1237'>buffer</a>           1237 lib/unistd.in.h _GL_CXXALIAS_RPL (getentropy, int, (void *buffer, size_t length));</span>
<span class='curline'><a href='../S/2935.html#L1240'>buffer</a>           1240 lib/unistd.in.h _GL_FUNCDECL_SYS (getentropy, int, (void *buffer, size_t length));</span>
<span class='curline'><a href='../S/2935.html#L1242'>buffer</a>           1242 lib/unistd.in.h _GL_CXXALIAS_SYS (getentropy, int, (void *buffer, size_t length));</span>
<span class='curline'><a href='../S/20.html#L43'>buffer</a>             43 nt/cmdproxy.c  extern int _snprintf (char *buffer, size_t count, const char *format, ...);</span>
<span class='curline'><a href='../S/20.html#L284'>buffer</a>            284 nt/cmdproxy.c  search_dir (const char *dir, const char *exec, int bufsize, char *buffer)</span>
<span class='curline'><a href='../S/20.html#L307'>buffer</a>            307 nt/cmdproxy.c        rc = SearchPath (dir, exec_ext, NULL, bufsize, buffer, &amp;dummy);</span>
<span class='curline'><a href='../S/20.html#L315'>buffer</a>            315 nt/cmdproxy.c  	  rc = SearchPath (dir, exec_ext, NULL, bufsize, buffer, &amp;dummy);</span>
<span class='curline'><a href='../S/20.html#L324'>buffer</a>            324 nt/cmdproxy.c  	  rc = SearchPath (dir, exec, exts[i], bufsize, buffer, &amp;dummy);</span>
<span class='curline'><a href='../S/2351.html#L478'>buffer</a>            478 src/alloc.c    static void mark_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/2351.html#L3372'>buffer</a>           3372 src/alloc.c          eassert (! PSEUDOVEC_STRUCT (vector, Lisp_Marker)-&gt;buffer);</span>
<span class='curline'><a href='../S/2351.html#L3628'>buffer</a>           3628 src/alloc.c    struct buffer *</span>
<span class='curline'><a href='../S/2351.html#L3631'>buffer</a>           3631 src/alloc.c      struct buffer *b</span>
<span class='curline'><a href='../S/2351.html#L3632'>buffer</a>           3632 src/alloc.c        = ALLOCATE_PSEUDOVECTOR (struct buffer, cursor_in_non_selected_windows_,</span>
<span class='curline'><a href='../S/2351.html#L3953'>buffer</a>           3953 src/alloc.c      p-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2351.html#L3964'>buffer</a>           3964 src/alloc.c      p-&gt;buffer = 0;</span>
<span class='curline'><a href='../S/2351.html#L3977'>buffer</a>           3977 src/alloc.c    build_marker (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t bytepos)</span>
<span class='curline'><a href='../S/2351.html#L3987'>buffer</a>           3987 src/alloc.c      m-&gt;buffer = buf;</span>
<span class='curline'><a href='../S/2351.html#L6250'>buffer</a>           6250 src/alloc.c                       struct buffer *buffer,</span>
<span class='curline'><a href='../S/2351.html#L6255'>buffer</a>           6255 src/alloc.c      eassert (buffer-&gt;base_buffer == NULL);</span>
<span class='curline'><a href='../S/2351.html#L6256'>buffer</a>           6256 src/alloc.c      eassert (buffer-&gt;overlays == NULL);</span>
<span class='curline'><a href='../S/2351.html#L6259'>buffer</a>           6259 src/alloc.c      visit_vectorlike_root (visitor, (struct Lisp_Vector *) buffer, type);</span>
<span class='curline'><a href='../S/2351.html#L6413'>buffer</a>           6413 src/alloc.c      Lisp_Object tail, buffer;</span>
<span class='curline'><a href='../S/2351.html#L6431'>buffer</a>           6431 src/alloc.c      FOR_EACH_LIVE_BUFFER (tail, buffer)</span>
<span class='curline'><a href='../S/2351.html#L6432'>buffer</a>           6432 src/alloc.c        compact_buffer (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2351.html#L6541'>buffer</a>           6541 src/alloc.c      FOR_EACH_LIVE_BUFFER (tail, buffer)</span>
<span class='curline'><a href='../S/2351.html#L6543'>buffer</a>           6543 src/alloc.c          struct buffer *nextb = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2351.html#L6683'>buffer</a>           6683 src/alloc.c        list3 (Qbuffers, make_fixnum (sizeof (struct buffer)),</span>
<span class='curline'><a href='../S/2351.html#L6844'>buffer</a>           6844 src/alloc.c    mark_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/2351.html#L6847'>buffer</a>           6847 src/alloc.c      mark_vectorlike (&amp;buffer-&gt;header);</span>
<span class='curline'><a href='../S/2351.html#L6851'>buffer</a>           6851 src/alloc.c      mark_interval_tree (buffer_intervals (buffer));</span>
<span class='curline'><a href='../S/2351.html#L6859'>buffer</a>           6859 src/alloc.c      if (!BUFFER_LIVE_P (buffer))</span>
<span class='curline'><a href='../S/2351.html#L6860'>buffer</a>           6860 src/alloc.c          mark_object (BVAR (buffer, undo_list));</span>
<span class='curline'><a href='../S/2351.html#L6862'>buffer</a>           6862 src/alloc.c      if (!itree_empty_p (buffer-&gt;overlays))</span>
<span class='curline'><a href='../S/2351.html#L6863'>buffer</a>           6863 src/alloc.c        mark_overlays (buffer-&gt;overlays-&gt;root);</span>
<span class='curline'><a href='../S/2351.html#L6866'>buffer</a>           6866 src/alloc.c      if (buffer-&gt;base_buffer &amp;&amp;</span>
<span class='curline'><a href='../S/2351.html#L6867'>buffer</a>           6867 src/alloc.c          !vectorlike_marked_p (&amp;buffer-&gt;base_buffer-&gt;header))</span>
<span class='curline'><a href='../S/2351.html#L6868'>buffer</a>           6868 src/alloc.c        mark_buffer (buffer-&gt;base_buffer);</span>
<span class='curline'><a href='../S/2351.html#L7198'>buffer</a>           7198 src/alloc.c    		mark_buffer ((struct buffer *) ptr);</span>
<span class='curline'><a href='../S/2351.html#L7719'>buffer</a>           7719 src/alloc.c    unchain_dead_markers (struct buffer *buffer)</span>
<span class='curline'><a href='../S/2351.html#L7721'>buffer</a>           7721 src/alloc.c      struct Lisp_Marker *this, **prev = &amp;BUF_MARKERS (buffer);</span>
<span class='curline'><a href='../S/2351.html#L7728'>buffer</a>           7728 src/alloc.c            this-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2351.html#L7742'>buffer</a>           7742 src/alloc.c          struct buffer *buffer = XBUFFER (buf);</span>
<span class='curline'><a href='../S/2351.html#L7744'>buffer</a>           7744 src/alloc.c          buffer-&gt;text-&gt;intervals = balance_intervals (buffer-&gt;text-&gt;intervals);</span>
<span class='curline'><a href='../S/2351.html#L7745'>buffer</a>           7745 src/alloc.c          unchain_dead_markers (buffer);</span>
<span class='curline'><a href='../S/2195.html#L302'>buffer</a>            302 src/android-asset.h android_asset_read_internal (AAsset *asset, int nbytes, char *buffer)</span>
<span class='curline'><a href='../S/2195.html#L352'>buffer</a>            352 src/android-asset.h       (*env)-&gt;GetByteArrayRegion (env, stash, 0, bytes_read, buffer);</span>
<span class='curline'><a href='../S/2195.html#L354'>buffer</a>            354 src/android-asset.h       buffer += bytes_read;</span>
<span class='curline'><a href='../S/2195.html#L387'>buffer</a>            387 src/android-asset.h   char *buffer;</span>
<span class='curline'><a href='../S/2195.html#L394'>buffer</a>            394 src/android-asset.h   buffer = malloc (length);</span>
<span class='curline'><a href='../S/2195.html#L396'>buffer</a>            396 src/android-asset.h   if (!buffer)</span>
<span class='curline'><a href='../S/2195.html#L399'>buffer</a>            399 src/android-asset.h   if (android_asset_read_internal (asset, length, buffer)</span>
<span class='curline'><a href='../S/2195.html#L402'>buffer</a>            402 src/android-asset.h       xfree (buffer);</span>
<span class='curline'><a href='../S/2195.html#L406'>buffer</a>            406 src/android-asset.h   return buffer;</span>
<span class='curline'><a href='../S/2195.html#L410'>buffer</a>            410 src/android-asset.h AAsset_read (AAsset *asset, void *buffer, size_t size)</span>
<span class='curline'><a href='../S/2195.html#L413'>buffer</a>            413 src/android-asset.h 				      buffer);</span>
<span class='curline'><a href='../S/2209.html#L1210'>buffer</a>           1210 src/android.c    static char buffer[PATH_MAX + 1];</span>
<span class='curline'><a href='../S/2209.html#L1232'>buffer</a>           1232 src/android.c    head = stpcpy (buffer, "content:/");</span>
<span class='curline'><a href='../S/2209.html#L1243'>buffer</a>           1243 src/android.c        eassert ((head - buffer) &lt;= PATH_MAX);</span>
<span class='curline'><a href='../S/2209.html#L1245'>buffer</a>           1245 src/android.c        n = PATH_MAX - (head - buffer);</span>
<span class='curline'><a href='../S/2209.html#L1249'>buffer</a>           1249 src/android.c    buffer[PATH_MAX] = '\0';</span>
<span class='curline'><a href='../S/2209.html#L1252'>buffer</a>           1252 src/android.c    return buffer;</span>
<span class='curline'><a href='../S/2209.html#L1982'>buffer</a>           1982 src/android.c  android_proc_name (int fd, char *buffer, size_t size)</span>
<span class='curline'><a href='../S/2209.html#L1989'>buffer</a>           1989 src/android.c    read = readlink (format, buffer, size - 1);</span>
<span class='curline'><a href='../S/2209.html#L1994'>buffer</a>           1994 src/android.c    buffer[read] = '\0';</span>
<span class='curline'><a href='../S/2209.html#L2023'>buffer</a>           2023 src/android.c    char buffer[sizeof fingerprint * 2 + 1];</span>
<span class='curline'><a href='../S/2209.html#L2025'>buffer</a>           2025 src/android.c    memset (buffer, 0, sizeof buffer);</span>
<span class='curline'><a href='../S/2209.html#L2026'>buffer</a>           2026 src/android.c    hexbuf_digest (buffer, (char *) fingerprint,</span>
<span class='curline'><a href='../S/2209.html#L2029'>buffer</a>           2029 src/android.c    return (*env)-&gt;NewStringUTF (env, buffer);</span>
<span class='curline'><a href='../S/2209.html#L2246'>buffer</a>           2246 src/android.c    char buffer[PATH_MAX + 1];</span>
<span class='curline'><a href='../S/2209.html#L2250'>buffer</a>           2250 src/android.c    if (android_proc_name (fd, buffer, PATH_MAX + 1))</span>
<span class='curline'><a href='../S/2209.html#L2255'>buffer</a>           2255 src/android.c    length = strlen (buffer);</span>
<span class='curline'><a href='../S/2209.html#L2261'>buffer</a>           2261 src/android.c  			      (jbyte *) buffer);</span>
<span class='curline'><a href='../S/2209.html#L6135'>buffer</a>           6135 src/android.c    const char *buffer;</span>
<span class='curline'><a href='../S/2209.html#L6143'>buffer</a>           6143 src/android.c    buffer = (*android_java_env)-&gt;GetStringUTFChars (android_java_env,</span>
<span class='curline'><a href='../S/2209.html#L6146'>buffer</a>           6146 src/android.c    android_exception_check_nonnull ((void *) buffer, string);</span>
<span class='curline'><a href='../S/2209.html#L6147'>buffer</a>           6147 src/android.c    strncpy (name_return, buffer, size - 1);</span>
<span class='curline'><a href='../S/2209.html#L6151'>buffer</a>           6151 src/android.c  					      buffer);</span>
<span class='curline'><a href='../S/2209.html#L7027'>buffer</a>           7027 src/android.c    const char *buffer;</span>
<span class='curline'><a href='../S/2209.html#L7043'>buffer</a>           7043 src/android.c    buffer = (*android_java_env)-&gt;GetStringUTFChars (android_java_env,</span>
<span class='curline'><a href='../S/2209.html#L7049'>buffer</a>           7049 src/android.c    tem = build_string_from_utf8 (buffer);</span>
<span class='curline'><a href='../S/2209.html#L7053'>buffer</a>           7053 src/android.c  					      buffer);</span>
<span class='curline'><a href='../S/2209.html#L7721'>buffer</a>           7721 src/android.c  			 void *buffer, size_t size)</span>
<span class='curline'><a href='../S/2209.html#L7724'>buffer</a>           7724 src/android.c      return emacs_read_quit (asset.fd, buffer, size);</span>
<span class='curline'><a href='../S/2209.html#L7728'>buffer</a>           7728 src/android.c    return AAsset_read (asset.asset, buffer, size);</span>
<span class='curline'><a href='../S/2209.html#L7736'>buffer</a>           7736 src/android.c  		    void *buffer, size_t size)</span>
<span class='curline'><a href='../S/2209.html#L7739'>buffer</a>           7739 src/android.c      return read (asset.fd, buffer, size);</span>
<span class='curline'><a href='../S/2209.html#L7743'>buffer</a>           7743 src/android.c    return AAsset_read (asset.asset, buffer, size);</span>
<span class='curline'><a href='../S/2204.html#L2192'>buffer</a>           2192 src/androidfns.c   struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/2243.html#L358'>buffer</a>            358 src/androidselect.c   char *buffer, *start;</span>
<span class='curline'><a href='../S/2243.html#L410'>buffer</a>            410 src/androidselect.c       buffer = xmalloc (MIN (length, PTRDIFF_MAX));</span>
<span class='curline'><a href='../S/2243.html#L411'>buffer</a>            411 src/androidselect.c       record_unwind_protect_ptr (xfree, buffer);</span>
<span class='curline'><a href='../S/2243.html#L413'>buffer</a>            413 src/androidselect.c       rc = emacs_read_quit (fd, buffer,</span>
<span class='curline'><a href='../S/2243.html#L421'>buffer</a>            421 src/androidselect.c       return unbind_to (ref, make_unibyte_string (buffer, rc));</span>
<span class='curline'><a href='../S/2243.html#L425'>buffer</a>            425 src/androidselect.c   buffer = xmalloc (BUFSIZ);</span>
<span class='curline'><a href='../S/2243.html#L427'>buffer</a>            427 src/androidselect.c   start = buffer;</span>
<span class='curline'><a href='../S/2243.html#L429'>buffer</a>            429 src/androidselect.c   record_unwind_protect_ptr (android_xfree_inside, &amp;buffer);</span>
<span class='curline'><a href='../S/2243.html#L453'>buffer</a>            453 src/androidselect.c       buffer = xrealloc (buffer, length + BUFSIZ);</span>
<span class='curline'><a href='../S/2243.html#L454'>buffer</a>            454 src/androidselect.c       start = buffer + length;</span>
<span class='curline'><a href='../S/2243.html#L457'>buffer</a>            457 src/androidselect.c   return unbind_to (ref, make_unibyte_string (buffer, rc));</span>
<span class='curline'><a href='../S/2300.html#L4644'>buffer</a>           4644 src/androidterm.c   unsigned short *buffer;</span>
<span class='curline'><a href='../S/2300.html#L4647'>buffer</a>           4647 src/androidterm.c   buffer = malloc (size * sizeof *buffer);</span>
<span class='curline'><a href='../S/2300.html#L4649'>buffer</a>           4649 src/androidterm.c   if (!buffer)</span>
<span class='curline'><a href='../S/2300.html#L4656'>buffer</a>           4656 src/androidterm.c       free (buffer);</span>
<span class='curline'><a href='../S/2300.html#L4661'>buffer</a>           4661 src/androidterm.c     buffer[i] = java[i];</span>
<span class='curline'><a href='../S/2300.html#L4665'>buffer</a>           4665 src/androidterm.c   return buffer;</span>
<span class='curline'><a href='../S/2300.html#L4879'>buffer</a>           4879 src/androidterm.c android_text_to_string (JNIEnv *env, char *buffer, ptrdiff_t n,</span>
<span class='curline'><a href='../S/2300.html#L4902'>buffer</a>           4902 src/androidterm.c 	  utf16[index] = buffer[index];</span>
<span class='curline'><a href='../S/2300.html#L4925'>buffer</a>           4925 src/androidterm.c       eassert (CHAR_HEAD_P (*buffer));</span>
<span class='curline'><a href='../S/2300.html#L4926'>buffer</a>           4926 src/androidterm.c       encoded = STRING_CHAR ((unsigned char *) buffer);</span>
<span class='curline'><a href='../S/2300.html#L4945'>buffer</a>           4945 src/androidterm.c       buffer += BYTES_BY_CHAR_HEAD (*buffer);</span>
<span class='curline'><a href='../S/2300.html#L5145'>buffer</a>           5145 src/androidterm.c   struct buffer *b;</span>
<span class='curline'><a href='../S/2300.html#L5951'>buffer</a>           5951 src/androidterm.c   struct buffer *b;</span>
<span class='curline'><a href='../S/2300.html#L6056'>buffer</a>           6056 src/androidterm.c   struct buffer *buffer;</span>
<span class='curline'><a href='../S/2300.html#L6067'>buffer</a>           6067 src/androidterm.c   buffer = XBUFFER (WINDOW_BUFFER (w));</span>
<span class='curline'><a href='../S/2300.html#L6071'>buffer</a>           6071 src/androidterm.c 	   ? BVAR (buffer, text_conversion_style)</span>
<span class='curline'><a href='../S/2300.html#L6118'>buffer</a>           6118 src/androidterm.c 		   struct buffer *buffer)</span>
<span class='curline'><a href='../S/2300.html#L6211'>buffer</a>           6211 src/androidterm.c   static char buffer[64];</span>
<span class='curline'><a href='../S/2300.html#L6214'>buffer</a>           6214 src/androidterm.c   android_get_keysym_name (keysym, buffer, 64);</span>
<span class='curline'><a href='../S/2300.html#L6218'>buffer</a>           6218 src/androidterm.c   return buffer;</span>
<span class='curline'><a href='../S/2208.html#L1496'>buffer</a>           1496 src/bidi.c       struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2208.html#L1557'>buffer</a>           1557 src/bidi.c       struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2152.html#L68'>buffer</a>             68 src/buffer.c   struct buffer buffer_defaults;</span>
<span class='curline'><a href='../S/2152.html#L87'>buffer</a>             87 src/buffer.c   struct buffer buffer_local_flags;</span>
<span class='curline'><a href='../S/2152.html#L92'>buffer</a>             92 src/buffer.c   struct buffer buffer_local_symbols;</span>
<span class='curline'><a href='../S/2152.html#L116'>buffer</a>            116 src/buffer.c   static void reset_buffer_local_variables (struct buffer *, bool);</span>
<span class='curline'><a href='../S/2152.html#L125'>buffer</a>            125 src/buffer.c   static void alloc_buffer_text (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/2152.html#L126'>buffer</a>            126 src/buffer.c   static void free_buffer_text (struct buffer *b);</span>
<span class='curline'><a href='../S/2152.html#L127'>buffer</a>            127 src/buffer.c   static void copy_overlays (struct buffer *, struct buffer *);</span>
<span class='curline'><a href='../S/2152.html#L128'>buffer</a>            128 src/buffer.c   static void modify_overlay (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/2152.html#L129'>buffer</a>            129 src/buffer.c   static Lisp_Object buffer_lisp_local_variables (struct buffer *, bool);</span>
<span class='curline'><a href='../S/2152.html#L130'>buffer</a>            130 src/buffer.c   static Lisp_Object buffer_local_variables_1 (struct buffer *buf, int offset, Lisp_Object sym);</span>
<span class='curline'><a href='../S/2152.html#L158'>buffer</a>            158 src/buffer.c   bset_abbrev_mode (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L163'>buffer</a>            163 src/buffer.c   bset_abbrev_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L168'>buffer</a>            168 src/buffer.c   bset_auto_fill_function (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L173'>buffer</a>            173 src/buffer.c   bset_auto_save_file_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L178'>buffer</a>            178 src/buffer.c   bset_auto_save_file_name (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L183'>buffer</a>            183 src/buffer.c   bset_backed_up (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L188'>buffer</a>            188 src/buffer.c   bset_begv_marker (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L193'>buffer</a>            193 src/buffer.c   bset_bidi_display_reordering (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L198'>buffer</a>            198 src/buffer.c   bset_bidi_paragraph_start_re (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L203'>buffer</a>            203 src/buffer.c   bset_bidi_paragraph_separate_re (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L208'>buffer</a>            208 src/buffer.c   bset_buffer_file_coding_system (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L213'>buffer</a>            213 src/buffer.c   bset_case_fold_search (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L218'>buffer</a>            218 src/buffer.c   bset_ctl_arrow (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L223'>buffer</a>            223 src/buffer.c   bset_cursor_in_non_selected_windows (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L228'>buffer</a>            228 src/buffer.c   bset_cursor_type (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L233'>buffer</a>            233 src/buffer.c   bset_display_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L238'>buffer</a>            238 src/buffer.c   bset_extra_line_spacing (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L244'>buffer</a>            244 src/buffer.c   bset_ts_parser_list (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L250'>buffer</a>            250 src/buffer.c   bset_file_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L255'>buffer</a>            255 src/buffer.c   bset_file_truename (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L260'>buffer</a>            260 src/buffer.c   bset_fringe_cursor_alist (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L265'>buffer</a>            265 src/buffer.c   bset_fringe_indicator_alist (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L270'>buffer</a>            270 src/buffer.c   bset_fringes_outside_margins (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L275'>buffer</a>            275 src/buffer.c   bset_header_line_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L280'>buffer</a>            280 src/buffer.c   bset_tab_line_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L285'>buffer</a>            285 src/buffer.c   bset_indicate_buffer_boundaries (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L290'>buffer</a>            290 src/buffer.c   bset_indicate_empty_lines (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L295'>buffer</a>            295 src/buffer.c   bset_invisibility_spec (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L300'>buffer</a>            300 src/buffer.c   bset_left_fringe_width (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L305'>buffer</a>            305 src/buffer.c   bset_major_mode (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L310'>buffer</a>            310 src/buffer.c   bset_local_minor_modes (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L315'>buffer</a>            315 src/buffer.c   bset_mark (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L320'>buffer</a>            320 src/buffer.c   bset_mode_line_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L325'>buffer</a>            325 src/buffer.c   bset_mode_name (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L330'>buffer</a>            330 src/buffer.c   bset_name (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L335'>buffer</a>            335 src/buffer.c   bset_overwrite_mode (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L340'>buffer</a>            340 src/buffer.c   bset_pt_marker (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L345'>buffer</a>            345 src/buffer.c   bset_right_fringe_width (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L350'>buffer</a>            350 src/buffer.c   bset_save_length (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L355'>buffer</a>            355 src/buffer.c   bset_scroll_bar_width (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L360'>buffer</a>            360 src/buffer.c   bset_scroll_bar_height (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L365'>buffer</a>            365 src/buffer.c   bset_scroll_down_aggressively (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L370'>buffer</a>            370 src/buffer.c   bset_scroll_up_aggressively (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L375'>buffer</a>            375 src/buffer.c   bset_selective_display (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L380'>buffer</a>            380 src/buffer.c   bset_selective_display_ellipses (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L385'>buffer</a>            385 src/buffer.c   bset_vertical_scroll_bar_type (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L390'>buffer</a>            390 src/buffer.c   bset_horizontal_scroll_bar_type (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L395'>buffer</a>            395 src/buffer.c   bset_word_wrap (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L400'>buffer</a>            400 src/buffer.c   bset_zv_marker (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2152.html#L540'>buffer</a>            540 src/buffer.c   run_buffer_list_update_hook (struct buffer *buf)</span>
<span class='curline'><a href='../S/2152.html#L564'>buffer</a>            564 src/buffer.c     register Lisp_Object buffer, name;</span>
<span class='curline'><a href='../S/2152.html#L565'>buffer</a>            565 src/buffer.c     register struct buffer *b;</span>
<span class='curline'><a href='../S/2152.html#L567'>buffer</a>            567 src/buffer.c     buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/2152.html#L568'>buffer</a>            568 src/buffer.c     if (!NILP (buffer))</span>
<span class='curline'><a href='../S/2152.html#L569'>buffer</a>            569 src/buffer.c       return buffer;</span>
<span class='curline'><a href='../S/2152.html#L647'>buffer</a>            647 src/buffer.c     XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/2152.html#L648'>buffer</a>            648 src/buffer.c     Vbuffer_alist = nconc2 (Vbuffer_alist, list1 (Fcons (name, buffer)));</span>
<span class='curline'><a href='../S/2152.html#L652'>buffer</a>            652 src/buffer.c     return buffer;</span>
<span class='curline'><a href='../S/2152.html#L656'>buffer</a>            656 src/buffer.c   add_buffer_overlay (struct buffer *b, struct Lisp_Overlay *ov,</span>
<span class='curline'><a href='../S/2152.html#L659'>buffer</a>            659 src/buffer.c     eassert (! ov-&gt;buffer);</span>
<span class='curline'><a href='../S/2152.html#L662'>buffer</a>            662 src/buffer.c     ov-&gt;buffer = b;</span>
<span class='curline'><a href='../S/2152.html#L669'>buffer</a>            669 src/buffer.c   copy_overlays (struct buffer *from, struct buffer *to)</span>
<span class='curline'><a href='../S/2152.html#L698'>buffer</a>            698 src/buffer.c   clone_per_buffer_values (struct buffer *from, struct buffer *to)</span>
<span class='curline'><a href='../S/2152.html#L711'>buffer</a>            711 src/buffer.c         if (MARKERP (obj) &amp;&amp; XMARKER (obj)-&gt;buffer == from)</span>
<span class='curline'><a href='../S/2152.html#L736'>buffer</a>            736 src/buffer.c   record_buffer_markers (struct buffer *b)</span>
<span class='curline'><a href='../S/2152.html#L740'>buffer</a>            740 src/buffer.c         Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2152.html#L745'>buffer</a>            745 src/buffer.c         XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/2152.html#L746'>buffer</a>            746 src/buffer.c         set_marker_both (BVAR (b, pt_marker), buffer, b-&gt;pt, b-&gt;pt_byte);</span>
<span class='curline'><a href='../S/2152.html#L747'>buffer</a>            747 src/buffer.c         set_marker_both (BVAR (b, begv_marker), buffer, b-&gt;begv, b-&gt;begv_byte);</span>
<span class='curline'><a href='../S/2152.html#L748'>buffer</a>            748 src/buffer.c         set_marker_both (BVAR (b, zv_marker), buffer, b-&gt;zv, b-&gt;zv_byte);</span>
<span class='curline'><a href='../S/2152.html#L757'>buffer</a>            757 src/buffer.c   fetch_buffer_markers (struct buffer *b)</span>
<span class='curline'><a href='../S/2152.html#L797'>buffer</a>            797 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/2152.html#L897'>buffer</a>            897 src/buffer.c         struct buffer *old_b = current_buffer;</span>
<span class='curline'><a href='../S/2152.html#L924'>buffer</a>            924 src/buffer.c   remove_buffer_overlay (struct buffer *b, struct Lisp_Overlay *ov)</span>
<span class='curline'><a href='../S/2152.html#L927'>buffer</a>            927 src/buffer.c     eassert (ov-&gt;buffer == b);</span>
<span class='curline'><a href='../S/2152.html#L928'>buffer</a>            928 src/buffer.c     itree_remove (ov-&gt;buffer-&gt;overlays, ov-&gt;interval);</span>
<span class='curline'><a href='../S/2152.html#L929'>buffer</a>            929 src/buffer.c     ov-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2152.html#L937'>buffer</a>            937 src/buffer.c     if (! ov-&gt;buffer)</span>
<span class='curline'><a href='../S/2152.html#L940'>buffer</a>            940 src/buffer.c     modify_overlay (ov-&gt;buffer, overlay_start (ov), overlay_end (ov));</span>
<span class='curline'><a href='../S/2152.html#L941'>buffer</a>            941 src/buffer.c     remove_buffer_overlay (ov-&gt;buffer, ov);</span>
<span class='curline'><a href='../S/2152.html#L947'>buffer</a>            947 src/buffer.c   delete_all_overlays (struct buffer *b)</span>
<span class='curline'><a href='../S/2152.html#L960'>buffer</a>            960 src/buffer.c         XOVERLAY (node-&gt;data)-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2152.html#L969'>buffer</a>            969 src/buffer.c   free_buffer_overlays (struct buffer *b)</span>
<span class='curline'><a href='../S/2152.html#L1044'>buffer</a>           1044 src/buffer.c   reset_buffer (register struct buffer *b)</span>
<span class='curline'><a href='../S/2152.html#L1091'>buffer</a>           1091 src/buffer.c   reset_buffer_local_variables (struct buffer *b, bool permanent_too)</span>
<span class='curline'><a href='../S/2152.html#L1122'>buffer</a>           1122 src/buffer.c         Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2152.html#L1123'>buffer</a>           1123 src/buffer.c         XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/2152.html#L1139'>buffer</a>           1139 src/buffer.c             if (BASE_EQ (SYMBOL_BLV (XSYMBOL (sym))-&gt;where, buffer))</span>
<span class='curline'><a href='../S/2152.html#L1260'>buffer</a>           1260 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L1262'>buffer</a>           1262 src/buffer.c     return BVAR (decode_buffer (buffer), name);</span>
<span class='curline'><a href='../S/2152.html#L1268'>buffer</a>           1268 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L1270'>buffer</a>           1270 src/buffer.c     return BVAR (decode_buffer (buffer), filename);</span>
<span class='curline'><a href='../S/2152.html#L1278'>buffer</a>           1278 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L1280'>buffer</a>           1280 src/buffer.c     struct buffer *base = decode_buffer (buffer)-&gt;base_buffer;</span>
<span class='curline'><a href='../S/2152.html#L1281'>buffer</a>           1281 src/buffer.c     return base ? (XSETBUFFER (buffer, base), buffer) : Qnil;</span>
<span class='curline'><a href='../S/2152.html#L1289'>buffer</a>           1289 src/buffer.c     (register Lisp_Object variable, register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L1291'>buffer</a>           1291 src/buffer.c     register Lisp_Object result = buffer_local_value (variable, buffer);</span>
<span class='curline'><a href='../S/2152.html#L1304'>buffer</a>           1304 src/buffer.c   buffer_local_value (Lisp_Object variable, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L1306'>buffer</a>           1306 src/buffer.c     register struct buffer *buf;</span>
<span class='curline'><a href='../S/2152.html#L1311'>buffer</a>           1311 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2152.html#L1312'>buffer</a>           1312 src/buffer.c     buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2152.html#L1368'>buffer</a>           1368 src/buffer.c   buffer_lisp_local_variables (struct buffer *buf, bool clone)</span>
<span class='curline'><a href='../S/2152.html#L1403'>buffer</a>           1403 src/buffer.c   buffer_local_variables_1 (struct buffer *buf, int offset, Lisp_Object sym)</span>
<span class='curline'><a href='../S/2152.html#L1423'>buffer</a>           1423 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L1425'>buffer</a>           1425 src/buffer.c     struct buffer *buf = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/2152.html#L1456'>buffer</a>           1456 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L1458'>buffer</a>           1458 src/buffer.c     struct buffer *buf = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/2152.html#L1538'>buffer</a>           1538 src/buffer.c     struct buffer *b = current_buffer-&gt;base_buffer</span>
<span class='curline'><a href='../S/2152.html#L1588'>buffer</a>           1588 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L1590'>buffer</a>           1590 src/buffer.c     return modiff_to_integer (BUF_MODIFF (decode_buffer (buffer)));</span>
<span class='curline'><a href='../S/2152.html#L1598'>buffer</a>           1598 src/buffer.c     (Lisp_Object tick, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L1601'>buffer</a>           1601 src/buffer.c     BUF_MODIFF (decode_buffer (buffer)) = XFIXNUM (tick);</span>
<span class='curline'><a href='../S/2152.html#L1615'>buffer</a>           1615 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L1617'>buffer</a>           1617 src/buffer.c     return modiff_to_integer (BUF_CHARS_MODIFF (decode_buffer (buffer)));</span>
<span class='curline'><a href='../S/2152.html#L1682'>buffer</a>           1682 src/buffer.c   candidate_buffer (Lisp_Object b, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L1684'>buffer</a>           1684 src/buffer.c     return (BUFFERP (b) &amp;&amp; !BASE_EQ (b, buffer)</span>
<span class='curline'><a href='../S/2152.html#L1700'>buffer</a>           1700 src/buffer.c     (Lisp_Object buffer, Lisp_Object visible_ok, Lisp_Object frame)</span>
<span class='curline'><a href='../S/2152.html#L1710'>buffer</a>           1710 src/buffer.c         if (candidate_buffer (buf, buffer)</span>
<span class='curline'><a href='../S/2152.html#L1726'>buffer</a>           1726 src/buffer.c         if (candidate_buffer (buf, buffer)</span>
<span class='curline'><a href='../S/2152.html#L1750'>buffer</a>           1750 src/buffer.c   other_buffer_safely (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L1755'>buffer</a>           1755 src/buffer.c       if (candidate_buffer (buf, buffer))</span>
<span class='curline'><a href='../S/2152.html#L1777'>buffer</a>           1777 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L1781'>buffer</a>           1781 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2152.html#L1785'>buffer</a>           1785 src/buffer.c         real_buffer = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/2152.html#L1787'>buffer</a>           1787 src/buffer.c   	nsberror (buffer);</span>
<span class='curline'><a href='../S/2152.html#L1799'>buffer</a>           1799 src/buffer.c   compact_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/2152.html#L1801'>buffer</a>           1801 src/buffer.c     BUFFER_CHECK_INDIRECTION (buffer);</span>
<span class='curline'><a href='../S/2152.html#L1805'>buffer</a>           1805 src/buffer.c     if (BUFFER_LIVE_P (buffer)</span>
<span class='curline'><a href='../S/2152.html#L1806'>buffer</a>           1806 src/buffer.c         &amp;&amp; (buffer-&gt;base_buffer == NULL)</span>
<span class='curline'><a href='../S/2152.html#L1807'>buffer</a>           1807 src/buffer.c         &amp;&amp; (BUF_COMPACT (buffer) != BUF_MODIFF (buffer)))</span>
<span class='curline'><a href='../S/2152.html#L1813'>buffer</a>           1813 src/buffer.c         if (!EQ (BVAR(buffer, undo_list), Qt))</span>
<span class='curline'><a href='../S/2152.html#L1814'>buffer</a>           1814 src/buffer.c   	truncate_undo_list (buffer);</span>
<span class='curline'><a href='../S/2152.html#L1817'>buffer</a>           1817 src/buffer.c         if (!buffer-&gt;text-&gt;inhibit_shrinking)</span>
<span class='curline'><a href='../S/2152.html#L1823'>buffer</a>           1823 src/buffer.c   					   BUF_Z_BYTE (buffer) / 10,</span>
<span class='curline'><a href='../S/2152.html#L1825'>buffer</a>           1825 src/buffer.c   	  if (BUF_GAP_SIZE (buffer) &gt; size)</span>
<span class='curline'><a href='../S/2152.html#L1826'>buffer</a>           1826 src/buffer.c   	    make_gap_1 (buffer, -(BUF_GAP_SIZE (buffer) - size));</span>
<span class='curline'><a href='../S/2152.html#L1828'>buffer</a>           1828 src/buffer.c         BUF_COMPACT (buffer) = BUF_MODIFF (buffer);</span>
<span class='curline'><a href='../S/2152.html#L1852'>buffer</a>           1852 src/buffer.c     Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2152.html#L1853'>buffer</a>           1853 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/2152.html#L1858'>buffer</a>           1858 src/buffer.c       buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2152.html#L1860'>buffer</a>           1860 src/buffer.c       buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/2152.html#L1861'>buffer</a>           1861 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2152.html#L1864'>buffer</a>           1864 src/buffer.c     b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2152.html#L1900'>buffer</a>           1900 src/buffer.c   	if (NILP (call1 (Qkill_buffer__possibly_save, buffer)))</span>
<span class='curline'><a href='../S/2152.html#L1942'>buffer</a>           1942 src/buffer.c     if (BASE_EQ (buffer, XWINDOW (minibuf_window)-&gt;contents))</span>
<span class='curline'><a href='../S/2152.html#L1966'>buffer</a>           1966 src/buffer.c     replace_buffer_in_windows (buffer);</span>
<span class='curline'><a href='../S/2152.html#L1976'>buffer</a>           1976 src/buffer.c         tem = Fother_buffer (buffer, Qnil, Qnil);</span>
<span class='curline'><a href='../S/2152.html#L1986'>buffer</a>           1986 src/buffer.c         &amp;&amp; BASE_EQ (buffer, Fother_buffer (buffer, Qnil, Qnil)))</span>
<span class='curline'><a href='../S/2152.html#L1994'>buffer</a>           1994 src/buffer.c     kill_buffer_processes (buffer);</span>
<span class='curline'><a href='../S/2152.html#L1995'>buffer</a>           1995 src/buffer.c     kill_buffer_xwidgets (buffer);</span>
<span class='curline'><a href='../S/2152.html#L2004'>buffer</a>           2004 src/buffer.c     frames_discard_buffer (buffer);</span>
<span class='curline'><a href='../S/2152.html#L2014'>buffer</a>           2014 src/buffer.c     Vbuffer_alist = Fdelq (Frassq (buffer, Vbuffer_alist), Vbuffer_alist);</span>
<span class='curline'><a href='../S/2152.html#L2016'>buffer</a>           2016 src/buffer.c     replace_buffer_in_windows_safely (buffer);</span>
<span class='curline'><a href='../S/2152.html#L2028'>buffer</a>           2028 src/buffer.c   	  if (m-&gt;buffer == b)</span>
<span class='curline'><a href='../S/2152.html#L2030'>buffer</a>           2030 src/buffer.c   	      m-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2152.html#L2052'>buffer</a>           2052 src/buffer.c   	  m-&gt;buffer = 0;</span>
<span class='curline'><a href='../S/2152.html#L2125'>buffer</a>           2125 src/buffer.c   record_buffer (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L2130'>buffer</a>           2130 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2152.html#L2137'>buffer</a>           2137 src/buffer.c     aelt = Frassq (buffer, Vbuffer_alist);</span>
<span class='curline'><a href='../S/2152.html#L2145'>buffer</a>           2145 src/buffer.c     fset_buffer_list (f, Fcons (buffer, Fdelq (buffer, f-&gt;buffer_list)));</span>
<span class='curline'><a href='../S/2152.html#L2146'>buffer</a>           2146 src/buffer.c     fset_buried_buffer_list (f, Fdelq (buffer, f-&gt;buried_buffer_list));</span>
<span class='curline'><a href='../S/2152.html#L2148'>buffer</a>           2148 src/buffer.c     run_buffer_list_update_hook (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2152.html#L2161'>buffer</a>           2161 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L2166'>buffer</a>           2166 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2152.html#L2173'>buffer</a>           2173 src/buffer.c     aelt = Frassq (buffer, Vbuffer_alist);</span>
<span class='curline'><a href='../S/2152.html#L2181'>buffer</a>           2181 src/buffer.c     fset_buffer_list (f, Fdelq (buffer, f-&gt;buffer_list));</span>
<span class='curline'><a href='../S/2152.html#L2183'>buffer</a>           2183 src/buffer.c       (f, Fcons (buffer, Fdelq (buffer, f-&gt;buried_buffer_list)));</span>
<span class='curline'><a href='../S/2152.html#L2185'>buffer</a>           2185 src/buffer.c     run_buffer_list_update_hook (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2152.html#L2196'>buffer</a>           2196 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L2200'>buffer</a>           2200 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2152.html#L2202'>buffer</a>           2202 src/buffer.c     if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/2152.html#L2205'>buffer</a>           2205 src/buffer.c     if (strcmp (SSDATA (BVAR (XBUFFER (buffer), name)), "*scratch*") == 0)</span>
<span class='curline'><a href='../S/2152.html#L2227'>buffer</a>           2227 src/buffer.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2152.html#L2246'>buffer</a>           2246 src/buffer.c   set_buffer_internal_1 (register struct buffer *b)</span>
<span class='curline'><a href='../S/2152.html#L2262'>buffer</a>           2262 src/buffer.c   void set_buffer_internal_2 (register struct buffer *b)</span>
<span class='curline'><a href='../S/2152.html#L2264'>buffer</a>           2264 src/buffer.c     register struct buffer *old_buf;</span>
<span class='curline'><a href='../S/2152.html#L2318'>buffer</a>           2318 src/buffer.c   set_buffer_temp (struct buffer *b)</span>
<span class='curline'><a href='../S/2152.html#L2320'>buffer</a>           2320 src/buffer.c     register struct buffer *old_buf;</span>
<span class='curline'><a href='../S/2152.html#L2347'>buffer</a>           2347 src/buffer.c     register Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2152.html#L2348'>buffer</a>           2348 src/buffer.c     buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/2152.html#L2349'>buffer</a>           2349 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2152.html#L2351'>buffer</a>           2351 src/buffer.c     if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/2152.html#L2353'>buffer</a>           2353 src/buffer.c     set_buffer_internal (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2152.html#L2354'>buffer</a>           2354 src/buffer.c     return buffer;</span>
<span class='curline'><a href='../S/2152.html#L2366'>buffer</a>           2366 src/buffer.c   set_buffer_if_live (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L2368'>buffer</a>           2368 src/buffer.c     if (BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/2152.html#L2369'>buffer</a>           2369 src/buffer.c       set_buffer_internal (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2152.html#L2464'>buffer</a>           2464 src/buffer.c   swap_buffer_overlays (struct buffer *buffer, struct buffer *other)</span>
<span class='curline'><a href='../S/2152.html#L2468'>buffer</a>           2468 src/buffer.c     ITREE_FOREACH (node, buffer-&gt;overlays, PTRDIFF_MIN, PTRDIFF_MAX, ASCENDING)</span>
<span class='curline'><a href='../S/2152.html#L2469'>buffer</a>           2469 src/buffer.c       XOVERLAY (node-&gt;data)-&gt;buffer = other;</span>
<span class='curline'><a href='../S/2152.html#L2472'>buffer</a>           2472 src/buffer.c       XOVERLAY (node-&gt;data)-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/2152.html#L2475'>buffer</a>           2475 src/buffer.c     void *tmp = buffer-&gt;overlays;</span>
<span class='curline'><a href='../S/2152.html#L2476'>buffer</a>           2476 src/buffer.c     buffer-&gt;overlays = other-&gt;overlays;</span>
<span class='curline'><a href='../S/2152.html#L2485'>buffer</a>           2485 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L2487'>buffer</a>           2487 src/buffer.c     struct buffer *other_buffer;</span>
<span class='curline'><a href='../S/2152.html#L2488'>buffer</a>           2488 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2152.html#L2489'>buffer</a>           2489 src/buffer.c     other_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2152.html#L2581'>buffer</a>           2581 src/buffer.c         if (m-&gt;buffer == other_buffer)</span>
<span class='curline'><a href='../S/2152.html#L2582'>buffer</a>           2582 src/buffer.c   	m-&gt;buffer = current_buffer;</span>
<span class='curline'><a href='../S/2152.html#L2586'>buffer</a>           2586 src/buffer.c   	eassert (!m-&gt;buffer);</span>
<span class='curline'><a href='../S/2152.html#L2588'>buffer</a>           2588 src/buffer.c         if (m-&gt;buffer == current_buffer)</span>
<span class='curline'><a href='../S/2152.html#L2589'>buffer</a>           2589 src/buffer.c   	m-&gt;buffer = other_buffer;</span>
<span class='curline'><a href='../S/2152.html#L2593'>buffer</a>           2593 src/buffer.c   	eassert (!m-&gt;buffer);</span>
<span class='curline'><a href='../S/2152.html#L2633'>buffer</a>           2633 src/buffer.c       (eassert (BASE_EQ (current_buffer-&gt;text-&gt;intervals-&gt;up.obj, buffer)),</span>
<span class='curline'><a href='../S/2152.html#L2906'>buffer</a>           2906 src/buffer.c         struct buffer *o = XBUFFER (other);</span>
<span class='curline'><a href='../S/2152.html#L3482'>buffer</a>           3482 src/buffer.c         struct buffer *base = current_buffer-&gt;base_buffer</span>
<span class='curline'><a href='../S/2152.html#L3495'>buffer</a>           3495 src/buffer.c   adjust_overlays_for_delete_in_buffer (struct buffer * buf,</span>
<span class='curline'><a href='../S/2152.html#L3527'>buffer</a>           3527 src/buffer.c         struct buffer *base = current_buffer-&gt;base_buffer</span>
<span class='curline'><a href='../S/2152.html#L3556'>buffer</a>           3556 src/buffer.c     (Lisp_Object beg, Lisp_Object end, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/2152.html#L3560'>buffer</a>           3560 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/2152.html#L3562'>buffer</a>           3562 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2152.html#L3563'>buffer</a>           3563 src/buffer.c       XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/2152.html#L3565'>buffer</a>           3565 src/buffer.c       CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2152.html#L3567'>buffer</a>           3567 src/buffer.c     b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2152.html#L3571'>buffer</a>           3571 src/buffer.c     if (MARKERP (beg) &amp;&amp; !BASE_EQ (Fmarker_buffer (beg), buffer))</span>
<span class='curline'><a href='../S/2152.html#L3573'>buffer</a>           3573 src/buffer.c     if (MARKERP (end) &amp;&amp; !BASE_EQ (Fmarker_buffer (end), buffer))</span>
<span class='curline'><a href='../S/2152.html#L3600'>buffer</a>           3600 src/buffer.c   modify_overlay (struct buffer *buf, ptrdiff_t start, ptrdiff_t end)</span>
<span class='curline'><a href='../S/2152.html#L3621'>buffer</a>           3621 src/buffer.c     (Lisp_Object overlay, Lisp_Object beg, Lisp_Object end, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L3623'>buffer</a>           3623 src/buffer.c     struct buffer *b, *ob = 0;</span>
<span class='curline'><a href='../S/2152.html#L3629'>buffer</a>           3629 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2152.html#L3630'>buffer</a>           3630 src/buffer.c       buffer = Foverlay_buffer (overlay);</span>
<span class='curline'><a href='../S/2152.html#L3631'>buffer</a>           3631 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2152.html#L3632'>buffer</a>           3632 src/buffer.c       XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/2152.html#L3633'>buffer</a>           3633 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2152.html#L3635'>buffer</a>           3635 src/buffer.c     if (NILP (Fbuffer_live_p (buffer)))</span>
<span class='curline'><a href='../S/2152.html#L3638'>buffer</a>           3638 src/buffer.c     if (MARKERP (beg) &amp;&amp; !BASE_EQ (Fmarker_buffer (beg), buffer))</span>
<span class='curline'><a href='../S/2152.html#L3640'>buffer</a>           3640 src/buffer.c     if (MARKERP (end) &amp;&amp; !BASE_EQ (Fmarker_buffer (end), buffer))</span>
<span class='curline'><a href='../S/2152.html#L3655'>buffer</a>           3655 src/buffer.c     b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2152.html#L3668'>buffer</a>           3668 src/buffer.c     if (! BASE_EQ (buffer, obuffer))</span>
<span class='curline'><a href='../S/2152.html#L3672'>buffer</a>           3672 src/buffer.c         add_buffer_overlay (XBUFFER (buffer), XOVERLAY (overlay), n_beg, n_end);</span>
<span class='curline'><a href='../S/2152.html#L3679'>buffer</a>           3679 src/buffer.c     if (!BASE_EQ (buffer, obuffer))</span>
<span class='curline'><a href='../S/2152.html#L3719'>buffer</a>           3719 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/2152.html#L3748'>buffer</a>           3748 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L3750'>buffer</a>           3750 src/buffer.c     delete_all_overlays (decode_buffer (buffer));</span>
<span class='curline'><a href='../S/2152.html#L3783'>buffer</a>           3783 src/buffer.c     Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2152.html#L3790'>buffer</a>           3790 src/buffer.c     XSETBUFFER (buffer, OVERLAY_BUFFER (overlay));</span>
<span class='curline'><a href='../S/2152.html#L3792'>buffer</a>           3792 src/buffer.c     return buffer;</span>
<span class='curline'><a href='../S/2152.html#L3969'>buffer</a>           3969 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/2152.html#L4520'>buffer</a>           4520 src/buffer.c   alloc_buffer_text (struct buffer *b, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/2152.html#L4547'>buffer</a>           4547 src/buffer.c   enlarge_buffer_text (struct buffer *b, ptrdiff_t delta)</span>
<span class='curline'><a href='../S/2152.html#L4589'>buffer</a>           4589 src/buffer.c   free_buffer_text (struct buffer *b)</span>
<span class='curline'><a href='../S/2152.html#L4865'>buffer</a>           4865 src/buffer.c         Lisp_Object tail, buffer;</span>
<span class='curline'><a href='../S/2152.html#L4891'>buffer</a>           4891 src/buffer.c         FOR_EACH_LIVE_BUFFER (tail, buffer)</span>
<span class='curline'><a href='../S/2152.html#L4893'>buffer</a>           4893 src/buffer.c   	  struct buffer *b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2152.html#L5022'>buffer</a>           5022 src/buffer.c        (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2152.html#L5024'>buffer</a>           5024 src/buffer.c     struct buffer *b = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/2131.html#L162'>buffer</a>            162 src/buffer.h   extern void temp_set_point (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/2131.html#L164'>buffer</a>            164 src/buffer.h   extern void temp_set_point_both (struct buffer *,</span>
<span class='curline'><a href='../S/2131.html#L167'>buffer</a>            167 src/buffer.h   extern void enlarge_buffer_text (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/2131.html#L190'>buffer</a>            190 src/buffer.h   BUF_TEMP_SET_PT (struct buffer *buffer, ptrdiff_t position)</span>
<span class='curline'><a href='../S/2131.html#L192'>buffer</a>            192 src/buffer.h     temp_set_point (buffer, position);</span>
<span class='curline'><a href='../S/2131.html#L611'>buffer</a>            611 src/buffer.h     struct buffer *base_buffer;</span>
<span class='curline'><a href='../S/2131.html#L729'>buffer</a>            729 src/buffer.h   INLINE struct buffer *</span>
<span class='curline'><a href='../S/2131.html#L733'>buffer</a>            733 src/buffer.h     return XUNTAG (a, Lisp_Vectorlike, struct buffer);</span>
<span class='curline'><a href='../S/2131.html#L740'>buffer</a>            740 src/buffer.h   bset_bidi_paragraph_direction (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L745'>buffer</a>            745 src/buffer.h   bset_cache_long_scans (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L750'>buffer</a>            750 src/buffer.h   bset_case_canon_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L755'>buffer</a>            755 src/buffer.h   bset_case_eqv_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L760'>buffer</a>            760 src/buffer.h   bset_directory (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L765'>buffer</a>            765 src/buffer.h   bset_display_count (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L770'>buffer</a>            770 src/buffer.h   bset_left_margin_cols (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L775'>buffer</a>            775 src/buffer.h   bset_right_margin_cols (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L780'>buffer</a>            780 src/buffer.h   bset_display_time (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L785'>buffer</a>            785 src/buffer.h   bset_downcase_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L790'>buffer</a>            790 src/buffer.h   bset_enable_multibyte_characters (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L795'>buffer</a>            795 src/buffer.h   bset_filename (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L800'>buffer</a>            800 src/buffer.h   bset_keymap (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L805'>buffer</a>            805 src/buffer.h   bset_last_selected_window (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L810'>buffer</a>            810 src/buffer.h   bset_local_var_alist (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L815'>buffer</a>            815 src/buffer.h   bset_mark_active (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L820'>buffer</a>            820 src/buffer.h   bset_point_before_scroll (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L825'>buffer</a>            825 src/buffer.h   bset_read_only (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L830'>buffer</a>            830 src/buffer.h   bset_truncate_lines (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L835'>buffer</a>            835 src/buffer.h   bset_undo_list (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L840'>buffer</a>            840 src/buffer.h   bset_upcase_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L845'>buffer</a>            845 src/buffer.h   bset_width_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L851'>buffer</a>            851 src/buffer.h   bset_text_conversion_style (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2131.html#L878'>buffer</a>            878 src/buffer.h   BUF_BEGV (struct buffer *buf)</span>
<span class='curline'><a href='../S/2131.html#L886'>buffer</a>            886 src/buffer.h   BUF_BEGV_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/2131.html#L895'>buffer</a>            895 src/buffer.h   BUF_PT (struct buffer *buf)</span>
<span class='curline'><a href='../S/2131.html#L903'>buffer</a>            903 src/buffer.h   BUF_PT_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/2131.html#L912'>buffer</a>            912 src/buffer.h   BUF_ZV (struct buffer *buf)</span>
<span class='curline'><a href='../S/2131.html#L920'>buffer</a>            920 src/buffer.h   BUF_ZV_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/2131.html#L931'>buffer</a>            931 src/buffer.h   BUF_BEG (struct buffer *buf)</span>
<span class='curline'><a href='../S/2131.html#L937'>buffer</a>            937 src/buffer.h   BUF_BEG_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/2131.html#L944'>buffer</a>            944 src/buffer.h   BUF_GPT_ADDR (struct buffer *buf)</span>
<span class='curline'><a href='../S/2131.html#L951'>buffer</a>            951 src/buffer.h   BUF_Z_ADDR (struct buffer *buf)</span>
<span class='curline'><a href='../S/2131.html#L958'>buffer</a>            958 src/buffer.h   BUF_GAP_END_ADDR (struct buffer *buf)</span>
<span class='curline'><a href='../S/2131.html#L968'>buffer</a>            968 src/buffer.h   BUF_COMPUTE_UNCHANGED (struct buffer *buf, ptrdiff_t start, ptrdiff_t end)</span>
<span class='curline'><a href='../S/2131.html#L995'>buffer</a>            995 src/buffer.h   SET_BUF_BEGV (struct buffer *buf, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/2131.html#L1002'>buffer</a>           1002 src/buffer.h   SET_BUF_ZV (struct buffer *buf, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/2131.html#L1009'>buffer</a>           1009 src/buffer.h   SET_BUF_BEGV_BOTH (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t byte)</span>
<span class='curline'><a href='../S/2131.html#L1016'>buffer</a>           1016 src/buffer.h   SET_BUF_ZV_BOTH (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t byte)</span>
<span class='curline'><a href='../S/2131.html#L1023'>buffer</a>           1023 src/buffer.h   SET_BUF_PT_BOTH (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t byte)</span>
<span class='curline'><a href='../S/2131.html#L1083'>buffer</a>           1083 src/buffer.h   enum { BUFFER_LISP_SIZE = PSEUDOVECSIZE (struct buffer,</span>
<span class='curline'><a href='../S/2131.html#L1089'>buffer</a>           1089 src/buffer.h   enum { BUFFER_REST_SIZE = VECSIZE (struct buffer) - BUFFER_LISP_SIZE };</span>
<span class='curline'><a href='../S/2131.html#L1096'>buffer</a>           1096 src/buffer.h   BUFFER_PVEC_INIT (struct buffer *b)</span>
<span class='curline'><a href='../S/2131.html#L1104'>buffer</a>           1104 src/buffer.h   BUFFER_LIVE_P (struct buffer *b)</span>
<span class='curline'><a href='../S/2131.html#L1113'>buffer</a>           1113 src/buffer.h   BUFFER_HIDDEN_P (struct buffer *b)</span>
<span class='curline'><a href='../S/2131.html#L1121'>buffer</a>           1121 src/buffer.h   BUFFER_CHECK_INDIRECTION (struct buffer *b)</span>
<span class='curline'><a href='../S/2131.html#L1142'>buffer</a>           1142 src/buffer.h   extern struct buffer buffer_defaults;</span>
<span class='curline'><a href='../S/2131.html#L1158'>buffer</a>           1158 src/buffer.h   extern struct buffer buffer_local_flags;</span>
<span class='curline'><a href='../S/2131.html#L1164'>buffer</a>           1164 src/buffer.h   extern struct buffer buffer_local_symbols;</span>
<span class='curline'><a href='../S/2131.html#L1174'>buffer</a>           1174 src/buffer.h   extern void delete_all_overlays (struct buffer *);</span>
<span class='curline'><a href='../S/2131.html#L1175'>buffer</a>           1175 src/buffer.h   extern void reset_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/2131.html#L1176'>buffer</a>           1176 src/buffer.h   extern void compact_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/2131.html#L1183'>buffer</a>           1183 src/buffer.h   extern void recenter_overlay_lists (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/2131.html#L1186'>buffer</a>           1186 src/buffer.h   extern void set_buffer_internal_1 (struct buffer *);</span>
<span class='curline'><a href='../S/2131.html#L1187'>buffer</a>           1187 src/buffer.h   extern void set_buffer_internal_2 (struct buffer *);</span>
<span class='curline'><a href='../S/2131.html#L1188'>buffer</a>           1188 src/buffer.h   extern void set_buffer_temp (struct buffer *);</span>
<span class='curline'><a href='../S/2131.html#L1191'>buffer</a>           1191 src/buffer.h   extern void fix_overlays_before (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/2131.html#L1199'>buffer</a>           1199 src/buffer.h   INLINE struct buffer *</span>
<span class='curline'><a href='../S/2131.html#L1215'>buffer</a>           1215 src/buffer.h   set_buffer_internal (struct buffer *b)</span>
<span class='curline'><a href='../S/2131.html#L1260'>buffer</a>           1260 src/buffer.h   buffer_intervals (struct buffer *b)</span>
<span class='curline'><a href='../S/2131.html#L1269'>buffer</a>           1269 src/buffer.h   set_buffer_intervals (struct buffer *b, INTERVAL i)</span>
<span class='curline'><a href='../S/2131.html#L1303'>buffer</a>           1303 src/buffer.h   BUF_FETCH_MULTIBYTE_CHAR (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/2131.html#L1338'>buffer</a>           1338 src/buffer.h   BUF_BYTE_ADDRESS (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/2131.html#L1348'>buffer</a>           1348 src/buffer.h   BUF_CHAR_ADDRESS (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/2131.html#L1358'>buffer</a>           1358 src/buffer.h   BUF_PTR_BYTE_POS (struct buffer *buf, unsigned char *ptr)</span>
<span class='curline'><a href='../S/2131.html#L1368'>buffer</a>           1368 src/buffer.h   BUF_FETCH_BYTE (struct buffer *buf, ptrdiff_t n)</span>
<span class='curline'><a href='../S/2131.html#L1378'>buffer</a>           1378 src/buffer.h   BUF_FETCH_CHAR_AS_MULTIBYTE (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/2131.html#L1388'>buffer</a>           1388 src/buffer.h   buffer_window_count (struct buffer *b)</span>
<span class='curline'><a href='../S/2131.html#L1401'>buffer</a>           1401 src/buffer.h     if (! ov-&gt;buffer)</span>
<span class='curline'><a href='../S/2131.html#L1403'>buffer</a>           1403 src/buffer.h     return itree_node_begin (ov-&gt;buffer-&gt;overlays, ov-&gt;interval);</span>
<span class='curline'><a href='../S/2131.html#L1409'>buffer</a>           1409 src/buffer.h     if (! ov-&gt;buffer)</span>
<span class='curline'><a href='../S/2131.html#L1411'>buffer</a>           1411 src/buffer.h     return itree_node_end (ov-&gt;buffer-&gt;overlays, ov-&gt;interval);</span>
<span class='curline'><a href='../S/2131.html#L1441'>buffer</a>           1441 src/buffer.h   INLINE struct buffer *</span>
<span class='curline'><a href='../S/2131.html#L1444'>buffer</a>           1444 src/buffer.h     return XOVERLAY (ov)-&gt;buffer;</span>
<span class='curline'><a href='../S/2131.html#L1472'>buffer</a>           1472 src/buffer.h     offsetof (struct buffer, VAR ## _)</span>
<span class='curline'><a href='../S/2131.html#L1498'>buffer</a>           1498 src/buffer.h   PER_BUFFER_VALUE_P (struct buffer *b, int idx)</span>
<span class='curline'><a href='../S/2131.html#L1508'>buffer</a>           1508 src/buffer.h   SET_PER_BUFFER_VALUE_P (struct buffer *b, int idx, bool val)</span>
<span class='curline'><a href='../S/2131.html#L1559'>buffer</a>           1559 src/buffer.h   per_buffer_value (struct buffer *b, int offset)</span>
<span class='curline'><a href='../S/2131.html#L1565'>buffer</a>           1565 src/buffer.h   set_per_buffer_value (struct buffer *b, int offset, Lisp_Object value)</span>
<span class='curline'><a href='../S/2131.html#L1612'>buffer</a>           1612 src/buffer.h   SANE_TAB_WIDTH (struct buffer *buf)</span>
<span class='curline'><a href='../S/2131.html#L1692'>buffer</a>           1692 src/buffer.h   buf_next_char_len (struct buffer *buf, ptrdiff_t pos_byte)</span>
<span class='curline'><a href='../S/2131.html#L1708'>buffer</a>           1708 src/buffer.h   buf_prev_char_len (struct buffer *buf, ptrdiff_t pos_byte)</span>
<span class='curline'><a href='../S/2206.html#L245'>buffer</a>            245 src/callproc.c call_process_cleanup (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2206.html#L247'>buffer</a>            247 src/callproc.c   Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2206.html#L357'>buffer</a>            357 src/callproc.c   Lisp_Object buffer, current_dir, path;</span>
<span class='curline'><a href='../S/2206.html#L444'>buffer</a>            444 src/callproc.c     buffer = Qnil;</span>
<span class='curline'><a href='../S/2206.html#L447'>buffer</a>            447 src/callproc.c       buffer = args[2];</span>
<span class='curline'><a href='../S/2206.html#L452'>buffer</a>            452 src/callproc.c       if (CONSP (buffer) &amp;&amp; !EQ (XCAR (buffer), QCfile))</span>
<span class='curline'><a href='../S/2206.html#L454'>buffer</a>            454 src/callproc.c 	  if (CONSP (XCDR (buffer)))</span>
<span class='curline'><a href='../S/2206.html#L457'>buffer</a>            457 src/callproc.c 	      stderr_file = XCAR (XCDR (buffer));</span>
<span class='curline'><a href='../S/2206.html#L465'>buffer</a>            465 src/callproc.c 	  buffer = XCAR (buffer);</span>
<span class='curline'><a href='../S/2206.html#L469'>buffer</a>            469 src/callproc.c       if (CONSP (buffer) &amp;&amp; EQ (XCAR (buffer), QCfile))</span>
<span class='curline'><a href='../S/2206.html#L471'>buffer</a>            471 src/callproc.c 	  Lisp_Object ofile = XCDR (buffer);</span>
<span class='curline'><a href='../S/2206.html#L478'>buffer</a>            478 src/callproc.c 	  buffer = Qnil;</span>
<span class='curline'><a href='../S/2206.html#L481'>buffer</a>            481 src/callproc.c       if (! (NILP (buffer) || EQ (buffer, Qt) || FIXNUMP (buffer)))</span>
<span class='curline'><a href='../S/2206.html#L483'>buffer</a>            483 src/callproc.c 	  Lisp_Object spec_buffer = buffer;</span>
<span class='curline'><a href='../S/2206.html#L484'>buffer</a>            484 src/callproc.c 	  buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/2206.html#L486'>buffer</a>            486 src/callproc.c 	  if (NILP (buffer))</span>
<span class='curline'><a href='../S/2206.html#L488'>buffer</a>            488 src/callproc.c 	  CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2206.html#L554'>buffer</a>            554 src/callproc.c   discard_output = FIXNUMP (buffer) || (NILP (buffer) &amp;&amp; NILP (output_file));</span>
<span class='curline'><a href='../S/2206.html#L685'>buffer</a>            685 src/callproc.c       if (FIXNUMP (buffer))</span>
<span class='curline'><a href='../S/2206.html#L718'>buffer</a>            718 src/callproc.c   if (FIXNUMP (buffer))</span>
<span class='curline'><a href='../S/2206.html#L721'>buffer</a>            721 src/callproc.c   if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/2206.html#L722'>buffer</a>            722 src/callproc.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2187.html#L40'>buffer</a>             40 src/category.c bset_category_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2087.html#L913'>buffer</a>            913 src/coding.c         struct buffer *buf = XBUFFER (coding-&gt;src_object);</span>
<span class='curline'><a href='../S/2087.html#L1030'>buffer</a>           1030 src/coding.c         struct buffer *buf = XBUFFER (coding-&gt;dst_object);</span>
<span class='curline'><a href='../S/2087.html#L7874'>buffer</a>           7874 src/coding.c         struct buffer *current = current_buffer;</span>
<span class='curline'><a href='../S/2087.html#L7895'>buffer</a>           7895 src/coding.c     struct buffer *buf = XBUFFER (XCDR (arg));</span>
<span class='curline'><a href='../S/2087.html#L8394'>buffer</a>           8394 src/coding.c   	  struct buffer *current = current_buffer;</span>
<span class='curline'><a href='../S/2087.html#L9447'>buffer</a>           9447 src/coding.c         struct buffer *buf = XBUFFER (dst_object);</span>
<span class='curline'><a href='../S/2087.html#L9596'>buffer</a>           9596 src/coding.c         struct buffer *buf = XBUFFER (dst_object);</span>
<span class='curline'><a href='../S/2087.html#L9630'>buffer</a>           9630 src/coding.c   get_buffer_gap_address (Lisp_Object buffer, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/2087.html#L9632'>buffer</a>           9632 src/coding.c     struct buffer *buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2087.html#L9636'>buffer</a>           9636 src/coding.c         struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/2087.html#L9743'>buffer</a>           9743 src/coding.c   encode_string_utf_8 (Lisp_Object string, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/2087.html#L9748'>buffer</a>           9748 src/coding.c     if (NILP (buffer) &amp;&amp; nchars == nbytes &amp;&amp; nocopy)</span>
<span class='curline'><a href='../S/2087.html#L9918'>buffer</a>           9918 src/coding.c   	  if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/2087.html#L9921'>buffer</a>           9921 src/coding.c   	      dst = get_buffer_gap_address (buffer, nbytes);</span>
<span class='curline'><a href='../S/2087.html#L9936'>buffer</a>           9936 src/coding.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/2087.html#L9938'>buffer</a>           9938 src/coding.c         struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/2087.html#L9940'>buffer</a>           9940 src/coding.c         current_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2087.html#L10020'>buffer</a>           10020 src/coding.c   		     Lisp_Object buffer, bool nocopy,</span>
<span class='curline'><a href='../S/2087.html#L10097'>buffer</a>           10097 src/coding.c         &amp;&amp; NILP (buffer))</span>
<span class='curline'><a href='../S/2087.html#L10166'>buffer</a>           10166 src/coding.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/2087.html#L10169'>buffer</a>           10169 src/coding.c         dst = get_buffer_gap_address (buffer, outbytes);</span>
<span class='curline'><a href='../S/2087.html#L10246'>buffer</a>           10246 src/coding.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/2087.html#L10248'>buffer</a>           10248 src/coding.c         struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/2087.html#L10250'>buffer</a>           10250 src/coding.c         current_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2087.html#L10274'>buffer</a>           10274 src/coding.c     (Lisp_Object string, Lisp_Object buffer, Lisp_Object nocopy,</span>
<span class='curline'><a href='../S/2087.html#L10284'>buffer</a>           10284 src/coding.c     if (! NILP (buffer)</span>
<span class='curline'><a href='../S/2087.html#L10285'>buffer</a>           10285 src/coding.c         &amp;&amp; (! BUFFERP (buffer)</span>
<span class='curline'><a href='../S/2087.html#L10286'>buffer</a>           10286 src/coding.c   	  || ! NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/2087.html#L10307'>buffer</a>           10307 src/coding.c   	val = encode_string_utf_8 (string, buffer, ! NILP (nocopy),</span>
<span class='curline'><a href='../S/2087.html#L10330'>buffer</a>           10330 src/coding.c     (Lisp_Object string, Lisp_Object buffer, Lisp_Object nocopy,</span>
<span class='curline'><a href='../S/2087.html#L10340'>buffer</a>           10340 src/coding.c     if (! NILP (buffer)</span>
<span class='curline'><a href='../S/2087.html#L10341'>buffer</a>           10341 src/coding.c         &amp;&amp; (! BUFFERP (buffer)</span>
<span class='curline'><a href='../S/2087.html#L10342'>buffer</a>           10342 src/coding.c   	  || NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/2087.html#L10363'>buffer</a>           10363 src/coding.c   	val = decode_string_utf_8 (string, buffer, ! NILP (nocopy),</span>
<span class='curline'><a href='../S/2087.html#L10368'>buffer</a>           10368 src/coding.c         if (! BUFFERP (buffer))</span>
<span class='curline'><a href='../S/2087.html#L10369'>buffer</a>           10369 src/coding.c   	buffer = Qt;</span>
<span class='curline'><a href='../S/2087.html#L10371'>buffer</a>           10371 src/coding.c   	val = code_convert_string (string, Qutf_8_unix, buffer, false,</span>
<span class='curline'><a href='../S/2087.html#L10470'>buffer</a>           10470 src/coding.c     (Lisp_Object string, Lisp_Object coding_system, Lisp_Object nocopy, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2087.html#L10472'>buffer</a>           10472 src/coding.c     return code_convert_string (string, coding_system, buffer,</span>
<span class='curline'><a href='../S/2087.html#L10490'>buffer</a>           10490 src/coding.c     (Lisp_Object string, Lisp_Object coding_system, Lisp_Object nocopy, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2087.html#L10492'>buffer</a>           10492 src/coding.c     return code_convert_string (string, coding_system, buffer,</span>
<span class='curline'><a href='../S/2168.html#L1371'>buffer</a>           1371 src/data.c     			 struct buffer *buf)</span>
<span class='curline'><a href='../S/2168.html#L1410'>buffer</a>           1410 src/data.c     	      struct buffer *b = XBUFFER (buf);</span>
<span class='curline'><a href='../S/2168.html#L1727'>buffer</a>           1727 src/data.c     	struct buffer *buf</span>
<span class='curline'><a href='../S/2168.html#L2034'>buffer</a>           2034 src/data.c     		    struct buffer *b = XBUFFER (buf);</span>
<span class='curline'><a href='../S/2168.html#L2340'>buffer</a>           2340 src/data.c       (Lisp_Object variable, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2168.html#L2342'>buffer</a>           2342 src/data.c       struct buffer *buf = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/2168.html#L2391'>buffer</a>           2391 src/data.c       (register Lisp_Object variable, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2168.html#L2409'>buffer</a>           2409 src/data.c     	return Flocal_variable_p (variable, buffer);</span>
<span class='curline'><a href='../S/2168.html#L2963'>buffer</a>           2963 src/data.c     fixnum_to_string (EMACS_INT number, char *buffer, char *end)</span>
<span class='curline'><a href='../S/2168.html#L2972'>buffer</a>           2972 src/data.c           eassume (p &gt; buffer &amp;&amp; p - 1 &lt; end);</span>
<span class='curline'><a href='../S/2168.html#L2988'>buffer</a>           2988 src/data.c       char buffer[max (FLOAT_TO_STRING_BUFSIZE, INT_BUFSIZE_BOUND (EMACS_INT))];</span>
<span class='curline'><a href='../S/2168.html#L2992'>buffer</a>           2992 src/data.c           char *end = buffer + sizeof buffer;</span>
<span class='curline'><a href='../S/2168.html#L2993'>buffer</a>           2993 src/data.c           char *p = fixnum_to_string (XFIXNUM (number), buffer, end);</span>
<span class='curline'><a href='../S/2168.html#L3001'>buffer</a>           3001 src/data.c         return make_unibyte_string (buffer,</span>
<span class='curline'><a href='../S/2168.html#L3002'>buffer</a>           3002 src/data.c     				float_to_string (buffer, XFLOAT_DATA (number)));</span>
<span class='curline'><a href='../S/2316.html#L828'>buffer</a>            828 src/dispextern.h   struct buffer *buffer;</span>
<span class='curline'><a href='../S/2141.html#L1489'>buffer</a>           1489 src/dispnew.c    struct buffer *saved = current_buffer;</span>
<span class='curline'><a href='../S/2141.html#L1490'>buffer</a>           1490 src/dispnew.c    struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2141.html#L1497'>buffer</a>           1497 src/dispnew.c    set_buffer_temp (buffer);</span>
<span class='curline'><a href='../S/2160.html#L152'>buffer</a>            152 src/doprnt.c   doprnt_non_null_end (char *buffer, ptrdiff_t bufsize, char const *format,</span>
<span class='curline'><a href='../S/2160.html#L160'>buffer</a>            160 src/doprnt.c     ptrdiff_t nbytes = doprnt (buffer, bufsize, fmt, NULL, ap);</span>
<span class='curline'><a href='../S/2160.html#L186'>buffer</a>            186 src/doprnt.c   doprnt (char *buffer, ptrdiff_t bufsize, const char *format,</span>
<span class='curline'><a href='../S/2160.html#L190'>buffer</a>            190 src/doprnt.c       return doprnt_non_null_end (buffer, bufsize, format, format_end, ap);</span>
<span class='curline'><a href='../S/2160.html#L193'>buffer</a>            193 src/doprnt.c     char *bufptr = buffer;	/* Pointer into output buffer.  */</span>
<span class='curline'><a href='../S/2160.html#L534'>buffer</a>            534 src/doprnt.c     return bufptr - buffer;</span>
<span class='curline'><a href='../S/2298.html#L320'>buffer</a>            320 src/editfns.c        struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/2298.html#L820'>buffer</a>            820 src/editfns.c    Lisp_Object buffer = Fmarker_buffer (marker);</span>
<span class='curline'><a href='../S/2298.html#L823'>buffer</a>            823 src/editfns.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2298.html#L826'>buffer</a>            826 src/editfns.c    Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2298.html#L891'>buffer</a>            891 src/editfns.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2298.html#L893'>buffer</a>            893 src/editfns.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2298.html#L897'>buffer</a>            897 src/editfns.c        CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2298.html#L898'>buffer</a>            898 src/editfns.c        return make_fixnum (BUF_Z (XBUFFER (buffer))</span>
<span class='curline'><a href='../S/2298.html#L899'>buffer</a>            899 src/editfns.c  			  - BUF_BEG (XBUFFER (buffer)));</span>
<span class='curline'><a href='../S/2298.html#L1739'>buffer</a>           1739 src/editfns.c    (Lisp_Object buffer, Lisp_Object start, Lisp_Object end)</span>
<span class='curline'><a href='../S/2298.html#L1742'>buffer</a>           1742 src/editfns.c    register struct buffer *bp, *obuf;</span>
<span class='curline'><a href='../S/2298.html#L1745'>buffer</a>           1745 src/editfns.c    buf = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/2298.html#L1747'>buffer</a>           1747 src/editfns.c      nsberror (buffer);</span>
<span class='curline'><a href='../S/2298.html#L1785'>buffer</a>           1785 src/editfns.c    register struct buffer *bp1, *bp2;</span>
<span class='curline'><a href='../S/2298.html#L1916'>buffer</a>           1916 src/editfns.c    struct buffer *buffer_a;                      \</span>
<span class='curline'><a href='../S/2298.html#L1917'>buffer</a>           1917 src/editfns.c    struct buffer *buffer_b;                      \</span>
<span class='curline'><a href='../S/2298.html#L1976'>buffer</a>           1976 src/editfns.c    struct buffer *a = current_buffer;</span>
<span class='curline'><a href='../S/2298.html#L1980'>buffer</a>           1980 src/editfns.c    struct buffer *b = XBUFFER (source_buffer);</span>
<span class='curline'><a href='../S/2298.html#L2041'>buffer</a>           2041 src/editfns.c    ptrdiff_t *buffer;</span>
<span class='curline'><a href='../S/2298.html#L2043'>buffer</a>           2043 src/editfns.c    if (ckd_mul (&amp;bytes_needed, diags, 2 * sizeof *buffer)</span>
<span class='curline'><a href='../S/2298.html#L2047'>buffer</a>           2047 src/editfns.c    buffer = SAFE_ALLOCA (bytes_needed);</span>
<span class='curline'><a href='../S/2298.html#L2048'>buffer</a>           2048 src/editfns.c    unsigned char *deletions_insertions = memset (buffer + 2 * diags, 0,</span>
<span class='curline'><a href='../S/2298.html#L2064'>buffer</a>           2064 src/editfns.c      .fdiag = buffer + size_b + 1,</span>
<span class='curline'><a href='../S/2298.html#L2065'>buffer</a>           2065 src/editfns.c      .bdiag = buffer + diags + size_b + 1,</span>
<span class='curline'><a href='../S/2298.html#L3052'>buffer</a>           3052 src/editfns.c    struct buffer *cur = NULL;</span>
<span class='curline'><a href='../S/2298.html#L3053'>buffer</a>           3053 src/editfns.c    struct buffer *buf = (CONSP (data)</span>
<span class='curline'><a href='../S/2298.html#L3054'>buffer</a>           3054 src/editfns.c  			? XMARKER (XCAR (data))-&gt;buffer</span>
<span class='curline'><a href='../S/2298.html#L3071'>buffer</a>           3071 src/editfns.c        eassert (buf == end-&gt;buffer);</span>
<span class='curline'><a href='../S/2341.html#L1128'>buffer</a>           1128 src/emacs.c    read_full (int fd, void *buffer, ptrdiff_t size)</span>
<span class='curline'><a href='../S/2341.html#L1131'>buffer</a>           1131 src/emacs.c      eassert (buffer != NULL);</span>
<span class='curline'><a href='../S/2341.html#L1147'>buffer</a>           1147 src/emacs.c      char *ptr = buffer;</span>
<span class='curline'><a href='../S/2341.html#L1171'>buffer</a>           1171 src/emacs.c      void *buffer = NULL;</span>
<span class='curline'><a href='../S/2341.html#L1208'>buffer</a>           1208 src/emacs.c      buffer = malloc (size + 1);</span>
<span class='curline'><a href='../S/2341.html#L1209'>buffer</a>           1209 src/emacs.c      if (buffer == NULL)</span>
<span class='curline'><a href='../S/2341.html#L1214'>buffer</a>           1214 src/emacs.c      ptrdiff_t read = read_full (fd, buffer, size + 1);</span>
<span class='curline'><a href='../S/2341.html#L1232'>buffer</a>           1232 src/emacs.c      program.filter = buffer;</span>
<span class='curline'><a href='../S/2341.html#L1254'>buffer</a>           1254 src/emacs.c      free (buffer);</span>
<span class='curline'><a href='../S/2189.html#L2079'>buffer</a>           2079 src/eval.c       char *buffer = buf;</span>
<span class='curline'><a href='../S/2189.html#L2083'>buffer</a>           2083 src/eval.c       used = evxprintf (&amp;buffer, &amp;size, buf, size_max, m, ap);</span>
<span class='curline'><a href='../S/2189.html#L2084'>buffer</a>           2084 src/eval.c       string = make_string (buffer, used);</span>
<span class='curline'><a href='../S/2189.html#L2085'>buffer</a>           2085 src/eval.c       if (buffer != buf)</span>
<span class='curline'><a href='../S/2189.html#L2086'>buffer</a>           2086 src/eval.c         xfree (buffer);</span>
<span class='curline'><a href='../S/2317.html#L3854'>buffer</a>           3854 src/fileio.c     Lisp_Object buffer = XCDR (tmp);</span>
<span class='curline'><a href='../S/2317.html#L3856'>buffer</a>           3856 src/fileio.c     set_buffer_internal (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2317.html#L4013'>buffer</a>           4013 src/fileio.c   maybe_move_gap (struct buffer *b)</span>
<span class='curline'><a href='../S/2317.html#L4017'>buffer</a>           4017 src/fileio.c         struct buffer *cb = current_buffer;</span>
<span class='curline'><a href='../S/2317.html#L4290'>buffer</a>           4290 src/fileio.c   		  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2317.html#L4292'>buffer</a>           4292 src/fileio.c   		  struct buffer *buf;</span>
<span class='curline'><a href='../S/2317.html#L5358'>buffer</a>           5358 src/fileio.c     struct buffer *given_buffer;</span>
<span class='curline'><a href='../S/2317.html#L5719'>buffer</a>           5719 src/fileio.c         struct buffer *given_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2317.html#L5756'>buffer</a>           5756 src/fileio.c         struct buffer *given_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2317.html#L5945'>buffer</a>           5945 src/fileio.c     struct buffer *b = decode_buffer (buf);</span>
<span class='curline'><a href='../S/2317.html#L5973'>buffer</a>           5973 src/fileio.c   buffer_visited_file_modtime (struct buffer *buf)</span>
<span class='curline'><a href='../S/2317.html#L6150'>buffer</a>           6150 src/fileio.c     struct buffer *old = current_buffer, *b;</span>
<span class='curline'><a href='../S/2364.html#L792'>buffer</a>            792 src/filelock.c   register struct buffer *b;</span>
<span class='curline'><a href='../S/2364.html#L886'>buffer</a>            886 src/filelock.c unlock_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/2364.html#L888'>buffer</a>            888 src/filelock.c   if (BUF_SAVE_MODIFF (buffer) &lt; BUF_MODIFF (buffer)</span>
<span class='curline'><a href='../S/2364.html#L889'>buffer</a>            889 src/filelock.c       &amp;&amp; STRINGP (BVAR (buffer, file_truename)))</span>
<span class='curline'><a href='../S/2364.html#L890'>buffer</a>            890 src/filelock.c     Funlock_file (BVAR (buffer, file_truename));</span>
<span class='curline'><a href='../S/2321.html#L2844'>buffer</a>           2844 src/fns.c      	    return (XMARKER (o1)-&gt;buffer == XMARKER (o2)-&gt;buffer</span>
<span class='curline'><a href='../S/2321.html#L2845'>buffer</a>           2845 src/fns.c      		    &amp;&amp; (XMARKER (o1)-&gt;buffer == 0</span>
<span class='curline'><a href='../S/2321.html#L5155'>buffer</a>           5155 src/fns.c      	      = XMARKER (obj)-&gt;buffer ? XMARKER (obj)-&gt;bytepos : 0;</span>
<span class='curline'><a href='../S/2321.html#L5157'>buffer</a>           5157 src/fns.c      	      = sxhash_combine ((intptr_t) XMARKER (obj)-&gt;buffer, bytepos);</span>
<span class='curline'><a href='../S/2321.html#L5653'>buffer</a>           5653 src/fns.c            struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2321.html#L5658'>buffer</a>           5658 src/fns.c            struct buffer *bp = XBUFFER (object);</span>
<span class='curline'><a href='../S/2321.html#L5922'>buffer</a>           5922 src/fns.c        Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2321.html#L5923'>buffer</a>           5923 src/fns.c        struct buffer *b;</span>
<span class='curline'><a href='../S/2321.html#L5927'>buffer</a>           5927 src/fns.c          buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2321.html#L5929'>buffer</a>           5929 src/fns.c          buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/2321.html#L5930'>buffer</a>           5930 src/fns.c        if (NILP (buffer))</span>
<span class='curline'><a href='../S/2321.html#L5933'>buffer</a>           5933 src/fns.c        b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2321.html#L5962'>buffer</a>           5962 src/fns.c        Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2321.html#L5965'>buffer</a>           5965 src/fns.c        struct buffer *b;</span>
<span class='curline'><a href='../S/2321.html#L5968'>buffer</a>           5968 src/fns.c          buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2321.html#L5970'>buffer</a>           5970 src/fns.c          buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/2321.html#L5971'>buffer</a>           5971 src/fns.c        if (NILP (buffer))</span>
<span class='curline'><a href='../S/2321.html#L5974'>buffer</a>           5974 src/fns.c        b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2321.html#L6167'>buffer</a>           6167 src/fns.c            if (XMARKER (position)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/2294.html#L419'>buffer</a>            419 src/font.h       unsigned char *buffer;</span>
<span class='curline'><a href='../S/2248.html#L3135'>buffer</a>           3135 src/frame.c    frames_discard_buffer (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2248.html#L3142'>buffer</a>           3142 src/frame.c    	(XFRAME (frame), Fdelq (buffer, XFRAME (frame)-&gt;buffer_list));</span>
<span class='curline'><a href='../S/2248.html#L3144'>buffer</a>           3144 src/frame.c    	(XFRAME (frame), Fdelq (buffer, XFRAME (frame)-&gt;buried_buffer_list));</span>
<span class='curline'><a href='../S/2355.html#L934'>buffer</a>            934 src/fringe.c     struct buffer *oldbuf = current_buffer;</span>
<span class='curline'><a href='../S/2344.html#L1665'>buffer</a>           1665 src/ftfont.c     bitmap-&gt;buffer = ft_face-&gt;glyph-&gt;bitmap.buffer;</span>
<span class='curline'><a href='../S/2363.html#L1429'>buffer</a>           1429 src/gtkutil.c        char buffer[sizeof format];</span>
<span class='curline'><a href='../S/2363.html#L1430'>buffer</a>           1430 src/gtkutil.c        int n = snprintf(buffer, sizeof buffer, format,</span>
<span class='curline'><a href='../S/2363.html#L1433'>buffer</a>           1433 src/gtkutil.c        eassert (n &lt; sizeof buffer);</span>
<span class='curline'><a href='../S/2363.html#L1435'>buffer</a>           1435 src/gtkutil.c        gtk_css_provider_load_from_data (provider, buffer, -1, NULL);</span>
<span class='curline'><a href='../S/2227.html#L5531'>buffer</a>           5531 src/haiku_support.cc   char *buffer;</span>
<span class='curline'><a href='../S/2227.html#L5544'>buffer</a>           5544 src/haiku_support.cc   buffer = new (std::nothrow) char[flat];</span>
<span class='curline'><a href='../S/2227.html#L5545'>buffer</a>           5545 src/haiku_support.cc   if (!buffer)</span>
<span class='curline'><a href='../S/2227.html#L5548'>buffer</a>           5548 src/haiku_support.cc   rc = msg-&gt;Flatten (buffer, flat);</span>
<span class='curline'><a href='../S/2227.html#L5551'>buffer</a>           5551 src/haiku_support.cc       delete[] buffer;</span>
<span class='curline'><a href='../S/2227.html#L5556'>buffer</a>           5556 src/haiku_support.cc 			   buffer, flat);</span>
<span class='curline'><a href='../S/2227.html#L5557'>buffer</a>           5557 src/haiku_support.cc   delete[] buffer;</span>
<span class='curline'><a href='../S/2097.html#L2401'>buffer</a>           2401 src/haikufns.c   struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/2332.html#L563'>buffer</a>            563 src/haikumenu.c   struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2332.html#L564'>buffer</a>            564 src/haikumenu.c   Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2332.html#L617'>buffer</a>            617 src/haikumenu.c       buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/2332.html#L630'>buffer</a>            630 src/haikumenu.c       set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2205.html#L4779'>buffer</a>           4779 src/image.c      char buffer[BUFSIZ];</span>
<span class='curline'><a href='../S/2205.html#L4788'>buffer</a>           4788 src/image.c         LA1 = xbm_scan (&amp;s, end, buffer, &amp;value)</span>
<span class='curline'><a href='../S/2205.html#L4800'>buffer</a>           4800 src/image.c         if (LA1 == XBM_TK_IDENT &amp;&amp; strcmp (buffer, (IDENT)) == 0)	\</span>
<span class='curline'><a href='../S/2205.html#L4808'>buffer</a>           4808 src/image.c      LA1 = xbm_scan (&amp;s, end, buffer, &amp;value);</span>
<span class='curline'><a href='../S/2205.html#L4819'>buffer</a>           4819 src/image.c    	  char *q = strrchr (buffer, '_');</span>
<span class='curline'><a href='../S/2205.html#L4820'>buffer</a>           4820 src/image.c    	  q = q ? q + 1 : buffer;</span>
<span class='curline'><a href='../S/2205.html#L4842'>buffer</a>           4842 src/image.c          if (strcmp (buffer, "unsigned") == 0)</span>
<span class='curline'><a href='../S/2205.html#L4847'>buffer</a>           4847 src/image.c          else if (strcmp (buffer, "short") == 0)</span>
<span class='curline'><a href='../S/2205.html#L4854'>buffer</a>           4854 src/image.c          else if (strcmp (buffer, "char") == 0)</span>
<span class='curline'><a href='../S/2205.html#L5705'>buffer</a>           5705 src/image.c          Lisp_Object buffer = image_spec_value (img-&gt;spec, QCdata, NULL);</span>
<span class='curline'><a href='../S/2205.html#L5706'>buffer</a>           5706 src/image.c          if (!STRINGP (buffer))</span>
<span class='curline'><a href='../S/2205.html#L5708'>buffer</a>           5708 src/image.c    	  image_error ("Invalid image data `%s'", buffer);</span>
<span class='curline'><a href='../S/2205.html#L5718'>buffer</a>           5718 src/image.c          rc = XpmCreateImageFromBuffer (&amp;hdc, SSDATA (buffer),</span>
<span class='curline'><a href='../S/2205.html#L5722'>buffer</a>           5722 src/image.c          rc = XpmCreateImageFromBuffer (FRAME_X_DISPLAY (f), SSDATA (buffer),</span>
<span class='curline'><a href='../S/2205.html#L6064'>buffer</a>           6064 src/image.c      char buffer[BUFSIZ];</span>
<span class='curline'><a href='../S/2205.html#L6112'>buffer</a>           6112 src/image.c      memcpy (buffer, beg, len);</span>
<span class='curline'><a href='../S/2205.html#L6113'>buffer</a>           6113 src/image.c      buffer[len] = '\0';</span>
<span class='curline'><a href='../S/2205.html#L6114'>buffer</a>           6114 src/image.c      if (sscanf (buffer, "%d %d %d %d", &amp;width, &amp;height,</span>
<span class='curline'><a href='../S/2205.html#L6166'>buffer</a>           6166 src/image.c          memcpy (buffer, beg + chars_per_pixel, len - chars_per_pixel);</span>
<span class='curline'><a href='../S/2205.html#L6167'>buffer</a>           6167 src/image.c          buffer[len - chars_per_pixel] = '\0';</span>
<span class='curline'><a href='../S/2205.html#L6169'>buffer</a>           6169 src/image.c          str = strtok (buffer, " \t");</span>
<span class='curline'><a href='../S/2205.html#L8621'>buffer</a>           8621 src/image.c      JOCTET *buffer;</span>
<span class='curline'><a href='../S/2205.html#L8643'>buffer</a>           8643 src/image.c          bytes = fread (src-&gt;buffer, 1, JPEG_STDIO_BUFFER_SIZE, src-&gt;file);</span>
<span class='curline'><a href='../S/2205.html#L8650'>buffer</a>           8650 src/image.c              src-&gt;buffer[0] = (JOCTET) 0xFF;</span>
<span class='curline'><a href='../S/2205.html#L8651'>buffer</a>           8651 src/image.c              src-&gt;buffer[1] = (JOCTET) JPEG_EOI;</span>
<span class='curline'><a href='../S/2205.html#L8654'>buffer</a>           8654 src/image.c          src-&gt;mgr.next_input_byte = src-&gt;buffer;</span>
<span class='curline'><a href='../S/2205.html#L8705'>buffer</a>           8705 src/image.c          src-&gt;buffer = cinfo-&gt;mem-&gt;alloc_small ((j_common_ptr) cinfo,</span>
<span class='curline'><a href='../S/2205.html#L8730'>buffer</a>           8730 src/image.c      JSAMPARRAY buffer;</span>
<span class='curline'><a href='../S/2205.html#L8875'>buffer</a>           8875 src/image.c      buffer = mgr-&gt;cinfo.mem-&gt;alloc_sarray ((j_common_ptr) &amp;mgr-&gt;cinfo,</span>
<span class='curline'><a href='../S/2205.html#L8879'>buffer</a>           8879 src/image.c          jpeg_read_scanlines (&amp;mgr-&gt;cinfo, buffer, 1);</span>
<span class='curline'><a href='../S/2205.html#L8881'>buffer</a>           8881 src/image.c    	PUT_PIXEL (ximg, x, y, colors[buffer[0][x]]);</span>
<span class='curline'><a href='../S/2205.html#L12265'>buffer</a>           12265 src/image.c      char buffer[sizeof " " + 2 * INT_STRLEN_BOUND (intmax_t)];</span>
<span class='curline'><a href='../S/2205.html#L12317'>buffer</a>           12317 src/image.c        = make_formatted_string (buffer, "%"PRIuMAX" %"PRIuMAX,</span>
<span class='curline'><a href='../S/2205.html#L12323'>buffer</a>           12323 src/image.c        = make_formatted_string (buffer, "%"PRIuMAX" %"PRIuMAX,</span>
<span class='curline'><a href='../S/2319.html#L127'>buffer</a>            127 src/indent.c   recompute_width_table (struct buffer *buf, struct Lisp_Char_Table *disptab)</span>
<span class='curline'><a href='../S/2319.html#L147'>buffer</a>            147 src/indent.c     struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2319.html#L220'>buffer</a>            220 src/indent.c     Lisp_Object buffer, tmp;</span>
<span class='curline'><a href='../S/2319.html#L225'>buffer</a>            225 src/indent.c     XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/2319.html#L233'>buffer</a>            233 src/indent.c     proplimit = Fnext_property_change (position, buffer, Qt);</span>
<span class='curline'><a href='../S/2319.html#L250'>buffer</a>            250 src/indent.c   					  buffer, proplimit);</span>
<span class='curline'><a href='../S/2319.html#L267'>buffer</a>            267 src/indent.c   			      &amp;&amp; EQ (XWINDOW (window)-&gt;contents, buffer))</span>
<span class='curline'><a href='../S/2319.html#L268'>buffer</a>            268 src/indent.c   			     ? window : buffer);</span>
<span class='curline'><a href='../S/2319.html#L1245'>buffer</a>           1245 src/indent.c     struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2319.html#L2047'>buffer</a>           2047 src/indent.c         struct buffer *old_buf = current_buffer;</span>
<span class='curline'><a href='../S/2319.html#L2062'>buffer</a>           2062 src/indent.c   	       &amp;&amp; XBUFFER (w-&gt;contents) == XMARKER (w-&gt;start)-&gt;buffer))</span>
<span class='curline'><a href='../S/2362.html#L57'>buffer</a>             57 src/indent.h   void recompute_width_table (struct buffer *buf,</span>
<span class='curline'><a href='../S/2336.html#L324'>buffer</a>            324 src/inotify.c    char *buffer = SAFE_ALLOCA (to_read);</span>
<span class='curline'><a href='../S/2336.html#L325'>buffer</a>            325 src/inotify.c    ssize_t n = read (fd, buffer, to_read);</span>
<span class='curline'><a href='../S/2336.html#L335'>buffer</a>            335 src/inotify.c        struct inotify_event *ev = (struct inotify_event *) &amp;buffer[i];</span>
<span class='curline'><a href='../S/2223.html#L40'>buffer</a>             40 src/insdel.c   static void insert_from_buffer_1 (struct buffer *, ptrdiff_t, ptrdiff_t, bool);</span>
<span class='curline'><a href='../S/2223.html#L73'>buffer</a>             73 src/insdel.c         if (tail-&gt;buffer-&gt;text != current_buffer-&gt;text)</span>
<span class='curline'><a href='../S/2223.html#L600'>buffer</a>            600 src/insdel.c   make_gap_1 (struct buffer *b, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/2223.html#L602'>buffer</a>            602 src/insdel.c     struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/2223.html#L1177'>buffer</a>           1177 src/insdel.c   insert_from_buffer (struct buffer *buf,</span>
<span class='curline'><a href='../S/2223.html#L1202'>buffer</a>           1202 src/insdel.c   insert_from_buffer_1 (struct buffer *buf,</span>
<span class='curline'><a href='../S/2223.html#L2008'>buffer</a>           2008 src/insdel.c     struct buffer *base_buffer;</span>
<span class='curline'><a href='../S/2223.html#L2059'>buffer</a>           2059 src/insdel.c         &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer</span>
<span class='curline'><a href='../S/2223.html#L2086'>buffer</a>           2086 src/insdel.c   invalidate_buffer_caches (struct buffer *buf, ptrdiff_t start, ptrdiff_t end)</span>
<span class='curline'><a href='../S/2223.html#L2113'>buffer</a>           2113 src/insdel.c   	      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2218.html#L468'>buffer</a>            468 src/intervals.c buffer_balance_intervals (struct buffer *b)</span>
<span class='curline'><a href='../S/2218.html#L1309'>buffer</a>           1309 src/intervals.c adjust_intervals_for_deletion (struct buffer *buffer,</span>
<span class='curline'><a href='../S/2218.html#L1313'>buffer</a>           1313 src/intervals.c   INTERVAL tree = buffer_intervals (buffer);</span>
<span class='curline'><a href='../S/2218.html#L1328'>buffer</a>           1328 src/intervals.c       set_buffer_intervals (buffer, NULL);</span>
<span class='curline'><a href='../S/2218.html#L1345'>buffer</a>           1345 src/intervals.c       tree = buffer_intervals (buffer);</span>
<span class='curline'><a href='../S/2218.html#L1348'>buffer</a>           1348 src/intervals.c 	  set_buffer_intervals (buffer, NULL);</span>
<span class='curline'><a href='../S/2218.html#L1360'>buffer</a>           1360 src/intervals.c offset_intervals (struct buffer *buffer, ptrdiff_t start, ptrdiff_t length)</span>
<span class='curline'><a href='../S/2218.html#L1362'>buffer</a>           1362 src/intervals.c   if (!buffer_intervals (buffer) || length == 0)</span>
<span class='curline'><a href='../S/2218.html#L1366'>buffer</a>           1366 src/intervals.c     adjust_intervals_for_insertion (buffer_intervals (buffer),</span>
<span class='curline'><a href='../S/2218.html#L1369'>buffer</a>           1369 src/intervals.c     adjust_intervals_for_deletion (buffer, start, -length);</span>
<span class='curline'><a href='../S/2218.html#L1569'>buffer</a>           1569 src/intervals.c 			     ptrdiff_t length, struct buffer *buffer,</span>
<span class='curline'><a href='../S/2218.html#L1572'>buffer</a>           1572 src/intervals.c   INTERVAL tree = buffer_intervals (buffer);</span>
<span class='curline'><a href='../S/2218.html#L1585'>buffer</a>           1585 src/intervals.c 	  XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/2218.html#L1592'>buffer</a>           1592 src/intervals.c       buffer_balance_intervals (buffer);</span>
<span class='curline'><a href='../S/2218.html#L1598'>buffer</a>           1598 src/intervals.c   if ((BUF_Z (buffer) - BUF_BEG (buffer)) == length)</span>
<span class='curline'><a href='../S/2218.html#L1604'>buffer</a>           1604 src/intervals.c       XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/2218.html#L1605'>buffer</a>           1605 src/intervals.c       set_buffer_intervals (buffer, reproduce_tree_obj (source, buf));</span>
<span class='curline'><a href='../S/2218.html#L1606'>buffer</a>           1606 src/intervals.c       buffer_intervals (buffer)-&gt;position = BUF_BEG (buffer);</span>
<span class='curline'><a href='../S/2218.html#L1607'>buffer</a>           1607 src/intervals.c       eassert (buffer_intervals (buffer)-&gt;up_obj == 1);</span>
<span class='curline'><a href='../S/2218.html#L1616'>buffer</a>           1616 src/intervals.c 	XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/2218.html#L1699'>buffer</a>           1699 src/intervals.c   buffer_balance_intervals (buffer);</span>
<span class='curline'><a href='../S/2218.html#L1753'>buffer</a>           1753 src/intervals.c temp_set_point_both (struct buffer *buffer,</span>
<span class='curline'><a href='../S/2218.html#L1757'>buffer</a>           1757 src/intervals.c   eassert (BUF_ZV (buffer) != BUF_ZV_BYTE (buffer) || charpos == bytepos);</span>
<span class='curline'><a href='../S/2218.html#L1760'>buffer</a>           1760 src/intervals.c   eassert (charpos &lt;= BUF_ZV (buffer) || BUF_BEGV (buffer) &lt;= charpos);</span>
<span class='curline'><a href='../S/2218.html#L1762'>buffer</a>           1762 src/intervals.c   SET_BUF_PT_BOTH (buffer, charpos, bytepos);</span>
<span class='curline'><a href='../S/2218.html#L1768'>buffer</a>           1768 src/intervals.c temp_set_point (struct buffer *buffer, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/2218.html#L1770'>buffer</a>           1770 src/intervals.c   temp_set_point_both (buffer, charpos,</span>
<span class='curline'><a href='../S/2218.html#L1771'>buffer</a>           1771 src/intervals.c 		       buf_charpos_to_bytepos (buffer, charpos));</span>
<span class='curline'><a href='../S/2218.html#L1793'>buffer</a>           1793 src/intervals.c   if (XMARKER (marker)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/2218.html#L2178'>buffer</a>           2178 src/intervals.c get_local_map (ptrdiff_t position, struct buffer *buffer, Lisp_Object type)</span>
<span class='curline'><a href='../S/2218.html#L2184'>buffer</a>           2184 src/intervals.c   position = clip_to_bounds (BUF_BEGV (buffer), position, BUF_ZV (buffer));</span>
<span class='curline'><a href='../S/2218.html#L2188'>buffer</a>           2188 src/intervals.c   old_begv = BUF_BEGV (buffer);</span>
<span class='curline'><a href='../S/2218.html#L2189'>buffer</a>           2189 src/intervals.c   old_zv = BUF_ZV (buffer);</span>
<span class='curline'><a href='../S/2218.html#L2190'>buffer</a>           2190 src/intervals.c   old_begv_byte = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2218.html#L2191'>buffer</a>           2191 src/intervals.c   old_zv_byte = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2218.html#L2194'>buffer</a>           2194 src/intervals.c   SET_BUF_BEGV_BOTH (buffer, BUF_BEG (buffer), BUF_BEG_BYTE (buffer));</span>
<span class='curline'><a href='../S/2218.html#L2195'>buffer</a>           2195 src/intervals.c   SET_BUF_ZV_BOTH (buffer, BUF_Z (buffer), BUF_Z_BYTE (buffer));</span>
<span class='curline'><a href='../S/2218.html#L2198'>buffer</a>           2198 src/intervals.c   XSETBUFFER (lispy_buffer, buffer);</span>
<span class='curline'><a href='../S/2218.html#L2209'>buffer</a>           2209 src/intervals.c   SET_BUF_BEGV_BOTH (buffer, old_begv, old_begv_byte);</span>
<span class='curline'><a href='../S/2218.html#L2210'>buffer</a>           2210 src/intervals.c   SET_BUF_ZV_BOTH (buffer, old_zv, old_zv_byte);</span>
<span class='curline'><a href='../S/2218.html#L2221'>buffer</a>           2221 src/intervals.c     return BVAR (buffer, keymap);</span>
<span class='curline'><a href='../S/2218.html#L2269'>buffer</a>           2269 src/intervals.c copy_intervals_to_string (Lisp_Object string, struct buffer *buffer,</span>
<span class='curline'><a href='../S/2218.html#L2272'>buffer</a>           2272 src/intervals.c   INTERVAL interval_copy = copy_intervals (buffer_intervals (buffer),</span>
<span class='curline'><a href='../S/2229.html#L259'>buffer</a>            259 src/intervals.h extern void offset_intervals (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/2229.html#L261'>buffer</a>            261 src/intervals.h                                          struct buffer *, bool);</span>
<span class='curline'><a href='../S/2229.html#L262'>buffer</a>            262 src/intervals.h extern void verify_interval_modification (struct buffer *,</span>
<span class='curline'><a href='../S/2229.html#L265'>buffer</a>            265 src/intervals.h extern void copy_intervals_to_string (Lisp_Object, struct buffer *,</span>
<span class='curline'><a href='../S/2229.html#L274'>buffer</a>            274 src/intervals.h extern Lisp_Object get_local_map (ptrdiff_t, struct buffer *, Lisp_Object);</span>
<span class='curline'><a href='../S/2229.html#L301'>buffer</a>            301 src/intervals.h                                      Lisp_Object buffer);</span>
<span class='curline'><a href='../S/2366.html#L644'>buffer</a>            644 src/json.c       const char *buffer;</span>
<span class='curline'><a href='../S/2366.html#L665'>buffer</a>            665 src/json.c     	  buffer_and_size-&gt;buffer, len);</span>
<span class='curline'><a href='../S/2366.html#L701'>buffer</a>            701 src/json.c     json_insert_callback (const char *buffer, size_t size, void *data)</span>
<span class='curline'><a href='../S/2366.html#L705'>buffer</a>            705 src/json.c         = {.buffer = buffer, .size = size, .inserted_bytes = d-&gt;inserted_bytes};</span>
<span class='curline'><a href='../S/2366.html#L1009'>buffer</a>           1009 src/json.c     json_read_buffer_callback (void *buffer, size_t buflen, void *data)</span>
<span class='curline'><a href='../S/2366.html#L1020'>buffer</a>           1020 src/json.c       memcpy (buffer, BYTE_POS_ADDR (point), count);</span>
<span class='curline'><a href='../S/2105.html#L237'>buffer</a>            237 src/keyboard.c struct buffer *buffer_before_last_command_or_undo;</span>
<span class='curline'><a href='../S/2105.html#L335'>buffer</a>            335 src/keyboard.c static void recursive_edit_unwind (Lisp_Object buffer);</span>
<span class='curline'><a href='../S/2105.html#L504'>buffer</a>            504 src/keyboard.c   char *buffer = initbuf;</span>
<span class='curline'><a href='../S/2105.html#L505'>buffer</a>            505 src/keyboard.c   char *ptr = buffer;</span>
<span class='curline'><a href='../S/2105.html#L523'>buffer</a>            523 src/keyboard.c       if (size - (ptr - buffer) &lt; nbytes)</span>
<span class='curline'><a href='../S/2105.html#L525'>buffer</a>            525 src/keyboard.c 	  ptrdiff_t offset = ptr - buffer;</span>
<span class='curline'><a href='../S/2105.html#L527'>buffer</a>            527 src/keyboard.c 	  buffer = SAFE_ALLOCA (size);</span>
<span class='curline'><a href='../S/2105.html#L528'>buffer</a>            528 src/keyboard.c 	  ptr = buffer + offset;</span>
<span class='curline'><a href='../S/2105.html#L535'>buffer</a>            535 src/keyboard.c   Lisp_Object new_string = make_string (buffer, ptr - buffer);</span>
<span class='curline'><a href='../S/2105.html#L800'>buffer</a>            800 src/keyboard.c   Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2105.html#L809'>buffer</a>            809 src/keyboard.c     buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2105.html#L811'>buffer</a>            811 src/keyboard.c     buffer = Qnil;</span>
<span class='curline'><a href='../S/2105.html#L818'>buffer</a>            818 src/keyboard.c   record_unwind_protect (recursive_edit_unwind, buffer);</span>
<span class='curline'><a href='../S/2105.html#L832'>buffer</a>            832 src/keyboard.c recursive_edit_unwind (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2105.html#L834'>buffer</a>            834 src/keyboard.c   if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/2105.html#L835'>buffer</a>            835 src/keyboard.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2105.html#L1304'>buffer</a>           1304 src/keyboard.c   struct buffer *prev_buffer = NULL;</span>
<span class='curline'><a href='../S/2105.html#L1441'>buffer</a>           1441 src/keyboard.c 	  struct buffer *b;</span>
<span class='curline'><a href='../S/2105.html#L1608'>buffer</a>           1608 src/keyboard.c 		  &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer</span>
<span class='curline'><a href='../S/2105.html#L3051'>buffer</a>           3051 src/keyboard.c       struct buffer *prev_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2105.html#L10264'>buffer</a>           10264 src/keyboard.c   struct buffer *starting_buffer;</span>
<span class='curline'><a href='../S/2186.html#L268'>buffer</a>            268 src/keyboard.h extern struct buffer *buffer_before_last_command_or_undo;</span>
<span class='curline'><a href='../S/2186.html#L270'>buffer</a>            270 src/keyboard.h extern struct buffer *prev_buffer;</span>
<span class='curline'><a href='../S/2226.html#L2342'>buffer</a>           2342 src/keymap.c   	  char *buffer = SAFE_ALLOCA (len + 3);</span>
<span class='curline'><a href='../S/2226.html#L2343'>buffer</a>           2343 src/keymap.c   	  memcpy (buffer, sym, i);</span>
<span class='curline'><a href='../S/2226.html#L2344'>buffer</a>           2344 src/keymap.c   	  buffer[i] = '&lt;';</span>
<span class='curline'><a href='../S/2226.html#L2345'>buffer</a>           2345 src/keymap.c   	  memcpy (buffer + i + 1, sym + i, len - i);</span>
<span class='curline'><a href='../S/2226.html#L2346'>buffer</a>           2346 src/keymap.c   	  buffer [len + 1] = '&gt;';</span>
<span class='curline'><a href='../S/2226.html#L2347'>buffer</a>           2347 src/keymap.c   	  buffer [len + 2] = '\0';</span>
<span class='curline'><a href='../S/2226.html#L2348'>buffer</a>           2348 src/keymap.c   	  Lisp_Object result = build_string (buffer);</span>
<span class='curline'><a href='../S/2226.html#L2832'>buffer</a>           2832 src/keymap.c     (Lisp_Object buffer, Lisp_Object prefix, Lisp_Object menus)</span>
<span class='curline'><a href='../S/2226.html#L2842'>buffer</a>           2842 src/keymap.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2226.html#L2886'>buffer</a>           2886 src/keymap.c   	     msg, nomenu, Qt, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2226.html#L2900'>buffer</a>           2900 src/keymap.c   	     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2226.html#L2913'>buffer</a>           2913 src/keymap.c   	     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2226.html#L2923'>buffer</a>           2923 src/keymap.c         Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2226.html#L2928'>buffer</a>           2928 src/keymap.c         start1 = get_local_map (BUF_PT (XBUFFER (buffer)),</span>
<span class='curline'><a href='../S/2226.html#L2929'>buffer</a>           2929 src/keymap.c   			      XBUFFER (buffer), Qkeymap);</span>
<span class='curline'><a href='../S/2226.html#L2936'>buffer</a>           2936 src/keymap.c   		 msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2226.html#L2969'>buffer</a>           2969 src/keymap.c   		 msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2226.html#L2974'>buffer</a>           2974 src/keymap.c         start1 = get_local_map (BUF_PT (XBUFFER (buffer)),</span>
<span class='curline'><a href='../S/2226.html#L2975'>buffer</a>           2975 src/keymap.c   			      XBUFFER (buffer), Qlocal_map);</span>
<span class='curline'><a href='../S/2226.html#L2978'>buffer</a>           2978 src/keymap.c   	  if (EQ (start1, BVAR (XBUFFER (buffer), keymap)))</span>
<span class='curline'><a href='../S/2226.html#L2983'>buffer</a>           2983 src/keymap.c   		       XBUFFER (buffer)-&gt;major_mode_);</span>
<span class='curline'><a href='../S/2226.html#L2987'>buffer</a>           2987 src/keymap.c   		     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2226.html#L2995'>buffer</a>           2995 src/keymap.c   		     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2226.html#L3006'>buffer</a>           3006 src/keymap.c   	 msg, nomenu, Qnil, Qt, Qnil, buffer);</span>
<span class='curline'><a href='../S/2226.html#L3015'>buffer</a>           3015 src/keymap.c   	     msg, nomenu, Qt, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2226.html#L3025'>buffer</a>           3025 src/keymap.c   	     msg, nomenu, Qt, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2226.html#L3315'>buffer</a>           3315 src/keymap.c   	      char *buffer =</span>
<span class='curline'><a href='../S/2226.html#L3317'>buffer</a>           3317 src/keymap.c   	      esprintf (buffer, fmt, SDATA (SYMBOL_NAME (shadowed_by)));</span>
<span class='curline'><a href='../S/2226.html#L3318'>buffer</a>           3318 src/keymap.c   	      insert_string (buffer);</span>
<span class='curline'><a href='../S/2268.html#L647'>buffer</a>            647 src/lisp.h     extern char *fixnum_to_string (EMACS_INT number, char *buffer, char *end);</span>
<span class='curline'><a href='../S/2268.html#L2571'>buffer</a>           2571 src/lisp.h       struct buffer *buffer;</span>
<span class='curline'><a href='../S/2268.html#L2611'>buffer</a>           2611 src/lisp.h         struct buffer *buffer;        /* eassert (live buffer || NULL). */</span>
<span class='curline'><a href='../S/2268.html#L4096'>buffer</a>           4096 src/lisp.h     extern void make_gap_1 (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/2268.html#L4111'>buffer</a>           4111 src/lisp.h     extern void insert_from_buffer (struct buffer *, ptrdiff_t, ptrdiff_t, bool);</span>
<span class='curline'><a href='../S/2268.html#L4129'>buffer</a>           4129 src/lisp.h     extern void invalidate_buffer_caches (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/2268.html#L4438'>buffer</a>           4438 src/lisp.h     extern struct buffer *allocate_buffer (void) ATTRIBUTE_RETURNS_NONNULL;</span>
<span class='curline'><a href='../S/2268.html#L4724'>buffer</a>           4724 src/lisp.h     extern void clear_charpos_cache (struct buffer *);</span>
<span class='curline'><a href='../S/2268.html#L4725'>buffer</a>           4725 src/lisp.h     extern ptrdiff_t buf_charpos_to_bytepos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/2268.html#L4726'>buffer</a>           4726 src/lisp.h     extern ptrdiff_t buf_bytepos_to_charpos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/2268.html#L4733'>buffer</a>           4733 src/lisp.h     extern Lisp_Object build_marker (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/2268.html#L4760'>buffer</a>           4760 src/lisp.h     extern Lisp_Object buffer_visited_file_modtime (struct buffer *);</span>
<span class='curline'><a href='../S/2268.html#L5024'>buffer</a>           5024 src/lisp.h     extern void truncate_undo_list (struct buffer *);</span>
<span class='curline'><a href='../S/2268.html#L5102'>buffer</a>           5102 src/lisp.h     extern void unlock_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/2268.html#L5238'>buffer</a>           5238 src/lisp.h     				 struct buffer *);</span>
<span class='curline'><a href='../S/2254.html#L304'>buffer</a>            304 src/lread.c          register struct buffer *inbuffer = XBUFFER (readcharfun);</span>
<span class='curline'><a href='../S/2254.html#L337'>buffer</a>            337 src/lread.c          register struct buffer *inbuffer = XMARKER (readcharfun)-&gt;buffer;</span>
<span class='curline'><a href='../S/2254.html#L518'>buffer</a>            518 src/lread.c          struct buffer *b = XBUFFER (readcharfun);</span>
<span class='curline'><a href='../S/2254.html#L531'>buffer</a>            531 src/lread.c          struct buffer *b = XMARKER (readcharfun)-&gt;buffer;</span>
<span class='curline'><a href='../S/2254.html#L2434'>buffer</a>           2434 src/lread.c      struct buffer *b = 0;</span>
<span class='curline'><a href='../S/2254.html#L2462'>buffer</a>           2462 src/lread.c        b = XMARKER (readcharfun)-&gt;buffer;</span>
<span class='curline'><a href='../S/2254.html#L2570'>buffer</a>           2570 src/lread.c    		  struct buffer *buf = XBUFFER (readcharfun);</span>
<span class='curline'><a href='../S/2254.html#L2643'>buffer</a>           2643 src/lread.c      (Lisp_Object buffer, Lisp_Object printflag, Lisp_Object filename, Lisp_Object unibyte, Lisp_Object do_allow_print)</span>
<span class='curline'><a href='../S/2254.html#L2648'>buffer</a>           2648 src/lread.c      if (NILP (buffer))</span>
<span class='curline'><a href='../S/2254.html#L2651'>buffer</a>           2651 src/lread.c        buf = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/2254.html#L5663'>buffer</a>           5663 src/lread.c          char *buffer = SAFE_ALLOCA (sizeof format - 3 * (sizeof "%s" - 1)</span>
<span class='curline'><a href='../S/2254.html#L5665'>buffer</a>           5665 src/lread.c          ptrdiff_t message_len = esprintf (buffer, format, use, SSDATA (dirname),</span>
<span class='curline'><a href='../S/2254.html#L5667'>buffer</a>           5667 src/lread.c          message_dolog (buffer, message_len, 0, STRING_MULTIBYTE (dirname));</span>
<span class='curline'><a href='../S/2275.html#L33'>buffer</a>             33 src/marker.c   static struct buffer *cached_buffer;</span>
<span class='curline'><a href='../S/2275.html#L42'>buffer</a>             42 src/marker.c   extern int count_markers (struct buffer *) EXTERNALLY_VISIBLE;</span>
<span class='curline'><a href='../S/2275.html#L46'>buffer</a>             46 src/marker.c   byte_char_debug_check (struct buffer *b, ptrdiff_t charpos, ptrdiff_t bytepos)</span>
<span class='curline'><a href='../S/2275.html#L74'>buffer</a>             74 src/marker.c   clear_charpos_cache (struct buffer *b)</span>
<span class='curline'><a href='../S/2275.html#L162'>buffer</a>            162 src/marker.c   buf_charpos_to_bytepos (struct buffer *b, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/2275.html#L319'>buffer</a>            319 src/marker.c   buf_bytepos_to_charpos (struct buffer *b, ptrdiff_t bytepos)</span>
<span class='curline'><a href='../S/2275.html#L437'>buffer</a>            437 src/marker.c     if (XMARKER (marker)-&gt;buffer)</span>
<span class='curline'><a href='../S/2275.html#L439'>buffer</a>            439 src/marker.c         XSETBUFFER (buf, XMARKER (marker)-&gt;buffer);</span>
<span class='curline'><a href='../S/2275.html#L455'>buffer</a>            455 src/marker.c     if (XMARKER (marker)-&gt;buffer)</span>
<span class='curline'><a href='../S/2275.html#L464'>buffer</a>            464 src/marker.c   attach_marker (struct Lisp_Marker *m, struct buffer *b,</span>
<span class='curline'><a href='../S/2275.html#L477'>buffer</a>            477 src/marker.c     if (m-&gt;buffer != b)</span>
<span class='curline'><a href='../S/2275.html#L480'>buffer</a>            480 src/marker.c         m-&gt;buffer = b;</span>
<span class='curline'><a href='../S/2275.html#L490'>buffer</a>            490 src/marker.c   static struct buffer *</span>
<span class='curline'><a href='../S/2275.html#L491'>buffer</a>            491 src/marker.c   live_buffer (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2275.html#L493'>buffer</a>            493 src/marker.c     struct buffer *b = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/2275.html#L502'>buffer</a>            502 src/marker.c   		     Lisp_Object buffer, bool restricted)</span>
<span class='curline'><a href='../S/2275.html#L505'>buffer</a>            505 src/marker.c     struct buffer *b = live_buffer (buffer);</span>
<span class='curline'><a href='../S/2275.html#L513'>buffer</a>            513 src/marker.c         || (MARKERP (position) &amp;&amp; !XMARKER (position)-&gt;buffer)</span>
<span class='curline'><a href='../S/2275.html#L519'>buffer</a>            519 src/marker.c     else if (MARKERP (position) &amp;&amp; b == XMARKER (position)-&gt;buffer</span>
<span class='curline'><a href='../S/2275.html#L520'>buffer</a>            520 src/marker.c   	   &amp;&amp; b == m-&gt;buffer)</span>
<span class='curline'><a href='../S/2275.html#L561'>buffer</a>            561 src/marker.c   	  || !(MARKERP (position) &amp;&amp; XMARKER (position)-&gt;buffer == b))</span>
<span class='curline'><a href='../S/2275.html#L587'>buffer</a>            587 src/marker.c     if (m-&gt;buffer</span>
<span class='curline'><a href='../S/2275.html#L588'>buffer</a>            588 src/marker.c         &amp;&amp; EQ (marker, BVAR (m-&gt;buffer, mark))</span>
<span class='curline'><a href='../S/2275.html#L589'>buffer</a>            589 src/marker.c         &amp;&amp; !NILP (BVAR (m-&gt;buffer, mark_active))</span>
<span class='curline'><a href='../S/2275.html#L590'>buffer</a>            590 src/marker.c         &amp;&amp; buffer_window_count (m-&gt;buffer))</span>
<span class='curline'><a href='../S/2275.html#L591'>buffer</a>            591 src/marker.c       bset_redisplay (m-&gt;buffer);</span>
<span class='curline'><a href='../S/2275.html#L603'>buffer</a>            603 src/marker.c     (Lisp_Object marker, Lisp_Object position, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2275.html#L605'>buffer</a>            605 src/marker.c     return set_marker_internal (marker, position, buffer, false);</span>
<span class='curline'><a href='../S/2275.html#L612'>buffer</a>            612 src/marker.c   		       Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2275.html#L614'>buffer</a>            614 src/marker.c     return set_marker_internal (marker, position, buffer, true);</span>
<span class='curline'><a href='../S/2275.html#L621'>buffer</a>            621 src/marker.c   set_marker_both (Lisp_Object marker, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/2275.html#L625'>buffer</a>            625 src/marker.c     register struct buffer *b = live_buffer (buffer);</span>
<span class='curline'><a href='../S/2275.html#L640'>buffer</a>            640 src/marker.c   set_marker_restricted_both (Lisp_Object marker, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/2275.html#L644'>buffer</a>            644 src/marker.c     register struct buffer *b = live_buffer (buffer);</span>
<span class='curline'><a href='../S/2275.html#L677'>buffer</a>            677 src/marker.c     register struct buffer *b = marker-&gt;buffer;</span>
<span class='curline'><a href='../S/2275.html#L686'>buffer</a>            686 src/marker.c         marker-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2275.html#L698'>buffer</a>            698 src/marker.c   		if (tail-&gt;next &amp;&amp; b-&gt;text != tail-&gt;next-&gt;buffer-&gt;text)</span>
<span class='curline'><a href='../S/2275.html#L718'>buffer</a>            718 src/marker.c     register struct buffer *buf = m-&gt;buffer;</span>
<span class='curline'><a href='../S/2275.html#L734'>buffer</a>            734 src/marker.c     register struct buffer *buf = m-&gt;buffer;</span>
<span class='curline'><a href='../S/2275.html#L793'>buffer</a>            793 src/marker.c   count_markers (struct buffer *buf)</span>
<span class='curline'><a href='../S/2233.html#L388'>buffer</a>            388 src/minibuf.c  live_minibuffer_p (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2233.html#L393'>buffer</a>            393 src/minibuf.c    if (EQ (buffer, Fcar (Vminibuffer_list)))</span>
<span class='curline'><a href='../S/2233.html#L398'>buffer</a>            398 src/minibuf.c      if (EQ (Fcar (tem), buffer))</span>
<span class='curline'><a href='../S/2233.html#L409'>buffer</a>            409 src/minibuf.c    (Lisp_Object buffer, Lisp_Object live)</span>
<span class='curline'><a href='../S/2233.html#L411'>buffer</a>            411 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2233.html#L412'>buffer</a>            412 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2233.html#L413'>buffer</a>            413 src/minibuf.c    else if (STRINGP (buffer))</span>
<span class='curline'><a href='../S/2233.html#L414'>buffer</a>            414 src/minibuf.c      buffer = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/2233.html#L416'>buffer</a>            416 src/minibuf.c      CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2233.html#L419'>buffer</a>            419 src/minibuf.c            ? !NILP (Fmemq (buffer, Vminibuffer_list))</span>
<span class='curline'><a href='../S/2233.html#L420'>buffer</a>            420 src/minibuf.c            : live_minibuffer_p (buffer))</span>
<span class='curline'><a href='../S/2233.html#L428'>buffer</a>            428 src/minibuf.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2233.html#L430'>buffer</a>            430 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2233.html#L431'>buffer</a>            431 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2233.html#L432'>buffer</a>            432 src/minibuf.c    return BASE_EQ (buffer, (Fcar (Fnthcdr (make_fixnum (minibuf_level),</span>
<span class='curline'><a href='../S/2233.html#L442'>buffer</a>            442 src/minibuf.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2233.html#L445'>buffer</a>            445 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2233.html#L446'>buffer</a>            446 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2233.html#L447'>buffer</a>            447 src/minibuf.c    depth = this_minibuffer_depth (buffer);</span>
<span class='curline'><a href='../S/2233.html#L457'>buffer</a>            457 src/minibuf.c  this_minibuffer_depth (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2233.html#L462'>buffer</a>            462 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2233.html#L463'>buffer</a>            463 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2233.html#L467'>buffer</a>            467 src/minibuf.c      if (EQ (Fcar (bufs), buffer))</span>
<span class='curline'><a href='../S/2370.html#L1322'>buffer</a>           1322 src/msdos.c          struct buffer *b = XBUFFER (sw-&gt;contents);</span>
<span class='curline'><a href='../S/2370.html#L3899'>buffer</a>           3899 src/msdos.c    readlinkat (int fd, char const *name, char *buffer, size_t buffer_size)</span>
<span class='curline'><a href='../S/2370.html#L3916'>buffer</a>           3916 src/msdos.c      return readlink (name, buffer, buffer_size);</span>
<span class='curline'><a href='../S/2370.html#L3965'>buffer</a>           3965 src/msdos.c                  char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2370.html#L3969'>buffer</a>           3969 src/msdos.c      if (!buffer)</span>
<span class='curline'><a href='../S/2370.html#L3976'>buffer</a>           3976 src/msdos.c          buffer = NULL;</span>
<span class='curline'><a href='../S/2370.html#L3980'>buffer</a>           3980 src/msdos.c          ssize_t len = preadlinkat (fd, filename, buffer, buffer_size);</span>
<span class='curline'><a href='../S/2370.html#L3983'>buffer</a>           3983 src/msdos.c    	buffer = NULL;</span>
<span class='curline'><a href='../S/2370.html#L3985'>buffer</a>           3985 src/msdos.c    	buffer[len + 1] = '\0';</span>
<span class='curline'><a href='../S/2370.html#L3987'>buffer</a>           3987 src/msdos.c      return buffer;</span>
<span class='curline'><a href='../S/2267.html#L2123'>buffer</a>           2123 src/pdumper.c    if (marker-&gt;buffer)</span>
<span class='curline'><a href='../S/2267.html#L2125'>buffer</a>           2125 src/pdumper.c        dump_field_lv_rawptr (ctx, out, marker, &amp;marker-&gt;buffer,</span>
<span class='curline'><a href='../S/2267.html#L2748'>buffer</a>           2748 src/pdumper.c  dump_buffer (struct dump_context *ctx, const struct buffer *in_buffer)</span>
<span class='curline'><a href='../S/2267.html#L2753'>buffer</a>           2753 src/pdumper.c    struct buffer munged_buffer = *in_buffer;</span>
<span class='curline'><a href='../S/2267.html#L2754'>buffer</a>           2754 src/pdumper.c    struct buffer *buffer = &amp;munged_buffer;</span>
<span class='curline'><a href='../S/2267.html#L2757'>buffer</a>           2757 src/pdumper.c    if (buffer-&gt;base_buffer == NULL)</span>
<span class='curline'><a href='../S/2267.html#L2758'>buffer</a>           2758 src/pdumper.c      buffer-&gt;window_count = 0;</span>
<span class='curline'><a href='../S/2267.html#L2760'>buffer</a>           2760 src/pdumper.c      eassert (buffer-&gt;window_count == -1);</span>
<span class='curline'><a href='../S/2267.html#L2761'>buffer</a>           2761 src/pdumper.c    buffer-&gt;local_minor_modes_ = Qnil;</span>
<span class='curline'><a href='../S/2267.html#L2762'>buffer</a>           2762 src/pdumper.c    buffer-&gt;last_selected_window_ = Qnil;</span>
<span class='curline'><a href='../S/2267.html#L2763'>buffer</a>           2763 src/pdumper.c    buffer-&gt;display_count_ = make_fixnum (0);</span>
<span class='curline'><a href='../S/2267.html#L2764'>buffer</a>           2764 src/pdumper.c    buffer-&gt;clip_changed = 0;</span>
<span class='curline'><a href='../S/2267.html#L2765'>buffer</a>           2765 src/pdumper.c    buffer-&gt;last_window_start = -1;</span>
<span class='curline'><a href='../S/2267.html#L2766'>buffer</a>           2766 src/pdumper.c    buffer-&gt;point_before_scroll_ = Qnil;</span>
<span class='curline'><a href='../S/2267.html#L2769'>buffer</a>           2769 src/pdumper.c    if (buffer-&gt;base_buffer)</span>
<span class='curline'><a href='../S/2267.html#L2771'>buffer</a>           2771 src/pdumper.c        eassert (buffer-&gt;base_buffer-&gt;base_buffer == NULL);</span>
<span class='curline'><a href='../S/2267.html#L2774'>buffer</a>           2774 src/pdumper.c  	 make_lisp_ptr (buffer-&gt;base_buffer, Lisp_Vectorlike));</span>
<span class='curline'><a href='../S/2267.html#L2777'>buffer</a>           2777 src/pdumper.c    eassert ((base_offset == 0 &amp;&amp; buffer-&gt;text == &amp;in_buffer-&gt;own_text)</span>
<span class='curline'><a href='../S/2267.html#L2778'>buffer</a>           2778 src/pdumper.c  	   || (base_offset &gt; 0 &amp;&amp; buffer-&gt;text != &amp;in_buffer-&gt;own_text));</span>
<span class='curline'><a href='../S/2267.html#L2780'>buffer</a>           2780 src/pdumper.c    START_DUMP_PVEC (ctx, &amp;buffer-&gt;header, struct buffer, out);</span>
<span class='curline'><a href='../S/2267.html#L2781'>buffer</a>           2781 src/pdumper.c    dump_pseudovector_lisp_fields (ctx, &amp;out-&gt;header, &amp;buffer-&gt;header);</span>
<span class='curline'><a href='../S/2267.html#L2785'>buffer</a>           2785 src/pdumper.c    if (buffer-&gt;base_buffer == NULL)</span>
<span class='curline'><a href='../S/2267.html#L2789'>buffer</a>           2789 src/pdumper.c        if (BUFFER_LIVE_P (buffer))</span>
<span class='curline'><a href='../S/2267.html#L2791'>buffer</a>           2791 src/pdumper.c            dump_field_fixup_later (ctx, out, buffer, &amp;buffer-&gt;own_text.beg);</span>
<span class='curline'><a href='../S/2267.html#L2797'>buffer</a>           2797 src/pdumper.c          eassert (buffer-&gt;own_text.beg == NULL);</span>
<span class='curline'><a href='../S/2267.html#L2799'>buffer</a>           2799 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.gpt);</span>
<span class='curline'><a href='../S/2267.html#L2800'>buffer</a>           2800 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.z);</span>
<span class='curline'><a href='../S/2267.html#L2801'>buffer</a>           2801 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.gpt_byte);</span>
<span class='curline'><a href='../S/2267.html#L2802'>buffer</a>           2802 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.z_byte);</span>
<span class='curline'><a href='../S/2267.html#L2803'>buffer</a>           2803 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.gap_size);</span>
<span class='curline'><a href='../S/2267.html#L2804'>buffer</a>           2804 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.modiff);</span>
<span class='curline'><a href='../S/2267.html#L2805'>buffer</a>           2805 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.chars_modiff);</span>
<span class='curline'><a href='../S/2267.html#L2806'>buffer</a>           2806 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.save_modiff);</span>
<span class='curline'><a href='../S/2267.html#L2807'>buffer</a>           2807 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.overlay_modiff);</span>
<span class='curline'><a href='../S/2267.html#L2808'>buffer</a>           2808 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.compact);</span>
<span class='curline'><a href='../S/2267.html#L2809'>buffer</a>           2809 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.beg_unchanged);</span>
<span class='curline'><a href='../S/2267.html#L2810'>buffer</a>           2810 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.end_unchanged);</span>
<span class='curline'><a href='../S/2267.html#L2811'>buffer</a>           2811 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.unchanged_modified);</span>
<span class='curline'><a href='../S/2267.html#L2812'>buffer</a>           2812 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.overlay_unchanged_modified);</span>
<span class='curline'><a href='../S/2267.html#L2813'>buffer</a>           2813 src/pdumper.c        if (buffer-&gt;own_text.intervals)</span>
<span class='curline'><a href='../S/2267.html#L2814'>buffer</a>           2814 src/pdumper.c          dump_field_fixup_later (ctx, out, buffer, &amp;buffer-&gt;own_text.intervals);</span>
<span class='curline'><a href='../S/2267.html#L2815'>buffer</a>           2815 src/pdumper.c        dump_field_lv_rawptr (ctx, out, buffer, &amp;buffer-&gt;own_text.markers,</span>
<span class='curline'><a href='../S/2267.html#L2817'>buffer</a>           2817 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.inhibit_shrinking);</span>
<span class='curline'><a href='../S/2267.html#L2818'>buffer</a>           2818 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.redisplay);</span>
<span class='curline'><a href='../S/2267.html#L2824'>buffer</a>           2824 src/pdumper.c       ctx-&gt;obj_offset + dump_offsetof (struct buffer, text),</span>
<span class='curline'><a href='../S/2267.html#L2825'>buffer</a>           2825 src/pdumper.c       base_offset + dump_offsetof (struct buffer, own_text));</span>
<span class='curline'><a href='../S/2267.html#L2827'>buffer</a>           2827 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, pt);</span>
<span class='curline'><a href='../S/2267.html#L2828'>buffer</a>           2828 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, pt_byte);</span>
<span class='curline'><a href='../S/2267.html#L2829'>buffer</a>           2829 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, begv);</span>
<span class='curline'><a href='../S/2267.html#L2830'>buffer</a>           2830 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, begv_byte);</span>
<span class='curline'><a href='../S/2267.html#L2831'>buffer</a>           2831 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, zv);</span>
<span class='curline'><a href='../S/2267.html#L2832'>buffer</a>           2832 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, zv_byte);</span>
<span class='curline'><a href='../S/2267.html#L2834'>buffer</a>           2834 src/pdumper.c    if (buffer-&gt;base_buffer)</span>
<span class='curline'><a href='../S/2267.html#L2837'>buffer</a>           2837 src/pdumper.c        dump_field_ptr_to_dump_offset (ctx, out, buffer, &amp;buffer-&gt;base_buffer,</span>
<span class='curline'><a href='../S/2267.html#L2841'>buffer</a>           2841 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, indirections);</span>
<span class='curline'><a href='../S/2267.html#L2842'>buffer</a>           2842 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, window_count);</span>
<span class='curline'><a href='../S/2267.html#L2845'>buffer</a>           2845 src/pdumper.c            &amp;buffer-&gt;local_flags,</span>
<span class='curline'><a href='../S/2267.html#L2847'>buffer</a>           2847 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, modtime);</span>
<span class='curline'><a href='../S/2267.html#L2848'>buffer</a>           2848 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, modtime_size);</span>
<span class='curline'><a href='../S/2267.html#L2849'>buffer</a>           2849 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, auto_save_modified);</span>
<span class='curline'><a href='../S/2267.html#L2850'>buffer</a>           2850 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, display_error_modiff);</span>
<span class='curline'><a href='../S/2267.html#L2851'>buffer</a>           2851 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, auto_save_failure_time);</span>
<span class='curline'><a href='../S/2267.html#L2852'>buffer</a>           2852 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, last_window_start);</span>
<span class='curline'><a href='../S/2267.html#L2859'>buffer</a>           2859 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, prevent_redisplay_optimizations_p);</span>
<span class='curline'><a href='../S/2267.html#L2860'>buffer</a>           2860 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, clip_changed);</span>
<span class='curline'><a href='../S/2267.html#L2861'>buffer</a>           2861 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, inhibit_buffer_hooks);</span>
<span class='curline'><a href='../S/2267.html#L2862'>buffer</a>           2862 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, long_line_optimizations_p);</span>
<span class='curline'><a href='../S/2267.html#L2864'>buffer</a>           2864 src/pdumper.c    if (!itree_empty_p (buffer-&gt;overlays))</span>
<span class='curline'><a href='../S/2267.html#L2870'>buffer</a>           2870 src/pdumper.c    dump_field_lv (ctx, out, buffer, &amp;buffer-&gt;undo_list_,</span>
<span class='curline'><a href='../S/2267.html#L2873'>buffer</a>           2873 src/pdumper.c    if (!buffer-&gt;base_buffer &amp;&amp; buffer-&gt;own_text.intervals)</span>
<span class='curline'><a href='../S/2267.html#L2876'>buffer</a>           2876 src/pdumper.c         offset + dump_offsetof (struct buffer, own_text.intervals),</span>
<span class='curline'><a href='../S/2267.html#L2877'>buffer</a>           2877 src/pdumper.c         dump_interval_tree (ctx, buffer-&gt;own_text.intervals, 0));</span>
<span class='curline'><a href='../S/2267.html#L3427'>buffer</a>           3427 src/pdumper.c    struct buffer *b = XBUFFER (data);</span>
<span class='curline'><a href='../S/2267.html#L3441'>buffer</a>           3441 src/pdumper.c       buffer_offset + dump_offsetof (struct buffer, own_text.beg),</span>
<span class='curline'><a href='../S/2181.html#L3121'>buffer</a>           3121 src/pgtkfns.c    struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/2307.html#L259'>buffer</a>            259 src/pgtkmenu.c       struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2307.html#L260'>buffer</a>            260 src/pgtkmenu.c       Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2307.html#L272'>buffer</a>            272 src/pgtkmenu.c       buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/2307.html#L285'>buffer</a>            285 src/pgtkmenu.c       set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2188.html#L71'>buffer</a>             71 src/print.c      char *buffer;			/* Allocated buffer.  */</span>
<span class='curline'><a href='../S/2188.html#L103'>buffer</a>            103 src/print.c      xfree (print_buffer.buffer);</span>
<span class='curline'><a href='../S/2188.html#L104'>buffer</a>            104 src/print.c      print_buffer.buffer = NULL;</span>
<span class='curline'><a href='../S/2188.html#L112'>buffer</a>            112 src/print.c      memcpy (print_buffer.buffer, SDATA (saved_text), SCHARS (saved_text));</span>
<span class='curline'><a href='../S/2188.html#L154'>buffer</a>            154 src/print.c          if (! XMARKER (printcharfun)-&gt;buffer)</span>
<span class='curline'><a href='../S/2188.html#L156'>buffer</a>            156 src/print.c          if (XMARKER (printcharfun)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/2188.html#L157'>buffer</a>            157 src/print.c    	set_buffer_internal (XMARKER (printcharfun)-&gt;buffer);</span>
<span class='curline'><a href='../S/2188.html#L177'>buffer</a>            177 src/print.c          if (print_buffer.buffer != NULL)</span>
<span class='curline'><a href='../S/2188.html#L179'>buffer</a>            179 src/print.c    	  Lisp_Object string = make_string_from_bytes (print_buffer.buffer,</span>
<span class='curline'><a href='../S/2188.html#L187'>buffer</a>            187 src/print.c    	  print_buffer.buffer = xmalloc (new_size);</span>
<span class='curline'><a href='../S/2188.html#L210'>buffer</a>            210 src/print.c    	  copy_text ((unsigned char *) print_buffer.buffer, temp,</span>
<span class='curline'><a href='../S/2188.html#L217'>buffer</a>            217 src/print.c    	insert_1_both (print_buffer.buffer, print_buffer.pos,</span>
<span class='curline'><a href='../S/2188.html#L320'>buffer</a>            320 src/print.c    	    print_buffer.buffer = xpalloc (print_buffer.buffer,</span>
<span class='curline'><a href='../S/2188.html#L323'>buffer</a>            323 src/print.c    	  memcpy (print_buffer.buffer + print_buffer.pos_byte, str, len);</span>
<span class='curline'><a href='../S/2188.html#L386'>buffer</a>            386 src/print.c    	print_buffer.buffer = xpalloc (print_buffer.buffer,</span>
<span class='curline'><a href='../S/2188.html#L388'>buffer</a>            388 src/print.c          memcpy (print_buffer.buffer + print_buffer.pos_byte, ptr, size_byte);</span>
<span class='curline'><a href='../S/2188.html#L513'>buffer</a>            513 src/print.c    	  char *buffer = SAFE_ALLOCA (nbytes);</span>
<span class='curline'><a href='../S/2188.html#L514'>buffer</a>            514 src/print.c    	  memcpy (buffer, SDATA (string), nbytes);</span>
<span class='curline'><a href='../S/2188.html#L516'>buffer</a>            516 src/print.c    	  strout (buffer, chars, nbytes, printcharfun);</span>
<span class='curline'><a href='../S/2188.html#L587'>buffer</a>            587 src/print.c      register struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2188.html#L818'>buffer</a>            818 src/print.c      struct buffer *previous = current_buffer;</span>
<span class='curline'><a href='../S/2188.html#L1027'>buffer</a>           1027 src/print.c      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2188.html#L1713'>buffer</a>           1713 src/print.c          if (! XMARKER (obj)-&gt;buffer)</span>
<span class='curline'><a href='../S/2188.html#L1719'>buffer</a>           1719 src/print.c    	  print_string (BVAR (XMARKER (obj)-&gt;buffer, name), printcharfun);</span>
<span class='curline'><a href='../S/2188.html#L1811'>buffer</a>           1811 src/print.c    	if (NILP (XXWIDGET (obj)-&gt;buffer))</span>
<span class='curline'><a href='../S/2236.html#L349'>buffer</a>            349 src/process.c    p-&gt;buffer = val;</span>
<span class='curline'><a href='../S/2236.html#L1281'>buffer</a>           1281 src/process.c    Lisp_Object buffer = p-&gt;buffer;</span>
<span class='curline'><a href='../S/2236.html#L1282'>buffer</a>           1282 src/process.c    if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/2236.html#L1283'>buffer</a>           1283 src/process.c      set_marker_both (p-&gt;mark, buffer,</span>
<span class='curline'><a href='../S/2236.html#L1284'>buffer</a>           1284 src/process.c  		     BUF_ZV (XBUFFER (buffer)),</span>
<span class='curline'><a href='../S/2236.html#L1285'>buffer</a>           1285 src/process.c  		     BUF_ZV_BYTE (XBUFFER (buffer)));</span>
<span class='curline'><a href='../S/2236.html#L1292'>buffer</a>           1292 src/process.c    (register Lisp_Object process, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2236.html#L1297'>buffer</a>           1297 src/process.c    if (!NILP (buffer))</span>
<span class='curline'><a href='../S/2236.html#L1298'>buffer</a>           1298 src/process.c      CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2236.html#L1300'>buffer</a>           1300 src/process.c    if (!EQ (p-&gt;buffer, buffer))</span>
<span class='curline'><a href='../S/2236.html#L1302'>buffer</a>           1302 src/process.c        pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/2236.html#L1306'>buffer</a>           1306 src/process.c      pset_childp (p, plist_put (p-&gt;childp, QCbuffer, buffer));</span>
<span class='curline'><a href='../S/2236.html#L1308'>buffer</a>           1308 src/process.c    return buffer;</span>
<span class='curline'><a href='../S/2236.html#L1318'>buffer</a>           1318 src/process.c    return XPROCESS (process)-&gt;buffer;</span>
<span class='curline'><a href='../S/2236.html#L1804'>buffer</a>           1804 src/process.c    Lisp_Object buffer, name, command, program, proc, contact, current_dir, tem;</span>
<span class='curline'><a href='../S/2236.html#L1823'>buffer</a>           1823 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/2236.html#L1824'>buffer</a>           1824 src/process.c    if (!NILP (buffer))</span>
<span class='curline'><a href='../S/2236.html#L1825'>buffer</a>           1825 src/process.c      buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/2236.html#L1873'>buffer</a>           1873 src/process.c    pset_buffer (XPROCESS (proc), buffer);</span>
<span class='curline'><a href='../S/2236.html#L1942'>buffer</a>           1942 src/process.c  	args2[i++] = buffer;</span>
<span class='curline'><a href='../S/2236.html#L1972'>buffer</a>           1972 src/process.c  	    args2[i++] = buffer;</span>
<span class='curline'><a href='../S/2236.html#L1997'>buffer</a>           1997 src/process.c      = !(NILP (buffer) || !inherit_process_coding_system);</span>
<span class='curline'><a href='../S/2236.html#L2411'>buffer</a>           2411 src/process.c    Lisp_Object name, buffer;</span>
<span class='curline'><a href='../S/2236.html#L2452'>buffer</a>           2452 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/2236.html#L2453'>buffer</a>           2453 src/process.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2236.html#L2454'>buffer</a>           2454 src/process.c      buffer = name;</span>
<span class='curline'><a href='../S/2236.html#L2455'>buffer</a>           2455 src/process.c    buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/2236.html#L2456'>buffer</a>           2456 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/2236.html#L2497'>buffer</a>           2497 src/process.c      else if ((!NILP (buffer) &amp;&amp; NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/2236.html#L2498'>buffer</a>           2498 src/process.c  	     || (NILP (buffer) &amp;&amp; NILP (BVAR (&amp;buffer_defaults, enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/2236.html#L3149'>buffer</a>           3149 src/process.c    Lisp_Object name, buffer;</span>
<span class='curline'><a href='../S/2236.html#L3187'>buffer</a>           3187 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/2236.html#L3188'>buffer</a>           3188 src/process.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2236.html#L3189'>buffer</a>           3189 src/process.c      buffer = name;</span>
<span class='curline'><a href='../S/2236.html#L3190'>buffer</a>           3190 src/process.c    buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/2236.html#L3191'>buffer</a>           3191 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/2236.html#L3222'>buffer</a>           3222 src/process.c    else if ((!NILP (buffer) &amp;&amp; NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/2236.html#L3223'>buffer</a>           3223 src/process.c  	   || (NILP (buffer) &amp;&amp; NILP (BVAR (&amp;buffer_defaults, enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/2236.html#L3236'>buffer</a>           3236 src/process.c    else if ((!NILP (buffer) &amp;&amp; NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/2236.html#L3237'>buffer</a>           3237 src/process.c  	   || (NILP (buffer) &amp;&amp; NILP (BVAR (&amp;buffer_defaults, enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/2236.html#L3246'>buffer</a>           3246 src/process.c      = !(!NILP (tem) || NILP (buffer) || !inherit_process_coding_system);</span>
<span class='curline'><a href='../S/2236.html#L3278'>buffer</a>           3278 src/process.c    else if ((!NILP (p-&gt;buffer)</span>
<span class='curline'><a href='../S/2236.html#L3279'>buffer</a>           3279 src/process.c  	    &amp;&amp; NILP (BVAR (XBUFFER (p-&gt;buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/2236.html#L3280'>buffer</a>           3280 src/process.c  	   || (NILP (p-&gt;buffer)</span>
<span class='curline'><a href='../S/2236.html#L3293'>buffer</a>           3293 src/process.c  				Qopen_network_stream, name, p-&gt;buffer,</span>
<span class='curline'><a href='../S/2236.html#L3322'>buffer</a>           3322 src/process.c  				    Qopen_network_stream, name, p-&gt;buffer,</span>
<span class='curline'><a href='../S/2236.html#L3339'>buffer</a>           3339 src/process.c      = !(!NILP (tem) || NILP (p-&gt;buffer) || !inherit_process_coding_system);</span>
<span class='curline'><a href='../S/2236.html#L3941'>buffer</a>           3941 src/process.c    Lisp_Object name, buffer, host, service, address;</span>
<span class='curline'><a href='../S/2236.html#L3979'>buffer</a>           3979 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/2236.html#L4218'>buffer</a>           4218 src/process.c    if (!NILP (buffer))</span>
<span class='curline'><a href='../S/2236.html#L4219'>buffer</a>           4219 src/process.c      buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/2236.html#L4231'>buffer</a>           4231 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/2236.html#L4912'>buffer</a>           4912 src/process.c    Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2236.html#L5004'>buffer</a>           5004 src/process.c      buffer = Qnil;</span>
<span class='curline'><a href='../S/2236.html#L5007'>buffer</a>           5007 src/process.c        buffer = ps-&gt;buffer;</span>
<span class='curline'><a href='../S/2236.html#L5008'>buffer</a>           5008 src/process.c        if (!NILP (buffer))</span>
<span class='curline'><a href='../S/2236.html#L5009'>buffer</a>           5009 src/process.c  	buffer = Fbuffer_name (buffer);</span>
<span class='curline'><a href='../S/2236.html#L5011'>buffer</a>           5011 src/process.c  	buffer = ps-&gt;name;</span>
<span class='curline'><a href='../S/2236.html#L5012'>buffer</a>           5012 src/process.c        if (!NILP (buffer))</span>
<span class='curline'><a href='../S/2236.html#L5014'>buffer</a>           5014 src/process.c  	  args[1] = buffer;</span>
<span class='curline'><a href='../S/2236.html#L5015'>buffer</a>           5015 src/process.c  	  buffer = Fget_buffer_create (Fformat (nargs, args), Qnil);</span>
<span class='curline'><a href='../S/2236.html#L5052'>buffer</a>           5052 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/2236.html#L5086'>buffer</a>           5086 src/process.c      = (NILP (buffer) ? 0 : ps-&gt;inherit_coding_system_flag);</span>
<span class='curline'><a href='../S/2236.html#L6339'>buffer</a>           6339 src/process.c    if (!NILP (p-&gt;buffer) &amp;&amp; BUFFER_LIVE_P (XBUFFER (p-&gt;buffer)))</span>
<span class='curline'><a href='../S/2236.html#L6345'>buffer</a>           6345 src/process.c        struct buffer *b;</span>
<span class='curline'><a href='../S/2236.html#L6347'>buffer</a>           6347 src/process.c        Fset_buffer (p-&gt;buffer);</span>
<span class='curline'><a href='../S/2236.html#L6358'>buffer</a>           6358 src/process.c        if (XMARKER (p-&gt;mark)-&gt;buffer)</span>
<span class='curline'><a href='../S/2236.html#L6384'>buffer</a>           6384 src/process.c        if (BUFFERP (p-&gt;buffer)</span>
<span class='curline'><a href='../S/2236.html#L6385'>buffer</a>           6385 src/process.c  	  &amp;&amp; (b = XBUFFER (p-&gt;buffer), b != current_buffer))</span>
<span class='curline'><a href='../S/2236.html#L6386'>buffer</a>           6386 src/process.c  	set_marker_both (p-&gt;mark, p-&gt;buffer, BUF_PT (b), BUF_PT_BYTE (b));</span>
<span class='curline'><a href='../S/2236.html#L6388'>buffer</a>           6388 src/process.c  	set_marker_both (p-&gt;mark, p-&gt;buffer, PT, PT_BYTE);</span>
<span class='curline'><a href='../S/2236.html#L6575'>buffer</a>           6575 src/process.c  	  struct buffer *cur = current_buffer;</span>
<span class='curline'><a href='../S/2236.html#L7684'>buffer</a>           7684 src/process.c  	  if (BUFFERP (p-&gt;buffer))</span>
<span class='curline'><a href='../S/2236.html#L7686'>buffer</a>           7686 src/process.c  	    bset_update_mode_line (XBUFFER (p-&gt;buffer));</span>
<span class='curline'><a href='../S/2236.html#L7699'>buffer</a>           7699 src/process.c    Lisp_Object buffer, symbol;</span>
<span class='curline'><a href='../S/2236.html#L7703'>buffer</a>           7703 src/process.c    buffer = p-&gt;buffer;</span>
<span class='curline'><a href='../S/2236.html#L7708'>buffer</a>           7708 src/process.c    if (!EQ (symbol, Qrun) &amp;&amp; !NILP (buffer))</span>
<span class='curline'><a href='../S/2236.html#L7711'>buffer</a>           7711 src/process.c        struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2236.html#L7717'>buffer</a>           7717 src/process.c        if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/2236.html#L7719'>buffer</a>           7719 src/process.c        Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2236.html#L7730'>buffer</a>           7730 src/process.c        if (XMARKER (p-&gt;mark)-&gt;buffer)</span>
<span class='curline'><a href='../S/2236.html#L7746'>buffer</a>           7746 src/process.c        set_marker_both (p-&gt;mark, p-&gt;buffer, PT, PT_BYTE);</span>
<span class='curline'><a href='../S/2236.html#L8142'>buffer</a>           8142 src/process.c        &amp;&amp; BUFFERP (p-&gt;buffer))</span>
<span class='curline'><a href='../S/2236.html#L8144'>buffer</a>           8144 src/process.c        if (NILP (BVAR (XBUFFER (p-&gt;buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/2236.html#L8162'>buffer</a>           8162 src/process.c    (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2236.html#L8167'>buffer</a>           8167 src/process.c    if (NILP (buffer)) return Qnil;</span>
<span class='curline'><a href='../S/2236.html#L8168'>buffer</a>           8168 src/process.c    buf = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/2236.html#L8172'>buffer</a>           8172 src/process.c      if (EQ (XPROCESS (proc)-&gt;buffer, buf))</span>
<span class='curline'><a href='../S/2236.html#L8201'>buffer</a>           8201 src/process.c  kill_buffer_processes (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2236.html#L8207'>buffer</a>           8207 src/process.c      if (NILP (buffer) || EQ (XPROCESS (proc)-&gt;buffer, buffer))</span>
<span class='curline'><a href='../S/2324.html#L68'>buffer</a>             68 src/process.h      Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2244.html#L740'>buffer</a>            740 src/regex-emacs.c   re_char *buffer = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2244.html#L742'>buffer</a>            742 src/regex-emacs.c   print_partial_compiled_pattern (buffer, buffer + bufp-&gt;used);</span>
<span class='curline'><a href='../S/2244.html#L1038'>buffer</a>           1038 src/regex-emacs.c       eassert (FAILURE_PAT (failure) &gt;= bufp-&gt;buffer			\</span>
<span class='curline'><a href='../S/2244.html#L1039'>buffer</a>           1039 src/regex-emacs.c 	       &amp;&amp; FAILURE_PAT (failure) &lt;= bufp-&gt;buffer + bufp-&gt;used);	\</span>
<span class='curline'><a href='../S/2244.html#L1186'>buffer</a>           1186 src/regex-emacs.c     if (bufp-&gt;buffer + bufp-&gt;allocated - b &lt; (n))			\</span>
<span class='curline'><a href='../S/2244.html#L1187'>buffer</a>           1187 src/regex-emacs.c       EXTEND_BUFFER ((n) - (bufp-&gt;buffer + bufp-&gt;allocated - b))</span>
<span class='curline'><a href='../S/2244.html#L1236'>buffer</a>           1236 src/regex-emacs.c     unsigned char *old_buffer = bufp-&gt;buffer;				\</span>
<span class='curline'><a href='../S/2244.html#L1246'>buffer</a>           1246 src/regex-emacs.c     bufp-&gt;buffer = xpalloc (bufp-&gt;buffer, &amp;bufp-&gt;allocated,		\</span>
<span class='curline'><a href='../S/2244.html#L1248'>buffer</a>           1248 src/regex-emacs.c     unsigned char *new_buffer = bufp-&gt;buffer;				\</span>
<span class='curline'><a href='../S/2244.html#L1786'>buffer</a>           1786 src/regex-emacs.c       bufp-&gt;buffer = xrealloc (bufp-&gt;buffer, INIT_BUF_SIZE);</span>
<span class='curline'><a href='../S/2244.html#L1790'>buffer</a>           1790 src/regex-emacs.c   begalt = b = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2244.html#L2251'>buffer</a>           2251 src/regex-emacs.c 		COMPILE_STACK_TOP.begalt_offset = begalt - bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2244.html#L2253'>buffer</a>           2253 src/regex-emacs.c 		  = fixup_alt_jump ? fixup_alt_jump - bufp-&gt;buffer + 1 : 0;</span>
<span class='curline'><a href='../S/2244.html#L2254'>buffer</a>           2254 src/regex-emacs.c 		COMPILE_STACK_TOP.laststart_offset = b - bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2244.html#L2294'>buffer</a>           2294 src/regex-emacs.c 		begalt = bufp-&gt;buffer + COMPILE_STACK_TOP.begalt_offset;</span>
<span class='curline'><a href='../S/2244.html#L2297'>buffer</a>           2297 src/regex-emacs.c 		    ? bufp-&gt;buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1</span>
<span class='curline'><a href='../S/2244.html#L2299'>buffer</a>           2299 src/regex-emacs.c 		laststart = bufp-&gt;buffer + COMPILE_STACK_TOP.laststart_offset;</span>
<span class='curline'><a href='../S/2244.html#L2666'>buffer</a>           2666 src/regex-emacs.c   bufp-&gt;used = b - bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2244.html#L3127'>buffer</a>           3127 src/regex-emacs.c   eassert (fastmap &amp;&amp; bufp-&gt;buffer);</span>
<span class='curline'><a href='../S/2244.html#L3134'>buffer</a>           3134 src/regex-emacs.c   analysis = analyze_first (bufp-&gt;buffer, bufp-&gt;buffer + bufp-&gt;used,</span>
<span class='curline'><a href='../S/2244.html#L3240'>buffer</a>           3240 src/regex-emacs.c   if (bufp-&gt;used &gt; 0 &amp;&amp; (re_opcode_t) bufp-&gt;buffer[0] == begbuf &amp;&amp; range &gt; 0)</span>
<span class='curline'><a href='../S/2244.html#L3250'>buffer</a>           3250 src/regex-emacs.c   if (bufp-&gt;used &gt; 0 &amp;&amp; (re_opcode_t) bufp-&gt;buffer[0] == at_dot &amp;&amp; range &gt; 0)</span>
<span class='curline'><a href='../S/2244.html#L3262'>buffer</a>           3262 src/regex-emacs.c   anchored_start = (bufp-&gt;buffer[0] == begline);</span>
<span class='curline'><a href='../S/2244.html#L3653'>buffer</a>           3653 src/regex-emacs.c   unsigned char *pend = bufp-&gt;buffer + bufp-&gt;used;</span>
<span class='curline'><a href='../S/2244.html#L3656'>buffer</a>           3656 src/regex-emacs.c   eassert (p1 &gt;= bufp-&gt;buffer &amp;&amp; p1 &lt; pend</span>
<span class='curline'><a href='../S/2244.html#L3657'>buffer</a>           3657 src/regex-emacs.c 	   &amp;&amp; p2 &gt;= bufp-&gt;buffer &amp;&amp; p2 &lt;= pend);</span>
<span class='curline'><a href='../S/2244.html#L3668'>buffer</a>           3668 src/regex-emacs.c   eassert (p1 &gt;= bufp-&gt;buffer &amp;&amp; p1 &lt; pend</span>
<span class='curline'><a href='../S/2244.html#L3669'>buffer</a>           3669 src/regex-emacs.c 	   &amp;&amp; p2 &gt;= bufp-&gt;buffer &amp;&amp; p2 &lt;= pend);</span>
<span class='curline'><a href='../S/2244.html#L3883'>buffer</a>           3883 src/regex-emacs.c   struct buffer *b = (struct buffer *) ptr;</span>
<span class='curline'><a href='../S/2244.html#L3919'>buffer</a>           3919 src/regex-emacs.c   re_char *p = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2244.html#L5092'>buffer</a>           5092 src/regex-emacs.c 	  eassert (p &gt;= bufp-&gt;buffer &amp;&amp; p &lt;= pend);</span>
<span class='curline'><a href='../S/2171.html#L69'>buffer</a>             69 src/regex-emacs.h   unsigned char *buffer;</span>
<span class='curline'><a href='../S/2171.html#L131'>buffer</a>            131 src/regex-emacs.h 				       struct re_pattern_buffer *buffer);</span>
<span class='curline'><a href='../S/2171.html#L139'>buffer</a>            139 src/regex-emacs.h extern ptrdiff_t re_search (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/2171.html#L147'>buffer</a>            147 src/regex-emacs.h extern ptrdiff_t re_search_2 (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/2171.html#L157'>buffer</a>            157 src/regex-emacs.h extern ptrdiff_t re_match_2 (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/2171.html#L176'>buffer</a>            176 src/regex-emacs.h extern void re_set_registers (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/2255.html#L125'>buffer</a>            125 src/region-cache.c static void revalidate_region_cache (struct buffer *buf, struct region_cache *c);</span>
<span class='curline'><a href='../S/2255.html#L458'>buffer</a>            458 src/region-cache.c invalidate_region_cache (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/2255.html#L537'>buffer</a>            537 src/region-cache.c revalidate_region_cache (struct buffer *buf, struct region_cache *c)</span>
<span class='curline'><a href='../S/2255.html#L665'>buffer</a>            665 src/region-cache.c know_region_cache (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/2255.html#L681'>buffer</a>            681 src/region-cache.c region_cache_forward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/2255.html#L719'>buffer</a>            719 src/region-cache.c region_cache_backward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/2094.html#L65'>buffer</a>             65 src/region-cache.h struct buffer;</span>
<span class='curline'><a href='../S/2094.html#L76'>buffer</a>             76 src/region-cache.h extern void know_region_cache (struct buffer *BUF,</span>
<span class='curline'><a href='../S/2094.html#L88'>buffer</a>             88 src/region-cache.h extern void invalidate_region_cache (struct buffer *BUF,</span>
<span class='curline'><a href='../S/2094.html#L105'>buffer</a>            105 src/region-cache.h extern int region_cache_forward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/2094.html#L109'>buffer</a>            109 src/region-cache.h extern int region_cache_backward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/2346.html#L147'>buffer</a>            147 src/search.c           cp-&gt;buf.buffer = xrealloc (cp-&gt;buf.buffer, cp-&gt;buf.used);</span>
<span class='curline'><a href='../S/2346.html#L598'>buffer</a>            598 src/search.c   newline_cache_on_off (struct buffer *buf)</span>
<span class='curline'><a href='../S/2346.html#L600'>buffer</a>            600 src/search.c     struct buffer *base_buf = buf;</span>
<span class='curline'><a href='../S/2346.html#L676'>buffer</a>            676 src/search.c     struct buffer *cache_buffer;</span>
<span class='curline'><a href='../S/2346.html#L3026'>buffer</a>           3026 src/search.c   		if (XMARKER (marker)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/2346.html#L3029'>buffer</a>           3029 src/search.c   		  XSETBUFFER (last_thing_searched, XMARKER (marker)-&gt;buffer);</span>
<span class='curline'><a href='../S/2346.html#L3046'>buffer</a>           3046 src/search.c   	    if (MARKERP (marker) &amp;&amp; XMARKER (marker)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/2346.html#L3303'>buffer</a>           3303 src/search.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2346.html#L3305'>buffer</a>           3305 src/search.c     struct buffer *buf, *old = NULL;</span>
<span class='curline'><a href='../S/2346.html#L3310'>buffer</a>           3310 src/search.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2346.html#L3314'>buffer</a>           3314 src/search.c         CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2346.html#L3315'>buffer</a>           3315 src/search.c         buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2346.html#L3465'>buffer</a>           3465 src/search.c         searchbufs[i].buf.buffer = xmalloc (100);</span>
<span class='curline'><a href='../S/2129.html#L805'>buffer</a>            805 src/sfnt.c       char buffer[3 + 4 + 4];</span>
<span class='curline'><a href='../S/2129.html#L845'>buffer</a>            845 src/sfnt.c           if (read (fd, buffer, sizeof buffer) &lt; sizeof buffer)</span>
<span class='curline'><a href='../S/2129.html#L853'>buffer</a>            853 src/sfnt.c     	= sfnt_read_24 ((unsigned char *) buffer);</span>
<span class='curline'><a href='../S/2129.html#L857'>buffer</a>            857 src/sfnt.c     	      buffer + 3,</span>
<span class='curline'><a href='../S/2129.html#L860'>buffer</a>            860 src/sfnt.c     	      buffer + 7,</span>
<span class='curline'><a href='../S/2129.html#L12649'>buffer</a>           12649 src/sfnt.c       char *buffer;</span>
<span class='curline'><a href='../S/2129.html#L12674'>buffer</a>           12674 src/sfnt.c       buffer = NULL;</span>
<span class='curline'><a href='../S/2129.html#L12804'>buffer</a>           12804 src/sfnt.c         buffer = alloca (fvar-&gt;instance_size);</span>
<span class='curline'><a href='../S/2129.html#L12806'>buffer</a>           12806 src/sfnt.c         buffer = xmalloc (fvar-&gt;instance_size);</span>
<span class='curline'><a href='../S/2129.html#L12812'>buffer</a>           12812 src/sfnt.c           rc = read (fd, buffer, fvar-&gt;instance_size);</span>
<span class='curline'><a href='../S/2129.html#L12818'>buffer</a>           12818 src/sfnt.c           fvar-&gt;instance[i].name_id = *((uint16_t *) buffer);</span>
<span class='curline'><a href='../S/2129.html#L12819'>buffer</a>           12819 src/sfnt.c           fvar-&gt;instance[i].flags = *((uint16_t *) buffer + 1);</span>
<span class='curline'><a href='../S/2129.html#L12830'>buffer</a>           12830 src/sfnt.c           memcpy (fvar-&gt;instance[i].coords, buffer + 4,</span>
<span class='curline'><a href='../S/2129.html#L12844'>buffer</a>           12844 src/sfnt.c     	    = *(uint16_t *) (buffer + 4 + (sizeof *fvar-&gt;instance[i].coords</span>
<span class='curline'><a href='../S/2129.html#L12851'>buffer</a>           12851 src/sfnt.c       if (buffer &amp;&amp; fvar-&gt;instance_size &gt;= 1024 * 16)</span>
<span class='curline'><a href='../S/2129.html#L12852'>buffer</a>           12852 src/sfnt.c         xfree (buffer);</span>
<span class='curline'><a href='../S/2129.html#L12858'>buffer</a>           12858 src/sfnt.c       if (buffer &amp;&amp; fvar-&gt;instance_size &gt;= 1024 * 16)</span>
<span class='curline'><a href='../S/2129.html#L12859'>buffer</a>           12859 src/sfnt.c         xfree (buffer);</span>
<span class='curline'><a href='../S/2129.html#L13042'>buffer</a>           13042 src/sfnt.c       uint16_t *buffer;</span>
<span class='curline'><a href='../S/2129.html#L13082'>buffer</a>           13082 src/sfnt.c       buffer = xmalloc (size);</span>
<span class='curline'><a href='../S/2129.html#L13083'>buffer</a>           13083 src/sfnt.c       rc = read (fd, buffer, size);</span>
<span class='curline'><a href='../S/2129.html#L13088'>buffer</a>           13088 src/sfnt.c       for (i = 0; i &lt; size / sizeof *buffer; ++i)</span>
<span class='curline'><a href='../S/2129.html#L13089'>buffer</a>           13089 src/sfnt.c         sfnt_swap16 (&amp;buffer[i]);</span>
<span class='curline'><a href='../S/2129.html#L13099'>buffer</a>           13099 src/sfnt.c           if (k &gt;= size / sizeof *buffer)</span>
<span class='curline'><a href='../S/2129.html#L13107'>buffer</a>           13107 src/sfnt.c     			    * buffer[k], min_size, &amp;min_size))</span>
<span class='curline'><a href='../S/2129.html#L13112'>buffer</a>           13112 src/sfnt.c           j = k + 1 + buffer[k] * 2;</span>
<span class='curline'><a href='../S/2129.html#L13113'>buffer</a>           13113 src/sfnt.c           if (j &gt; size / sizeof *buffer)</span>
<span class='curline'><a href='../S/2129.html#L13131'>buffer</a>           13131 src/sfnt.c           avar-&gt;segments[i].pair_count = buffer[k++];</span>
<span class='curline'><a href='../S/2129.html#L13136'>buffer</a>           13136 src/sfnt.c     	  correspondences-&gt;from_coord = buffer[k++];</span>
<span class='curline'><a href='../S/2129.html#L13137'>buffer</a>           13137 src/sfnt.c     	  correspondences-&gt;to_coord = buffer[k++];</span>
<span class='curline'><a href='../S/2129.html#L13143'>buffer</a>           13143 src/sfnt.c       xfree (buffer);</span>
<span class='curline'><a href='../S/2129.html#L13147'>buffer</a>           13147 src/sfnt.c       xfree (buffer);</span>
<span class='curline'><a href='../S/2129.html#L13346'>buffer</a>           13346 src/sfnt.c       unsigned char *buffer, *data, *end, *tuple;</span>
<span class='curline'><a href='../S/2129.html#L13383'>buffer</a>           13383 src/sfnt.c       buffer = xmalloc (size);</span>
<span class='curline'><a href='../S/2129.html#L13384'>buffer</a>           13384 src/sfnt.c       rc = read (fd, buffer, size);</span>
<span class='curline'><a href='../S/2129.html#L13393'>buffer</a>           13393 src/sfnt.c       end = buffer + size;</span>
<span class='curline'><a href='../S/2129.html#L13400'>buffer</a>           13400 src/sfnt.c       data = buffer + data_offset;</span>
<span class='curline'><a href='../S/2129.html#L13401'>buffer</a>           13401 src/sfnt.c       tuple = buffer;</span>
<span class='curline'><a href='../S/2129.html#L13430'>buffer</a>           13430 src/sfnt.c           data = buffer + data_offset;</span>
<span class='curline'><a href='../S/2129.html#L13490'>buffer</a>           13490 src/sfnt.c       tuple = buffer;</span>
<span class='curline'><a href='../S/2129.html#L13498'>buffer</a>           13498 src/sfnt.c           data = buffer + data_offset;</span>
<span class='curline'><a href='../S/2129.html#L13648'>buffer</a>           13648 src/sfnt.c       xfree (buffer);</span>
<span class='curline'><a href='../S/2129.html#L13655'>buffer</a>           13655 src/sfnt.c       xfree (buffer);</span>
<span class='curline'><a href='../S/2129.html#L18598'>buffer</a>           18598 src/sfnt.c       char buffer[80];</span>
<span class='curline'><a href='../S/2129.html#L18602'>buffer</a>           18602 src/sfnt.c       sprintf (buffer, "opcode:IP:depth: 0x%x:%d:%d",</span>
<span class='curline'><a href='../S/2129.html#L18612'>buffer</a>           18612 src/sfnt.c       XDrawString (display, window, point_gc, 0, 13, buffer,</span>
<span class='curline'><a href='../S/2129.html#L18613'>buffer</a>           18613 src/sfnt.c     	       strlen (buffer));</span>
<span class='curline'><a href='../S/2129.html#L18617'>buffer</a>           18617 src/sfnt.c       sprintf (buffer, "opcode: %s",</span>
<span class='curline'><a href='../S/2129.html#L18620'>buffer</a>           18620 src/sfnt.c       XDrawString (display, window, point_gc, 14, 27, buffer,</span>
<span class='curline'><a href='../S/2129.html#L18621'>buffer</a>           18621 src/sfnt.c     	       strlen (buffer));</span>
<span class='curline'><a href='../S/2129.html#L18632'>buffer</a>           18632 src/sfnt.c       sprintf (buffer, "projection function: %s", name);</span>
<span class='curline'><a href='../S/2129.html#L18634'>buffer</a>           18634 src/sfnt.c       XDrawString (display, window, point_gc, 28, 42, buffer,</span>
<span class='curline'><a href='../S/2129.html#L18635'>buffer</a>           18635 src/sfnt.c     	       strlen (buffer));</span>
<span class='curline'><a href='../S/2129.html#L18697'>buffer</a>           18697 src/sfnt.c       static char buffer[256];</span>
<span class='curline'><a href='../S/2129.html#L18707'>buffer</a>           18707 src/sfnt.c           sprintf (buffer, "prep+%td",</span>
<span class='curline'><a href='../S/2129.html#L18709'>buffer</a>           18709 src/sfnt.c           return buffer;</span>
<span class='curline'><a href='../S/2129.html#L18717'>buffer</a>           18717 src/sfnt.c           sprintf (buffer, "fpgm+%td",</span>
<span class='curline'><a href='../S/2129.html#L18719'>buffer</a>           18719 src/sfnt.c           return buffer;</span>
<span class='curline'><a href='../S/2129.html#L18722'>buffer</a>           18722 src/sfnt.c       sprintf (buffer, "IP+%td", where - interpreter-&gt;instructions);</span>
<span class='curline'><a href='../S/2129.html#L18723'>buffer</a>           18723 src/sfnt.c       return buffer;</span>
<span class='curline'><a href='../S/2304.html#L77'>buffer</a>             77 src/sfntfont-android.c #define GET_SCANLINE_BUFFER(buffer, height, stride)		\</span>
<span class='curline'><a href='../S/2304.html#L86'>buffer</a>             86 src/sfntfont-android.c 	(buffer) = alloca (_size);				\</span>
<span class='curline'><a href='../S/2304.html#L91'>buffer</a>             91 src/sfntfont-android.c 	      (buffer)						\</span>
<span class='curline'><a href='../S/2304.html#L98'>buffer</a>             98 src/sfntfont-android.c 	    (buffer) = scanline_buffer.buffer_data;		\</span>
<span class='curline'><a href='../S/2304.html#L110'>buffer</a>            110 src/sfntfont-android.c #define GET_SCANLINE_BUFFER(buffer, height, stride)		\</span>
<span class='curline'><a href='../S/2304.html#L124'>buffer</a>            124 src/sfntfont-android.c 	  (buffer)						\</span>
<span class='curline'><a href='../S/2304.html#L130'>buffer</a>            130 src/sfntfont-android.c 	(buffer) = scanline_buffer.buffer_data;			\</span>
<span class='curline'><a href='../S/2304.html#L317'>buffer</a>            317 src/sfntfont-android.c sfntfont_android_composite_bitmap (unsigned char *restrict buffer,</span>
<span class='curline'><a href='../S/2304.html#L349'>buffer</a>            349 src/sfntfont-android.c 	  src_row = (unsigned int *) ((buffer + src_y * stride));</span>
<span class='curline'><a href='../S/2304.html#L411'>buffer</a>            411 src/sfntfont-android.c   unsigned int *buffer, *row;</span>
<span class='curline'><a href='../S/2304.html#L492'>buffer</a>            492 src/sfntfont-android.c   stride = ((text_rectangle.width * sizeof *buffer) + 7) &amp; ~7;</span>
<span class='curline'><a href='../S/2304.html#L494'>buffer</a>            494 src/sfntfont-android.c   stride = ((text_rectangle.width * sizeof *buffer) + 15) &amp; ~15;</span>
<span class='curline'><a href='../S/2304.html#L496'>buffer</a>            496 src/sfntfont-android.c   GET_SCANLINE_BUFFER (buffer, text_rectangle.height, stride);</span>
<span class='curline'><a href='../S/2304.html#L503'>buffer</a>            503 src/sfntfont-android.c     memset (buffer, 0, text_rectangle.height * stride);</span>
<span class='curline'><a href='../S/2304.html#L519'>buffer</a>            519 src/sfntfont-android.c 	  row = (unsigned int *) ((unsigned char *) buffer</span>
<span class='curline'><a href='../S/2304.html#L548'>buffer</a>            548 src/sfntfont-android.c 	  row = (unsigned int *) ((unsigned char *) buffer</span>
<span class='curline'><a href='../S/2304.html#L585'>buffer</a>            585 src/sfntfont-android.c 	  sfntfont_android_composite_bitmap ((unsigned char *) buffer,</span>
<span class='curline'><a href='../S/2304.html#L592'>buffer</a>            592 src/sfntfont-android.c     sfntfont_android_composite_bitmap ((unsigned char *) buffer,</span>
<span class='curline'><a href='../S/2312.html#L223'>buffer</a>            223 src/sound.c      void (* write) (struct sound_device *sd, const char *buffer,</span>
<span class='curline'><a href='../S/2312.html#L571'>buffer</a>            571 src/sound.c          char *buffer = SAFE_ALLOCA (blksize);</span>
<span class='curline'><a href='../S/2312.html#L574'>buffer</a>            574 src/sound.c                 &amp;&amp; (nbytes = emacs_read (s-&gt;fd, buffer, blksize)) &gt; 0)</span>
<span class='curline'><a href='../S/2312.html#L579'>buffer</a>            579 src/sound.c              sd-&gt;write (sd, buffer, nbytes);</span>
<span class='curline'><a href='../S/2312.html#L666'>buffer</a>            666 src/sound.c          char *buffer = SAFE_ALLOCA (blksize);</span>
<span class='curline'><a href='../S/2312.html#L667'>buffer</a>            667 src/sound.c          while ((nbytes = emacs_read (s-&gt;fd, buffer, blksize)) &gt; 0)</span>
<span class='curline'><a href='../S/2312.html#L668'>buffer</a>            668 src/sound.c    	sd-&gt;write (sd, buffer, nbytes);</span>
<span class='curline'><a href='../S/2312.html#L868'>buffer</a>            868 src/sound.c    vox_write (struct sound_device *sd, const char *buffer, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/2312.html#L870'>buffer</a>            870 src/sound.c      if (emacs_write_sig (sd-&gt;fd, buffer, nbytes) != nbytes)</span>
<span class='curline'><a href='../S/2312.html#L1126'>buffer</a>           1126 src/sound.c    alsa_write (struct sound_device *sd, const char *buffer, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/2312.html#L1140'>buffer</a>           1140 src/sound.c          err = snd_pcm_writei (p-&gt;handle, buffer + nwritten, frames);</span>
<span class='curline'><a href='../S/2315.html#L176'>buffer</a>            176 src/syntax.c   static struct buffer *find_start_buffer;</span>
<span class='curline'><a href='../S/2315.html#L193'>buffer</a>            193 src/syntax.c   bset_syntax_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2315.html#L278'>buffer</a>            278 src/syntax.c         struct buffer *buf = XBUFFER (gl_state.object);</span>
<span class='curline'><a href='../S/2287.html#L2355'>buffer</a>           2355 src/sysdep.c     void *buffer;</span>
<span class='curline'><a href='../S/2287.html#L2360'>buffer</a>           2360 src/sysdep.c         buffer = thread_backtrace_buffer;</span>
<span class='curline'><a href='../S/2287.html#L2365'>buffer</a>           2365 src/sysdep.c         buffer = main_backtrace_buffer;</span>
<span class='curline'><a href='../S/2287.html#L2370'>buffer</a>           2370 src/sysdep.c   	  backtrace (buffer, 1);</span>
<span class='curline'><a href='../S/2287.html#L2374'>buffer</a>           2374 src/sysdep.c         npointers = backtrace (buffer, bounded_limit + 1);</span>
<span class='curline'><a href='../S/2287.html#L2380'>buffer</a>           2380 src/sysdep.c         backtrace_symbols_fd (buffer, npointers, STDERR_FILENO);</span>
<span class='curline'><a href='../S/2215.html#L3516'>buffer</a>           3516 src/term.c       struct buffer *buffer;</span>
<span class='curline'><a href='../S/2215.html#L3526'>buffer</a>           3526 src/term.c       set_buffer_internal (data-&gt;buffer);</span>
<span class='curline'><a href='../S/2098.html#L88'>buffer</a>             88 src/textconv.c 	     char *buffer)</span>
<span class='curline'><a href='../S/2098.html#L110'>buffer</a>            110 src/textconv.c   memcpy (buffer, BYTE_POS_ADDR (beg0), size);</span>
<span class='curline'><a href='../S/2098.html#L112'>buffer</a>            112 src/textconv.c     memcpy (buffer + size, BEG_ADDR + beg1, end1 - beg1);</span>
<span class='curline'><a href='../S/2098.html#L126'>buffer</a>            126 src/textconv.c       &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer)</span>
<span class='curline'><a href='../S/2098.html#L179'>buffer</a>            179 src/textconv.c   char *buffer;</span>
<span class='curline'><a href='../S/2098.html#L394'>buffer</a>            394 src/textconv.c   buffer = xmalloc (end_byte - pos_byte);</span>
<span class='curline'><a href='../S/2098.html#L395'>buffer</a>            395 src/textconv.c   copy_buffer (pos, pos_byte, end, end_byte, buffer);</span>
<span class='curline'><a href='../S/2098.html#L396'>buffer</a>            396 src/textconv.c   query-&gt;text.text = buffer;</span>
<span class='curline'><a href='../S/2098.html#L461'>buffer</a>            461 src/textconv.c   Lisp_Object buffer, beg_marker, end_marker;</span>
<span class='curline'><a href='../S/2098.html#L463'>buffer</a>            463 src/textconv.c   XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/2098.html#L485'>buffer</a>            485 src/textconv.c     = Fcons (list4 (buffer, beg_marker, end_marker,</span>
<span class='curline'><a href='../S/2098.html#L1222'>buffer</a>           1222 src/textconv.c   struct buffer *buffer UNINIT;</span>
<span class='curline'><a href='../S/2098.html#L1254'>buffer</a>           1254 src/textconv.c       buffer = XBUFFER (WINDOW_BUFFER (w));</span>
<span class='curline'><a href='../S/2098.html#L1275'>buffer</a>           1275 src/textconv.c 	text_interface-&gt;point_changed (f, w, buffer);</span>
<span class='curline'><a href='../S/2098.html#L1702'>buffer</a>           1702 src/textconv.c   char *buffer;</span>
<span class='curline'><a href='../S/2098.html#L1718'>buffer</a>           1718 src/textconv.c   buffer = NULL;</span>
<span class='curline'><a href='../S/2098.html#L1733'>buffer</a>           1733 src/textconv.c 	  &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer)</span>
<span class='curline'><a href='../S/2098.html#L1765'>buffer</a>           1765 src/textconv.c   buffer = xmalloc (end_byte - start_byte);</span>
<span class='curline'><a href='../S/2098.html#L1767'>buffer</a>           1767 src/textconv.c 	       buffer);</span>
<span class='curline'><a href='../S/2098.html#L1792'>buffer</a>           1792 src/textconv.c   return buffer;</span>
<span class='curline'><a href='../S/2098.html#L1813'>buffer</a>           1813 src/textconv.c   char *buffer;</span>
<span class='curline'><a href='../S/2098.html#L1829'>buffer</a>           1829 src/textconv.c   buffer = NULL;</span>
<span class='curline'><a href='../S/2098.html#L1870'>buffer</a>           1870 src/textconv.c   buffer = xmalloc (end_byte - start_byte);</span>
<span class='curline'><a href='../S/2098.html#L1872'>buffer</a>           1872 src/textconv.c 	       buffer);</span>
<span class='curline'><a href='../S/2098.html#L1892'>buffer</a>           1892 src/textconv.c   return buffer;</span>
<span class='curline'><a href='../S/2098.html#L1948'>buffer</a>           1948 src/textconv.c 		     struct buffer *buffer)</span>
<span class='curline'><a href='../S/2098.html#L1956'>buffer</a>           1956 src/textconv.c     text_interface-&gt;point_changed (f, window, buffer);</span>
<span class='curline'><a href='../S/2098.html#L2034'>buffer</a>           2034 src/textconv.c   Lisp_Object buffer, tail, frame;</span>
<span class='curline'><a href='../S/2098.html#L2035'>buffer</a>           2035 src/textconv.c   struct buffer *b;</span>
<span class='curline'><a href='../S/2098.html#L2038'>buffer</a>           2038 src/textconv.c   buffer = postponed_buffers;</span>
<span class='curline'><a href='../S/2098.html#L2044'>buffer</a>           2044 src/textconv.c   FOR_EACH_TAIL (buffer)</span>
<span class='curline'><a href='../S/2098.html#L2046'>buffer</a>           2046 src/textconv.c       b = XBUFFER (XCAR (buffer));</span>
<span class='curline'><a href='../S/2098.html#L2069'>buffer</a>           2069 src/textconv.c 		     XCAR (buffer)))</span>
<span class='curline'><a href='../S/2098.html#L2106'>buffer</a>           2106 src/textconv.c   Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2098.html#L2118'>buffer</a>           2118 src/textconv.c       buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2098.html#L2126'>buffer</a>           2126 src/textconv.c 	  if (NILP (Fmemq (buffer, postponed_buffers)))</span>
<span class='curline'><a href='../S/2098.html#L2130'>buffer</a>           2130 src/textconv.c 	    postponed_buffers = Fcons (buffer, postponed_buffers);</span>
<span class='curline'><a href='../S/2098.html#L2141'>buffer</a>           2141 src/textconv.c 		     buffer))</span>
<span class='curline'><a href='../S/2320.html#L43'>buffer</a>             43 src/textconv.h 			 struct buffer *);</span>
<span class='curline'><a href='../S/2274.html#L78'>buffer</a>             78 src/textprop.c modify_text_properties (Lisp_Object buffer, Lisp_Object start, Lisp_Object end)</span>
<span class='curline'><a href='../S/2274.html#L81'>buffer</a>             81 src/textprop.c   struct buffer *buf = XBUFFER (buffer), *old = current_buffer;</span>
<span class='curline'><a href='../S/2274.html#L154'>buffer</a>            154 src/textprop.c       register struct buffer *b = XBUFFER (object);</span>
<span class='curline'><a href='../S/2274.html#L537'>buffer</a>            537 src/textprop.c       register struct buffer *b = XBUFFER (object);</span>
<span class='curline'><a href='../S/2274.html#L636'>buffer</a>            636 src/textprop.c       struct buffer *b = XBUFFER (object);</span>
<span class='curline'><a href='../S/2274.html#L1901'>buffer</a>           1901 src/textprop.c text_property_stickiness (Lisp_Object prop, Lisp_Object pos, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2274.html#L1909'>buffer</a>           1909 src/textprop.c   if (NILP (buffer))</span>
<span class='curline'><a href='../S/2274.html#L1910'>buffer</a>           1910 src/textprop.c     XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/2274.html#L1912'>buffer</a>           1912 src/textprop.c   ignore_previous_character = XFIXNUM (pos) &lt;= BUF_BEGV (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2274.html#L1919'>buffer</a>           1919 src/textprop.c 	= Fget_text_property (prev_pos, Qrear_nonsticky, buffer);</span>
<span class='curline'><a href='../S/2274.html#L1931'>buffer</a>           1931 src/textprop.c   front_sticky = Fget_text_property (pos, Qfront_sticky, buffer);</span>
<span class='curline'><a href='../S/2274.html#L1952'>buffer</a>           1952 src/textprop.c       || NILP (Fget_text_property (prev_pos, prop, buffer)))</span>
<span class='curline'><a href='../S/2274.html#L2184'>buffer</a>           2184 src/textprop.c verify_interval_modification (struct buffer *buf,</span>
<span class='curline'><a href='../S/2119.html#L1095'>buffer</a>           1095 src/thread.c   thread_check_current_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/2119.html#L1104'>buffer</a>           1104 src/thread.c         if (iter-&gt;m_current_buffer == buffer)</span>
<span class='curline'><a href='../S/2353.html#L132'>buffer</a>            132 src/thread.h     struct buffer *m_current_buffer;</span>
<span class='curline'><a href='../S/2353.html#L327'>buffer</a>            327 src/thread.h   bool thread_check_current_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/2278.html#L1342'>buffer</a>           1342 src/timefns.c    char buffer[4000];</span>
<span class='curline'><a href='../S/2278.html#L1343'>buffer</a>           1343 src/timefns.c    char *buf = buffer;</span>
<span class='curline'><a href='../S/2278.html#L1344'>buffer</a>           1344 src/timefns.c    ptrdiff_t size = sizeof buffer;</span>
<span class='curline'><a href='../S/2296.html#L792'>buffer</a>            792 src/treesit.c    struct buffer *base_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2296.html#L921'>buffer</a>            921 src/treesit.c    struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2296.html#L927'>buffer</a>            927 src/treesit.c        XTS_PARSER (parser)-&gt;visible_beg = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2296.html#L928'>buffer</a>            928 src/treesit.c        XTS_PARSER (parser)-&gt;visible_end = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2296.html#L937'>buffer</a>            937 src/treesit.c    eassert (BUF_BEGV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/2296.html#L938'>buffer</a>            938 src/treesit.c    eassert (BUF_ZV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/2296.html#L942'>buffer</a>            942 src/treesit.c    if (visible_beg != BUF_BEGV_BYTE (buffer)</span>
<span class='curline'><a href='../S/2296.html#L943'>buffer</a>            943 src/treesit.c        || visible_end != BUF_ZV_BYTE (buffer))</span>
<span class='curline'><a href='../S/2296.html#L955'>buffer</a>            955 src/treesit.c    if (visible_beg &gt; BUF_BEGV_BYTE (buffer))</span>
<span class='curline'><a href='../S/2296.html#L958'>buffer</a>            958 src/treesit.c        treesit_tree_edit_1 (tree, 0, 0, visible_beg - BUF_BEGV_BYTE (buffer));</span>
<span class='curline'><a href='../S/2296.html#L959'>buffer</a>            959 src/treesit.c        visible_beg = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2296.html#L963'>buffer</a>            963 src/treesit.c    if (visible_end &lt; BUF_ZV_BYTE (buffer))</span>
<span class='curline'><a href='../S/2296.html#L968'>buffer</a>            968 src/treesit.c  			   BUF_ZV_BYTE (buffer) - visible_beg);</span>
<span class='curline'><a href='../S/2296.html#L969'>buffer</a>            969 src/treesit.c        visible_end = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2296.html#L972'>buffer</a>            972 src/treesit.c    else if (visible_end &gt; BUF_ZV_BYTE (buffer))</span>
<span class='curline'><a href='../S/2296.html#L975'>buffer</a>            975 src/treesit.c        treesit_tree_edit_1 (tree, BUF_ZV_BYTE (buffer) - visible_beg,</span>
<span class='curline'><a href='../S/2296.html#L977'>buffer</a>            977 src/treesit.c  			   BUF_ZV_BYTE (buffer) - visible_beg);</span>
<span class='curline'><a href='../S/2296.html#L978'>buffer</a>            978 src/treesit.c        visible_end = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2296.html#L982'>buffer</a>            982 src/treesit.c    if (visible_beg &lt; BUF_BEGV_BYTE (buffer))</span>
<span class='curline'><a href='../S/2296.html#L985'>buffer</a>            985 src/treesit.c        treesit_tree_edit_1 (tree, 0, BUF_BEGV_BYTE (buffer) - visible_beg, 0);</span>
<span class='curline'><a href='../S/2296.html#L986'>buffer</a>            986 src/treesit.c        visible_beg = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2296.html#L991'>buffer</a>            991 src/treesit.c    eassert (visible_beg == BUF_BEGV_BYTE (buffer));</span>
<span class='curline'><a href='../S/2296.html#L992'>buffer</a>            992 src/treesit.c    eassert (visible_end == BUF_ZV_BYTE (buffer));</span>
<span class='curline'><a href='../S/2296.html#L999'>buffer</a>            999 src/treesit.c  treesit_check_buffer_size (struct buffer *buffer)</span>
<span class='curline'><a href='../S/2296.html#L1001'>buffer</a>           1001 src/treesit.c    ptrdiff_t buffer_size_bytes = (BUF_Z_BYTE (buffer) - BUF_BEG_BYTE (buffer));</span>
<span class='curline'><a href='../S/2296.html#L1008'>buffer</a>           1008 src/treesit.c  static Lisp_Object treesit_make_ranges (const TSRange *, uint32_t, struct buffer *);</span>
<span class='curline'><a href='../S/2296.html#L1017'>buffer</a>           1017 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2296.html#L1027'>buffer</a>           1027 src/treesit.c        struct buffer *oldbuf = current_buffer;</span>
<span class='curline'><a href='../S/2296.html#L1049'>buffer</a>           1049 src/treesit.c    struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2296.html#L1052'>buffer</a>           1052 src/treesit.c    treesit_check_buffer_size (buffer);</span>
<span class='curline'><a href='../S/2296.html#L1077'>buffer</a>           1077 src/treesit.c        XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/2296.html#L1101'>buffer</a>           1101 src/treesit.c    struct buffer *buffer = XBUFFER (((struct Lisp_TS_Parser *) parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2296.html#L1108'>buffer</a>           1108 src/treesit.c    eassert (visible_beg = BUF_BEGV_BYTE (buffer));</span>
<span class='curline'><a href='../S/2296.html#L1109'>buffer</a>           1109 src/treesit.c    eassert (visible_end = BUF_ZV_BYTE (buffer));</span>
<span class='curline'><a href='../S/2296.html#L1121'>buffer</a>           1121 src/treesit.c    if (!BUFFER_LIVE_P (buffer))</span>
<span class='curline'><a href='../S/2296.html#L1135'>buffer</a>           1135 src/treesit.c        beg = (char *) BUF_BYTE_ADDRESS (buffer, byte_pos);</span>
<span class='curline'><a href='../S/2296.html#L1151'>buffer</a>           1151 src/treesit.c  make_treesit_parser (Lisp_Object buffer, TSParser *parser,</span>
<span class='curline'><a href='../S/2296.html#L1157'>buffer</a>           1157 src/treesit.c  				       buffer, PVEC_TS_PARSER);</span>
<span class='curline'><a href='../S/2296.html#L1161'>buffer</a>           1161 src/treesit.c    lisp_parser-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/2296.html#L1167'>buffer</a>           1167 src/treesit.c    lisp_parser-&gt;visible_beg = BUF_BEGV_BYTE (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2296.html#L1168'>buffer</a>           1168 src/treesit.c    lisp_parser-&gt;visible_end = BUF_ZV_BYTE (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2296.html#L1391'>buffer</a>           1391 src/treesit.c    (Lisp_Object language, Lisp_Object buffer, Lisp_Object no_reuse)</span>
<span class='curline'><a href='../S/2296.html#L1396'>buffer</a>           1396 src/treesit.c    struct buffer *buf;</span>
<span class='curline'><a href='../S/2296.html#L1397'>buffer</a>           1397 src/treesit.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2296.html#L1401'>buffer</a>           1401 src/treesit.c        CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2296.html#L1402'>buffer</a>           1402 src/treesit.c        buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2296.html#L1453'>buffer</a>           1453 src/treesit.c    Lisp_Object buffer = XTS_PARSER (parser)-&gt;buffer;</span>
<span class='curline'><a href='../S/2296.html#L1454'>buffer</a>           1454 src/treesit.c    struct buffer *buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2296.html#L1471'>buffer</a>           1471 src/treesit.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2296.html#L1473'>buffer</a>           1473 src/treesit.c    struct buffer *buf;</span>
<span class='curline'><a href='../S/2296.html#L1474'>buffer</a>           1474 src/treesit.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2296.html#L1478'>buffer</a>           1478 src/treesit.c        CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2296.html#L1479'>buffer</a>           1479 src/treesit.c        buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2296.html#L1505'>buffer</a>           1505 src/treesit.c    XSETBUFFER (buf, XBUFFER (XTS_PARSER (parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/2296.html#L1526'>buffer</a>           1526 src/treesit.c  	  (!NILP (Fbuffer_live_p (XTS_PARSER (parser)-&gt;buffer))));</span>
<span class='curline'><a href='../S/2296.html#L1550'>buffer</a>           1550 src/treesit.c    struct buffer *buffer = current_buffer;</span>
<span class='curline'><a href='../S/2296.html#L1551'>buffer</a>           1551 src/treesit.c    ptrdiff_t point_min = BUF_BEGV (buffer);</span>
<span class='curline'><a href='../S/2296.html#L1552'>buffer</a>           1552 src/treesit.c    ptrdiff_t point_max = BUF_ZV (buffer);</span>
<span class='curline'><a href='../S/2296.html#L1586'>buffer</a>           1586 src/treesit.c  		     struct buffer *buffer)</span>
<span class='curline'><a href='../S/2296.html#L1592'>buffer</a>           1592 src/treesit.c        uint32_t beg_byte = range.start_byte + BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2296.html#L1593'>buffer</a>           1593 src/treesit.c        uint32_t end_byte = range.end_byte + BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2296.html#L1594'>buffer</a>           1594 src/treesit.c        eassert (BUF_BEGV_BYTE (buffer) &lt;= beg_byte);</span>
<span class='curline'><a href='../S/2296.html#L1596'>buffer</a>           1596 src/treesit.c        eassert (end_byte &lt;= BUF_ZV_BYTE (buffer));</span>
<span class='curline'><a href='../S/2296.html#L1599'>buffer</a>           1599 src/treesit.c  	= Fcons (make_fixnum (buf_bytepos_to_charpos (buffer, beg_byte)),</span>
<span class='curline'><a href='../S/2296.html#L1600'>buffer</a>           1600 src/treesit.c  		 make_fixnum (buf_bytepos_to_charpos (buffer, end_byte)));</span>
<span class='curline'><a href='../S/2296.html#L1627'>buffer</a>           1627 src/treesit.c    treesit_check_buffer_size (XBUFFER (XTS_PARSER (parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/2296.html#L1650'>buffer</a>           1650 src/treesit.c        struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2296.html#L1658'>buffer</a>           1658 src/treesit.c  	  ptrdiff_t beg_byte = buf_charpos_to_bytepos (buffer,</span>
<span class='curline'><a href='../S/2296.html#L1660'>buffer</a>           1660 src/treesit.c  	  ptrdiff_t end_byte = buf_charpos_to_bytepos (buffer,</span>
<span class='curline'><a href='../S/2296.html#L1664'>buffer</a>           1664 src/treesit.c  	  eassert (beg_byte - BUF_BEGV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/2296.html#L1665'>buffer</a>           1665 src/treesit.c  	  eassert (end_byte - BUF_BEGV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/2296.html#L1669'>buffer</a>           1669 src/treesit.c  			(uint32_t) beg_byte - BUF_BEGV_BYTE (buffer),</span>
<span class='curline'><a href='../S/2296.html#L1670'>buffer</a>           1670 src/treesit.c  			(uint32_t) end_byte - BUF_BEGV_BYTE (buffer)};</span>
<span class='curline'><a href='../S/2296.html#L1713'>buffer</a>           1713 src/treesit.c    treesit_check_buffer_size (XBUFFER (XTS_PARSER (parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/2296.html#L1716'>buffer</a>           1716 src/treesit.c    struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2296.html#L1717'>buffer</a>           1717 src/treesit.c    return treesit_make_ranges (ranges, len, buffer);</span>
<span class='curline'><a href='../S/2296.html#L1800'>buffer</a>           1800 src/treesit.c  treesit_check_position (Lisp_Object obj, struct buffer *buf)</span>
<span class='curline'><a href='../S/2296.html#L1843'>buffer</a>           1843 src/treesit.c    struct buffer *buffer</span>
<span class='curline'><a href='../S/2296.html#L1844'>buffer</a>           1844 src/treesit.c      = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2296.html#L1846'>buffer</a>           1846 src/treesit.c      = buf_bytepos_to_charpos (buffer,</span>
<span class='curline'><a href='../S/2296.html#L1864'>buffer</a>           1864 src/treesit.c    struct buffer *buffer</span>
<span class='curline'><a href='../S/2296.html#L1865'>buffer</a>           1865 src/treesit.c      = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2296.html#L1867'>buffer</a>           1867 src/treesit.c      = buf_bytepos_to_charpos (buffer, end_byte_offset + visible_beg);</span>
<span class='curline'><a href='../S/2296.html#L2208'>buffer</a>           2208 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2296.html#L2244'>buffer</a>           2244 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2296.html#L2532'>buffer</a>           2532 src/treesit.c    struct buffer *old_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2296.html#L2533'>buffer</a>           2533 src/treesit.c    set_buffer_internal (XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/2296.html#L2888'>buffer</a>           2888 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (lisp_parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2296.html#L2944'>buffer</a>           2944 src/treesit.c    struct buffer *old_buf = current_buffer;</span>
<span class='curline'><a href='../S/2089.html#L45'>buffer</a>             45 src/treesit.h    Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2148.html#L212'>buffer</a>            212 src/undo.c       struct buffer *base_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2148.html#L231'>buffer</a>            231 src/undo.c     			Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2148.html#L234'>buffer</a>            234 src/undo.c       struct buffer *buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2148.html#L290'>buffer</a>            290 src/undo.c     truncate_undo_list (struct buffer *b)</span>
<span class='curline'><a href='../S/2144.html#L283'>buffer</a>            283 src/unexcw.c         char buffer[4096];</span>
<span class='curline'><a href='../S/2144.html#L284'>buffer</a>            284 src/unexcw.c         ret = read (fd_in, buffer, sizeof (buffer));</span>
<span class='curline'><a href='../S/2144.html#L292'>buffer</a>            292 src/unexcw.c         ret2 = write (fd_out, buffer, ret);</span>
<span class='curline'><a href='../S/2228.html#L217'>buffer</a>            217 src/unexhp9k800.c   int buffer[8192];  /* word aligned will be faster */</span>
<span class='curline'><a href='../S/2228.html#L221'>buffer</a>            221 src/unexhp9k800.c       len = min (size, sizeof (buffer));</span>
<span class='curline'><a href='../S/2228.html#L222'>buffer</a>            222 src/unexhp9k800.c       if (read (old, buffer, len) != len)</span>
<span class='curline'><a href='../S/2228.html#L224'>buffer</a>            224 src/unexhp9k800.c       if (write (new, buffer, len) != len)</span>
<span class='curline'><a href='../S/2228.html#L234'>buffer</a>            234 src/unexhp9k800.c   int buffer[4096];</span>
<span class='curline'><a href='../S/2228.html#L238'>buffer</a>            238 src/unexhp9k800.c   while ((len = read (old, buffer, sizeof (buffer))) &gt; 0)</span>
<span class='curline'><a href='../S/2228.html#L239'>buffer</a>            239 src/unexhp9k800.c     if (write (new, buffer, len) != len) break;</span>
<span class='curline'><a href='../S/2301.html#L3931'>buffer</a>           3931 src/w32.c        char *buffer;</span>
<span class='curline'><a href='../S/2301.html#L3941'>buffer</a>           3941 src/w32.c            buffer = alloca (bufsize);</span>
<span class='curline'><a href='../S/2301.html#L3942'>buffer</a>           3942 src/w32.c            result = WNetEnumResourceW (henum, &amp;count, buffer, &amp;bufsize);</span>
<span class='curline'><a href='../S/2301.html#L3946'>buffer</a>           3946 src/w32.c            ptrw = ((LPNETRESOURCEW) buffer)-&gt;lpRemoteName;</span>
<span class='curline'><a href='../S/2301.html#L3958'>buffer</a>           3958 src/w32.c            buffer = alloca (bufsize);</span>
<span class='curline'><a href='../S/2301.html#L3959'>buffer</a>           3959 src/w32.c            result = WNetEnumResourceA (henum, &amp;count, buffer, &amp;bufsize);</span>
<span class='curline'><a href='../S/2301.html#L3962'>buffer</a>           3962 src/w32.c            ptra = ((LPNETRESOURCEA) buffer)-&gt;lpRemoteName;</span>
<span class='curline'><a href='../S/2301.html#L6364'>buffer</a>           6364 src/w32.c      readlinkat (int fd, char const *name, char *buffer,</span>
<span class='curline'><a href='../S/2301.html#L6382'>buffer</a>           6382 src/w32.c        return readlink (name, buffer, buffer_size);</span>
<span class='curline'><a href='../S/2301.html#L6803'>buffer</a>           6803 src/w32.c                    char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2301.html#L6814'>buffer</a>           6814 src/w32.c            char *retval = buffer;</span>
<span class='curline'><a href='../S/2301.html#L9005'>buffer</a>           9005 src/w32.c      sys_read (int fd, char * buffer, unsigned int count)</span>
<span class='curline'><a href='../S/2301.html#L9010'>buffer</a>           9010 src/w32.c        char * orig_buffer = buffer;</span>
<span class='curline'><a href='../S/2301.html#L9034'>buffer</a>           9034 src/w32.c      	  *buffer++ = 0x0d;</span>
<span class='curline'><a href='../S/2301.html#L9076'>buffer</a>           9076 src/w32.c      	      *buffer++ = cp-&gt;chr;</span>
<span class='curline'><a href='../S/2301.html#L9098'>buffer</a>           9098 src/w32.c      		nchars += _read (fd, buffer, to_read);</span>
<span class='curline'><a href='../S/2301.html#L9129'>buffer</a>           9129 src/w32.c      		  if (!ReadFile (hnd, buffer, count, (DWORD*) &amp;rc, ovl))</span>
<span class='curline'><a href='../S/2301.html#L9182'>buffer</a>           9182 src/w32.c      		  int res = pfn_recv (SOCK_HANDLE (fd), buffer, count, 0);</span>
<span class='curline'><a href='../S/2301.html#L9196'>buffer</a>           9196 src/w32.c      	  int nread = _read (fd, buffer, count);</span>
<span class='curline'><a href='../S/2301.html#L9221'>buffer</a>           9221 src/w32.c          nchars = _read (fd, buffer, count);</span>
<span class='curline'><a href='../S/2301.html#L9230'>buffer</a>           9230 src/w32.c      sys_write (int fd, const void * buffer, unsigned int count)</span>
<span class='curline'><a href='../S/2301.html#L9253'>buffer</a>           9253 src/w32.c      	  const unsigned char * src = buffer;</span>
<span class='curline'><a href='../S/2301.html#L9281'>buffer</a>           9281 src/w32.c      	  buffer = tmpbuf;</span>
<span class='curline'><a href='../S/2301.html#L9295'>buffer</a>           9295 src/w32.c            if (!WriteFile (hnd, buffer, count, (DWORD*) &amp;nchars, ovl))</span>
<span class='curline'><a href='../S/2301.html#L9367'>buffer</a>           9367 src/w32.c            nchars =  pfn_send (SOCK_HANDLE (fd), buffer, count, 0);</span>
<span class='curline'><a href='../S/2301.html#L9392'>buffer</a>           9392 src/w32.c            const unsigned char *p = buffer;</span>
<span class='curline'><a href='../S/2301.html#L10346'>buffer</a>           10346 src/w32.c      	  char *buffer = alloca (1024</span>
<span class='curline'><a href='../S/2301.html#L10349'>buffer</a>           10349 src/w32.c      	  char *msg = buffer;</span>
<span class='curline'><a href='../S/2301.html#L10352'>buffer</a>           10352 src/w32.c      	  sprintf (buffer,</span>
<span class='curline'><a href='../S/2301.html#L10363'>buffer</a>           10363 src/w32.c      					 buffer, -1, NULL, 0);</span>
<span class='curline'><a href='../S/2301.html#L10368'>buffer</a>           10368 src/w32.c      	      pMultiByteToWideChar (CP_UTF8, multiByteToWideCharFlags, buffer,</span>
<span class='curline'><a href='../S/2182.html#L177'>buffer</a>            177 src/w32fns.c     (IN HIMC context, IN DWORD index, OUT LPVOID buffer, IN DWORD bufLen);</span>
<span class='curline'><a href='../S/2182.html#L4610'>buffer</a>           4610 src/w32fns.c   	  wchar_t * buffer;</span>
<span class='curline'><a href='../S/2182.html#L4620'>buffer</a>           4620 src/w32fns.c   	  buffer = alloca (size);</span>
<span class='curline'><a href='../S/2182.html#L4622'>buffer</a>           4622 src/w32fns.c   					    buffer, size);</span>
<span class='curline'><a href='../S/2182.html#L4628'>buffer</a>           4628 src/w32fns.c   	      my_post_msg (&amp;wmsg, hwnd, WM_UNICHAR, (WPARAM) buffer[i],</span>
<span class='curline'><a href='../S/2182.html#L7389'>buffer</a>           7389 src/w32fns.c     struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/2182.html#L11127'>buffer</a>           11127 src/w32fns.c   w32_backtrace (void **buffer, int limit)</span>
<span class='curline'><a href='../S/2182.html#L11140'>buffer</a>           11140 src/w32fns.c   					buffer, NULL);</span>
<span class='curline'><a href='../S/2340.html#L286'>buffer</a>            286 src/w32menu.c        struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2340.html#L287'>buffer</a>            287 src/w32menu.c        Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2340.html#L299'>buffer</a>            299 src/w32menu.c        buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/2340.html#L313'>buffer</a>            313 src/w32menu.c        set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2256.html#L592'>buffer</a>            592 src/w32select.c   char buffer[20] = "";</span>
<span class='curline'><a href='../S/2256.html#L598'>buffer</a>            598 src/w32select.c   GetLocaleInfo (lcid, variant, buffer, sizeof (buffer));</span>
<span class='curline'><a href='../S/2256.html#L599'>buffer</a>            599 src/w32select.c   cp = strtoul (buffer, NULL, 10);</span>
<span class='curline'><a href='../S/2256.html#L612'>buffer</a>            612 src/w32select.c   char buffer[30];</span>
<span class='curline'><a href='../S/2256.html#L613'>buffer</a>            613 src/w32select.c   sprintf (buffer, "cp%d-dos", (int) codepage);</span>
<span class='curline'><a href='../S/2256.html#L614'>buffer</a>            614 src/w32select.c   return intern (buffer);</span>
<span class='curline'><a href='../S/2216.html#L7423'>buffer</a>           7423 src/w32term.c    char *buffer = xmalloc (strlen (xrm_option) + 2);</span>
<span class='curline'><a href='../S/2216.html#L7424'>buffer</a>           7424 src/w32term.c    char *current = buffer;</span>
<span class='curline'><a href='../S/2216.html#L7459'>buffer</a>           7459 src/w32term.c    return buffer;</span>
<span class='curline'><a href='../S/2343.html#L283'>buffer</a>            283 src/widget.c     char buffer[sizeof wmshell-&gt;wm.size_hints];</span>
<span class='curline'><a href='../S/2343.html#L287'>buffer</a>            287 src/widget.c     memcpy (buffer, &amp;wmshell-&gt;wm.size_hints,</span>
<span class='curline'><a href='../S/2343.html#L316'>buffer</a>            316 src/widget.c     return memcmp (hints_ptr + sizeof (long), buffer + sizeof (long),</span>
<span class='curline'><a href='../S/2109.html#L230'>buffer</a>            230 src/window.c     struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2109.html#L280'>buffer</a>            280 src/window.c         struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2109.html#L1821'>buffer</a>           1821 src/window.c     struct buffer *b;</span>
<span class='curline'><a href='../S/2109.html#L1841'>buffer</a>           1841 src/window.c         struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/2109.html#L1892'>buffer</a>           1892 src/window.c   	  struct buffer *old_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2109.html#L1976'>buffer</a>           1976 src/window.c     struct buffer *buf;</span>
<span class='curline'><a href='../S/2109.html#L2043'>buffer</a>           2043 src/window.c     register struct buffer *b;</span>
<span class='curline'><a href='../S/2109.html#L2178'>buffer</a>           2178 src/window.c     struct buffer *b;</span>
<span class='curline'><a href='../S/2109.html#L2414'>buffer</a>           2414 src/window.c         struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2109.html#L2440'>buffer</a>           2440 src/window.c     struct buffer *b = XBUFFER (buf);</span>
<span class='curline'><a href='../S/2109.html#L2442'>buffer</a>           2442 src/window.c     eassert (b == XMARKER (w-&gt;pointm)-&gt;buffer);</span>
<span class='curline'><a href='../S/2109.html#L3185'>buffer</a>           3185 src/window.c   		struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2109.html#L3189'>buffer</a>           3189 src/window.c   		if (!MARKERP (w-&gt;start) || XMARKER (w-&gt;start)-&gt;buffer != b)</span>
<span class='curline'><a href='../S/2109.html#L3191'>buffer</a>           3191 src/window.c   		if (!MARKERP (w-&gt;pointm) || XMARKER (w-&gt;pointm)-&gt;buffer != b)</span>
<span class='curline'><a href='../S/2109.html#L3233'>buffer</a>           3233 src/window.c     Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2109.html#L3236'>buffer</a>           3236 src/window.c       buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2109.html#L3238'>buffer</a>           3238 src/window.c       buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/2109.html#L3240'>buffer</a>           3240 src/window.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/2109.html#L3241'>buffer</a>           3241 src/window.c       return window_loop (GET_BUFFER_WINDOW, buffer, true, all_frames);</span>
<span class='curline'><a href='../S/2109.html#L3486'>buffer</a>           3486 src/window.c   	  struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/2109.html#L3515'>buffer</a>           3515 src/window.c   replace_buffer_in_windows (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2109.html#L3520'>buffer</a>           3520 src/window.c       call1 (Qreplace_buffer_in_windows, buffer);</span>
<span class='curline'><a href='../S/2109.html#L3527'>buffer</a>           3527 src/window.c   replace_buffer_in_windows_safely (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2109.html#L3529'>buffer</a>           3529 src/window.c     if (buffer_window_count (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/2109.html#L3537'>buffer</a>           3537 src/window.c   	window_loop (REPLACE_BUFFER_IN_WINDOWS_SAFELY, buffer, true, frame);</span>
<span class='curline'><a href='../S/2109.html#L3606'>buffer</a>           3606 src/window.c   	Lisp_Object buffer = Fwindow_buffer (window);</span>
<span class='curline'><a href='../S/2109.html#L3608'>buffer</a>           3608 src/window.c   				      buffer)))</span>
<span class='curline'><a href='../S/2109.html#L3614'>buffer</a>           3614 src/window.c   					   buffer));</span>
<span class='curline'><a href='../S/2109.html#L3793'>buffer</a>           3793 src/window.c   run_window_change_functions_1 (Lisp_Object symbol, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/2109.html#L3798'>buffer</a>           3798 src/window.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2109.html#L3800'>buffer</a>           3800 src/window.c     else if (!NILP (Fassoc (symbol, BVAR (XBUFFER (buffer), local_var_alist),</span>
<span class='curline'><a href='../S/2109.html#L3803'>buffer</a>           3803 src/window.c       funs = buffer_local_value (symbol, buffer);</span>
<span class='curline'><a href='../S/2109.html#L3808'>buffer</a>           3808 src/window.c   	  &amp;&amp; (NILP (buffer)</span>
<span class='curline'><a href='../S/2109.html#L3940'>buffer</a>           3940 src/window.c   	  Lisp_Object buffer = WINDOW_BUFFER (w);</span>
<span class='curline'><a href='../S/2109.html#L3954'>buffer</a>           3954 src/window.c   	     &amp;&amp; (!EQ (buffer, w-&gt;old_buffer)</span>
<span class='curline'><a href='../S/2109.html#L3982'>buffer</a>           3982 src/window.c   	      (Qwindow_buffer_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/2109.html#L3986'>buffer</a>           3986 src/window.c   	      (Qwindow_size_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/2109.html#L3999'>buffer</a>           3999 src/window.c   	      (Qwindow_selection_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/2109.html#L4014'>buffer</a>           4014 src/window.c   	      (Qwindow_state_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/2109.html#L4098'>buffer</a>           4098 src/window.c   set_window_buffer (Lisp_Object window, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/2109.html#L4102'>buffer</a>           4102 src/window.c     struct buffer *b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2109.html#L4104'>buffer</a>           4104 src/window.c     bool samebuf = EQ (buffer, w-&gt;contents);</span>
<span class='curline'><a href='../S/2109.html#L4106'>buffer</a>           4106 src/window.c     wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/2109.html#L4131'>buffer</a>           4131 src/window.c         set_marker_both (w-&gt;pointm, buffer, BUF_PT (b), BUF_PT_BYTE (b));</span>
<span class='curline'><a href='../S/2109.html#L4132'>buffer</a>           4132 src/window.c         set_marker_both (w-&gt;old_pointm, buffer, BUF_PT (b), BUF_PT_BYTE (b));</span>
<span class='curline'><a href='../S/2109.html#L4135'>buffer</a>           4135 src/window.c   			     buffer);</span>
<span class='curline'><a href='../S/2109.html#L4146'>buffer</a>           4146 src/window.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2109.html#L4204'>buffer</a>           4204 src/window.c     register Lisp_Object tem, buffer;</span>
<span class='curline'><a href='../S/2109.html#L4208'>buffer</a>           4208 src/window.c     buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/2109.html#L4209'>buffer</a>           4209 src/window.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2109.html#L4210'>buffer</a>           4210 src/window.c     if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/2109.html#L4218'>buffer</a>           4218 src/window.c         if (!EQ (tem, buffer))</span>
<span class='curline'><a href='../S/2109.html#L4235'>buffer</a>           4235 src/window.c     set_window_buffer (window, buffer, true, !NILP (keep_margins));</span>
<span class='curline'><a href='../S/2109.html#L4241'>buffer</a>           4241 src/window.c   display_buffer (Lisp_Object buffer, Lisp_Object not_this_window_p, Lisp_Object override_frame)</span>
<span class='curline'><a href='../S/2109.html#L4243'>buffer</a>           4243 src/window.c     return call3 (Qdisplay_buffer, buffer, not_this_window_p, override_frame);</span>
<span class='curline'><a href='../S/2109.html#L4293'>buffer</a>           4293 src/window.c     register struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2109.html#L5580'>buffer</a>           5580 src/window.c     struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2109.html#L6591'>buffer</a>           6591 src/window.c     struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/2109.html#L6654'>buffer</a>           6654 src/window.c     struct buffer *buf = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2109.html#L7023'>buffer</a>           7023 src/window.c     Lisp_Object window, buffer, start, pointm, old_pointm;</span>
<span class='curline'><a href='../S/2109.html#L7162'>buffer</a>           7162 src/window.c   	      &amp;&amp; !EQ (w-&gt;contents, p-&gt;buffer)</span>
<span class='curline'><a href='../S/2109.html#L7163'>buffer</a>           7163 src/window.c   	      &amp;&amp; BUFFER_LIVE_P (XBUFFER (p-&gt;buffer))</span>
<span class='curline'><a href='../S/2109.html#L7164'>buffer</a>           7164 src/window.c   	      &amp;&amp; (NILP (Fminibufferp (p-&gt;buffer, Qnil))))</span>
<span class='curline'><a href='../S/2109.html#L7294'>buffer</a>           7294 src/window.c   	      &amp;&amp; BUFFERP (p-&gt;buffer) &amp;&amp; BUFFER_LIVE_P (XBUFFER (p-&gt;buffer)))</span>
<span class='curline'><a href='../S/2109.html#L7298'>buffer</a>           7298 src/window.c   	      wset_buffer (w, p-&gt;buffer);</span>
<span class='curline'><a href='../S/2109.html#L7306'>buffer</a>           7306 src/window.c   	      if (!EQ (p-&gt;buffer, new_current_buffer)</span>
<span class='curline'><a href='../S/2109.html#L7307'>buffer</a>           7307 src/window.c   		  &amp;&amp; XBUFFER (p-&gt;buffer) == current_buffer)</span>
<span class='curline'><a href='../S/2109.html#L7314'>buffer</a>           7314 src/window.c   	      if (XMARKER (w-&gt;start)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/2109.html#L7316'>buffer</a>           7316 src/window.c   	      if (XMARKER (w-&gt;pointm)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/2109.html#L7321'>buffer</a>           7321 src/window.c   	      if (XMARKER (w-&gt;old_pointm)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/2109.html#L7584'>buffer</a>           7584 src/window.c         p-&gt;buffer = (WINDOW_LEAF_P (w) ? w-&gt;contents : Qnil);</span>
<span class='curline'><a href='../S/2109.html#L8290'>buffer</a>           8290 src/window.c   	  || !EQ (sw1-&gt;buffer, sw2-&gt;buffer)</span>
<span class='curline'><a href='../S/2318.html#L1127'>buffer</a>           1127 src/window.h   void set_window_buffer (Lisp_Object window, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/2318.html#L1155'>buffer</a>           1155 src/window.h   extern void bset_redisplay (struct buffer *b);</span>
<span class='curline'><a href='../S/2318.html#L1156'>buffer</a>           1156 src/window.h   extern void bset_update_mode_line (struct buffer *b);</span>
<span class='curline'><a href='../S/2225.html#L659'>buffer</a>            659 src/xdisp.c    static struct buffer *this_line_buffer;</span>
<span class='curline'><a href='../S/2225.html#L847'>buffer</a>            847 src/xdisp.c    bset_redisplay (struct buffer *b)</span>
<span class='curline'><a href='../S/2225.html#L863'>buffer</a>            863 src/xdisp.c    bset_update_mode_line (struct buffer *b)</span>
<span class='curline'><a href='../S/2225.html#L936'>buffer</a>            936 src/xdisp.c    static struct buffer *displayed_buffer;</span>
<span class='curline'><a href='../S/2225.html#L1510'>buffer</a>           1510 src/xdisp.c      struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/2225.html#L1557'>buffer</a>           1557 src/xdisp.c          struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L1655'>buffer</a>           1655 src/xdisp.c      struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/2225.html#L4522'>buffer</a>           4522 src/xdisp.c          struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L11600'>buffer</a>           11600 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L11601'>buffer</a>           11601 src/xdisp.c      struct buffer *old_b = NULL;</span>
<span class='curline'><a href='../S/2225.html#L11638'>buffer</a>           11638 src/xdisp.c      struct buffer *b = (NILP (buffer_or_name)</span>
<span class='curline'><a href='../S/2225.html#L11641'>buffer</a>           11641 src/xdisp.c      Lisp_Object buffer, value;</span>
<span class='curline'><a href='../S/2225.html#L11644'>buffer</a>           11644 src/xdisp.c      XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/2225.html#L11654'>buffer</a>           11654 src/xdisp.c      if (!EQ (buffer, w-&gt;contents))</span>
<span class='curline'><a href='../S/2225.html#L11656'>buffer</a>           11656 src/xdisp.c          wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/2225.html#L11657'>buffer</a>           11657 src/xdisp.c          set_marker_both (w-&gt;pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/2225.html#L11658'>buffer</a>           11658 src/xdisp.c          set_marker_both (w-&gt;old_pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/2225.html#L11675'>buffer</a>           11675 src/xdisp.c      struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L11757'>buffer</a>           11757 src/xdisp.c      char *buffer = SAFE_ALLOCA (len);</span>
<span class='curline'><a href='../S/2225.html#L11758'>buffer</a>           11758 src/xdisp.c      memcpy (buffer, SDATA (msg), len);</span>
<span class='curline'><a href='../S/2225.html#L11760'>buffer</a>           11760 src/xdisp.c      message_dolog (buffer, len - 1, true, STRING_MULTIBYTE (msg));</span>
<span class='curline'><a href='../S/2225.html#L11794'>buffer</a>           11794 src/xdisp.c          struct buffer *oldbuf;</span>
<span class='curline'><a href='../S/2225.html#L12028'>buffer</a>           12028 src/xdisp.c          char *buffer;</span>
<span class='curline'><a href='../S/2225.html#L12030'>buffer</a>           12030 src/xdisp.c          SAFE_ALLOCA_STRING (buffer, m);</span>
<span class='curline'><a href='../S/2225.html#L12031'>buffer</a>           12031 src/xdisp.c          message_dolog (buffer, nbytes, true, multibyte);</span>
<span class='curline'><a href='../S/2225.html#L12331'>buffer</a>           12331 src/xdisp.c      Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2225.html#L12367'>buffer</a>           12367 src/xdisp.c      buffer = echo_area_buffer[this_one];</span>
<span class='curline'><a href='../S/2225.html#L12371'>buffer</a>           12371 src/xdisp.c      if (echo_kboard == NULL &amp;&amp; EQ (buffer, echo_message_buffer))</span>
<span class='curline'><a href='../S/2225.html#L12384'>buffer</a>           12384 src/xdisp.c      set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2225.html#L12387'>buffer</a>           12387 src/xdisp.c          wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/2225.html#L12388'>buffer</a>           12388 src/xdisp.c          set_marker_both (w-&gt;pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/2225.html#L12389'>buffer</a>           12389 src/xdisp.c          set_marker_both (w-&gt;old_pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/2225.html#L12470'>buffer</a>           12470 src/xdisp.c          Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2225.html#L12473'>buffer</a>           12473 src/xdisp.c          buffer = AREF (vector, 4);</span>
<span class='curline'><a href='../S/2225.html#L12475'>buffer</a>           12475 src/xdisp.c          wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/2225.html#L12476'>buffer</a>           12476 src/xdisp.c          set_marker_restricted_both (w-&gt;pointm, buffer,</span>
<span class='curline'><a href='../S/2225.html#L12479'>buffer</a>           12479 src/xdisp.c          set_marker_restricted_both (w-&gt;old_pointm, buffer,</span>
<span class='curline'><a href='../S/2225.html#L12482'>buffer</a>           12482 src/xdisp.c          set_marker_restricted_both (w-&gt;start, buffer,</span>
<span class='curline'><a href='../S/2225.html#L12735'>buffer</a>           12735 src/xdisp.c          struct buffer *old_current_buffer = NULL;</span>
<span class='curline'><a href='../S/2225.html#L13247'>buffer</a>           13247 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L13332'>buffer</a>           13332 src/xdisp.c    			      struct buffer *obuf,</span>
<span class='curline'><a href='../S/2225.html#L13361'>buffer</a>           13361 src/xdisp.c          Lisp_Object buffer = XWINDOW (target_frame-&gt;selected_window)-&gt;contents;</span>
<span class='curline'><a href='../S/2225.html#L13362'>buffer</a>           13362 src/xdisp.c          struct buffer *b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2225.html#L13363'>buffer</a>           13363 src/xdisp.c          struct buffer *cb = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L13375'>buffer</a>           13375 src/xdisp.c          ASET (vector, 10, buffer);</span>
<span class='curline'><a href='../S/2225.html#L13427'>buffer</a>           13427 src/xdisp.c    	  Lisp_Object buffer = AREF (vector, 10);</span>
<span class='curline'><a href='../S/2225.html#L13429'>buffer</a>           13429 src/xdisp.c    	  if (BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/2225.html#L13431'>buffer</a>           13431 src/xdisp.c    	      struct buffer *cb = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L13433'>buffer</a>           13433 src/xdisp.c    	      current_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2225.html#L13628'>buffer</a>           13628 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L13635'>buffer</a>           13635 src/xdisp.c              &amp;&amp; !buffer-&gt;text-&gt;redisplay</span>
<span class='curline'><a href='../S/2225.html#L13805'>buffer</a>           13805 src/xdisp.c    	  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L13972'>buffer</a>           13972 src/xdisp.c    	  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L14940'>buffer</a>           14940 src/xdisp.c    	  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L16042'>buffer</a>           16042 src/xdisp.c    	      struct buffer *saved_current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L16144'>buffer</a>           16144 src/xdisp.c    		  struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L16351'>buffer</a>           16351 src/xdisp.c    	  &amp;&amp; current_buffer == XMARKER (val)-&gt;buffer)</span>
<span class='curline'><a href='../S/2225.html#L16388'>buffer</a>           16388 src/xdisp.c    	  struct buffer *buf = XMARKER (val)-&gt;buffer;</span>
<span class='curline'><a href='../S/2225.html#L16460'>buffer</a>           16460 src/xdisp.c    	  &amp;&amp; current_buffer == XMARKER (val)-&gt;buffer</span>
<span class='curline'><a href='../S/2225.html#L16490'>buffer</a>           16490 src/xdisp.c    check_point_in_composition (struct buffer *prev_buf, ptrdiff_t prev_pt,</span>
<span class='curline'><a href='../S/2225.html#L16491'>buffer</a>           16491 src/xdisp.c    			    struct buffer *buf, ptrdiff_t pt)</span>
<span class='curline'><a href='../S/2225.html#L16495'>buffer</a>           16495 src/xdisp.c      Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2225.html#L16497'>buffer</a>           16497 src/xdisp.c      XSETBUFFER (buffer, buf);</span>
<span class='curline'><a href='../S/2225.html#L16507'>buffer</a>           16507 src/xdisp.c    	  &amp;&amp; find_composition (prev_pt, -1, &amp;start, &amp;end, &amp;prop, buffer)</span>
<span class='curline'><a href='../S/2225.html#L16517'>buffer</a>           16517 src/xdisp.c    	  &amp;&amp; find_composition (pt, -1, &amp;start, &amp;end, &amp;prop, buffer)</span>
<span class='curline'><a href='../S/2225.html#L16527'>buffer</a>           16527 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L16531'>buffer</a>           16531 src/xdisp.c          &amp;&amp; w-&gt;current_matrix-&gt;buffer == b</span>
<span class='curline'><a href='../S/2225.html#L16545'>buffer</a>           16545 src/xdisp.c          if ((w-&gt;current_matrix-&gt;buffer != b || pt != w-&gt;last_point)</span>
<span class='curline'><a href='../S/2225.html#L16546'>buffer</a>           16546 src/xdisp.c    	  &amp;&amp; check_point_in_composition (w-&gt;current_matrix-&gt;buffer,</span>
<span class='curline'><a href='../S/2225.html#L16568'>buffer</a>           16568 src/xdisp.c          struct buffer *thisb = XBUFFER (thisw-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L17531'>buffer</a>           17531 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L17555'>buffer</a>           17555 src/xdisp.c          w-&gt;current_matrix-&gt;buffer = b;</span>
<span class='curline'><a href='../S/2225.html#L17578'>buffer</a>           17578 src/xdisp.c          if (XMARKER (BVAR (b, mark))-&gt;buffer == b</span>
<span class='curline'><a href='../S/2225.html#L19477'>buffer</a>           19477 src/xdisp.c          struct buffer *buf = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L19490'>buffer</a>           19490 src/xdisp.c    	  struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L19525'>buffer</a>           19525 src/xdisp.c          struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L19526'>buffer</a>           19526 src/xdisp.c          struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/2225.html#L19673'>buffer</a>           19673 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L19674'>buffer</a>           19674 src/xdisp.c      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L19706'>buffer</a>           19706 src/xdisp.c      eassert (XMARKER (w-&gt;start)-&gt;buffer == buffer);</span>
<span class='curline'><a href='../S/2225.html#L19707'>buffer</a>           19707 src/xdisp.c      eassert (XMARKER (w-&gt;pointm)-&gt;buffer == buffer);</span>
<span class='curline'><a href='../S/2225.html#L19717'>buffer</a>           19717 src/xdisp.c    		      || buffer-&gt;clip_changed</span>
<span class='curline'><a href='../S/2225.html#L19718'>buffer</a>           19718 src/xdisp.c    		      || buffer-&gt;prevent_redisplay_optimizations_p);</span>
<span class='curline'><a href='../S/2225.html#L19801'>buffer</a>           19801 src/xdisp.c          if (XMARKER (w-&gt;start)-&gt;buffer == current_buffer)</span>
<span class='curline'><a href='../S/2225.html#L19858'>buffer</a>           19858 src/xdisp.c    	  struct buffer *buf = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L19887'>buffer</a>           19887 src/xdisp.c      if (XMARKER (w-&gt;start)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/2225.html#L20225'>buffer</a>           20225 src/xdisp.c    	  &amp;&amp; XMARKER (w-&gt;start)-&gt;buffer == current_buffer</span>
<span class='curline'><a href='../S/2225.html#L22798'>buffer</a>           22798 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L22801'>buffer</a>           22801 src/xdisp.c    	   BUF_PT (buffer), BUF_BEGV (buffer), BUF_ZV (buffer));</span>
<span class='curline'><a href='../S/2225.html#L22969'>buffer</a>           22969 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L22970'>buffer</a>           22970 src/xdisp.c      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L22979'>buffer</a>           22979 src/xdisp.c      set_buffer_temp (buffer);</span>
<span class='curline'><a href='../S/2225.html#L22985'>buffer</a>           22985 src/xdisp.c      multibyte_p = !NILP (BVAR (buffer, enable_multibyte_characters));</span>
<span class='curline'><a href='../S/2225.html#L25815'>buffer</a>           25815 src/xdisp.c      (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2225.html#L25817'>buffer</a>           25817 src/xdisp.c      struct buffer *buf = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L25818'>buffer</a>           25818 src/xdisp.c      struct buffer *old = buf;</span>
<span class='curline'><a href='../S/2225.html#L25820'>buffer</a>           25820 src/xdisp.c      if (! NILP (buffer))</span>
<span class='curline'><a href='../S/2225.html#L25822'>buffer</a>           25822 src/xdisp.c          CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2225.html#L25823'>buffer</a>           25823 src/xdisp.c          buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2225.html#L25939'>buffer</a>           25939 src/xdisp.c      struct buffer *buf = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L25940'>buffer</a>           25940 src/xdisp.c      struct buffer *old = buf;</span>
<span class='curline'><a href='../S/2225.html#L26057'>buffer</a>           26057 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L26531'>buffer</a>           26531 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L26929'>buffer</a>           26929 src/xdisp.c    	  struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L27830'>buffer</a>           27830 src/xdisp.c          Lisp_Object window, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2225.html#L27835'>buffer</a>           27835 src/xdisp.c      struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/2225.html#L27845'>buffer</a>           27845 src/xdisp.c      if (NILP (buffer))</span>
<span class='curline'><a href='../S/2225.html#L27846'>buffer</a>           27846 src/xdisp.c        buffer = w-&gt;contents;</span>
<span class='curline'><a href='../S/2225.html#L27847'>buffer</a>           27847 src/xdisp.c      CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2225.html#L27879'>buffer</a>           27879 src/xdisp.c      set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2225.html#L28175'>buffer</a>           28175 src/xdisp.c      struct buffer *b = current_buffer;</span>
<span class='curline'><a href='../S/2225.html#L33194'>buffer</a>           33194 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2225.html#L35331'>buffer</a>           35331 src/xdisp.c      struct buffer *b;</span>
<span class='curline'><a href='../S/2225.html#L35552'>buffer</a>           35552 src/xdisp.c          struct buffer *obuf;</span>
<span class='curline'><a href='../S/2225.html#L35749'>buffer</a>           35749 src/xdisp.c    	      Lisp_Object buffer UNINIT;</span>
<span class='curline'><a href='../S/2225.html#L35763'>buffer</a>           35763 src/xdisp.c    		      buffer = w-&gt;contents;</span>
<span class='curline'><a href='../S/2225.html#L35769'>buffer</a>           35769 src/xdisp.c    		  buffer = object;</span>
<span class='curline'><a href='../S/2225.html#L35788'>buffer</a>           35788 src/xdisp.c    		    = NILP (BVAR (XBUFFER (buffer), bidi_display_reordering))</span>
<span class='curline'><a href='../S/2225.html#L35792'>buffer</a>           35792 src/xdisp.c    		    = NILP (BVAR (XBUFFER (buffer), bidi_display_reordering))</span>
<span class='curline'><a href='../S/2225.html#L35793'>buffer</a>           35793 src/xdisp.c    		    ? make_fixnum (BUF_Z (XBUFFER (buffer))</span>
<span class='curline'><a href='../S/2225.html#L35801'>buffer</a>           35801 src/xdisp.c    			(make_fixnum (pos + 1), Qmouse_face, buffer, lim1);</span>
<span class='curline'><a href='../S/2225.html#L35803'>buffer</a>           35803 src/xdisp.c    			(make_fixnum (pos), Qmouse_face, buffer, lim2);</span>
<span class='curline'><a href='../S/2225.html#L35823'>buffer</a>           35823 src/xdisp.c    					      ? BUF_Z (XBUFFER (buffer))</span>
<span class='curline'><a href='../S/2225.html#L36343'>buffer</a>           36343 src/xdisp.c          struct buffer *oldbuf = current_buffer;</span>
<span class='curline'><a href='../S/2297.html#L8988'>buffer</a>           8988 src/xfns.c       struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/2107.html#L967'>buffer</a>            967 src/xmenu.c          struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2107.html#L968'>buffer</a>            968 src/xmenu.c          Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2107.html#L980'>buffer</a>            980 src/xmenu.c          buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/2107.html#L993'>buffer</a>            993 src/xmenu.c          set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2290.html#L2413'>buffer</a>           2413 src/xterm.c      char *buffer;</span>
<span class='curline'><a href='../S/2290.html#L2461'>buffer</a>           2461 src/xterm.c      buffer = dpyinfo-&gt;motif_drag_atom_name;</span>
<span class='curline'><a href='../S/2290.html#L2465'>buffer</a>           2465 src/xterm.c          sprintf (buffer, "_EMACS_ATOM_%lu", i + 1);</span>
<span class='curline'><a href='../S/2290.html#L2479'>buffer</a>           2479 src/xterm.c          sprintf (buffer, "_EMACS_ATOM_%lu", nitems + 1);</span>
<span class='curline'><a href='../S/2290.html#L2480'>buffer</a>           2480 src/xterm.c          atom = XInternAtom (dpyinfo-&gt;display, buffer, False);</span>
<span class='curline'><a href='../S/2290.html#L29274'>buffer</a>           29274 src/xterm.c      char *dpyinfo_pointer, *name, *value, *buffer;</span>
<span class='curline'><a href='../S/2290.html#L29284'>buffer</a>           29284 src/xterm.c      buffer = alloca (45 + INT_STRLEN_BOUND (int));</span>
<span class='curline'><a href='../S/2290.html#L29325'>buffer</a>           29325 src/xterm.c    	  sprintf (buffer, "_XSETTINGS_S%d",</span>
<span class='curline'><a href='../S/2290.html#L29327'>buffer</a>           29327 src/xterm.c    	  return xstrdup (buffer);</span>
<span class='curline'><a href='../S/2290.html#L29332'>buffer</a>           29332 src/xterm.c    	  sprintf (buffer, "_NET_WM_CM_S%d",</span>
<span class='curline'><a href='../S/2290.html#L29334'>buffer</a>           29334 src/xterm.c    	  return xstrdup (buffer);</span>
<span class='curline'><a href='../S/2335.html#L214'>buffer</a>            214 src/xwidget.c    if (NILP (xw-&gt;buffer))</span>
<span class='curline'><a href='../S/2335.html#L297'>buffer</a>            297 src/xwidget.c     Lisp_Object arguments, Lisp_Object buffer, Lisp_Object related)</span>
<span class='curline'><a href='../S/2335.html#L316'>buffer</a>            316 src/xwidget.c    xw-&gt;buffer = (NILP (buffer) ? Fcurrent_buffer ()</span>
<span class='curline'><a href='../S/2335.html#L317'>buffer</a>            317 src/xwidget.c  		: Fget_buffer_create (buffer, Qnil));</span>
<span class='curline'><a href='../S/2335.html#L467'>buffer</a>            467 src/xwidget.c  	   &amp;&amp; !NILP (XXWIDGET (object)-&gt;buffer))</span>
<span class='curline'><a href='../S/2335.html#L679'>buffer</a>            679 src/xwidget.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2335.html#L683'>buffer</a>            683 src/xwidget.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2335.html#L685'>buffer</a>            685 src/xwidget.c    buffer = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/2335.html#L686'>buffer</a>            686 src/xwidget.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2335.html#L694'>buffer</a>            694 src/xwidget.c        if (XWIDGETP (xw) &amp;&amp; EQ (Fxwidget_buffer (xw), buffer))</span>
<span class='curline'><a href='../S/2335.html#L1311'>buffer</a>           1311 src/xwidget.c    if (NILP (XXWIDGET (view-&gt;model)-&gt;buffer))</span>
<span class='curline'><a href='../S/2335.html#L1378'>buffer</a>           1378 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/2335.html#L1430'>buffer</a>           1430 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/2335.html#L1480'>buffer</a>           1480 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/2335.html#L1934'>buffer</a>           1934 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/2335.html#L2169'>buffer</a>           2169 src/xwidget.c    if (NILP (w-&gt;buffer))</span>
<span class='curline'><a href='../S/2335.html#L2201'>buffer</a>           2201 src/xwidget.c    if (NILP (w-&gt;buffer))</span>
<span class='curline'><a href='../S/2335.html#L2989'>buffer</a>           2989 src/xwidget.c    if (!NILP (xww-&gt;buffer))</span>
<span class='curline'><a href='../S/2335.html#L3009'>buffer</a>           3009 src/xwidget.c    if (!NILP (xww-&gt;buffer))</span>
<span class='curline'><a href='../S/2335.html#L3022'>buffer</a>           3022 src/xwidget.c    if (NILP (xw-&gt;buffer) || !EQ (xw-&gt;type, Qwebkit))	\</span>
<span class='curline'><a href='../S/2335.html#L3412'>buffer</a>           3412 src/xwidget.c    if (xw-&gt;embedder_view == xv &amp;&amp; !NILP (xw-&gt;buffer))</span>
<span class='curline'><a href='../S/2335.html#L3474'>buffer</a>           3474 src/xwidget.c    return XXWIDGET (xwidget)-&gt;buffer;</span>
<span class='curline'><a href='../S/2335.html#L3481'>buffer</a>           3481 src/xwidget.c    (Lisp_Object xwidget, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2335.html#L3484'>buffer</a>           3484 src/xwidget.c    CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2335.html#L3486'>buffer</a>           3486 src/xwidget.c    XXWIDGET (xwidget)-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/2335.html#L4225'>buffer</a>           4225 src/xwidget.c    xw-&gt;buffer = Qnil;</span>
<span class='curline'><a href='../S/2335.html#L4259'>buffer</a>           4259 src/xwidget.c  kill_buffer_xwidgets (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2335.html#L4262'>buffer</a>           4262 src/xwidget.c    for (tail = Fget_buffer_xwidgets (buffer); CONSP (tail); tail = XCDR (tail))</span>
<span class='curline'><a href='../S/2262.html#L61'>buffer</a>             61 src/xwidget.h    Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2262.html#L163'>buffer</a>            163 src/xwidget.h  #define XWIDGET_LIVE_P(w) (!NILP ((w)-&gt;buffer))</span>
<span class='curline'><a href='../S/4055.html#L221'>buffer</a>            221 test/manual/etags/c-src/abbrev.c   register char *buffer, *p;</span>
<span class='curline'><a href='../S/4055.html#L270'>buffer</a>            270 test/manual/etags/c-src/abbrev.c   p = buffer = (char *) alloca (wordend_byte - wordstart_byte);</span>
<span class='curline'><a href='../S/4055.html#L284'>buffer</a>            284 test/manual/etags/c-src/abbrev.c     sym = oblookup (current_buffer-&gt;abbrev_table, buffer,</span>
<span class='curline'><a href='../S/4055.html#L289'>buffer</a>            289 test/manual/etags/c-src/abbrev.c     sym = oblookup (Vglobal_abbrev_table, buffer,</span>
<span class='curline'><a href='../S/4047.html#L313'>buffer</a>            313 test/manual/etags/c-src/emacs/src/keyboard.c static void recursive_edit_unwind (Lisp_Object buffer);</span>
<span class='curline'><a href='../S/4047.html#L447'>buffer</a>            447 test/manual/etags/c-src/emacs/src/keyboard.c   char *buffer = initbuf;</span>
<span class='curline'><a href='../S/4047.html#L448'>buffer</a>            448 test/manual/etags/c-src/emacs/src/keyboard.c   char *ptr = buffer;</span>
<span class='curline'><a href='../S/4047.html#L464'>buffer</a>            464 test/manual/etags/c-src/emacs/src/keyboard.c       if (size - (ptr - buffer) &lt; nbytes)</span>
<span class='curline'><a href='../S/4047.html#L466'>buffer</a>            466 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptrdiff_t offset = ptr - buffer;</span>
<span class='curline'><a href='../S/4047.html#L468'>buffer</a>            468 test/manual/etags/c-src/emacs/src/keyboard.c 	  buffer = SAFE_ALLOCA (size);</span>
<span class='curline'><a href='../S/4047.html#L469'>buffer</a>            469 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptr = buffer + offset;</span>
<span class='curline'><a href='../S/4047.html#L482'>buffer</a>            482 test/manual/etags/c-src/emacs/src/keyboard.c       if (size - (ptr - buffer) &lt; len)</span>
<span class='curline'><a href='../S/4047.html#L484'>buffer</a>            484 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptrdiff_t offset = ptr - buffer;</span>
<span class='curline'><a href='../S/4047.html#L486'>buffer</a>            486 test/manual/etags/c-src/emacs/src/keyboard.c 	  buffer = SAFE_ALLOCA (size);</span>
<span class='curline'><a href='../S/4047.html#L487'>buffer</a>            487 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptr = buffer + offset;</span>
<span class='curline'><a href='../S/4047.html#L519'>buffer</a>            519 test/manual/etags/c-src/emacs/src/keyboard.c      concat2 (echo_string, make_string (buffer, ptr - buffer)));</span>
<span class='curline'><a href='../S/4047.html#L772'>buffer</a>            772 test/manual/etags/c-src/emacs/src/keyboard.c   Lisp_Object buffer;</span>
<span class='curline'><a href='../S/4047.html#L781'>buffer</a>            781 test/manual/etags/c-src/emacs/src/keyboard.c     buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/4047.html#L783'>buffer</a>            783 test/manual/etags/c-src/emacs/src/keyboard.c     buffer = Qnil;</span>
<span class='curline'><a href='../S/4047.html#L790'>buffer</a>            790 test/manual/etags/c-src/emacs/src/keyboard.c   record_unwind_protect (recursive_edit_unwind, buffer);</span>
<span class='curline'><a href='../S/4047.html#L804'>buffer</a>            804 test/manual/etags/c-src/emacs/src/keyboard.c recursive_edit_unwind (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/4047.html#L806'>buffer</a>            806 test/manual/etags/c-src/emacs/src/keyboard.c   if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/4047.html#L807'>buffer</a>            807 test/manual/etags/c-src/emacs/src/keyboard.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/4047.html#L1300'>buffer</a>           1300 test/manual/etags/c-src/emacs/src/keyboard.c   struct buffer *prev_buffer = NULL;</span>
<span class='curline'><a href='../S/4047.html#L1442'>buffer</a>           1442 test/manual/etags/c-src/emacs/src/keyboard.c 	  struct buffer *b;</span>
<span class='curline'><a href='../S/4047.html#L1596'>buffer</a>           1596 test/manual/etags/c-src/emacs/src/keyboard.c 		  &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer</span>
<span class='curline'><a href='../S/4047.html#L2918'>buffer</a>           2918 test/manual/etags/c-src/emacs/src/keyboard.c       struct buffer *prev_buffer = current_buffer;</span>
<span class='curline'><a href='../S/4047.html#L8981'>buffer</a>           8981 test/manual/etags/c-src/emacs/src/keyboard.c   struct buffer *starting_buffer;</span>
<span class='curline'><a href='../S/4050.html#L1027'>buffer</a>           1027 test/manual/etags/c-src/emacs/src/lisp.h INLINE struct buffer *</span>
<span class='curline'><a href='../S/4050.html#L2000'>buffer</a>           2000 test/manual/etags/c-src/emacs/src/lisp.h   struct buffer *buffer;</span>
<span class='curline'><a href='../S/4050.html#L3624'>buffer</a>           3624 test/manual/etags/c-src/emacs/src/lisp.h extern void make_gap_1 (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/4050.html#L3638'>buffer</a>           3638 test/manual/etags/c-src/emacs/src/lisp.h extern void insert_from_buffer (struct buffer *, ptrdiff_t, ptrdiff_t, bool);</span>
<span class='curline'><a href='../S/4050.html#L3655'>buffer</a>           3655 test/manual/etags/c-src/emacs/src/lisp.h extern void invalidate_buffer_caches (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/4050.html#L3884'>buffer</a>           3884 test/manual/etags/c-src/emacs/src/lisp.h extern struct buffer * allocate_buffer (void);</span>
<span class='curline'><a href='../S/4050.html#L4088'>buffer</a>           4088 test/manual/etags/c-src/emacs/src/lisp.h extern void clear_charpos_cache (struct buffer *);</span>
<span class='curline'><a href='../S/4050.html#L4089'>buffer</a>           4089 test/manual/etags/c-src/emacs/src/lisp.h extern ptrdiff_t buf_charpos_to_bytepos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/4050.html#L4090'>buffer</a>           4090 test/manual/etags/c-src/emacs/src/lisp.h extern ptrdiff_t buf_bytepos_to_charpos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/4050.html#L4096'>buffer</a>           4096 test/manual/etags/c-src/emacs/src/lisp.h extern Lisp_Object build_marker (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/4050.html#L4329'>buffer</a>           4329 test/manual/etags/c-src/emacs/src/lisp.h extern void truncate_undo_list (struct buffer *);</span>
<span class='curline'><a href='../S/4050.html#L4386'>buffer</a>           4386 test/manual/etags/c-src/emacs/src/lisp.h extern void unlock_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/4049.html#L341'>buffer</a>            341 test/manual/etags/c-src/emacs/src/regex.h   unsigned char *buffer;</span>
<span class='curline'><a href='../S/4054.html#L238'>buffer</a>            238 test/manual/etags/c-src/etags.c   char *buffer;</span>
<span class='curline'><a href='../S/4054.html#L1213'>buffer</a>           1213 test/manual/etags/c-src/etags.c 		    process_file_name (filename_lb.buffer, lang);</span>
<span class='curline'><a href='../S/4054.html#L1226'>buffer</a>           1226 test/manual/etags/c-src/etags.c   free (lb.buffer);</span>
<span class='curline'><a href='../S/4054.html#L1227'>buffer</a>           1227 test/manual/etags/c-src/etags.c   free (filebuf.buffer);</span>
<span class='curline'><a href='../S/4054.html#L1228'>buffer</a>           1228 test/manual/etags/c-src/etags.c   free (token_name.buffer);</span>
<span class='curline'><a href='../S/4054.html#L1683'>buffer</a>           1683 test/manual/etags/c-src/etags.c       &amp;&amp; lb.buffer[0] == '#'</span>
<span class='curline'><a href='../S/4054.html#L1684'>buffer</a>           1684 test/manual/etags/c-src/etags.c       &amp;&amp; lb.buffer[1] == '!')</span>
<span class='curline'><a href='../S/4054.html#L1691'>buffer</a>           1691 test/manual/etags/c-src/etags.c       lp = strrchr (lb.buffer+2, '/');</span>
<span class='curline'><a href='../S/4054.html#L1695'>buffer</a>           1695 test/manual/etags/c-src/etags.c 	lp = skip_spaces (lb.buffer + 2);</span>
<span class='curline'><a href='../S/4054.html#L2573'>buffer</a>           2573 test/manual/etags/c-src/etags.c       cn-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/4054.html#L2579'>buffer</a>           2579 test/manual/etags/c-src/etags.c       strcpy (cn-&gt;buffer, cstack.cname[0]);</span>
<span class='curline'><a href='../S/4054.html#L2587'>buffer</a>           2587 test/manual/etags/c-src/etags.c       len += sprintf (cn-&gt;buffer + len, "%s%s", qualifier, s);</span>
<span class='curline'><a href='../S/4054.html#L2803'>buffer</a>           2803 test/manual/etags/c-src/etags.c 	   memcpy (token_name.buffer, str, len);</span>
<span class='curline'><a href='../S/4054.html#L2804'>buffer</a>           2804 test/manual/etags/c-src/etags.c 	   token_name.buffer[len] = '\0';</span>
<span class='curline'><a href='../S/4054.html#L2819'>buffer</a>           2819 test/manual/etags/c-src/etags.c 	   memcpy (token_name.buffer + oldlen, str, len);</span>
<span class='curline'><a href='../S/4054.html#L2820'>buffer</a>           2820 test/manual/etags/c-src/etags.c 	   token_name.buffer[oldlen + len] = '\0';</span>
<span class='curline'><a href='../S/4054.html#L2942'>buffer</a>           2942 test/manual/etags/c-src/etags.c   lp = curlb.buffer;							\</span>
<span class='curline'><a href='../S/4054.html#L2965'>buffer</a>           2965 test/manual/etags/c-src/etags.c     make_tag (token_name.buffer, token_name.len, isfun, token.line,</span>
<span class='curline'><a href='../S/4054.html#L2969'>buffer</a>           2969 test/manual/etags/c-src/etags.c       make_tag (concat ("INVALID TOKEN:--&gt;", token_name.buffer, ""),</span>
<span class='curline'><a href='../S/4054.html#L3020'>buffer</a>           3020 test/manual/etags/c-src/etags.c   lp = curlb.buffer;</span>
<span class='curline'><a href='../S/4054.html#L3170'>buffer</a>           3170 test/manual/etags/c-src/etags.c 	      for (cp = newlb.buffer; cp &lt; lp-1; cp++)</span>
<span class='curline'><a href='../S/4054.html#L3243'>buffer</a>           3243 test/manual/etags/c-src/etags.c 			  || consider_token (newlb.buffer + tokoff, toklen, c,</span>
<span class='curline'><a href='../S/4054.html#L3268'>buffer</a>           3268 test/manual/etags/c-src/etags.c 			      sprintf (token_name.buffer + len, "%s%.*s",</span>
<span class='curline'><a href='../S/4054.html#L3269'>buffer</a>           3269 test/manual/etags/c-src/etags.c 				       qualifier, toklen, newlb.buffer + tokoff);</span>
<span class='curline'><a href='../S/4054.html#L3277'>buffer</a>           3277 test/manual/etags/c-src/etags.c 			      sprintf (token_name.buffer, "%s(%.*s)",</span>
<span class='curline'><a href='../S/4054.html#L3278'>buffer</a>           3278 test/manual/etags/c-src/etags.c 				       objtag, toklen, newlb.buffer + tokoff);</span>
<span class='curline'><a href='../S/4054.html#L3290'>buffer</a>           3290 test/manual/etags/c-src/etags.c 			      bool defun = (newlb.buffer[tokoff] == 'F');</span>
<span class='curline'><a href='../S/4054.html#L3302'>buffer</a>           3302 test/manual/etags/c-src/etags.c 			      memcpy (token_name.buffer,</span>
<span class='curline'><a href='../S/4054.html#L3303'>buffer</a>           3303 test/manual/etags/c-src/etags.c 				      newlb.buffer + off, len);</span>
<span class='curline'><a href='../S/4054.html#L3304'>buffer</a>           3304 test/manual/etags/c-src/etags.c 			      token_name.buffer[len] = '\0';</span>
<span class='curline'><a href='../S/4054.html#L3307'>buffer</a>           3307 test/manual/etags/c-src/etags.c 				  if (token_name.buffer[len] == '_')</span>
<span class='curline'><a href='../S/4054.html#L3308'>buffer</a>           3308 test/manual/etags/c-src/etags.c 				    token_name.buffer[len] = '-';</span>
<span class='curline'><a href='../S/4054.html#L3314'>buffer</a>           3314 test/manual/etags/c-src/etags.c 			      memcpy (token_name.buffer,</span>
<span class='curline'><a href='../S/4054.html#L3315'>buffer</a>           3315 test/manual/etags/c-src/etags.c 				      newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/4054.html#L3316'>buffer</a>           3316 test/manual/etags/c-src/etags.c 			      token_name.buffer[toklen] = '\0';</span>
<span class='curline'><a href='../S/4054.html#L3331'>buffer</a>           3331 test/manual/etags/c-src/etags.c 			  token.line = newlb.buffer;</span>
<span class='curline'><a href='../S/4054.html#L3402'>buffer</a>           3402 test/manual/etags/c-src/etags.c 	      if (!yacc_rules || lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/4054.html#L3404'>buffer</a>           3404 test/manual/etags/c-src/etags.c 		  tokoff = lp - 1 - newlb.buffer;</span>
<span class='curline'><a href='../S/4054.html#L3438'>buffer</a>           3438 test/manual/etags/c-src/etags.c 	      strcpy (token_name.buffer + toklen, ":");</span>
<span class='curline'><a href='../S/4054.html#L3726'>buffer</a>           3726 test/manual/etags/c-src/etags.c 	  if (!ignoreindent &amp;&amp; lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/4054.html#L3824'>buffer</a>           3824 test/manual/etags/c-src/etags.c   free (lbs[0].lb.buffer);</span>
<span class='curline'><a href='../S/4054.html#L3825'>buffer</a>           3825 test/manual/etags/c-src/etags.c   free (lbs[1].lb.buffer);</span>
<span class='curline'><a href='../S/4054.html#L3880'>buffer</a>           3880 test/manual/etags/c-src/etags.c            char_pointer = line_buffer.buffer,				\</span>
<span class='curline'><a href='../S/4054.html#L3945'>buffer</a>           3945 test/manual/etags/c-src/etags.c       dbp = lb.buffer;</span>
<span class='curline'><a href='../S/4054.html#L3956'>buffer</a>           3956 test/manual/etags/c-src/etags.c 	    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4033'>buffer</a>           4033 test/manual/etags/c-src/etags.c 			  lb.buffer, dbp - lb.buffer, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4065'>buffer</a>           4065 test/manual/etags/c-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/4054.html#L4106'>buffer</a>           4106 test/manual/etags/c-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4244'>buffer</a>           4244 test/manual/etags/c-src/etags.c 	    make_tag (lb.buffer, cp - lb.buffer, true,</span>
<span class='curline'><a href='../S/4054.html#L4245'>buffer</a>           4245 test/manual/etags/c-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4289'>buffer</a>           4289 test/manual/etags/c-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4300'>buffer</a>           4300 test/manual/etags/c-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4343'>buffer</a>           4343 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4370'>buffer</a>           4370 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4402'>buffer</a>           4402 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4415'>buffer</a>           4415 test/manual/etags/c-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4428'>buffer</a>           4428 test/manual/etags/c-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4443'>buffer</a>           4443 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4453'>buffer</a>           4453 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4484'>buffer</a>           4484 test/manual/etags/c-src/etags.c 		  lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4508'>buffer</a>           4508 test/manual/etags/c-src/etags.c 	  char * namestart = skip_spaces (lb.buffer);</span>
<span class='curline'><a href='../S/4054.html#L4513'>buffer</a>           4513 test/manual/etags/c-src/etags.c 		    lb.buffer, bp - lb.buffer + 2, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4550'>buffer</a>           4550 test/manual/etags/c-src/etags.c   dbp = lb.buffer;</span>
<span class='curline'><a href='../S/4054.html#L4567'>buffer</a>           4567 test/manual/etags/c-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/4054.html#L4649'>buffer</a>           4649 test/manual/etags/c-src/etags.c 			tline.buffer, taglen, save_lineno, save_lcno);</span>
<span class='curline'><a href='../S/4054.html#L4666'>buffer</a>           4666 test/manual/etags/c-src/etags.c 	  strcpy (tline.buffer, lb.buffer);</span>
<span class='curline'><a href='../S/4054.html#L4669'>buffer</a>           4669 test/manual/etags/c-src/etags.c 	  name = tline.buffer + (dbp - lb.buffer);</span>
<span class='curline'><a href='../S/4054.html#L4671'>buffer</a>           4671 test/manual/etags/c-src/etags.c 	  taglen = cp - lb.buffer + 1;</span>
<span class='curline'><a href='../S/4054.html#L4697'>buffer</a>           4697 test/manual/etags/c-src/etags.c   free (tline.buffer);</span>
<span class='curline'><a href='../S/4054.html#L4824'>buffer</a>           4824 test/manual/etags/c-src/etags.c 		    lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L4950'>buffer</a>           4950 test/manual/etags/c-src/etags.c 	  for (key = TEX_toktab; key-&gt;buffer != NULL; key++)</span>
<span class='curline'><a href='../S/4054.html#L4951'>buffer</a>           4951 test/manual/etags/c-src/etags.c 	    if (strneq (cp, key-&gt;buffer, key-&gt;len))</span>
<span class='curline'><a href='../S/4054.html#L4974'>buffer</a>           4974 test/manual/etags/c-src/etags.c 		    linelen = p - lb.buffer + 1;</span>
<span class='curline'><a href='../S/4054.html#L4977'>buffer</a>           4977 test/manual/etags/c-src/etags.c 			  lb.buffer, linelen, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L5053'>buffer</a>           5053 test/manual/etags/c-src/etags.c 	  TEX_toktab[i].buffer = savenstr (env, p - env);</span>
<span class='curline'><a href='../S/4054.html#L5061'>buffer</a>           5061 test/manual/etags/c-src/etags.c 	  TEX_toktab[i].buffer = NULL; /* Mark end of table. */</span>
<span class='curline'><a href='../S/4054.html#L5081'>buffer</a>           5081 test/manual/etags/c-src/etags.c 		  lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L5146'>buffer</a>           5146 test/manual/etags/c-src/etags.c 		memcpy (token_name.buffer, dbp, end - dbp);</span>
<span class='curline'><a href='../S/4054.html#L5147'>buffer</a>           5147 test/manual/etags/c-src/etags.c 		token_name.buffer[end - dbp] = '\0';</span>
<span class='curline'><a href='../S/4054.html#L5172'>buffer</a>           5172 test/manual/etags/c-src/etags.c 	    make_tag (token_name.buffer, token_name.len, true,</span>
<span class='curline'><a href='../S/4054.html#L5261'>buffer</a>           5261 test/manual/etags/c-src/etags.c       for (cp = plb-&gt;buffer; *cp != '\0'; cp++)</span>
<span class='curline'><a href='../S/4054.html#L5617'>buffer</a>           5617 test/manual/etags/c-src/etags.c 	  analyze_regex (regexbuf.buffer);</span>
<span class='curline'><a href='../S/4054.html#L5618'>buffer</a>           5618 test/manual/etags/c-src/etags.c 	free (regexbuf.buffer);</span>
<span class='curline'><a href='../S/4054.html#L5838'>buffer</a>           5838 test/manual/etags/c-src/etags.c   char *buffer = filebuf.buffer;</span>
<span class='curline'><a href='../S/4054.html#L5860'>buffer</a>           5860 test/manual/etags/c-src/etags.c 	  match = re_search (rp-&gt;pat, buffer, filebuf.len, charno,</span>
<span class='curline'><a href='../S/4054.html#L5891'>buffer</a>           5891 test/manual/etags/c-src/etags.c 		if (buffer[charno++] == '\n')</span>
<span class='curline'><a href='../S/4054.html#L5897'>buffer</a>           5897 test/manual/etags/c-src/etags.c 		name = substitute (buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/4054.html#L5900'>buffer</a>           5900 test/manual/etags/c-src/etags.c 		pfnote (name, true, buffer + linecharno,</span>
<span class='curline'><a href='../S/4054.html#L5903'>buffer</a>           5903 test/manual/etags/c-src/etags.c 		make_tag (name, strlen (name), true, buffer + linecharno,</span>
<span class='curline'><a href='../S/4054.html#L5938'>buffer</a>           5938 test/manual/etags/c-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L5961'>buffer</a>           5961 test/manual/etags/c-src/etags.c   char *buffer = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/4054.html#L5962'>buffer</a>           5962 test/manual/etags/c-src/etags.c   register char *p = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/4054.html#L5975'>buffer</a>           5975 test/manual/etags/c-src/etags.c 	  xrnew (buffer, lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/4054.html#L5976'>buffer</a>           5976 test/manual/etags/c-src/etags.c 	  p += buffer - lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/4054.html#L5977'>buffer</a>           5977 test/manual/etags/c-src/etags.c 	  pend = buffer + lbp-&gt;size;</span>
<span class='curline'><a href='../S/4054.html#L5978'>buffer</a>           5978 test/manual/etags/c-src/etags.c 	  lbp-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/4054.html#L5988'>buffer</a>           5988 test/manual/etags/c-src/etags.c 	  if (p &gt; buffer &amp;&amp; p[-1] == '\r')</span>
<span class='curline'><a href='../S/4054.html#L6011'>buffer</a>           6011 test/manual/etags/c-src/etags.c   lbp-&gt;len = p - buffer;</span>
<span class='curline'><a href='../S/4054.html#L6020'>buffer</a>           6020 test/manual/etags/c-src/etags.c 	  xrnew (filebuf.buffer, filebuf.size, char);</span>
<span class='curline'><a href='../S/4054.html#L6022'>buffer</a>           6022 test/manual/etags/c-src/etags.c       memcpy (filebuf.buffer + filebuf.len, lbp-&gt;buffer, lbp-&gt;len);</span>
<span class='curline'><a href='../S/4054.html#L6024'>buffer</a>           6024 test/manual/etags/c-src/etags.c       filebuf.buffer[filebuf.len++] = '\n';</span>
<span class='curline'><a href='../S/4054.html#L6025'>buffer</a>           6025 test/manual/etags/c-src/etags.c       filebuf.buffer[filebuf.len] = '\0';</span>
<span class='curline'><a href='../S/4054.html#L6052'>buffer</a>           6052 test/manual/etags/c-src/etags.c       if (result &gt; 12 &amp;&amp; strneq (lbp-&gt;buffer, "#line ", 6))</span>
<span class='curline'><a href='../S/4054.html#L6057'>buffer</a>           6057 test/manual/etags/c-src/etags.c 	  if (sscanf (lbp-&gt;buffer, "#line %u \"%n", &amp;lno, &amp;start) &gt;= 1</span>
<span class='curline'><a href='../S/4054.html#L6060'>buffer</a>           6060 test/manual/etags/c-src/etags.c 	      char *endp = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/4054.html#L6073'>buffer</a>           6073 test/manual/etags/c-src/etags.c 		  name = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/4054.html#L6182'>buffer</a>           6182 test/manual/etags/c-src/etags.c 	  match = re_match (rp-&gt;pat, lbp-&gt;buffer, lbp-&gt;len, 0, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/4054.html#L6211'>buffer</a>           6211 test/manual/etags/c-src/etags.c 		name = substitute (lbp-&gt;buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/4054.html#L6214'>buffer</a>           6214 test/manual/etags/c-src/etags.c 		pfnote (name, true, lbp-&gt;buffer, match, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L6217'>buffer</a>           6217 test/manual/etags/c-src/etags.c 			  lbp-&gt;buffer, match, lineno, linecharno);</span>
<span class='curline'><a href='../S/4054.html#L6517'>buffer</a>           6517 test/manual/etags/c-src/etags.c   lbp-&gt;buffer = xnew (lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/4054.html#L6518'>buffer</a>           6518 test/manual/etags/c-src/etags.c   lbp-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/4054.html#L6529'>buffer</a>           6529 test/manual/etags/c-src/etags.c       xrnew (lbp-&gt;buffer, lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/4044.html#L119'>buffer</a>            119 test/manual/etags/c-src/h.h struct re_pattern_buffer { unsigned char *buffer; };</span>
<span class='curline'><a href='../S/4071.html#L88'>buffer</a>             88 test/manual/etags/objc-src/PackInsp.h -subprocess:(Subprocess *)sender output:(char *)buffer;</span>
<span class='curline'><a href='../S/4184.html#L729'>buffer</a>            729 test/src/emacs-module-resources/mod-test.c   char *buffer = length == 0 ? NULL : malloc (length);</span>
<span class='curline'><a href='../S/4184.html#L730'>buffer</a>            730 test/src/emacs-module-resources/mod-test.c   if (buffer == NULL &amp;&amp; length != 0)</span>
<span class='curline'><a href='../S/4184.html#L735'>buffer</a>            735 test/src/emacs-module-resources/mod-test.c   memset (buffer, 'a', length);</span>
<span class='curline'><a href='../S/4184.html#L736'>buffer</a>            736 test/src/emacs-module-resources/mod-test.c   emacs_value ret = multibyte ? env-&gt;make_string (env, buffer, length)</span>
<span class='curline'><a href='../S/4184.html#L737'>buffer</a>            737 test/src/emacs-module-resources/mod-test.c                               : env-&gt;make_unibyte_string (env, buffer, length);</span>
<span class='curline'><a href='../S/4184.html#L738'>buffer</a>            738 test/src/emacs-module-resources/mod-test.c   free (buffer);</span>
</pre>
</body>
</html>
