<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>buffer</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.7' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/42.html#L3563'>buffer</a>           3563 lib-src/ebrowse.c   static char *buffer;</span>
<span class='curline'><a href='../S/42.html#L3577'>buffer</a>           3577 lib-src/ebrowse.c 	  buffer = (char *) xrealloc (buffer, buffer_size);</span>
<span class='curline'><a href='../S/42.html#L3580'>buffer</a>           3580 lib-src/ebrowse.c       char *z = stpcpy (buffer, path-&gt;path);</span>
<span class='curline'><a href='../S/42.html#L3583'>buffer</a>           3583 lib-src/ebrowse.c       fp = fopen (buffer, "r");</span>
<span class='curline'><a href='../S/42.html#L3706'>buffer</a>           3706 lib-src/ebrowse.c   static char *buffer;</span>
<span class='curline'><a href='../S/42.html#L3715'>buffer</a>           3715 lib-src/ebrowse.c 	  buffer = (char *) xrealloc (buffer, buffer_size);</span>
<span class='curline'><a href='../S/42.html#L3718'>buffer</a>           3718 lib-src/ebrowse.c       buffer[i++] = c;</span>
<span class='curline'><a href='../S/42.html#L3727'>buffer</a>           3727 lib-src/ebrowse.c       buffer = (char *) xrealloc (buffer, buffer_size);</span>
<span class='curline'><a href='../S/42.html#L3730'>buffer</a>           3730 lib-src/ebrowse.c   buffer[i] = '\0';</span>
<span class='curline'><a href='../S/42.html#L3731'>buffer</a>           3731 lib-src/ebrowse.c   if (i &gt; 0 &amp;&amp; buffer[i - 1] == '\r')</span>
<span class='curline'><a href='../S/42.html#L3732'>buffer</a>           3732 lib-src/ebrowse.c     buffer[i - 1] = '\0';</span>
<span class='curline'><a href='../S/42.html#L3733'>buffer</a>           3733 lib-src/ebrowse.c   return buffer;</span>
<span class='curline'><a href='../S/37.html#L377'>buffer</a>            377 lib-src/emacsclient.c 	  char *buffer = xmalloc (size);</span>
<span class='curline'><a href='../S/37.html#L378'>buffer</a>            378 lib-src/emacsclient.c 	  if (ExpandEnvironmentStrings (value, buffer, size))</span>
<span class='curline'><a href='../S/37.html#L382'>buffer</a>            382 lib-src/emacsclient.c 	      return buffer;</span>
<span class='curline'><a href='../S/37.html#L386'>buffer</a>            386 lib-src/emacsclient.c 	  free (buffer);</span>
<span class='curline'><a href='../S/39.html#L309'>buffer</a>            309 lib-src/etags.c   char *buffer;</span>
<span class='curline'><a href='../S/39.html#L1341'>buffer</a>           1341 lib-src/etags.c 		    process_file_name (filename_lb.buffer, lang);</span>
<span class='curline'><a href='../S/39.html#L1356'>buffer</a>           1356 lib-src/etags.c   free (lb.buffer);</span>
<span class='curline'><a href='../S/39.html#L1357'>buffer</a>           1357 lib-src/etags.c   free (filebuf.buffer);</span>
<span class='curline'><a href='../S/39.html#L1358'>buffer</a>           1358 lib-src/etags.c   free (token_name.buffer);</span>
<span class='curline'><a href='../S/39.html#L1470'>buffer</a>           1470 lib-src/etags.c       if (strstr (line.buffer, buf) == NULL)</span>
<span class='curline'><a href='../S/39.html#L1472'>buffer</a>           1472 lib-src/etags.c           fprintf (otags_f, "%s\n", line.buffer);</span>
<span class='curline'><a href='../S/39.html#L1478'>buffer</a>           1478 lib-src/etags.c   free (line.buffer);</span>
<span class='curline'><a href='../S/39.html#L1886'>buffer</a>           1886 lib-src/etags.c       &amp;&amp; lb.buffer[0] == '#'</span>
<span class='curline'><a href='../S/39.html#L1887'>buffer</a>           1887 lib-src/etags.c       &amp;&amp; lb.buffer[1] == '!')</span>
<span class='curline'><a href='../S/39.html#L1894'>buffer</a>           1894 lib-src/etags.c       lp = strrchr (lb.buffer+2, '/');</span>
<span class='curline'><a href='../S/39.html#L1898'>buffer</a>           1898 lib-src/etags.c 	lp = skip_spaces (lb.buffer + 2);</span>
<span class='curline'><a href='../S/39.html#L2951'>buffer</a>           2951 lib-src/etags.c       cn-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/39.html#L2957'>buffer</a>           2957 lib-src/etags.c       strcpy (cn-&gt;buffer, cstack.cname[0]);</span>
<span class='curline'><a href='../S/39.html#L2967'>buffer</a>           2967 lib-src/etags.c       memcpyz (stpcpy (cn-&gt;buffer + len, qualifier), s, slen);</span>
<span class='curline'><a href='../S/39.html#L3202'>buffer</a>           3202 lib-src/etags.c 	   memcpyz (token_name.buffer, str, len);</span>
<span class='curline'><a href='../S/39.html#L3219'>buffer</a>           3219 lib-src/etags.c 	       memcpyz (token_name.buffer + oldlen, str, len);</span>
<span class='curline'><a href='../S/39.html#L3350'>buffer</a>           3350 lib-src/etags.c   lp = curlb.buffer;							\</span>
<span class='curline'><a href='../S/39.html#L3373'>buffer</a>           3373 lib-src/etags.c     make_tag (token_name.buffer, token_name.len, isfun, token.line,</span>
<span class='curline'><a href='../S/39.html#L3377'>buffer</a>           3377 lib-src/etags.c       make_tag (concat ("INVALID TOKEN:--&gt;", token_name.buffer, ""),</span>
<span class='curline'><a href='../S/39.html#L3433'>buffer</a>           3433 lib-src/etags.c   lp = curlb.buffer;</span>
<span class='curline'><a href='../S/39.html#L3583'>buffer</a>           3583 lib-src/etags.c 	      for (cp = newlb.buffer; cp &lt; lp-1; cp++)</span>
<span class='curline'><a href='../S/39.html#L3657'>buffer</a>           3657 lib-src/etags.c 			  || consider_token (newlb.buffer + tokoff, toklen, c,</span>
<span class='curline'><a href='../S/39.html#L3684'>buffer</a>           3684 lib-src/etags.c 				  memcpyz (stpcpy (token_name.buffer + len,</span>
<span class='curline'><a href='../S/39.html#L3686'>buffer</a>           3686 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/39.html#L3691'>buffer</a>           3691 lib-src/etags.c 				  memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/39.html#L3692'>buffer</a>           3692 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/39.html#L3703'>buffer</a>           3703 lib-src/etags.c 				  char *p1 = stpcpy (token_name.buffer, objtag);</span>
<span class='curline'><a href='../S/39.html#L3705'>buffer</a>           3705 lib-src/etags.c 				  char *p3 = mempcpy (p2, newlb.buffer + tokoff,</span>
<span class='curline'><a href='../S/39.html#L3712'>buffer</a>           3712 lib-src/etags.c 				  memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/39.html#L3713'>buffer</a>           3713 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/39.html#L3726'>buffer</a>           3726 lib-src/etags.c 			      bool defun = (newlb.buffer[tokoff] == 'F');</span>
<span class='curline'><a href='../S/39.html#L3737'>buffer</a>           3737 lib-src/etags.c 				  memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/39.html#L3738'>buffer</a>           3738 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/39.html#L3743'>buffer</a>           3743 lib-src/etags.c 				  token.line = newlb.buffer;</span>
<span class='curline'><a href='../S/39.html#L3751'>buffer</a>           3751 lib-src/etags.c 			      memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/39.html#L3752'>buffer</a>           3752 lib-src/etags.c 				       newlb.buffer + off, len);</span>
<span class='curline'><a href='../S/39.html#L3755'>buffer</a>           3755 lib-src/etags.c 				  if (token_name.buffer[len] == '_')</span>
<span class='curline'><a href='../S/39.html#L3756'>buffer</a>           3756 lib-src/etags.c 				    token_name.buffer[len] = '-';</span>
<span class='curline'><a href='../S/39.html#L3762'>buffer</a>           3762 lib-src/etags.c 			      memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/39.html#L3763'>buffer</a>           3763 lib-src/etags.c 				       newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/39.html#L3778'>buffer</a>           3778 lib-src/etags.c 			  token.line = newlb.buffer;</span>
<span class='curline'><a href='../S/39.html#L3853'>buffer</a>           3853 lib-src/etags.c 	      if (!yacc_rules || lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/39.html#L3855'>buffer</a>           3855 lib-src/etags.c 		  tokoff = lp - 1 - newlb.buffer;</span>
<span class='curline'><a href='../S/39.html#L3891'>buffer</a>           3891 lib-src/etags.c 		  strcpy (token_name.buffer + toklen, ":");</span>
<span class='curline'><a href='../S/39.html#L4147'>buffer</a>           4147 lib-src/etags.c 		  char *cc, *uqname = token_name.buffer;</span>
<span class='curline'><a href='../S/39.html#L4148'>buffer</a>           4148 lib-src/etags.c 		  char *tok_end = token_name.buffer + token_name.len;</span>
<span class='curline'><a href='../S/39.html#L4150'>buffer</a>           4150 lib-src/etags.c 		  for (cc = token_name.buffer; cc &lt; tok_end; cc++)</span>
<span class='curline'><a href='../S/39.html#L4158'>buffer</a>           4158 lib-src/etags.c 		  if (uqname &gt; token_name.buffer)</span>
<span class='curline'><a href='../S/39.html#L4162'>buffer</a>           4162 lib-src/etags.c 		      memmove (token_name.buffer, uqname, uqlen + 1);</span>
<span class='curline'><a href='../S/39.html#L4225'>buffer</a>           4225 lib-src/etags.c 	  if (!ignoreindent &amp;&amp; lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/39.html#L4323'>buffer</a>           4323 lib-src/etags.c   free (lbs[0].lb.buffer);</span>
<span class='curline'><a href='../S/39.html#L4324'>buffer</a>           4324 lib-src/etags.c   free (lbs[1].lb.buffer);</span>
<span class='curline'><a href='../S/39.html#L4377'>buffer</a>           4377 lib-src/etags.c 	     (char_pointer) = (line_buffer).buffer,			\</span>
<span class='curline'><a href='../S/39.html#L4441'>buffer</a>           4441 lib-src/etags.c       dbp = lb.buffer;</span>
<span class='curline'><a href='../S/39.html#L4452'>buffer</a>           4452 lib-src/etags.c 	    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L4529'>buffer</a>           4529 lib-src/etags.c 			  lb.buffer, dbp - lb.buffer, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L4557'>buffer</a>           4557 lib-src/etags.c 	  make_tag (name, cp - name, false, lb.buffer,</span>
<span class='curline'><a href='../S/39.html#L4558'>buffer</a>           4558 lib-src/etags.c 		    cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L4580'>buffer</a>           4580 lib-src/etags.c 	      make_tag (name, cp - name, true, lb.buffer,</span>
<span class='curline'><a href='../S/39.html#L4581'>buffer</a>           4581 lib-src/etags.c 			cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L4599'>buffer</a>           4599 lib-src/etags.c 	  make_tag (name, cp - name, false, lb.buffer,</span>
<span class='curline'><a href='../S/39.html#L4600'>buffer</a>           4600 lib-src/etags.c 		    cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L4628'>buffer</a>           4628 lib-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/39.html#L4668'>buffer</a>           4668 lib-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L4806'>buffer</a>           4806 lib-src/etags.c 	    make_tag (lb.buffer, cp - lb.buffer, true,</span>
<span class='curline'><a href='../S/39.html#L4807'>buffer</a>           4807 lib-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L4861'>buffer</a>           4861 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L4873'>buffer</a>           4873 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L4878'>buffer</a>           4878 lib-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L4919'>buffer</a>           4919 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L4946'>buffer</a>           4946 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L4989'>buffer</a>           4989 lib-src/etags.c 			    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L5030'>buffer</a>           5030 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L5072'>buffer</a>           5072 lib-src/etags.c 				  lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/39.html#L5082'>buffer</a>           5082 lib-src/etags.c 			pfnote (wr_name, true, lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/39.html#L5086'>buffer</a>           5086 lib-src/etags.c 				   curfdp-&gt;taggedfname, lineno, lb.buffer);</span>
<span class='curline'><a href='../S/39.html#L5093'>buffer</a>           5093 lib-src/etags.c 				    lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/39.html#L5158'>buffer</a>           5158 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/39.html#L5192'>buffer</a>           5192 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L5205'>buffer</a>           5205 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L5218'>buffer</a>           5218 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L5233'>buffer</a>           5233 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L5243'>buffer</a>           5243 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L5274'>buffer</a>           5274 lib-src/etags.c 		  lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L5298'>buffer</a>           5298 lib-src/etags.c 	  char * namestart = skip_spaces (lb.buffer);</span>
<span class='curline'><a href='../S/39.html#L5303'>buffer</a>           5303 lib-src/etags.c 		    lb.buffer, bp - lb.buffer + 2, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L5340'>buffer</a>           5340 lib-src/etags.c   dbp = lb.buffer;</span>
<span class='curline'><a href='../S/39.html#L5357'>buffer</a>           5357 lib-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/39.html#L5439'>buffer</a>           5439 lib-src/etags.c 			tline.buffer, taglen, save_lineno, save_lcno);</span>
<span class='curline'><a href='../S/39.html#L5456'>buffer</a>           5456 lib-src/etags.c 	  strcpy (tline.buffer, lb.buffer);</span>
<span class='curline'><a href='../S/39.html#L5459'>buffer</a>           5459 lib-src/etags.c 	  name = tline.buffer + (dbp - lb.buffer);</span>
<span class='curline'><a href='../S/39.html#L5461'>buffer</a>           5461 lib-src/etags.c 	  taglen = cp - lb.buffer + 1;</span>
<span class='curline'><a href='../S/39.html#L5487'>buffer</a>           5487 lib-src/etags.c   free (tline.buffer);</span>
<span class='curline'><a href='../S/39.html#L5630'>buffer</a>           5630 lib-src/etags.c 		    lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L5686'>buffer</a>           5686 lib-src/etags.c 		      true, lb.buffer, name_end - lb.buffer,</span>
<span class='curline'><a href='../S/39.html#L5796'>buffer</a>           5796 lib-src/etags.c 	  for (key = TEX_toktab; key-&gt;buffer != NULL; key++)</span>
<span class='curline'><a href='../S/39.html#L5797'>buffer</a>           5797 lib-src/etags.c 	    if (strneq (cp, key-&gt;buffer, key-&gt;len))</span>
<span class='curline'><a href='../S/39.html#L5820'>buffer</a>           5820 lib-src/etags.c 		    linelen = p - lb.buffer + 1;</span>
<span class='curline'><a href='../S/39.html#L5823'>buffer</a>           5823 lib-src/etags.c 			  lb.buffer, linelen, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L5867'>buffer</a>           5867 lib-src/etags.c 	  TEX_toktab[i].buffer = savenstr (env, p - env);</span>
<span class='curline'><a href='../S/39.html#L5875'>buffer</a>           5875 lib-src/etags.c 	  TEX_toktab[i].buffer = NULL; /* Mark end of table. */</span>
<span class='curline'><a href='../S/39.html#L5895'>buffer</a>           5895 lib-src/etags.c 		  lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L5960'>buffer</a>           5960 lib-src/etags.c 		memcpyz (token_name.buffer, dbp, end - dbp);</span>
<span class='curline'><a href='../S/39.html#L5985'>buffer</a>           5985 lib-src/etags.c 	    make_tag (token_name.buffer, token_name.len, true,</span>
<span class='curline'><a href='../S/39.html#L6073'>buffer</a>           6073 lib-src/etags.c       for (cp = plb-&gt;buffer; *cp != '\0'; cp++)</span>
<span class='curline'><a href='../S/39.html#L6394'>buffer</a>           6394 lib-src/etags.c       for (cp = plb-&gt;buffer; *cp != '\0'; ++cp)</span>
<span class='curline'><a href='../S/39.html#L6932'>buffer</a>           6932 lib-src/etags.c 	  analyze_regex (regexbuf.buffer);</span>
<span class='curline'><a href='../S/39.html#L6933'>buffer</a>           6933 lib-src/etags.c 	free (regexbuf.buffer);</span>
<span class='curline'><a href='../S/39.html#L7152'>buffer</a>           7152 lib-src/etags.c   char *buffer = filebuf.buffer;</span>
<span class='curline'><a href='../S/39.html#L7174'>buffer</a>           7174 lib-src/etags.c 	  match = re_search (rp-&gt;pat, buffer, filebuf.len, charno,</span>
<span class='curline'><a href='../S/39.html#L7205'>buffer</a>           7205 lib-src/etags.c 		if (buffer[charno++] == '\n')</span>
<span class='curline'><a href='../S/39.html#L7211'>buffer</a>           7211 lib-src/etags.c 		name = substitute (buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/39.html#L7214'>buffer</a>           7214 lib-src/etags.c 	      pfnote (name, true, buffer + linecharno,</span>
<span class='curline'><a href='../S/39.html#L7220'>buffer</a>           7220 lib-src/etags.c 			 lineno, buffer + linecharno);</span>
<span class='curline'><a href='../S/39.html#L7254'>buffer</a>           7254 lib-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L7273'>buffer</a>           7273 lib-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L7296'>buffer</a>           7296 lib-src/etags.c   char *buffer = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/39.html#L7297'>buffer</a>           7297 lib-src/etags.c   char *p = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/39.html#L7309'>buffer</a>           7309 lib-src/etags.c 	  xrnew (buffer, lbp-&gt;size, 2);</span>
<span class='curline'><a href='../S/39.html#L7310'>buffer</a>           7310 lib-src/etags.c 	  p = buffer + lbp-&gt;size;</span>
<span class='curline'><a href='../S/39.html#L7312'>buffer</a>           7312 lib-src/etags.c 	  pend = buffer + lbp-&gt;size;</span>
<span class='curline'><a href='../S/39.html#L7313'>buffer</a>           7313 lib-src/etags.c 	  lbp-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/39.html#L7325'>buffer</a>           7325 lib-src/etags.c           if (!leave_cr &amp;&amp; p &gt; buffer &amp;&amp; p[-1] == '\r')</span>
<span class='curline'><a href='../S/39.html#L7339'>buffer</a>           7339 lib-src/etags.c   lbp-&gt;len = p - buffer;</span>
<span class='curline'><a href='../S/39.html#L7347'>buffer</a>           7347 lib-src/etags.c 	  xrnew (filebuf.buffer, filebuf.size, 2);</span>
<span class='curline'><a href='../S/39.html#L7350'>buffer</a>           7350 lib-src/etags.c       strcpy (mempcpy (filebuf.buffer + filebuf.len, lbp-&gt;buffer, lbp-&gt;len),</span>
<span class='curline'><a href='../S/39.html#L7377'>buffer</a>           7377 lib-src/etags.c       if (result &gt; 12 &amp;&amp; strneq (lbp-&gt;buffer, "#line ", 6))</span>
<span class='curline'><a href='../S/39.html#L7382'>buffer</a>           7382 lib-src/etags.c 	  if (sscanf (lbp-&gt;buffer, "#line %"SCNdMAX" \"%n", &amp;lno, &amp;start) &gt;= 1</span>
<span class='curline'><a href='../S/39.html#L7385'>buffer</a>           7385 lib-src/etags.c 	      char *endp = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/39.html#L7398'>buffer</a>           7398 lib-src/etags.c 		  name = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/39.html#L7507'>buffer</a>           7507 lib-src/etags.c 	  match = re_match (rp-&gt;pat, lbp-&gt;buffer, lbp-&gt;len, 0, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/39.html#L7536'>buffer</a>           7536 lib-src/etags.c 		name = substitute (lbp-&gt;buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/39.html#L7539'>buffer</a>           7539 lib-src/etags.c 	      pfnote (name, true, lbp-&gt;buffer, match, lineno, linecharno);</span>
<span class='curline'><a href='../S/39.html#L7544'>buffer</a>           7544 lib-src/etags.c 			 lineno, lbp-&gt;buffer);</span>
<span class='curline'><a href='../S/39.html#L7998'>buffer</a>           7998 lib-src/etags.c   lbp-&gt;buffer = xnew (lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/39.html#L7999'>buffer</a>           7999 lib-src/etags.c   lbp-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/39.html#L8010'>buffer</a>           8010 lib-src/etags.c       xrnew (lbp-&gt;buffer, lbp-&gt;size, multiplier);</span>
<span class='curline'><a href='../S/29.html#L267'>buffer</a>            267 lib-src/pop.c    server-&gt;buffer = (char *) malloc (GETLINE_MIN);</span>
<span class='curline'><a href='../S/29.html#L268'>buffer</a>            268 lib-src/pop.c    if (! server-&gt;buffer)</span>
<span class='curline'><a href='../S/29.html#L950'>buffer</a>            950 lib-src/pop.c    free (server-&gt;buffer);</span>
<span class='curline'><a href='../S/29.html#L1237'>buffer</a>           1237 lib-src/pop.c        char *cp = find_crlf (server-&gt;buffer + server-&gt;buffer_index,</span>
<span class='curline'><a href='../S/29.html#L1245'>buffer</a>           1245 lib-src/pop.c  	  data_used = (cp + 2) - server-&gt;buffer - found;</span>
<span class='curline'><a href='../S/29.html#L1254'>buffer</a>           1254 lib-src/pop.c  	    fprintf (stderr, "&lt;&lt;&lt; %s\n", server-&gt;buffer + found);</span>
<span class='curline'><a href='../S/29.html#L1255'>buffer</a>           1255 lib-src/pop.c  	  *line = server-&gt;buffer + found;</span>
<span class='curline'><a href='../S/29.html#L1260'>buffer</a>           1260 lib-src/pop.c  	  memmove (server-&gt;buffer, server-&gt;buffer + server-&gt;buffer_index,</span>
<span class='curline'><a href='../S/29.html#L1286'>buffer</a>           1286 lib-src/pop.c  	  server-&gt;buffer = (char *)realloc (server-&gt;buffer, server-&gt;buffer_size);</span>
<span class='curline'><a href='../S/29.html#L1287'>buffer</a>           1287 lib-src/pop.c  	  if (! server-&gt;buffer)</span>
<span class='curline'><a href='../S/29.html#L1294'>buffer</a>           1294 lib-src/pop.c        ret = RECV (server-&gt;file, server-&gt;buffer + server-&gt;data,</span>
<span class='curline'><a href='../S/29.html#L1313'>buffer</a>           1313 lib-src/pop.c  	  server-&gt;buffer[server-&gt;data] = '\0';</span>
<span class='curline'><a href='../S/29.html#L1315'>buffer</a>           1315 lib-src/pop.c  	  cp = find_crlf (server-&gt;buffer + search_offset,</span>
<span class='curline'><a href='../S/29.html#L1319'>buffer</a>           1319 lib-src/pop.c  	      int data_used = (cp + 2) - server-&gt;buffer;</span>
<span class='curline'><a href='../S/29.html#L1325'>buffer</a>           1325 lib-src/pop.c  		fprintf (stderr, "&lt;&lt;&lt; %s\n", server-&gt;buffer);</span>
<span class='curline'><a href='../S/29.html#L1326'>buffer</a>           1326 lib-src/pop.c  	      *line = server-&gt;buffer;</span>
<span class='curline'><a href='../S/29.html#L1531'>buffer</a>           1531 lib-src/pop.c        if (server-&gt;buffer)</span>
<span class='curline'><a href='../S/29.html#L1533'>buffer</a>           1533 lib-src/pop.c  	  free (server-&gt;buffer);</span>
<span class='curline'><a href='../S/29.html#L1534'>buffer</a>           1534 lib-src/pop.c  	  server-&gt;buffer = 0;</span>
<span class='curline'><a href='../S/40.html#L35'>buffer</a>             35 lib-src/pop.h    char *buffer;</span>
<span class='curline'><a href='../S/2243.html#L61'>buffer</a>             61 lib/af_alg.h   afalg_buffer (const char *buffer, size_t len, const char *alg,</span>
<span class='curline'><a href='../S/2243.html#L96'>buffer</a>             96 lib/af_alg.h   afalg_buffer (const char *buffer, size_t len, const char *alg,</span>
<span class='curline'><a href='../S/2164.html#L66'>buffer</a>             66 lib/careadlinkat.c               char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2164.html#L74'>buffer</a>             74 lib/careadlinkat.c   if (!buffer)</span>
<span class='curline'><a href='../S/2164.html#L76'>buffer</a>             76 lib/careadlinkat.c       buffer = stack_buf;</span>
<span class='curline'><a href='../S/2164.html#L80'>buffer</a>             80 lib/careadlinkat.c   char *buf = buffer;</span>
<span class='curline'><a href='../S/2164.html#L90'>buffer</a>             90 lib/careadlinkat.c           if (buf != buffer)</span>
<span class='curline'><a href='../S/2164.html#L114'>buffer</a>            114 lib/careadlinkat.c           if (link_size &lt; buf_size &amp;&amp; buf != buffer &amp;&amp; alloc-&gt;reallocate)</span>
<span class='curline'><a href='../S/2164.html#L125'>buffer</a>            125 lib/careadlinkat.c       if (buf != buffer)</span>
<span class='curline'><a href='../S/2164.html#L169'>buffer</a>            169 lib/careadlinkat.c               char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2164.html#L182'>buffer</a>            182 lib/careadlinkat.c   return readlink_stk (fd, filename, buffer, buffer_size, alloc,</span>
<span class='curline'><a href='../S/2236.html#L50'>buffer</a>             50 lib/careadlinkat.h                     char *restrict buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2141.html#L32'>buffer</a>             32 lib/execinfo.in.h backtrace (void **buffer, int size)</span>
<span class='curline'><a href='../S/2141.html#L34'>buffer</a>             34 lib/execinfo.in.h   (void) buffer;</span>
<span class='curline'><a href='../S/2141.html#L40'>buffer</a>             40 lib/execinfo.in.h backtrace_symbols (void *const *buffer, int size)</span>
<span class='curline'><a href='../S/2141.html#L42'>buffer</a>             42 lib/execinfo.in.h   (void) buffer;</span>
<span class='curline'><a href='../S/2141.html#L48'>buffer</a>             48 lib/execinfo.in.h backtrace_symbols_fd (void *const *buffer, int size, int fd)</span>
<span class='curline'><a href='../S/2141.html#L50'>buffer</a>             50 lib/execinfo.in.h   (void) buffer;</span>
<span class='curline'><a href='../S/2252.html#L112'>buffer</a>            112 lib/getrandom.c getrandom (void *buffer, size_t length, unsigned int flags)</span>
<span class='curline'><a href='../S/2252.html#L128'>buffer</a>            128 lib/getrandom.c           &amp;&amp; BCryptGenRandomFunc (NULL, buffer, length,</span>
<span class='curline'><a href='../S/2252.html#L153'>buffer</a>            153 lib/getrandom.c         if (!CryptGenRandom (provider, length, buffer))</span>
<span class='curline'><a href='../S/2252.html#L165'>buffer</a>            165 lib/getrandom.c   return getrandom (buffer, length, flags);</span>
<span class='curline'><a href='../S/2252.html#L188'>buffer</a>            188 lib/getrandom.c   return read (fd, buffer, length);</span>
<span class='curline'><a href='../S/2334.html#L75'>buffer</a>             75 lib/malloc/scratch_buffer.h scratch_buffer_init (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2334.html#L77'>buffer</a>             77 lib/malloc/scratch_buffer.h   buffer-&gt;data = buffer-&gt;__space.__c;</span>
<span class='curline'><a href='../S/2334.html#L78'>buffer</a>             78 lib/malloc/scratch_buffer.h   buffer-&gt;length = sizeof (buffer-&gt;__space);</span>
<span class='curline'><a href='../S/2334.html#L83'>buffer</a>             83 lib/malloc/scratch_buffer.h scratch_buffer_free (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2334.html#L85'>buffer</a>             85 lib/malloc/scratch_buffer.h   if (buffer-&gt;data != buffer-&gt;__space.__c)</span>
<span class='curline'><a href='../S/2334.html#L86'>buffer</a>             86 lib/malloc/scratch_buffer.h     free (buffer-&gt;data);</span>
<span class='curline'><a href='../S/2334.html#L94'>buffer</a>             94 lib/malloc/scratch_buffer.h bool __libc_scratch_buffer_grow (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2334.html#L99'>buffer</a>             99 lib/malloc/scratch_buffer.h scratch_buffer_grow (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2334.html#L101'>buffer</a>            101 lib/malloc/scratch_buffer.h   return __glibc_likely (__libc_scratch_buffer_grow (buffer));</span>
<span class='curline'><a href='../S/2334.html#L106'>buffer</a>            106 lib/malloc/scratch_buffer.h bool __libc_scratch_buffer_grow_preserve (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2334.html#L111'>buffer</a>            111 lib/malloc/scratch_buffer.h scratch_buffer_grow_preserve (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2334.html#L113'>buffer</a>            113 lib/malloc/scratch_buffer.h   return __glibc_likely (__libc_scratch_buffer_grow_preserve (buffer));</span>
<span class='curline'><a href='../S/2334.html#L122'>buffer</a>            122 lib/malloc/scratch_buffer.h bool __libc_scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2334.html#L128'>buffer</a>            128 lib/malloc/scratch_buffer.h scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2334.html#L132'>buffer</a>            132 lib/malloc/scratch_buffer.h 			 (buffer, nelem, size));</span>
<span class='curline'><a href='../S/2335.html#L27'>buffer</a>             27 lib/malloc/scratch_buffer_dupfree.c __libc_scratch_buffer_dupfree (struct scratch_buffer *buffer, size_t size)</span>
<span class='curline'><a href='../S/2335.html#L29'>buffer</a>             29 lib/malloc/scratch_buffer_dupfree.c   void *data = buffer-&gt;data;</span>
<span class='curline'><a href='../S/2335.html#L30'>buffer</a>             30 lib/malloc/scratch_buffer_dupfree.c   if (data == buffer-&gt;__space.__c)</span>
<span class='curline'><a href='../S/2331.html#L27'>buffer</a>             27 lib/malloc/scratch_buffer_grow.c __libc_scratch_buffer_grow (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2331.html#L30'>buffer</a>             30 lib/malloc/scratch_buffer_grow.c   size_t new_length = buffer-&gt;length * 2;</span>
<span class='curline'><a href='../S/2331.html#L33'>buffer</a>             33 lib/malloc/scratch_buffer_grow.c   scratch_buffer_free (buffer);</span>
<span class='curline'><a href='../S/2331.html#L36'>buffer</a>             36 lib/malloc/scratch_buffer_grow.c   if (__glibc_likely (new_length &gt;= buffer-&gt;length))</span>
<span class='curline'><a href='../S/2331.html#L47'>buffer</a>             47 lib/malloc/scratch_buffer_grow.c       scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2331.html#L52'>buffer</a>             52 lib/malloc/scratch_buffer_grow.c   buffer-&gt;data = new_ptr;</span>
<span class='curline'><a href='../S/2331.html#L53'>buffer</a>             53 lib/malloc/scratch_buffer_grow.c   buffer-&gt;length = new_length;</span>
<span class='curline'><a href='../S/2330.html#L28'>buffer</a>             28 lib/malloc/scratch_buffer_grow_preserve.c __libc_scratch_buffer_grow_preserve (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2330.html#L30'>buffer</a>             30 lib/malloc/scratch_buffer_grow_preserve.c   size_t new_length = 2 * buffer-&gt;length;</span>
<span class='curline'><a href='../S/2330.html#L33'>buffer</a>             33 lib/malloc/scratch_buffer_grow_preserve.c   if (buffer-&gt;data == buffer-&gt;__space.__c)</span>
<span class='curline'><a href='../S/2330.html#L40'>buffer</a>             40 lib/malloc/scratch_buffer_grow_preserve.c       memcpy (new_ptr, buffer-&gt;__space.__c, buffer-&gt;length);</span>
<span class='curline'><a href='../S/2330.html#L45'>buffer</a>             45 lib/malloc/scratch_buffer_grow_preserve.c       if (__glibc_likely (new_length &gt;= buffer-&gt;length))</span>
<span class='curline'><a href='../S/2330.html#L46'>buffer</a>             46 lib/malloc/scratch_buffer_grow_preserve.c 	new_ptr = realloc (buffer-&gt;data, new_length);</span>
<span class='curline'><a href='../S/2330.html#L56'>buffer</a>             56 lib/malloc/scratch_buffer_grow_preserve.c 	  free (buffer-&gt;data);</span>
<span class='curline'><a href='../S/2330.html#L57'>buffer</a>             57 lib/malloc/scratch_buffer_grow_preserve.c 	  scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2330.html#L63'>buffer</a>             63 lib/malloc/scratch_buffer_grow_preserve.c   buffer-&gt;data = new_ptr;</span>
<span class='curline'><a href='../S/2330.html#L64'>buffer</a>             64 lib/malloc/scratch_buffer_grow_preserve.c   buffer-&gt;length = new_length;</span>
<span class='curline'><a href='../S/2332.html#L28'>buffer</a>             28 lib/malloc/scratch_buffer_set_array_size.c __libc_scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2332.html#L39'>buffer</a>             39 lib/malloc/scratch_buffer_set_array_size.c       scratch_buffer_free (buffer);</span>
<span class='curline'><a href='../S/2332.html#L40'>buffer</a>             40 lib/malloc/scratch_buffer_set_array_size.c       scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2332.html#L45'>buffer</a>             45 lib/malloc/scratch_buffer_set_array_size.c   if (new_length &lt;= buffer-&gt;length)</span>
<span class='curline'><a href='../S/2332.html#L49'>buffer</a>             49 lib/malloc/scratch_buffer_set_array_size.c   scratch_buffer_free (buffer);</span>
<span class='curline'><a href='../S/2332.html#L55'>buffer</a>             55 lib/malloc/scratch_buffer_set_array_size.c       scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2332.html#L60'>buffer</a>             60 lib/malloc/scratch_buffer_set_array_size.c   buffer-&gt;data = new_ptr;</span>
<span class='curline'><a href='../S/2332.html#L61'>buffer</a>             61 lib/malloc/scratch_buffer_set_array_size.c   buffer-&gt;length = new_length;</span>
<span class='curline'><a href='../S/2320.html#L69'>buffer</a>             69 lib/md5-stream.c   char *buffer = malloc (BLOCKSIZE + 72);</span>
<span class='curline'><a href='../S/2320.html#L70'>buffer</a>             70 lib/md5-stream.c   if (!buffer)</span>
<span class='curline'><a href='../S/2320.html#L97'>buffer</a>             97 lib/md5-stream.c           n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);</span>
<span class='curline'><a href='../S/2320.html#L111'>buffer</a>            111 lib/md5-stream.c                   free (buffer);</span>
<span class='curline'><a href='../S/2320.html#L121'>buffer</a>            121 lib/md5-stream.c       md5_process_block (buffer, BLOCKSIZE, &amp;ctx);</span>
<span class='curline'><a href='../S/2320.html#L128'>buffer</a>            128 lib/md5-stream.c     md5_process_bytes (buffer, sum, &amp;ctx);</span>
<span class='curline'><a href='../S/2320.html#L132'>buffer</a>            132 lib/md5-stream.c   free (buffer);</span>
<span class='curline'><a href='../S/2149.html#L115'>buffer</a>            115 lib/md5.c        ctx-&gt;buffer[size - 2] = SWAP (ctx-&gt;total[0] &lt;&lt; 3);</span>
<span class='curline'><a href='../S/2149.html#L116'>buffer</a>            116 lib/md5.c        ctx-&gt;buffer[size - 1] = SWAP ((ctx-&gt;total[1] &lt;&lt; 3) | (ctx-&gt;total[0] &gt;&gt; 29));</span>
<span class='curline'><a href='../S/2149.html#L118'>buffer</a>            118 lib/md5.c        memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);</span>
<span class='curline'><a href='../S/2149.html#L121'>buffer</a>            121 lib/md5.c        md5_process_block (ctx-&gt;buffer, size * 4, ctx);</span>
<span class='curline'><a href='../S/2149.html#L131'>buffer</a>            131 lib/md5.c      md5_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2149.html#L139'>buffer</a>            139 lib/md5.c        md5_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2149.html#L147'>buffer</a>            147 lib/md5.c      md5_process_bytes (const void *buffer, size_t len, struct md5_ctx *ctx)</span>
<span class='curline'><a href='../S/2149.html#L156'>buffer</a>            156 lib/md5.c            memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2149.html#L161'>buffer</a>            161 lib/md5.c                md5_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2149.html#L166'>buffer</a>            166 lib/md5.c                memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2149.html#L167'>buffer</a>            167 lib/md5.c                        &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~63],</span>
<span class='curline'><a href='../S/2149.html#L171'>buffer</a>            171 lib/md5.c            buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2149.html#L180'>buffer</a>            180 lib/md5.c            if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2149.html#L183'>buffer</a>            183 lib/md5.c                  md5_process_block (memcpy (ctx-&gt;buffer, buffer, 64), 64, ctx);</span>
<span class='curline'><a href='../S/2149.html#L184'>buffer</a>            184 lib/md5.c                  buffer = (const char *) buffer + 64;</span>
<span class='curline'><a href='../S/2149.html#L190'>buffer</a>            190 lib/md5.c                md5_process_block (buffer, len &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2149.html#L191'>buffer</a>            191 lib/md5.c                buffer = (const char *) buffer + (len &amp; ~63);</span>
<span class='curline'><a href='../S/2149.html#L201'>buffer</a>            201 lib/md5.c            memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2149.html#L205'>buffer</a>            205 lib/md5.c                md5_process_block (ctx-&gt;buffer, 64, ctx);</span>
<span class='curline'><a href='../S/2149.html#L209'>buffer</a>            209 lib/md5.c                memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2149.html#L229'>buffer</a>            229 lib/md5.c      md5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)</span>
<span class='curline'><a href='../S/2149.html#L232'>buffer</a>            232 lib/md5.c        const uint32_t *words = buffer;</span>
<span class='curline'><a href='../S/2259.html#L81'>buffer</a>             81 lib/md5.h        uint32_t buffer[32]; /* 128 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2259.html#L97'>buffer</a>             97 lib/md5.h      extern void __md5_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2259.html#L104'>buffer</a>            104 lib/md5.h      extern void __md5_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2259.html#L126'>buffer</a>            126 lib/md5.h      extern void *__md5_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2159.html#L253'>buffer</a>            253 lib/regcomp.c    re_dfa_t *dfa = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2159.html#L284'>buffer</a>            284 lib/regcomp.c    re_dfa_t *dfa = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2159.html#L445'>buffer</a>            445 lib/regcomp.c    preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2159.html#L609'>buffer</a>            609 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2159.html#L615'>buffer</a>            615 lib/regcomp.c    preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2159.html#L649'>buffer</a>            649 lib/regcomp.c        if (!re_comp_buf.buffer)</span>
<span class='curline'><a href='../S/2159.html#L654'>buffer</a>            654 lib/regcomp.c    if (re_comp_buf.buffer)</span>
<span class='curline'><a href='../S/2159.html#L717'>buffer</a>            717 lib/regcomp.c    dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2159.html#L724'>buffer</a>            724 lib/regcomp.c        dfa = re_realloc (preg-&gt;buffer, re_dfa_t, 1);</span>
<span class='curline'><a href='../S/2159.html#L728'>buffer</a>            728 lib/regcomp.c        preg-&gt;buffer = dfa;</span>
<span class='curline'><a href='../S/2159.html#L738'>buffer</a>            738 lib/regcomp.c        preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2159.html#L757'>buffer</a>            757 lib/regcomp.c        preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2159.html#L788'>buffer</a>            788 lib/regcomp.c        preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2159.html#L944'>buffer</a>            944 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2159.html#L1127'>buffer</a>           1127 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2159.html#L1308'>buffer</a>           1308 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2159.html#L2084'>buffer</a>           2084 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2159.html#L2118'>buffer</a>           2118 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2159.html#L2168'>buffer</a>           2168 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2159.html#L2212'>buffer</a>           2212 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2159.html#L2444'>buffer</a>           2444 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2176.html#L417'>buffer</a>            417 lib/regex.h      struct re_dfa_t *__REPB_PREFIX(buffer);</span>
<span class='curline'><a href='../S/2305.html#L192'>buffer</a>            192 lib/regexec.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2305.html#L372'>buffer</a>            372 lib/regexec.c    re_dfa_t *dfa = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2305.html#L585'>buffer</a>            585 lib/regexec.c    const re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2305.html#L1368'>buffer</a>           1368 lib/regexec.c    const re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2316.html#L67'>buffer</a>             67 lib/scratch_buffer.h extern void scratch_buffer_init (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2316.html#L72'>buffer</a>             72 lib/scratch_buffer.h extern void scratch_buffer_free (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2316.html#L81'>buffer</a>             81 lib/scratch_buffer.h extern bool scratch_buffer_grow (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2316.html#L87'>buffer</a>             87 lib/scratch_buffer.h extern bool scratch_buffer_grow_preserve (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2316.html#L97'>buffer</a>             97 lib/scratch_buffer.h extern bool scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2270.html#L105'>buffer</a>            105 lib/sha1.c       ctx-&gt;buffer[size - 2] = SWAP ((ctx-&gt;total[1] &lt;&lt; 3) | (ctx-&gt;total[0] &gt;&gt; 29));</span>
<span class='curline'><a href='../S/2270.html#L106'>buffer</a>            106 lib/sha1.c       ctx-&gt;buffer[size - 1] = SWAP (ctx-&gt;total[0] &lt;&lt; 3);</span>
<span class='curline'><a href='../S/2270.html#L108'>buffer</a>            108 lib/sha1.c       memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);</span>
<span class='curline'><a href='../S/2270.html#L111'>buffer</a>            111 lib/sha1.c       sha1_process_block (ctx-&gt;buffer, size * 4, ctx);</span>
<span class='curline'><a href='../S/2270.html#L121'>buffer</a>            121 lib/sha1.c     sha1_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2270.html#L129'>buffer</a>            129 lib/sha1.c       sha1_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2270.html#L136'>buffer</a>            136 lib/sha1.c     sha1_process_bytes (const void *buffer, size_t len, struct sha1_ctx *ctx)</span>
<span class='curline'><a href='../S/2270.html#L145'>buffer</a>            145 lib/sha1.c           memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2270.html#L150'>buffer</a>            150 lib/sha1.c               sha1_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2270.html#L155'>buffer</a>            155 lib/sha1.c               memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2270.html#L156'>buffer</a>            156 lib/sha1.c                       &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~63],</span>
<span class='curline'><a href='../S/2270.html#L160'>buffer</a>            160 lib/sha1.c           buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2270.html#L169'>buffer</a>            169 lib/sha1.c           if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2270.html#L172'>buffer</a>            172 lib/sha1.c                 sha1_process_block (memcpy (ctx-&gt;buffer, buffer, 64), 64, ctx);</span>
<span class='curline'><a href='../S/2270.html#L173'>buffer</a>            173 lib/sha1.c                 buffer = (const char *) buffer + 64;</span>
<span class='curline'><a href='../S/2270.html#L179'>buffer</a>            179 lib/sha1.c               sha1_process_block (buffer, len &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2270.html#L180'>buffer</a>            180 lib/sha1.c               buffer = (const char *) buffer + (len &amp; ~63);</span>
<span class='curline'><a href='../S/2270.html#L190'>buffer</a>            190 lib/sha1.c           memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2270.html#L194'>buffer</a>            194 lib/sha1.c               sha1_process_block (ctx-&gt;buffer, 64, ctx);</span>
<span class='curline'><a href='../S/2270.html#L198'>buffer</a>            198 lib/sha1.c               memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2270.html#L223'>buffer</a>            223 lib/sha1.c     sha1_process_block (const void *buffer, size_t len, struct sha1_ctx *ctx)</span>
<span class='curline'><a href='../S/2270.html#L225'>buffer</a>            225 lib/sha1.c       const uint32_t *words = buffer;</span>
<span class='curline'><a href='../S/2301.html#L53'>buffer</a>             53 lib/sha1.h       uint32_t buffer[32]; /* 128 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2301.html#L63'>buffer</a>             63 lib/sha1.h     extern void sha1_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2301.html#L70'>buffer</a>             70 lib/sha1.h     extern void sha1_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2301.html#L90'>buffer</a>             90 lib/sha1.h     extern void *sha1_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2155.html#L137'>buffer</a>            137 lib/sha256.c     set_uint32 ((char *) &amp;ctx-&gt;buffer[size - 2],</span>
<span class='curline'><a href='../S/2155.html#L139'>buffer</a>            139 lib/sha256.c     set_uint32 ((char *) &amp;ctx-&gt;buffer[size - 1],</span>
<span class='curline'><a href='../S/2155.html#L142'>buffer</a>            142 lib/sha256.c     memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);</span>
<span class='curline'><a href='../S/2155.html#L145'>buffer</a>            145 lib/sha256.c     sha256_process_block (ctx-&gt;buffer, size * 4, ctx);</span>
<span class='curline'><a href='../S/2155.html#L167'>buffer</a>            167 lib/sha256.c   sha256_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2155.html#L175'>buffer</a>            175 lib/sha256.c     sha256_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2155.html#L182'>buffer</a>            182 lib/sha256.c   sha224_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2155.html#L190'>buffer</a>            190 lib/sha256.c     sha256_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2155.html#L197'>buffer</a>            197 lib/sha256.c   sha256_process_bytes (const void *buffer, size_t len, struct sha256_ctx *ctx)</span>
<span class='curline'><a href='../S/2155.html#L206'>buffer</a>            206 lib/sha256.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2155.html#L211'>buffer</a>            211 lib/sha256.c             sha256_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2155.html#L216'>buffer</a>            216 lib/sha256.c             memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2155.html#L217'>buffer</a>            217 lib/sha256.c                     &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~63],</span>
<span class='curline'><a href='../S/2155.html#L221'>buffer</a>            221 lib/sha256.c         buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2155.html#L230'>buffer</a>            230 lib/sha256.c         if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2155.html#L233'>buffer</a>            233 lib/sha256.c               sha256_process_block (memcpy (ctx-&gt;buffer, buffer, 64), 64, ctx);</span>
<span class='curline'><a href='../S/2155.html#L234'>buffer</a>            234 lib/sha256.c               buffer = (const char *) buffer + 64;</span>
<span class='curline'><a href='../S/2155.html#L240'>buffer</a>            240 lib/sha256.c             sha256_process_block (buffer, len &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2155.html#L241'>buffer</a>            241 lib/sha256.c             buffer = (const char *) buffer + (len &amp; ~63);</span>
<span class='curline'><a href='../S/2155.html#L251'>buffer</a>            251 lib/sha256.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2155.html#L255'>buffer</a>            255 lib/sha256.c             sha256_process_block (ctx-&gt;buffer, 64, ctx);</span>
<span class='curline'><a href='../S/2155.html#L259'>buffer</a>            259 lib/sha256.c             memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2155.html#L297'>buffer</a>            297 lib/sha256.c   sha256_process_block (const void *buffer, size_t len, struct sha256_ctx *ctx)</span>
<span class='curline'><a href='../S/2155.html#L299'>buffer</a>            299 lib/sha256.c     const uint32_t *words = buffer;</span>
<span class='curline'><a href='../S/2272.html#L51'>buffer</a>             51 lib/sha256.h     uint32_t buffer[32]; /* 128 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2272.html#L62'>buffer</a>             62 lib/sha256.h   extern void sha256_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2272.html#L69'>buffer</a>             69 lib/sha256.h   extern void sha256_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2272.html#L93'>buffer</a>             93 lib/sha256.h   extern void *sha256_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2272.html#L95'>buffer</a>             95 lib/sha256.h   extern void *sha224_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2309.html#L137'>buffer</a>            137 lib/sha512.c     set_uint64 ((char *) &amp;ctx-&gt;buffer[size - 2],</span>
<span class='curline'><a href='../S/2309.html#L140'>buffer</a>            140 lib/sha512.c     set_uint64 ((char *) &amp;ctx-&gt;buffer[size - 1],</span>
<span class='curline'><a href='../S/2309.html#L143'>buffer</a>            143 lib/sha512.c     memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 8 - bytes);</span>
<span class='curline'><a href='../S/2309.html#L146'>buffer</a>            146 lib/sha512.c     sha512_process_block (ctx-&gt;buffer, size * 8, ctx);</span>
<span class='curline'><a href='../S/2309.html#L168'>buffer</a>            168 lib/sha512.c   sha512_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2309.html#L176'>buffer</a>            176 lib/sha512.c     sha512_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2309.html#L183'>buffer</a>            183 lib/sha512.c   sha384_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2309.html#L191'>buffer</a>            191 lib/sha512.c     sha512_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2309.html#L198'>buffer</a>            198 lib/sha512.c   sha512_process_bytes (const void *buffer, size_t len, struct sha512_ctx *ctx)</span>
<span class='curline'><a href='../S/2309.html#L207'>buffer</a>            207 lib/sha512.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2309.html#L212'>buffer</a>            212 lib/sha512.c             sha512_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~127, ctx);</span>
<span class='curline'><a href='../S/2309.html#L217'>buffer</a>            217 lib/sha512.c             memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2309.html#L218'>buffer</a>            218 lib/sha512.c                     &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~127],</span>
<span class='curline'><a href='../S/2309.html#L222'>buffer</a>            222 lib/sha512.c         buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2309.html#L231'>buffer</a>            231 lib/sha512.c         if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2309.html#L234'>buffer</a>            234 lib/sha512.c               sha512_process_block (memcpy (ctx-&gt;buffer, buffer, 128), 128, ctx);</span>
<span class='curline'><a href='../S/2309.html#L235'>buffer</a>            235 lib/sha512.c               buffer = (const char *) buffer + 128;</span>
<span class='curline'><a href='../S/2309.html#L241'>buffer</a>            241 lib/sha512.c             sha512_process_block (buffer, len &amp; ~127, ctx);</span>
<span class='curline'><a href='../S/2309.html#L242'>buffer</a>            242 lib/sha512.c             buffer = (const char *) buffer + (len &amp; ~127);</span>
<span class='curline'><a href='../S/2309.html#L252'>buffer</a>            252 lib/sha512.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2309.html#L256'>buffer</a>            256 lib/sha512.c             sha512_process_block (ctx-&gt;buffer, 128, ctx);</span>
<span class='curline'><a href='../S/2309.html#L260'>buffer</a>            260 lib/sha512.c             memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2309.html#L322'>buffer</a>            322 lib/sha512.c   sha512_process_block (const void *buffer, size_t len, struct sha512_ctx *ctx)</span>
<span class='curline'><a href='../S/2309.html#L324'>buffer</a>            324 lib/sha512.c     u64 const *words = buffer;</span>
<span class='curline'><a href='../S/2283.html#L51'>buffer</a>             51 lib/sha512.h     u64 buffer[32]; /* 256 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2283.html#L62'>buffer</a>             62 lib/sha512.h   extern void sha512_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2283.html#L69'>buffer</a>             69 lib/sha512.h   extern void sha512_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2283.html#L96'>buffer</a>             96 lib/sha512.h   extern void *sha512_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2283.html#L98'>buffer</a>             98 lib/sha512.h   extern void *sha384_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2250.html#L74'>buffer</a>             74 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags)</span>
<span class='curline'><a href='../S/2250.html#L77'>buffer</a>             77 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags));</span>
<span class='curline'><a href='../S/2250.html#L81'>buffer</a>             81 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags)</span>
<span class='curline'><a href='../S/2250.html#L85'>buffer</a>             85 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags));</span>
<span class='curline'><a href='../S/2262.html#L1189'>buffer</a>           1189 lib/unistd.in.h _GL_FUNCDECL_SYS (getentropy, int, (void *buffer, size_t length));</span>
<span class='curline'><a href='../S/2262.html#L1191'>buffer</a>           1191 lib/unistd.in.h _GL_CXXALIAS_SYS (getentropy, int, (void *buffer, size_t length));</span>
<span class='curline'><a href='../S/3888.html#L43'>buffer</a>             43 nt/cmdproxy.c  extern int _snprintf (char *buffer, size_t count, const char *format, ...);</span>
<span class='curline'><a href='../S/3888.html#L284'>buffer</a>            284 nt/cmdproxy.c  search_dir (const char *dir, const char *exec, int bufsize, char *buffer)</span>
<span class='curline'><a href='../S/3888.html#L307'>buffer</a>            307 nt/cmdproxy.c        rc = SearchPath (dir, exec_ext, NULL, bufsize, buffer, &amp;dummy);</span>
<span class='curline'><a href='../S/3888.html#L315'>buffer</a>            315 nt/cmdproxy.c  	  rc = SearchPath (dir, exec_ext, NULL, bufsize, buffer, &amp;dummy);</span>
<span class='curline'><a href='../S/3888.html#L324'>buffer</a>            324 nt/cmdproxy.c  	  rc = SearchPath (dir, exec, exts[i], bufsize, buffer, &amp;dummy);</span>
<span class='curline'><a href='../S/105.html#L443'>buffer</a>            443 src/alloc.c    static void mark_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/105.html#L3169'>buffer</a>           3169 src/alloc.c          eassert (! PSEUDOVEC_STRUCT (vector, Lisp_Marker)-&gt;buffer);</span>
<span class='curline'><a href='../S/105.html#L3424'>buffer</a>           3424 src/alloc.c    struct buffer *</span>
<span class='curline'><a href='../S/105.html#L3427'>buffer</a>           3427 src/alloc.c      struct buffer *b</span>
<span class='curline'><a href='../S/105.html#L3428'>buffer</a>           3428 src/alloc.c        = ALLOCATE_PSEUDOVECTOR (struct buffer, cursor_in_non_selected_windows_,</span>
<span class='curline'><a href='../S/105.html#L3728'>buffer</a>           3728 src/alloc.c      p-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/105.html#L3739'>buffer</a>           3739 src/alloc.c      p-&gt;buffer = 0;</span>
<span class='curline'><a href='../S/105.html#L3752'>buffer</a>           3752 src/alloc.c    build_marker (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t bytepos)</span>
<span class='curline'><a href='../S/105.html#L3762'>buffer</a>           3762 src/alloc.c      m-&gt;buffer = buf;</span>
<span class='curline'><a href='../S/105.html#L5954'>buffer</a>           5954 src/alloc.c                       struct buffer *buffer,</span>
<span class='curline'><a href='../S/105.html#L5959'>buffer</a>           5959 src/alloc.c      eassert (buffer-&gt;base_buffer == NULL);</span>
<span class='curline'><a href='../S/105.html#L5960'>buffer</a>           5960 src/alloc.c      eassert (buffer-&gt;overlays == NULL);</span>
<span class='curline'><a href='../S/105.html#L5963'>buffer</a>           5963 src/alloc.c      visit_vectorlike_root (visitor, (struct Lisp_Vector *) buffer, type);</span>
<span class='curline'><a href='../S/105.html#L6117'>buffer</a>           6117 src/alloc.c      Lisp_Object tail, buffer;</span>
<span class='curline'><a href='../S/105.html#L6135'>buffer</a>           6135 src/alloc.c      FOR_EACH_LIVE_BUFFER (tail, buffer)</span>
<span class='curline'><a href='../S/105.html#L6136'>buffer</a>           6136 src/alloc.c        compact_buffer (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/105.html#L6237'>buffer</a>           6237 src/alloc.c      FOR_EACH_LIVE_BUFFER (tail, buffer)</span>
<span class='curline'><a href='../S/105.html#L6239'>buffer</a>           6239 src/alloc.c          struct buffer *nextb = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/105.html#L6379'>buffer</a>           6379 src/alloc.c        list3 (Qbuffers, make_fixnum (sizeof (struct buffer)),</span>
<span class='curline'><a href='../S/105.html#L6540'>buffer</a>           6540 src/alloc.c    mark_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/105.html#L6543'>buffer</a>           6543 src/alloc.c      mark_vectorlike (&amp;buffer-&gt;header);</span>
<span class='curline'><a href='../S/105.html#L6547'>buffer</a>           6547 src/alloc.c      mark_interval_tree (buffer_intervals (buffer));</span>
<span class='curline'><a href='../S/105.html#L6555'>buffer</a>           6555 src/alloc.c      if (!BUFFER_LIVE_P (buffer))</span>
<span class='curline'><a href='../S/105.html#L6556'>buffer</a>           6556 src/alloc.c          mark_object (BVAR (buffer, undo_list));</span>
<span class='curline'><a href='../S/105.html#L6558'>buffer</a>           6558 src/alloc.c      if (buffer-&gt;overlays)</span>
<span class='curline'><a href='../S/105.html#L6559'>buffer</a>           6559 src/alloc.c        mark_overlays (buffer-&gt;overlays-&gt;root);</span>
<span class='curline'><a href='../S/105.html#L6562'>buffer</a>           6562 src/alloc.c      if (buffer-&gt;base_buffer &amp;&amp;</span>
<span class='curline'><a href='../S/105.html#L6563'>buffer</a>           6563 src/alloc.c          !vectorlike_marked_p (&amp;buffer-&gt;base_buffer-&gt;header))</span>
<span class='curline'><a href='../S/105.html#L6564'>buffer</a>           6564 src/alloc.c        mark_buffer (buffer-&gt;base_buffer);</span>
<span class='curline'><a href='../S/105.html#L6880'>buffer</a>           6880 src/alloc.c    		mark_buffer ((struct buffer *) ptr);</span>
<span class='curline'><a href='../S/105.html#L7389'>buffer</a>           7389 src/alloc.c    unchain_dead_markers (struct buffer *buffer)</span>
<span class='curline'><a href='../S/105.html#L7391'>buffer</a>           7391 src/alloc.c      struct Lisp_Marker *this, **prev = &amp;BUF_MARKERS (buffer);</span>
<span class='curline'><a href='../S/105.html#L7398'>buffer</a>           7398 src/alloc.c            this-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/105.html#L7412'>buffer</a>           7412 src/alloc.c          struct buffer *buffer = XBUFFER (buf);</span>
<span class='curline'><a href='../S/105.html#L7414'>buffer</a>           7414 src/alloc.c          buffer-&gt;text-&gt;intervals = balance_intervals (buffer-&gt;text-&gt;intervals);</span>
<span class='curline'><a href='../S/105.html#L7415'>buffer</a>           7415 src/alloc.c          unchain_dead_markers (buffer);</span>
<span class='curline'><a href='../S/278.html#L1496'>buffer</a>           1496 src/bidi.c       struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/278.html#L1557'>buffer</a>           1557 src/bidi.c       struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/272.html#L60'>buffer</a>             60 src/buffer.c   struct buffer buffer_defaults;</span>
<span class='curline'><a href='../S/272.html#L79'>buffer</a>             79 src/buffer.c   struct buffer buffer_local_flags;</span>
<span class='curline'><a href='../S/272.html#L84'>buffer</a>             84 src/buffer.c   struct buffer buffer_local_symbols;</span>
<span class='curline'><a href='../S/272.html#L108'>buffer</a>            108 src/buffer.c   static void reset_buffer_local_variables (struct buffer *, bool);</span>
<span class='curline'><a href='../S/272.html#L117'>buffer</a>            117 src/buffer.c   static void alloc_buffer_text (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/272.html#L118'>buffer</a>            118 src/buffer.c   static void free_buffer_text (struct buffer *b);</span>
<span class='curline'><a href='../S/272.html#L119'>buffer</a>            119 src/buffer.c   static void copy_overlays (struct buffer *, struct buffer *);</span>
<span class='curline'><a href='../S/272.html#L120'>buffer</a>            120 src/buffer.c   static void modify_overlay (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/272.html#L121'>buffer</a>            121 src/buffer.c   static Lisp_Object buffer_lisp_local_variables (struct buffer *, bool);</span>
<span class='curline'><a href='../S/272.html#L122'>buffer</a>            122 src/buffer.c   static Lisp_Object buffer_local_variables_1 (struct buffer *buf, int offset, Lisp_Object sym);</span>
<span class='curline'><a href='../S/272.html#L150'>buffer</a>            150 src/buffer.c   bset_abbrev_mode (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L155'>buffer</a>            155 src/buffer.c   bset_abbrev_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L160'>buffer</a>            160 src/buffer.c   bset_auto_fill_function (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L165'>buffer</a>            165 src/buffer.c   bset_auto_save_file_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L170'>buffer</a>            170 src/buffer.c   bset_auto_save_file_name (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L175'>buffer</a>            175 src/buffer.c   bset_backed_up (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L180'>buffer</a>            180 src/buffer.c   bset_begv_marker (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L185'>buffer</a>            185 src/buffer.c   bset_bidi_display_reordering (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L190'>buffer</a>            190 src/buffer.c   bset_bidi_paragraph_start_re (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L195'>buffer</a>            195 src/buffer.c   bset_bidi_paragraph_separate_re (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L200'>buffer</a>            200 src/buffer.c   bset_buffer_file_coding_system (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L205'>buffer</a>            205 src/buffer.c   bset_case_fold_search (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L210'>buffer</a>            210 src/buffer.c   bset_ctl_arrow (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L215'>buffer</a>            215 src/buffer.c   bset_cursor_in_non_selected_windows (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L220'>buffer</a>            220 src/buffer.c   bset_cursor_type (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L225'>buffer</a>            225 src/buffer.c   bset_display_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L230'>buffer</a>            230 src/buffer.c   bset_extra_line_spacing (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L236'>buffer</a>            236 src/buffer.c   bset_ts_parser_list (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L242'>buffer</a>            242 src/buffer.c   bset_file_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L247'>buffer</a>            247 src/buffer.c   bset_file_truename (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L252'>buffer</a>            252 src/buffer.c   bset_fringe_cursor_alist (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L257'>buffer</a>            257 src/buffer.c   bset_fringe_indicator_alist (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L262'>buffer</a>            262 src/buffer.c   bset_fringes_outside_margins (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L267'>buffer</a>            267 src/buffer.c   bset_header_line_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L272'>buffer</a>            272 src/buffer.c   bset_tab_line_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L277'>buffer</a>            277 src/buffer.c   bset_indicate_buffer_boundaries (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L282'>buffer</a>            282 src/buffer.c   bset_indicate_empty_lines (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L287'>buffer</a>            287 src/buffer.c   bset_invisibility_spec (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L292'>buffer</a>            292 src/buffer.c   bset_left_fringe_width (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L297'>buffer</a>            297 src/buffer.c   bset_major_mode (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L302'>buffer</a>            302 src/buffer.c   bset_local_minor_modes (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L307'>buffer</a>            307 src/buffer.c   bset_mark (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L312'>buffer</a>            312 src/buffer.c   bset_mode_line_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L317'>buffer</a>            317 src/buffer.c   bset_mode_name (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L322'>buffer</a>            322 src/buffer.c   bset_name (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L327'>buffer</a>            327 src/buffer.c   bset_overwrite_mode (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L332'>buffer</a>            332 src/buffer.c   bset_pt_marker (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L337'>buffer</a>            337 src/buffer.c   bset_right_fringe_width (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L342'>buffer</a>            342 src/buffer.c   bset_save_length (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L347'>buffer</a>            347 src/buffer.c   bset_scroll_bar_width (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L352'>buffer</a>            352 src/buffer.c   bset_scroll_bar_height (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L357'>buffer</a>            357 src/buffer.c   bset_scroll_down_aggressively (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L362'>buffer</a>            362 src/buffer.c   bset_scroll_up_aggressively (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L367'>buffer</a>            367 src/buffer.c   bset_selective_display (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L372'>buffer</a>            372 src/buffer.c   bset_selective_display_ellipses (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L377'>buffer</a>            377 src/buffer.c   bset_vertical_scroll_bar_type (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L382'>buffer</a>            382 src/buffer.c   bset_horizontal_scroll_bar_type (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L387'>buffer</a>            387 src/buffer.c   bset_word_wrap (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L392'>buffer</a>            392 src/buffer.c   bset_zv_marker (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/272.html#L532'>buffer</a>            532 src/buffer.c   run_buffer_list_update_hook (struct buffer *buf)</span>
<span class='curline'><a href='../S/272.html#L556'>buffer</a>            556 src/buffer.c     register Lisp_Object buffer, name;</span>
<span class='curline'><a href='../S/272.html#L557'>buffer</a>            557 src/buffer.c     register struct buffer *b;</span>
<span class='curline'><a href='../S/272.html#L559'>buffer</a>            559 src/buffer.c     buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/272.html#L560'>buffer</a>            560 src/buffer.c     if (!NILP (buffer))</span>
<span class='curline'><a href='../S/272.html#L561'>buffer</a>            561 src/buffer.c       return buffer;</span>
<span class='curline'><a href='../S/272.html#L639'>buffer</a>            639 src/buffer.c     XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/272.html#L640'>buffer</a>            640 src/buffer.c     Vbuffer_alist = nconc2 (Vbuffer_alist, list1 (Fcons (name, buffer)));</span>
<span class='curline'><a href='../S/272.html#L644'>buffer</a>            644 src/buffer.c     return buffer;</span>
<span class='curline'><a href='../S/272.html#L648'>buffer</a>            648 src/buffer.c   add_buffer_overlay (struct buffer *b, struct Lisp_Overlay *ov,</span>
<span class='curline'><a href='../S/272.html#L651'>buffer</a>            651 src/buffer.c     eassert (! ov-&gt;buffer);</span>
<span class='curline'><a href='../S/272.html#L654'>buffer</a>            654 src/buffer.c     ov-&gt;buffer = b;</span>
<span class='curline'><a href='../S/272.html#L661'>buffer</a>            661 src/buffer.c   copy_overlays (struct buffer *from, struct buffer *to)</span>
<span class='curline'><a href='../S/272.html#L690'>buffer</a>            690 src/buffer.c   clone_per_buffer_values (struct buffer *from, struct buffer *to)</span>
<span class='curline'><a href='../S/272.html#L703'>buffer</a>            703 src/buffer.c         if (MARKERP (obj) &amp;&amp; XMARKER (obj)-&gt;buffer == from)</span>
<span class='curline'><a href='../S/272.html#L728'>buffer</a>            728 src/buffer.c   record_buffer_markers (struct buffer *b)</span>
<span class='curline'><a href='../S/272.html#L732'>buffer</a>            732 src/buffer.c         Lisp_Object buffer;</span>
<span class='curline'><a href='../S/272.html#L737'>buffer</a>            737 src/buffer.c         XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/272.html#L738'>buffer</a>            738 src/buffer.c         set_marker_both (BVAR (b, pt_marker), buffer, b-&gt;pt, b-&gt;pt_byte);</span>
<span class='curline'><a href='../S/272.html#L739'>buffer</a>            739 src/buffer.c         set_marker_both (BVAR (b, begv_marker), buffer, b-&gt;begv, b-&gt;begv_byte);</span>
<span class='curline'><a href='../S/272.html#L740'>buffer</a>            740 src/buffer.c         set_marker_both (BVAR (b, zv_marker), buffer, b-&gt;zv, b-&gt;zv_byte);</span>
<span class='curline'><a href='../S/272.html#L749'>buffer</a>            749 src/buffer.c   fetch_buffer_markers (struct buffer *b)</span>
<span class='curline'><a href='../S/272.html#L789'>buffer</a>            789 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/272.html#L889'>buffer</a>            889 src/buffer.c         struct buffer *old_b = current_buffer;</span>
<span class='curline'><a href='../S/272.html#L916'>buffer</a>            916 src/buffer.c   remove_buffer_overlay (struct buffer *b, struct Lisp_Overlay *ov)</span>
<span class='curline'><a href='../S/272.html#L919'>buffer</a>            919 src/buffer.c     eassert (ov-&gt;buffer == b);</span>
<span class='curline'><a href='../S/272.html#L920'>buffer</a>            920 src/buffer.c     itree_remove (ov-&gt;buffer-&gt;overlays, ov-&gt;interval);</span>
<span class='curline'><a href='../S/272.html#L921'>buffer</a>            921 src/buffer.c     ov-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/272.html#L929'>buffer</a>            929 src/buffer.c     if (! ov-&gt;buffer)</span>
<span class='curline'><a href='../S/272.html#L932'>buffer</a>            932 src/buffer.c     modify_overlay (ov-&gt;buffer, overlay_start (ov), overlay_end (ov));</span>
<span class='curline'><a href='../S/272.html#L933'>buffer</a>            933 src/buffer.c     remove_buffer_overlay (ov-&gt;buffer, ov);</span>
<span class='curline'><a href='../S/272.html#L939'>buffer</a>            939 src/buffer.c   delete_all_overlays (struct buffer *b)</span>
<span class='curline'><a href='../S/272.html#L952'>buffer</a>            952 src/buffer.c         XOVERLAY (node-&gt;data)-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/272.html#L961'>buffer</a>            961 src/buffer.c   free_buffer_overlays (struct buffer *b)</span>
<span class='curline'><a href='../S/272.html#L1036'>buffer</a>           1036 src/buffer.c   reset_buffer (register struct buffer *b)</span>
<span class='curline'><a href='../S/272.html#L1083'>buffer</a>           1083 src/buffer.c   reset_buffer_local_variables (struct buffer *b, bool permanent_too)</span>
<span class='curline'><a href='../S/272.html#L1114'>buffer</a>           1114 src/buffer.c         Lisp_Object buffer;</span>
<span class='curline'><a href='../S/272.html#L1115'>buffer</a>           1115 src/buffer.c         XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/272.html#L1131'>buffer</a>           1131 src/buffer.c             if (BASE_EQ (SYMBOL_BLV (XSYMBOL (sym))-&gt;where, buffer))</span>
<span class='curline'><a href='../S/272.html#L1252'>buffer</a>           1252 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L1254'>buffer</a>           1254 src/buffer.c     return BVAR (decode_buffer (buffer), name);</span>
<span class='curline'><a href='../S/272.html#L1260'>buffer</a>           1260 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L1262'>buffer</a>           1262 src/buffer.c     return BVAR (decode_buffer (buffer), filename);</span>
<span class='curline'><a href='../S/272.html#L1270'>buffer</a>           1270 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L1272'>buffer</a>           1272 src/buffer.c     struct buffer *base = decode_buffer (buffer)-&gt;base_buffer;</span>
<span class='curline'><a href='../S/272.html#L1273'>buffer</a>           1273 src/buffer.c     return base ? (XSETBUFFER (buffer, base), buffer) : Qnil;</span>
<span class='curline'><a href='../S/272.html#L1281'>buffer</a>           1281 src/buffer.c     (register Lisp_Object variable, register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L1283'>buffer</a>           1283 src/buffer.c     register Lisp_Object result = buffer_local_value (variable, buffer);</span>
<span class='curline'><a href='../S/272.html#L1296'>buffer</a>           1296 src/buffer.c   buffer_local_value (Lisp_Object variable, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L1298'>buffer</a>           1298 src/buffer.c     register struct buffer *buf;</span>
<span class='curline'><a href='../S/272.html#L1303'>buffer</a>           1303 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/272.html#L1304'>buffer</a>           1304 src/buffer.c     buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/272.html#L1360'>buffer</a>           1360 src/buffer.c   buffer_lisp_local_variables (struct buffer *buf, bool clone)</span>
<span class='curline'><a href='../S/272.html#L1395'>buffer</a>           1395 src/buffer.c   buffer_local_variables_1 (struct buffer *buf, int offset, Lisp_Object sym)</span>
<span class='curline'><a href='../S/272.html#L1415'>buffer</a>           1415 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L1417'>buffer</a>           1417 src/buffer.c     struct buffer *buf = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/272.html#L1448'>buffer</a>           1448 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L1450'>buffer</a>           1450 src/buffer.c     struct buffer *buf = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/272.html#L1530'>buffer</a>           1530 src/buffer.c     struct buffer *b = current_buffer-&gt;base_buffer</span>
<span class='curline'><a href='../S/272.html#L1580'>buffer</a>           1580 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L1582'>buffer</a>           1582 src/buffer.c     return modiff_to_integer (BUF_MODIFF (decode_buffer (buffer)));</span>
<span class='curline'><a href='../S/272.html#L1590'>buffer</a>           1590 src/buffer.c     (Lisp_Object tick, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L1593'>buffer</a>           1593 src/buffer.c     BUF_MODIFF (decode_buffer (buffer)) = XFIXNUM (tick);</span>
<span class='curline'><a href='../S/272.html#L1607'>buffer</a>           1607 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L1609'>buffer</a>           1609 src/buffer.c     return modiff_to_integer (BUF_CHARS_MODIFF (decode_buffer (buffer)));</span>
<span class='curline'><a href='../S/272.html#L1674'>buffer</a>           1674 src/buffer.c   candidate_buffer (Lisp_Object b, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L1676'>buffer</a>           1676 src/buffer.c     return (BUFFERP (b) &amp;&amp; !BASE_EQ (b, buffer)</span>
<span class='curline'><a href='../S/272.html#L1692'>buffer</a>           1692 src/buffer.c     (Lisp_Object buffer, Lisp_Object visible_ok, Lisp_Object frame)</span>
<span class='curline'><a href='../S/272.html#L1702'>buffer</a>           1702 src/buffer.c         if (candidate_buffer (buf, buffer)</span>
<span class='curline'><a href='../S/272.html#L1718'>buffer</a>           1718 src/buffer.c         if (candidate_buffer (buf, buffer)</span>
<span class='curline'><a href='../S/272.html#L1742'>buffer</a>           1742 src/buffer.c   other_buffer_safely (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L1747'>buffer</a>           1747 src/buffer.c       if (candidate_buffer (buf, buffer))</span>
<span class='curline'><a href='../S/272.html#L1769'>buffer</a>           1769 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L1773'>buffer</a>           1773 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/272.html#L1777'>buffer</a>           1777 src/buffer.c         real_buffer = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/272.html#L1779'>buffer</a>           1779 src/buffer.c   	nsberror (buffer);</span>
<span class='curline'><a href='../S/272.html#L1791'>buffer</a>           1791 src/buffer.c   compact_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/272.html#L1793'>buffer</a>           1793 src/buffer.c     BUFFER_CHECK_INDIRECTION (buffer);</span>
<span class='curline'><a href='../S/272.html#L1797'>buffer</a>           1797 src/buffer.c     if (BUFFER_LIVE_P (buffer)</span>
<span class='curline'><a href='../S/272.html#L1798'>buffer</a>           1798 src/buffer.c         &amp;&amp; (buffer-&gt;base_buffer == NULL)</span>
<span class='curline'><a href='../S/272.html#L1799'>buffer</a>           1799 src/buffer.c         &amp;&amp; (BUF_COMPACT (buffer) != BUF_MODIFF (buffer)))</span>
<span class='curline'><a href='../S/272.html#L1805'>buffer</a>           1805 src/buffer.c         if (!EQ (BVAR(buffer, undo_list), Qt))</span>
<span class='curline'><a href='../S/272.html#L1806'>buffer</a>           1806 src/buffer.c   	truncate_undo_list (buffer);</span>
<span class='curline'><a href='../S/272.html#L1809'>buffer</a>           1809 src/buffer.c         if (!buffer-&gt;text-&gt;inhibit_shrinking)</span>
<span class='curline'><a href='../S/272.html#L1815'>buffer</a>           1815 src/buffer.c   					   BUF_Z_BYTE (buffer) / 10,</span>
<span class='curline'><a href='../S/272.html#L1817'>buffer</a>           1817 src/buffer.c   	  if (BUF_GAP_SIZE (buffer) &gt; size)</span>
<span class='curline'><a href='../S/272.html#L1818'>buffer</a>           1818 src/buffer.c   	    make_gap_1 (buffer, -(BUF_GAP_SIZE (buffer) - size));</span>
<span class='curline'><a href='../S/272.html#L1820'>buffer</a>           1820 src/buffer.c         BUF_COMPACT (buffer) = BUF_MODIFF (buffer);</span>
<span class='curline'><a href='../S/272.html#L1844'>buffer</a>           1844 src/buffer.c     Lisp_Object buffer;</span>
<span class='curline'><a href='../S/272.html#L1845'>buffer</a>           1845 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/272.html#L1850'>buffer</a>           1850 src/buffer.c       buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/272.html#L1852'>buffer</a>           1852 src/buffer.c       buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/272.html#L1853'>buffer</a>           1853 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/272.html#L1856'>buffer</a>           1856 src/buffer.c     b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/272.html#L1892'>buffer</a>           1892 src/buffer.c   	if (NILP (call1 (Qkill_buffer__possibly_save, buffer)))</span>
<span class='curline'><a href='../S/272.html#L1934'>buffer</a>           1934 src/buffer.c     if (BASE_EQ (buffer, XWINDOW (minibuf_window)-&gt;contents))</span>
<span class='curline'><a href='../S/272.html#L1958'>buffer</a>           1958 src/buffer.c     replace_buffer_in_windows (buffer);</span>
<span class='curline'><a href='../S/272.html#L1968'>buffer</a>           1968 src/buffer.c         tem = Fother_buffer (buffer, Qnil, Qnil);</span>
<span class='curline'><a href='../S/272.html#L1978'>buffer</a>           1978 src/buffer.c         &amp;&amp; BASE_EQ (buffer, Fother_buffer (buffer, Qnil, Qnil)))</span>
<span class='curline'><a href='../S/272.html#L1986'>buffer</a>           1986 src/buffer.c     kill_buffer_processes (buffer);</span>
<span class='curline'><a href='../S/272.html#L1987'>buffer</a>           1987 src/buffer.c     kill_buffer_xwidgets (buffer);</span>
<span class='curline'><a href='../S/272.html#L1996'>buffer</a>           1996 src/buffer.c     frames_discard_buffer (buffer);</span>
<span class='curline'><a href='../S/272.html#L2006'>buffer</a>           2006 src/buffer.c     Vbuffer_alist = Fdelq (Frassq (buffer, Vbuffer_alist), Vbuffer_alist);</span>
<span class='curline'><a href='../S/272.html#L2008'>buffer</a>           2008 src/buffer.c     replace_buffer_in_windows_safely (buffer);</span>
<span class='curline'><a href='../S/272.html#L2020'>buffer</a>           2020 src/buffer.c   	  if (m-&gt;buffer == b)</span>
<span class='curline'><a href='../S/272.html#L2022'>buffer</a>           2022 src/buffer.c   	      m-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/272.html#L2044'>buffer</a>           2044 src/buffer.c   	  m-&gt;buffer = 0;</span>
<span class='curline'><a href='../S/272.html#L2117'>buffer</a>           2117 src/buffer.c   record_buffer (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L2122'>buffer</a>           2122 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/272.html#L2129'>buffer</a>           2129 src/buffer.c     aelt = Frassq (buffer, Vbuffer_alist);</span>
<span class='curline'><a href='../S/272.html#L2137'>buffer</a>           2137 src/buffer.c     fset_buffer_list (f, Fcons (buffer, Fdelq (buffer, f-&gt;buffer_list)));</span>
<span class='curline'><a href='../S/272.html#L2138'>buffer</a>           2138 src/buffer.c     fset_buried_buffer_list (f, Fdelq (buffer, f-&gt;buried_buffer_list));</span>
<span class='curline'><a href='../S/272.html#L2140'>buffer</a>           2140 src/buffer.c     run_buffer_list_update_hook (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/272.html#L2153'>buffer</a>           2153 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L2158'>buffer</a>           2158 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/272.html#L2165'>buffer</a>           2165 src/buffer.c     aelt = Frassq (buffer, Vbuffer_alist);</span>
<span class='curline'><a href='../S/272.html#L2173'>buffer</a>           2173 src/buffer.c     fset_buffer_list (f, Fdelq (buffer, f-&gt;buffer_list));</span>
<span class='curline'><a href='../S/272.html#L2175'>buffer</a>           2175 src/buffer.c       (f, Fcons (buffer, Fdelq (buffer, f-&gt;buried_buffer_list)));</span>
<span class='curline'><a href='../S/272.html#L2177'>buffer</a>           2177 src/buffer.c     run_buffer_list_update_hook (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/272.html#L2188'>buffer</a>           2188 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L2192'>buffer</a>           2192 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/272.html#L2194'>buffer</a>           2194 src/buffer.c     if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/272.html#L2197'>buffer</a>           2197 src/buffer.c     if (strcmp (SSDATA (BVAR (XBUFFER (buffer), name)), "*scratch*") == 0)</span>
<span class='curline'><a href='../S/272.html#L2219'>buffer</a>           2219 src/buffer.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/272.html#L2238'>buffer</a>           2238 src/buffer.c   set_buffer_internal_1 (register struct buffer *b)</span>
<span class='curline'><a href='../S/272.html#L2254'>buffer</a>           2254 src/buffer.c   void set_buffer_internal_2 (register struct buffer *b)</span>
<span class='curline'><a href='../S/272.html#L2256'>buffer</a>           2256 src/buffer.c     register struct buffer *old_buf;</span>
<span class='curline'><a href='../S/272.html#L2310'>buffer</a>           2310 src/buffer.c   set_buffer_temp (struct buffer *b)</span>
<span class='curline'><a href='../S/272.html#L2312'>buffer</a>           2312 src/buffer.c     register struct buffer *old_buf;</span>
<span class='curline'><a href='../S/272.html#L2339'>buffer</a>           2339 src/buffer.c     register Lisp_Object buffer;</span>
<span class='curline'><a href='../S/272.html#L2340'>buffer</a>           2340 src/buffer.c     buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/272.html#L2341'>buffer</a>           2341 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/272.html#L2343'>buffer</a>           2343 src/buffer.c     if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/272.html#L2345'>buffer</a>           2345 src/buffer.c     set_buffer_internal (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/272.html#L2346'>buffer</a>           2346 src/buffer.c     return buffer;</span>
<span class='curline'><a href='../S/272.html#L2358'>buffer</a>           2358 src/buffer.c   set_buffer_if_live (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L2360'>buffer</a>           2360 src/buffer.c     if (BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/272.html#L2361'>buffer</a>           2361 src/buffer.c       set_buffer_internal (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/272.html#L2456'>buffer</a>           2456 src/buffer.c   swap_buffer_overlays (struct buffer *buffer, struct buffer *other)</span>
<span class='curline'><a href='../S/272.html#L2460'>buffer</a>           2460 src/buffer.c     ITREE_FOREACH (node, buffer-&gt;overlays, PTRDIFF_MIN, PTRDIFF_MAX, ASCENDING)</span>
<span class='curline'><a href='../S/272.html#L2461'>buffer</a>           2461 src/buffer.c       XOVERLAY (node-&gt;data)-&gt;buffer = other;</span>
<span class='curline'><a href='../S/272.html#L2464'>buffer</a>           2464 src/buffer.c       XOVERLAY (node-&gt;data)-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/272.html#L2467'>buffer</a>           2467 src/buffer.c     void *tmp = buffer-&gt;overlays;</span>
<span class='curline'><a href='../S/272.html#L2468'>buffer</a>           2468 src/buffer.c     buffer-&gt;overlays = other-&gt;overlays;</span>
<span class='curline'><a href='../S/272.html#L2477'>buffer</a>           2477 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L2479'>buffer</a>           2479 src/buffer.c     struct buffer *other_buffer;</span>
<span class='curline'><a href='../S/272.html#L2480'>buffer</a>           2480 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/272.html#L2481'>buffer</a>           2481 src/buffer.c     other_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/272.html#L2573'>buffer</a>           2573 src/buffer.c         if (m-&gt;buffer == other_buffer)</span>
<span class='curline'><a href='../S/272.html#L2574'>buffer</a>           2574 src/buffer.c   	m-&gt;buffer = current_buffer;</span>
<span class='curline'><a href='../S/272.html#L2578'>buffer</a>           2578 src/buffer.c   	eassert (!m-&gt;buffer);</span>
<span class='curline'><a href='../S/272.html#L2580'>buffer</a>           2580 src/buffer.c         if (m-&gt;buffer == current_buffer)</span>
<span class='curline'><a href='../S/272.html#L2581'>buffer</a>           2581 src/buffer.c   	m-&gt;buffer = other_buffer;</span>
<span class='curline'><a href='../S/272.html#L2585'>buffer</a>           2585 src/buffer.c   	eassert (!m-&gt;buffer);</span>
<span class='curline'><a href='../S/272.html#L2625'>buffer</a>           2625 src/buffer.c       (eassert (BASE_EQ (current_buffer-&gt;text-&gt;intervals-&gt;up.obj, buffer)),</span>
<span class='curline'><a href='../S/272.html#L2898'>buffer</a>           2898 src/buffer.c         struct buffer *o = XBUFFER (other);</span>
<span class='curline'><a href='../S/272.html#L3474'>buffer</a>           3474 src/buffer.c         struct buffer *base = current_buffer-&gt;base_buffer</span>
<span class='curline'><a href='../S/272.html#L3487'>buffer</a>           3487 src/buffer.c   adjust_overlays_for_delete_in_buffer (struct buffer * buf,</span>
<span class='curline'><a href='../S/272.html#L3519'>buffer</a>           3519 src/buffer.c         struct buffer *base = current_buffer-&gt;base_buffer</span>
<span class='curline'><a href='../S/272.html#L3548'>buffer</a>           3548 src/buffer.c     (Lisp_Object beg, Lisp_Object end, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/272.html#L3552'>buffer</a>           3552 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/272.html#L3554'>buffer</a>           3554 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/272.html#L3555'>buffer</a>           3555 src/buffer.c       XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/272.html#L3557'>buffer</a>           3557 src/buffer.c       CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/272.html#L3559'>buffer</a>           3559 src/buffer.c     b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/272.html#L3563'>buffer</a>           3563 src/buffer.c     if (MARKERP (beg) &amp;&amp; !BASE_EQ (Fmarker_buffer (beg), buffer))</span>
<span class='curline'><a href='../S/272.html#L3565'>buffer</a>           3565 src/buffer.c     if (MARKERP (end) &amp;&amp; !BASE_EQ (Fmarker_buffer (end), buffer))</span>
<span class='curline'><a href='../S/272.html#L3592'>buffer</a>           3592 src/buffer.c   modify_overlay (struct buffer *buf, ptrdiff_t start, ptrdiff_t end)</span>
<span class='curline'><a href='../S/272.html#L3613'>buffer</a>           3613 src/buffer.c     (Lisp_Object overlay, Lisp_Object beg, Lisp_Object end, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L3615'>buffer</a>           3615 src/buffer.c     struct buffer *b, *ob = 0;</span>
<span class='curline'><a href='../S/272.html#L3621'>buffer</a>           3621 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/272.html#L3622'>buffer</a>           3622 src/buffer.c       buffer = Foverlay_buffer (overlay);</span>
<span class='curline'><a href='../S/272.html#L3623'>buffer</a>           3623 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/272.html#L3624'>buffer</a>           3624 src/buffer.c       XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/272.html#L3625'>buffer</a>           3625 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/272.html#L3627'>buffer</a>           3627 src/buffer.c     if (NILP (Fbuffer_live_p (buffer)))</span>
<span class='curline'><a href='../S/272.html#L3630'>buffer</a>           3630 src/buffer.c     if (MARKERP (beg) &amp;&amp; !BASE_EQ (Fmarker_buffer (beg), buffer))</span>
<span class='curline'><a href='../S/272.html#L3632'>buffer</a>           3632 src/buffer.c     if (MARKERP (end) &amp;&amp; !BASE_EQ (Fmarker_buffer (end), buffer))</span>
<span class='curline'><a href='../S/272.html#L3647'>buffer</a>           3647 src/buffer.c     b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/272.html#L3660'>buffer</a>           3660 src/buffer.c     if (! BASE_EQ (buffer, obuffer))</span>
<span class='curline'><a href='../S/272.html#L3664'>buffer</a>           3664 src/buffer.c         add_buffer_overlay (XBUFFER (buffer), XOVERLAY (overlay), n_beg, n_end);</span>
<span class='curline'><a href='../S/272.html#L3671'>buffer</a>           3671 src/buffer.c     if (!BASE_EQ (buffer, obuffer))</span>
<span class='curline'><a href='../S/272.html#L3711'>buffer</a>           3711 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/272.html#L3740'>buffer</a>           3740 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L3742'>buffer</a>           3742 src/buffer.c     delete_all_overlays (decode_buffer (buffer));</span>
<span class='curline'><a href='../S/272.html#L3775'>buffer</a>           3775 src/buffer.c     Lisp_Object buffer;</span>
<span class='curline'><a href='../S/272.html#L3782'>buffer</a>           3782 src/buffer.c     XSETBUFFER (buffer, OVERLAY_BUFFER (overlay));</span>
<span class='curline'><a href='../S/272.html#L3784'>buffer</a>           3784 src/buffer.c     return buffer;</span>
<span class='curline'><a href='../S/272.html#L3961'>buffer</a>           3961 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/272.html#L4512'>buffer</a>           4512 src/buffer.c   alloc_buffer_text (struct buffer *b, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/272.html#L4539'>buffer</a>           4539 src/buffer.c   enlarge_buffer_text (struct buffer *b, ptrdiff_t delta)</span>
<span class='curline'><a href='../S/272.html#L4581'>buffer</a>           4581 src/buffer.c   free_buffer_text (struct buffer *b)</span>
<span class='curline'><a href='../S/272.html#L4853'>buffer</a>           4853 src/buffer.c         Lisp_Object tail, buffer;</span>
<span class='curline'><a href='../S/272.html#L4879'>buffer</a>           4879 src/buffer.c         FOR_EACH_LIVE_BUFFER (tail, buffer)</span>
<span class='curline'><a href='../S/272.html#L4881'>buffer</a>           4881 src/buffer.c   	  struct buffer *b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/272.html#L5010'>buffer</a>           5010 src/buffer.c        (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/272.html#L5012'>buffer</a>           5012 src/buffer.c     struct buffer *b = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/239.html#L162'>buffer</a>            162 src/buffer.h   extern void temp_set_point (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/239.html#L164'>buffer</a>            164 src/buffer.h   extern void temp_set_point_both (struct buffer *,</span>
<span class='curline'><a href='../S/239.html#L167'>buffer</a>            167 src/buffer.h   extern void enlarge_buffer_text (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/239.html#L190'>buffer</a>            190 src/buffer.h   BUF_TEMP_SET_PT (struct buffer *buffer, ptrdiff_t position)</span>
<span class='curline'><a href='../S/239.html#L192'>buffer</a>            192 src/buffer.h     temp_set_point (buffer, position);</span>
<span class='curline'><a href='../S/239.html#L606'>buffer</a>            606 src/buffer.h     struct buffer *base_buffer;</span>
<span class='curline'><a href='../S/239.html#L724'>buffer</a>            724 src/buffer.h   INLINE struct buffer *</span>
<span class='curline'><a href='../S/239.html#L728'>buffer</a>            728 src/buffer.h     return XUNTAG (a, Lisp_Vectorlike, struct buffer);</span>
<span class='curline'><a href='../S/239.html#L735'>buffer</a>            735 src/buffer.h   bset_bidi_paragraph_direction (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L740'>buffer</a>            740 src/buffer.h   bset_cache_long_scans (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L745'>buffer</a>            745 src/buffer.h   bset_case_canon_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L750'>buffer</a>            750 src/buffer.h   bset_case_eqv_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L755'>buffer</a>            755 src/buffer.h   bset_directory (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L760'>buffer</a>            760 src/buffer.h   bset_display_count (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L765'>buffer</a>            765 src/buffer.h   bset_left_margin_cols (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L770'>buffer</a>            770 src/buffer.h   bset_right_margin_cols (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L775'>buffer</a>            775 src/buffer.h   bset_display_time (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L780'>buffer</a>            780 src/buffer.h   bset_downcase_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L785'>buffer</a>            785 src/buffer.h   bset_enable_multibyte_characters (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L790'>buffer</a>            790 src/buffer.h   bset_filename (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L795'>buffer</a>            795 src/buffer.h   bset_keymap (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L800'>buffer</a>            800 src/buffer.h   bset_last_selected_window (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L805'>buffer</a>            805 src/buffer.h   bset_local_var_alist (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L810'>buffer</a>            810 src/buffer.h   bset_mark_active (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L815'>buffer</a>            815 src/buffer.h   bset_point_before_scroll (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L820'>buffer</a>            820 src/buffer.h   bset_read_only (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L825'>buffer</a>            825 src/buffer.h   bset_truncate_lines (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L830'>buffer</a>            830 src/buffer.h   bset_undo_list (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L835'>buffer</a>            835 src/buffer.h   bset_upcase_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L840'>buffer</a>            840 src/buffer.h   bset_width_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/239.html#L867'>buffer</a>            867 src/buffer.h   BUF_BEGV (struct buffer *buf)</span>
<span class='curline'><a href='../S/239.html#L875'>buffer</a>            875 src/buffer.h   BUF_BEGV_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/239.html#L884'>buffer</a>            884 src/buffer.h   BUF_PT (struct buffer *buf)</span>
<span class='curline'><a href='../S/239.html#L892'>buffer</a>            892 src/buffer.h   BUF_PT_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/239.html#L901'>buffer</a>            901 src/buffer.h   BUF_ZV (struct buffer *buf)</span>
<span class='curline'><a href='../S/239.html#L909'>buffer</a>            909 src/buffer.h   BUF_ZV_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/239.html#L920'>buffer</a>            920 src/buffer.h   BUF_BEG (struct buffer *buf)</span>
<span class='curline'><a href='../S/239.html#L926'>buffer</a>            926 src/buffer.h   BUF_BEG_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/239.html#L933'>buffer</a>            933 src/buffer.h   BUF_GPT_ADDR (struct buffer *buf)</span>
<span class='curline'><a href='../S/239.html#L940'>buffer</a>            940 src/buffer.h   BUF_Z_ADDR (struct buffer *buf)</span>
<span class='curline'><a href='../S/239.html#L947'>buffer</a>            947 src/buffer.h   BUF_GAP_END_ADDR (struct buffer *buf)</span>
<span class='curline'><a href='../S/239.html#L957'>buffer</a>            957 src/buffer.h   BUF_COMPUTE_UNCHANGED (struct buffer *buf, ptrdiff_t start, ptrdiff_t end)</span>
<span class='curline'><a href='../S/239.html#L984'>buffer</a>            984 src/buffer.h   SET_BUF_BEGV (struct buffer *buf, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/239.html#L991'>buffer</a>            991 src/buffer.h   SET_BUF_ZV (struct buffer *buf, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/239.html#L998'>buffer</a>            998 src/buffer.h   SET_BUF_BEGV_BOTH (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t byte)</span>
<span class='curline'><a href='../S/239.html#L1005'>buffer</a>           1005 src/buffer.h   SET_BUF_ZV_BOTH (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t byte)</span>
<span class='curline'><a href='../S/239.html#L1012'>buffer</a>           1012 src/buffer.h   SET_BUF_PT_BOTH (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t byte)</span>
<span class='curline'><a href='../S/239.html#L1072'>buffer</a>           1072 src/buffer.h   enum { BUFFER_LISP_SIZE = PSEUDOVECSIZE (struct buffer,</span>
<span class='curline'><a href='../S/239.html#L1078'>buffer</a>           1078 src/buffer.h   enum { BUFFER_REST_SIZE = VECSIZE (struct buffer) - BUFFER_LISP_SIZE };</span>
<span class='curline'><a href='../S/239.html#L1085'>buffer</a>           1085 src/buffer.h   BUFFER_PVEC_INIT (struct buffer *b)</span>
<span class='curline'><a href='../S/239.html#L1093'>buffer</a>           1093 src/buffer.h   BUFFER_LIVE_P (struct buffer *b)</span>
<span class='curline'><a href='../S/239.html#L1102'>buffer</a>           1102 src/buffer.h   BUFFER_HIDDEN_P (struct buffer *b)</span>
<span class='curline'><a href='../S/239.html#L1110'>buffer</a>           1110 src/buffer.h   BUFFER_CHECK_INDIRECTION (struct buffer *b)</span>
<span class='curline'><a href='../S/239.html#L1131'>buffer</a>           1131 src/buffer.h   extern struct buffer buffer_defaults;</span>
<span class='curline'><a href='../S/239.html#L1147'>buffer</a>           1147 src/buffer.h   extern struct buffer buffer_local_flags;</span>
<span class='curline'><a href='../S/239.html#L1153'>buffer</a>           1153 src/buffer.h   extern struct buffer buffer_local_symbols;</span>
<span class='curline'><a href='../S/239.html#L1163'>buffer</a>           1163 src/buffer.h   extern void delete_all_overlays (struct buffer *);</span>
<span class='curline'><a href='../S/239.html#L1164'>buffer</a>           1164 src/buffer.h   extern void reset_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/239.html#L1165'>buffer</a>           1165 src/buffer.h   extern void compact_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/239.html#L1172'>buffer</a>           1172 src/buffer.h   extern void recenter_overlay_lists (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/239.html#L1175'>buffer</a>           1175 src/buffer.h   extern void set_buffer_internal_1 (struct buffer *);</span>
<span class='curline'><a href='../S/239.html#L1176'>buffer</a>           1176 src/buffer.h   extern void set_buffer_internal_2 (struct buffer *);</span>
<span class='curline'><a href='../S/239.html#L1177'>buffer</a>           1177 src/buffer.h   extern void set_buffer_temp (struct buffer *);</span>
<span class='curline'><a href='../S/239.html#L1180'>buffer</a>           1180 src/buffer.h   extern void fix_overlays_before (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/239.html#L1188'>buffer</a>           1188 src/buffer.h   INLINE struct buffer *</span>
<span class='curline'><a href='../S/239.html#L1204'>buffer</a>           1204 src/buffer.h   set_buffer_internal (struct buffer *b)</span>
<span class='curline'><a href='../S/239.html#L1249'>buffer</a>           1249 src/buffer.h   buffer_intervals (struct buffer *b)</span>
<span class='curline'><a href='../S/239.html#L1258'>buffer</a>           1258 src/buffer.h   set_buffer_intervals (struct buffer *b, INTERVAL i)</span>
<span class='curline'><a href='../S/239.html#L1293'>buffer</a>           1293 src/buffer.h   BUF_FETCH_MULTIBYTE_CHAR (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/239.html#L1328'>buffer</a>           1328 src/buffer.h   BUF_BYTE_ADDRESS (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/239.html#L1338'>buffer</a>           1338 src/buffer.h   BUF_CHAR_ADDRESS (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/239.html#L1348'>buffer</a>           1348 src/buffer.h   BUF_PTR_BYTE_POS (struct buffer *buf, unsigned char *ptr)</span>
<span class='curline'><a href='../S/239.html#L1358'>buffer</a>           1358 src/buffer.h   BUF_FETCH_BYTE (struct buffer *buf, ptrdiff_t n)</span>
<span class='curline'><a href='../S/239.html#L1368'>buffer</a>           1368 src/buffer.h   BUF_FETCH_CHAR_AS_MULTIBYTE (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/239.html#L1378'>buffer</a>           1378 src/buffer.h   buffer_window_count (struct buffer *b)</span>
<span class='curline'><a href='../S/239.html#L1391'>buffer</a>           1391 src/buffer.h     if (! ov-&gt;buffer)</span>
<span class='curline'><a href='../S/239.html#L1393'>buffer</a>           1393 src/buffer.h     return itree_node_begin (ov-&gt;buffer-&gt;overlays, ov-&gt;interval);</span>
<span class='curline'><a href='../S/239.html#L1399'>buffer</a>           1399 src/buffer.h     if (! ov-&gt;buffer)</span>
<span class='curline'><a href='../S/239.html#L1401'>buffer</a>           1401 src/buffer.h     return itree_node_end (ov-&gt;buffer-&gt;overlays, ov-&gt;interval);</span>
<span class='curline'><a href='../S/239.html#L1431'>buffer</a>           1431 src/buffer.h   INLINE struct buffer *</span>
<span class='curline'><a href='../S/239.html#L1434'>buffer</a>           1434 src/buffer.h     return XOVERLAY (ov)-&gt;buffer;</span>
<span class='curline'><a href='../S/239.html#L1462'>buffer</a>           1462 src/buffer.h     offsetof (struct buffer, VAR ## _)</span>
<span class='curline'><a href='../S/239.html#L1488'>buffer</a>           1488 src/buffer.h   PER_BUFFER_VALUE_P (struct buffer *b, int idx)</span>
<span class='curline'><a href='../S/239.html#L1498'>buffer</a>           1498 src/buffer.h   SET_PER_BUFFER_VALUE_P (struct buffer *b, int idx, bool val)</span>
<span class='curline'><a href='../S/239.html#L1549'>buffer</a>           1549 src/buffer.h   per_buffer_value (struct buffer *b, int offset)</span>
<span class='curline'><a href='../S/239.html#L1555'>buffer</a>           1555 src/buffer.h   set_per_buffer_value (struct buffer *b, int offset, Lisp_Object value)</span>
<span class='curline'><a href='../S/239.html#L1602'>buffer</a>           1602 src/buffer.h   SANE_TAB_WIDTH (struct buffer *buf)</span>
<span class='curline'><a href='../S/239.html#L1682'>buffer</a>           1682 src/buffer.h   buf_next_char_len (struct buffer *buf, ptrdiff_t pos_byte)</span>
<span class='curline'><a href='../S/239.html#L1698'>buffer</a>           1698 src/buffer.h   buf_prev_char_len (struct buffer *buf, ptrdiff_t pos_byte)</span>
<span class='curline'><a href='../S/128.html#L224'>buffer</a>            224 src/callproc.c call_process_cleanup (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/128.html#L226'>buffer</a>            226 src/callproc.c   Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/128.html#L336'>buffer</a>            336 src/callproc.c   Lisp_Object buffer, current_dir, path;</span>
<span class='curline'><a href='../S/128.html#L423'>buffer</a>            423 src/callproc.c     buffer = Qnil;</span>
<span class='curline'><a href='../S/128.html#L426'>buffer</a>            426 src/callproc.c       buffer = args[2];</span>
<span class='curline'><a href='../S/128.html#L431'>buffer</a>            431 src/callproc.c       if (CONSP (buffer) &amp;&amp; !EQ (XCAR (buffer), QCfile))</span>
<span class='curline'><a href='../S/128.html#L433'>buffer</a>            433 src/callproc.c 	  if (CONSP (XCDR (buffer)))</span>
<span class='curline'><a href='../S/128.html#L436'>buffer</a>            436 src/callproc.c 	      stderr_file = XCAR (XCDR (buffer));</span>
<span class='curline'><a href='../S/128.html#L444'>buffer</a>            444 src/callproc.c 	  buffer = XCAR (buffer);</span>
<span class='curline'><a href='../S/128.html#L448'>buffer</a>            448 src/callproc.c       if (CONSP (buffer) &amp;&amp; EQ (XCAR (buffer), QCfile))</span>
<span class='curline'><a href='../S/128.html#L450'>buffer</a>            450 src/callproc.c 	  Lisp_Object ofile = XCDR (buffer);</span>
<span class='curline'><a href='../S/128.html#L457'>buffer</a>            457 src/callproc.c 	  buffer = Qnil;</span>
<span class='curline'><a href='../S/128.html#L460'>buffer</a>            460 src/callproc.c       if (! (NILP (buffer) || EQ (buffer, Qt) || FIXNUMP (buffer)))</span>
<span class='curline'><a href='../S/128.html#L462'>buffer</a>            462 src/callproc.c 	  Lisp_Object spec_buffer = buffer;</span>
<span class='curline'><a href='../S/128.html#L463'>buffer</a>            463 src/callproc.c 	  buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/128.html#L465'>buffer</a>            465 src/callproc.c 	  if (NILP (buffer))</span>
<span class='curline'><a href='../S/128.html#L467'>buffer</a>            467 src/callproc.c 	  CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/128.html#L533'>buffer</a>            533 src/callproc.c   discard_output = FIXNUMP (buffer) || (NILP (buffer) &amp;&amp; NILP (output_file));</span>
<span class='curline'><a href='../S/128.html#L664'>buffer</a>            664 src/callproc.c       if (FIXNUMP (buffer))</span>
<span class='curline'><a href='../S/128.html#L697'>buffer</a>            697 src/callproc.c   if (FIXNUMP (buffer))</span>
<span class='curline'><a href='../S/128.html#L700'>buffer</a>            700 src/callproc.c   if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/128.html#L701'>buffer</a>            701 src/callproc.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/91.html#L40'>buffer</a>             40 src/category.c bset_category_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/269.html#L907'>buffer</a>            907 src/coding.c         struct buffer *buf = XBUFFER (coding-&gt;src_object);</span>
<span class='curline'><a href='../S/269.html#L1024'>buffer</a>           1024 src/coding.c         struct buffer *buf = XBUFFER (coding-&gt;dst_object);</span>
<span class='curline'><a href='../S/269.html#L7869'>buffer</a>           7869 src/coding.c         struct buffer *current = current_buffer;</span>
<span class='curline'><a href='../S/269.html#L7890'>buffer</a>           7890 src/coding.c     struct buffer *buf = XBUFFER (XCDR (arg));</span>
<span class='curline'><a href='../S/269.html#L8389'>buffer</a>           8389 src/coding.c   	  struct buffer *current = current_buffer;</span>
<span class='curline'><a href='../S/269.html#L9421'>buffer</a>           9421 src/coding.c         struct buffer *buf = XBUFFER (dst_object);</span>
<span class='curline'><a href='../S/269.html#L9570'>buffer</a>           9570 src/coding.c         struct buffer *buf = XBUFFER (dst_object);</span>
<span class='curline'><a href='../S/269.html#L9604'>buffer</a>           9604 src/coding.c   get_buffer_gap_address (Lisp_Object buffer, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/269.html#L9606'>buffer</a>           9606 src/coding.c     struct buffer *buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/269.html#L9610'>buffer</a>           9610 src/coding.c         struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/269.html#L9717'>buffer</a>           9717 src/coding.c   encode_string_utf_8 (Lisp_Object string, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/269.html#L9722'>buffer</a>           9722 src/coding.c     if (NILP (buffer) &amp;&amp; nchars == nbytes &amp;&amp; nocopy)</span>
<span class='curline'><a href='../S/269.html#L9892'>buffer</a>           9892 src/coding.c   	  if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/269.html#L9895'>buffer</a>           9895 src/coding.c   	      dst = get_buffer_gap_address (buffer, nbytes);</span>
<span class='curline'><a href='../S/269.html#L9910'>buffer</a>           9910 src/coding.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/269.html#L9912'>buffer</a>           9912 src/coding.c         struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/269.html#L9914'>buffer</a>           9914 src/coding.c         current_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/269.html#L9994'>buffer</a>           9994 src/coding.c   		     Lisp_Object buffer, bool nocopy,</span>
<span class='curline'><a href='../S/269.html#L10071'>buffer</a>           10071 src/coding.c         &amp;&amp; NILP (buffer))</span>
<span class='curline'><a href='../S/269.html#L10140'>buffer</a>           10140 src/coding.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/269.html#L10143'>buffer</a>           10143 src/coding.c         dst = get_buffer_gap_address (buffer, outbytes);</span>
<span class='curline'><a href='../S/269.html#L10220'>buffer</a>           10220 src/coding.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/269.html#L10222'>buffer</a>           10222 src/coding.c         struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/269.html#L10224'>buffer</a>           10224 src/coding.c         current_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/269.html#L10248'>buffer</a>           10248 src/coding.c     (Lisp_Object string, Lisp_Object buffer, Lisp_Object nocopy,</span>
<span class='curline'><a href='../S/269.html#L10258'>buffer</a>           10258 src/coding.c     if (! NILP (buffer)</span>
<span class='curline'><a href='../S/269.html#L10259'>buffer</a>           10259 src/coding.c         &amp;&amp; (! BUFFERP (buffer)</span>
<span class='curline'><a href='../S/269.html#L10260'>buffer</a>           10260 src/coding.c   	  || ! NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/269.html#L10281'>buffer</a>           10281 src/coding.c   	val = encode_string_utf_8 (string, buffer, ! NILP (nocopy),</span>
<span class='curline'><a href='../S/269.html#L10304'>buffer</a>           10304 src/coding.c     (Lisp_Object string, Lisp_Object buffer, Lisp_Object nocopy,</span>
<span class='curline'><a href='../S/269.html#L10314'>buffer</a>           10314 src/coding.c     if (! NILP (buffer)</span>
<span class='curline'><a href='../S/269.html#L10315'>buffer</a>           10315 src/coding.c         &amp;&amp; (! BUFFERP (buffer)</span>
<span class='curline'><a href='../S/269.html#L10316'>buffer</a>           10316 src/coding.c   	  || NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/269.html#L10337'>buffer</a>           10337 src/coding.c   	val = decode_string_utf_8 (string, buffer, ! NILP (nocopy),</span>
<span class='curline'><a href='../S/269.html#L10342'>buffer</a>           10342 src/coding.c         if (! BUFFERP (buffer))</span>
<span class='curline'><a href='../S/269.html#L10343'>buffer</a>           10343 src/coding.c   	buffer = Qt;</span>
<span class='curline'><a href='../S/269.html#L10345'>buffer</a>           10345 src/coding.c   	val = code_convert_string (string, Qutf_8_unix, buffer, false,</span>
<span class='curline'><a href='../S/269.html#L10444'>buffer</a>           10444 src/coding.c     (Lisp_Object string, Lisp_Object coding_system, Lisp_Object nocopy, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/269.html#L10446'>buffer</a>           10446 src/coding.c     return code_convert_string (string, coding_system, buffer,</span>
<span class='curline'><a href='../S/269.html#L10464'>buffer</a>           10464 src/coding.c     (Lisp_Object string, Lisp_Object coding_system, Lisp_Object nocopy, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/269.html#L10466'>buffer</a>           10466 src/coding.c     return code_convert_string (string, coding_system, buffer,</span>
<span class='curline'><a href='../S/192.html#L1393'>buffer</a>           1393 src/data.c     			 struct buffer *buf)</span>
<span class='curline'><a href='../S/192.html#L1432'>buffer</a>           1432 src/data.c     	      struct buffer *b = XBUFFER (buf);</span>
<span class='curline'><a href='../S/192.html#L1749'>buffer</a>           1749 src/data.c     	struct buffer *buf</span>
<span class='curline'><a href='../S/192.html#L2056'>buffer</a>           2056 src/data.c     		    struct buffer *b = XBUFFER (buf);</span>
<span class='curline'><a href='../S/192.html#L2362'>buffer</a>           2362 src/data.c       (Lisp_Object variable, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/192.html#L2364'>buffer</a>           2364 src/data.c       struct buffer *buf = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/192.html#L2413'>buffer</a>           2413 src/data.c       (register Lisp_Object variable, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/192.html#L2431'>buffer</a>           2431 src/data.c     	return Flocal_variable_p (variable, buffer);</span>
<span class='curline'><a href='../S/192.html#L3017'>buffer</a>           3017 src/data.c     fixnum_to_string (EMACS_INT number, char *buffer, char *end)</span>
<span class='curline'><a href='../S/192.html#L3026'>buffer</a>           3026 src/data.c           eassume (p &gt; buffer &amp;&amp; p - 1 &lt; end);</span>
<span class='curline'><a href='../S/192.html#L3042'>buffer</a>           3042 src/data.c       char buffer[max (FLOAT_TO_STRING_BUFSIZE, INT_BUFSIZE_BOUND (EMACS_INT))];</span>
<span class='curline'><a href='../S/192.html#L3046'>buffer</a>           3046 src/data.c           char *end = buffer + sizeof buffer;</span>
<span class='curline'><a href='../S/192.html#L3047'>buffer</a>           3047 src/data.c           char *p = fixnum_to_string (XFIXNUM (number), buffer, end);</span>
<span class='curline'><a href='../S/192.html#L3055'>buffer</a>           3055 src/data.c         return make_unibyte_string (buffer,</span>
<span class='curline'><a href='../S/192.html#L3056'>buffer</a>           3056 src/data.c     				float_to_string (buffer, XFLOAT_DATA (number)));</span>
<span class='curline'><a href='../S/164.html#L792'>buffer</a>            792 src/dispextern.h   struct buffer *buffer;</span>
<span class='curline'><a href='../S/158.html#L1483'>buffer</a>           1483 src/dispnew.c    struct buffer *saved = current_buffer;</span>
<span class='curline'><a href='../S/158.html#L1484'>buffer</a>           1484 src/dispnew.c    struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/158.html#L1491'>buffer</a>           1491 src/dispnew.c    set_buffer_temp (buffer);</span>
<span class='curline'><a href='../S/72.html#L152'>buffer</a>            152 src/doprnt.c   doprnt_non_null_end (char *buffer, ptrdiff_t bufsize, char const *format,</span>
<span class='curline'><a href='../S/72.html#L160'>buffer</a>            160 src/doprnt.c     ptrdiff_t nbytes = doprnt (buffer, bufsize, fmt, NULL, ap);</span>
<span class='curline'><a href='../S/72.html#L186'>buffer</a>            186 src/doprnt.c   doprnt (char *buffer, ptrdiff_t bufsize, const char *format,</span>
<span class='curline'><a href='../S/72.html#L190'>buffer</a>            190 src/doprnt.c       return doprnt_non_null_end (buffer, bufsize, format, format_end, ap);</span>
<span class='curline'><a href='../S/72.html#L193'>buffer</a>            193 src/doprnt.c     char *bufptr = buffer;	/* Pointer into output buffer.  */</span>
<span class='curline'><a href='../S/72.html#L534'>buffer</a>            534 src/doprnt.c     return bufptr - buffer;</span>
<span class='curline'><a href='../S/82.html#L316'>buffer</a>            316 src/editfns.c        struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/82.html#L816'>buffer</a>            816 src/editfns.c    Lisp_Object buffer = Fmarker_buffer (marker);</span>
<span class='curline'><a href='../S/82.html#L819'>buffer</a>            819 src/editfns.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/82.html#L822'>buffer</a>            822 src/editfns.c    Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/82.html#L887'>buffer</a>            887 src/editfns.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/82.html#L889'>buffer</a>            889 src/editfns.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/82.html#L893'>buffer</a>            893 src/editfns.c        CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/82.html#L894'>buffer</a>            894 src/editfns.c        return make_fixnum (BUF_Z (XBUFFER (buffer))</span>
<span class='curline'><a href='../S/82.html#L895'>buffer</a>            895 src/editfns.c  			  - BUF_BEG (XBUFFER (buffer)));</span>
<span class='curline'><a href='../S/82.html#L1731'>buffer</a>           1731 src/editfns.c    (Lisp_Object buffer, Lisp_Object start, Lisp_Object end)</span>
<span class='curline'><a href='../S/82.html#L1734'>buffer</a>           1734 src/editfns.c    register struct buffer *bp, *obuf;</span>
<span class='curline'><a href='../S/82.html#L1737'>buffer</a>           1737 src/editfns.c    buf = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/82.html#L1739'>buffer</a>           1739 src/editfns.c      nsberror (buffer);</span>
<span class='curline'><a href='../S/82.html#L1777'>buffer</a>           1777 src/editfns.c    register struct buffer *bp1, *bp2;</span>
<span class='curline'><a href='../S/82.html#L1908'>buffer</a>           1908 src/editfns.c    struct buffer *buffer_a;                      \</span>
<span class='curline'><a href='../S/82.html#L1909'>buffer</a>           1909 src/editfns.c    struct buffer *buffer_b;                      \</span>
<span class='curline'><a href='../S/82.html#L1968'>buffer</a>           1968 src/editfns.c    struct buffer *a = current_buffer;</span>
<span class='curline'><a href='../S/82.html#L1972'>buffer</a>           1972 src/editfns.c    struct buffer *b = XBUFFER (source_buffer);</span>
<span class='curline'><a href='../S/82.html#L2033'>buffer</a>           2033 src/editfns.c    ptrdiff_t *buffer;</span>
<span class='curline'><a href='../S/82.html#L2035'>buffer</a>           2035 src/editfns.c    if (INT_MULTIPLY_WRAPV (diags, 2 * sizeof *buffer, &amp;bytes_needed)</span>
<span class='curline'><a href='../S/82.html#L2039'>buffer</a>           2039 src/editfns.c    buffer = SAFE_ALLOCA (bytes_needed);</span>
<span class='curline'><a href='../S/82.html#L2040'>buffer</a>           2040 src/editfns.c    unsigned char *deletions_insertions = memset (buffer + 2 * diags, 0,</span>
<span class='curline'><a href='../S/82.html#L2056'>buffer</a>           2056 src/editfns.c      .fdiag = buffer + size_b + 1,</span>
<span class='curline'><a href='../S/82.html#L2057'>buffer</a>           2057 src/editfns.c      .bdiag = buffer + diags + size_b + 1,</span>
<span class='curline'><a href='../S/82.html#L3044'>buffer</a>           3044 src/editfns.c    struct buffer *cur = NULL;</span>
<span class='curline'><a href='../S/82.html#L3045'>buffer</a>           3045 src/editfns.c    struct buffer *buf = (CONSP (data)</span>
<span class='curline'><a href='../S/82.html#L3046'>buffer</a>           3046 src/editfns.c  			? XMARKER (XCAR (data))-&gt;buffer</span>
<span class='curline'><a href='../S/82.html#L3063'>buffer</a>           3063 src/editfns.c        eassert (buf == end-&gt;buffer);</span>
<span class='curline'><a href='../S/200.html#L1074'>buffer</a>           1074 src/emacs.c    read_full (int fd, void *buffer, ptrdiff_t size)</span>
<span class='curline'><a href='../S/200.html#L1077'>buffer</a>           1077 src/emacs.c      eassert (buffer != NULL);</span>
<span class='curline'><a href='../S/200.html#L1093'>buffer</a>           1093 src/emacs.c      char *ptr = buffer;</span>
<span class='curline'><a href='../S/200.html#L1117'>buffer</a>           1117 src/emacs.c      void *buffer = NULL;</span>
<span class='curline'><a href='../S/200.html#L1154'>buffer</a>           1154 src/emacs.c      buffer = malloc (size + 1);</span>
<span class='curline'><a href='../S/200.html#L1155'>buffer</a>           1155 src/emacs.c      if (buffer == NULL)</span>
<span class='curline'><a href='../S/200.html#L1160'>buffer</a>           1160 src/emacs.c      ptrdiff_t read = read_full (fd, buffer, size + 1);</span>
<span class='curline'><a href='../S/200.html#L1178'>buffer</a>           1178 src/emacs.c      program.filter = buffer;</span>
<span class='curline'><a href='../S/200.html#L1200'>buffer</a>           1200 src/emacs.c      free (buffer);</span>
<span class='curline'><a href='../S/116.html#L2067'>buffer</a>           2067 src/eval.c       char *buffer = buf;</span>
<span class='curline'><a href='../S/116.html#L2071'>buffer</a>           2071 src/eval.c       used = evxprintf (&amp;buffer, &amp;size, buf, size_max, m, ap);</span>
<span class='curline'><a href='../S/116.html#L2072'>buffer</a>           2072 src/eval.c       string = make_string (buffer, used);</span>
<span class='curline'><a href='../S/116.html#L2073'>buffer</a>           2073 src/eval.c       if (buffer != buf)</span>
<span class='curline'><a href='../S/116.html#L2074'>buffer</a>           2074 src/eval.c         xfree (buffer);</span>
<span class='curline'><a href='../S/197.html#L3710'>buffer</a>           3710 src/fileio.c     Lisp_Object buffer = XCDR (tmp);</span>
<span class='curline'><a href='../S/197.html#L3712'>buffer</a>           3712 src/fileio.c     set_buffer_internal (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/197.html#L3869'>buffer</a>           3869 src/fileio.c   maybe_move_gap (struct buffer *b)</span>
<span class='curline'><a href='../S/197.html#L3873'>buffer</a>           3873 src/fileio.c         struct buffer *cb = current_buffer;</span>
<span class='curline'><a href='../S/197.html#L4151'>buffer</a>           4151 src/fileio.c   		  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/197.html#L4153'>buffer</a>           4153 src/fileio.c   		  struct buffer *buf;</span>
<span class='curline'><a href='../S/197.html#L5224'>buffer</a>           5224 src/fileio.c     struct buffer *given_buffer;</span>
<span class='curline'><a href='../S/197.html#L5583'>buffer</a>           5583 src/fileio.c         struct buffer *given_buffer = current_buffer;</span>
<span class='curline'><a href='../S/197.html#L5620'>buffer</a>           5620 src/fileio.c         struct buffer *given_buffer = current_buffer;</span>
<span class='curline'><a href='../S/197.html#L5809'>buffer</a>           5809 src/fileio.c     struct buffer *b = decode_buffer (buf);</span>
<span class='curline'><a href='../S/197.html#L5838'>buffer</a>           5838 src/fileio.c   buffer_visited_file_modtime (struct buffer *buf)</span>
<span class='curline'><a href='../S/197.html#L6013'>buffer</a>           6013 src/fileio.c     struct buffer *old = current_buffer, *b;</span>
<span class='curline'><a href='../S/317.html#L763'>buffer</a>            763 src/filelock.c   register struct buffer *b;</span>
<span class='curline'><a href='../S/317.html#L857'>buffer</a>            857 src/filelock.c unlock_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/317.html#L859'>buffer</a>            859 src/filelock.c   if (BUF_SAVE_MODIFF (buffer) &lt; BUF_MODIFF (buffer)</span>
<span class='curline'><a href='../S/317.html#L860'>buffer</a>            860 src/filelock.c       &amp;&amp; STRINGP (BVAR (buffer, file_truename)))</span>
<span class='curline'><a href='../S/317.html#L861'>buffer</a>            861 src/filelock.c     Funlock_file (BVAR (buffer, file_truename));</span>
<span class='curline'><a href='../S/113.html#L2819'>buffer</a>           2819 src/fns.c      	    return (XMARKER (o1)-&gt;buffer == XMARKER (o2)-&gt;buffer</span>
<span class='curline'><a href='../S/113.html#L2820'>buffer</a>           2820 src/fns.c      		    &amp;&amp; (XMARKER (o1)-&gt;buffer == 0</span>
<span class='curline'><a href='../S/113.html#L5119'>buffer</a>           5119 src/fns.c      	      = XMARKER (obj)-&gt;buffer ? XMARKER (obj)-&gt;bytepos : 0;</span>
<span class='curline'><a href='../S/113.html#L5121'>buffer</a>           5121 src/fns.c      	      = sxhash_combine ((intptr_t) XMARKER (obj)-&gt;buffer, bytepos);</span>
<span class='curline'><a href='../S/113.html#L5617'>buffer</a>           5617 src/fns.c            struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/113.html#L5622'>buffer</a>           5622 src/fns.c            struct buffer *bp = XBUFFER (object);</span>
<span class='curline'><a href='../S/113.html#L5886'>buffer</a>           5886 src/fns.c        Lisp_Object buffer;</span>
<span class='curline'><a href='../S/113.html#L5887'>buffer</a>           5887 src/fns.c        struct buffer *b;</span>
<span class='curline'><a href='../S/113.html#L5891'>buffer</a>           5891 src/fns.c          buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/113.html#L5893'>buffer</a>           5893 src/fns.c          buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/113.html#L5894'>buffer</a>           5894 src/fns.c        if (NILP (buffer))</span>
<span class='curline'><a href='../S/113.html#L5897'>buffer</a>           5897 src/fns.c        b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/113.html#L5926'>buffer</a>           5926 src/fns.c        Lisp_Object buffer;</span>
<span class='curline'><a href='../S/113.html#L5929'>buffer</a>           5929 src/fns.c        struct buffer *b;</span>
<span class='curline'><a href='../S/113.html#L5932'>buffer</a>           5932 src/fns.c          buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/113.html#L5934'>buffer</a>           5934 src/fns.c          buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/113.html#L5935'>buffer</a>           5935 src/fns.c        if (NILP (buffer))</span>
<span class='curline'><a href='../S/113.html#L5938'>buffer</a>           5938 src/fns.c        b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/113.html#L6134'>buffer</a>           6134 src/fns.c            if (XMARKER (position)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/134.html#L414'>buffer</a>            414 src/font.h       unsigned char *buffer;</span>
<span class='curline'><a href='../S/297.html#L3058'>buffer</a>           3058 src/frame.c    frames_discard_buffer (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/297.html#L3065'>buffer</a>           3065 src/frame.c    	(XFRAME (frame), Fdelq (buffer, XFRAME (frame)-&gt;buffer_list));</span>
<span class='curline'><a href='../S/297.html#L3067'>buffer</a>           3067 src/frame.c    	(XFRAME (frame), Fdelq (buffer, XFRAME (frame)-&gt;buried_buffer_list));</span>
<span class='curline'><a href='../S/304.html#L934'>buffer</a>            934 src/fringe.c     struct buffer *oldbuf = current_buffer;</span>
<span class='curline'><a href='../S/202.html#L1665'>buffer</a>           1665 src/ftfont.c     bitmap-&gt;buffer = ft_face-&gt;glyph-&gt;bitmap.buffer;</span>
<span class='curline'><a href='../S/46.html#L1429'>buffer</a>           1429 src/gtkutil.c        char buffer[sizeof format];</span>
<span class='curline'><a href='../S/46.html#L1430'>buffer</a>           1430 src/gtkutil.c        int n = snprintf(buffer, sizeof buffer, format,</span>
<span class='curline'><a href='../S/46.html#L1433'>buffer</a>           1433 src/gtkutil.c        eassert (n &lt; sizeof buffer);</span>
<span class='curline'><a href='../S/46.html#L1435'>buffer</a>           1435 src/gtkutil.c        gtk_css_provider_load_from_data (provider, buffer, -1, NULL);</span>
<span class='curline'><a href='../S/222.html#L5531'>buffer</a>           5531 src/haiku_support.cc   char *buffer;</span>
<span class='curline'><a href='../S/222.html#L5544'>buffer</a>           5544 src/haiku_support.cc   buffer = new (std::nothrow) char[flat];</span>
<span class='curline'><a href='../S/222.html#L5545'>buffer</a>           5545 src/haiku_support.cc   if (!buffer)</span>
<span class='curline'><a href='../S/222.html#L5548'>buffer</a>           5548 src/haiku_support.cc   rc = msg-&gt;Flatten (buffer, flat);</span>
<span class='curline'><a href='../S/222.html#L5551'>buffer</a>           5551 src/haiku_support.cc       delete[] buffer;</span>
<span class='curline'><a href='../S/222.html#L5556'>buffer</a>           5556 src/haiku_support.cc 			   buffer, flat);</span>
<span class='curline'><a href='../S/222.html#L5557'>buffer</a>           5557 src/haiku_support.cc   delete[] buffer;</span>
<span class='curline'><a href='../S/265.html#L2347'>buffer</a>           2347 src/haikufns.c   struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/201.html#L563'>buffer</a>            563 src/haikumenu.c   struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/201.html#L564'>buffer</a>            564 src/haikumenu.c   Lisp_Object buffer;</span>
<span class='curline'><a href='../S/201.html#L617'>buffer</a>            617 src/haikumenu.c       buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/201.html#L630'>buffer</a>            630 src/haikumenu.c       set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/323.html#L4252'>buffer</a>           4252 src/image.c      char buffer[BUFSIZ];</span>
<span class='curline'><a href='../S/323.html#L4261'>buffer</a>           4261 src/image.c         LA1 = xbm_scan (&amp;s, end, buffer, &amp;value)</span>
<span class='curline'><a href='../S/323.html#L4273'>buffer</a>           4273 src/image.c         if (LA1 == XBM_TK_IDENT &amp;&amp; strcmp (buffer, (IDENT)) == 0)	\</span>
<span class='curline'><a href='../S/323.html#L4281'>buffer</a>           4281 src/image.c      LA1 = xbm_scan (&amp;s, end, buffer, &amp;value);</span>
<span class='curline'><a href='../S/323.html#L4292'>buffer</a>           4292 src/image.c    	  char *q = strrchr (buffer, '_');</span>
<span class='curline'><a href='../S/323.html#L4293'>buffer</a>           4293 src/image.c    	  q = q ? q + 1 : buffer;</span>
<span class='curline'><a href='../S/323.html#L4315'>buffer</a>           4315 src/image.c          if (strcmp (buffer, "unsigned") == 0)</span>
<span class='curline'><a href='../S/323.html#L4320'>buffer</a>           4320 src/image.c          else if (strcmp (buffer, "short") == 0)</span>
<span class='curline'><a href='../S/323.html#L4327'>buffer</a>           4327 src/image.c          else if (strcmp (buffer, "char") == 0)</span>
<span class='curline'><a href='../S/323.html#L5174'>buffer</a>           5174 src/image.c          Lisp_Object buffer = image_spec_value (img-&gt;spec, QCdata, NULL);</span>
<span class='curline'><a href='../S/323.html#L5175'>buffer</a>           5175 src/image.c          if (!STRINGP (buffer))</span>
<span class='curline'><a href='../S/323.html#L5177'>buffer</a>           5177 src/image.c    	  image_error ("Invalid image data `%s'", buffer);</span>
<span class='curline'><a href='../S/323.html#L5187'>buffer</a>           5187 src/image.c          rc = XpmCreateImageFromBuffer (&amp;hdc, SSDATA (buffer),</span>
<span class='curline'><a href='../S/323.html#L5191'>buffer</a>           5191 src/image.c          rc = XpmCreateImageFromBuffer (FRAME_X_DISPLAY (f), SSDATA (buffer),</span>
<span class='curline'><a href='../S/323.html#L5531'>buffer</a>           5531 src/image.c      char buffer[BUFSIZ];</span>
<span class='curline'><a href='../S/323.html#L5579'>buffer</a>           5579 src/image.c      memcpy (buffer, beg, len);</span>
<span class='curline'><a href='../S/323.html#L5580'>buffer</a>           5580 src/image.c      buffer[len] = '\0';</span>
<span class='curline'><a href='../S/323.html#L5581'>buffer</a>           5581 src/image.c      if (sscanf (buffer, "%d %d %d %d", &amp;width, &amp;height,</span>
<span class='curline'><a href='../S/323.html#L5633'>buffer</a>           5633 src/image.c          memcpy (buffer, beg + chars_per_pixel, len - chars_per_pixel);</span>
<span class='curline'><a href='../S/323.html#L5634'>buffer</a>           5634 src/image.c          buffer[len - chars_per_pixel] = '\0';</span>
<span class='curline'><a href='../S/323.html#L5636'>buffer</a>           5636 src/image.c          str = strtok (buffer, " \t");</span>
<span class='curline'><a href='../S/323.html#L8064'>buffer</a>           8064 src/image.c      JOCTET *buffer;</span>
<span class='curline'><a href='../S/323.html#L8086'>buffer</a>           8086 src/image.c          bytes = fread (src-&gt;buffer, 1, JPEG_STDIO_BUFFER_SIZE, src-&gt;file);</span>
<span class='curline'><a href='../S/323.html#L8093'>buffer</a>           8093 src/image.c              src-&gt;buffer[0] = (JOCTET) 0xFF;</span>
<span class='curline'><a href='../S/323.html#L8094'>buffer</a>           8094 src/image.c              src-&gt;buffer[1] = (JOCTET) JPEG_EOI;</span>
<span class='curline'><a href='../S/323.html#L8097'>buffer</a>           8097 src/image.c          src-&gt;mgr.next_input_byte = src-&gt;buffer;</span>
<span class='curline'><a href='../S/323.html#L8148'>buffer</a>           8148 src/image.c          src-&gt;buffer = cinfo-&gt;mem-&gt;alloc_small ((j_common_ptr) cinfo,</span>
<span class='curline'><a href='../S/323.html#L8173'>buffer</a>           8173 src/image.c      JSAMPARRAY buffer;</span>
<span class='curline'><a href='../S/323.html#L8316'>buffer</a>           8316 src/image.c      buffer = mgr-&gt;cinfo.mem-&gt;alloc_sarray ((j_common_ptr) &amp;mgr-&gt;cinfo,</span>
<span class='curline'><a href='../S/323.html#L8320'>buffer</a>           8320 src/image.c          jpeg_read_scanlines (&amp;mgr-&gt;cinfo, buffer, 1);</span>
<span class='curline'><a href='../S/323.html#L8322'>buffer</a>           8322 src/image.c    	PUT_PIXEL (ximg, x, y, colors[buffer[0][x]]);</span>
<span class='curline'><a href='../S/323.html#L11698'>buffer</a>           11698 src/image.c      char buffer[sizeof " " + 2 * INT_STRLEN_BOUND (intmax_t)];</span>
<span class='curline'><a href='../S/323.html#L11750'>buffer</a>           11750 src/image.c        = make_formatted_string (buffer, "%"PRIuMAX" %"PRIuMAX,</span>
<span class='curline'><a href='../S/323.html#L11756'>buffer</a>           11756 src/image.c        = make_formatted_string (buffer, "%"PRIuMAX" %"PRIuMAX,</span>
<span class='curline'><a href='../S/299.html#L127'>buffer</a>            127 src/indent.c   recompute_width_table (struct buffer *buf, struct Lisp_Char_Table *disptab)</span>
<span class='curline'><a href='../S/299.html#L147'>buffer</a>            147 src/indent.c     struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/299.html#L220'>buffer</a>            220 src/indent.c     Lisp_Object buffer, tmp;</span>
<span class='curline'><a href='../S/299.html#L225'>buffer</a>            225 src/indent.c     XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/299.html#L233'>buffer</a>            233 src/indent.c     proplimit = Fnext_property_change (position, buffer, Qt);</span>
<span class='curline'><a href='../S/299.html#L250'>buffer</a>            250 src/indent.c   					  buffer, proplimit);</span>
<span class='curline'><a href='../S/299.html#L267'>buffer</a>            267 src/indent.c   			      &amp;&amp; EQ (XWINDOW (window)-&gt;contents, buffer))</span>
<span class='curline'><a href='../S/299.html#L268'>buffer</a>            268 src/indent.c   			     ? window : buffer);</span>
<span class='curline'><a href='../S/299.html#L1245'>buffer</a>           1245 src/indent.c     struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/299.html#L2047'>buffer</a>           2047 src/indent.c         struct buffer *old_buf = current_buffer;</span>
<span class='curline'><a href='../S/299.html#L2062'>buffer</a>           2062 src/indent.c   	       &amp;&amp; XBUFFER (w-&gt;contents) == XMARKER (w-&gt;start)-&gt;buffer))</span>
<span class='curline'><a href='../S/220.html#L57'>buffer</a>             57 src/indent.h   void recompute_width_table (struct buffer *buf,</span>
<span class='curline'><a href='../S/298.html#L320'>buffer</a>            320 src/inotify.c    char *buffer = SAFE_ALLOCA (to_read);</span>
<span class='curline'><a href='../S/298.html#L321'>buffer</a>            321 src/inotify.c    ssize_t n = read (fd, buffer, to_read);</span>
<span class='curline'><a href='../S/298.html#L331'>buffer</a>            331 src/inotify.c        struct inotify_event *ev = (struct inotify_event *) &amp;buffer[i];</span>
<span class='curline'><a href='../S/254.html#L40'>buffer</a>             40 src/insdel.c   static void insert_from_buffer_1 (struct buffer *, ptrdiff_t, ptrdiff_t, bool);</span>
<span class='curline'><a href='../S/254.html#L73'>buffer</a>             73 src/insdel.c         if (tail-&gt;buffer-&gt;text != current_buffer-&gt;text)</span>
<span class='curline'><a href='../S/254.html#L600'>buffer</a>            600 src/insdel.c   make_gap_1 (struct buffer *b, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/254.html#L602'>buffer</a>            602 src/insdel.c     struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/254.html#L1177'>buffer</a>           1177 src/insdel.c   insert_from_buffer (struct buffer *buf,</span>
<span class='curline'><a href='../S/254.html#L1202'>buffer</a>           1202 src/insdel.c   insert_from_buffer_1 (struct buffer *buf,</span>
<span class='curline'><a href='../S/254.html#L1970'>buffer</a>           1970 src/insdel.c     struct buffer *base_buffer;</span>
<span class='curline'><a href='../S/254.html#L2021'>buffer</a>           2021 src/insdel.c         &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer</span>
<span class='curline'><a href='../S/254.html#L2048'>buffer</a>           2048 src/insdel.c   invalidate_buffer_caches (struct buffer *buf, ptrdiff_t start, ptrdiff_t end)</span>
<span class='curline'><a href='../S/254.html#L2075'>buffer</a>           2075 src/insdel.c   	      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/235.html#L468'>buffer</a>            468 src/intervals.c buffer_balance_intervals (struct buffer *b)</span>
<span class='curline'><a href='../S/235.html#L1309'>buffer</a>           1309 src/intervals.c adjust_intervals_for_deletion (struct buffer *buffer,</span>
<span class='curline'><a href='../S/235.html#L1313'>buffer</a>           1313 src/intervals.c   INTERVAL tree = buffer_intervals (buffer);</span>
<span class='curline'><a href='../S/235.html#L1328'>buffer</a>           1328 src/intervals.c       set_buffer_intervals (buffer, NULL);</span>
<span class='curline'><a href='../S/235.html#L1345'>buffer</a>           1345 src/intervals.c       tree = buffer_intervals (buffer);</span>
<span class='curline'><a href='../S/235.html#L1348'>buffer</a>           1348 src/intervals.c 	  set_buffer_intervals (buffer, NULL);</span>
<span class='curline'><a href='../S/235.html#L1360'>buffer</a>           1360 src/intervals.c offset_intervals (struct buffer *buffer, ptrdiff_t start, ptrdiff_t length)</span>
<span class='curline'><a href='../S/235.html#L1362'>buffer</a>           1362 src/intervals.c   if (!buffer_intervals (buffer) || length == 0)</span>
<span class='curline'><a href='../S/235.html#L1366'>buffer</a>           1366 src/intervals.c     adjust_intervals_for_insertion (buffer_intervals (buffer),</span>
<span class='curline'><a href='../S/235.html#L1369'>buffer</a>           1369 src/intervals.c     adjust_intervals_for_deletion (buffer, start, -length);</span>
<span class='curline'><a href='../S/235.html#L1569'>buffer</a>           1569 src/intervals.c 			     ptrdiff_t length, struct buffer *buffer,</span>
<span class='curline'><a href='../S/235.html#L1572'>buffer</a>           1572 src/intervals.c   INTERVAL tree = buffer_intervals (buffer);</span>
<span class='curline'><a href='../S/235.html#L1585'>buffer</a>           1585 src/intervals.c 	  XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/235.html#L1592'>buffer</a>           1592 src/intervals.c       buffer_balance_intervals (buffer);</span>
<span class='curline'><a href='../S/235.html#L1598'>buffer</a>           1598 src/intervals.c   if ((BUF_Z (buffer) - BUF_BEG (buffer)) == length)</span>
<span class='curline'><a href='../S/235.html#L1604'>buffer</a>           1604 src/intervals.c       XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/235.html#L1605'>buffer</a>           1605 src/intervals.c       set_buffer_intervals (buffer, reproduce_tree_obj (source, buf));</span>
<span class='curline'><a href='../S/235.html#L1606'>buffer</a>           1606 src/intervals.c       buffer_intervals (buffer)-&gt;position = BUF_BEG (buffer);</span>
<span class='curline'><a href='../S/235.html#L1607'>buffer</a>           1607 src/intervals.c       eassert (buffer_intervals (buffer)-&gt;up_obj == 1);</span>
<span class='curline'><a href='../S/235.html#L1616'>buffer</a>           1616 src/intervals.c 	XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/235.html#L1699'>buffer</a>           1699 src/intervals.c   buffer_balance_intervals (buffer);</span>
<span class='curline'><a href='../S/235.html#L1753'>buffer</a>           1753 src/intervals.c temp_set_point_both (struct buffer *buffer,</span>
<span class='curline'><a href='../S/235.html#L1757'>buffer</a>           1757 src/intervals.c   eassert (BUF_ZV (buffer) != BUF_ZV_BYTE (buffer) || charpos == bytepos);</span>
<span class='curline'><a href='../S/235.html#L1760'>buffer</a>           1760 src/intervals.c   eassert (charpos &lt;= BUF_ZV (buffer) || BUF_BEGV (buffer) &lt;= charpos);</span>
<span class='curline'><a href='../S/235.html#L1762'>buffer</a>           1762 src/intervals.c   SET_BUF_PT_BOTH (buffer, charpos, bytepos);</span>
<span class='curline'><a href='../S/235.html#L1768'>buffer</a>           1768 src/intervals.c temp_set_point (struct buffer *buffer, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/235.html#L1770'>buffer</a>           1770 src/intervals.c   temp_set_point_both (buffer, charpos,</span>
<span class='curline'><a href='../S/235.html#L1771'>buffer</a>           1771 src/intervals.c 		       buf_charpos_to_bytepos (buffer, charpos));</span>
<span class='curline'><a href='../S/235.html#L1793'>buffer</a>           1793 src/intervals.c   if (XMARKER (marker)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/235.html#L2178'>buffer</a>           2178 src/intervals.c get_local_map (ptrdiff_t position, struct buffer *buffer, Lisp_Object type)</span>
<span class='curline'><a href='../S/235.html#L2184'>buffer</a>           2184 src/intervals.c   position = clip_to_bounds (BUF_BEGV (buffer), position, BUF_ZV (buffer));</span>
<span class='curline'><a href='../S/235.html#L2188'>buffer</a>           2188 src/intervals.c   old_begv = BUF_BEGV (buffer);</span>
<span class='curline'><a href='../S/235.html#L2189'>buffer</a>           2189 src/intervals.c   old_zv = BUF_ZV (buffer);</span>
<span class='curline'><a href='../S/235.html#L2190'>buffer</a>           2190 src/intervals.c   old_begv_byte = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/235.html#L2191'>buffer</a>           2191 src/intervals.c   old_zv_byte = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/235.html#L2194'>buffer</a>           2194 src/intervals.c   SET_BUF_BEGV_BOTH (buffer, BUF_BEG (buffer), BUF_BEG_BYTE (buffer));</span>
<span class='curline'><a href='../S/235.html#L2195'>buffer</a>           2195 src/intervals.c   SET_BUF_ZV_BOTH (buffer, BUF_Z (buffer), BUF_Z_BYTE (buffer));</span>
<span class='curline'><a href='../S/235.html#L2198'>buffer</a>           2198 src/intervals.c   XSETBUFFER (lispy_buffer, buffer);</span>
<span class='curline'><a href='../S/235.html#L2209'>buffer</a>           2209 src/intervals.c   SET_BUF_BEGV_BOTH (buffer, old_begv, old_begv_byte);</span>
<span class='curline'><a href='../S/235.html#L2210'>buffer</a>           2210 src/intervals.c   SET_BUF_ZV_BOTH (buffer, old_zv, old_zv_byte);</span>
<span class='curline'><a href='../S/235.html#L2221'>buffer</a>           2221 src/intervals.c     return BVAR (buffer, keymap);</span>
<span class='curline'><a href='../S/235.html#L2269'>buffer</a>           2269 src/intervals.c copy_intervals_to_string (Lisp_Object string, struct buffer *buffer,</span>
<span class='curline'><a href='../S/235.html#L2272'>buffer</a>           2272 src/intervals.c   INTERVAL interval_copy = copy_intervals (buffer_intervals (buffer),</span>
<span class='curline'><a href='../S/322.html#L259'>buffer</a>            259 src/intervals.h extern void offset_intervals (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/322.html#L261'>buffer</a>            261 src/intervals.h                                          struct buffer *, bool);</span>
<span class='curline'><a href='../S/322.html#L262'>buffer</a>            262 src/intervals.h extern void verify_interval_modification (struct buffer *,</span>
<span class='curline'><a href='../S/322.html#L265'>buffer</a>            265 src/intervals.h extern void copy_intervals_to_string (Lisp_Object, struct buffer *,</span>
<span class='curline'><a href='../S/322.html#L274'>buffer</a>            274 src/intervals.h extern Lisp_Object get_local_map (ptrdiff_t, struct buffer *, Lisp_Object);</span>
<span class='curline'><a href='../S/322.html#L301'>buffer</a>            301 src/intervals.h                                      Lisp_Object buffer);</span>
<span class='curline'><a href='../S/308.html#L644'>buffer</a>            644 src/json.c       const char *buffer;</span>
<span class='curline'><a href='../S/308.html#L665'>buffer</a>            665 src/json.c     	  buffer_and_size-&gt;buffer, len);</span>
<span class='curline'><a href='../S/308.html#L701'>buffer</a>            701 src/json.c     json_insert_callback (const char *buffer, size_t size, void *data)</span>
<span class='curline'><a href='../S/308.html#L705'>buffer</a>            705 src/json.c         = {.buffer = buffer, .size = size, .inserted_bytes = d-&gt;inserted_bytes};</span>
<span class='curline'><a href='../S/308.html#L1009'>buffer</a>           1009 src/json.c     json_read_buffer_callback (void *buffer, size_t buflen, void *data)</span>
<span class='curline'><a href='../S/308.html#L1020'>buffer</a>           1020 src/json.c       memcpy (buffer, BYTE_POS_ADDR (point), count);</span>
<span class='curline'><a href='../S/53.html#L217'>buffer</a>            217 src/keyboard.c struct buffer *buffer_before_last_command_or_undo;</span>
<span class='curline'><a href='../S/53.html#L315'>buffer</a>            315 src/keyboard.c static void recursive_edit_unwind (Lisp_Object buffer);</span>
<span class='curline'><a href='../S/53.html#L480'>buffer</a>            480 src/keyboard.c   char *buffer = initbuf;</span>
<span class='curline'><a href='../S/53.html#L481'>buffer</a>            481 src/keyboard.c   char *ptr = buffer;</span>
<span class='curline'><a href='../S/53.html#L499'>buffer</a>            499 src/keyboard.c       if (size - (ptr - buffer) &lt; nbytes)</span>
<span class='curline'><a href='../S/53.html#L501'>buffer</a>            501 src/keyboard.c 	  ptrdiff_t offset = ptr - buffer;</span>
<span class='curline'><a href='../S/53.html#L503'>buffer</a>            503 src/keyboard.c 	  buffer = SAFE_ALLOCA (size);</span>
<span class='curline'><a href='../S/53.html#L504'>buffer</a>            504 src/keyboard.c 	  ptr = buffer + offset;</span>
<span class='curline'><a href='../S/53.html#L511'>buffer</a>            511 src/keyboard.c   Lisp_Object new_string = make_string (buffer, ptr - buffer);</span>
<span class='curline'><a href='../S/53.html#L776'>buffer</a>            776 src/keyboard.c   Lisp_Object buffer;</span>
<span class='curline'><a href='../S/53.html#L785'>buffer</a>            785 src/keyboard.c     buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/53.html#L787'>buffer</a>            787 src/keyboard.c     buffer = Qnil;</span>
<span class='curline'><a href='../S/53.html#L794'>buffer</a>            794 src/keyboard.c   record_unwind_protect (recursive_edit_unwind, buffer);</span>
<span class='curline'><a href='../S/53.html#L808'>buffer</a>            808 src/keyboard.c recursive_edit_unwind (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/53.html#L810'>buffer</a>            810 src/keyboard.c   if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/53.html#L811'>buffer</a>            811 src/keyboard.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/53.html#L1280'>buffer</a>           1280 src/keyboard.c   struct buffer *prev_buffer = NULL;</span>
<span class='curline'><a href='../S/53.html#L1417'>buffer</a>           1417 src/keyboard.c 	  struct buffer *b;</span>
<span class='curline'><a href='../S/53.html#L1580'>buffer</a>           1580 src/keyboard.c 		  &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer</span>
<span class='curline'><a href='../S/53.html#L3023'>buffer</a>           3023 src/keyboard.c       struct buffer *prev_buffer = current_buffer;</span>
<span class='curline'><a href='../S/53.html#L9900'>buffer</a>           9900 src/keyboard.c   struct buffer *starting_buffer;</span>
<span class='curline'><a href='../S/259.html#L260'>buffer</a>            260 src/keyboard.h extern struct buffer *buffer_before_last_command_or_undo;</span>
<span class='curline'><a href='../S/259.html#L262'>buffer</a>            262 src/keyboard.h extern struct buffer *prev_buffer;</span>
<span class='curline'><a href='../S/285.html#L2346'>buffer</a>           2346 src/keymap.c   	  char *buffer = SAFE_ALLOCA (len + 3);</span>
<span class='curline'><a href='../S/285.html#L2347'>buffer</a>           2347 src/keymap.c   	  memcpy (buffer, sym, i);</span>
<span class='curline'><a href='../S/285.html#L2348'>buffer</a>           2348 src/keymap.c   	  buffer[i] = '&lt;';</span>
<span class='curline'><a href='../S/285.html#L2349'>buffer</a>           2349 src/keymap.c   	  memcpy (buffer + i + 1, sym + i, len - i);</span>
<span class='curline'><a href='../S/285.html#L2350'>buffer</a>           2350 src/keymap.c   	  buffer [len + 1] = '&gt;';</span>
<span class='curline'><a href='../S/285.html#L2351'>buffer</a>           2351 src/keymap.c   	  buffer [len + 2] = '\0';</span>
<span class='curline'><a href='../S/285.html#L2352'>buffer</a>           2352 src/keymap.c   	  Lisp_Object result = build_string (buffer);</span>
<span class='curline'><a href='../S/285.html#L2836'>buffer</a>           2836 src/keymap.c     (Lisp_Object buffer, Lisp_Object prefix, Lisp_Object menus)</span>
<span class='curline'><a href='../S/285.html#L2846'>buffer</a>           2846 src/keymap.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/285.html#L2890'>buffer</a>           2890 src/keymap.c   	     msg, nomenu, Qt, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/285.html#L2904'>buffer</a>           2904 src/keymap.c   	     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/285.html#L2917'>buffer</a>           2917 src/keymap.c   	     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/285.html#L2927'>buffer</a>           2927 src/keymap.c         Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/285.html#L2932'>buffer</a>           2932 src/keymap.c         start1 = get_local_map (BUF_PT (XBUFFER (buffer)),</span>
<span class='curline'><a href='../S/285.html#L2933'>buffer</a>           2933 src/keymap.c   			      XBUFFER (buffer), Qkeymap);</span>
<span class='curline'><a href='../S/285.html#L2940'>buffer</a>           2940 src/keymap.c   		 msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/285.html#L2973'>buffer</a>           2973 src/keymap.c   		 msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/285.html#L2978'>buffer</a>           2978 src/keymap.c         start1 = get_local_map (BUF_PT (XBUFFER (buffer)),</span>
<span class='curline'><a href='../S/285.html#L2979'>buffer</a>           2979 src/keymap.c   			      XBUFFER (buffer), Qlocal_map);</span>
<span class='curline'><a href='../S/285.html#L2982'>buffer</a>           2982 src/keymap.c   	  if (EQ (start1, BVAR (XBUFFER (buffer), keymap)))</span>
<span class='curline'><a href='../S/285.html#L2987'>buffer</a>           2987 src/keymap.c   		       XBUFFER (buffer)-&gt;major_mode_);</span>
<span class='curline'><a href='../S/285.html#L2991'>buffer</a>           2991 src/keymap.c   		     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/285.html#L2999'>buffer</a>           2999 src/keymap.c   		     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/285.html#L3010'>buffer</a>           3010 src/keymap.c   	 msg, nomenu, Qnil, Qt, Qnil, buffer);</span>
<span class='curline'><a href='../S/285.html#L3019'>buffer</a>           3019 src/keymap.c   	     msg, nomenu, Qt, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/285.html#L3029'>buffer</a>           3029 src/keymap.c   	     msg, nomenu, Qt, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/285.html#L3319'>buffer</a>           3319 src/keymap.c   	      char *buffer =</span>
<span class='curline'><a href='../S/285.html#L3321'>buffer</a>           3321 src/keymap.c   	      esprintf (buffer, fmt, SDATA (SYMBOL_NAME (shadowed_by)));</span>
<span class='curline'><a href='../S/285.html#L3322'>buffer</a>           3322 src/keymap.c   	      insert_string (buffer);</span>
<span class='curline'><a href='../S/125.html#L641'>buffer</a>            641 src/lisp.h     extern char *fixnum_to_string (EMACS_INT number, char *buffer, char *end);</span>
<span class='curline'><a href='../S/125.html#L2575'>buffer</a>           2575 src/lisp.h       struct buffer *buffer;</span>
<span class='curline'><a href='../S/125.html#L2615'>buffer</a>           2615 src/lisp.h         struct buffer *buffer;        /* eassert (live buffer || NULL). */</span>
<span class='curline'><a href='../S/125.html#L4091'>buffer</a>           4091 src/lisp.h     extern void make_gap_1 (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/125.html#L4106'>buffer</a>           4106 src/lisp.h     extern void insert_from_buffer (struct buffer *, ptrdiff_t, ptrdiff_t, bool);</span>
<span class='curline'><a href='../S/125.html#L4123'>buffer</a>           4123 src/lisp.h     extern void invalidate_buffer_caches (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/125.html#L4432'>buffer</a>           4432 src/lisp.h     extern struct buffer *allocate_buffer (void) ATTRIBUTE_RETURNS_NONNULL;</span>
<span class='curline'><a href='../S/125.html#L4717'>buffer</a>           4717 src/lisp.h     extern void clear_charpos_cache (struct buffer *);</span>
<span class='curline'><a href='../S/125.html#L4718'>buffer</a>           4718 src/lisp.h     extern ptrdiff_t buf_charpos_to_bytepos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/125.html#L4719'>buffer</a>           4719 src/lisp.h     extern ptrdiff_t buf_bytepos_to_charpos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/125.html#L4726'>buffer</a>           4726 src/lisp.h     extern Lisp_Object build_marker (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/125.html#L4752'>buffer</a>           4752 src/lisp.h     extern Lisp_Object buffer_visited_file_modtime (struct buffer *);</span>
<span class='curline'><a href='../S/125.html#L5016'>buffer</a>           5016 src/lisp.h     extern void truncate_undo_list (struct buffer *);</span>
<span class='curline'><a href='../S/125.html#L5087'>buffer</a>           5087 src/lisp.h     extern void unlock_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/165.html#L209'>buffer</a>            209 src/lread.c          register struct buffer *inbuffer = XBUFFER (readcharfun);</span>
<span class='curline'><a href='../S/165.html#L242'>buffer</a>            242 src/lread.c          register struct buffer *inbuffer = XMARKER (readcharfun)-&gt;buffer;</span>
<span class='curline'><a href='../S/165.html#L423'>buffer</a>            423 src/lread.c          struct buffer *b = XBUFFER (readcharfun);</span>
<span class='curline'><a href='../S/165.html#L436'>buffer</a>            436 src/lread.c          struct buffer *b = XMARKER (readcharfun)-&gt;buffer;</span>
<span class='curline'><a href='../S/165.html#L2186'>buffer</a>           2186 src/lread.c      struct buffer *b = 0;</span>
<span class='curline'><a href='../S/165.html#L2214'>buffer</a>           2214 src/lread.c        b = XMARKER (readcharfun)-&gt;buffer;</span>
<span class='curline'><a href='../S/165.html#L2322'>buffer</a>           2322 src/lread.c    		  struct buffer *buf = XBUFFER (readcharfun);</span>
<span class='curline'><a href='../S/165.html#L2395'>buffer</a>           2395 src/lread.c      (Lisp_Object buffer, Lisp_Object printflag, Lisp_Object filename, Lisp_Object unibyte, Lisp_Object do_allow_print)</span>
<span class='curline'><a href='../S/165.html#L2400'>buffer</a>           2400 src/lread.c      if (NILP (buffer))</span>
<span class='curline'><a href='../S/165.html#L2403'>buffer</a>           2403 src/lread.c        buf = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/165.html#L5402'>buffer</a>           5402 src/lread.c          char *buffer = SAFE_ALLOCA (sizeof format - 3 * (sizeof "%s" - 1)</span>
<span class='curline'><a href='../S/165.html#L5404'>buffer</a>           5404 src/lread.c          ptrdiff_t message_len = esprintf (buffer, format, use, SSDATA (dirname),</span>
<span class='curline'><a href='../S/165.html#L5406'>buffer</a>           5406 src/lread.c          message_dolog (buffer, message_len, 0, STRING_MULTIBYTE (dirname));</span>
<span class='curline'><a href='../S/242.html#L32'>buffer</a>             32 src/marker.c   static struct buffer *cached_buffer;</span>
<span class='curline'><a href='../S/242.html#L41'>buffer</a>             41 src/marker.c   extern int count_markers (struct buffer *) EXTERNALLY_VISIBLE;</span>
<span class='curline'><a href='../S/242.html#L45'>buffer</a>             45 src/marker.c   byte_char_debug_check (struct buffer *b, ptrdiff_t charpos, ptrdiff_t bytepos)</span>
<span class='curline'><a href='../S/242.html#L73'>buffer</a>             73 src/marker.c   clear_charpos_cache (struct buffer *b)</span>
<span class='curline'><a href='../S/242.html#L161'>buffer</a>            161 src/marker.c   buf_charpos_to_bytepos (struct buffer *b, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/242.html#L318'>buffer</a>            318 src/marker.c   buf_bytepos_to_charpos (struct buffer *b, ptrdiff_t bytepos)</span>
<span class='curline'><a href='../S/242.html#L436'>buffer</a>            436 src/marker.c     if (XMARKER (marker)-&gt;buffer)</span>
<span class='curline'><a href='../S/242.html#L438'>buffer</a>            438 src/marker.c         XSETBUFFER (buf, XMARKER (marker)-&gt;buffer);</span>
<span class='curline'><a href='../S/242.html#L454'>buffer</a>            454 src/marker.c     if (XMARKER (marker)-&gt;buffer)</span>
<span class='curline'><a href='../S/242.html#L463'>buffer</a>            463 src/marker.c   attach_marker (struct Lisp_Marker *m, struct buffer *b,</span>
<span class='curline'><a href='../S/242.html#L476'>buffer</a>            476 src/marker.c     if (m-&gt;buffer != b)</span>
<span class='curline'><a href='../S/242.html#L479'>buffer</a>            479 src/marker.c         m-&gt;buffer = b;</span>
<span class='curline'><a href='../S/242.html#L489'>buffer</a>            489 src/marker.c   static struct buffer *</span>
<span class='curline'><a href='../S/242.html#L490'>buffer</a>            490 src/marker.c   live_buffer (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/242.html#L492'>buffer</a>            492 src/marker.c     struct buffer *b = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/242.html#L501'>buffer</a>            501 src/marker.c   		     Lisp_Object buffer, bool restricted)</span>
<span class='curline'><a href='../S/242.html#L504'>buffer</a>            504 src/marker.c     struct buffer *b = live_buffer (buffer);</span>
<span class='curline'><a href='../S/242.html#L512'>buffer</a>            512 src/marker.c         || (MARKERP (position) &amp;&amp; !XMARKER (position)-&gt;buffer)</span>
<span class='curline'><a href='../S/242.html#L518'>buffer</a>            518 src/marker.c     else if (MARKERP (position) &amp;&amp; b == XMARKER (position)-&gt;buffer</span>
<span class='curline'><a href='../S/242.html#L519'>buffer</a>            519 src/marker.c   	   &amp;&amp; b == m-&gt;buffer)</span>
<span class='curline'><a href='../S/242.html#L560'>buffer</a>            560 src/marker.c   	  || !(MARKERP (position) &amp;&amp; XMARKER (position)-&gt;buffer == b))</span>
<span class='curline'><a href='../S/242.html#L577'>buffer</a>            577 src/marker.c     (Lisp_Object marker, Lisp_Object position, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/242.html#L579'>buffer</a>            579 src/marker.c     return set_marker_internal (marker, position, buffer, false);</span>
<span class='curline'><a href='../S/242.html#L586'>buffer</a>            586 src/marker.c   		       Lisp_Object buffer)</span>
<span class='curline'><a href='../S/242.html#L588'>buffer</a>            588 src/marker.c     return set_marker_internal (marker, position, buffer, true);</span>
<span class='curline'><a href='../S/242.html#L595'>buffer</a>            595 src/marker.c   set_marker_both (Lisp_Object marker, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/242.html#L599'>buffer</a>            599 src/marker.c     register struct buffer *b = live_buffer (buffer);</span>
<span class='curline'><a href='../S/242.html#L614'>buffer</a>            614 src/marker.c   set_marker_restricted_both (Lisp_Object marker, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/242.html#L618'>buffer</a>            618 src/marker.c     register struct buffer *b = live_buffer (buffer);</span>
<span class='curline'><a href='../S/242.html#L651'>buffer</a>            651 src/marker.c     register struct buffer *b = marker-&gt;buffer;</span>
<span class='curline'><a href='../S/242.html#L660'>buffer</a>            660 src/marker.c         marker-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/242.html#L672'>buffer</a>            672 src/marker.c   		if (tail-&gt;next &amp;&amp; b-&gt;text != tail-&gt;next-&gt;buffer-&gt;text)</span>
<span class='curline'><a href='../S/242.html#L692'>buffer</a>            692 src/marker.c     register struct buffer *buf = m-&gt;buffer;</span>
<span class='curline'><a href='../S/242.html#L708'>buffer</a>            708 src/marker.c     register struct buffer *buf = m-&gt;buffer;</span>
<span class='curline'><a href='../S/242.html#L767'>buffer</a>            767 src/marker.c   count_markers (struct buffer *buf)</span>
<span class='curline'><a href='../S/64.html#L388'>buffer</a>            388 src/minibuf.c  live_minibuffer_p (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/64.html#L393'>buffer</a>            393 src/minibuf.c    if (EQ (buffer, Fcar (Vminibuffer_list)))</span>
<span class='curline'><a href='../S/64.html#L398'>buffer</a>            398 src/minibuf.c      if (EQ (Fcar (tem), buffer))</span>
<span class='curline'><a href='../S/64.html#L409'>buffer</a>            409 src/minibuf.c    (Lisp_Object buffer, Lisp_Object live)</span>
<span class='curline'><a href='../S/64.html#L411'>buffer</a>            411 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/64.html#L412'>buffer</a>            412 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/64.html#L413'>buffer</a>            413 src/minibuf.c    else if (STRINGP (buffer))</span>
<span class='curline'><a href='../S/64.html#L414'>buffer</a>            414 src/minibuf.c      buffer = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/64.html#L416'>buffer</a>            416 src/minibuf.c      CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/64.html#L419'>buffer</a>            419 src/minibuf.c            ? !NILP (Fmemq (buffer, Vminibuffer_list))</span>
<span class='curline'><a href='../S/64.html#L420'>buffer</a>            420 src/minibuf.c            : live_minibuffer_p (buffer))</span>
<span class='curline'><a href='../S/64.html#L428'>buffer</a>            428 src/minibuf.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/64.html#L430'>buffer</a>            430 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/64.html#L431'>buffer</a>            431 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/64.html#L432'>buffer</a>            432 src/minibuf.c    return BASE_EQ (buffer, (Fcar (Fnthcdr (make_fixnum (minibuf_level),</span>
<span class='curline'><a href='../S/64.html#L442'>buffer</a>            442 src/minibuf.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/64.html#L445'>buffer</a>            445 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/64.html#L446'>buffer</a>            446 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/64.html#L447'>buffer</a>            447 src/minibuf.c    depth = this_minibuffer_depth (buffer);</span>
<span class='curline'><a href='../S/64.html#L457'>buffer</a>            457 src/minibuf.c  this_minibuffer_depth (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/64.html#L462'>buffer</a>            462 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/64.html#L463'>buffer</a>            463 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/64.html#L467'>buffer</a>            467 src/minibuf.c      if (EQ (Fcar (bufs), buffer))</span>
<span class='curline'><a href='../S/310.html#L1322'>buffer</a>           1322 src/msdos.c          struct buffer *b = XBUFFER (sw-&gt;contents);</span>
<span class='curline'><a href='../S/310.html#L3899'>buffer</a>           3899 src/msdos.c    readlinkat (int fd, char const *name, char *buffer, size_t buffer_size)</span>
<span class='curline'><a href='../S/310.html#L3916'>buffer</a>           3916 src/msdos.c      return readlink (name, buffer, buffer_size);</span>
<span class='curline'><a href='../S/310.html#L3965'>buffer</a>           3965 src/msdos.c                  char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/310.html#L3969'>buffer</a>           3969 src/msdos.c      if (!buffer)</span>
<span class='curline'><a href='../S/310.html#L3976'>buffer</a>           3976 src/msdos.c          buffer = NULL;</span>
<span class='curline'><a href='../S/310.html#L3980'>buffer</a>           3980 src/msdos.c          ssize_t len = preadlinkat (fd, filename, buffer, buffer_size);</span>
<span class='curline'><a href='../S/310.html#L3983'>buffer</a>           3983 src/msdos.c    	buffer = NULL;</span>
<span class='curline'><a href='../S/310.html#L3985'>buffer</a>           3985 src/msdos.c    	buffer[len + 1] = '\0';</span>
<span class='curline'><a href='../S/310.html#L3987'>buffer</a>           3987 src/msdos.c      return buffer;</span>
<span class='curline'><a href='../S/311.html#L2124'>buffer</a>           2124 src/pdumper.c    if (marker-&gt;buffer)</span>
<span class='curline'><a href='../S/311.html#L2126'>buffer</a>           2126 src/pdumper.c        dump_field_lv_rawptr (ctx, out, marker, &amp;marker-&gt;buffer,</span>
<span class='curline'><a href='../S/311.html#L2749'>buffer</a>           2749 src/pdumper.c  dump_buffer (struct dump_context *ctx, const struct buffer *in_buffer)</span>
<span class='curline'><a href='../S/311.html#L2754'>buffer</a>           2754 src/pdumper.c    struct buffer munged_buffer = *in_buffer;</span>
<span class='curline'><a href='../S/311.html#L2755'>buffer</a>           2755 src/pdumper.c    struct buffer *buffer = &amp;munged_buffer;</span>
<span class='curline'><a href='../S/311.html#L2758'>buffer</a>           2758 src/pdumper.c    if (buffer-&gt;base_buffer == NULL)</span>
<span class='curline'><a href='../S/311.html#L2759'>buffer</a>           2759 src/pdumper.c      buffer-&gt;window_count = 0;</span>
<span class='curline'><a href='../S/311.html#L2761'>buffer</a>           2761 src/pdumper.c      eassert (buffer-&gt;window_count == -1);</span>
<span class='curline'><a href='../S/311.html#L2762'>buffer</a>           2762 src/pdumper.c    buffer-&gt;local_minor_modes_ = Qnil;</span>
<span class='curline'><a href='../S/311.html#L2763'>buffer</a>           2763 src/pdumper.c    buffer-&gt;last_selected_window_ = Qnil;</span>
<span class='curline'><a href='../S/311.html#L2764'>buffer</a>           2764 src/pdumper.c    buffer-&gt;display_count_ = make_fixnum (0);</span>
<span class='curline'><a href='../S/311.html#L2765'>buffer</a>           2765 src/pdumper.c    buffer-&gt;clip_changed = 0;</span>
<span class='curline'><a href='../S/311.html#L2766'>buffer</a>           2766 src/pdumper.c    buffer-&gt;last_window_start = -1;</span>
<span class='curline'><a href='../S/311.html#L2767'>buffer</a>           2767 src/pdumper.c    buffer-&gt;point_before_scroll_ = Qnil;</span>
<span class='curline'><a href='../S/311.html#L2770'>buffer</a>           2770 src/pdumper.c    if (buffer-&gt;base_buffer)</span>
<span class='curline'><a href='../S/311.html#L2772'>buffer</a>           2772 src/pdumper.c        eassert (buffer-&gt;base_buffer-&gt;base_buffer == NULL);</span>
<span class='curline'><a href='../S/311.html#L2775'>buffer</a>           2775 src/pdumper.c  	 make_lisp_ptr (buffer-&gt;base_buffer, Lisp_Vectorlike));</span>
<span class='curline'><a href='../S/311.html#L2778'>buffer</a>           2778 src/pdumper.c    eassert ((base_offset == 0 &amp;&amp; buffer-&gt;text == &amp;in_buffer-&gt;own_text)</span>
<span class='curline'><a href='../S/311.html#L2779'>buffer</a>           2779 src/pdumper.c  	   || (base_offset &gt; 0 &amp;&amp; buffer-&gt;text != &amp;in_buffer-&gt;own_text));</span>
<span class='curline'><a href='../S/311.html#L2781'>buffer</a>           2781 src/pdumper.c    START_DUMP_PVEC (ctx, &amp;buffer-&gt;header, struct buffer, out);</span>
<span class='curline'><a href='../S/311.html#L2782'>buffer</a>           2782 src/pdumper.c    dump_pseudovector_lisp_fields (ctx, &amp;out-&gt;header, &amp;buffer-&gt;header);</span>
<span class='curline'><a href='../S/311.html#L2786'>buffer</a>           2786 src/pdumper.c    if (buffer-&gt;base_buffer == NULL)</span>
<span class='curline'><a href='../S/311.html#L2790'>buffer</a>           2790 src/pdumper.c        if (BUFFER_LIVE_P (buffer))</span>
<span class='curline'><a href='../S/311.html#L2792'>buffer</a>           2792 src/pdumper.c            dump_field_fixup_later (ctx, out, buffer, &amp;buffer-&gt;own_text.beg);</span>
<span class='curline'><a href='../S/311.html#L2798'>buffer</a>           2798 src/pdumper.c          eassert (buffer-&gt;own_text.beg == NULL);</span>
<span class='curline'><a href='../S/311.html#L2800'>buffer</a>           2800 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.gpt);</span>
<span class='curline'><a href='../S/311.html#L2801'>buffer</a>           2801 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.z);</span>
<span class='curline'><a href='../S/311.html#L2802'>buffer</a>           2802 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.gpt_byte);</span>
<span class='curline'><a href='../S/311.html#L2803'>buffer</a>           2803 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.z_byte);</span>
<span class='curline'><a href='../S/311.html#L2804'>buffer</a>           2804 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.gap_size);</span>
<span class='curline'><a href='../S/311.html#L2805'>buffer</a>           2805 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.modiff);</span>
<span class='curline'><a href='../S/311.html#L2806'>buffer</a>           2806 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.chars_modiff);</span>
<span class='curline'><a href='../S/311.html#L2807'>buffer</a>           2807 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.save_modiff);</span>
<span class='curline'><a href='../S/311.html#L2808'>buffer</a>           2808 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.overlay_modiff);</span>
<span class='curline'><a href='../S/311.html#L2809'>buffer</a>           2809 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.compact);</span>
<span class='curline'><a href='../S/311.html#L2810'>buffer</a>           2810 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.beg_unchanged);</span>
<span class='curline'><a href='../S/311.html#L2811'>buffer</a>           2811 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.end_unchanged);</span>
<span class='curline'><a href='../S/311.html#L2812'>buffer</a>           2812 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.unchanged_modified);</span>
<span class='curline'><a href='../S/311.html#L2813'>buffer</a>           2813 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.overlay_unchanged_modified);</span>
<span class='curline'><a href='../S/311.html#L2814'>buffer</a>           2814 src/pdumper.c        if (buffer-&gt;own_text.intervals)</span>
<span class='curline'><a href='../S/311.html#L2815'>buffer</a>           2815 src/pdumper.c          dump_field_fixup_later (ctx, out, buffer, &amp;buffer-&gt;own_text.intervals);</span>
<span class='curline'><a href='../S/311.html#L2816'>buffer</a>           2816 src/pdumper.c        dump_field_lv_rawptr (ctx, out, buffer, &amp;buffer-&gt;own_text.markers,</span>
<span class='curline'><a href='../S/311.html#L2818'>buffer</a>           2818 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.inhibit_shrinking);</span>
<span class='curline'><a href='../S/311.html#L2819'>buffer</a>           2819 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.redisplay);</span>
<span class='curline'><a href='../S/311.html#L2825'>buffer</a>           2825 src/pdumper.c       ctx-&gt;obj_offset + dump_offsetof (struct buffer, text),</span>
<span class='curline'><a href='../S/311.html#L2826'>buffer</a>           2826 src/pdumper.c       base_offset + dump_offsetof (struct buffer, own_text));</span>
<span class='curline'><a href='../S/311.html#L2828'>buffer</a>           2828 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, pt);</span>
<span class='curline'><a href='../S/311.html#L2829'>buffer</a>           2829 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, pt_byte);</span>
<span class='curline'><a href='../S/311.html#L2830'>buffer</a>           2830 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, begv);</span>
<span class='curline'><a href='../S/311.html#L2831'>buffer</a>           2831 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, begv_byte);</span>
<span class='curline'><a href='../S/311.html#L2832'>buffer</a>           2832 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, zv);</span>
<span class='curline'><a href='../S/311.html#L2833'>buffer</a>           2833 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, zv_byte);</span>
<span class='curline'><a href='../S/311.html#L2835'>buffer</a>           2835 src/pdumper.c    if (buffer-&gt;base_buffer)</span>
<span class='curline'><a href='../S/311.html#L2838'>buffer</a>           2838 src/pdumper.c        dump_field_ptr_to_dump_offset (ctx, out, buffer, &amp;buffer-&gt;base_buffer,</span>
<span class='curline'><a href='../S/311.html#L2842'>buffer</a>           2842 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, indirections);</span>
<span class='curline'><a href='../S/311.html#L2843'>buffer</a>           2843 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, window_count);</span>
<span class='curline'><a href='../S/311.html#L2846'>buffer</a>           2846 src/pdumper.c            &amp;buffer-&gt;local_flags,</span>
<span class='curline'><a href='../S/311.html#L2848'>buffer</a>           2848 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, modtime);</span>
<span class='curline'><a href='../S/311.html#L2849'>buffer</a>           2849 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, modtime_size);</span>
<span class='curline'><a href='../S/311.html#L2850'>buffer</a>           2850 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, auto_save_modified);</span>
<span class='curline'><a href='../S/311.html#L2851'>buffer</a>           2851 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, display_error_modiff);</span>
<span class='curline'><a href='../S/311.html#L2852'>buffer</a>           2852 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, auto_save_failure_time);</span>
<span class='curline'><a href='../S/311.html#L2853'>buffer</a>           2853 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, last_window_start);</span>
<span class='curline'><a href='../S/311.html#L2860'>buffer</a>           2860 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, prevent_redisplay_optimizations_p);</span>
<span class='curline'><a href='../S/311.html#L2861'>buffer</a>           2861 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, clip_changed);</span>
<span class='curline'><a href='../S/311.html#L2862'>buffer</a>           2862 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, inhibit_buffer_hooks);</span>
<span class='curline'><a href='../S/311.html#L2863'>buffer</a>           2863 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, long_line_optimizations_p);</span>
<span class='curline'><a href='../S/311.html#L2865'>buffer</a>           2865 src/pdumper.c    if (buffer-&gt;overlays &amp;&amp; buffer-&gt;overlays-&gt;root != NULL)</span>
<span class='curline'><a href='../S/311.html#L2871'>buffer</a>           2871 src/pdumper.c    dump_field_lv (ctx, out, buffer, &amp;buffer-&gt;undo_list_,</span>
<span class='curline'><a href='../S/311.html#L2874'>buffer</a>           2874 src/pdumper.c    if (!buffer-&gt;base_buffer &amp;&amp; buffer-&gt;own_text.intervals)</span>
<span class='curline'><a href='../S/311.html#L2877'>buffer</a>           2877 src/pdumper.c         offset + dump_offsetof (struct buffer, own_text.intervals),</span>
<span class='curline'><a href='../S/311.html#L2878'>buffer</a>           2878 src/pdumper.c         dump_interval_tree (ctx, buffer-&gt;own_text.intervals, 0));</span>
<span class='curline'><a href='../S/311.html#L3428'>buffer</a>           3428 src/pdumper.c    struct buffer *b = XBUFFER (data);</span>
<span class='curline'><a href='../S/311.html#L3442'>buffer</a>           3442 src/pdumper.c       buffer_offset + dump_offsetof (struct buffer, own_text.beg),</span>
<span class='curline'><a href='../S/124.html#L3128'>buffer</a>           3128 src/pgtkfns.c    struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/331.html#L259'>buffer</a>            259 src/pgtkmenu.c       struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/331.html#L260'>buffer</a>            260 src/pgtkmenu.c       Lisp_Object buffer;</span>
<span class='curline'><a href='../S/331.html#L272'>buffer</a>            272 src/pgtkmenu.c       buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/331.html#L285'>buffer</a>            285 src/pgtkmenu.c       set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/132.html#L71'>buffer</a>             71 src/print.c      char *buffer;			/* Allocated buffer.  */</span>
<span class='curline'><a href='../S/132.html#L103'>buffer</a>            103 src/print.c      xfree (print_buffer.buffer);</span>
<span class='curline'><a href='../S/132.html#L104'>buffer</a>            104 src/print.c      print_buffer.buffer = NULL;</span>
<span class='curline'><a href='../S/132.html#L112'>buffer</a>            112 src/print.c      memcpy (print_buffer.buffer, SDATA (saved_text), SCHARS (saved_text));</span>
<span class='curline'><a href='../S/132.html#L154'>buffer</a>            154 src/print.c          if (! XMARKER (printcharfun)-&gt;buffer)</span>
<span class='curline'><a href='../S/132.html#L156'>buffer</a>            156 src/print.c          if (XMARKER (printcharfun)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/132.html#L157'>buffer</a>            157 src/print.c    	set_buffer_internal (XMARKER (printcharfun)-&gt;buffer);</span>
<span class='curline'><a href='../S/132.html#L177'>buffer</a>            177 src/print.c          if (print_buffer.buffer != NULL)</span>
<span class='curline'><a href='../S/132.html#L179'>buffer</a>            179 src/print.c    	  Lisp_Object string = make_string_from_bytes (print_buffer.buffer,</span>
<span class='curline'><a href='../S/132.html#L187'>buffer</a>            187 src/print.c    	  print_buffer.buffer = xmalloc (new_size);</span>
<span class='curline'><a href='../S/132.html#L210'>buffer</a>            210 src/print.c    	  copy_text ((unsigned char *) print_buffer.buffer, temp,</span>
<span class='curline'><a href='../S/132.html#L217'>buffer</a>            217 src/print.c    	insert_1_both (print_buffer.buffer, print_buffer.pos,</span>
<span class='curline'><a href='../S/132.html#L320'>buffer</a>            320 src/print.c    	    print_buffer.buffer = xpalloc (print_buffer.buffer,</span>
<span class='curline'><a href='../S/132.html#L323'>buffer</a>            323 src/print.c    	  memcpy (print_buffer.buffer + print_buffer.pos_byte, str, len);</span>
<span class='curline'><a href='../S/132.html#L386'>buffer</a>            386 src/print.c    	print_buffer.buffer = xpalloc (print_buffer.buffer,</span>
<span class='curline'><a href='../S/132.html#L388'>buffer</a>            388 src/print.c          memcpy (print_buffer.buffer + print_buffer.pos_byte, ptr, size_byte);</span>
<span class='curline'><a href='../S/132.html#L513'>buffer</a>            513 src/print.c    	  char *buffer = SAFE_ALLOCA (nbytes);</span>
<span class='curline'><a href='../S/132.html#L514'>buffer</a>            514 src/print.c    	  memcpy (buffer, SDATA (string), nbytes);</span>
<span class='curline'><a href='../S/132.html#L516'>buffer</a>            516 src/print.c    	  strout (buffer, chars, nbytes, printcharfun);</span>
<span class='curline'><a href='../S/132.html#L587'>buffer</a>            587 src/print.c      register struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/132.html#L817'>buffer</a>            817 src/print.c      struct buffer *previous = current_buffer;</span>
<span class='curline'><a href='../S/132.html#L1026'>buffer</a>           1026 src/print.c      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/132.html#L1712'>buffer</a>           1712 src/print.c          if (! XMARKER (obj)-&gt;buffer)</span>
<span class='curline'><a href='../S/132.html#L1718'>buffer</a>           1718 src/print.c    	  print_string (BVAR (XMARKER (obj)-&gt;buffer, name), printcharfun);</span>
<span class='curline'><a href='../S/132.html#L1810'>buffer</a>           1810 src/print.c    	if (NILP (XXWIDGET (obj)-&gt;buffer))</span>
<span class='curline'><a href='../S/55.html#L344'>buffer</a>            344 src/process.c    p-&gt;buffer = val;</span>
<span class='curline'><a href='../S/55.html#L1275'>buffer</a>           1275 src/process.c    Lisp_Object buffer = p-&gt;buffer;</span>
<span class='curline'><a href='../S/55.html#L1276'>buffer</a>           1276 src/process.c    if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/55.html#L1277'>buffer</a>           1277 src/process.c      set_marker_both (p-&gt;mark, buffer,</span>
<span class='curline'><a href='../S/55.html#L1278'>buffer</a>           1278 src/process.c  		     BUF_ZV (XBUFFER (buffer)),</span>
<span class='curline'><a href='../S/55.html#L1279'>buffer</a>           1279 src/process.c  		     BUF_ZV_BYTE (XBUFFER (buffer)));</span>
<span class='curline'><a href='../S/55.html#L1286'>buffer</a>           1286 src/process.c    (register Lisp_Object process, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/55.html#L1291'>buffer</a>           1291 src/process.c    if (!NILP (buffer))</span>
<span class='curline'><a href='../S/55.html#L1292'>buffer</a>           1292 src/process.c      CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/55.html#L1294'>buffer</a>           1294 src/process.c    if (!EQ (p-&gt;buffer, buffer))</span>
<span class='curline'><a href='../S/55.html#L1296'>buffer</a>           1296 src/process.c        pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/55.html#L1300'>buffer</a>           1300 src/process.c      pset_childp (p, plist_put (p-&gt;childp, QCbuffer, buffer));</span>
<span class='curline'><a href='../S/55.html#L1302'>buffer</a>           1302 src/process.c    return buffer;</span>
<span class='curline'><a href='../S/55.html#L1312'>buffer</a>           1312 src/process.c    return XPROCESS (process)-&gt;buffer;</span>
<span class='curline'><a href='../S/55.html#L1798'>buffer</a>           1798 src/process.c    Lisp_Object buffer, name, command, program, proc, contact, current_dir, tem;</span>
<span class='curline'><a href='../S/55.html#L1817'>buffer</a>           1817 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/55.html#L1818'>buffer</a>           1818 src/process.c    if (!NILP (buffer))</span>
<span class='curline'><a href='../S/55.html#L1819'>buffer</a>           1819 src/process.c      buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/55.html#L1867'>buffer</a>           1867 src/process.c    pset_buffer (XPROCESS (proc), buffer);</span>
<span class='curline'><a href='../S/55.html#L1936'>buffer</a>           1936 src/process.c  	args2[i++] = buffer;</span>
<span class='curline'><a href='../S/55.html#L1966'>buffer</a>           1966 src/process.c  	    args2[i++] = buffer;</span>
<span class='curline'><a href='../S/55.html#L1991'>buffer</a>           1991 src/process.c      = !(NILP (buffer) || !inherit_process_coding_system);</span>
<span class='curline'><a href='../S/55.html#L2405'>buffer</a>           2405 src/process.c    Lisp_Object name, buffer;</span>
<span class='curline'><a href='../S/55.html#L2446'>buffer</a>           2446 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/55.html#L2447'>buffer</a>           2447 src/process.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/55.html#L2448'>buffer</a>           2448 src/process.c      buffer = name;</span>
<span class='curline'><a href='../S/55.html#L2449'>buffer</a>           2449 src/process.c    buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/55.html#L2450'>buffer</a>           2450 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/55.html#L2491'>buffer</a>           2491 src/process.c      else if ((!NILP (buffer) &amp;&amp; NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/55.html#L2492'>buffer</a>           2492 src/process.c  	     || (NILP (buffer) &amp;&amp; NILP (BVAR (&amp;buffer_defaults, enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/55.html#L3143'>buffer</a>           3143 src/process.c    Lisp_Object name, buffer;</span>
<span class='curline'><a href='../S/55.html#L3181'>buffer</a>           3181 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/55.html#L3182'>buffer</a>           3182 src/process.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/55.html#L3183'>buffer</a>           3183 src/process.c      buffer = name;</span>
<span class='curline'><a href='../S/55.html#L3184'>buffer</a>           3184 src/process.c    buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/55.html#L3185'>buffer</a>           3185 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/55.html#L3216'>buffer</a>           3216 src/process.c    else if ((!NILP (buffer) &amp;&amp; NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/55.html#L3217'>buffer</a>           3217 src/process.c  	   || (NILP (buffer) &amp;&amp; NILP (BVAR (&amp;buffer_defaults, enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/55.html#L3230'>buffer</a>           3230 src/process.c    else if ((!NILP (buffer) &amp;&amp; NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/55.html#L3231'>buffer</a>           3231 src/process.c  	   || (NILP (buffer) &amp;&amp; NILP (BVAR (&amp;buffer_defaults, enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/55.html#L3240'>buffer</a>           3240 src/process.c      = !(!NILP (tem) || NILP (buffer) || !inherit_process_coding_system);</span>
<span class='curline'><a href='../S/55.html#L3272'>buffer</a>           3272 src/process.c    else if ((!NILP (p-&gt;buffer)</span>
<span class='curline'><a href='../S/55.html#L3273'>buffer</a>           3273 src/process.c  	    &amp;&amp; NILP (BVAR (XBUFFER (p-&gt;buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/55.html#L3274'>buffer</a>           3274 src/process.c  	   || (NILP (p-&gt;buffer)</span>
<span class='curline'><a href='../S/55.html#L3287'>buffer</a>           3287 src/process.c  				Qopen_network_stream, name, p-&gt;buffer,</span>
<span class='curline'><a href='../S/55.html#L3316'>buffer</a>           3316 src/process.c  				    Qopen_network_stream, name, p-&gt;buffer,</span>
<span class='curline'><a href='../S/55.html#L3333'>buffer</a>           3333 src/process.c      = !(!NILP (tem) || NILP (p-&gt;buffer) || !inherit_process_coding_system);</span>
<span class='curline'><a href='../S/55.html#L3935'>buffer</a>           3935 src/process.c    Lisp_Object name, buffer, host, service, address;</span>
<span class='curline'><a href='../S/55.html#L3973'>buffer</a>           3973 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/55.html#L4212'>buffer</a>           4212 src/process.c    if (!NILP (buffer))</span>
<span class='curline'><a href='../S/55.html#L4213'>buffer</a>           4213 src/process.c      buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/55.html#L4225'>buffer</a>           4225 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/55.html#L4906'>buffer</a>           4906 src/process.c    Lisp_Object buffer;</span>
<span class='curline'><a href='../S/55.html#L4998'>buffer</a>           4998 src/process.c      buffer = Qnil;</span>
<span class='curline'><a href='../S/55.html#L5001'>buffer</a>           5001 src/process.c        buffer = ps-&gt;buffer;</span>
<span class='curline'><a href='../S/55.html#L5002'>buffer</a>           5002 src/process.c        if (!NILP (buffer))</span>
<span class='curline'><a href='../S/55.html#L5003'>buffer</a>           5003 src/process.c  	buffer = Fbuffer_name (buffer);</span>
<span class='curline'><a href='../S/55.html#L5005'>buffer</a>           5005 src/process.c  	buffer = ps-&gt;name;</span>
<span class='curline'><a href='../S/55.html#L5006'>buffer</a>           5006 src/process.c        if (!NILP (buffer))</span>
<span class='curline'><a href='../S/55.html#L5008'>buffer</a>           5008 src/process.c  	  args[1] = buffer;</span>
<span class='curline'><a href='../S/55.html#L5009'>buffer</a>           5009 src/process.c  	  buffer = Fget_buffer_create (Fformat (nargs, args), Qnil);</span>
<span class='curline'><a href='../S/55.html#L5046'>buffer</a>           5046 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/55.html#L5080'>buffer</a>           5080 src/process.c      = (NILP (buffer) ? 0 : ps-&gt;inherit_coding_system_flag);</span>
<span class='curline'><a href='../S/55.html#L6322'>buffer</a>           6322 src/process.c    if (!NILP (p-&gt;buffer) &amp;&amp; BUFFER_LIVE_P (XBUFFER (p-&gt;buffer)))</span>
<span class='curline'><a href='../S/55.html#L6328'>buffer</a>           6328 src/process.c        struct buffer *b;</span>
<span class='curline'><a href='../S/55.html#L6330'>buffer</a>           6330 src/process.c        Fset_buffer (p-&gt;buffer);</span>
<span class='curline'><a href='../S/55.html#L6341'>buffer</a>           6341 src/process.c        if (XMARKER (p-&gt;mark)-&gt;buffer)</span>
<span class='curline'><a href='../S/55.html#L6367'>buffer</a>           6367 src/process.c        if (BUFFERP (p-&gt;buffer)</span>
<span class='curline'><a href='../S/55.html#L6368'>buffer</a>           6368 src/process.c  	  &amp;&amp; (b = XBUFFER (p-&gt;buffer), b != current_buffer))</span>
<span class='curline'><a href='../S/55.html#L6369'>buffer</a>           6369 src/process.c  	set_marker_both (p-&gt;mark, p-&gt;buffer, BUF_PT (b), BUF_PT_BYTE (b));</span>
<span class='curline'><a href='../S/55.html#L6371'>buffer</a>           6371 src/process.c  	set_marker_both (p-&gt;mark, p-&gt;buffer, PT, PT_BYTE);</span>
<span class='curline'><a href='../S/55.html#L6558'>buffer</a>           6558 src/process.c  	  struct buffer *cur = current_buffer;</span>
<span class='curline'><a href='../S/55.html#L7666'>buffer</a>           7666 src/process.c  	  if (BUFFERP (p-&gt;buffer))</span>
<span class='curline'><a href='../S/55.html#L7668'>buffer</a>           7668 src/process.c  	    bset_update_mode_line (XBUFFER (p-&gt;buffer));</span>
<span class='curline'><a href='../S/55.html#L7681'>buffer</a>           7681 src/process.c    Lisp_Object buffer, symbol;</span>
<span class='curline'><a href='../S/55.html#L7685'>buffer</a>           7685 src/process.c    buffer = p-&gt;buffer;</span>
<span class='curline'><a href='../S/55.html#L7690'>buffer</a>           7690 src/process.c    if (!EQ (symbol, Qrun) &amp;&amp; !NILP (buffer))</span>
<span class='curline'><a href='../S/55.html#L7693'>buffer</a>           7693 src/process.c        struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/55.html#L7699'>buffer</a>           7699 src/process.c        if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/55.html#L7701'>buffer</a>           7701 src/process.c        Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/55.html#L7712'>buffer</a>           7712 src/process.c        if (XMARKER (p-&gt;mark)-&gt;buffer)</span>
<span class='curline'><a href='../S/55.html#L7728'>buffer</a>           7728 src/process.c        set_marker_both (p-&gt;mark, p-&gt;buffer, PT, PT_BYTE);</span>
<span class='curline'><a href='../S/55.html#L8124'>buffer</a>           8124 src/process.c        &amp;&amp; BUFFERP (p-&gt;buffer))</span>
<span class='curline'><a href='../S/55.html#L8126'>buffer</a>           8126 src/process.c        if (NILP (BVAR (XBUFFER (p-&gt;buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/55.html#L8144'>buffer</a>           8144 src/process.c    (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/55.html#L8149'>buffer</a>           8149 src/process.c    if (NILP (buffer)) return Qnil;</span>
<span class='curline'><a href='../S/55.html#L8150'>buffer</a>           8150 src/process.c    buf = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/55.html#L8154'>buffer</a>           8154 src/process.c      if (EQ (XPROCESS (proc)-&gt;buffer, buf))</span>
<span class='curline'><a href='../S/55.html#L8183'>buffer</a>           8183 src/process.c  kill_buffer_processes (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/55.html#L8189'>buffer</a>           8189 src/process.c      if (NILP (buffer) || EQ (XPROCESS (proc)-&gt;buffer, buffer))</span>
<span class='curline'><a href='../S/256.html#L68'>buffer</a>             68 src/process.h      Lisp_Object buffer;</span>
<span class='curline'><a href='../S/67.html#L747'>buffer</a>            747 src/regex-emacs.c   re_char *buffer = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/67.html#L749'>buffer</a>            749 src/regex-emacs.c   print_partial_compiled_pattern (buffer, buffer + bufp-&gt;used);</span>
<span class='curline'><a href='../S/67.html#L1045'>buffer</a>           1045 src/regex-emacs.c       eassert (FAILURE_PAT (failure) &gt;= bufp-&gt;buffer			\</span>
<span class='curline'><a href='../S/67.html#L1046'>buffer</a>           1046 src/regex-emacs.c 	       &amp;&amp; FAILURE_PAT (failure) &lt;= bufp-&gt;buffer + bufp-&gt;used);	\</span>
<span class='curline'><a href='../S/67.html#L1193'>buffer</a>           1193 src/regex-emacs.c     if (bufp-&gt;buffer + bufp-&gt;allocated - b &lt; (n))			\</span>
<span class='curline'><a href='../S/67.html#L1194'>buffer</a>           1194 src/regex-emacs.c       EXTEND_BUFFER ((n) - (bufp-&gt;buffer + bufp-&gt;allocated - b))</span>
<span class='curline'><a href='../S/67.html#L1243'>buffer</a>           1243 src/regex-emacs.c     unsigned char *old_buffer = bufp-&gt;buffer;				\</span>
<span class='curline'><a href='../S/67.html#L1253'>buffer</a>           1253 src/regex-emacs.c     bufp-&gt;buffer = xpalloc (bufp-&gt;buffer, &amp;bufp-&gt;allocated,		\</span>
<span class='curline'><a href='../S/67.html#L1255'>buffer</a>           1255 src/regex-emacs.c     unsigned char *new_buffer = bufp-&gt;buffer;				\</span>
<span class='curline'><a href='../S/67.html#L1792'>buffer</a>           1792 src/regex-emacs.c       bufp-&gt;buffer = xrealloc (bufp-&gt;buffer, INIT_BUF_SIZE);</span>
<span class='curline'><a href='../S/67.html#L1796'>buffer</a>           1796 src/regex-emacs.c   begalt = b = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/67.html#L2254'>buffer</a>           2254 src/regex-emacs.c 		COMPILE_STACK_TOP.begalt_offset = begalt - bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/67.html#L2256'>buffer</a>           2256 src/regex-emacs.c 		  = fixup_alt_jump ? fixup_alt_jump - bufp-&gt;buffer + 1 : 0;</span>
<span class='curline'><a href='../S/67.html#L2257'>buffer</a>           2257 src/regex-emacs.c 		COMPILE_STACK_TOP.laststart_offset = b - bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/67.html#L2297'>buffer</a>           2297 src/regex-emacs.c 		begalt = bufp-&gt;buffer + COMPILE_STACK_TOP.begalt_offset;</span>
<span class='curline'><a href='../S/67.html#L2300'>buffer</a>           2300 src/regex-emacs.c 		    ? bufp-&gt;buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1</span>
<span class='curline'><a href='../S/67.html#L2302'>buffer</a>           2302 src/regex-emacs.c 		laststart = bufp-&gt;buffer + COMPILE_STACK_TOP.laststart_offset;</span>
<span class='curline'><a href='../S/67.html#L2663'>buffer</a>           2663 src/regex-emacs.c   bufp-&gt;used = b - bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/67.html#L3124'>buffer</a>           3124 src/regex-emacs.c   eassert (fastmap &amp;&amp; bufp-&gt;buffer);</span>
<span class='curline'><a href='../S/67.html#L3131'>buffer</a>           3131 src/regex-emacs.c   analysis = analyze_first (bufp-&gt;buffer, bufp-&gt;buffer + bufp-&gt;used,</span>
<span class='curline'><a href='../S/67.html#L3237'>buffer</a>           3237 src/regex-emacs.c   if (bufp-&gt;used &gt; 0 &amp;&amp; (re_opcode_t) bufp-&gt;buffer[0] == begbuf &amp;&amp; range &gt; 0)</span>
<span class='curline'><a href='../S/67.html#L3247'>buffer</a>           3247 src/regex-emacs.c   if (bufp-&gt;used &gt; 0 &amp;&amp; (re_opcode_t) bufp-&gt;buffer[0] == at_dot &amp;&amp; range &gt; 0)</span>
<span class='curline'><a href='../S/67.html#L3259'>buffer</a>           3259 src/regex-emacs.c   anchored_start = (bufp-&gt;buffer[0] == begline);</span>
<span class='curline'><a href='../S/67.html#L3655'>buffer</a>           3655 src/regex-emacs.c   unsigned char *pend = bufp-&gt;buffer + bufp-&gt;used;</span>
<span class='curline'><a href='../S/67.html#L3658'>buffer</a>           3658 src/regex-emacs.c   eassert (p1 &gt;= bufp-&gt;buffer &amp;&amp; p1 &lt; pend</span>
<span class='curline'><a href='../S/67.html#L3659'>buffer</a>           3659 src/regex-emacs.c 	   &amp;&amp; p2 &gt;= bufp-&gt;buffer &amp;&amp; p2 &lt;= pend);</span>
<span class='curline'><a href='../S/67.html#L3670'>buffer</a>           3670 src/regex-emacs.c   eassert (p1 &gt;= bufp-&gt;buffer &amp;&amp; p1 &lt; pend</span>
<span class='curline'><a href='../S/67.html#L3671'>buffer</a>           3671 src/regex-emacs.c 	   &amp;&amp; p2 &gt;= bufp-&gt;buffer &amp;&amp; p2 &lt;= pend);</span>
<span class='curline'><a href='../S/67.html#L3888'>buffer</a>           3888 src/regex-emacs.c   struct buffer *b = (struct buffer *) ptr;</span>
<span class='curline'><a href='../S/67.html#L3924'>buffer</a>           3924 src/regex-emacs.c   re_char *p = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/67.html#L5097'>buffer</a>           5097 src/regex-emacs.c 	  eassert (p &gt;= bufp-&gt;buffer &amp;&amp; p &lt;= pend);</span>
<span class='curline'><a href='../S/174.html#L69'>buffer</a>             69 src/regex-emacs.h   unsigned char *buffer;</span>
<span class='curline'><a href='../S/174.html#L131'>buffer</a>            131 src/regex-emacs.h 				       struct re_pattern_buffer *buffer);</span>
<span class='curline'><a href='../S/174.html#L139'>buffer</a>            139 src/regex-emacs.h extern ptrdiff_t re_search (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/174.html#L147'>buffer</a>            147 src/regex-emacs.h extern ptrdiff_t re_search_2 (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/174.html#L157'>buffer</a>            157 src/regex-emacs.h extern ptrdiff_t re_match_2 (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/174.html#L176'>buffer</a>            176 src/regex-emacs.h extern void re_set_registers (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/213.html#L125'>buffer</a>            125 src/region-cache.c static void revalidate_region_cache (struct buffer *buf, struct region_cache *c);</span>
<span class='curline'><a href='../S/213.html#L458'>buffer</a>            458 src/region-cache.c invalidate_region_cache (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/213.html#L537'>buffer</a>            537 src/region-cache.c revalidate_region_cache (struct buffer *buf, struct region_cache *c)</span>
<span class='curline'><a href='../S/213.html#L665'>buffer</a>            665 src/region-cache.c know_region_cache (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/213.html#L681'>buffer</a>            681 src/region-cache.c region_cache_forward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/213.html#L719'>buffer</a>            719 src/region-cache.c region_cache_backward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/327.html#L65'>buffer</a>             65 src/region-cache.h struct buffer;</span>
<span class='curline'><a href='../S/327.html#L76'>buffer</a>             76 src/region-cache.h extern void know_region_cache (struct buffer *BUF,</span>
<span class='curline'><a href='../S/327.html#L88'>buffer</a>             88 src/region-cache.h extern void invalidate_region_cache (struct buffer *BUF,</span>
<span class='curline'><a href='../S/327.html#L105'>buffer</a>            105 src/region-cache.h extern int region_cache_forward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/327.html#L109'>buffer</a>            109 src/region-cache.h extern int region_cache_backward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/224.html#L147'>buffer</a>            147 src/search.c           cp-&gt;buf.buffer = xrealloc (cp-&gt;buf.buffer, cp-&gt;buf.used);</span>
<span class='curline'><a href='../S/224.html#L598'>buffer</a>            598 src/search.c   newline_cache_on_off (struct buffer *buf)</span>
<span class='curline'><a href='../S/224.html#L600'>buffer</a>            600 src/search.c     struct buffer *base_buf = buf;</span>
<span class='curline'><a href='../S/224.html#L676'>buffer</a>            676 src/search.c     struct buffer *cache_buffer;</span>
<span class='curline'><a href='../S/224.html#L3025'>buffer</a>           3025 src/search.c   		if (XMARKER (marker)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/224.html#L3028'>buffer</a>           3028 src/search.c   		  XSETBUFFER (last_thing_searched, XMARKER (marker)-&gt;buffer);</span>
<span class='curline'><a href='../S/224.html#L3045'>buffer</a>           3045 src/search.c   	    if (MARKERP (marker) &amp;&amp; XMARKER (marker)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/224.html#L3302'>buffer</a>           3302 src/search.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/224.html#L3304'>buffer</a>           3304 src/search.c     struct buffer *buf, *old = NULL;</span>
<span class='curline'><a href='../S/224.html#L3309'>buffer</a>           3309 src/search.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/224.html#L3313'>buffer</a>           3313 src/search.c         CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/224.html#L3314'>buffer</a>           3314 src/search.c         buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/224.html#L3464'>buffer</a>           3464 src/search.c         searchbufs[i].buf.buffer = xmalloc (100);</span>
<span class='curline'><a href='../S/59.html#L223'>buffer</a>            223 src/sound.c      void (* write) (struct sound_device *sd, const char *buffer,</span>
<span class='curline'><a href='../S/59.html#L571'>buffer</a>            571 src/sound.c          char *buffer = SAFE_ALLOCA (blksize);</span>
<span class='curline'><a href='../S/59.html#L574'>buffer</a>            574 src/sound.c                 &amp;&amp; (nbytes = emacs_read (s-&gt;fd, buffer, blksize)) &gt; 0)</span>
<span class='curline'><a href='../S/59.html#L579'>buffer</a>            579 src/sound.c              sd-&gt;write (sd, buffer, nbytes);</span>
<span class='curline'><a href='../S/59.html#L666'>buffer</a>            666 src/sound.c          char *buffer = SAFE_ALLOCA (blksize);</span>
<span class='curline'><a href='../S/59.html#L667'>buffer</a>            667 src/sound.c          while ((nbytes = emacs_read (s-&gt;fd, buffer, blksize)) &gt; 0)</span>
<span class='curline'><a href='../S/59.html#L668'>buffer</a>            668 src/sound.c    	sd-&gt;write (sd, buffer, nbytes);</span>
<span class='curline'><a href='../S/59.html#L868'>buffer</a>            868 src/sound.c    vox_write (struct sound_device *sd, const char *buffer, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/59.html#L870'>buffer</a>            870 src/sound.c      if (emacs_write_sig (sd-&gt;fd, buffer, nbytes) != nbytes)</span>
<span class='curline'><a href='../S/59.html#L1126'>buffer</a>           1126 src/sound.c    alsa_write (struct sound_device *sd, const char *buffer, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/59.html#L1140'>buffer</a>           1140 src/sound.c          err = snd_pcm_writei (p-&gt;handle, buffer + nwritten, frames);</span>
<span class='curline'><a href='../S/152.html#L176'>buffer</a>            176 src/syntax.c   static struct buffer *find_start_buffer;</span>
<span class='curline'><a href='../S/152.html#L193'>buffer</a>            193 src/syntax.c   bset_syntax_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/152.html#L283'>buffer</a>            283 src/syntax.c         struct buffer *buf = XBUFFER (gl_state.object);</span>
<span class='curline'><a href='../S/253.html#L2285'>buffer</a>           2285 src/sysdep.c     void *buffer;</span>
<span class='curline'><a href='../S/253.html#L2290'>buffer</a>           2290 src/sysdep.c         buffer = thread_backtrace_buffer;</span>
<span class='curline'><a href='../S/253.html#L2295'>buffer</a>           2295 src/sysdep.c         buffer = main_backtrace_buffer;</span>
<span class='curline'><a href='../S/253.html#L2300'>buffer</a>           2300 src/sysdep.c   	  backtrace (buffer, 1);</span>
<span class='curline'><a href='../S/253.html#L2304'>buffer</a>           2304 src/sysdep.c         npointers = backtrace (buffer, bounded_limit + 1);</span>
<span class='curline'><a href='../S/253.html#L2310'>buffer</a>           2310 src/sysdep.c         backtrace_symbols_fd (buffer, npointers, STDERR_FILENO);</span>
<span class='curline'><a href='../S/54.html#L3448'>buffer</a>           3448 src/term.c       struct buffer *buffer;</span>
<span class='curline'><a href='../S/54.html#L3458'>buffer</a>           3458 src/term.c       set_buffer_internal (data-&gt;buffer);</span>
<span class='curline'><a href='../S/143.html#L78'>buffer</a>             78 src/textprop.c modify_text_properties (Lisp_Object buffer, Lisp_Object start, Lisp_Object end)</span>
<span class='curline'><a href='../S/143.html#L81'>buffer</a>             81 src/textprop.c   struct buffer *buf = XBUFFER (buffer), *old = current_buffer;</span>
<span class='curline'><a href='../S/143.html#L154'>buffer</a>            154 src/textprop.c       register struct buffer *b = XBUFFER (object);</span>
<span class='curline'><a href='../S/143.html#L537'>buffer</a>            537 src/textprop.c       register struct buffer *b = XBUFFER (object);</span>
<span class='curline'><a href='../S/143.html#L636'>buffer</a>            636 src/textprop.c       struct buffer *b = XBUFFER (object);</span>
<span class='curline'><a href='../S/143.html#L1901'>buffer</a>           1901 src/textprop.c text_property_stickiness (Lisp_Object prop, Lisp_Object pos, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/143.html#L1909'>buffer</a>           1909 src/textprop.c   if (NILP (buffer))</span>
<span class='curline'><a href='../S/143.html#L1910'>buffer</a>           1910 src/textprop.c     XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/143.html#L1912'>buffer</a>           1912 src/textprop.c   ignore_previous_character = XFIXNUM (pos) &lt;= BUF_BEGV (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/143.html#L1919'>buffer</a>           1919 src/textprop.c 	= Fget_text_property (prev_pos, Qrear_nonsticky, buffer);</span>
<span class='curline'><a href='../S/143.html#L1931'>buffer</a>           1931 src/textprop.c   front_sticky = Fget_text_property (pos, Qfront_sticky, buffer);</span>
<span class='curline'><a href='../S/143.html#L1952'>buffer</a>           1952 src/textprop.c       || NILP (Fget_text_property (prev_pos, prop, buffer)))</span>
<span class='curline'><a href='../S/143.html#L2184'>buffer</a>           2184 src/textprop.c verify_interval_modification (struct buffer *buf,</span>
<span class='curline'><a href='../S/155.html#L1095'>buffer</a>           1095 src/thread.c   thread_check_current_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/155.html#L1104'>buffer</a>           1104 src/thread.c         if (iter-&gt;m_current_buffer == buffer)</span>
<span class='curline'><a href='../S/111.html#L123'>buffer</a>            123 src/thread.h     struct buffer *m_current_buffer;</span>
<span class='curline'><a href='../S/111.html#L318'>buffer</a>            318 src/thread.h   bool thread_check_current_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/316.html#L1342'>buffer</a>           1342 src/timefns.c    char buffer[4000];</span>
<span class='curline'><a href='../S/316.html#L1343'>buffer</a>           1343 src/timefns.c    char *buf = buffer;</span>
<span class='curline'><a href='../S/316.html#L1344'>buffer</a>           1344 src/timefns.c    ptrdiff_t size = sizeof buffer;</span>
<span class='curline'><a href='../S/209.html#L778'>buffer</a>            778 src/treesit.c    struct buffer *base_buffer = current_buffer;</span>
<span class='curline'><a href='../S/209.html#L907'>buffer</a>            907 src/treesit.c    struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/209.html#L913'>buffer</a>            913 src/treesit.c        XTS_PARSER (parser)-&gt;visible_beg = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/209.html#L914'>buffer</a>            914 src/treesit.c        XTS_PARSER (parser)-&gt;visible_end = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/209.html#L923'>buffer</a>            923 src/treesit.c    eassert (BUF_BEGV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/209.html#L924'>buffer</a>            924 src/treesit.c    eassert (BUF_ZV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/209.html#L928'>buffer</a>            928 src/treesit.c    if (visible_beg != BUF_BEGV_BYTE (buffer)</span>
<span class='curline'><a href='../S/209.html#L929'>buffer</a>            929 src/treesit.c        || visible_end != BUF_ZV_BYTE (buffer))</span>
<span class='curline'><a href='../S/209.html#L941'>buffer</a>            941 src/treesit.c    if (visible_beg &gt; BUF_BEGV_BYTE (buffer))</span>
<span class='curline'><a href='../S/209.html#L944'>buffer</a>            944 src/treesit.c        treesit_tree_edit_1 (tree, 0, 0, visible_beg - BUF_BEGV_BYTE (buffer));</span>
<span class='curline'><a href='../S/209.html#L945'>buffer</a>            945 src/treesit.c        visible_beg = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/209.html#L949'>buffer</a>            949 src/treesit.c    if (visible_end &lt; BUF_ZV_BYTE (buffer))</span>
<span class='curline'><a href='../S/209.html#L954'>buffer</a>            954 src/treesit.c  			   BUF_ZV_BYTE (buffer) - visible_beg);</span>
<span class='curline'><a href='../S/209.html#L955'>buffer</a>            955 src/treesit.c        visible_end = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/209.html#L958'>buffer</a>            958 src/treesit.c    else if (visible_end &gt; BUF_ZV_BYTE (buffer))</span>
<span class='curline'><a href='../S/209.html#L961'>buffer</a>            961 src/treesit.c        treesit_tree_edit_1 (tree, BUF_ZV_BYTE (buffer) - visible_beg,</span>
<span class='curline'><a href='../S/209.html#L963'>buffer</a>            963 src/treesit.c  			   BUF_ZV_BYTE (buffer) - visible_beg);</span>
<span class='curline'><a href='../S/209.html#L964'>buffer</a>            964 src/treesit.c        visible_end = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/209.html#L968'>buffer</a>            968 src/treesit.c    if (visible_beg &lt; BUF_BEGV_BYTE (buffer))</span>
<span class='curline'><a href='../S/209.html#L971'>buffer</a>            971 src/treesit.c        treesit_tree_edit_1 (tree, 0, BUF_BEGV_BYTE (buffer) - visible_beg, 0);</span>
<span class='curline'><a href='../S/209.html#L972'>buffer</a>            972 src/treesit.c        visible_beg = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/209.html#L977'>buffer</a>            977 src/treesit.c    eassert (visible_beg == BUF_BEGV_BYTE (buffer));</span>
<span class='curline'><a href='../S/209.html#L978'>buffer</a>            978 src/treesit.c    eassert (visible_end == BUF_ZV_BYTE (buffer));</span>
<span class='curline'><a href='../S/209.html#L985'>buffer</a>            985 src/treesit.c  treesit_check_buffer_size (struct buffer *buffer)</span>
<span class='curline'><a href='../S/209.html#L987'>buffer</a>            987 src/treesit.c    ptrdiff_t buffer_size_bytes = (BUF_Z_BYTE (buffer) - BUF_BEG_BYTE (buffer));</span>
<span class='curline'><a href='../S/209.html#L994'>buffer</a>            994 src/treesit.c  static Lisp_Object treesit_make_ranges (const TSRange *, uint32_t, struct buffer *);</span>
<span class='curline'><a href='../S/209.html#L1003'>buffer</a>           1003 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/209.html#L1013'>buffer</a>           1013 src/treesit.c        struct buffer *oldbuf = current_buffer;</span>
<span class='curline'><a href='../S/209.html#L1035'>buffer</a>           1035 src/treesit.c    struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/209.html#L1038'>buffer</a>           1038 src/treesit.c    treesit_check_buffer_size (buffer);</span>
<span class='curline'><a href='../S/209.html#L1063'>buffer</a>           1063 src/treesit.c        XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/209.html#L1087'>buffer</a>           1087 src/treesit.c    struct buffer *buffer = XBUFFER (((struct Lisp_TS_Parser *) parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/209.html#L1094'>buffer</a>           1094 src/treesit.c    eassert (visible_beg = BUF_BEGV_BYTE (buffer));</span>
<span class='curline'><a href='../S/209.html#L1095'>buffer</a>           1095 src/treesit.c    eassert (visible_end = BUF_ZV_BYTE (buffer));</span>
<span class='curline'><a href='../S/209.html#L1107'>buffer</a>           1107 src/treesit.c    if (!BUFFER_LIVE_P (buffer))</span>
<span class='curline'><a href='../S/209.html#L1121'>buffer</a>           1121 src/treesit.c        beg = (char *) BUF_BYTE_ADDRESS (buffer, byte_pos);</span>
<span class='curline'><a href='../S/209.html#L1137'>buffer</a>           1137 src/treesit.c  make_treesit_parser (Lisp_Object buffer, TSParser *parser,</span>
<span class='curline'><a href='../S/209.html#L1143'>buffer</a>           1143 src/treesit.c  				       buffer, PVEC_TS_PARSER);</span>
<span class='curline'><a href='../S/209.html#L1147'>buffer</a>           1147 src/treesit.c    lisp_parser-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/209.html#L1153'>buffer</a>           1153 src/treesit.c    lisp_parser-&gt;visible_beg = BUF_BEGV_BYTE (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/209.html#L1154'>buffer</a>           1154 src/treesit.c    lisp_parser-&gt;visible_end = BUF_ZV_BYTE (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/209.html#L1377'>buffer</a>           1377 src/treesit.c    (Lisp_Object language, Lisp_Object buffer, Lisp_Object no_reuse)</span>
<span class='curline'><a href='../S/209.html#L1382'>buffer</a>           1382 src/treesit.c    struct buffer *buf;</span>
<span class='curline'><a href='../S/209.html#L1383'>buffer</a>           1383 src/treesit.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/209.html#L1387'>buffer</a>           1387 src/treesit.c        CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/209.html#L1388'>buffer</a>           1388 src/treesit.c        buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/209.html#L1439'>buffer</a>           1439 src/treesit.c    Lisp_Object buffer = XTS_PARSER (parser)-&gt;buffer;</span>
<span class='curline'><a href='../S/209.html#L1440'>buffer</a>           1440 src/treesit.c    struct buffer *buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/209.html#L1457'>buffer</a>           1457 src/treesit.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/209.html#L1459'>buffer</a>           1459 src/treesit.c    struct buffer *buf;</span>
<span class='curline'><a href='../S/209.html#L1460'>buffer</a>           1460 src/treesit.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/209.html#L1464'>buffer</a>           1464 src/treesit.c        CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/209.html#L1465'>buffer</a>           1465 src/treesit.c        buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/209.html#L1491'>buffer</a>           1491 src/treesit.c    XSETBUFFER (buf, XBUFFER (XTS_PARSER (parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/209.html#L1512'>buffer</a>           1512 src/treesit.c  	  (!NILP (Fbuffer_live_p (XTS_PARSER (parser)-&gt;buffer))));</span>
<span class='curline'><a href='../S/209.html#L1536'>buffer</a>           1536 src/treesit.c    struct buffer *buffer = current_buffer;</span>
<span class='curline'><a href='../S/209.html#L1537'>buffer</a>           1537 src/treesit.c    ptrdiff_t point_min = BUF_BEGV (buffer);</span>
<span class='curline'><a href='../S/209.html#L1538'>buffer</a>           1538 src/treesit.c    ptrdiff_t point_max = BUF_ZV (buffer);</span>
<span class='curline'><a href='../S/209.html#L1572'>buffer</a>           1572 src/treesit.c  		     struct buffer *buffer)</span>
<span class='curline'><a href='../S/209.html#L1578'>buffer</a>           1578 src/treesit.c        uint32_t beg_byte = range.start_byte + BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/209.html#L1579'>buffer</a>           1579 src/treesit.c        uint32_t end_byte = range.end_byte + BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/209.html#L1580'>buffer</a>           1580 src/treesit.c        eassert (BUF_BEGV_BYTE (buffer) &lt;= beg_byte);</span>
<span class='curline'><a href='../S/209.html#L1582'>buffer</a>           1582 src/treesit.c        eassert (end_byte &lt;= BUF_ZV_BYTE (buffer));</span>
<span class='curline'><a href='../S/209.html#L1585'>buffer</a>           1585 src/treesit.c  	= Fcons (make_fixnum (buf_bytepos_to_charpos (buffer, beg_byte)),</span>
<span class='curline'><a href='../S/209.html#L1586'>buffer</a>           1586 src/treesit.c  		 make_fixnum (buf_bytepos_to_charpos (buffer, end_byte)));</span>
<span class='curline'><a href='../S/209.html#L1613'>buffer</a>           1613 src/treesit.c    treesit_check_buffer_size (XBUFFER (XTS_PARSER (parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/209.html#L1636'>buffer</a>           1636 src/treesit.c        struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/209.html#L1641'>buffer</a>           1641 src/treesit.c  	  ptrdiff_t beg_byte = buf_charpos_to_bytepos (buffer,</span>
<span class='curline'><a href='../S/209.html#L1643'>buffer</a>           1643 src/treesit.c  	  ptrdiff_t end_byte = buf_charpos_to_bytepos (buffer,</span>
<span class='curline'><a href='../S/209.html#L1647'>buffer</a>           1647 src/treesit.c  	  eassert (beg_byte - BUF_BEGV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/209.html#L1648'>buffer</a>           1648 src/treesit.c  	  eassert (end_byte - BUF_BEGV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/209.html#L1652'>buffer</a>           1652 src/treesit.c  			(uint32_t) beg_byte - BUF_BEGV_BYTE (buffer),</span>
<span class='curline'><a href='../S/209.html#L1653'>buffer</a>           1653 src/treesit.c  			(uint32_t) end_byte - BUF_BEGV_BYTE (buffer)};</span>
<span class='curline'><a href='../S/209.html#L1699'>buffer</a>           1699 src/treesit.c    treesit_check_buffer_size (XBUFFER (XTS_PARSER (parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/209.html#L1702'>buffer</a>           1702 src/treesit.c    struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/209.html#L1703'>buffer</a>           1703 src/treesit.c    return treesit_make_ranges (ranges, len, buffer);</span>
<span class='curline'><a href='../S/209.html#L1786'>buffer</a>           1786 src/treesit.c  treesit_check_position (Lisp_Object obj, struct buffer *buf)</span>
<span class='curline'><a href='../S/209.html#L1829'>buffer</a>           1829 src/treesit.c    struct buffer *buffer</span>
<span class='curline'><a href='../S/209.html#L1830'>buffer</a>           1830 src/treesit.c      = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/209.html#L1832'>buffer</a>           1832 src/treesit.c      = buf_bytepos_to_charpos (buffer,</span>
<span class='curline'><a href='../S/209.html#L1850'>buffer</a>           1850 src/treesit.c    struct buffer *buffer</span>
<span class='curline'><a href='../S/209.html#L1851'>buffer</a>           1851 src/treesit.c      = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/209.html#L1853'>buffer</a>           1853 src/treesit.c      = buf_bytepos_to_charpos (buffer, end_byte_offset + visible_beg);</span>
<span class='curline'><a href='../S/209.html#L2198'>buffer</a>           2198 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/209.html#L2234'>buffer</a>           2234 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/209.html#L2464'>buffer</a>           2464 src/treesit.c    struct buffer *old_buffer = current_buffer;</span>
<span class='curline'><a href='../S/209.html#L2465'>buffer</a>           2465 src/treesit.c    set_buffer_internal (XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/209.html#L2530'>buffer</a>           2530 src/treesit.c    struct buffer *old_buffer = current_buffer;</span>
<span class='curline'><a href='../S/209.html#L2531'>buffer</a>           2531 src/treesit.c    struct buffer *buffer = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/209.html#L2532'>buffer</a>           2532 src/treesit.c    set_buffer_internal (buffer);</span>
<span class='curline'><a href='../S/209.html#L2737'>buffer</a>           2737 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (lisp_parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/243.html#L45'>buffer</a>             45 src/treesit.h    Lisp_Object buffer;</span>
<span class='curline'><a href='../S/88.html#L212'>buffer</a>            212 src/undo.c       struct buffer *base_buffer = current_buffer;</span>
<span class='curline'><a href='../S/88.html#L231'>buffer</a>            231 src/undo.c     			Lisp_Object buffer)</span>
<span class='curline'><a href='../S/88.html#L234'>buffer</a>            234 src/undo.c       struct buffer *buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/88.html#L290'>buffer</a>            290 src/undo.c     truncate_undo_list (struct buffer *b)</span>
<span class='curline'><a href='../S/312.html#L283'>buffer</a>            283 src/unexcw.c         char buffer[4096];</span>
<span class='curline'><a href='../S/312.html#L284'>buffer</a>            284 src/unexcw.c         ret = read (fd_in, buffer, sizeof (buffer));</span>
<span class='curline'><a href='../S/312.html#L292'>buffer</a>            292 src/unexcw.c         ret2 = write (fd_out, buffer, ret);</span>
<span class='curline'><a href='../S/144.html#L217'>buffer</a>            217 src/unexhp9k800.c   int buffer[8192];  /* word aligned will be faster */</span>
<span class='curline'><a href='../S/144.html#L221'>buffer</a>            221 src/unexhp9k800.c       len = min (size, sizeof (buffer));</span>
<span class='curline'><a href='../S/144.html#L222'>buffer</a>            222 src/unexhp9k800.c       if (read (old, buffer, len) != len)</span>
<span class='curline'><a href='../S/144.html#L224'>buffer</a>            224 src/unexhp9k800.c       if (write (new, buffer, len) != len)</span>
<span class='curline'><a href='../S/144.html#L234'>buffer</a>            234 src/unexhp9k800.c   int buffer[4096];</span>
<span class='curline'><a href='../S/144.html#L238'>buffer</a>            238 src/unexhp9k800.c   while ((len = read (old, buffer, sizeof (buffer))) &gt; 0)</span>
<span class='curline'><a href='../S/144.html#L239'>buffer</a>            239 src/unexhp9k800.c     if (write (new, buffer, len) != len) break;</span>
<span class='curline'><a href='../S/207.html#L3931'>buffer</a>           3931 src/w32.c        char *buffer;</span>
<span class='curline'><a href='../S/207.html#L3941'>buffer</a>           3941 src/w32.c            buffer = alloca (bufsize);</span>
<span class='curline'><a href='../S/207.html#L3942'>buffer</a>           3942 src/w32.c            result = WNetEnumResourceW (henum, &amp;count, buffer, &amp;bufsize);</span>
<span class='curline'><a href='../S/207.html#L3946'>buffer</a>           3946 src/w32.c            ptrw = ((LPNETRESOURCEW) buffer)-&gt;lpRemoteName;</span>
<span class='curline'><a href='../S/207.html#L3958'>buffer</a>           3958 src/w32.c            buffer = alloca (bufsize);</span>
<span class='curline'><a href='../S/207.html#L3959'>buffer</a>           3959 src/w32.c            result = WNetEnumResourceA (henum, &amp;count, buffer, &amp;bufsize);</span>
<span class='curline'><a href='../S/207.html#L3962'>buffer</a>           3962 src/w32.c            ptra = ((LPNETRESOURCEA) buffer)-&gt;lpRemoteName;</span>
<span class='curline'><a href='../S/207.html#L6364'>buffer</a>           6364 src/w32.c      readlinkat (int fd, char const *name, char *buffer,</span>
<span class='curline'><a href='../S/207.html#L6382'>buffer</a>           6382 src/w32.c        return readlink (name, buffer, buffer_size);</span>
<span class='curline'><a href='../S/207.html#L6803'>buffer</a>           6803 src/w32.c                    char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/207.html#L6814'>buffer</a>           6814 src/w32.c            char *retval = buffer;</span>
<span class='curline'><a href='../S/207.html#L9005'>buffer</a>           9005 src/w32.c      sys_read (int fd, char * buffer, unsigned int count)</span>
<span class='curline'><a href='../S/207.html#L9010'>buffer</a>           9010 src/w32.c        char * orig_buffer = buffer;</span>
<span class='curline'><a href='../S/207.html#L9034'>buffer</a>           9034 src/w32.c      	  *buffer++ = 0x0d;</span>
<span class='curline'><a href='../S/207.html#L9076'>buffer</a>           9076 src/w32.c      	      *buffer++ = cp-&gt;chr;</span>
<span class='curline'><a href='../S/207.html#L9098'>buffer</a>           9098 src/w32.c      		nchars += _read (fd, buffer, to_read);</span>
<span class='curline'><a href='../S/207.html#L9129'>buffer</a>           9129 src/w32.c      		  if (!ReadFile (hnd, buffer, count, (DWORD*) &amp;rc, ovl))</span>
<span class='curline'><a href='../S/207.html#L9182'>buffer</a>           9182 src/w32.c      		  int res = pfn_recv (SOCK_HANDLE (fd), buffer, count, 0);</span>
<span class='curline'><a href='../S/207.html#L9196'>buffer</a>           9196 src/w32.c      	  int nread = _read (fd, buffer, count);</span>
<span class='curline'><a href='../S/207.html#L9221'>buffer</a>           9221 src/w32.c          nchars = _read (fd, buffer, count);</span>
<span class='curline'><a href='../S/207.html#L9230'>buffer</a>           9230 src/w32.c      sys_write (int fd, const void * buffer, unsigned int count)</span>
<span class='curline'><a href='../S/207.html#L9253'>buffer</a>           9253 src/w32.c      	  const unsigned char * src = buffer;</span>
<span class='curline'><a href='../S/207.html#L9281'>buffer</a>           9281 src/w32.c      	  buffer = tmpbuf;</span>
<span class='curline'><a href='../S/207.html#L9295'>buffer</a>           9295 src/w32.c            if (!WriteFile (hnd, buffer, count, (DWORD*) &amp;nchars, ovl))</span>
<span class='curline'><a href='../S/207.html#L9367'>buffer</a>           9367 src/w32.c            nchars =  pfn_send (SOCK_HANDLE (fd), buffer, count, 0);</span>
<span class='curline'><a href='../S/207.html#L9392'>buffer</a>           9392 src/w32.c            const unsigned char *p = buffer;</span>
<span class='curline'><a href='../S/207.html#L10345'>buffer</a>           10345 src/w32.c      	  char *buffer = alloca (1024</span>
<span class='curline'><a href='../S/207.html#L10348'>buffer</a>           10348 src/w32.c      	  char *msg = buffer;</span>
<span class='curline'><a href='../S/207.html#L10351'>buffer</a>           10351 src/w32.c      	  sprintf (buffer,</span>
<span class='curline'><a href='../S/207.html#L10362'>buffer</a>           10362 src/w32.c      					 buffer, -1, NULL, 0);</span>
<span class='curline'><a href='../S/207.html#L10367'>buffer</a>           10367 src/w32.c      	      pMultiByteToWideChar (CP_UTF8, multiByteToWideCharFlags, buffer,</span>
<span class='curline'><a href='../S/97.html#L177'>buffer</a>            177 src/w32fns.c     (IN HIMC context, IN DWORD index, OUT LPVOID buffer, IN DWORD bufLen);</span>
<span class='curline'><a href='../S/97.html#L4577'>buffer</a>           4577 src/w32fns.c   	  wchar_t * buffer;</span>
<span class='curline'><a href='../S/97.html#L4587'>buffer</a>           4587 src/w32fns.c   	  buffer = alloca (size);</span>
<span class='curline'><a href='../S/97.html#L4589'>buffer</a>           4589 src/w32fns.c   					    buffer, size);</span>
<span class='curline'><a href='../S/97.html#L4595'>buffer</a>           4595 src/w32fns.c   	      my_post_msg (&amp;wmsg, hwnd, WM_UNICHAR, (WPARAM) buffer[i],</span>
<span class='curline'><a href='../S/97.html#L7356'>buffer</a>           7356 src/w32fns.c     struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/97.html#L11091'>buffer</a>           11091 src/w32fns.c   w32_backtrace (void **buffer, int limit)</span>
<span class='curline'><a href='../S/97.html#L11104'>buffer</a>           11104 src/w32fns.c   					buffer, NULL);</span>
<span class='curline'><a href='../S/276.html#L286'>buffer</a>            286 src/w32menu.c        struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/276.html#L287'>buffer</a>            287 src/w32menu.c        Lisp_Object buffer;</span>
<span class='curline'><a href='../S/276.html#L299'>buffer</a>            299 src/w32menu.c        buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/276.html#L313'>buffer</a>            313 src/w32menu.c        set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/93.html#L592'>buffer</a>            592 src/w32select.c   char buffer[20] = "";</span>
<span class='curline'><a href='../S/93.html#L598'>buffer</a>            598 src/w32select.c   GetLocaleInfo (lcid, variant, buffer, sizeof (buffer));</span>
<span class='curline'><a href='../S/93.html#L599'>buffer</a>            599 src/w32select.c   cp = strtoul (buffer, NULL, 10);</span>
<span class='curline'><a href='../S/93.html#L612'>buffer</a>            612 src/w32select.c   char buffer[30];</span>
<span class='curline'><a href='../S/93.html#L613'>buffer</a>            613 src/w32select.c   sprintf (buffer, "cp%d-dos", (int) codepage);</span>
<span class='curline'><a href='../S/93.html#L614'>buffer</a>            614 src/w32select.c   return intern (buffer);</span>
<span class='curline'><a href='../S/293.html#L7423'>buffer</a>           7423 src/w32term.c    char *buffer = xmalloc (strlen (xrm_option) + 2);</span>
<span class='curline'><a href='../S/293.html#L7424'>buffer</a>           7424 src/w32term.c    char *current = buffer;</span>
<span class='curline'><a href='../S/293.html#L7459'>buffer</a>           7459 src/w32term.c    return buffer;</span>
<span class='curline'><a href='../S/306.html#L283'>buffer</a>            283 src/widget.c     char buffer[sizeof wmshell-&gt;wm.size_hints];</span>
<span class='curline'><a href='../S/306.html#L287'>buffer</a>            287 src/widget.c     memcpy (buffer, &amp;wmshell-&gt;wm.size_hints,</span>
<span class='curline'><a href='../S/306.html#L316'>buffer</a>            316 src/widget.c     return memcmp (hints_ptr + sizeof (long), buffer + sizeof (long),</span>
<span class='curline'><a href='../S/250.html#L230'>buffer</a>            230 src/window.c     struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/250.html#L280'>buffer</a>            280 src/window.c         struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/250.html#L1821'>buffer</a>           1821 src/window.c     struct buffer *b;</span>
<span class='curline'><a href='../S/250.html#L1841'>buffer</a>           1841 src/window.c         struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/250.html#L1892'>buffer</a>           1892 src/window.c   	  struct buffer *old_buffer = current_buffer;</span>
<span class='curline'><a href='../S/250.html#L1976'>buffer</a>           1976 src/window.c     struct buffer *buf;</span>
<span class='curline'><a href='../S/250.html#L2043'>buffer</a>           2043 src/window.c     register struct buffer *b;</span>
<span class='curline'><a href='../S/250.html#L2178'>buffer</a>           2178 src/window.c     struct buffer *b;</span>
<span class='curline'><a href='../S/250.html#L2414'>buffer</a>           2414 src/window.c         struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/250.html#L2440'>buffer</a>           2440 src/window.c     struct buffer *b = XBUFFER (buf);</span>
<span class='curline'><a href='../S/250.html#L2442'>buffer</a>           2442 src/window.c     eassert (b == XMARKER (w-&gt;pointm)-&gt;buffer);</span>
<span class='curline'><a href='../S/250.html#L3185'>buffer</a>           3185 src/window.c   		struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/250.html#L3189'>buffer</a>           3189 src/window.c   		if (!MARKERP (w-&gt;start) || XMARKER (w-&gt;start)-&gt;buffer != b)</span>
<span class='curline'><a href='../S/250.html#L3191'>buffer</a>           3191 src/window.c   		if (!MARKERP (w-&gt;pointm) || XMARKER (w-&gt;pointm)-&gt;buffer != b)</span>
<span class='curline'><a href='../S/250.html#L3233'>buffer</a>           3233 src/window.c     Lisp_Object buffer;</span>
<span class='curline'><a href='../S/250.html#L3236'>buffer</a>           3236 src/window.c       buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/250.html#L3238'>buffer</a>           3238 src/window.c       buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/250.html#L3240'>buffer</a>           3240 src/window.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/250.html#L3241'>buffer</a>           3241 src/window.c       return window_loop (GET_BUFFER_WINDOW, buffer, true, all_frames);</span>
<span class='curline'><a href='../S/250.html#L3486'>buffer</a>           3486 src/window.c   	  struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/250.html#L3515'>buffer</a>           3515 src/window.c   replace_buffer_in_windows (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/250.html#L3517'>buffer</a>           3517 src/window.c     call1 (Qreplace_buffer_in_windows, buffer);</span>
<span class='curline'><a href='../S/250.html#L3524'>buffer</a>           3524 src/window.c   replace_buffer_in_windows_safely (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/250.html#L3526'>buffer</a>           3526 src/window.c     if (buffer_window_count (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/250.html#L3534'>buffer</a>           3534 src/window.c   	window_loop (REPLACE_BUFFER_IN_WINDOWS_SAFELY, buffer, true, frame);</span>
<span class='curline'><a href='../S/250.html#L3603'>buffer</a>           3603 src/window.c   	Lisp_Object buffer = Fwindow_buffer (window);</span>
<span class='curline'><a href='../S/250.html#L3605'>buffer</a>           3605 src/window.c   				      buffer)))</span>
<span class='curline'><a href='../S/250.html#L3611'>buffer</a>           3611 src/window.c   					   buffer));</span>
<span class='curline'><a href='../S/250.html#L3790'>buffer</a>           3790 src/window.c   run_window_change_functions_1 (Lisp_Object symbol, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/250.html#L3795'>buffer</a>           3795 src/window.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/250.html#L3797'>buffer</a>           3797 src/window.c     else if (!NILP (Fassoc (symbol, BVAR (XBUFFER (buffer), local_var_alist),</span>
<span class='curline'><a href='../S/250.html#L3800'>buffer</a>           3800 src/window.c       funs = buffer_local_value (symbol, buffer);</span>
<span class='curline'><a href='../S/250.html#L3805'>buffer</a>           3805 src/window.c   	  &amp;&amp; (NILP (buffer)</span>
<span class='curline'><a href='../S/250.html#L3934'>buffer</a>           3934 src/window.c   	  Lisp_Object buffer = WINDOW_BUFFER (w);</span>
<span class='curline'><a href='../S/250.html#L3948'>buffer</a>           3948 src/window.c   	     &amp;&amp; (!EQ (buffer, w-&gt;old_buffer)</span>
<span class='curline'><a href='../S/250.html#L3976'>buffer</a>           3976 src/window.c   	      (Qwindow_buffer_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/250.html#L3980'>buffer</a>           3980 src/window.c   	      (Qwindow_size_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/250.html#L3993'>buffer</a>           3993 src/window.c   	      (Qwindow_selection_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/250.html#L4008'>buffer</a>           4008 src/window.c   	      (Qwindow_state_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/250.html#L4080'>buffer</a>           4080 src/window.c   set_window_buffer (Lisp_Object window, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/250.html#L4084'>buffer</a>           4084 src/window.c     struct buffer *b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/250.html#L4086'>buffer</a>           4086 src/window.c     bool samebuf = EQ (buffer, w-&gt;contents);</span>
<span class='curline'><a href='../S/250.html#L4088'>buffer</a>           4088 src/window.c     wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/250.html#L4113'>buffer</a>           4113 src/window.c         set_marker_both (w-&gt;pointm, buffer, BUF_PT (b), BUF_PT_BYTE (b));</span>
<span class='curline'><a href='../S/250.html#L4114'>buffer</a>           4114 src/window.c         set_marker_both (w-&gt;old_pointm, buffer, BUF_PT (b), BUF_PT_BYTE (b));</span>
<span class='curline'><a href='../S/250.html#L4117'>buffer</a>           4117 src/window.c   			     buffer);</span>
<span class='curline'><a href='../S/250.html#L4128'>buffer</a>           4128 src/window.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/250.html#L4186'>buffer</a>           4186 src/window.c     register Lisp_Object tem, buffer;</span>
<span class='curline'><a href='../S/250.html#L4190'>buffer</a>           4190 src/window.c     buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/250.html#L4191'>buffer</a>           4191 src/window.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/250.html#L4192'>buffer</a>           4192 src/window.c     if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/250.html#L4200'>buffer</a>           4200 src/window.c         if (!EQ (tem, buffer))</span>
<span class='curline'><a href='../S/250.html#L4217'>buffer</a>           4217 src/window.c     set_window_buffer (window, buffer, true, !NILP (keep_margins));</span>
<span class='curline'><a href='../S/250.html#L4223'>buffer</a>           4223 src/window.c   display_buffer (Lisp_Object buffer, Lisp_Object not_this_window_p, Lisp_Object override_frame)</span>
<span class='curline'><a href='../S/250.html#L4225'>buffer</a>           4225 src/window.c     return call3 (Qdisplay_buffer, buffer, not_this_window_p, override_frame);</span>
<span class='curline'><a href='../S/250.html#L4275'>buffer</a>           4275 src/window.c     register struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/250.html#L5563'>buffer</a>           5563 src/window.c     struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/250.html#L6574'>buffer</a>           6574 src/window.c     struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/250.html#L6637'>buffer</a>           6637 src/window.c     struct buffer *buf = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/250.html#L7006'>buffer</a>           7006 src/window.c     Lisp_Object window, buffer, start, pointm, old_pointm;</span>
<span class='curline'><a href='../S/250.html#L7145'>buffer</a>           7145 src/window.c   	      &amp;&amp; !EQ (w-&gt;contents, p-&gt;buffer)</span>
<span class='curline'><a href='../S/250.html#L7146'>buffer</a>           7146 src/window.c   	      &amp;&amp; BUFFER_LIVE_P (XBUFFER (p-&gt;buffer))</span>
<span class='curline'><a href='../S/250.html#L7147'>buffer</a>           7147 src/window.c   	      &amp;&amp; (NILP (Fminibufferp (p-&gt;buffer, Qnil))))</span>
<span class='curline'><a href='../S/250.html#L7277'>buffer</a>           7277 src/window.c   	      &amp;&amp; BUFFERP (p-&gt;buffer) &amp;&amp; BUFFER_LIVE_P (XBUFFER (p-&gt;buffer)))</span>
<span class='curline'><a href='../S/250.html#L7281'>buffer</a>           7281 src/window.c   	      wset_buffer (w, p-&gt;buffer);</span>
<span class='curline'><a href='../S/250.html#L7289'>buffer</a>           7289 src/window.c   	      if (!EQ (p-&gt;buffer, new_current_buffer)</span>
<span class='curline'><a href='../S/250.html#L7290'>buffer</a>           7290 src/window.c   		  &amp;&amp; XBUFFER (p-&gt;buffer) == current_buffer)</span>
<span class='curline'><a href='../S/250.html#L7297'>buffer</a>           7297 src/window.c   	      if (XMARKER (w-&gt;start)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/250.html#L7299'>buffer</a>           7299 src/window.c   	      if (XMARKER (w-&gt;pointm)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/250.html#L7304'>buffer</a>           7304 src/window.c   	      if (XMARKER (w-&gt;old_pointm)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/250.html#L7567'>buffer</a>           7567 src/window.c         p-&gt;buffer = (WINDOW_LEAF_P (w) ? w-&gt;contents : Qnil);</span>
<span class='curline'><a href='../S/250.html#L8273'>buffer</a>           8273 src/window.c   	  || !EQ (sw1-&gt;buffer, sw2-&gt;buffer)</span>
<span class='curline'><a href='../S/294.html#L1108'>buffer</a>           1108 src/window.h   void set_window_buffer (Lisp_Object window, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/294.html#L1136'>buffer</a>           1136 src/window.h   extern void bset_redisplay (struct buffer *b);</span>
<span class='curline'><a href='../S/294.html#L1137'>buffer</a>           1137 src/window.h   extern void bset_update_mode_line (struct buffer *b);</span>
<span class='curline'><a href='../S/236.html#L694'>buffer</a>            694 src/xdisp.c    static struct buffer *this_line_buffer;</span>
<span class='curline'><a href='../S/236.html#L882'>buffer</a>            882 src/xdisp.c    bset_redisplay (struct buffer *b)</span>
<span class='curline'><a href='../S/236.html#L898'>buffer</a>            898 src/xdisp.c    bset_update_mode_line (struct buffer *b)</span>
<span class='curline'><a href='../S/236.html#L971'>buffer</a>            971 src/xdisp.c    static struct buffer *displayed_buffer;</span>
<span class='curline'><a href='../S/236.html#L1544'>buffer</a>           1544 src/xdisp.c      struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/236.html#L1591'>buffer</a>           1591 src/xdisp.c          struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L1689'>buffer</a>           1689 src/xdisp.c      struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/236.html#L4542'>buffer</a>           4542 src/xdisp.c          struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L11627'>buffer</a>           11627 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L11628'>buffer</a>           11628 src/xdisp.c      struct buffer *old_b = NULL;</span>
<span class='curline'><a href='../S/236.html#L11665'>buffer</a>           11665 src/xdisp.c      struct buffer *b = (NILP (buffer_or_name)</span>
<span class='curline'><a href='../S/236.html#L11668'>buffer</a>           11668 src/xdisp.c      Lisp_Object buffer, value;</span>
<span class='curline'><a href='../S/236.html#L11671'>buffer</a>           11671 src/xdisp.c      XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/236.html#L11681'>buffer</a>           11681 src/xdisp.c      if (!EQ (buffer, w-&gt;contents))</span>
<span class='curline'><a href='../S/236.html#L11683'>buffer</a>           11683 src/xdisp.c          wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/236.html#L11684'>buffer</a>           11684 src/xdisp.c          set_marker_both (w-&gt;pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/236.html#L11685'>buffer</a>           11685 src/xdisp.c          set_marker_both (w-&gt;old_pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/236.html#L11702'>buffer</a>           11702 src/xdisp.c      struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L11784'>buffer</a>           11784 src/xdisp.c      char *buffer = SAFE_ALLOCA (len);</span>
<span class='curline'><a href='../S/236.html#L11785'>buffer</a>           11785 src/xdisp.c      memcpy (buffer, SDATA (msg), len);</span>
<span class='curline'><a href='../S/236.html#L11787'>buffer</a>           11787 src/xdisp.c      message_dolog (buffer, len - 1, true, STRING_MULTIBYTE (msg));</span>
<span class='curline'><a href='../S/236.html#L11821'>buffer</a>           11821 src/xdisp.c          struct buffer *oldbuf;</span>
<span class='curline'><a href='../S/236.html#L12055'>buffer</a>           12055 src/xdisp.c          char *buffer;</span>
<span class='curline'><a href='../S/236.html#L12057'>buffer</a>           12057 src/xdisp.c          SAFE_ALLOCA_STRING (buffer, m);</span>
<span class='curline'><a href='../S/236.html#L12058'>buffer</a>           12058 src/xdisp.c          message_dolog (buffer, nbytes, true, multibyte);</span>
<span class='curline'><a href='../S/236.html#L12358'>buffer</a>           12358 src/xdisp.c      Lisp_Object buffer;</span>
<span class='curline'><a href='../S/236.html#L12394'>buffer</a>           12394 src/xdisp.c      buffer = echo_area_buffer[this_one];</span>
<span class='curline'><a href='../S/236.html#L12398'>buffer</a>           12398 src/xdisp.c      if (echo_kboard == NULL &amp;&amp; EQ (buffer, echo_message_buffer))</span>
<span class='curline'><a href='../S/236.html#L12411'>buffer</a>           12411 src/xdisp.c      set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/236.html#L12414'>buffer</a>           12414 src/xdisp.c          wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/236.html#L12415'>buffer</a>           12415 src/xdisp.c          set_marker_both (w-&gt;pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/236.html#L12416'>buffer</a>           12416 src/xdisp.c          set_marker_both (w-&gt;old_pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/236.html#L12497'>buffer</a>           12497 src/xdisp.c          Lisp_Object buffer;</span>
<span class='curline'><a href='../S/236.html#L12500'>buffer</a>           12500 src/xdisp.c          buffer = AREF (vector, 4);</span>
<span class='curline'><a href='../S/236.html#L12502'>buffer</a>           12502 src/xdisp.c          wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/236.html#L12503'>buffer</a>           12503 src/xdisp.c          set_marker_restricted_both (w-&gt;pointm, buffer,</span>
<span class='curline'><a href='../S/236.html#L12506'>buffer</a>           12506 src/xdisp.c          set_marker_restricted_both (w-&gt;old_pointm, buffer,</span>
<span class='curline'><a href='../S/236.html#L12509'>buffer</a>           12509 src/xdisp.c          set_marker_restricted_both (w-&gt;start, buffer,</span>
<span class='curline'><a href='../S/236.html#L12762'>buffer</a>           12762 src/xdisp.c          struct buffer *old_current_buffer = NULL;</span>
<span class='curline'><a href='../S/236.html#L13274'>buffer</a>           13274 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L13359'>buffer</a>           13359 src/xdisp.c    			      struct buffer *obuf,</span>
<span class='curline'><a href='../S/236.html#L13388'>buffer</a>           13388 src/xdisp.c          Lisp_Object buffer = XWINDOW (target_frame-&gt;selected_window)-&gt;contents;</span>
<span class='curline'><a href='../S/236.html#L13389'>buffer</a>           13389 src/xdisp.c          struct buffer *b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/236.html#L13390'>buffer</a>           13390 src/xdisp.c          struct buffer *cb = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L13402'>buffer</a>           13402 src/xdisp.c          ASET (vector, 10, buffer);</span>
<span class='curline'><a href='../S/236.html#L13454'>buffer</a>           13454 src/xdisp.c    	  Lisp_Object buffer = AREF (vector, 10);</span>
<span class='curline'><a href='../S/236.html#L13456'>buffer</a>           13456 src/xdisp.c    	  if (BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/236.html#L13458'>buffer</a>           13458 src/xdisp.c    	      struct buffer *cb = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L13460'>buffer</a>           13460 src/xdisp.c    	      current_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/236.html#L13655'>buffer</a>           13655 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L13662'>buffer</a>           13662 src/xdisp.c              &amp;&amp; !buffer-&gt;text-&gt;redisplay</span>
<span class='curline'><a href='../S/236.html#L13832'>buffer</a>           13832 src/xdisp.c    	  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L13999'>buffer</a>           13999 src/xdisp.c    	  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L14924'>buffer</a>           14924 src/xdisp.c    	  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L15949'>buffer</a>           15949 src/xdisp.c    	      struct buffer *saved_current_buffer;</span>
<span class='curline'><a href='../S/236.html#L16051'>buffer</a>           16051 src/xdisp.c    		  struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L16258'>buffer</a>           16258 src/xdisp.c    	  &amp;&amp; current_buffer == XMARKER (val)-&gt;buffer)</span>
<span class='curline'><a href='../S/236.html#L16295'>buffer</a>           16295 src/xdisp.c    	  struct buffer *buf = XMARKER (val)-&gt;buffer;</span>
<span class='curline'><a href='../S/236.html#L16367'>buffer</a>           16367 src/xdisp.c    	  &amp;&amp; current_buffer == XMARKER (val)-&gt;buffer</span>
<span class='curline'><a href='../S/236.html#L16397'>buffer</a>           16397 src/xdisp.c    check_point_in_composition (struct buffer *prev_buf, ptrdiff_t prev_pt,</span>
<span class='curline'><a href='../S/236.html#L16398'>buffer</a>           16398 src/xdisp.c    			    struct buffer *buf, ptrdiff_t pt)</span>
<span class='curline'><a href='../S/236.html#L16402'>buffer</a>           16402 src/xdisp.c      Lisp_Object buffer;</span>
<span class='curline'><a href='../S/236.html#L16404'>buffer</a>           16404 src/xdisp.c      XSETBUFFER (buffer, buf);</span>
<span class='curline'><a href='../S/236.html#L16414'>buffer</a>           16414 src/xdisp.c    	  &amp;&amp; find_composition (prev_pt, -1, &amp;start, &amp;end, &amp;prop, buffer)</span>
<span class='curline'><a href='../S/236.html#L16424'>buffer</a>           16424 src/xdisp.c    	  &amp;&amp; find_composition (pt, -1, &amp;start, &amp;end, &amp;prop, buffer)</span>
<span class='curline'><a href='../S/236.html#L16434'>buffer</a>           16434 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L16438'>buffer</a>           16438 src/xdisp.c          &amp;&amp; w-&gt;current_matrix-&gt;buffer == b</span>
<span class='curline'><a href='../S/236.html#L16452'>buffer</a>           16452 src/xdisp.c          if ((w-&gt;current_matrix-&gt;buffer != b || pt != w-&gt;last_point)</span>
<span class='curline'><a href='../S/236.html#L16453'>buffer</a>           16453 src/xdisp.c    	  &amp;&amp; check_point_in_composition (w-&gt;current_matrix-&gt;buffer,</span>
<span class='curline'><a href='../S/236.html#L16475'>buffer</a>           16475 src/xdisp.c          struct buffer *thisb = XBUFFER (thisw-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L17438'>buffer</a>           17438 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L17459'>buffer</a>           17459 src/xdisp.c          w-&gt;current_matrix-&gt;buffer = b;</span>
<span class='curline'><a href='../S/236.html#L19342'>buffer</a>           19342 src/xdisp.c          struct buffer *buf = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L19355'>buffer</a>           19355 src/xdisp.c    	  struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L19390'>buffer</a>           19390 src/xdisp.c          struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L19391'>buffer</a>           19391 src/xdisp.c          struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/236.html#L19538'>buffer</a>           19538 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L19539'>buffer</a>           19539 src/xdisp.c      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L19571'>buffer</a>           19571 src/xdisp.c      eassert (XMARKER (w-&gt;start)-&gt;buffer == buffer);</span>
<span class='curline'><a href='../S/236.html#L19572'>buffer</a>           19572 src/xdisp.c      eassert (XMARKER (w-&gt;pointm)-&gt;buffer == buffer);</span>
<span class='curline'><a href='../S/236.html#L19582'>buffer</a>           19582 src/xdisp.c    		      || buffer-&gt;clip_changed</span>
<span class='curline'><a href='../S/236.html#L19583'>buffer</a>           19583 src/xdisp.c    		      || buffer-&gt;prevent_redisplay_optimizations_p);</span>
<span class='curline'><a href='../S/236.html#L19666'>buffer</a>           19666 src/xdisp.c          if (XMARKER (w-&gt;start)-&gt;buffer == current_buffer)</span>
<span class='curline'><a href='../S/236.html#L19723'>buffer</a>           19723 src/xdisp.c    	  struct buffer *buf = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L19752'>buffer</a>           19752 src/xdisp.c      if (XMARKER (w-&gt;start)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/236.html#L20090'>buffer</a>           20090 src/xdisp.c    	  &amp;&amp; XMARKER (w-&gt;start)-&gt;buffer == current_buffer</span>
<span class='curline'><a href='../S/236.html#L22663'>buffer</a>           22663 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L22666'>buffer</a>           22666 src/xdisp.c    	   BUF_PT (buffer), BUF_BEGV (buffer), BUF_ZV (buffer));</span>
<span class='curline'><a href='../S/236.html#L22834'>buffer</a>           22834 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L22835'>buffer</a>           22835 src/xdisp.c      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L22844'>buffer</a>           22844 src/xdisp.c      set_buffer_temp (buffer);</span>
<span class='curline'><a href='../S/236.html#L22850'>buffer</a>           22850 src/xdisp.c      multibyte_p = !NILP (BVAR (buffer, enable_multibyte_characters));</span>
<span class='curline'><a href='../S/236.html#L25680'>buffer</a>           25680 src/xdisp.c      (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/236.html#L25682'>buffer</a>           25682 src/xdisp.c      struct buffer *buf = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L25683'>buffer</a>           25683 src/xdisp.c      struct buffer *old = buf;</span>
<span class='curline'><a href='../S/236.html#L25685'>buffer</a>           25685 src/xdisp.c      if (! NILP (buffer))</span>
<span class='curline'><a href='../S/236.html#L25687'>buffer</a>           25687 src/xdisp.c          CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/236.html#L25688'>buffer</a>           25688 src/xdisp.c          buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/236.html#L25804'>buffer</a>           25804 src/xdisp.c      struct buffer *buf = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L25805'>buffer</a>           25805 src/xdisp.c      struct buffer *old = buf;</span>
<span class='curline'><a href='../S/236.html#L25922'>buffer</a>           25922 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L26396'>buffer</a>           26396 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L26737'>buffer</a>           26737 src/xdisp.c    	  struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L27638'>buffer</a>           27638 src/xdisp.c          Lisp_Object window, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/236.html#L27643'>buffer</a>           27643 src/xdisp.c      struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/236.html#L27653'>buffer</a>           27653 src/xdisp.c      if (NILP (buffer))</span>
<span class='curline'><a href='../S/236.html#L27654'>buffer</a>           27654 src/xdisp.c        buffer = w-&gt;contents;</span>
<span class='curline'><a href='../S/236.html#L27655'>buffer</a>           27655 src/xdisp.c      CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/236.html#L27656'>buffer</a>           27656 src/xdisp.c      if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/236.html#L27689'>buffer</a>           27689 src/xdisp.c      set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/236.html#L27983'>buffer</a>           27983 src/xdisp.c      struct buffer *b = current_buffer;</span>
<span class='curline'><a href='../S/236.html#L32955'>buffer</a>           32955 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/236.html#L35090'>buffer</a>           35090 src/xdisp.c      struct buffer *b;</span>
<span class='curline'><a href='../S/236.html#L35310'>buffer</a>           35310 src/xdisp.c          struct buffer *obuf;</span>
<span class='curline'><a href='../S/236.html#L35507'>buffer</a>           35507 src/xdisp.c    	      Lisp_Object buffer UNINIT;</span>
<span class='curline'><a href='../S/236.html#L35521'>buffer</a>           35521 src/xdisp.c    		      buffer = w-&gt;contents;</span>
<span class='curline'><a href='../S/236.html#L35527'>buffer</a>           35527 src/xdisp.c    		  buffer = object;</span>
<span class='curline'><a href='../S/236.html#L35546'>buffer</a>           35546 src/xdisp.c    		    = NILP (BVAR (XBUFFER (buffer), bidi_display_reordering))</span>
<span class='curline'><a href='../S/236.html#L35550'>buffer</a>           35550 src/xdisp.c    		    = NILP (BVAR (XBUFFER (buffer), bidi_display_reordering))</span>
<span class='curline'><a href='../S/236.html#L35551'>buffer</a>           35551 src/xdisp.c    		    ? make_fixnum (BUF_Z (XBUFFER (buffer))</span>
<span class='curline'><a href='../S/236.html#L35559'>buffer</a>           35559 src/xdisp.c    			(make_fixnum (pos + 1), Qmouse_face, buffer, lim1);</span>
<span class='curline'><a href='../S/236.html#L35561'>buffer</a>           35561 src/xdisp.c    			(make_fixnum (pos), Qmouse_face, buffer, lim2);</span>
<span class='curline'><a href='../S/236.html#L35581'>buffer</a>           35581 src/xdisp.c    					      ? BUF_Z (XBUFFER (buffer))</span>
<span class='curline'><a href='../S/236.html#L36101'>buffer</a>           36101 src/xdisp.c          struct buffer *oldbuf = current_buffer;</span>
<span class='curline'><a href='../S/68.html#L8741'>buffer</a>           8741 src/xfns.c       struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/77.html#L967'>buffer</a>            967 src/xmenu.c          struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/77.html#L968'>buffer</a>            968 src/xmenu.c          Lisp_Object buffer;</span>
<span class='curline'><a href='../S/77.html#L980'>buffer</a>            980 src/xmenu.c          buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/77.html#L993'>buffer</a>            993 src/xmenu.c          set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/47.html#L2341'>buffer</a>           2341 src/xterm.c      char *buffer;</span>
<span class='curline'><a href='../S/47.html#L2389'>buffer</a>           2389 src/xterm.c      buffer = dpyinfo-&gt;motif_drag_atom_name;</span>
<span class='curline'><a href='../S/47.html#L2393'>buffer</a>           2393 src/xterm.c          sprintf (buffer, "_EMACS_ATOM_%lu", i + 1);</span>
<span class='curline'><a href='../S/47.html#L2407'>buffer</a>           2407 src/xterm.c          sprintf (buffer, "_EMACS_ATOM_%lu", nitems + 1);</span>
<span class='curline'><a href='../S/47.html#L2408'>buffer</a>           2408 src/xterm.c          atom = XInternAtom (dpyinfo-&gt;display, buffer, False);</span>
<span class='curline'><a href='../S/47.html#L28781'>buffer</a>           28781 src/xterm.c      char *dpyinfo_pointer, *name, *value, *buffer;</span>
<span class='curline'><a href='../S/47.html#L28791'>buffer</a>           28791 src/xterm.c      buffer = alloca (45 + INT_STRLEN_BOUND (int));</span>
<span class='curline'><a href='../S/47.html#L28832'>buffer</a>           28832 src/xterm.c    	  sprintf (buffer, "_XSETTINGS_S%d",</span>
<span class='curline'><a href='../S/47.html#L28834'>buffer</a>           28834 src/xterm.c    	  return xstrdup (buffer);</span>
<span class='curline'><a href='../S/47.html#L28839'>buffer</a>           28839 src/xterm.c    	  sprintf (buffer, "_NET_WM_CM_S%d",</span>
<span class='curline'><a href='../S/47.html#L28841'>buffer</a>           28841 src/xterm.c    	  return xstrdup (buffer);</span>
<span class='curline'><a href='../S/57.html#L214'>buffer</a>            214 src/xwidget.c    if (NILP (xw-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L297'>buffer</a>            297 src/xwidget.c     Lisp_Object arguments, Lisp_Object buffer, Lisp_Object related)</span>
<span class='curline'><a href='../S/57.html#L316'>buffer</a>            316 src/xwidget.c    xw-&gt;buffer = (NILP (buffer) ? Fcurrent_buffer ()</span>
<span class='curline'><a href='../S/57.html#L317'>buffer</a>            317 src/xwidget.c  		: Fget_buffer_create (buffer, Qnil));</span>
<span class='curline'><a href='../S/57.html#L467'>buffer</a>            467 src/xwidget.c  	   &amp;&amp; !NILP (XXWIDGET (object)-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L679'>buffer</a>            679 src/xwidget.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/57.html#L683'>buffer</a>            683 src/xwidget.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/57.html#L685'>buffer</a>            685 src/xwidget.c    buffer = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/57.html#L686'>buffer</a>            686 src/xwidget.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/57.html#L694'>buffer</a>            694 src/xwidget.c        if (XWIDGETP (xw) &amp;&amp; EQ (Fxwidget_buffer (xw), buffer))</span>
<span class='curline'><a href='../S/57.html#L1311'>buffer</a>           1311 src/xwidget.c    if (NILP (XXWIDGET (view-&gt;model)-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L1378'>buffer</a>           1378 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L1430'>buffer</a>           1430 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L1480'>buffer</a>           1480 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L1934'>buffer</a>           1934 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L2169'>buffer</a>           2169 src/xwidget.c    if (NILP (w-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L2201'>buffer</a>           2201 src/xwidget.c    if (NILP (w-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L2989'>buffer</a>           2989 src/xwidget.c    if (!NILP (xww-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L3009'>buffer</a>           3009 src/xwidget.c    if (!NILP (xww-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L3022'>buffer</a>           3022 src/xwidget.c    if (NILP (xw-&gt;buffer) || !EQ (xw-&gt;type, Qwebkit))	\</span>
<span class='curline'><a href='../S/57.html#L3412'>buffer</a>           3412 src/xwidget.c    if (xw-&gt;embedder_view == xv &amp;&amp; !NILP (xw-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L3474'>buffer</a>           3474 src/xwidget.c    return XXWIDGET (xwidget)-&gt;buffer;</span>
<span class='curline'><a href='../S/57.html#L3481'>buffer</a>           3481 src/xwidget.c    (Lisp_Object xwidget, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/57.html#L3484'>buffer</a>           3484 src/xwidget.c    CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/57.html#L3486'>buffer</a>           3486 src/xwidget.c    XXWIDGET (xwidget)-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/57.html#L4225'>buffer</a>           4225 src/xwidget.c    xw-&gt;buffer = Qnil;</span>
<span class='curline'><a href='../S/57.html#L4259'>buffer</a>           4259 src/xwidget.c  kill_buffer_xwidgets (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/57.html#L4262'>buffer</a>           4262 src/xwidget.c    for (tail = Fget_buffer_xwidgets (buffer); CONSP (tail); tail = XCDR (tail))</span>
<span class='curline'><a href='../S/61.html#L61'>buffer</a>             61 src/xwidget.h    Lisp_Object buffer;</span>
<span class='curline'><a href='../S/61.html#L163'>buffer</a>            163 src/xwidget.h  #define XWIDGET_LIVE_P(w) (!NILP ((w)-&gt;buffer))</span>
<span class='curline'><a href='../S/3563.html#L221'>buffer</a>            221 test/manual/etags/c-src/abbrev.c   register char *buffer, *p;</span>
<span class='curline'><a href='../S/3563.html#L270'>buffer</a>            270 test/manual/etags/c-src/abbrev.c   p = buffer = (char *) alloca (wordend_byte - wordstart_byte);</span>
<span class='curline'><a href='../S/3563.html#L284'>buffer</a>            284 test/manual/etags/c-src/abbrev.c     sym = oblookup (current_buffer-&gt;abbrev_table, buffer,</span>
<span class='curline'><a href='../S/3563.html#L289'>buffer</a>            289 test/manual/etags/c-src/abbrev.c     sym = oblookup (Vglobal_abbrev_table, buffer,</span>
<span class='curline'><a href='../S/3576.html#L313'>buffer</a>            313 test/manual/etags/c-src/emacs/src/keyboard.c static void recursive_edit_unwind (Lisp_Object buffer);</span>
<span class='curline'><a href='../S/3576.html#L447'>buffer</a>            447 test/manual/etags/c-src/emacs/src/keyboard.c   char *buffer = initbuf;</span>
<span class='curline'><a href='../S/3576.html#L448'>buffer</a>            448 test/manual/etags/c-src/emacs/src/keyboard.c   char *ptr = buffer;</span>
<span class='curline'><a href='../S/3576.html#L464'>buffer</a>            464 test/manual/etags/c-src/emacs/src/keyboard.c       if (size - (ptr - buffer) &lt; nbytes)</span>
<span class='curline'><a href='../S/3576.html#L466'>buffer</a>            466 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptrdiff_t offset = ptr - buffer;</span>
<span class='curline'><a href='../S/3576.html#L468'>buffer</a>            468 test/manual/etags/c-src/emacs/src/keyboard.c 	  buffer = SAFE_ALLOCA (size);</span>
<span class='curline'><a href='../S/3576.html#L469'>buffer</a>            469 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptr = buffer + offset;</span>
<span class='curline'><a href='../S/3576.html#L482'>buffer</a>            482 test/manual/etags/c-src/emacs/src/keyboard.c       if (size - (ptr - buffer) &lt; len)</span>
<span class='curline'><a href='../S/3576.html#L484'>buffer</a>            484 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptrdiff_t offset = ptr - buffer;</span>
<span class='curline'><a href='../S/3576.html#L486'>buffer</a>            486 test/manual/etags/c-src/emacs/src/keyboard.c 	  buffer = SAFE_ALLOCA (size);</span>
<span class='curline'><a href='../S/3576.html#L487'>buffer</a>            487 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptr = buffer + offset;</span>
<span class='curline'><a href='../S/3576.html#L519'>buffer</a>            519 test/manual/etags/c-src/emacs/src/keyboard.c      concat2 (echo_string, make_string (buffer, ptr - buffer)));</span>
<span class='curline'><a href='../S/3576.html#L772'>buffer</a>            772 test/manual/etags/c-src/emacs/src/keyboard.c   Lisp_Object buffer;</span>
<span class='curline'><a href='../S/3576.html#L781'>buffer</a>            781 test/manual/etags/c-src/emacs/src/keyboard.c     buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/3576.html#L783'>buffer</a>            783 test/manual/etags/c-src/emacs/src/keyboard.c     buffer = Qnil;</span>
<span class='curline'><a href='../S/3576.html#L790'>buffer</a>            790 test/manual/etags/c-src/emacs/src/keyboard.c   record_unwind_protect (recursive_edit_unwind, buffer);</span>
<span class='curline'><a href='../S/3576.html#L804'>buffer</a>            804 test/manual/etags/c-src/emacs/src/keyboard.c recursive_edit_unwind (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/3576.html#L806'>buffer</a>            806 test/manual/etags/c-src/emacs/src/keyboard.c   if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/3576.html#L807'>buffer</a>            807 test/manual/etags/c-src/emacs/src/keyboard.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/3576.html#L1300'>buffer</a>           1300 test/manual/etags/c-src/emacs/src/keyboard.c   struct buffer *prev_buffer = NULL;</span>
<span class='curline'><a href='../S/3576.html#L1442'>buffer</a>           1442 test/manual/etags/c-src/emacs/src/keyboard.c 	  struct buffer *b;</span>
<span class='curline'><a href='../S/3576.html#L1596'>buffer</a>           1596 test/manual/etags/c-src/emacs/src/keyboard.c 		  &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer</span>
<span class='curline'><a href='../S/3576.html#L2918'>buffer</a>           2918 test/manual/etags/c-src/emacs/src/keyboard.c       struct buffer *prev_buffer = current_buffer;</span>
<span class='curline'><a href='../S/3576.html#L8981'>buffer</a>           8981 test/manual/etags/c-src/emacs/src/keyboard.c   struct buffer *starting_buffer;</span>
<span class='curline'><a href='../S/3577.html#L1027'>buffer</a>           1027 test/manual/etags/c-src/emacs/src/lisp.h INLINE struct buffer *</span>
<span class='curline'><a href='../S/3577.html#L2000'>buffer</a>           2000 test/manual/etags/c-src/emacs/src/lisp.h   struct buffer *buffer;</span>
<span class='curline'><a href='../S/3577.html#L3624'>buffer</a>           3624 test/manual/etags/c-src/emacs/src/lisp.h extern void make_gap_1 (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/3577.html#L3638'>buffer</a>           3638 test/manual/etags/c-src/emacs/src/lisp.h extern void insert_from_buffer (struct buffer *, ptrdiff_t, ptrdiff_t, bool);</span>
<span class='curline'><a href='../S/3577.html#L3655'>buffer</a>           3655 test/manual/etags/c-src/emacs/src/lisp.h extern void invalidate_buffer_caches (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/3577.html#L3884'>buffer</a>           3884 test/manual/etags/c-src/emacs/src/lisp.h extern struct buffer * allocate_buffer (void);</span>
<span class='curline'><a href='../S/3577.html#L4088'>buffer</a>           4088 test/manual/etags/c-src/emacs/src/lisp.h extern void clear_charpos_cache (struct buffer *);</span>
<span class='curline'><a href='../S/3577.html#L4089'>buffer</a>           4089 test/manual/etags/c-src/emacs/src/lisp.h extern ptrdiff_t buf_charpos_to_bytepos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/3577.html#L4090'>buffer</a>           4090 test/manual/etags/c-src/emacs/src/lisp.h extern ptrdiff_t buf_bytepos_to_charpos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/3577.html#L4096'>buffer</a>           4096 test/manual/etags/c-src/emacs/src/lisp.h extern Lisp_Object build_marker (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/3577.html#L4329'>buffer</a>           4329 test/manual/etags/c-src/emacs/src/lisp.h extern void truncate_undo_list (struct buffer *);</span>
<span class='curline'><a href='../S/3577.html#L4386'>buffer</a>           4386 test/manual/etags/c-src/emacs/src/lisp.h extern void unlock_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/3578.html#L341'>buffer</a>            341 test/manual/etags/c-src/emacs/src/regex.h   unsigned char *buffer;</span>
<span class='curline'><a href='../S/3574.html#L238'>buffer</a>            238 test/manual/etags/c-src/etags.c   char *buffer;</span>
<span class='curline'><a href='../S/3574.html#L1213'>buffer</a>           1213 test/manual/etags/c-src/etags.c 		    process_file_name (filename_lb.buffer, lang);</span>
<span class='curline'><a href='../S/3574.html#L1226'>buffer</a>           1226 test/manual/etags/c-src/etags.c   free (lb.buffer);</span>
<span class='curline'><a href='../S/3574.html#L1227'>buffer</a>           1227 test/manual/etags/c-src/etags.c   free (filebuf.buffer);</span>
<span class='curline'><a href='../S/3574.html#L1228'>buffer</a>           1228 test/manual/etags/c-src/etags.c   free (token_name.buffer);</span>
<span class='curline'><a href='../S/3574.html#L1683'>buffer</a>           1683 test/manual/etags/c-src/etags.c       &amp;&amp; lb.buffer[0] == '#'</span>
<span class='curline'><a href='../S/3574.html#L1684'>buffer</a>           1684 test/manual/etags/c-src/etags.c       &amp;&amp; lb.buffer[1] == '!')</span>
<span class='curline'><a href='../S/3574.html#L1691'>buffer</a>           1691 test/manual/etags/c-src/etags.c       lp = strrchr (lb.buffer+2, '/');</span>
<span class='curline'><a href='../S/3574.html#L1695'>buffer</a>           1695 test/manual/etags/c-src/etags.c 	lp = skip_spaces (lb.buffer + 2);</span>
<span class='curline'><a href='../S/3574.html#L2573'>buffer</a>           2573 test/manual/etags/c-src/etags.c       cn-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/3574.html#L2579'>buffer</a>           2579 test/manual/etags/c-src/etags.c       strcpy (cn-&gt;buffer, cstack.cname[0]);</span>
<span class='curline'><a href='../S/3574.html#L2587'>buffer</a>           2587 test/manual/etags/c-src/etags.c       len += sprintf (cn-&gt;buffer + len, "%s%s", qualifier, s);</span>
<span class='curline'><a href='../S/3574.html#L2803'>buffer</a>           2803 test/manual/etags/c-src/etags.c 	   memcpy (token_name.buffer, str, len);</span>
<span class='curline'><a href='../S/3574.html#L2804'>buffer</a>           2804 test/manual/etags/c-src/etags.c 	   token_name.buffer[len] = '\0';</span>
<span class='curline'><a href='../S/3574.html#L2819'>buffer</a>           2819 test/manual/etags/c-src/etags.c 	   memcpy (token_name.buffer + oldlen, str, len);</span>
<span class='curline'><a href='../S/3574.html#L2820'>buffer</a>           2820 test/manual/etags/c-src/etags.c 	   token_name.buffer[oldlen + len] = '\0';</span>
<span class='curline'><a href='../S/3574.html#L2942'>buffer</a>           2942 test/manual/etags/c-src/etags.c   lp = curlb.buffer;							\</span>
<span class='curline'><a href='../S/3574.html#L2965'>buffer</a>           2965 test/manual/etags/c-src/etags.c     make_tag (token_name.buffer, token_name.len, isfun, token.line,</span>
<span class='curline'><a href='../S/3574.html#L2969'>buffer</a>           2969 test/manual/etags/c-src/etags.c       make_tag (concat ("INVALID TOKEN:--&gt;", token_name.buffer, ""),</span>
<span class='curline'><a href='../S/3574.html#L3020'>buffer</a>           3020 test/manual/etags/c-src/etags.c   lp = curlb.buffer;</span>
<span class='curline'><a href='../S/3574.html#L3170'>buffer</a>           3170 test/manual/etags/c-src/etags.c 	      for (cp = newlb.buffer; cp &lt; lp-1; cp++)</span>
<span class='curline'><a href='../S/3574.html#L3243'>buffer</a>           3243 test/manual/etags/c-src/etags.c 			  || consider_token (newlb.buffer + tokoff, toklen, c,</span>
<span class='curline'><a href='../S/3574.html#L3268'>buffer</a>           3268 test/manual/etags/c-src/etags.c 			      sprintf (token_name.buffer + len, "%s%.*s",</span>
<span class='curline'><a href='../S/3574.html#L3269'>buffer</a>           3269 test/manual/etags/c-src/etags.c 				       qualifier, toklen, newlb.buffer + tokoff);</span>
<span class='curline'><a href='../S/3574.html#L3277'>buffer</a>           3277 test/manual/etags/c-src/etags.c 			      sprintf (token_name.buffer, "%s(%.*s)",</span>
<span class='curline'><a href='../S/3574.html#L3278'>buffer</a>           3278 test/manual/etags/c-src/etags.c 				       objtag, toklen, newlb.buffer + tokoff);</span>
<span class='curline'><a href='../S/3574.html#L3290'>buffer</a>           3290 test/manual/etags/c-src/etags.c 			      bool defun = (newlb.buffer[tokoff] == 'F');</span>
<span class='curline'><a href='../S/3574.html#L3302'>buffer</a>           3302 test/manual/etags/c-src/etags.c 			      memcpy (token_name.buffer,</span>
<span class='curline'><a href='../S/3574.html#L3303'>buffer</a>           3303 test/manual/etags/c-src/etags.c 				      newlb.buffer + off, len);</span>
<span class='curline'><a href='../S/3574.html#L3304'>buffer</a>           3304 test/manual/etags/c-src/etags.c 			      token_name.buffer[len] = '\0';</span>
<span class='curline'><a href='../S/3574.html#L3307'>buffer</a>           3307 test/manual/etags/c-src/etags.c 				  if (token_name.buffer[len] == '_')</span>
<span class='curline'><a href='../S/3574.html#L3308'>buffer</a>           3308 test/manual/etags/c-src/etags.c 				    token_name.buffer[len] = '-';</span>
<span class='curline'><a href='../S/3574.html#L3314'>buffer</a>           3314 test/manual/etags/c-src/etags.c 			      memcpy (token_name.buffer,</span>
<span class='curline'><a href='../S/3574.html#L3315'>buffer</a>           3315 test/manual/etags/c-src/etags.c 				      newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/3574.html#L3316'>buffer</a>           3316 test/manual/etags/c-src/etags.c 			      token_name.buffer[toklen] = '\0';</span>
<span class='curline'><a href='../S/3574.html#L3331'>buffer</a>           3331 test/manual/etags/c-src/etags.c 			  token.line = newlb.buffer;</span>
<span class='curline'><a href='../S/3574.html#L3402'>buffer</a>           3402 test/manual/etags/c-src/etags.c 	      if (!yacc_rules || lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/3574.html#L3404'>buffer</a>           3404 test/manual/etags/c-src/etags.c 		  tokoff = lp - 1 - newlb.buffer;</span>
<span class='curline'><a href='../S/3574.html#L3438'>buffer</a>           3438 test/manual/etags/c-src/etags.c 	      strcpy (token_name.buffer + toklen, ":");</span>
<span class='curline'><a href='../S/3574.html#L3726'>buffer</a>           3726 test/manual/etags/c-src/etags.c 	  if (!ignoreindent &amp;&amp; lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/3574.html#L3824'>buffer</a>           3824 test/manual/etags/c-src/etags.c   free (lbs[0].lb.buffer);</span>
<span class='curline'><a href='../S/3574.html#L3825'>buffer</a>           3825 test/manual/etags/c-src/etags.c   free (lbs[1].lb.buffer);</span>
<span class='curline'><a href='../S/3574.html#L3880'>buffer</a>           3880 test/manual/etags/c-src/etags.c            char_pointer = line_buffer.buffer,				\</span>
<span class='curline'><a href='../S/3574.html#L3945'>buffer</a>           3945 test/manual/etags/c-src/etags.c       dbp = lb.buffer;</span>
<span class='curline'><a href='../S/3574.html#L3956'>buffer</a>           3956 test/manual/etags/c-src/etags.c 	    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4033'>buffer</a>           4033 test/manual/etags/c-src/etags.c 			  lb.buffer, dbp - lb.buffer, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4065'>buffer</a>           4065 test/manual/etags/c-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/3574.html#L4106'>buffer</a>           4106 test/manual/etags/c-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4244'>buffer</a>           4244 test/manual/etags/c-src/etags.c 	    make_tag (lb.buffer, cp - lb.buffer, true,</span>
<span class='curline'><a href='../S/3574.html#L4245'>buffer</a>           4245 test/manual/etags/c-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4289'>buffer</a>           4289 test/manual/etags/c-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4300'>buffer</a>           4300 test/manual/etags/c-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4343'>buffer</a>           4343 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4370'>buffer</a>           4370 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4402'>buffer</a>           4402 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4415'>buffer</a>           4415 test/manual/etags/c-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4428'>buffer</a>           4428 test/manual/etags/c-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4443'>buffer</a>           4443 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4453'>buffer</a>           4453 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4484'>buffer</a>           4484 test/manual/etags/c-src/etags.c 		  lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4508'>buffer</a>           4508 test/manual/etags/c-src/etags.c 	  char * namestart = skip_spaces (lb.buffer);</span>
<span class='curline'><a href='../S/3574.html#L4513'>buffer</a>           4513 test/manual/etags/c-src/etags.c 		    lb.buffer, bp - lb.buffer + 2, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4550'>buffer</a>           4550 test/manual/etags/c-src/etags.c   dbp = lb.buffer;</span>
<span class='curline'><a href='../S/3574.html#L4567'>buffer</a>           4567 test/manual/etags/c-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/3574.html#L4649'>buffer</a>           4649 test/manual/etags/c-src/etags.c 			tline.buffer, taglen, save_lineno, save_lcno);</span>
<span class='curline'><a href='../S/3574.html#L4666'>buffer</a>           4666 test/manual/etags/c-src/etags.c 	  strcpy (tline.buffer, lb.buffer);</span>
<span class='curline'><a href='../S/3574.html#L4669'>buffer</a>           4669 test/manual/etags/c-src/etags.c 	  name = tline.buffer + (dbp - lb.buffer);</span>
<span class='curline'><a href='../S/3574.html#L4671'>buffer</a>           4671 test/manual/etags/c-src/etags.c 	  taglen = cp - lb.buffer + 1;</span>
<span class='curline'><a href='../S/3574.html#L4697'>buffer</a>           4697 test/manual/etags/c-src/etags.c   free (tline.buffer);</span>
<span class='curline'><a href='../S/3574.html#L4824'>buffer</a>           4824 test/manual/etags/c-src/etags.c 		    lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L4950'>buffer</a>           4950 test/manual/etags/c-src/etags.c 	  for (key = TEX_toktab; key-&gt;buffer != NULL; key++)</span>
<span class='curline'><a href='../S/3574.html#L4951'>buffer</a>           4951 test/manual/etags/c-src/etags.c 	    if (strneq (cp, key-&gt;buffer, key-&gt;len))</span>
<span class='curline'><a href='../S/3574.html#L4974'>buffer</a>           4974 test/manual/etags/c-src/etags.c 		    linelen = p - lb.buffer + 1;</span>
<span class='curline'><a href='../S/3574.html#L4977'>buffer</a>           4977 test/manual/etags/c-src/etags.c 			  lb.buffer, linelen, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L5053'>buffer</a>           5053 test/manual/etags/c-src/etags.c 	  TEX_toktab[i].buffer = savenstr (env, p - env);</span>
<span class='curline'><a href='../S/3574.html#L5061'>buffer</a>           5061 test/manual/etags/c-src/etags.c 	  TEX_toktab[i].buffer = NULL; /* Mark end of table. */</span>
<span class='curline'><a href='../S/3574.html#L5081'>buffer</a>           5081 test/manual/etags/c-src/etags.c 		  lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L5146'>buffer</a>           5146 test/manual/etags/c-src/etags.c 		memcpy (token_name.buffer, dbp, end - dbp);</span>
<span class='curline'><a href='../S/3574.html#L5147'>buffer</a>           5147 test/manual/etags/c-src/etags.c 		token_name.buffer[end - dbp] = '\0';</span>
<span class='curline'><a href='../S/3574.html#L5172'>buffer</a>           5172 test/manual/etags/c-src/etags.c 	    make_tag (token_name.buffer, token_name.len, true,</span>
<span class='curline'><a href='../S/3574.html#L5261'>buffer</a>           5261 test/manual/etags/c-src/etags.c       for (cp = plb-&gt;buffer; *cp != '\0'; cp++)</span>
<span class='curline'><a href='../S/3574.html#L5617'>buffer</a>           5617 test/manual/etags/c-src/etags.c 	  analyze_regex (regexbuf.buffer);</span>
<span class='curline'><a href='../S/3574.html#L5618'>buffer</a>           5618 test/manual/etags/c-src/etags.c 	free (regexbuf.buffer);</span>
<span class='curline'><a href='../S/3574.html#L5838'>buffer</a>           5838 test/manual/etags/c-src/etags.c   char *buffer = filebuf.buffer;</span>
<span class='curline'><a href='../S/3574.html#L5860'>buffer</a>           5860 test/manual/etags/c-src/etags.c 	  match = re_search (rp-&gt;pat, buffer, filebuf.len, charno,</span>
<span class='curline'><a href='../S/3574.html#L5891'>buffer</a>           5891 test/manual/etags/c-src/etags.c 		if (buffer[charno++] == '\n')</span>
<span class='curline'><a href='../S/3574.html#L5897'>buffer</a>           5897 test/manual/etags/c-src/etags.c 		name = substitute (buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/3574.html#L5900'>buffer</a>           5900 test/manual/etags/c-src/etags.c 		pfnote (name, true, buffer + linecharno,</span>
<span class='curline'><a href='../S/3574.html#L5903'>buffer</a>           5903 test/manual/etags/c-src/etags.c 		make_tag (name, strlen (name), true, buffer + linecharno,</span>
<span class='curline'><a href='../S/3574.html#L5938'>buffer</a>           5938 test/manual/etags/c-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L5961'>buffer</a>           5961 test/manual/etags/c-src/etags.c   char *buffer = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/3574.html#L5962'>buffer</a>           5962 test/manual/etags/c-src/etags.c   register char *p = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/3574.html#L5975'>buffer</a>           5975 test/manual/etags/c-src/etags.c 	  xrnew (buffer, lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/3574.html#L5976'>buffer</a>           5976 test/manual/etags/c-src/etags.c 	  p += buffer - lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/3574.html#L5977'>buffer</a>           5977 test/manual/etags/c-src/etags.c 	  pend = buffer + lbp-&gt;size;</span>
<span class='curline'><a href='../S/3574.html#L5978'>buffer</a>           5978 test/manual/etags/c-src/etags.c 	  lbp-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/3574.html#L5988'>buffer</a>           5988 test/manual/etags/c-src/etags.c 	  if (p &gt; buffer &amp;&amp; p[-1] == '\r')</span>
<span class='curline'><a href='../S/3574.html#L6011'>buffer</a>           6011 test/manual/etags/c-src/etags.c   lbp-&gt;len = p - buffer;</span>
<span class='curline'><a href='../S/3574.html#L6020'>buffer</a>           6020 test/manual/etags/c-src/etags.c 	  xrnew (filebuf.buffer, filebuf.size, char);</span>
<span class='curline'><a href='../S/3574.html#L6022'>buffer</a>           6022 test/manual/etags/c-src/etags.c       memcpy (filebuf.buffer + filebuf.len, lbp-&gt;buffer, lbp-&gt;len);</span>
<span class='curline'><a href='../S/3574.html#L6024'>buffer</a>           6024 test/manual/etags/c-src/etags.c       filebuf.buffer[filebuf.len++] = '\n';</span>
<span class='curline'><a href='../S/3574.html#L6025'>buffer</a>           6025 test/manual/etags/c-src/etags.c       filebuf.buffer[filebuf.len] = '\0';</span>
<span class='curline'><a href='../S/3574.html#L6052'>buffer</a>           6052 test/manual/etags/c-src/etags.c       if (result &gt; 12 &amp;&amp; strneq (lbp-&gt;buffer, "#line ", 6))</span>
<span class='curline'><a href='../S/3574.html#L6057'>buffer</a>           6057 test/manual/etags/c-src/etags.c 	  if (sscanf (lbp-&gt;buffer, "#line %u \"%n", &amp;lno, &amp;start) &gt;= 1</span>
<span class='curline'><a href='../S/3574.html#L6060'>buffer</a>           6060 test/manual/etags/c-src/etags.c 	      char *endp = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/3574.html#L6073'>buffer</a>           6073 test/manual/etags/c-src/etags.c 		  name = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/3574.html#L6182'>buffer</a>           6182 test/manual/etags/c-src/etags.c 	  match = re_match (rp-&gt;pat, lbp-&gt;buffer, lbp-&gt;len, 0, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/3574.html#L6211'>buffer</a>           6211 test/manual/etags/c-src/etags.c 		name = substitute (lbp-&gt;buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/3574.html#L6214'>buffer</a>           6214 test/manual/etags/c-src/etags.c 		pfnote (name, true, lbp-&gt;buffer, match, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L6217'>buffer</a>           6217 test/manual/etags/c-src/etags.c 			  lbp-&gt;buffer, match, lineno, linecharno);</span>
<span class='curline'><a href='../S/3574.html#L6517'>buffer</a>           6517 test/manual/etags/c-src/etags.c   lbp-&gt;buffer = xnew (lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/3574.html#L6518'>buffer</a>           6518 test/manual/etags/c-src/etags.c   lbp-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/3574.html#L6529'>buffer</a>           6529 test/manual/etags/c-src/etags.c       xrnew (lbp-&gt;buffer, lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/3564.html#L119'>buffer</a>            119 test/manual/etags/c-src/h.h struct re_pattern_buffer { unsigned char *buffer; };</span>
<span class='curline'><a href='../S/3616.html#L88'>buffer</a>             88 test/manual/etags/objc-src/PackInsp.h -subprocess:(Subprocess *)sender output:(char *)buffer;</span>
<span class='curline'><a href='../S/2534.html#L729'>buffer</a>            729 test/src/emacs-module-resources/mod-test.c   char *buffer = length == 0 ? NULL : malloc (length);</span>
<span class='curline'><a href='../S/2534.html#L730'>buffer</a>            730 test/src/emacs-module-resources/mod-test.c   if (buffer == NULL &amp;&amp; length != 0)</span>
<span class='curline'><a href='../S/2534.html#L735'>buffer</a>            735 test/src/emacs-module-resources/mod-test.c   memset (buffer, 'a', length);</span>
<span class='curline'><a href='../S/2534.html#L736'>buffer</a>            736 test/src/emacs-module-resources/mod-test.c   emacs_value ret = multibyte ? env-&gt;make_string (env, buffer, length)</span>
<span class='curline'><a href='../S/2534.html#L737'>buffer</a>            737 test/src/emacs-module-resources/mod-test.c                               : env-&gt;make_unibyte_string (env, buffer, length);</span>
<span class='curline'><a href='../S/2534.html#L738'>buffer</a>            738 test/src/emacs-module-resources/mod-test.c   free (buffer);</span>
</pre>
</body>
</html>
