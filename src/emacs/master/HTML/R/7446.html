<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>buffer</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.7' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/2787.html#L3558'>buffer</a>           3558 lib-src/ebrowse.c   static char *buffer;</span>
<span class='curline'><a href='../S/2787.html#L3572'>buffer</a>           3572 lib-src/ebrowse.c 	  buffer = (char *) xrealloc (buffer, buffer_size);</span>
<span class='curline'><a href='../S/2787.html#L3575'>buffer</a>           3575 lib-src/ebrowse.c       char *z = stpcpy (buffer, path-&gt;path);</span>
<span class='curline'><a href='../S/2787.html#L3578'>buffer</a>           3578 lib-src/ebrowse.c       fp = fopen (buffer, "r");</span>
<span class='curline'><a href='../S/2787.html#L3701'>buffer</a>           3701 lib-src/ebrowse.c   static char *buffer;</span>
<span class='curline'><a href='../S/2787.html#L3710'>buffer</a>           3710 lib-src/ebrowse.c 	  buffer = (char *) xrealloc (buffer, buffer_size);</span>
<span class='curline'><a href='../S/2787.html#L3713'>buffer</a>           3713 lib-src/ebrowse.c       buffer[i++] = c;</span>
<span class='curline'><a href='../S/2787.html#L3722'>buffer</a>           3722 lib-src/ebrowse.c       buffer = (char *) xrealloc (buffer, buffer_size);</span>
<span class='curline'><a href='../S/2787.html#L3725'>buffer</a>           3725 lib-src/ebrowse.c   buffer[i] = '\0';</span>
<span class='curline'><a href='../S/2787.html#L3726'>buffer</a>           3726 lib-src/ebrowse.c   if (i &gt; 0 &amp;&amp; buffer[i - 1] == '\r')</span>
<span class='curline'><a href='../S/2787.html#L3727'>buffer</a>           3727 lib-src/ebrowse.c     buffer[i - 1] = '\0';</span>
<span class='curline'><a href='../S/2787.html#L3728'>buffer</a>           3728 lib-src/ebrowse.c   return buffer;</span>
<span class='curline'><a href='../S/2790.html#L377'>buffer</a>            377 lib-src/emacsclient.c 	  char *buffer = xmalloc (size);</span>
<span class='curline'><a href='../S/2790.html#L378'>buffer</a>            378 lib-src/emacsclient.c 	  if (ExpandEnvironmentStrings (value, buffer, size))</span>
<span class='curline'><a href='../S/2790.html#L382'>buffer</a>            382 lib-src/emacsclient.c 	      return buffer;</span>
<span class='curline'><a href='../S/2790.html#L386'>buffer</a>            386 lib-src/emacsclient.c 	  free (buffer);</span>
<span class='curline'><a href='../S/2778.html#L310'>buffer</a>            310 lib-src/etags.c   char *buffer;</span>
<span class='curline'><a href='../S/2778.html#L1342'>buffer</a>           1342 lib-src/etags.c 		    process_file_name (filename_lb.buffer, lang);</span>
<span class='curline'><a href='../S/2778.html#L1357'>buffer</a>           1357 lib-src/etags.c   free (lb.buffer);</span>
<span class='curline'><a href='../S/2778.html#L1358'>buffer</a>           1358 lib-src/etags.c   free (filebuf.buffer);</span>
<span class='curline'><a href='../S/2778.html#L1359'>buffer</a>           1359 lib-src/etags.c   free (token_name.buffer);</span>
<span class='curline'><a href='../S/2778.html#L1471'>buffer</a>           1471 lib-src/etags.c       if (strstr (line.buffer, buf) == NULL)</span>
<span class='curline'><a href='../S/2778.html#L1473'>buffer</a>           1473 lib-src/etags.c           fprintf (otags_f, "%s\n", line.buffer);</span>
<span class='curline'><a href='../S/2778.html#L1479'>buffer</a>           1479 lib-src/etags.c   free (line.buffer);</span>
<span class='curline'><a href='../S/2778.html#L1887'>buffer</a>           1887 lib-src/etags.c       &amp;&amp; lb.buffer[0] == '#'</span>
<span class='curline'><a href='../S/2778.html#L1888'>buffer</a>           1888 lib-src/etags.c       &amp;&amp; lb.buffer[1] == '!')</span>
<span class='curline'><a href='../S/2778.html#L1895'>buffer</a>           1895 lib-src/etags.c       lp = strrchr (lb.buffer+2, '/');</span>
<span class='curline'><a href='../S/2778.html#L1899'>buffer</a>           1899 lib-src/etags.c 	lp = skip_spaces (lb.buffer + 2);</span>
<span class='curline'><a href='../S/2778.html#L2952'>buffer</a>           2952 lib-src/etags.c       cn-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/2778.html#L2958'>buffer</a>           2958 lib-src/etags.c       strcpy (cn-&gt;buffer, cstack.cname[0]);</span>
<span class='curline'><a href='../S/2778.html#L2968'>buffer</a>           2968 lib-src/etags.c       memcpyz (stpcpy (cn-&gt;buffer + len, qualifier), s, slen);</span>
<span class='curline'><a href='../S/2778.html#L3203'>buffer</a>           3203 lib-src/etags.c 	   memcpyz (token_name.buffer, str, len);</span>
<span class='curline'><a href='../S/2778.html#L3220'>buffer</a>           3220 lib-src/etags.c 	       memcpyz (token_name.buffer + oldlen, str, len);</span>
<span class='curline'><a href='../S/2778.html#L3351'>buffer</a>           3351 lib-src/etags.c   lp = curlb.buffer;							\</span>
<span class='curline'><a href='../S/2778.html#L3374'>buffer</a>           3374 lib-src/etags.c     make_tag (token_name.buffer, token_name.len, isfun, token.line,</span>
<span class='curline'><a href='../S/2778.html#L3378'>buffer</a>           3378 lib-src/etags.c       make_tag (concat ("INVALID TOKEN:--&gt;", token_name.buffer, ""),</span>
<span class='curline'><a href='../S/2778.html#L3434'>buffer</a>           3434 lib-src/etags.c   lp = curlb.buffer;</span>
<span class='curline'><a href='../S/2778.html#L3584'>buffer</a>           3584 lib-src/etags.c 	      for (cp = newlb.buffer; cp &lt; lp-1; cp++)</span>
<span class='curline'><a href='../S/2778.html#L3658'>buffer</a>           3658 lib-src/etags.c 			  || consider_token (newlb.buffer + tokoff, toklen, c,</span>
<span class='curline'><a href='../S/2778.html#L3685'>buffer</a>           3685 lib-src/etags.c 				  memcpyz (stpcpy (token_name.buffer + len,</span>
<span class='curline'><a href='../S/2778.html#L3687'>buffer</a>           3687 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/2778.html#L3692'>buffer</a>           3692 lib-src/etags.c 				  memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/2778.html#L3693'>buffer</a>           3693 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/2778.html#L3704'>buffer</a>           3704 lib-src/etags.c 				  char *p1 = stpcpy (token_name.buffer, objtag);</span>
<span class='curline'><a href='../S/2778.html#L3706'>buffer</a>           3706 lib-src/etags.c 				  char *p3 = mempcpy (p2, newlb.buffer + tokoff,</span>
<span class='curline'><a href='../S/2778.html#L3713'>buffer</a>           3713 lib-src/etags.c 				  memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/2778.html#L3714'>buffer</a>           3714 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/2778.html#L3727'>buffer</a>           3727 lib-src/etags.c 			      bool defun = (newlb.buffer[tokoff] == 'F');</span>
<span class='curline'><a href='../S/2778.html#L3738'>buffer</a>           3738 lib-src/etags.c 				  memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/2778.html#L3739'>buffer</a>           3739 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/2778.html#L3744'>buffer</a>           3744 lib-src/etags.c 				  token.line = newlb.buffer;</span>
<span class='curline'><a href='../S/2778.html#L3752'>buffer</a>           3752 lib-src/etags.c 			      memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/2778.html#L3753'>buffer</a>           3753 lib-src/etags.c 				       newlb.buffer + off, len);</span>
<span class='curline'><a href='../S/2778.html#L3756'>buffer</a>           3756 lib-src/etags.c 				  if (token_name.buffer[len] == '_')</span>
<span class='curline'><a href='../S/2778.html#L3757'>buffer</a>           3757 lib-src/etags.c 				    token_name.buffer[len] = '-';</span>
<span class='curline'><a href='../S/2778.html#L3763'>buffer</a>           3763 lib-src/etags.c 			      memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/2778.html#L3764'>buffer</a>           3764 lib-src/etags.c 				       newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/2778.html#L3779'>buffer</a>           3779 lib-src/etags.c 			  token.line = newlb.buffer;</span>
<span class='curline'><a href='../S/2778.html#L3854'>buffer</a>           3854 lib-src/etags.c 	      if (!yacc_rules || lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/2778.html#L3856'>buffer</a>           3856 lib-src/etags.c 		  tokoff = lp - 1 - newlb.buffer;</span>
<span class='curline'><a href='../S/2778.html#L3892'>buffer</a>           3892 lib-src/etags.c 		  strcpy (token_name.buffer + toklen, ":");</span>
<span class='curline'><a href='../S/2778.html#L4148'>buffer</a>           4148 lib-src/etags.c 		  char *cc, *uqname = token_name.buffer;</span>
<span class='curline'><a href='../S/2778.html#L4149'>buffer</a>           4149 lib-src/etags.c 		  char *tok_end = token_name.buffer + token_name.len;</span>
<span class='curline'><a href='../S/2778.html#L4151'>buffer</a>           4151 lib-src/etags.c 		  for (cc = token_name.buffer; cc &lt; tok_end; cc++)</span>
<span class='curline'><a href='../S/2778.html#L4159'>buffer</a>           4159 lib-src/etags.c 		  if (uqname &gt; token_name.buffer)</span>
<span class='curline'><a href='../S/2778.html#L4163'>buffer</a>           4163 lib-src/etags.c 		      memmove (token_name.buffer, uqname, uqlen + 1);</span>
<span class='curline'><a href='../S/2778.html#L4226'>buffer</a>           4226 lib-src/etags.c 	  if (!ignoreindent &amp;&amp; lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/2778.html#L4324'>buffer</a>           4324 lib-src/etags.c   free (lbs[0].lb.buffer);</span>
<span class='curline'><a href='../S/2778.html#L4325'>buffer</a>           4325 lib-src/etags.c   free (lbs[1].lb.buffer);</span>
<span class='curline'><a href='../S/2778.html#L4378'>buffer</a>           4378 lib-src/etags.c 	     (char_pointer) = (line_buffer).buffer,			\</span>
<span class='curline'><a href='../S/2778.html#L4442'>buffer</a>           4442 lib-src/etags.c       dbp = lb.buffer;</span>
<span class='curline'><a href='../S/2778.html#L4453'>buffer</a>           4453 lib-src/etags.c 	    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L4530'>buffer</a>           4530 lib-src/etags.c 			  lb.buffer, dbp - lb.buffer, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L4558'>buffer</a>           4558 lib-src/etags.c 	  make_tag (name, cp - name, false, lb.buffer,</span>
<span class='curline'><a href='../S/2778.html#L4559'>buffer</a>           4559 lib-src/etags.c 		    cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L4581'>buffer</a>           4581 lib-src/etags.c 	      make_tag (name, cp - name, true, lb.buffer,</span>
<span class='curline'><a href='../S/2778.html#L4582'>buffer</a>           4582 lib-src/etags.c 			cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L4600'>buffer</a>           4600 lib-src/etags.c 	  make_tag (name, cp - name, false, lb.buffer,</span>
<span class='curline'><a href='../S/2778.html#L4601'>buffer</a>           4601 lib-src/etags.c 		    cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L4629'>buffer</a>           4629 lib-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/2778.html#L4669'>buffer</a>           4669 lib-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L4807'>buffer</a>           4807 lib-src/etags.c 	    make_tag (lb.buffer, cp - lb.buffer, true,</span>
<span class='curline'><a href='../S/2778.html#L4808'>buffer</a>           4808 lib-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L4862'>buffer</a>           4862 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L4874'>buffer</a>           4874 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L4879'>buffer</a>           4879 lib-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L4920'>buffer</a>           4920 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L4947'>buffer</a>           4947 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L4990'>buffer</a>           4990 lib-src/etags.c 			    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L5031'>buffer</a>           5031 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L5073'>buffer</a>           5073 lib-src/etags.c 				  lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/2778.html#L5083'>buffer</a>           5083 lib-src/etags.c 			pfnote (wr_name, true, lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/2778.html#L5087'>buffer</a>           5087 lib-src/etags.c 				   curfdp-&gt;taggedfname, lineno, lb.buffer);</span>
<span class='curline'><a href='../S/2778.html#L5094'>buffer</a>           5094 lib-src/etags.c 				    lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/2778.html#L5159'>buffer</a>           5159 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/2778.html#L5193'>buffer</a>           5193 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L5206'>buffer</a>           5206 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L5219'>buffer</a>           5219 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L5234'>buffer</a>           5234 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L5244'>buffer</a>           5244 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L5275'>buffer</a>           5275 lib-src/etags.c 		  lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L5299'>buffer</a>           5299 lib-src/etags.c 	  char * namestart = skip_spaces (lb.buffer);</span>
<span class='curline'><a href='../S/2778.html#L5304'>buffer</a>           5304 lib-src/etags.c 		    lb.buffer, bp - lb.buffer + 2, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L5341'>buffer</a>           5341 lib-src/etags.c   dbp = lb.buffer;</span>
<span class='curline'><a href='../S/2778.html#L5358'>buffer</a>           5358 lib-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/2778.html#L5440'>buffer</a>           5440 lib-src/etags.c 			tline.buffer, taglen, save_lineno, save_lcno);</span>
<span class='curline'><a href='../S/2778.html#L5457'>buffer</a>           5457 lib-src/etags.c 	  strcpy (tline.buffer, lb.buffer);</span>
<span class='curline'><a href='../S/2778.html#L5460'>buffer</a>           5460 lib-src/etags.c 	  name = tline.buffer + (dbp - lb.buffer);</span>
<span class='curline'><a href='../S/2778.html#L5462'>buffer</a>           5462 lib-src/etags.c 	  taglen = cp - lb.buffer + 1;</span>
<span class='curline'><a href='../S/2778.html#L5488'>buffer</a>           5488 lib-src/etags.c   free (tline.buffer);</span>
<span class='curline'><a href='../S/2778.html#L5631'>buffer</a>           5631 lib-src/etags.c 		    lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L5687'>buffer</a>           5687 lib-src/etags.c 		      true, lb.buffer, name_end - lb.buffer,</span>
<span class='curline'><a href='../S/2778.html#L5797'>buffer</a>           5797 lib-src/etags.c 	  for (key = TEX_toktab; key-&gt;buffer != NULL; key++)</span>
<span class='curline'><a href='../S/2778.html#L5798'>buffer</a>           5798 lib-src/etags.c 	    if (strneq (cp, key-&gt;buffer, key-&gt;len))</span>
<span class='curline'><a href='../S/2778.html#L5821'>buffer</a>           5821 lib-src/etags.c 		    linelen = p - lb.buffer + 1;</span>
<span class='curline'><a href='../S/2778.html#L5824'>buffer</a>           5824 lib-src/etags.c 			  lb.buffer, linelen, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L5868'>buffer</a>           5868 lib-src/etags.c 	  TEX_toktab[i].buffer = savenstr (env, p - env);</span>
<span class='curline'><a href='../S/2778.html#L5876'>buffer</a>           5876 lib-src/etags.c 	  TEX_toktab[i].buffer = NULL; /* Mark end of table. */</span>
<span class='curline'><a href='../S/2778.html#L5896'>buffer</a>           5896 lib-src/etags.c 		  lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L5961'>buffer</a>           5961 lib-src/etags.c 		memcpyz (token_name.buffer, dbp, end - dbp);</span>
<span class='curline'><a href='../S/2778.html#L5986'>buffer</a>           5986 lib-src/etags.c 	    make_tag (token_name.buffer, token_name.len, true,</span>
<span class='curline'><a href='../S/2778.html#L6074'>buffer</a>           6074 lib-src/etags.c       for (cp = plb-&gt;buffer; *cp != '\0'; cp++)</span>
<span class='curline'><a href='../S/2778.html#L6395'>buffer</a>           6395 lib-src/etags.c       for (cp = plb-&gt;buffer; *cp != '\0'; ++cp)</span>
<span class='curline'><a href='../S/2778.html#L6933'>buffer</a>           6933 lib-src/etags.c 	  analyze_regex (regexbuf.buffer);</span>
<span class='curline'><a href='../S/2778.html#L6934'>buffer</a>           6934 lib-src/etags.c 	free (regexbuf.buffer);</span>
<span class='curline'><a href='../S/2778.html#L7153'>buffer</a>           7153 lib-src/etags.c   char *buffer = filebuf.buffer;</span>
<span class='curline'><a href='../S/2778.html#L7175'>buffer</a>           7175 lib-src/etags.c 	  match = re_search (rp-&gt;pat, buffer, filebuf.len, charno,</span>
<span class='curline'><a href='../S/2778.html#L7206'>buffer</a>           7206 lib-src/etags.c 		if (buffer[charno++] == '\n')</span>
<span class='curline'><a href='../S/2778.html#L7212'>buffer</a>           7212 lib-src/etags.c 		name = substitute (buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/2778.html#L7215'>buffer</a>           7215 lib-src/etags.c 	      pfnote (name, true, buffer + linecharno,</span>
<span class='curline'><a href='../S/2778.html#L7221'>buffer</a>           7221 lib-src/etags.c 			 lineno, buffer + linecharno);</span>
<span class='curline'><a href='../S/2778.html#L7255'>buffer</a>           7255 lib-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L7274'>buffer</a>           7274 lib-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L7297'>buffer</a>           7297 lib-src/etags.c   char *buffer = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/2778.html#L7298'>buffer</a>           7298 lib-src/etags.c   char *p = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/2778.html#L7310'>buffer</a>           7310 lib-src/etags.c 	  xrnew (buffer, lbp-&gt;size, 2);</span>
<span class='curline'><a href='../S/2778.html#L7311'>buffer</a>           7311 lib-src/etags.c 	  p = buffer + lbp-&gt;size;</span>
<span class='curline'><a href='../S/2778.html#L7313'>buffer</a>           7313 lib-src/etags.c 	  pend = buffer + lbp-&gt;size;</span>
<span class='curline'><a href='../S/2778.html#L7314'>buffer</a>           7314 lib-src/etags.c 	  lbp-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/2778.html#L7326'>buffer</a>           7326 lib-src/etags.c           if (!leave_cr &amp;&amp; p &gt; buffer &amp;&amp; p[-1] == '\r')</span>
<span class='curline'><a href='../S/2778.html#L7340'>buffer</a>           7340 lib-src/etags.c   lbp-&gt;len = p - buffer;</span>
<span class='curline'><a href='../S/2778.html#L7348'>buffer</a>           7348 lib-src/etags.c 	  xrnew (filebuf.buffer, filebuf.size, 2);</span>
<span class='curline'><a href='../S/2778.html#L7351'>buffer</a>           7351 lib-src/etags.c       strcpy (mempcpy (filebuf.buffer + filebuf.len, lbp-&gt;buffer, lbp-&gt;len),</span>
<span class='curline'><a href='../S/2778.html#L7378'>buffer</a>           7378 lib-src/etags.c       if (result &gt; 12 &amp;&amp; strneq (lbp-&gt;buffer, "#line ", 6))</span>
<span class='curline'><a href='../S/2778.html#L7383'>buffer</a>           7383 lib-src/etags.c 	  if (sscanf (lbp-&gt;buffer, "#line %"SCNdMAX" \"%n", &amp;lno, &amp;start) &gt;= 1</span>
<span class='curline'><a href='../S/2778.html#L7386'>buffer</a>           7386 lib-src/etags.c 	      char *endp = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/2778.html#L7399'>buffer</a>           7399 lib-src/etags.c 		  name = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/2778.html#L7508'>buffer</a>           7508 lib-src/etags.c 	  match = re_match (rp-&gt;pat, lbp-&gt;buffer, lbp-&gt;len, 0, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/2778.html#L7537'>buffer</a>           7537 lib-src/etags.c 		name = substitute (lbp-&gt;buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/2778.html#L7540'>buffer</a>           7540 lib-src/etags.c 	      pfnote (name, true, lbp-&gt;buffer, match, lineno, linecharno);</span>
<span class='curline'><a href='../S/2778.html#L7545'>buffer</a>           7545 lib-src/etags.c 			 lineno, lbp-&gt;buffer);</span>
<span class='curline'><a href='../S/2778.html#L7999'>buffer</a>           7999 lib-src/etags.c   lbp-&gt;buffer = xnew (lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/2778.html#L8000'>buffer</a>           8000 lib-src/etags.c   lbp-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/2778.html#L8011'>buffer</a>           8011 lib-src/etags.c       xrnew (lbp-&gt;buffer, lbp-&gt;size, multiplier);</span>
<span class='curline'><a href='../S/2782.html#L267'>buffer</a>            267 lib-src/pop.c    server-&gt;buffer = (char *) malloc (GETLINE_MIN);</span>
<span class='curline'><a href='../S/2782.html#L268'>buffer</a>            268 lib-src/pop.c    if (! server-&gt;buffer)</span>
<span class='curline'><a href='../S/2782.html#L950'>buffer</a>            950 lib-src/pop.c    free (server-&gt;buffer);</span>
<span class='curline'><a href='../S/2782.html#L1237'>buffer</a>           1237 lib-src/pop.c        char *cp = find_crlf (server-&gt;buffer + server-&gt;buffer_index,</span>
<span class='curline'><a href='../S/2782.html#L1245'>buffer</a>           1245 lib-src/pop.c  	  data_used = (cp + 2) - server-&gt;buffer - found;</span>
<span class='curline'><a href='../S/2782.html#L1254'>buffer</a>           1254 lib-src/pop.c  	    fprintf (stderr, "&lt;&lt;&lt; %s\n", server-&gt;buffer + found);</span>
<span class='curline'><a href='../S/2782.html#L1255'>buffer</a>           1255 lib-src/pop.c  	  *line = server-&gt;buffer + found;</span>
<span class='curline'><a href='../S/2782.html#L1260'>buffer</a>           1260 lib-src/pop.c  	  memmove (server-&gt;buffer, server-&gt;buffer + server-&gt;buffer_index,</span>
<span class='curline'><a href='../S/2782.html#L1286'>buffer</a>           1286 lib-src/pop.c  	  server-&gt;buffer = (char *)realloc (server-&gt;buffer, server-&gt;buffer_size);</span>
<span class='curline'><a href='../S/2782.html#L1287'>buffer</a>           1287 lib-src/pop.c  	  if (! server-&gt;buffer)</span>
<span class='curline'><a href='../S/2782.html#L1294'>buffer</a>           1294 lib-src/pop.c        ret = RECV (server-&gt;file, server-&gt;buffer + server-&gt;data,</span>
<span class='curline'><a href='../S/2782.html#L1313'>buffer</a>           1313 lib-src/pop.c  	  server-&gt;buffer[server-&gt;data] = '\0';</span>
<span class='curline'><a href='../S/2782.html#L1315'>buffer</a>           1315 lib-src/pop.c  	  cp = find_crlf (server-&gt;buffer + search_offset,</span>
<span class='curline'><a href='../S/2782.html#L1319'>buffer</a>           1319 lib-src/pop.c  	      int data_used = (cp + 2) - server-&gt;buffer;</span>
<span class='curline'><a href='../S/2782.html#L1325'>buffer</a>           1325 lib-src/pop.c  		fprintf (stderr, "&lt;&lt;&lt; %s\n", server-&gt;buffer);</span>
<span class='curline'><a href='../S/2782.html#L1326'>buffer</a>           1326 lib-src/pop.c  	      *line = server-&gt;buffer;</span>
<span class='curline'><a href='../S/2782.html#L1531'>buffer</a>           1531 lib-src/pop.c        if (server-&gt;buffer)</span>
<span class='curline'><a href='../S/2782.html#L1533'>buffer</a>           1533 lib-src/pop.c  	  free (server-&gt;buffer);</span>
<span class='curline'><a href='../S/2782.html#L1534'>buffer</a>           1534 lib-src/pop.c  	  server-&gt;buffer = 0;</span>
<span class='curline'><a href='../S/2785.html#L35'>buffer</a>             35 lib-src/pop.h    char *buffer;</span>
<span class='curline'><a href='../S/2584.html#L61'>buffer</a>             61 lib/af_alg.h   afalg_buffer (const char *buffer, size_t len, const char *alg,</span>
<span class='curline'><a href='../S/2584.html#L96'>buffer</a>             96 lib/af_alg.h   afalg_buffer (const char *buffer, size_t len, const char *alg,</span>
<span class='curline'><a href='../S/2694.html#L64'>buffer</a>             64 lib/careadlinkat.c               char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2694.html#L72'>buffer</a>             72 lib/careadlinkat.c   if (!buffer)</span>
<span class='curline'><a href='../S/2694.html#L74'>buffer</a>             74 lib/careadlinkat.c       buffer = stack_buf;</span>
<span class='curline'><a href='../S/2694.html#L78'>buffer</a>             78 lib/careadlinkat.c   char *buf = buffer;</span>
<span class='curline'><a href='../S/2694.html#L88'>buffer</a>             88 lib/careadlinkat.c           if (buf != buffer)</span>
<span class='curline'><a href='../S/2694.html#L112'>buffer</a>            112 lib/careadlinkat.c           if (link_size &lt; buf_size &amp;&amp; buf != buffer &amp;&amp; alloc-&gt;reallocate)</span>
<span class='curline'><a href='../S/2694.html#L123'>buffer</a>            123 lib/careadlinkat.c       if (buf != buffer)</span>
<span class='curline'><a href='../S/2694.html#L167'>buffer</a>            167 lib/careadlinkat.c               char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2694.html#L180'>buffer</a>            180 lib/careadlinkat.c   return readlink_stk (fd, filename, buffer, buffer_size, alloc,</span>
<span class='curline'><a href='../S/2621.html#L55'>buffer</a>             55 lib/careadlinkat.h                     char *restrict buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2603.html#L34'>buffer</a>             34 lib/execinfo.in.h backtrace (void **buffer, int size)</span>
<span class='curline'><a href='../S/2603.html#L36'>buffer</a>             36 lib/execinfo.in.h   (void) buffer;</span>
<span class='curline'><a href='../S/2603.html#L42'>buffer</a>             42 lib/execinfo.in.h backtrace_symbols (void *const *buffer, int size)</span>
<span class='curline'><a href='../S/2603.html#L44'>buffer</a>             44 lib/execinfo.in.h   (void) buffer;</span>
<span class='curline'><a href='../S/2603.html#L50'>buffer</a>             50 lib/execinfo.in.h backtrace_symbols_fd (void *const *buffer, int size, int fd)</span>
<span class='curline'><a href='../S/2603.html#L52'>buffer</a>             52 lib/execinfo.in.h   (void) buffer;</span>
<span class='curline'><a href='../S/2728.html#L112'>buffer</a>            112 lib/getrandom.c getrandom (void *buffer, size_t length, unsigned int flags)</span>
<span class='curline'><a href='../S/2728.html#L128'>buffer</a>            128 lib/getrandom.c           &amp;&amp; BCryptGenRandomFunc (NULL, buffer, length,</span>
<span class='curline'><a href='../S/2728.html#L153'>buffer</a>            153 lib/getrandom.c         if (!CryptGenRandom (provider, length, buffer))</span>
<span class='curline'><a href='../S/2728.html#L165'>buffer</a>            165 lib/getrandom.c   return getrandom (buffer, length, flags);</span>
<span class='curline'><a href='../S/2728.html#L188'>buffer</a>            188 lib/getrandom.c   return read (fd, buffer, length);</span>
<span class='curline'><a href='../S/2739.html#L75'>buffer</a>             75 lib/malloc/scratch_buffer.h scratch_buffer_init (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2739.html#L77'>buffer</a>             77 lib/malloc/scratch_buffer.h   buffer-&gt;data = buffer-&gt;__space.__c;</span>
<span class='curline'><a href='../S/2739.html#L78'>buffer</a>             78 lib/malloc/scratch_buffer.h   buffer-&gt;length = sizeof (buffer-&gt;__space);</span>
<span class='curline'><a href='../S/2739.html#L83'>buffer</a>             83 lib/malloc/scratch_buffer.h scratch_buffer_free (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2739.html#L85'>buffer</a>             85 lib/malloc/scratch_buffer.h   if (buffer-&gt;data != buffer-&gt;__space.__c)</span>
<span class='curline'><a href='../S/2739.html#L86'>buffer</a>             86 lib/malloc/scratch_buffer.h     free (buffer-&gt;data);</span>
<span class='curline'><a href='../S/2739.html#L94'>buffer</a>             94 lib/malloc/scratch_buffer.h bool __libc_scratch_buffer_grow (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2739.html#L99'>buffer</a>             99 lib/malloc/scratch_buffer.h scratch_buffer_grow (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2739.html#L101'>buffer</a>            101 lib/malloc/scratch_buffer.h   return __glibc_likely (__libc_scratch_buffer_grow (buffer));</span>
<span class='curline'><a href='../S/2739.html#L106'>buffer</a>            106 lib/malloc/scratch_buffer.h bool __libc_scratch_buffer_grow_preserve (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2739.html#L111'>buffer</a>            111 lib/malloc/scratch_buffer.h scratch_buffer_grow_preserve (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2739.html#L113'>buffer</a>            113 lib/malloc/scratch_buffer.h   return __glibc_likely (__libc_scratch_buffer_grow_preserve (buffer));</span>
<span class='curline'><a href='../S/2739.html#L122'>buffer</a>            122 lib/malloc/scratch_buffer.h bool __libc_scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2739.html#L128'>buffer</a>            128 lib/malloc/scratch_buffer.h scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2739.html#L132'>buffer</a>            132 lib/malloc/scratch_buffer.h 			 (buffer, nelem, size));</span>
<span class='curline'><a href='../S/2745.html#L27'>buffer</a>             27 lib/malloc/scratch_buffer_dupfree.c __libc_scratch_buffer_dupfree (struct scratch_buffer *buffer, size_t size)</span>
<span class='curline'><a href='../S/2745.html#L29'>buffer</a>             29 lib/malloc/scratch_buffer_dupfree.c   void *data = buffer-&gt;data;</span>
<span class='curline'><a href='../S/2745.html#L30'>buffer</a>             30 lib/malloc/scratch_buffer_dupfree.c   if (data == buffer-&gt;__space.__c)</span>
<span class='curline'><a href='../S/2743.html#L27'>buffer</a>             27 lib/malloc/scratch_buffer_grow.c __libc_scratch_buffer_grow (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2743.html#L30'>buffer</a>             30 lib/malloc/scratch_buffer_grow.c   size_t new_length = buffer-&gt;length * 2;</span>
<span class='curline'><a href='../S/2743.html#L33'>buffer</a>             33 lib/malloc/scratch_buffer_grow.c   scratch_buffer_free (buffer);</span>
<span class='curline'><a href='../S/2743.html#L36'>buffer</a>             36 lib/malloc/scratch_buffer_grow.c   if (__glibc_likely (new_length &gt;= buffer-&gt;length))</span>
<span class='curline'><a href='../S/2743.html#L47'>buffer</a>             47 lib/malloc/scratch_buffer_grow.c       scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2743.html#L52'>buffer</a>             52 lib/malloc/scratch_buffer_grow.c   buffer-&gt;data = new_ptr;</span>
<span class='curline'><a href='../S/2743.html#L53'>buffer</a>             53 lib/malloc/scratch_buffer_grow.c   buffer-&gt;length = new_length;</span>
<span class='curline'><a href='../S/2734.html#L28'>buffer</a>             28 lib/malloc/scratch_buffer_grow_preserve.c __libc_scratch_buffer_grow_preserve (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2734.html#L30'>buffer</a>             30 lib/malloc/scratch_buffer_grow_preserve.c   size_t new_length = 2 * buffer-&gt;length;</span>
<span class='curline'><a href='../S/2734.html#L33'>buffer</a>             33 lib/malloc/scratch_buffer_grow_preserve.c   if (buffer-&gt;data == buffer-&gt;__space.__c)</span>
<span class='curline'><a href='../S/2734.html#L40'>buffer</a>             40 lib/malloc/scratch_buffer_grow_preserve.c       memcpy (new_ptr, buffer-&gt;__space.__c, buffer-&gt;length);</span>
<span class='curline'><a href='../S/2734.html#L45'>buffer</a>             45 lib/malloc/scratch_buffer_grow_preserve.c       if (__glibc_likely (new_length &gt;= buffer-&gt;length))</span>
<span class='curline'><a href='../S/2734.html#L46'>buffer</a>             46 lib/malloc/scratch_buffer_grow_preserve.c 	new_ptr = realloc (buffer-&gt;data, new_length);</span>
<span class='curline'><a href='../S/2734.html#L56'>buffer</a>             56 lib/malloc/scratch_buffer_grow_preserve.c 	  free (buffer-&gt;data);</span>
<span class='curline'><a href='../S/2734.html#L57'>buffer</a>             57 lib/malloc/scratch_buffer_grow_preserve.c 	  scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2734.html#L63'>buffer</a>             63 lib/malloc/scratch_buffer_grow_preserve.c   buffer-&gt;data = new_ptr;</span>
<span class='curline'><a href='../S/2734.html#L64'>buffer</a>             64 lib/malloc/scratch_buffer_grow_preserve.c   buffer-&gt;length = new_length;</span>
<span class='curline'><a href='../S/2742.html#L28'>buffer</a>             28 lib/malloc/scratch_buffer_set_array_size.c __libc_scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2742.html#L39'>buffer</a>             39 lib/malloc/scratch_buffer_set_array_size.c       scratch_buffer_free (buffer);</span>
<span class='curline'><a href='../S/2742.html#L40'>buffer</a>             40 lib/malloc/scratch_buffer_set_array_size.c       scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2742.html#L45'>buffer</a>             45 lib/malloc/scratch_buffer_set_array_size.c   if (new_length &lt;= buffer-&gt;length)</span>
<span class='curline'><a href='../S/2742.html#L49'>buffer</a>             49 lib/malloc/scratch_buffer_set_array_size.c   scratch_buffer_free (buffer);</span>
<span class='curline'><a href='../S/2742.html#L55'>buffer</a>             55 lib/malloc/scratch_buffer_set_array_size.c       scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2742.html#L60'>buffer</a>             60 lib/malloc/scratch_buffer_set_array_size.c   buffer-&gt;data = new_ptr;</span>
<span class='curline'><a href='../S/2742.html#L61'>buffer</a>             61 lib/malloc/scratch_buffer_set_array_size.c   buffer-&gt;length = new_length;</span>
<span class='curline'><a href='../S/2724.html#L69'>buffer</a>             69 lib/md5-stream.c   char *buffer = malloc (BLOCKSIZE + 72);</span>
<span class='curline'><a href='../S/2724.html#L70'>buffer</a>             70 lib/md5-stream.c   if (!buffer)</span>
<span class='curline'><a href='../S/2724.html#L97'>buffer</a>             97 lib/md5-stream.c           n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);</span>
<span class='curline'><a href='../S/2724.html#L111'>buffer</a>            111 lib/md5-stream.c                   free (buffer);</span>
<span class='curline'><a href='../S/2724.html#L121'>buffer</a>            121 lib/md5-stream.c       md5_process_block (buffer, BLOCKSIZE, &amp;ctx);</span>
<span class='curline'><a href='../S/2724.html#L128'>buffer</a>            128 lib/md5-stream.c     md5_process_bytes (buffer, sum, &amp;ctx);</span>
<span class='curline'><a href='../S/2724.html#L132'>buffer</a>            132 lib/md5-stream.c   free (buffer);</span>
<span class='curline'><a href='../S/2693.html#L115'>buffer</a>            115 lib/md5.c        ctx-&gt;buffer[size - 2] = SWAP (ctx-&gt;total[0] &lt;&lt; 3);</span>
<span class='curline'><a href='../S/2693.html#L116'>buffer</a>            116 lib/md5.c        ctx-&gt;buffer[size - 1] = SWAP ((ctx-&gt;total[1] &lt;&lt; 3) | (ctx-&gt;total[0] &gt;&gt; 29));</span>
<span class='curline'><a href='../S/2693.html#L118'>buffer</a>            118 lib/md5.c        memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);</span>
<span class='curline'><a href='../S/2693.html#L121'>buffer</a>            121 lib/md5.c        md5_process_block (ctx-&gt;buffer, size * 4, ctx);</span>
<span class='curline'><a href='../S/2693.html#L131'>buffer</a>            131 lib/md5.c      md5_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2693.html#L139'>buffer</a>            139 lib/md5.c        md5_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2693.html#L147'>buffer</a>            147 lib/md5.c      md5_process_bytes (const void *buffer, size_t len, struct md5_ctx *ctx)</span>
<span class='curline'><a href='../S/2693.html#L156'>buffer</a>            156 lib/md5.c            memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2693.html#L161'>buffer</a>            161 lib/md5.c                md5_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2693.html#L166'>buffer</a>            166 lib/md5.c                memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2693.html#L167'>buffer</a>            167 lib/md5.c                        &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~63],</span>
<span class='curline'><a href='../S/2693.html#L171'>buffer</a>            171 lib/md5.c            buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2693.html#L180'>buffer</a>            180 lib/md5.c            if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2693.html#L183'>buffer</a>            183 lib/md5.c                  md5_process_block (memcpy (ctx-&gt;buffer, buffer, 64), 64, ctx);</span>
<span class='curline'><a href='../S/2693.html#L184'>buffer</a>            184 lib/md5.c                  buffer = (const char *) buffer + 64;</span>
<span class='curline'><a href='../S/2693.html#L190'>buffer</a>            190 lib/md5.c                md5_process_block (buffer, len &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2693.html#L191'>buffer</a>            191 lib/md5.c                buffer = (const char *) buffer + (len &amp; ~63);</span>
<span class='curline'><a href='../S/2693.html#L201'>buffer</a>            201 lib/md5.c            memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2693.html#L205'>buffer</a>            205 lib/md5.c                md5_process_block (ctx-&gt;buffer, 64, ctx);</span>
<span class='curline'><a href='../S/2693.html#L209'>buffer</a>            209 lib/md5.c                memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2693.html#L229'>buffer</a>            229 lib/md5.c      md5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)</span>
<span class='curline'><a href='../S/2693.html#L232'>buffer</a>            232 lib/md5.c        const uint32_t *words = buffer;</span>
<span class='curline'><a href='../S/2626.html#L86'>buffer</a>             86 lib/md5.h        uint32_t buffer[32]; /* 128 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2626.html#L102'>buffer</a>            102 lib/md5.h      extern void __md5_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2626.html#L109'>buffer</a>            109 lib/md5.h      extern void __md5_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2626.html#L131'>buffer</a>            131 lib/md5.h      extern void *__md5_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2767.html#L253'>buffer</a>            253 lib/regcomp.c    re_dfa_t *dfa = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2767.html#L284'>buffer</a>            284 lib/regcomp.c    re_dfa_t *dfa = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2767.html#L445'>buffer</a>            445 lib/regcomp.c    preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2767.html#L609'>buffer</a>            609 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2767.html#L615'>buffer</a>            615 lib/regcomp.c    preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2767.html#L649'>buffer</a>            649 lib/regcomp.c        if (!re_comp_buf.buffer)</span>
<span class='curline'><a href='../S/2767.html#L654'>buffer</a>            654 lib/regcomp.c    if (re_comp_buf.buffer)</span>
<span class='curline'><a href='../S/2767.html#L717'>buffer</a>            717 lib/regcomp.c    dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2767.html#L724'>buffer</a>            724 lib/regcomp.c        dfa = re_realloc (preg-&gt;buffer, re_dfa_t, 1);</span>
<span class='curline'><a href='../S/2767.html#L728'>buffer</a>            728 lib/regcomp.c        preg-&gt;buffer = dfa;</span>
<span class='curline'><a href='../S/2767.html#L738'>buffer</a>            738 lib/regcomp.c        preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2767.html#L757'>buffer</a>            757 lib/regcomp.c        preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2767.html#L788'>buffer</a>            788 lib/regcomp.c        preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2767.html#L944'>buffer</a>            944 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2767.html#L1127'>buffer</a>           1127 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2767.html#L1308'>buffer</a>           1308 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2767.html#L2084'>buffer</a>           2084 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2767.html#L2118'>buffer</a>           2118 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2767.html#L2168'>buffer</a>           2168 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2767.html#L2212'>buffer</a>           2212 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2767.html#L2444'>buffer</a>           2444 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2676.html#L417'>buffer</a>            417 lib/regex.h      struct re_dfa_t *__REPB_PREFIX(buffer);</span>
<span class='curline'><a href='../S/2747.html#L192'>buffer</a>            192 lib/regexec.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2747.html#L372'>buffer</a>            372 lib/regexec.c    re_dfa_t *dfa = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2747.html#L585'>buffer</a>            585 lib/regexec.c    const re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2747.html#L1368'>buffer</a>           1368 lib/regexec.c    const re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2589.html#L67'>buffer</a>             67 lib/scratch_buffer.h extern void scratch_buffer_init (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2589.html#L72'>buffer</a>             72 lib/scratch_buffer.h extern void scratch_buffer_free (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2589.html#L81'>buffer</a>             81 lib/scratch_buffer.h extern bool scratch_buffer_grow (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2589.html#L87'>buffer</a>             87 lib/scratch_buffer.h extern bool scratch_buffer_grow_preserve (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2589.html#L97'>buffer</a>             97 lib/scratch_buffer.h extern bool scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2713.html#L104'>buffer</a>            104 lib/sha1.c       ctx-&gt;buffer[size - 2] = SWAP ((ctx-&gt;total[1] &lt;&lt; 3) | (ctx-&gt;total[0] &gt;&gt; 29));</span>
<span class='curline'><a href='../S/2713.html#L105'>buffer</a>            105 lib/sha1.c       ctx-&gt;buffer[size - 1] = SWAP (ctx-&gt;total[0] &lt;&lt; 3);</span>
<span class='curline'><a href='../S/2713.html#L107'>buffer</a>            107 lib/sha1.c       memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);</span>
<span class='curline'><a href='../S/2713.html#L110'>buffer</a>            110 lib/sha1.c       sha1_process_block (ctx-&gt;buffer, size * 4, ctx);</span>
<span class='curline'><a href='../S/2713.html#L120'>buffer</a>            120 lib/sha1.c     sha1_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2713.html#L128'>buffer</a>            128 lib/sha1.c       sha1_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2713.html#L135'>buffer</a>            135 lib/sha1.c     sha1_process_bytes (const void *buffer, size_t len, struct sha1_ctx *ctx)</span>
<span class='curline'><a href='../S/2713.html#L144'>buffer</a>            144 lib/sha1.c           memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2713.html#L149'>buffer</a>            149 lib/sha1.c               sha1_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2713.html#L154'>buffer</a>            154 lib/sha1.c               memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2713.html#L155'>buffer</a>            155 lib/sha1.c                       &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~63],</span>
<span class='curline'><a href='../S/2713.html#L159'>buffer</a>            159 lib/sha1.c           buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2713.html#L168'>buffer</a>            168 lib/sha1.c           if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2713.html#L171'>buffer</a>            171 lib/sha1.c                 sha1_process_block (memcpy (ctx-&gt;buffer, buffer, 64), 64, ctx);</span>
<span class='curline'><a href='../S/2713.html#L172'>buffer</a>            172 lib/sha1.c                 buffer = (const char *) buffer + 64;</span>
<span class='curline'><a href='../S/2713.html#L178'>buffer</a>            178 lib/sha1.c               sha1_process_block (buffer, len &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2713.html#L179'>buffer</a>            179 lib/sha1.c               buffer = (const char *) buffer + (len &amp; ~63);</span>
<span class='curline'><a href='../S/2713.html#L189'>buffer</a>            189 lib/sha1.c           memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2713.html#L193'>buffer</a>            193 lib/sha1.c               sha1_process_block (ctx-&gt;buffer, 64, ctx);</span>
<span class='curline'><a href='../S/2713.html#L197'>buffer</a>            197 lib/sha1.c               memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2713.html#L222'>buffer</a>            222 lib/sha1.c     sha1_process_block (const void *buffer, size_t len, struct sha1_ctx *ctx)</span>
<span class='curline'><a href='../S/2713.html#L224'>buffer</a>            224 lib/sha1.c       const uint32_t *words = buffer;</span>
<span class='curline'><a href='../S/2704.html#L58'>buffer</a>             58 lib/sha1.h       uint32_t buffer[32]; /* 128 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2704.html#L68'>buffer</a>             68 lib/sha1.h     extern void sha1_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2704.html#L75'>buffer</a>             75 lib/sha1.h     extern void sha1_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2704.html#L95'>buffer</a>             95 lib/sha1.h     extern void *sha1_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2668.html#L137'>buffer</a>            137 lib/sha256.c     set_uint32 ((char *) &amp;ctx-&gt;buffer[size - 2],</span>
<span class='curline'><a href='../S/2668.html#L139'>buffer</a>            139 lib/sha256.c     set_uint32 ((char *) &amp;ctx-&gt;buffer[size - 1],</span>
<span class='curline'><a href='../S/2668.html#L142'>buffer</a>            142 lib/sha256.c     memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);</span>
<span class='curline'><a href='../S/2668.html#L145'>buffer</a>            145 lib/sha256.c     sha256_process_block (ctx-&gt;buffer, size * 4, ctx);</span>
<span class='curline'><a href='../S/2668.html#L167'>buffer</a>            167 lib/sha256.c   sha256_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2668.html#L175'>buffer</a>            175 lib/sha256.c     sha256_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2668.html#L182'>buffer</a>            182 lib/sha256.c   sha224_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2668.html#L190'>buffer</a>            190 lib/sha256.c     sha256_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2668.html#L197'>buffer</a>            197 lib/sha256.c   sha256_process_bytes (const void *buffer, size_t len, struct sha256_ctx *ctx)</span>
<span class='curline'><a href='../S/2668.html#L206'>buffer</a>            206 lib/sha256.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2668.html#L211'>buffer</a>            211 lib/sha256.c             sha256_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2668.html#L216'>buffer</a>            216 lib/sha256.c             memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2668.html#L217'>buffer</a>            217 lib/sha256.c                     &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~63],</span>
<span class='curline'><a href='../S/2668.html#L221'>buffer</a>            221 lib/sha256.c         buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2668.html#L230'>buffer</a>            230 lib/sha256.c         if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2668.html#L233'>buffer</a>            233 lib/sha256.c               sha256_process_block (memcpy (ctx-&gt;buffer, buffer, 64), 64, ctx);</span>
<span class='curline'><a href='../S/2668.html#L234'>buffer</a>            234 lib/sha256.c               buffer = (const char *) buffer + 64;</span>
<span class='curline'><a href='../S/2668.html#L240'>buffer</a>            240 lib/sha256.c             sha256_process_block (buffer, len &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2668.html#L241'>buffer</a>            241 lib/sha256.c             buffer = (const char *) buffer + (len &amp; ~63);</span>
<span class='curline'><a href='../S/2668.html#L251'>buffer</a>            251 lib/sha256.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2668.html#L255'>buffer</a>            255 lib/sha256.c             sha256_process_block (ctx-&gt;buffer, 64, ctx);</span>
<span class='curline'><a href='../S/2668.html#L259'>buffer</a>            259 lib/sha256.c             memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2668.html#L297'>buffer</a>            297 lib/sha256.c   sha256_process_block (const void *buffer, size_t len, struct sha256_ctx *ctx)</span>
<span class='curline'><a href='../S/2668.html#L299'>buffer</a>            299 lib/sha256.c     const uint32_t *words = buffer;</span>
<span class='curline'><a href='../S/2594.html#L56'>buffer</a>             56 lib/sha256.h     uint32_t buffer[32]; /* 128 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2594.html#L67'>buffer</a>             67 lib/sha256.h   extern void sha256_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2594.html#L74'>buffer</a>             74 lib/sha256.h   extern void sha256_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2594.html#L98'>buffer</a>             98 lib/sha256.h   extern void *sha256_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2594.html#L100'>buffer</a>            100 lib/sha256.h   extern void *sha224_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2643.html#L137'>buffer</a>            137 lib/sha512.c     set_uint64 ((char *) &amp;ctx-&gt;buffer[size - 2],</span>
<span class='curline'><a href='../S/2643.html#L140'>buffer</a>            140 lib/sha512.c     set_uint64 ((char *) &amp;ctx-&gt;buffer[size - 1],</span>
<span class='curline'><a href='../S/2643.html#L143'>buffer</a>            143 lib/sha512.c     memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 8 - bytes);</span>
<span class='curline'><a href='../S/2643.html#L146'>buffer</a>            146 lib/sha512.c     sha512_process_block (ctx-&gt;buffer, size * 8, ctx);</span>
<span class='curline'><a href='../S/2643.html#L168'>buffer</a>            168 lib/sha512.c   sha512_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2643.html#L176'>buffer</a>            176 lib/sha512.c     sha512_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2643.html#L183'>buffer</a>            183 lib/sha512.c   sha384_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2643.html#L191'>buffer</a>            191 lib/sha512.c     sha512_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2643.html#L198'>buffer</a>            198 lib/sha512.c   sha512_process_bytes (const void *buffer, size_t len, struct sha512_ctx *ctx)</span>
<span class='curline'><a href='../S/2643.html#L207'>buffer</a>            207 lib/sha512.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2643.html#L212'>buffer</a>            212 lib/sha512.c             sha512_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~127, ctx);</span>
<span class='curline'><a href='../S/2643.html#L217'>buffer</a>            217 lib/sha512.c             memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2643.html#L218'>buffer</a>            218 lib/sha512.c                     &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~127],</span>
<span class='curline'><a href='../S/2643.html#L222'>buffer</a>            222 lib/sha512.c         buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2643.html#L231'>buffer</a>            231 lib/sha512.c         if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2643.html#L234'>buffer</a>            234 lib/sha512.c               sha512_process_block (memcpy (ctx-&gt;buffer, buffer, 128), 128, ctx);</span>
<span class='curline'><a href='../S/2643.html#L235'>buffer</a>            235 lib/sha512.c               buffer = (const char *) buffer + 128;</span>
<span class='curline'><a href='../S/2643.html#L241'>buffer</a>            241 lib/sha512.c             sha512_process_block (buffer, len &amp; ~127, ctx);</span>
<span class='curline'><a href='../S/2643.html#L242'>buffer</a>            242 lib/sha512.c             buffer = (const char *) buffer + (len &amp; ~127);</span>
<span class='curline'><a href='../S/2643.html#L252'>buffer</a>            252 lib/sha512.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2643.html#L256'>buffer</a>            256 lib/sha512.c             sha512_process_block (ctx-&gt;buffer, 128, ctx);</span>
<span class='curline'><a href='../S/2643.html#L260'>buffer</a>            260 lib/sha512.c             memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2643.html#L322'>buffer</a>            322 lib/sha512.c   sha512_process_block (const void *buffer, size_t len, struct sha512_ctx *ctx)</span>
<span class='curline'><a href='../S/2643.html#L324'>buffer</a>            324 lib/sha512.c     u64 const *words = buffer;</span>
<span class='curline'><a href='../S/2650.html#L56'>buffer</a>             56 lib/sha512.h     u64 buffer[32]; /* 256 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2650.html#L67'>buffer</a>             67 lib/sha512.h   extern void sha512_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2650.html#L74'>buffer</a>             74 lib/sha512.h   extern void sha512_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2650.html#L101'>buffer</a>            101 lib/sha512.h   extern void *sha512_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2650.html#L103'>buffer</a>            103 lib/sha512.h   extern void *sha384_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2726.html#L79'>buffer</a>             79 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags)</span>
<span class='curline'><a href='../S/2726.html#L82'>buffer</a>             82 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags));</span>
<span class='curline'><a href='../S/2726.html#L86'>buffer</a>             86 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags)</span>
<span class='curline'><a href='../S/2726.html#L90'>buffer</a>             90 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags));</span>
<span class='curline'><a href='../S/2749.html#L1236'>buffer</a>           1236 lib/unistd.in.h _GL_FUNCDECL_RPL (getentropy, int, (void *buffer, size_t length));</span>
<span class='curline'><a href='../S/2749.html#L1237'>buffer</a>           1237 lib/unistd.in.h _GL_CXXALIAS_RPL (getentropy, int, (void *buffer, size_t length));</span>
<span class='curline'><a href='../S/2749.html#L1240'>buffer</a>           1240 lib/unistd.in.h _GL_FUNCDECL_SYS (getentropy, int, (void *buffer, size_t length));</span>
<span class='curline'><a href='../S/2749.html#L1242'>buffer</a>           1242 lib/unistd.in.h _GL_CXXALIAS_SYS (getentropy, int, (void *buffer, size_t length));</span>
<span class='curline'><a href='../S/6.html#L43'>buffer</a>             43 nt/cmdproxy.c  extern int _snprintf (char *buffer, size_t count, const char *format, ...);</span>
<span class='curline'><a href='../S/6.html#L284'>buffer</a>            284 nt/cmdproxy.c  search_dir (const char *dir, const char *exec, int bufsize, char *buffer)</span>
<span class='curline'><a href='../S/6.html#L307'>buffer</a>            307 nt/cmdproxy.c        rc = SearchPath (dir, exec_ext, NULL, bufsize, buffer, &amp;dummy);</span>
<span class='curline'><a href='../S/6.html#L315'>buffer</a>            315 nt/cmdproxy.c  	  rc = SearchPath (dir, exec_ext, NULL, bufsize, buffer, &amp;dummy);</span>
<span class='curline'><a href='../S/6.html#L324'>buffer</a>            324 nt/cmdproxy.c  	  rc = SearchPath (dir, exec, exts[i], bufsize, buffer, &amp;dummy);</span>
<span class='curline'><a href='../S/2238.html#L474'>buffer</a>            474 src/alloc.c    static void mark_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/2238.html#L3359'>buffer</a>           3359 src/alloc.c          eassert (! PSEUDOVEC_STRUCT (vector, Lisp_Marker)-&gt;buffer);</span>
<span class='curline'><a href='../S/2238.html#L3615'>buffer</a>           3615 src/alloc.c    struct buffer *</span>
<span class='curline'><a href='../S/2238.html#L3618'>buffer</a>           3618 src/alloc.c      struct buffer *b</span>
<span class='curline'><a href='../S/2238.html#L3619'>buffer</a>           3619 src/alloc.c        = ALLOCATE_PSEUDOVECTOR (struct buffer, cursor_in_non_selected_windows_,</span>
<span class='curline'><a href='../S/2238.html#L3940'>buffer</a>           3940 src/alloc.c      p-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2238.html#L3951'>buffer</a>           3951 src/alloc.c      p-&gt;buffer = 0;</span>
<span class='curline'><a href='../S/2238.html#L3964'>buffer</a>           3964 src/alloc.c    build_marker (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t bytepos)</span>
<span class='curline'><a href='../S/2238.html#L3974'>buffer</a>           3974 src/alloc.c      m-&gt;buffer = buf;</span>
<span class='curline'><a href='../S/2238.html#L6192'>buffer</a>           6192 src/alloc.c                       struct buffer *buffer,</span>
<span class='curline'><a href='../S/2238.html#L6197'>buffer</a>           6197 src/alloc.c      eassert (buffer-&gt;base_buffer == NULL);</span>
<span class='curline'><a href='../S/2238.html#L6198'>buffer</a>           6198 src/alloc.c      eassert (buffer-&gt;overlays == NULL);</span>
<span class='curline'><a href='../S/2238.html#L6201'>buffer</a>           6201 src/alloc.c      visit_vectorlike_root (visitor, (struct Lisp_Vector *) buffer, type);</span>
<span class='curline'><a href='../S/2238.html#L6355'>buffer</a>           6355 src/alloc.c      Lisp_Object tail, buffer;</span>
<span class='curline'><a href='../S/2238.html#L6373'>buffer</a>           6373 src/alloc.c      FOR_EACH_LIVE_BUFFER (tail, buffer)</span>
<span class='curline'><a href='../S/2238.html#L6374'>buffer</a>           6374 src/alloc.c        compact_buffer (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2238.html#L6476'>buffer</a>           6476 src/alloc.c      FOR_EACH_LIVE_BUFFER (tail, buffer)</span>
<span class='curline'><a href='../S/2238.html#L6478'>buffer</a>           6478 src/alloc.c          struct buffer *nextb = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2238.html#L6618'>buffer</a>           6618 src/alloc.c        list3 (Qbuffers, make_fixnum (sizeof (struct buffer)),</span>
<span class='curline'><a href='../S/2238.html#L6779'>buffer</a>           6779 src/alloc.c    mark_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/2238.html#L6782'>buffer</a>           6782 src/alloc.c      mark_vectorlike (&amp;buffer-&gt;header);</span>
<span class='curline'><a href='../S/2238.html#L6786'>buffer</a>           6786 src/alloc.c      mark_interval_tree (buffer_intervals (buffer));</span>
<span class='curline'><a href='../S/2238.html#L6794'>buffer</a>           6794 src/alloc.c      if (!BUFFER_LIVE_P (buffer))</span>
<span class='curline'><a href='../S/2238.html#L6795'>buffer</a>           6795 src/alloc.c          mark_object (BVAR (buffer, undo_list));</span>
<span class='curline'><a href='../S/2238.html#L6797'>buffer</a>           6797 src/alloc.c      if (!itree_empty_p (buffer-&gt;overlays))</span>
<span class='curline'><a href='../S/2238.html#L6798'>buffer</a>           6798 src/alloc.c        mark_overlays (buffer-&gt;overlays-&gt;root);</span>
<span class='curline'><a href='../S/2238.html#L6801'>buffer</a>           6801 src/alloc.c      if (buffer-&gt;base_buffer &amp;&amp;</span>
<span class='curline'><a href='../S/2238.html#L6802'>buffer</a>           6802 src/alloc.c          !vectorlike_marked_p (&amp;buffer-&gt;base_buffer-&gt;header))</span>
<span class='curline'><a href='../S/2238.html#L6803'>buffer</a>           6803 src/alloc.c        mark_buffer (buffer-&gt;base_buffer);</span>
<span class='curline'><a href='../S/2238.html#L7119'>buffer</a>           7119 src/alloc.c    		mark_buffer ((struct buffer *) ptr);</span>
<span class='curline'><a href='../S/2238.html#L7640'>buffer</a>           7640 src/alloc.c    unchain_dead_markers (struct buffer *buffer)</span>
<span class='curline'><a href='../S/2238.html#L7642'>buffer</a>           7642 src/alloc.c      struct Lisp_Marker *this, **prev = &amp;BUF_MARKERS (buffer);</span>
<span class='curline'><a href='../S/2238.html#L7649'>buffer</a>           7649 src/alloc.c            this-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2238.html#L7663'>buffer</a>           7663 src/alloc.c          struct buffer *buffer = XBUFFER (buf);</span>
<span class='curline'><a href='../S/2238.html#L7665'>buffer</a>           7665 src/alloc.c          buffer-&gt;text-&gt;intervals = balance_intervals (buffer-&gt;text-&gt;intervals);</span>
<span class='curline'><a href='../S/2238.html#L7666'>buffer</a>           7666 src/alloc.c          unchain_dead_markers (buffer);</span>
<span class='curline'><a href='../S/2102.html#L1496'>buffer</a>           1496 src/bidi.c       struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2102.html#L1557'>buffer</a>           1557 src/bidi.c       struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2049.html#L68'>buffer</a>             68 src/buffer.c   struct buffer buffer_defaults;</span>
<span class='curline'><a href='../S/2049.html#L87'>buffer</a>             87 src/buffer.c   struct buffer buffer_local_flags;</span>
<span class='curline'><a href='../S/2049.html#L92'>buffer</a>             92 src/buffer.c   struct buffer buffer_local_symbols;</span>
<span class='curline'><a href='../S/2049.html#L116'>buffer</a>            116 src/buffer.c   static void reset_buffer_local_variables (struct buffer *, bool);</span>
<span class='curline'><a href='../S/2049.html#L125'>buffer</a>            125 src/buffer.c   static void alloc_buffer_text (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/2049.html#L126'>buffer</a>            126 src/buffer.c   static void free_buffer_text (struct buffer *b);</span>
<span class='curline'><a href='../S/2049.html#L127'>buffer</a>            127 src/buffer.c   static void copy_overlays (struct buffer *, struct buffer *);</span>
<span class='curline'><a href='../S/2049.html#L128'>buffer</a>            128 src/buffer.c   static void modify_overlay (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/2049.html#L129'>buffer</a>            129 src/buffer.c   static Lisp_Object buffer_lisp_local_variables (struct buffer *, bool);</span>
<span class='curline'><a href='../S/2049.html#L130'>buffer</a>            130 src/buffer.c   static Lisp_Object buffer_local_variables_1 (struct buffer *buf, int offset, Lisp_Object sym);</span>
<span class='curline'><a href='../S/2049.html#L158'>buffer</a>            158 src/buffer.c   bset_abbrev_mode (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L163'>buffer</a>            163 src/buffer.c   bset_abbrev_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L168'>buffer</a>            168 src/buffer.c   bset_auto_fill_function (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L173'>buffer</a>            173 src/buffer.c   bset_auto_save_file_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L178'>buffer</a>            178 src/buffer.c   bset_auto_save_file_name (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L183'>buffer</a>            183 src/buffer.c   bset_backed_up (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L188'>buffer</a>            188 src/buffer.c   bset_begv_marker (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L193'>buffer</a>            193 src/buffer.c   bset_bidi_display_reordering (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L198'>buffer</a>            198 src/buffer.c   bset_bidi_paragraph_start_re (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L203'>buffer</a>            203 src/buffer.c   bset_bidi_paragraph_separate_re (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L208'>buffer</a>            208 src/buffer.c   bset_buffer_file_coding_system (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L213'>buffer</a>            213 src/buffer.c   bset_case_fold_search (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L218'>buffer</a>            218 src/buffer.c   bset_ctl_arrow (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L223'>buffer</a>            223 src/buffer.c   bset_cursor_in_non_selected_windows (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L228'>buffer</a>            228 src/buffer.c   bset_cursor_type (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L233'>buffer</a>            233 src/buffer.c   bset_display_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L238'>buffer</a>            238 src/buffer.c   bset_extra_line_spacing (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L244'>buffer</a>            244 src/buffer.c   bset_ts_parser_list (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L250'>buffer</a>            250 src/buffer.c   bset_file_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L255'>buffer</a>            255 src/buffer.c   bset_file_truename (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L260'>buffer</a>            260 src/buffer.c   bset_fringe_cursor_alist (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L265'>buffer</a>            265 src/buffer.c   bset_fringe_indicator_alist (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L270'>buffer</a>            270 src/buffer.c   bset_fringes_outside_margins (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L275'>buffer</a>            275 src/buffer.c   bset_header_line_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L280'>buffer</a>            280 src/buffer.c   bset_tab_line_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L285'>buffer</a>            285 src/buffer.c   bset_indicate_buffer_boundaries (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L290'>buffer</a>            290 src/buffer.c   bset_indicate_empty_lines (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L295'>buffer</a>            295 src/buffer.c   bset_invisibility_spec (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L300'>buffer</a>            300 src/buffer.c   bset_left_fringe_width (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L305'>buffer</a>            305 src/buffer.c   bset_major_mode (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L310'>buffer</a>            310 src/buffer.c   bset_local_minor_modes (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L315'>buffer</a>            315 src/buffer.c   bset_mark (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L320'>buffer</a>            320 src/buffer.c   bset_mode_line_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L325'>buffer</a>            325 src/buffer.c   bset_mode_name (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L330'>buffer</a>            330 src/buffer.c   bset_name (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L335'>buffer</a>            335 src/buffer.c   bset_overwrite_mode (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L340'>buffer</a>            340 src/buffer.c   bset_pt_marker (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L345'>buffer</a>            345 src/buffer.c   bset_right_fringe_width (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L350'>buffer</a>            350 src/buffer.c   bset_save_length (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L355'>buffer</a>            355 src/buffer.c   bset_scroll_bar_width (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L360'>buffer</a>            360 src/buffer.c   bset_scroll_bar_height (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L365'>buffer</a>            365 src/buffer.c   bset_scroll_down_aggressively (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L370'>buffer</a>            370 src/buffer.c   bset_scroll_up_aggressively (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L375'>buffer</a>            375 src/buffer.c   bset_selective_display (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L380'>buffer</a>            380 src/buffer.c   bset_selective_display_ellipses (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L385'>buffer</a>            385 src/buffer.c   bset_vertical_scroll_bar_type (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L390'>buffer</a>            390 src/buffer.c   bset_horizontal_scroll_bar_type (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L395'>buffer</a>            395 src/buffer.c   bset_word_wrap (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L400'>buffer</a>            400 src/buffer.c   bset_zv_marker (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2049.html#L540'>buffer</a>            540 src/buffer.c   run_buffer_list_update_hook (struct buffer *buf)</span>
<span class='curline'><a href='../S/2049.html#L564'>buffer</a>            564 src/buffer.c     register Lisp_Object buffer, name;</span>
<span class='curline'><a href='../S/2049.html#L565'>buffer</a>            565 src/buffer.c     register struct buffer *b;</span>
<span class='curline'><a href='../S/2049.html#L567'>buffer</a>            567 src/buffer.c     buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/2049.html#L568'>buffer</a>            568 src/buffer.c     if (!NILP (buffer))</span>
<span class='curline'><a href='../S/2049.html#L569'>buffer</a>            569 src/buffer.c       return buffer;</span>
<span class='curline'><a href='../S/2049.html#L647'>buffer</a>            647 src/buffer.c     XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/2049.html#L648'>buffer</a>            648 src/buffer.c     Vbuffer_alist = nconc2 (Vbuffer_alist, list1 (Fcons (name, buffer)));</span>
<span class='curline'><a href='../S/2049.html#L652'>buffer</a>            652 src/buffer.c     return buffer;</span>
<span class='curline'><a href='../S/2049.html#L656'>buffer</a>            656 src/buffer.c   add_buffer_overlay (struct buffer *b, struct Lisp_Overlay *ov,</span>
<span class='curline'><a href='../S/2049.html#L659'>buffer</a>            659 src/buffer.c     eassert (! ov-&gt;buffer);</span>
<span class='curline'><a href='../S/2049.html#L662'>buffer</a>            662 src/buffer.c     ov-&gt;buffer = b;</span>
<span class='curline'><a href='../S/2049.html#L669'>buffer</a>            669 src/buffer.c   copy_overlays (struct buffer *from, struct buffer *to)</span>
<span class='curline'><a href='../S/2049.html#L698'>buffer</a>            698 src/buffer.c   clone_per_buffer_values (struct buffer *from, struct buffer *to)</span>
<span class='curline'><a href='../S/2049.html#L711'>buffer</a>            711 src/buffer.c         if (MARKERP (obj) &amp;&amp; XMARKER (obj)-&gt;buffer == from)</span>
<span class='curline'><a href='../S/2049.html#L736'>buffer</a>            736 src/buffer.c   record_buffer_markers (struct buffer *b)</span>
<span class='curline'><a href='../S/2049.html#L740'>buffer</a>            740 src/buffer.c         Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2049.html#L745'>buffer</a>            745 src/buffer.c         XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/2049.html#L746'>buffer</a>            746 src/buffer.c         set_marker_both (BVAR (b, pt_marker), buffer, b-&gt;pt, b-&gt;pt_byte);</span>
<span class='curline'><a href='../S/2049.html#L747'>buffer</a>            747 src/buffer.c         set_marker_both (BVAR (b, begv_marker), buffer, b-&gt;begv, b-&gt;begv_byte);</span>
<span class='curline'><a href='../S/2049.html#L748'>buffer</a>            748 src/buffer.c         set_marker_both (BVAR (b, zv_marker), buffer, b-&gt;zv, b-&gt;zv_byte);</span>
<span class='curline'><a href='../S/2049.html#L757'>buffer</a>            757 src/buffer.c   fetch_buffer_markers (struct buffer *b)</span>
<span class='curline'><a href='../S/2049.html#L797'>buffer</a>            797 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/2049.html#L897'>buffer</a>            897 src/buffer.c         struct buffer *old_b = current_buffer;</span>
<span class='curline'><a href='../S/2049.html#L924'>buffer</a>            924 src/buffer.c   remove_buffer_overlay (struct buffer *b, struct Lisp_Overlay *ov)</span>
<span class='curline'><a href='../S/2049.html#L927'>buffer</a>            927 src/buffer.c     eassert (ov-&gt;buffer == b);</span>
<span class='curline'><a href='../S/2049.html#L928'>buffer</a>            928 src/buffer.c     itree_remove (ov-&gt;buffer-&gt;overlays, ov-&gt;interval);</span>
<span class='curline'><a href='../S/2049.html#L929'>buffer</a>            929 src/buffer.c     ov-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2049.html#L937'>buffer</a>            937 src/buffer.c     if (! ov-&gt;buffer)</span>
<span class='curline'><a href='../S/2049.html#L940'>buffer</a>            940 src/buffer.c     modify_overlay (ov-&gt;buffer, overlay_start (ov), overlay_end (ov));</span>
<span class='curline'><a href='../S/2049.html#L941'>buffer</a>            941 src/buffer.c     remove_buffer_overlay (ov-&gt;buffer, ov);</span>
<span class='curline'><a href='../S/2049.html#L947'>buffer</a>            947 src/buffer.c   delete_all_overlays (struct buffer *b)</span>
<span class='curline'><a href='../S/2049.html#L960'>buffer</a>            960 src/buffer.c         XOVERLAY (node-&gt;data)-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2049.html#L969'>buffer</a>            969 src/buffer.c   free_buffer_overlays (struct buffer *b)</span>
<span class='curline'><a href='../S/2049.html#L1044'>buffer</a>           1044 src/buffer.c   reset_buffer (register struct buffer *b)</span>
<span class='curline'><a href='../S/2049.html#L1091'>buffer</a>           1091 src/buffer.c   reset_buffer_local_variables (struct buffer *b, bool permanent_too)</span>
<span class='curline'><a href='../S/2049.html#L1122'>buffer</a>           1122 src/buffer.c         Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2049.html#L1123'>buffer</a>           1123 src/buffer.c         XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/2049.html#L1139'>buffer</a>           1139 src/buffer.c             if (BASE_EQ (SYMBOL_BLV (XSYMBOL (sym))-&gt;where, buffer))</span>
<span class='curline'><a href='../S/2049.html#L1260'>buffer</a>           1260 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L1262'>buffer</a>           1262 src/buffer.c     return BVAR (decode_buffer (buffer), name);</span>
<span class='curline'><a href='../S/2049.html#L1268'>buffer</a>           1268 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L1270'>buffer</a>           1270 src/buffer.c     return BVAR (decode_buffer (buffer), filename);</span>
<span class='curline'><a href='../S/2049.html#L1278'>buffer</a>           1278 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L1280'>buffer</a>           1280 src/buffer.c     struct buffer *base = decode_buffer (buffer)-&gt;base_buffer;</span>
<span class='curline'><a href='../S/2049.html#L1281'>buffer</a>           1281 src/buffer.c     return base ? (XSETBUFFER (buffer, base), buffer) : Qnil;</span>
<span class='curline'><a href='../S/2049.html#L1289'>buffer</a>           1289 src/buffer.c     (register Lisp_Object variable, register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L1291'>buffer</a>           1291 src/buffer.c     register Lisp_Object result = buffer_local_value (variable, buffer);</span>
<span class='curline'><a href='../S/2049.html#L1304'>buffer</a>           1304 src/buffer.c   buffer_local_value (Lisp_Object variable, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L1306'>buffer</a>           1306 src/buffer.c     register struct buffer *buf;</span>
<span class='curline'><a href='../S/2049.html#L1311'>buffer</a>           1311 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2049.html#L1312'>buffer</a>           1312 src/buffer.c     buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2049.html#L1368'>buffer</a>           1368 src/buffer.c   buffer_lisp_local_variables (struct buffer *buf, bool clone)</span>
<span class='curline'><a href='../S/2049.html#L1403'>buffer</a>           1403 src/buffer.c   buffer_local_variables_1 (struct buffer *buf, int offset, Lisp_Object sym)</span>
<span class='curline'><a href='../S/2049.html#L1423'>buffer</a>           1423 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L1425'>buffer</a>           1425 src/buffer.c     struct buffer *buf = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/2049.html#L1456'>buffer</a>           1456 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L1458'>buffer</a>           1458 src/buffer.c     struct buffer *buf = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/2049.html#L1538'>buffer</a>           1538 src/buffer.c     struct buffer *b = current_buffer-&gt;base_buffer</span>
<span class='curline'><a href='../S/2049.html#L1588'>buffer</a>           1588 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L1590'>buffer</a>           1590 src/buffer.c     return modiff_to_integer (BUF_MODIFF (decode_buffer (buffer)));</span>
<span class='curline'><a href='../S/2049.html#L1598'>buffer</a>           1598 src/buffer.c     (Lisp_Object tick, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L1601'>buffer</a>           1601 src/buffer.c     BUF_MODIFF (decode_buffer (buffer)) = XFIXNUM (tick);</span>
<span class='curline'><a href='../S/2049.html#L1615'>buffer</a>           1615 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L1617'>buffer</a>           1617 src/buffer.c     return modiff_to_integer (BUF_CHARS_MODIFF (decode_buffer (buffer)));</span>
<span class='curline'><a href='../S/2049.html#L1682'>buffer</a>           1682 src/buffer.c   candidate_buffer (Lisp_Object b, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L1684'>buffer</a>           1684 src/buffer.c     return (BUFFERP (b) &amp;&amp; !BASE_EQ (b, buffer)</span>
<span class='curline'><a href='../S/2049.html#L1700'>buffer</a>           1700 src/buffer.c     (Lisp_Object buffer, Lisp_Object visible_ok, Lisp_Object frame)</span>
<span class='curline'><a href='../S/2049.html#L1710'>buffer</a>           1710 src/buffer.c         if (candidate_buffer (buf, buffer)</span>
<span class='curline'><a href='../S/2049.html#L1726'>buffer</a>           1726 src/buffer.c         if (candidate_buffer (buf, buffer)</span>
<span class='curline'><a href='../S/2049.html#L1750'>buffer</a>           1750 src/buffer.c   other_buffer_safely (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L1755'>buffer</a>           1755 src/buffer.c       if (candidate_buffer (buf, buffer))</span>
<span class='curline'><a href='../S/2049.html#L1777'>buffer</a>           1777 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L1781'>buffer</a>           1781 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2049.html#L1785'>buffer</a>           1785 src/buffer.c         real_buffer = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/2049.html#L1787'>buffer</a>           1787 src/buffer.c   	nsberror (buffer);</span>
<span class='curline'><a href='../S/2049.html#L1799'>buffer</a>           1799 src/buffer.c   compact_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/2049.html#L1801'>buffer</a>           1801 src/buffer.c     BUFFER_CHECK_INDIRECTION (buffer);</span>
<span class='curline'><a href='../S/2049.html#L1805'>buffer</a>           1805 src/buffer.c     if (BUFFER_LIVE_P (buffer)</span>
<span class='curline'><a href='../S/2049.html#L1806'>buffer</a>           1806 src/buffer.c         &amp;&amp; (buffer-&gt;base_buffer == NULL)</span>
<span class='curline'><a href='../S/2049.html#L1807'>buffer</a>           1807 src/buffer.c         &amp;&amp; (BUF_COMPACT (buffer) != BUF_MODIFF (buffer)))</span>
<span class='curline'><a href='../S/2049.html#L1813'>buffer</a>           1813 src/buffer.c         if (!EQ (BVAR(buffer, undo_list), Qt))</span>
<span class='curline'><a href='../S/2049.html#L1814'>buffer</a>           1814 src/buffer.c   	truncate_undo_list (buffer);</span>
<span class='curline'><a href='../S/2049.html#L1817'>buffer</a>           1817 src/buffer.c         if (!buffer-&gt;text-&gt;inhibit_shrinking)</span>
<span class='curline'><a href='../S/2049.html#L1823'>buffer</a>           1823 src/buffer.c   					   BUF_Z_BYTE (buffer) / 10,</span>
<span class='curline'><a href='../S/2049.html#L1825'>buffer</a>           1825 src/buffer.c   	  if (BUF_GAP_SIZE (buffer) &gt; size)</span>
<span class='curline'><a href='../S/2049.html#L1826'>buffer</a>           1826 src/buffer.c   	    make_gap_1 (buffer, -(BUF_GAP_SIZE (buffer) - size));</span>
<span class='curline'><a href='../S/2049.html#L1828'>buffer</a>           1828 src/buffer.c         BUF_COMPACT (buffer) = BUF_MODIFF (buffer);</span>
<span class='curline'><a href='../S/2049.html#L1852'>buffer</a>           1852 src/buffer.c     Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2049.html#L1853'>buffer</a>           1853 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/2049.html#L1858'>buffer</a>           1858 src/buffer.c       buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2049.html#L1860'>buffer</a>           1860 src/buffer.c       buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/2049.html#L1861'>buffer</a>           1861 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2049.html#L1864'>buffer</a>           1864 src/buffer.c     b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2049.html#L1900'>buffer</a>           1900 src/buffer.c   	if (NILP (call1 (Qkill_buffer__possibly_save, buffer)))</span>
<span class='curline'><a href='../S/2049.html#L1942'>buffer</a>           1942 src/buffer.c     if (BASE_EQ (buffer, XWINDOW (minibuf_window)-&gt;contents))</span>
<span class='curline'><a href='../S/2049.html#L1966'>buffer</a>           1966 src/buffer.c     replace_buffer_in_windows (buffer);</span>
<span class='curline'><a href='../S/2049.html#L1976'>buffer</a>           1976 src/buffer.c         tem = Fother_buffer (buffer, Qnil, Qnil);</span>
<span class='curline'><a href='../S/2049.html#L1986'>buffer</a>           1986 src/buffer.c         &amp;&amp; BASE_EQ (buffer, Fother_buffer (buffer, Qnil, Qnil)))</span>
<span class='curline'><a href='../S/2049.html#L1994'>buffer</a>           1994 src/buffer.c     kill_buffer_processes (buffer);</span>
<span class='curline'><a href='../S/2049.html#L1995'>buffer</a>           1995 src/buffer.c     kill_buffer_xwidgets (buffer);</span>
<span class='curline'><a href='../S/2049.html#L2004'>buffer</a>           2004 src/buffer.c     frames_discard_buffer (buffer);</span>
<span class='curline'><a href='../S/2049.html#L2014'>buffer</a>           2014 src/buffer.c     Vbuffer_alist = Fdelq (Frassq (buffer, Vbuffer_alist), Vbuffer_alist);</span>
<span class='curline'><a href='../S/2049.html#L2016'>buffer</a>           2016 src/buffer.c     replace_buffer_in_windows_safely (buffer);</span>
<span class='curline'><a href='../S/2049.html#L2028'>buffer</a>           2028 src/buffer.c   	  if (m-&gt;buffer == b)</span>
<span class='curline'><a href='../S/2049.html#L2030'>buffer</a>           2030 src/buffer.c   	      m-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2049.html#L2052'>buffer</a>           2052 src/buffer.c   	  m-&gt;buffer = 0;</span>
<span class='curline'><a href='../S/2049.html#L2125'>buffer</a>           2125 src/buffer.c   record_buffer (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L2130'>buffer</a>           2130 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2049.html#L2137'>buffer</a>           2137 src/buffer.c     aelt = Frassq (buffer, Vbuffer_alist);</span>
<span class='curline'><a href='../S/2049.html#L2145'>buffer</a>           2145 src/buffer.c     fset_buffer_list (f, Fcons (buffer, Fdelq (buffer, f-&gt;buffer_list)));</span>
<span class='curline'><a href='../S/2049.html#L2146'>buffer</a>           2146 src/buffer.c     fset_buried_buffer_list (f, Fdelq (buffer, f-&gt;buried_buffer_list));</span>
<span class='curline'><a href='../S/2049.html#L2148'>buffer</a>           2148 src/buffer.c     run_buffer_list_update_hook (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2049.html#L2161'>buffer</a>           2161 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L2166'>buffer</a>           2166 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2049.html#L2173'>buffer</a>           2173 src/buffer.c     aelt = Frassq (buffer, Vbuffer_alist);</span>
<span class='curline'><a href='../S/2049.html#L2181'>buffer</a>           2181 src/buffer.c     fset_buffer_list (f, Fdelq (buffer, f-&gt;buffer_list));</span>
<span class='curline'><a href='../S/2049.html#L2183'>buffer</a>           2183 src/buffer.c       (f, Fcons (buffer, Fdelq (buffer, f-&gt;buried_buffer_list)));</span>
<span class='curline'><a href='../S/2049.html#L2185'>buffer</a>           2185 src/buffer.c     run_buffer_list_update_hook (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2049.html#L2196'>buffer</a>           2196 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L2200'>buffer</a>           2200 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2049.html#L2202'>buffer</a>           2202 src/buffer.c     if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/2049.html#L2205'>buffer</a>           2205 src/buffer.c     if (strcmp (SSDATA (BVAR (XBUFFER (buffer), name)), "*scratch*") == 0)</span>
<span class='curline'><a href='../S/2049.html#L2227'>buffer</a>           2227 src/buffer.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2049.html#L2246'>buffer</a>           2246 src/buffer.c   set_buffer_internal_1 (register struct buffer *b)</span>
<span class='curline'><a href='../S/2049.html#L2262'>buffer</a>           2262 src/buffer.c   void set_buffer_internal_2 (register struct buffer *b)</span>
<span class='curline'><a href='../S/2049.html#L2264'>buffer</a>           2264 src/buffer.c     register struct buffer *old_buf;</span>
<span class='curline'><a href='../S/2049.html#L2318'>buffer</a>           2318 src/buffer.c   set_buffer_temp (struct buffer *b)</span>
<span class='curline'><a href='../S/2049.html#L2320'>buffer</a>           2320 src/buffer.c     register struct buffer *old_buf;</span>
<span class='curline'><a href='../S/2049.html#L2347'>buffer</a>           2347 src/buffer.c     register Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2049.html#L2348'>buffer</a>           2348 src/buffer.c     buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/2049.html#L2349'>buffer</a>           2349 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2049.html#L2351'>buffer</a>           2351 src/buffer.c     if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/2049.html#L2353'>buffer</a>           2353 src/buffer.c     set_buffer_internal (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2049.html#L2354'>buffer</a>           2354 src/buffer.c     return buffer;</span>
<span class='curline'><a href='../S/2049.html#L2366'>buffer</a>           2366 src/buffer.c   set_buffer_if_live (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L2368'>buffer</a>           2368 src/buffer.c     if (BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/2049.html#L2369'>buffer</a>           2369 src/buffer.c       set_buffer_internal (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2049.html#L2464'>buffer</a>           2464 src/buffer.c   swap_buffer_overlays (struct buffer *buffer, struct buffer *other)</span>
<span class='curline'><a href='../S/2049.html#L2468'>buffer</a>           2468 src/buffer.c     ITREE_FOREACH (node, buffer-&gt;overlays, PTRDIFF_MIN, PTRDIFF_MAX, ASCENDING)</span>
<span class='curline'><a href='../S/2049.html#L2469'>buffer</a>           2469 src/buffer.c       XOVERLAY (node-&gt;data)-&gt;buffer = other;</span>
<span class='curline'><a href='../S/2049.html#L2472'>buffer</a>           2472 src/buffer.c       XOVERLAY (node-&gt;data)-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/2049.html#L2475'>buffer</a>           2475 src/buffer.c     void *tmp = buffer-&gt;overlays;</span>
<span class='curline'><a href='../S/2049.html#L2476'>buffer</a>           2476 src/buffer.c     buffer-&gt;overlays = other-&gt;overlays;</span>
<span class='curline'><a href='../S/2049.html#L2485'>buffer</a>           2485 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L2487'>buffer</a>           2487 src/buffer.c     struct buffer *other_buffer;</span>
<span class='curline'><a href='../S/2049.html#L2488'>buffer</a>           2488 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2049.html#L2489'>buffer</a>           2489 src/buffer.c     other_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2049.html#L2581'>buffer</a>           2581 src/buffer.c         if (m-&gt;buffer == other_buffer)</span>
<span class='curline'><a href='../S/2049.html#L2582'>buffer</a>           2582 src/buffer.c   	m-&gt;buffer = current_buffer;</span>
<span class='curline'><a href='../S/2049.html#L2586'>buffer</a>           2586 src/buffer.c   	eassert (!m-&gt;buffer);</span>
<span class='curline'><a href='../S/2049.html#L2588'>buffer</a>           2588 src/buffer.c         if (m-&gt;buffer == current_buffer)</span>
<span class='curline'><a href='../S/2049.html#L2589'>buffer</a>           2589 src/buffer.c   	m-&gt;buffer = other_buffer;</span>
<span class='curline'><a href='../S/2049.html#L2593'>buffer</a>           2593 src/buffer.c   	eassert (!m-&gt;buffer);</span>
<span class='curline'><a href='../S/2049.html#L2633'>buffer</a>           2633 src/buffer.c       (eassert (BASE_EQ (current_buffer-&gt;text-&gt;intervals-&gt;up.obj, buffer)),</span>
<span class='curline'><a href='../S/2049.html#L2906'>buffer</a>           2906 src/buffer.c         struct buffer *o = XBUFFER (other);</span>
<span class='curline'><a href='../S/2049.html#L3482'>buffer</a>           3482 src/buffer.c         struct buffer *base = current_buffer-&gt;base_buffer</span>
<span class='curline'><a href='../S/2049.html#L3495'>buffer</a>           3495 src/buffer.c   adjust_overlays_for_delete_in_buffer (struct buffer * buf,</span>
<span class='curline'><a href='../S/2049.html#L3527'>buffer</a>           3527 src/buffer.c         struct buffer *base = current_buffer-&gt;base_buffer</span>
<span class='curline'><a href='../S/2049.html#L3556'>buffer</a>           3556 src/buffer.c     (Lisp_Object beg, Lisp_Object end, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/2049.html#L3560'>buffer</a>           3560 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/2049.html#L3562'>buffer</a>           3562 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2049.html#L3563'>buffer</a>           3563 src/buffer.c       XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/2049.html#L3565'>buffer</a>           3565 src/buffer.c       CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2049.html#L3567'>buffer</a>           3567 src/buffer.c     b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2049.html#L3571'>buffer</a>           3571 src/buffer.c     if (MARKERP (beg) &amp;&amp; !BASE_EQ (Fmarker_buffer (beg), buffer))</span>
<span class='curline'><a href='../S/2049.html#L3573'>buffer</a>           3573 src/buffer.c     if (MARKERP (end) &amp;&amp; !BASE_EQ (Fmarker_buffer (end), buffer))</span>
<span class='curline'><a href='../S/2049.html#L3600'>buffer</a>           3600 src/buffer.c   modify_overlay (struct buffer *buf, ptrdiff_t start, ptrdiff_t end)</span>
<span class='curline'><a href='../S/2049.html#L3621'>buffer</a>           3621 src/buffer.c     (Lisp_Object overlay, Lisp_Object beg, Lisp_Object end, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L3623'>buffer</a>           3623 src/buffer.c     struct buffer *b, *ob = 0;</span>
<span class='curline'><a href='../S/2049.html#L3629'>buffer</a>           3629 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2049.html#L3630'>buffer</a>           3630 src/buffer.c       buffer = Foverlay_buffer (overlay);</span>
<span class='curline'><a href='../S/2049.html#L3631'>buffer</a>           3631 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2049.html#L3632'>buffer</a>           3632 src/buffer.c       XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/2049.html#L3633'>buffer</a>           3633 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2049.html#L3635'>buffer</a>           3635 src/buffer.c     if (NILP (Fbuffer_live_p (buffer)))</span>
<span class='curline'><a href='../S/2049.html#L3638'>buffer</a>           3638 src/buffer.c     if (MARKERP (beg) &amp;&amp; !BASE_EQ (Fmarker_buffer (beg), buffer))</span>
<span class='curline'><a href='../S/2049.html#L3640'>buffer</a>           3640 src/buffer.c     if (MARKERP (end) &amp;&amp; !BASE_EQ (Fmarker_buffer (end), buffer))</span>
<span class='curline'><a href='../S/2049.html#L3655'>buffer</a>           3655 src/buffer.c     b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2049.html#L3668'>buffer</a>           3668 src/buffer.c     if (! BASE_EQ (buffer, obuffer))</span>
<span class='curline'><a href='../S/2049.html#L3672'>buffer</a>           3672 src/buffer.c         add_buffer_overlay (XBUFFER (buffer), XOVERLAY (overlay), n_beg, n_end);</span>
<span class='curline'><a href='../S/2049.html#L3679'>buffer</a>           3679 src/buffer.c     if (!BASE_EQ (buffer, obuffer))</span>
<span class='curline'><a href='../S/2049.html#L3719'>buffer</a>           3719 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/2049.html#L3748'>buffer</a>           3748 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L3750'>buffer</a>           3750 src/buffer.c     delete_all_overlays (decode_buffer (buffer));</span>
<span class='curline'><a href='../S/2049.html#L3783'>buffer</a>           3783 src/buffer.c     Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2049.html#L3790'>buffer</a>           3790 src/buffer.c     XSETBUFFER (buffer, OVERLAY_BUFFER (overlay));</span>
<span class='curline'><a href='../S/2049.html#L3792'>buffer</a>           3792 src/buffer.c     return buffer;</span>
<span class='curline'><a href='../S/2049.html#L3969'>buffer</a>           3969 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/2049.html#L4520'>buffer</a>           4520 src/buffer.c   alloc_buffer_text (struct buffer *b, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/2049.html#L4547'>buffer</a>           4547 src/buffer.c   enlarge_buffer_text (struct buffer *b, ptrdiff_t delta)</span>
<span class='curline'><a href='../S/2049.html#L4589'>buffer</a>           4589 src/buffer.c   free_buffer_text (struct buffer *b)</span>
<span class='curline'><a href='../S/2049.html#L4861'>buffer</a>           4861 src/buffer.c         Lisp_Object tail, buffer;</span>
<span class='curline'><a href='../S/2049.html#L4887'>buffer</a>           4887 src/buffer.c         FOR_EACH_LIVE_BUFFER (tail, buffer)</span>
<span class='curline'><a href='../S/2049.html#L4889'>buffer</a>           4889 src/buffer.c   	  struct buffer *b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2049.html#L5018'>buffer</a>           5018 src/buffer.c        (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2049.html#L5020'>buffer</a>           5020 src/buffer.c     struct buffer *b = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/2030.html#L162'>buffer</a>            162 src/buffer.h   extern void temp_set_point (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/2030.html#L164'>buffer</a>            164 src/buffer.h   extern void temp_set_point_both (struct buffer *,</span>
<span class='curline'><a href='../S/2030.html#L167'>buffer</a>            167 src/buffer.h   extern void enlarge_buffer_text (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/2030.html#L190'>buffer</a>            190 src/buffer.h   BUF_TEMP_SET_PT (struct buffer *buffer, ptrdiff_t position)</span>
<span class='curline'><a href='../S/2030.html#L192'>buffer</a>            192 src/buffer.h     temp_set_point (buffer, position);</span>
<span class='curline'><a href='../S/2030.html#L606'>buffer</a>            606 src/buffer.h     struct buffer *base_buffer;</span>
<span class='curline'><a href='../S/2030.html#L724'>buffer</a>            724 src/buffer.h   INLINE struct buffer *</span>
<span class='curline'><a href='../S/2030.html#L728'>buffer</a>            728 src/buffer.h     return XUNTAG (a, Lisp_Vectorlike, struct buffer);</span>
<span class='curline'><a href='../S/2030.html#L735'>buffer</a>            735 src/buffer.h   bset_bidi_paragraph_direction (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L740'>buffer</a>            740 src/buffer.h   bset_cache_long_scans (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L745'>buffer</a>            745 src/buffer.h   bset_case_canon_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L750'>buffer</a>            750 src/buffer.h   bset_case_eqv_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L755'>buffer</a>            755 src/buffer.h   bset_directory (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L760'>buffer</a>            760 src/buffer.h   bset_display_count (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L765'>buffer</a>            765 src/buffer.h   bset_left_margin_cols (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L770'>buffer</a>            770 src/buffer.h   bset_right_margin_cols (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L775'>buffer</a>            775 src/buffer.h   bset_display_time (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L780'>buffer</a>            780 src/buffer.h   bset_downcase_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L785'>buffer</a>            785 src/buffer.h   bset_enable_multibyte_characters (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L790'>buffer</a>            790 src/buffer.h   bset_filename (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L795'>buffer</a>            795 src/buffer.h   bset_keymap (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L800'>buffer</a>            800 src/buffer.h   bset_last_selected_window (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L805'>buffer</a>            805 src/buffer.h   bset_local_var_alist (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L810'>buffer</a>            810 src/buffer.h   bset_mark_active (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L815'>buffer</a>            815 src/buffer.h   bset_point_before_scroll (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L820'>buffer</a>            820 src/buffer.h   bset_read_only (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L825'>buffer</a>            825 src/buffer.h   bset_truncate_lines (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L830'>buffer</a>            830 src/buffer.h   bset_undo_list (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L835'>buffer</a>            835 src/buffer.h   bset_upcase_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L840'>buffer</a>            840 src/buffer.h   bset_width_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2030.html#L867'>buffer</a>            867 src/buffer.h   BUF_BEGV (struct buffer *buf)</span>
<span class='curline'><a href='../S/2030.html#L875'>buffer</a>            875 src/buffer.h   BUF_BEGV_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/2030.html#L884'>buffer</a>            884 src/buffer.h   BUF_PT (struct buffer *buf)</span>
<span class='curline'><a href='../S/2030.html#L892'>buffer</a>            892 src/buffer.h   BUF_PT_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/2030.html#L901'>buffer</a>            901 src/buffer.h   BUF_ZV (struct buffer *buf)</span>
<span class='curline'><a href='../S/2030.html#L909'>buffer</a>            909 src/buffer.h   BUF_ZV_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/2030.html#L920'>buffer</a>            920 src/buffer.h   BUF_BEG (struct buffer *buf)</span>
<span class='curline'><a href='../S/2030.html#L926'>buffer</a>            926 src/buffer.h   BUF_BEG_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/2030.html#L933'>buffer</a>            933 src/buffer.h   BUF_GPT_ADDR (struct buffer *buf)</span>
<span class='curline'><a href='../S/2030.html#L940'>buffer</a>            940 src/buffer.h   BUF_Z_ADDR (struct buffer *buf)</span>
<span class='curline'><a href='../S/2030.html#L947'>buffer</a>            947 src/buffer.h   BUF_GAP_END_ADDR (struct buffer *buf)</span>
<span class='curline'><a href='../S/2030.html#L957'>buffer</a>            957 src/buffer.h   BUF_COMPUTE_UNCHANGED (struct buffer *buf, ptrdiff_t start, ptrdiff_t end)</span>
<span class='curline'><a href='../S/2030.html#L984'>buffer</a>            984 src/buffer.h   SET_BUF_BEGV (struct buffer *buf, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/2030.html#L991'>buffer</a>            991 src/buffer.h   SET_BUF_ZV (struct buffer *buf, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/2030.html#L998'>buffer</a>            998 src/buffer.h   SET_BUF_BEGV_BOTH (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t byte)</span>
<span class='curline'><a href='../S/2030.html#L1005'>buffer</a>           1005 src/buffer.h   SET_BUF_ZV_BOTH (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t byte)</span>
<span class='curline'><a href='../S/2030.html#L1012'>buffer</a>           1012 src/buffer.h   SET_BUF_PT_BOTH (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t byte)</span>
<span class='curline'><a href='../S/2030.html#L1072'>buffer</a>           1072 src/buffer.h   enum { BUFFER_LISP_SIZE = PSEUDOVECSIZE (struct buffer,</span>
<span class='curline'><a href='../S/2030.html#L1078'>buffer</a>           1078 src/buffer.h   enum { BUFFER_REST_SIZE = VECSIZE (struct buffer) - BUFFER_LISP_SIZE };</span>
<span class='curline'><a href='../S/2030.html#L1085'>buffer</a>           1085 src/buffer.h   BUFFER_PVEC_INIT (struct buffer *b)</span>
<span class='curline'><a href='../S/2030.html#L1093'>buffer</a>           1093 src/buffer.h   BUFFER_LIVE_P (struct buffer *b)</span>
<span class='curline'><a href='../S/2030.html#L1102'>buffer</a>           1102 src/buffer.h   BUFFER_HIDDEN_P (struct buffer *b)</span>
<span class='curline'><a href='../S/2030.html#L1110'>buffer</a>           1110 src/buffer.h   BUFFER_CHECK_INDIRECTION (struct buffer *b)</span>
<span class='curline'><a href='../S/2030.html#L1131'>buffer</a>           1131 src/buffer.h   extern struct buffer buffer_defaults;</span>
<span class='curline'><a href='../S/2030.html#L1147'>buffer</a>           1147 src/buffer.h   extern struct buffer buffer_local_flags;</span>
<span class='curline'><a href='../S/2030.html#L1153'>buffer</a>           1153 src/buffer.h   extern struct buffer buffer_local_symbols;</span>
<span class='curline'><a href='../S/2030.html#L1163'>buffer</a>           1163 src/buffer.h   extern void delete_all_overlays (struct buffer *);</span>
<span class='curline'><a href='../S/2030.html#L1164'>buffer</a>           1164 src/buffer.h   extern void reset_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/2030.html#L1165'>buffer</a>           1165 src/buffer.h   extern void compact_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/2030.html#L1172'>buffer</a>           1172 src/buffer.h   extern void recenter_overlay_lists (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/2030.html#L1175'>buffer</a>           1175 src/buffer.h   extern void set_buffer_internal_1 (struct buffer *);</span>
<span class='curline'><a href='../S/2030.html#L1176'>buffer</a>           1176 src/buffer.h   extern void set_buffer_internal_2 (struct buffer *);</span>
<span class='curline'><a href='../S/2030.html#L1177'>buffer</a>           1177 src/buffer.h   extern void set_buffer_temp (struct buffer *);</span>
<span class='curline'><a href='../S/2030.html#L1180'>buffer</a>           1180 src/buffer.h   extern void fix_overlays_before (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/2030.html#L1188'>buffer</a>           1188 src/buffer.h   INLINE struct buffer *</span>
<span class='curline'><a href='../S/2030.html#L1204'>buffer</a>           1204 src/buffer.h   set_buffer_internal (struct buffer *b)</span>
<span class='curline'><a href='../S/2030.html#L1249'>buffer</a>           1249 src/buffer.h   buffer_intervals (struct buffer *b)</span>
<span class='curline'><a href='../S/2030.html#L1258'>buffer</a>           1258 src/buffer.h   set_buffer_intervals (struct buffer *b, INTERVAL i)</span>
<span class='curline'><a href='../S/2030.html#L1292'>buffer</a>           1292 src/buffer.h   BUF_FETCH_MULTIBYTE_CHAR (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/2030.html#L1327'>buffer</a>           1327 src/buffer.h   BUF_BYTE_ADDRESS (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/2030.html#L1337'>buffer</a>           1337 src/buffer.h   BUF_CHAR_ADDRESS (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/2030.html#L1347'>buffer</a>           1347 src/buffer.h   BUF_PTR_BYTE_POS (struct buffer *buf, unsigned char *ptr)</span>
<span class='curline'><a href='../S/2030.html#L1357'>buffer</a>           1357 src/buffer.h   BUF_FETCH_BYTE (struct buffer *buf, ptrdiff_t n)</span>
<span class='curline'><a href='../S/2030.html#L1367'>buffer</a>           1367 src/buffer.h   BUF_FETCH_CHAR_AS_MULTIBYTE (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/2030.html#L1377'>buffer</a>           1377 src/buffer.h   buffer_window_count (struct buffer *b)</span>
<span class='curline'><a href='../S/2030.html#L1390'>buffer</a>           1390 src/buffer.h     if (! ov-&gt;buffer)</span>
<span class='curline'><a href='../S/2030.html#L1392'>buffer</a>           1392 src/buffer.h     return itree_node_begin (ov-&gt;buffer-&gt;overlays, ov-&gt;interval);</span>
<span class='curline'><a href='../S/2030.html#L1398'>buffer</a>           1398 src/buffer.h     if (! ov-&gt;buffer)</span>
<span class='curline'><a href='../S/2030.html#L1400'>buffer</a>           1400 src/buffer.h     return itree_node_end (ov-&gt;buffer-&gt;overlays, ov-&gt;interval);</span>
<span class='curline'><a href='../S/2030.html#L1430'>buffer</a>           1430 src/buffer.h   INLINE struct buffer *</span>
<span class='curline'><a href='../S/2030.html#L1433'>buffer</a>           1433 src/buffer.h     return XOVERLAY (ov)-&gt;buffer;</span>
<span class='curline'><a href='../S/2030.html#L1461'>buffer</a>           1461 src/buffer.h     offsetof (struct buffer, VAR ## _)</span>
<span class='curline'><a href='../S/2030.html#L1487'>buffer</a>           1487 src/buffer.h   PER_BUFFER_VALUE_P (struct buffer *b, int idx)</span>
<span class='curline'><a href='../S/2030.html#L1497'>buffer</a>           1497 src/buffer.h   SET_PER_BUFFER_VALUE_P (struct buffer *b, int idx, bool val)</span>
<span class='curline'><a href='../S/2030.html#L1548'>buffer</a>           1548 src/buffer.h   per_buffer_value (struct buffer *b, int offset)</span>
<span class='curline'><a href='../S/2030.html#L1554'>buffer</a>           1554 src/buffer.h   set_per_buffer_value (struct buffer *b, int offset, Lisp_Object value)</span>
<span class='curline'><a href='../S/2030.html#L1601'>buffer</a>           1601 src/buffer.h   SANE_TAB_WIDTH (struct buffer *buf)</span>
<span class='curline'><a href='../S/2030.html#L1681'>buffer</a>           1681 src/buffer.h   buf_next_char_len (struct buffer *buf, ptrdiff_t pos_byte)</span>
<span class='curline'><a href='../S/2030.html#L1697'>buffer</a>           1697 src/buffer.h   buf_prev_char_len (struct buffer *buf, ptrdiff_t pos_byte)</span>
<span class='curline'><a href='../S/2100.html#L224'>buffer</a>            224 src/callproc.c call_process_cleanup (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2100.html#L226'>buffer</a>            226 src/callproc.c   Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2100.html#L336'>buffer</a>            336 src/callproc.c   Lisp_Object buffer, current_dir, path;</span>
<span class='curline'><a href='../S/2100.html#L423'>buffer</a>            423 src/callproc.c     buffer = Qnil;</span>
<span class='curline'><a href='../S/2100.html#L426'>buffer</a>            426 src/callproc.c       buffer = args[2];</span>
<span class='curline'><a href='../S/2100.html#L431'>buffer</a>            431 src/callproc.c       if (CONSP (buffer) &amp;&amp; !EQ (XCAR (buffer), QCfile))</span>
<span class='curline'><a href='../S/2100.html#L433'>buffer</a>            433 src/callproc.c 	  if (CONSP (XCDR (buffer)))</span>
<span class='curline'><a href='../S/2100.html#L436'>buffer</a>            436 src/callproc.c 	      stderr_file = XCAR (XCDR (buffer));</span>
<span class='curline'><a href='../S/2100.html#L444'>buffer</a>            444 src/callproc.c 	  buffer = XCAR (buffer);</span>
<span class='curline'><a href='../S/2100.html#L448'>buffer</a>            448 src/callproc.c       if (CONSP (buffer) &amp;&amp; EQ (XCAR (buffer), QCfile))</span>
<span class='curline'><a href='../S/2100.html#L450'>buffer</a>            450 src/callproc.c 	  Lisp_Object ofile = XCDR (buffer);</span>
<span class='curline'><a href='../S/2100.html#L457'>buffer</a>            457 src/callproc.c 	  buffer = Qnil;</span>
<span class='curline'><a href='../S/2100.html#L460'>buffer</a>            460 src/callproc.c       if (! (NILP (buffer) || EQ (buffer, Qt) || FIXNUMP (buffer)))</span>
<span class='curline'><a href='../S/2100.html#L462'>buffer</a>            462 src/callproc.c 	  Lisp_Object spec_buffer = buffer;</span>
<span class='curline'><a href='../S/2100.html#L463'>buffer</a>            463 src/callproc.c 	  buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/2100.html#L465'>buffer</a>            465 src/callproc.c 	  if (NILP (buffer))</span>
<span class='curline'><a href='../S/2100.html#L467'>buffer</a>            467 src/callproc.c 	  CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2100.html#L533'>buffer</a>            533 src/callproc.c   discard_output = FIXNUMP (buffer) || (NILP (buffer) &amp;&amp; NILP (output_file));</span>
<span class='curline'><a href='../S/2100.html#L664'>buffer</a>            664 src/callproc.c       if (FIXNUMP (buffer))</span>
<span class='curline'><a href='../S/2100.html#L697'>buffer</a>            697 src/callproc.c   if (FIXNUMP (buffer))</span>
<span class='curline'><a href='../S/2100.html#L700'>buffer</a>            700 src/callproc.c   if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/2100.html#L701'>buffer</a>            701 src/callproc.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2083.html#L40'>buffer</a>             40 src/category.c bset_category_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/1990.html#L913'>buffer</a>            913 src/coding.c         struct buffer *buf = XBUFFER (coding-&gt;src_object);</span>
<span class='curline'><a href='../S/1990.html#L1030'>buffer</a>           1030 src/coding.c         struct buffer *buf = XBUFFER (coding-&gt;dst_object);</span>
<span class='curline'><a href='../S/1990.html#L7874'>buffer</a>           7874 src/coding.c         struct buffer *current = current_buffer;</span>
<span class='curline'><a href='../S/1990.html#L7895'>buffer</a>           7895 src/coding.c     struct buffer *buf = XBUFFER (XCDR (arg));</span>
<span class='curline'><a href='../S/1990.html#L8394'>buffer</a>           8394 src/coding.c   	  struct buffer *current = current_buffer;</span>
<span class='curline'><a href='../S/1990.html#L9426'>buffer</a>           9426 src/coding.c         struct buffer *buf = XBUFFER (dst_object);</span>
<span class='curline'><a href='../S/1990.html#L9575'>buffer</a>           9575 src/coding.c         struct buffer *buf = XBUFFER (dst_object);</span>
<span class='curline'><a href='../S/1990.html#L9609'>buffer</a>           9609 src/coding.c   get_buffer_gap_address (Lisp_Object buffer, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/1990.html#L9611'>buffer</a>           9611 src/coding.c     struct buffer *buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/1990.html#L9615'>buffer</a>           9615 src/coding.c         struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/1990.html#L9722'>buffer</a>           9722 src/coding.c   encode_string_utf_8 (Lisp_Object string, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/1990.html#L9727'>buffer</a>           9727 src/coding.c     if (NILP (buffer) &amp;&amp; nchars == nbytes &amp;&amp; nocopy)</span>
<span class='curline'><a href='../S/1990.html#L9897'>buffer</a>           9897 src/coding.c   	  if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/1990.html#L9900'>buffer</a>           9900 src/coding.c   	      dst = get_buffer_gap_address (buffer, nbytes);</span>
<span class='curline'><a href='../S/1990.html#L9915'>buffer</a>           9915 src/coding.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/1990.html#L9917'>buffer</a>           9917 src/coding.c         struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/1990.html#L9919'>buffer</a>           9919 src/coding.c         current_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/1990.html#L9999'>buffer</a>           9999 src/coding.c   		     Lisp_Object buffer, bool nocopy,</span>
<span class='curline'><a href='../S/1990.html#L10076'>buffer</a>           10076 src/coding.c         &amp;&amp; NILP (buffer))</span>
<span class='curline'><a href='../S/1990.html#L10145'>buffer</a>           10145 src/coding.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/1990.html#L10148'>buffer</a>           10148 src/coding.c         dst = get_buffer_gap_address (buffer, outbytes);</span>
<span class='curline'><a href='../S/1990.html#L10225'>buffer</a>           10225 src/coding.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/1990.html#L10227'>buffer</a>           10227 src/coding.c         struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/1990.html#L10229'>buffer</a>           10229 src/coding.c         current_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/1990.html#L10253'>buffer</a>           10253 src/coding.c     (Lisp_Object string, Lisp_Object buffer, Lisp_Object nocopy,</span>
<span class='curline'><a href='../S/1990.html#L10263'>buffer</a>           10263 src/coding.c     if (! NILP (buffer)</span>
<span class='curline'><a href='../S/1990.html#L10264'>buffer</a>           10264 src/coding.c         &amp;&amp; (! BUFFERP (buffer)</span>
<span class='curline'><a href='../S/1990.html#L10265'>buffer</a>           10265 src/coding.c   	  || ! NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/1990.html#L10286'>buffer</a>           10286 src/coding.c   	val = encode_string_utf_8 (string, buffer, ! NILP (nocopy),</span>
<span class='curline'><a href='../S/1990.html#L10309'>buffer</a>           10309 src/coding.c     (Lisp_Object string, Lisp_Object buffer, Lisp_Object nocopy,</span>
<span class='curline'><a href='../S/1990.html#L10319'>buffer</a>           10319 src/coding.c     if (! NILP (buffer)</span>
<span class='curline'><a href='../S/1990.html#L10320'>buffer</a>           10320 src/coding.c         &amp;&amp; (! BUFFERP (buffer)</span>
<span class='curline'><a href='../S/1990.html#L10321'>buffer</a>           10321 src/coding.c   	  || NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/1990.html#L10342'>buffer</a>           10342 src/coding.c   	val = decode_string_utf_8 (string, buffer, ! NILP (nocopy),</span>
<span class='curline'><a href='../S/1990.html#L10347'>buffer</a>           10347 src/coding.c         if (! BUFFERP (buffer))</span>
<span class='curline'><a href='../S/1990.html#L10348'>buffer</a>           10348 src/coding.c   	buffer = Qt;</span>
<span class='curline'><a href='../S/1990.html#L10350'>buffer</a>           10350 src/coding.c   	val = code_convert_string (string, Qutf_8_unix, buffer, false,</span>
<span class='curline'><a href='../S/1990.html#L10449'>buffer</a>           10449 src/coding.c     (Lisp_Object string, Lisp_Object coding_system, Lisp_Object nocopy, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/1990.html#L10451'>buffer</a>           10451 src/coding.c     return code_convert_string (string, coding_system, buffer,</span>
<span class='curline'><a href='../S/1990.html#L10469'>buffer</a>           10469 src/coding.c     (Lisp_Object string, Lisp_Object coding_system, Lisp_Object nocopy, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/1990.html#L10471'>buffer</a>           10471 src/coding.c     return code_convert_string (string, coding_system, buffer,</span>
<span class='curline'><a href='../S/2065.html#L1371'>buffer</a>           1371 src/data.c     			 struct buffer *buf)</span>
<span class='curline'><a href='../S/2065.html#L1410'>buffer</a>           1410 src/data.c     	      struct buffer *b = XBUFFER (buf);</span>
<span class='curline'><a href='../S/2065.html#L1727'>buffer</a>           1727 src/data.c     	struct buffer *buf</span>
<span class='curline'><a href='../S/2065.html#L2034'>buffer</a>           2034 src/data.c     		    struct buffer *b = XBUFFER (buf);</span>
<span class='curline'><a href='../S/2065.html#L2340'>buffer</a>           2340 src/data.c       (Lisp_Object variable, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2065.html#L2342'>buffer</a>           2342 src/data.c       struct buffer *buf = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/2065.html#L2391'>buffer</a>           2391 src/data.c       (register Lisp_Object variable, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2065.html#L2409'>buffer</a>           2409 src/data.c     	return Flocal_variable_p (variable, buffer);</span>
<span class='curline'><a href='../S/2065.html#L2963'>buffer</a>           2963 src/data.c     fixnum_to_string (EMACS_INT number, char *buffer, char *end)</span>
<span class='curline'><a href='../S/2065.html#L2972'>buffer</a>           2972 src/data.c           eassume (p &gt; buffer &amp;&amp; p - 1 &lt; end);</span>
<span class='curline'><a href='../S/2065.html#L2988'>buffer</a>           2988 src/data.c       char buffer[max (FLOAT_TO_STRING_BUFSIZE, INT_BUFSIZE_BOUND (EMACS_INT))];</span>
<span class='curline'><a href='../S/2065.html#L2992'>buffer</a>           2992 src/data.c           char *end = buffer + sizeof buffer;</span>
<span class='curline'><a href='../S/2065.html#L2993'>buffer</a>           2993 src/data.c           char *p = fixnum_to_string (XFIXNUM (number), buffer, end);</span>
<span class='curline'><a href='../S/2065.html#L3001'>buffer</a>           3001 src/data.c         return make_unibyte_string (buffer,</span>
<span class='curline'><a href='../S/2065.html#L3002'>buffer</a>           3002 src/data.c     				float_to_string (buffer, XFLOAT_DATA (number)));</span>
<span class='curline'><a href='../S/2203.html#L792'>buffer</a>            792 src/dispextern.h   struct buffer *buffer;</span>
<span class='curline'><a href='../S/2038.html#L1483'>buffer</a>           1483 src/dispnew.c    struct buffer *saved = current_buffer;</span>
<span class='curline'><a href='../S/2038.html#L1484'>buffer</a>           1484 src/dispnew.c    struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2038.html#L1491'>buffer</a>           1491 src/dispnew.c    set_buffer_temp (buffer);</span>
<span class='curline'><a href='../S/2057.html#L152'>buffer</a>            152 src/doprnt.c   doprnt_non_null_end (char *buffer, ptrdiff_t bufsize, char const *format,</span>
<span class='curline'><a href='../S/2057.html#L160'>buffer</a>            160 src/doprnt.c     ptrdiff_t nbytes = doprnt (buffer, bufsize, fmt, NULL, ap);</span>
<span class='curline'><a href='../S/2057.html#L186'>buffer</a>            186 src/doprnt.c   doprnt (char *buffer, ptrdiff_t bufsize, const char *format,</span>
<span class='curline'><a href='../S/2057.html#L190'>buffer</a>            190 src/doprnt.c       return doprnt_non_null_end (buffer, bufsize, format, format_end, ap);</span>
<span class='curline'><a href='../S/2057.html#L193'>buffer</a>            193 src/doprnt.c     char *bufptr = buffer;	/* Pointer into output buffer.  */</span>
<span class='curline'><a href='../S/2057.html#L534'>buffer</a>            534 src/doprnt.c     return bufptr - buffer;</span>
<span class='curline'><a href='../S/2189.html#L316'>buffer</a>            316 src/editfns.c        struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/2189.html#L816'>buffer</a>            816 src/editfns.c    Lisp_Object buffer = Fmarker_buffer (marker);</span>
<span class='curline'><a href='../S/2189.html#L819'>buffer</a>            819 src/editfns.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2189.html#L822'>buffer</a>            822 src/editfns.c    Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2189.html#L887'>buffer</a>            887 src/editfns.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2189.html#L889'>buffer</a>            889 src/editfns.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2189.html#L893'>buffer</a>            893 src/editfns.c        CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2189.html#L894'>buffer</a>            894 src/editfns.c        return make_fixnum (BUF_Z (XBUFFER (buffer))</span>
<span class='curline'><a href='../S/2189.html#L895'>buffer</a>            895 src/editfns.c  			  - BUF_BEG (XBUFFER (buffer)));</span>
<span class='curline'><a href='../S/2189.html#L1731'>buffer</a>           1731 src/editfns.c    (Lisp_Object buffer, Lisp_Object start, Lisp_Object end)</span>
<span class='curline'><a href='../S/2189.html#L1734'>buffer</a>           1734 src/editfns.c    register struct buffer *bp, *obuf;</span>
<span class='curline'><a href='../S/2189.html#L1737'>buffer</a>           1737 src/editfns.c    buf = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/2189.html#L1739'>buffer</a>           1739 src/editfns.c      nsberror (buffer);</span>
<span class='curline'><a href='../S/2189.html#L1777'>buffer</a>           1777 src/editfns.c    register struct buffer *bp1, *bp2;</span>
<span class='curline'><a href='../S/2189.html#L1908'>buffer</a>           1908 src/editfns.c    struct buffer *buffer_a;                      \</span>
<span class='curline'><a href='../S/2189.html#L1909'>buffer</a>           1909 src/editfns.c    struct buffer *buffer_b;                      \</span>
<span class='curline'><a href='../S/2189.html#L1968'>buffer</a>           1968 src/editfns.c    struct buffer *a = current_buffer;</span>
<span class='curline'><a href='../S/2189.html#L1972'>buffer</a>           1972 src/editfns.c    struct buffer *b = XBUFFER (source_buffer);</span>
<span class='curline'><a href='../S/2189.html#L2033'>buffer</a>           2033 src/editfns.c    ptrdiff_t *buffer;</span>
<span class='curline'><a href='../S/2189.html#L2035'>buffer</a>           2035 src/editfns.c    if (ckd_mul (&amp;bytes_needed, diags, 2 * sizeof *buffer)</span>
<span class='curline'><a href='../S/2189.html#L2039'>buffer</a>           2039 src/editfns.c    buffer = SAFE_ALLOCA (bytes_needed);</span>
<span class='curline'><a href='../S/2189.html#L2040'>buffer</a>           2040 src/editfns.c    unsigned char *deletions_insertions = memset (buffer + 2 * diags, 0,</span>
<span class='curline'><a href='../S/2189.html#L2056'>buffer</a>           2056 src/editfns.c      .fdiag = buffer + size_b + 1,</span>
<span class='curline'><a href='../S/2189.html#L2057'>buffer</a>           2057 src/editfns.c      .bdiag = buffer + diags + size_b + 1,</span>
<span class='curline'><a href='../S/2189.html#L3044'>buffer</a>           3044 src/editfns.c    struct buffer *cur = NULL;</span>
<span class='curline'><a href='../S/2189.html#L3045'>buffer</a>           3045 src/editfns.c    struct buffer *buf = (CONSP (data)</span>
<span class='curline'><a href='../S/2189.html#L3046'>buffer</a>           3046 src/editfns.c  			? XMARKER (XCAR (data))-&gt;buffer</span>
<span class='curline'><a href='../S/2189.html#L3063'>buffer</a>           3063 src/editfns.c        eassert (buf == end-&gt;buffer);</span>
<span class='curline'><a href='../S/2228.html#L1074'>buffer</a>           1074 src/emacs.c    read_full (int fd, void *buffer, ptrdiff_t size)</span>
<span class='curline'><a href='../S/2228.html#L1077'>buffer</a>           1077 src/emacs.c      eassert (buffer != NULL);</span>
<span class='curline'><a href='../S/2228.html#L1093'>buffer</a>           1093 src/emacs.c      char *ptr = buffer;</span>
<span class='curline'><a href='../S/2228.html#L1117'>buffer</a>           1117 src/emacs.c      void *buffer = NULL;</span>
<span class='curline'><a href='../S/2228.html#L1154'>buffer</a>           1154 src/emacs.c      buffer = malloc (size + 1);</span>
<span class='curline'><a href='../S/2228.html#L1155'>buffer</a>           1155 src/emacs.c      if (buffer == NULL)</span>
<span class='curline'><a href='../S/2228.html#L1160'>buffer</a>           1160 src/emacs.c      ptrdiff_t read = read_full (fd, buffer, size + 1);</span>
<span class='curline'><a href='../S/2228.html#L1178'>buffer</a>           1178 src/emacs.c      program.filter = buffer;</span>
<span class='curline'><a href='../S/2228.html#L1200'>buffer</a>           1200 src/emacs.c      free (buffer);</span>
<span class='curline'><a href='../S/2085.html#L2079'>buffer</a>           2079 src/eval.c       char *buffer = buf;</span>
<span class='curline'><a href='../S/2085.html#L2083'>buffer</a>           2083 src/eval.c       used = evxprintf (&amp;buffer, &amp;size, buf, size_max, m, ap);</span>
<span class='curline'><a href='../S/2085.html#L2084'>buffer</a>           2084 src/eval.c       string = make_string (buffer, used);</span>
<span class='curline'><a href='../S/2085.html#L2085'>buffer</a>           2085 src/eval.c       if (buffer != buf)</span>
<span class='curline'><a href='../S/2085.html#L2086'>buffer</a>           2086 src/eval.c         xfree (buffer);</span>
<span class='curline'><a href='../S/2204.html#L3699'>buffer</a>           3699 src/fileio.c     Lisp_Object buffer = XCDR (tmp);</span>
<span class='curline'><a href='../S/2204.html#L3701'>buffer</a>           3701 src/fileio.c     set_buffer_internal (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2204.html#L3858'>buffer</a>           3858 src/fileio.c   maybe_move_gap (struct buffer *b)</span>
<span class='curline'><a href='../S/2204.html#L3862'>buffer</a>           3862 src/fileio.c         struct buffer *cb = current_buffer;</span>
<span class='curline'><a href='../S/2204.html#L4135'>buffer</a>           4135 src/fileio.c   		  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2204.html#L4137'>buffer</a>           4137 src/fileio.c   		  struct buffer *buf;</span>
<span class='curline'><a href='../S/2204.html#L5201'>buffer</a>           5201 src/fileio.c     struct buffer *given_buffer;</span>
<span class='curline'><a href='../S/2204.html#L5560'>buffer</a>           5560 src/fileio.c         struct buffer *given_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2204.html#L5597'>buffer</a>           5597 src/fileio.c         struct buffer *given_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2204.html#L5786'>buffer</a>           5786 src/fileio.c     struct buffer *b = decode_buffer (buf);</span>
<span class='curline'><a href='../S/2204.html#L5815'>buffer</a>           5815 src/fileio.c   buffer_visited_file_modtime (struct buffer *buf)</span>
<span class='curline'><a href='../S/2204.html#L5990'>buffer</a>           5990 src/fileio.c     struct buffer *old = current_buffer, *b;</span>
<span class='curline'><a href='../S/2251.html#L763'>buffer</a>            763 src/filelock.c   register struct buffer *b;</span>
<span class='curline'><a href='../S/2251.html#L857'>buffer</a>            857 src/filelock.c unlock_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/2251.html#L859'>buffer</a>            859 src/filelock.c   if (BUF_SAVE_MODIFF (buffer) &lt; BUF_MODIFF (buffer)</span>
<span class='curline'><a href='../S/2251.html#L860'>buffer</a>            860 src/filelock.c       &amp;&amp; STRINGP (BVAR (buffer, file_truename)))</span>
<span class='curline'><a href='../S/2251.html#L861'>buffer</a>            861 src/filelock.c     Funlock_file (BVAR (buffer, file_truename));</span>
<span class='curline'><a href='../S/2208.html#L2844'>buffer</a>           2844 src/fns.c      	    return (XMARKER (o1)-&gt;buffer == XMARKER (o2)-&gt;buffer</span>
<span class='curline'><a href='../S/2208.html#L2845'>buffer</a>           2845 src/fns.c      		    &amp;&amp; (XMARKER (o1)-&gt;buffer == 0</span>
<span class='curline'><a href='../S/2208.html#L5151'>buffer</a>           5151 src/fns.c      	      = XMARKER (obj)-&gt;buffer ? XMARKER (obj)-&gt;bytepos : 0;</span>
<span class='curline'><a href='../S/2208.html#L5153'>buffer</a>           5153 src/fns.c      	      = sxhash_combine ((intptr_t) XMARKER (obj)-&gt;buffer, bytepos);</span>
<span class='curline'><a href='../S/2208.html#L5649'>buffer</a>           5649 src/fns.c            struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2208.html#L5654'>buffer</a>           5654 src/fns.c            struct buffer *bp = XBUFFER (object);</span>
<span class='curline'><a href='../S/2208.html#L5918'>buffer</a>           5918 src/fns.c        Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2208.html#L5919'>buffer</a>           5919 src/fns.c        struct buffer *b;</span>
<span class='curline'><a href='../S/2208.html#L5923'>buffer</a>           5923 src/fns.c          buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2208.html#L5925'>buffer</a>           5925 src/fns.c          buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/2208.html#L5926'>buffer</a>           5926 src/fns.c        if (NILP (buffer))</span>
<span class='curline'><a href='../S/2208.html#L5929'>buffer</a>           5929 src/fns.c        b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2208.html#L5958'>buffer</a>           5958 src/fns.c        Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2208.html#L5961'>buffer</a>           5961 src/fns.c        struct buffer *b;</span>
<span class='curline'><a href='../S/2208.html#L5964'>buffer</a>           5964 src/fns.c          buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2208.html#L5966'>buffer</a>           5966 src/fns.c          buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/2208.html#L5967'>buffer</a>           5967 src/fns.c        if (NILP (buffer))</span>
<span class='curline'><a href='../S/2208.html#L5970'>buffer</a>           5970 src/fns.c        b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2208.html#L6163'>buffer</a>           6163 src/fns.c            if (XMARKER (position)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/2185.html#L414'>buffer</a>            414 src/font.h       unsigned char *buffer;</span>
<span class='curline'><a href='../S/2140.html#L3105'>buffer</a>           3105 src/frame.c    frames_discard_buffer (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2140.html#L3112'>buffer</a>           3112 src/frame.c    	(XFRAME (frame), Fdelq (buffer, XFRAME (frame)-&gt;buffer_list));</span>
<span class='curline'><a href='../S/2140.html#L3114'>buffer</a>           3114 src/frame.c    	(XFRAME (frame), Fdelq (buffer, XFRAME (frame)-&gt;buried_buffer_list));</span>
<span class='curline'><a href='../S/2242.html#L934'>buffer</a>            934 src/fringe.c     struct buffer *oldbuf = current_buffer;</span>
<span class='curline'><a href='../S/2231.html#L1665'>buffer</a>           1665 src/ftfont.c     bitmap-&gt;buffer = ft_face-&gt;glyph-&gt;bitmap.buffer;</span>
<span class='curline'><a href='../S/2250.html#L1429'>buffer</a>           1429 src/gtkutil.c        char buffer[sizeof format];</span>
<span class='curline'><a href='../S/2250.html#L1430'>buffer</a>           1430 src/gtkutil.c        int n = snprintf(buffer, sizeof buffer, format,</span>
<span class='curline'><a href='../S/2250.html#L1433'>buffer</a>           1433 src/gtkutil.c        eassert (n &lt; sizeof buffer);</span>
<span class='curline'><a href='../S/2250.html#L1435'>buffer</a>           1435 src/gtkutil.c        gtk_css_provider_load_from_data (provider, buffer, -1, NULL);</span>
<span class='curline'><a href='../S/2120.html#L5531'>buffer</a>           5531 src/haiku_support.cc   char *buffer;</span>
<span class='curline'><a href='../S/2120.html#L5544'>buffer</a>           5544 src/haiku_support.cc   buffer = new (std::nothrow) char[flat];</span>
<span class='curline'><a href='../S/2120.html#L5545'>buffer</a>           5545 src/haiku_support.cc   if (!buffer)</span>
<span class='curline'><a href='../S/2120.html#L5548'>buffer</a>           5548 src/haiku_support.cc   rc = msg-&gt;Flatten (buffer, flat);</span>
<span class='curline'><a href='../S/2120.html#L5551'>buffer</a>           5551 src/haiku_support.cc       delete[] buffer;</span>
<span class='curline'><a href='../S/2120.html#L5556'>buffer</a>           5556 src/haiku_support.cc 			   buffer, flat);</span>
<span class='curline'><a href='../S/2120.html#L5557'>buffer</a>           5557 src/haiku_support.cc   delete[] buffer;</span>
<span class='curline'><a href='../S/2000.html#L2401'>buffer</a>           2401 src/haikufns.c   struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/2219.html#L563'>buffer</a>            563 src/haikumenu.c   struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2219.html#L564'>buffer</a>            564 src/haikumenu.c   Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2219.html#L617'>buffer</a>            617 src/haikumenu.c       buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/2219.html#L630'>buffer</a>            630 src/haikumenu.c       set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2099.html#L4260'>buffer</a>           4260 src/image.c      char buffer[BUFSIZ];</span>
<span class='curline'><a href='../S/2099.html#L4269'>buffer</a>           4269 src/image.c         LA1 = xbm_scan (&amp;s, end, buffer, &amp;value)</span>
<span class='curline'><a href='../S/2099.html#L4281'>buffer</a>           4281 src/image.c         if (LA1 == XBM_TK_IDENT &amp;&amp; strcmp (buffer, (IDENT)) == 0)	\</span>
<span class='curline'><a href='../S/2099.html#L4289'>buffer</a>           4289 src/image.c      LA1 = xbm_scan (&amp;s, end, buffer, &amp;value);</span>
<span class='curline'><a href='../S/2099.html#L4300'>buffer</a>           4300 src/image.c    	  char *q = strrchr (buffer, '_');</span>
<span class='curline'><a href='../S/2099.html#L4301'>buffer</a>           4301 src/image.c    	  q = q ? q + 1 : buffer;</span>
<span class='curline'><a href='../S/2099.html#L4323'>buffer</a>           4323 src/image.c          if (strcmp (buffer, "unsigned") == 0)</span>
<span class='curline'><a href='../S/2099.html#L4328'>buffer</a>           4328 src/image.c          else if (strcmp (buffer, "short") == 0)</span>
<span class='curline'><a href='../S/2099.html#L4335'>buffer</a>           4335 src/image.c          else if (strcmp (buffer, "char") == 0)</span>
<span class='curline'><a href='../S/2099.html#L5182'>buffer</a>           5182 src/image.c          Lisp_Object buffer = image_spec_value (img-&gt;spec, QCdata, NULL);</span>
<span class='curline'><a href='../S/2099.html#L5183'>buffer</a>           5183 src/image.c          if (!STRINGP (buffer))</span>
<span class='curline'><a href='../S/2099.html#L5185'>buffer</a>           5185 src/image.c    	  image_error ("Invalid image data `%s'", buffer);</span>
<span class='curline'><a href='../S/2099.html#L5195'>buffer</a>           5195 src/image.c          rc = XpmCreateImageFromBuffer (&amp;hdc, SSDATA (buffer),</span>
<span class='curline'><a href='../S/2099.html#L5199'>buffer</a>           5199 src/image.c          rc = XpmCreateImageFromBuffer (FRAME_X_DISPLAY (f), SSDATA (buffer),</span>
<span class='curline'><a href='../S/2099.html#L5539'>buffer</a>           5539 src/image.c      char buffer[BUFSIZ];</span>
<span class='curline'><a href='../S/2099.html#L5587'>buffer</a>           5587 src/image.c      memcpy (buffer, beg, len);</span>
<span class='curline'><a href='../S/2099.html#L5588'>buffer</a>           5588 src/image.c      buffer[len] = '\0';</span>
<span class='curline'><a href='../S/2099.html#L5589'>buffer</a>           5589 src/image.c      if (sscanf (buffer, "%d %d %d %d", &amp;width, &amp;height,</span>
<span class='curline'><a href='../S/2099.html#L5641'>buffer</a>           5641 src/image.c          memcpy (buffer, beg + chars_per_pixel, len - chars_per_pixel);</span>
<span class='curline'><a href='../S/2099.html#L5642'>buffer</a>           5642 src/image.c          buffer[len - chars_per_pixel] = '\0';</span>
<span class='curline'><a href='../S/2099.html#L5644'>buffer</a>           5644 src/image.c          str = strtok (buffer, " \t");</span>
<span class='curline'><a href='../S/2099.html#L8072'>buffer</a>           8072 src/image.c      JOCTET *buffer;</span>
<span class='curline'><a href='../S/2099.html#L8094'>buffer</a>           8094 src/image.c          bytes = fread (src-&gt;buffer, 1, JPEG_STDIO_BUFFER_SIZE, src-&gt;file);</span>
<span class='curline'><a href='../S/2099.html#L8101'>buffer</a>           8101 src/image.c              src-&gt;buffer[0] = (JOCTET) 0xFF;</span>
<span class='curline'><a href='../S/2099.html#L8102'>buffer</a>           8102 src/image.c              src-&gt;buffer[1] = (JOCTET) JPEG_EOI;</span>
<span class='curline'><a href='../S/2099.html#L8105'>buffer</a>           8105 src/image.c          src-&gt;mgr.next_input_byte = src-&gt;buffer;</span>
<span class='curline'><a href='../S/2099.html#L8156'>buffer</a>           8156 src/image.c          src-&gt;buffer = cinfo-&gt;mem-&gt;alloc_small ((j_common_ptr) cinfo,</span>
<span class='curline'><a href='../S/2099.html#L8181'>buffer</a>           8181 src/image.c      JSAMPARRAY buffer;</span>
<span class='curline'><a href='../S/2099.html#L8324'>buffer</a>           8324 src/image.c      buffer = mgr-&gt;cinfo.mem-&gt;alloc_sarray ((j_common_ptr) &amp;mgr-&gt;cinfo,</span>
<span class='curline'><a href='../S/2099.html#L8328'>buffer</a>           8328 src/image.c          jpeg_read_scanlines (&amp;mgr-&gt;cinfo, buffer, 1);</span>
<span class='curline'><a href='../S/2099.html#L8330'>buffer</a>           8330 src/image.c    	PUT_PIXEL (ximg, x, y, colors[buffer[0][x]]);</span>
<span class='curline'><a href='../S/2099.html#L11706'>buffer</a>           11706 src/image.c      char buffer[sizeof " " + 2 * INT_STRLEN_BOUND (intmax_t)];</span>
<span class='curline'><a href='../S/2099.html#L11758'>buffer</a>           11758 src/image.c        = make_formatted_string (buffer, "%"PRIuMAX" %"PRIuMAX,</span>
<span class='curline'><a href='../S/2099.html#L11764'>buffer</a>           11764 src/image.c        = make_formatted_string (buffer, "%"PRIuMAX" %"PRIuMAX,</span>
<span class='curline'><a href='../S/2206.html#L127'>buffer</a>            127 src/indent.c   recompute_width_table (struct buffer *buf, struct Lisp_Char_Table *disptab)</span>
<span class='curline'><a href='../S/2206.html#L147'>buffer</a>            147 src/indent.c     struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2206.html#L220'>buffer</a>            220 src/indent.c     Lisp_Object buffer, tmp;</span>
<span class='curline'><a href='../S/2206.html#L225'>buffer</a>            225 src/indent.c     XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/2206.html#L233'>buffer</a>            233 src/indent.c     proplimit = Fnext_property_change (position, buffer, Qt);</span>
<span class='curline'><a href='../S/2206.html#L250'>buffer</a>            250 src/indent.c   					  buffer, proplimit);</span>
<span class='curline'><a href='../S/2206.html#L267'>buffer</a>            267 src/indent.c   			      &amp;&amp; EQ (XWINDOW (window)-&gt;contents, buffer))</span>
<span class='curline'><a href='../S/2206.html#L268'>buffer</a>            268 src/indent.c   			     ? window : buffer);</span>
<span class='curline'><a href='../S/2206.html#L1245'>buffer</a>           1245 src/indent.c     struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2206.html#L2047'>buffer</a>           2047 src/indent.c         struct buffer *old_buf = current_buffer;</span>
<span class='curline'><a href='../S/2206.html#L2062'>buffer</a>           2062 src/indent.c   	       &amp;&amp; XBUFFER (w-&gt;contents) == XMARKER (w-&gt;start)-&gt;buffer))</span>
<span class='curline'><a href='../S/2249.html#L57'>buffer</a>             57 src/indent.h   void recompute_width_table (struct buffer *buf,</span>
<span class='curline'><a href='../S/2223.html#L320'>buffer</a>            320 src/inotify.c    char *buffer = SAFE_ALLOCA (to_read);</span>
<span class='curline'><a href='../S/2223.html#L321'>buffer</a>            321 src/inotify.c    ssize_t n = read (fd, buffer, to_read);</span>
<span class='curline'><a href='../S/2223.html#L331'>buffer</a>            331 src/inotify.c        struct inotify_event *ev = (struct inotify_event *) &amp;buffer[i];</span>
<span class='curline'><a href='../S/2116.html#L40'>buffer</a>             40 src/insdel.c   static void insert_from_buffer_1 (struct buffer *, ptrdiff_t, ptrdiff_t, bool);</span>
<span class='curline'><a href='../S/2116.html#L73'>buffer</a>             73 src/insdel.c         if (tail-&gt;buffer-&gt;text != current_buffer-&gt;text)</span>
<span class='curline'><a href='../S/2116.html#L600'>buffer</a>            600 src/insdel.c   make_gap_1 (struct buffer *b, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/2116.html#L602'>buffer</a>            602 src/insdel.c     struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/2116.html#L1177'>buffer</a>           1177 src/insdel.c   insert_from_buffer (struct buffer *buf,</span>
<span class='curline'><a href='../S/2116.html#L1202'>buffer</a>           1202 src/insdel.c   insert_from_buffer_1 (struct buffer *buf,</span>
<span class='curline'><a href='../S/2116.html#L2008'>buffer</a>           2008 src/insdel.c     struct buffer *base_buffer;</span>
<span class='curline'><a href='../S/2116.html#L2059'>buffer</a>           2059 src/insdel.c         &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer</span>
<span class='curline'><a href='../S/2116.html#L2086'>buffer</a>           2086 src/insdel.c   invalidate_buffer_caches (struct buffer *buf, ptrdiff_t start, ptrdiff_t end)</span>
<span class='curline'><a href='../S/2116.html#L2113'>buffer</a>           2113 src/insdel.c   	      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2111.html#L468'>buffer</a>            468 src/intervals.c buffer_balance_intervals (struct buffer *b)</span>
<span class='curline'><a href='../S/2111.html#L1309'>buffer</a>           1309 src/intervals.c adjust_intervals_for_deletion (struct buffer *buffer,</span>
<span class='curline'><a href='../S/2111.html#L1313'>buffer</a>           1313 src/intervals.c   INTERVAL tree = buffer_intervals (buffer);</span>
<span class='curline'><a href='../S/2111.html#L1328'>buffer</a>           1328 src/intervals.c       set_buffer_intervals (buffer, NULL);</span>
<span class='curline'><a href='../S/2111.html#L1345'>buffer</a>           1345 src/intervals.c       tree = buffer_intervals (buffer);</span>
<span class='curline'><a href='../S/2111.html#L1348'>buffer</a>           1348 src/intervals.c 	  set_buffer_intervals (buffer, NULL);</span>
<span class='curline'><a href='../S/2111.html#L1360'>buffer</a>           1360 src/intervals.c offset_intervals (struct buffer *buffer, ptrdiff_t start, ptrdiff_t length)</span>
<span class='curline'><a href='../S/2111.html#L1362'>buffer</a>           1362 src/intervals.c   if (!buffer_intervals (buffer) || length == 0)</span>
<span class='curline'><a href='../S/2111.html#L1366'>buffer</a>           1366 src/intervals.c     adjust_intervals_for_insertion (buffer_intervals (buffer),</span>
<span class='curline'><a href='../S/2111.html#L1369'>buffer</a>           1369 src/intervals.c     adjust_intervals_for_deletion (buffer, start, -length);</span>
<span class='curline'><a href='../S/2111.html#L1569'>buffer</a>           1569 src/intervals.c 			     ptrdiff_t length, struct buffer *buffer,</span>
<span class='curline'><a href='../S/2111.html#L1572'>buffer</a>           1572 src/intervals.c   INTERVAL tree = buffer_intervals (buffer);</span>
<span class='curline'><a href='../S/2111.html#L1585'>buffer</a>           1585 src/intervals.c 	  XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/2111.html#L1592'>buffer</a>           1592 src/intervals.c       buffer_balance_intervals (buffer);</span>
<span class='curline'><a href='../S/2111.html#L1598'>buffer</a>           1598 src/intervals.c   if ((BUF_Z (buffer) - BUF_BEG (buffer)) == length)</span>
<span class='curline'><a href='../S/2111.html#L1604'>buffer</a>           1604 src/intervals.c       XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/2111.html#L1605'>buffer</a>           1605 src/intervals.c       set_buffer_intervals (buffer, reproduce_tree_obj (source, buf));</span>
<span class='curline'><a href='../S/2111.html#L1606'>buffer</a>           1606 src/intervals.c       buffer_intervals (buffer)-&gt;position = BUF_BEG (buffer);</span>
<span class='curline'><a href='../S/2111.html#L1607'>buffer</a>           1607 src/intervals.c       eassert (buffer_intervals (buffer)-&gt;up_obj == 1);</span>
<span class='curline'><a href='../S/2111.html#L1616'>buffer</a>           1616 src/intervals.c 	XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/2111.html#L1699'>buffer</a>           1699 src/intervals.c   buffer_balance_intervals (buffer);</span>
<span class='curline'><a href='../S/2111.html#L1753'>buffer</a>           1753 src/intervals.c temp_set_point_both (struct buffer *buffer,</span>
<span class='curline'><a href='../S/2111.html#L1757'>buffer</a>           1757 src/intervals.c   eassert (BUF_ZV (buffer) != BUF_ZV_BYTE (buffer) || charpos == bytepos);</span>
<span class='curline'><a href='../S/2111.html#L1760'>buffer</a>           1760 src/intervals.c   eassert (charpos &lt;= BUF_ZV (buffer) || BUF_BEGV (buffer) &lt;= charpos);</span>
<span class='curline'><a href='../S/2111.html#L1762'>buffer</a>           1762 src/intervals.c   SET_BUF_PT_BOTH (buffer, charpos, bytepos);</span>
<span class='curline'><a href='../S/2111.html#L1768'>buffer</a>           1768 src/intervals.c temp_set_point (struct buffer *buffer, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/2111.html#L1770'>buffer</a>           1770 src/intervals.c   temp_set_point_both (buffer, charpos,</span>
<span class='curline'><a href='../S/2111.html#L1771'>buffer</a>           1771 src/intervals.c 		       buf_charpos_to_bytepos (buffer, charpos));</span>
<span class='curline'><a href='../S/2111.html#L1793'>buffer</a>           1793 src/intervals.c   if (XMARKER (marker)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/2111.html#L2178'>buffer</a>           2178 src/intervals.c get_local_map (ptrdiff_t position, struct buffer *buffer, Lisp_Object type)</span>
<span class='curline'><a href='../S/2111.html#L2184'>buffer</a>           2184 src/intervals.c   position = clip_to_bounds (BUF_BEGV (buffer), position, BUF_ZV (buffer));</span>
<span class='curline'><a href='../S/2111.html#L2188'>buffer</a>           2188 src/intervals.c   old_begv = BUF_BEGV (buffer);</span>
<span class='curline'><a href='../S/2111.html#L2189'>buffer</a>           2189 src/intervals.c   old_zv = BUF_ZV (buffer);</span>
<span class='curline'><a href='../S/2111.html#L2190'>buffer</a>           2190 src/intervals.c   old_begv_byte = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2111.html#L2191'>buffer</a>           2191 src/intervals.c   old_zv_byte = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2111.html#L2194'>buffer</a>           2194 src/intervals.c   SET_BUF_BEGV_BOTH (buffer, BUF_BEG (buffer), BUF_BEG_BYTE (buffer));</span>
<span class='curline'><a href='../S/2111.html#L2195'>buffer</a>           2195 src/intervals.c   SET_BUF_ZV_BOTH (buffer, BUF_Z (buffer), BUF_Z_BYTE (buffer));</span>
<span class='curline'><a href='../S/2111.html#L2198'>buffer</a>           2198 src/intervals.c   XSETBUFFER (lispy_buffer, buffer);</span>
<span class='curline'><a href='../S/2111.html#L2209'>buffer</a>           2209 src/intervals.c   SET_BUF_BEGV_BOTH (buffer, old_begv, old_begv_byte);</span>
<span class='curline'><a href='../S/2111.html#L2210'>buffer</a>           2210 src/intervals.c   SET_BUF_ZV_BOTH (buffer, old_zv, old_zv_byte);</span>
<span class='curline'><a href='../S/2111.html#L2221'>buffer</a>           2221 src/intervals.c     return BVAR (buffer, keymap);</span>
<span class='curline'><a href='../S/2111.html#L2269'>buffer</a>           2269 src/intervals.c copy_intervals_to_string (Lisp_Object string, struct buffer *buffer,</span>
<span class='curline'><a href='../S/2111.html#L2272'>buffer</a>           2272 src/intervals.c   INTERVAL interval_copy = copy_intervals (buffer_intervals (buffer),</span>
<span class='curline'><a href='../S/2122.html#L259'>buffer</a>            259 src/intervals.h extern void offset_intervals (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/2122.html#L261'>buffer</a>            261 src/intervals.h                                          struct buffer *, bool);</span>
<span class='curline'><a href='../S/2122.html#L262'>buffer</a>            262 src/intervals.h extern void verify_interval_modification (struct buffer *,</span>
<span class='curline'><a href='../S/2122.html#L265'>buffer</a>            265 src/intervals.h extern void copy_intervals_to_string (Lisp_Object, struct buffer *,</span>
<span class='curline'><a href='../S/2122.html#L274'>buffer</a>            274 src/intervals.h extern Lisp_Object get_local_map (ptrdiff_t, struct buffer *, Lisp_Object);</span>
<span class='curline'><a href='../S/2122.html#L301'>buffer</a>            301 src/intervals.h                                      Lisp_Object buffer);</span>
<span class='curline'><a href='../S/2253.html#L644'>buffer</a>            644 src/json.c       const char *buffer;</span>
<span class='curline'><a href='../S/2253.html#L665'>buffer</a>            665 src/json.c     	  buffer_and_size-&gt;buffer, len);</span>
<span class='curline'><a href='../S/2253.html#L701'>buffer</a>            701 src/json.c     json_insert_callback (const char *buffer, size_t size, void *data)</span>
<span class='curline'><a href='../S/2253.html#L705'>buffer</a>            705 src/json.c         = {.buffer = buffer, .size = size, .inserted_bytes = d-&gt;inserted_bytes};</span>
<span class='curline'><a href='../S/2253.html#L1009'>buffer</a>           1009 src/json.c     json_read_buffer_callback (void *buffer, size_t buflen, void *data)</span>
<span class='curline'><a href='../S/2253.html#L1020'>buffer</a>           1020 src/json.c       memcpy (buffer, BYTE_POS_ADDR (point), count);</span>
<span class='curline'><a href='../S/2008.html#L217'>buffer</a>            217 src/keyboard.c struct buffer *buffer_before_last_command_or_undo;</span>
<span class='curline'><a href='../S/2008.html#L315'>buffer</a>            315 src/keyboard.c static void recursive_edit_unwind (Lisp_Object buffer);</span>
<span class='curline'><a href='../S/2008.html#L480'>buffer</a>            480 src/keyboard.c   char *buffer = initbuf;</span>
<span class='curline'><a href='../S/2008.html#L481'>buffer</a>            481 src/keyboard.c   char *ptr = buffer;</span>
<span class='curline'><a href='../S/2008.html#L499'>buffer</a>            499 src/keyboard.c       if (size - (ptr - buffer) &lt; nbytes)</span>
<span class='curline'><a href='../S/2008.html#L501'>buffer</a>            501 src/keyboard.c 	  ptrdiff_t offset = ptr - buffer;</span>
<span class='curline'><a href='../S/2008.html#L503'>buffer</a>            503 src/keyboard.c 	  buffer = SAFE_ALLOCA (size);</span>
<span class='curline'><a href='../S/2008.html#L504'>buffer</a>            504 src/keyboard.c 	  ptr = buffer + offset;</span>
<span class='curline'><a href='../S/2008.html#L511'>buffer</a>            511 src/keyboard.c   Lisp_Object new_string = make_string (buffer, ptr - buffer);</span>
<span class='curline'><a href='../S/2008.html#L776'>buffer</a>            776 src/keyboard.c   Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2008.html#L785'>buffer</a>            785 src/keyboard.c     buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2008.html#L787'>buffer</a>            787 src/keyboard.c     buffer = Qnil;</span>
<span class='curline'><a href='../S/2008.html#L794'>buffer</a>            794 src/keyboard.c   record_unwind_protect (recursive_edit_unwind, buffer);</span>
<span class='curline'><a href='../S/2008.html#L808'>buffer</a>            808 src/keyboard.c recursive_edit_unwind (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2008.html#L810'>buffer</a>            810 src/keyboard.c   if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/2008.html#L811'>buffer</a>            811 src/keyboard.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2008.html#L1280'>buffer</a>           1280 src/keyboard.c   struct buffer *prev_buffer = NULL;</span>
<span class='curline'><a href='../S/2008.html#L1417'>buffer</a>           1417 src/keyboard.c 	  struct buffer *b;</span>
<span class='curline'><a href='../S/2008.html#L1584'>buffer</a>           1584 src/keyboard.c 		  &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer</span>
<span class='curline'><a href='../S/2008.html#L3027'>buffer</a>           3027 src/keyboard.c       struct buffer *prev_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2008.html#L9921'>buffer</a>           9921 src/keyboard.c   struct buffer *starting_buffer;</span>
<span class='curline'><a href='../S/2082.html#L260'>buffer</a>            260 src/keyboard.h extern struct buffer *buffer_before_last_command_or_undo;</span>
<span class='curline'><a href='../S/2082.html#L262'>buffer</a>            262 src/keyboard.h extern struct buffer *prev_buffer;</span>
<span class='curline'><a href='../S/2119.html#L2342'>buffer</a>           2342 src/keymap.c   	  char *buffer = SAFE_ALLOCA (len + 3);</span>
<span class='curline'><a href='../S/2119.html#L2343'>buffer</a>           2343 src/keymap.c   	  memcpy (buffer, sym, i);</span>
<span class='curline'><a href='../S/2119.html#L2344'>buffer</a>           2344 src/keymap.c   	  buffer[i] = '&lt;';</span>
<span class='curline'><a href='../S/2119.html#L2345'>buffer</a>           2345 src/keymap.c   	  memcpy (buffer + i + 1, sym + i, len - i);</span>
<span class='curline'><a href='../S/2119.html#L2346'>buffer</a>           2346 src/keymap.c   	  buffer [len + 1] = '&gt;';</span>
<span class='curline'><a href='../S/2119.html#L2347'>buffer</a>           2347 src/keymap.c   	  buffer [len + 2] = '\0';</span>
<span class='curline'><a href='../S/2119.html#L2348'>buffer</a>           2348 src/keymap.c   	  Lisp_Object result = build_string (buffer);</span>
<span class='curline'><a href='../S/2119.html#L2832'>buffer</a>           2832 src/keymap.c     (Lisp_Object buffer, Lisp_Object prefix, Lisp_Object menus)</span>
<span class='curline'><a href='../S/2119.html#L2842'>buffer</a>           2842 src/keymap.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2119.html#L2886'>buffer</a>           2886 src/keymap.c   	     msg, nomenu, Qt, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2119.html#L2900'>buffer</a>           2900 src/keymap.c   	     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2119.html#L2913'>buffer</a>           2913 src/keymap.c   	     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2119.html#L2923'>buffer</a>           2923 src/keymap.c         Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2119.html#L2928'>buffer</a>           2928 src/keymap.c         start1 = get_local_map (BUF_PT (XBUFFER (buffer)),</span>
<span class='curline'><a href='../S/2119.html#L2929'>buffer</a>           2929 src/keymap.c   			      XBUFFER (buffer), Qkeymap);</span>
<span class='curline'><a href='../S/2119.html#L2936'>buffer</a>           2936 src/keymap.c   		 msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2119.html#L2969'>buffer</a>           2969 src/keymap.c   		 msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2119.html#L2974'>buffer</a>           2974 src/keymap.c         start1 = get_local_map (BUF_PT (XBUFFER (buffer)),</span>
<span class='curline'><a href='../S/2119.html#L2975'>buffer</a>           2975 src/keymap.c   			      XBUFFER (buffer), Qlocal_map);</span>
<span class='curline'><a href='../S/2119.html#L2978'>buffer</a>           2978 src/keymap.c   	  if (EQ (start1, BVAR (XBUFFER (buffer), keymap)))</span>
<span class='curline'><a href='../S/2119.html#L2983'>buffer</a>           2983 src/keymap.c   		       XBUFFER (buffer)-&gt;major_mode_);</span>
<span class='curline'><a href='../S/2119.html#L2987'>buffer</a>           2987 src/keymap.c   		     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2119.html#L2995'>buffer</a>           2995 src/keymap.c   		     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2119.html#L3006'>buffer</a>           3006 src/keymap.c   	 msg, nomenu, Qnil, Qt, Qnil, buffer);</span>
<span class='curline'><a href='../S/2119.html#L3015'>buffer</a>           3015 src/keymap.c   	     msg, nomenu, Qt, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2119.html#L3025'>buffer</a>           3025 src/keymap.c   	     msg, nomenu, Qt, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/2119.html#L3315'>buffer</a>           3315 src/keymap.c   	      char *buffer =</span>
<span class='curline'><a href='../S/2119.html#L3317'>buffer</a>           3317 src/keymap.c   	      esprintf (buffer, fmt, SDATA (SYMBOL_NAME (shadowed_by)));</span>
<span class='curline'><a href='../S/2119.html#L3318'>buffer</a>           3318 src/keymap.c   	      insert_string (buffer);</span>
<span class='curline'><a href='../S/2159.html#L642'>buffer</a>            642 src/lisp.h     extern char *fixnum_to_string (EMACS_INT number, char *buffer, char *end);</span>
<span class='curline'><a href='../S/2159.html#L2566'>buffer</a>           2566 src/lisp.h       struct buffer *buffer;</span>
<span class='curline'><a href='../S/2159.html#L2606'>buffer</a>           2606 src/lisp.h         struct buffer *buffer;        /* eassert (live buffer || NULL). */</span>
<span class='curline'><a href='../S/2159.html#L4091'>buffer</a>           4091 src/lisp.h     extern void make_gap_1 (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/2159.html#L4106'>buffer</a>           4106 src/lisp.h     extern void insert_from_buffer (struct buffer *, ptrdiff_t, ptrdiff_t, bool);</span>
<span class='curline'><a href='../S/2159.html#L4124'>buffer</a>           4124 src/lisp.h     extern void invalidate_buffer_caches (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/2159.html#L4433'>buffer</a>           4433 src/lisp.h     extern struct buffer *allocate_buffer (void) ATTRIBUTE_RETURNS_NONNULL;</span>
<span class='curline'><a href='../S/2159.html#L4718'>buffer</a>           4718 src/lisp.h     extern void clear_charpos_cache (struct buffer *);</span>
<span class='curline'><a href='../S/2159.html#L4719'>buffer</a>           4719 src/lisp.h     extern ptrdiff_t buf_charpos_to_bytepos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/2159.html#L4720'>buffer</a>           4720 src/lisp.h     extern ptrdiff_t buf_bytepos_to_charpos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/2159.html#L4727'>buffer</a>           4727 src/lisp.h     extern Lisp_Object build_marker (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/2159.html#L4753'>buffer</a>           4753 src/lisp.h     extern Lisp_Object buffer_visited_file_modtime (struct buffer *);</span>
<span class='curline'><a href='../S/2159.html#L5017'>buffer</a>           5017 src/lisp.h     extern void truncate_undo_list (struct buffer *);</span>
<span class='curline'><a href='../S/2159.html#L5088'>buffer</a>           5088 src/lisp.h     extern void unlock_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/2145.html#L213'>buffer</a>            213 src/lread.c          register struct buffer *inbuffer = XBUFFER (readcharfun);</span>
<span class='curline'><a href='../S/2145.html#L246'>buffer</a>            246 src/lread.c          register struct buffer *inbuffer = XMARKER (readcharfun)-&gt;buffer;</span>
<span class='curline'><a href='../S/2145.html#L427'>buffer</a>            427 src/lread.c          struct buffer *b = XBUFFER (readcharfun);</span>
<span class='curline'><a href='../S/2145.html#L440'>buffer</a>            440 src/lread.c          struct buffer *b = XMARKER (readcharfun)-&gt;buffer;</span>
<span class='curline'><a href='../S/2145.html#L2190'>buffer</a>           2190 src/lread.c      struct buffer *b = 0;</span>
<span class='curline'><a href='../S/2145.html#L2218'>buffer</a>           2218 src/lread.c        b = XMARKER (readcharfun)-&gt;buffer;</span>
<span class='curline'><a href='../S/2145.html#L2326'>buffer</a>           2326 src/lread.c    		  struct buffer *buf = XBUFFER (readcharfun);</span>
<span class='curline'><a href='../S/2145.html#L2399'>buffer</a>           2399 src/lread.c      (Lisp_Object buffer, Lisp_Object printflag, Lisp_Object filename, Lisp_Object unibyte, Lisp_Object do_allow_print)</span>
<span class='curline'><a href='../S/2145.html#L2404'>buffer</a>           2404 src/lread.c      if (NILP (buffer))</span>
<span class='curline'><a href='../S/2145.html#L2407'>buffer</a>           2407 src/lread.c        buf = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/2145.html#L5419'>buffer</a>           5419 src/lread.c          char *buffer = SAFE_ALLOCA (sizeof format - 3 * (sizeof "%s" - 1)</span>
<span class='curline'><a href='../S/2145.html#L5421'>buffer</a>           5421 src/lread.c          ptrdiff_t message_len = esprintf (buffer, format, use, SSDATA (dirname),</span>
<span class='curline'><a href='../S/2145.html#L5423'>buffer</a>           5423 src/lread.c          message_dolog (buffer, message_len, 0, STRING_MULTIBYTE (dirname));</span>
<span class='curline'><a href='../S/2166.html#L32'>buffer</a>             32 src/marker.c   static struct buffer *cached_buffer;</span>
<span class='curline'><a href='../S/2166.html#L41'>buffer</a>             41 src/marker.c   extern int count_markers (struct buffer *) EXTERNALLY_VISIBLE;</span>
<span class='curline'><a href='../S/2166.html#L45'>buffer</a>             45 src/marker.c   byte_char_debug_check (struct buffer *b, ptrdiff_t charpos, ptrdiff_t bytepos)</span>
<span class='curline'><a href='../S/2166.html#L73'>buffer</a>             73 src/marker.c   clear_charpos_cache (struct buffer *b)</span>
<span class='curline'><a href='../S/2166.html#L161'>buffer</a>            161 src/marker.c   buf_charpos_to_bytepos (struct buffer *b, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/2166.html#L318'>buffer</a>            318 src/marker.c   buf_bytepos_to_charpos (struct buffer *b, ptrdiff_t bytepos)</span>
<span class='curline'><a href='../S/2166.html#L436'>buffer</a>            436 src/marker.c     if (XMARKER (marker)-&gt;buffer)</span>
<span class='curline'><a href='../S/2166.html#L438'>buffer</a>            438 src/marker.c         XSETBUFFER (buf, XMARKER (marker)-&gt;buffer);</span>
<span class='curline'><a href='../S/2166.html#L454'>buffer</a>            454 src/marker.c     if (XMARKER (marker)-&gt;buffer)</span>
<span class='curline'><a href='../S/2166.html#L463'>buffer</a>            463 src/marker.c   attach_marker (struct Lisp_Marker *m, struct buffer *b,</span>
<span class='curline'><a href='../S/2166.html#L476'>buffer</a>            476 src/marker.c     if (m-&gt;buffer != b)</span>
<span class='curline'><a href='../S/2166.html#L479'>buffer</a>            479 src/marker.c         m-&gt;buffer = b;</span>
<span class='curline'><a href='../S/2166.html#L489'>buffer</a>            489 src/marker.c   static struct buffer *</span>
<span class='curline'><a href='../S/2166.html#L490'>buffer</a>            490 src/marker.c   live_buffer (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2166.html#L492'>buffer</a>            492 src/marker.c     struct buffer *b = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/2166.html#L501'>buffer</a>            501 src/marker.c   		     Lisp_Object buffer, bool restricted)</span>
<span class='curline'><a href='../S/2166.html#L504'>buffer</a>            504 src/marker.c     struct buffer *b = live_buffer (buffer);</span>
<span class='curline'><a href='../S/2166.html#L512'>buffer</a>            512 src/marker.c         || (MARKERP (position) &amp;&amp; !XMARKER (position)-&gt;buffer)</span>
<span class='curline'><a href='../S/2166.html#L518'>buffer</a>            518 src/marker.c     else if (MARKERP (position) &amp;&amp; b == XMARKER (position)-&gt;buffer</span>
<span class='curline'><a href='../S/2166.html#L519'>buffer</a>            519 src/marker.c   	   &amp;&amp; b == m-&gt;buffer)</span>
<span class='curline'><a href='../S/2166.html#L560'>buffer</a>            560 src/marker.c   	  || !(MARKERP (position) &amp;&amp; XMARKER (position)-&gt;buffer == b))</span>
<span class='curline'><a href='../S/2166.html#L577'>buffer</a>            577 src/marker.c     (Lisp_Object marker, Lisp_Object position, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2166.html#L579'>buffer</a>            579 src/marker.c     return set_marker_internal (marker, position, buffer, false);</span>
<span class='curline'><a href='../S/2166.html#L586'>buffer</a>            586 src/marker.c   		       Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2166.html#L588'>buffer</a>            588 src/marker.c     return set_marker_internal (marker, position, buffer, true);</span>
<span class='curline'><a href='../S/2166.html#L595'>buffer</a>            595 src/marker.c   set_marker_both (Lisp_Object marker, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/2166.html#L599'>buffer</a>            599 src/marker.c     register struct buffer *b = live_buffer (buffer);</span>
<span class='curline'><a href='../S/2166.html#L614'>buffer</a>            614 src/marker.c   set_marker_restricted_both (Lisp_Object marker, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/2166.html#L618'>buffer</a>            618 src/marker.c     register struct buffer *b = live_buffer (buffer);</span>
<span class='curline'><a href='../S/2166.html#L651'>buffer</a>            651 src/marker.c     register struct buffer *b = marker-&gt;buffer;</span>
<span class='curline'><a href='../S/2166.html#L660'>buffer</a>            660 src/marker.c         marker-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2166.html#L672'>buffer</a>            672 src/marker.c   		if (tail-&gt;next &amp;&amp; b-&gt;text != tail-&gt;next-&gt;buffer-&gt;text)</span>
<span class='curline'><a href='../S/2166.html#L692'>buffer</a>            692 src/marker.c     register struct buffer *buf = m-&gt;buffer;</span>
<span class='curline'><a href='../S/2166.html#L708'>buffer</a>            708 src/marker.c     register struct buffer *buf = m-&gt;buffer;</span>
<span class='curline'><a href='../S/2166.html#L767'>buffer</a>            767 src/marker.c   count_markers (struct buffer *buf)</span>
<span class='curline'><a href='../S/2126.html#L388'>buffer</a>            388 src/minibuf.c  live_minibuffer_p (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2126.html#L393'>buffer</a>            393 src/minibuf.c    if (EQ (buffer, Fcar (Vminibuffer_list)))</span>
<span class='curline'><a href='../S/2126.html#L398'>buffer</a>            398 src/minibuf.c      if (EQ (Fcar (tem), buffer))</span>
<span class='curline'><a href='../S/2126.html#L409'>buffer</a>            409 src/minibuf.c    (Lisp_Object buffer, Lisp_Object live)</span>
<span class='curline'><a href='../S/2126.html#L411'>buffer</a>            411 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2126.html#L412'>buffer</a>            412 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2126.html#L413'>buffer</a>            413 src/minibuf.c    else if (STRINGP (buffer))</span>
<span class='curline'><a href='../S/2126.html#L414'>buffer</a>            414 src/minibuf.c      buffer = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/2126.html#L416'>buffer</a>            416 src/minibuf.c      CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2126.html#L419'>buffer</a>            419 src/minibuf.c            ? !NILP (Fmemq (buffer, Vminibuffer_list))</span>
<span class='curline'><a href='../S/2126.html#L420'>buffer</a>            420 src/minibuf.c            : live_minibuffer_p (buffer))</span>
<span class='curline'><a href='../S/2126.html#L428'>buffer</a>            428 src/minibuf.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2126.html#L430'>buffer</a>            430 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2126.html#L431'>buffer</a>            431 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2126.html#L432'>buffer</a>            432 src/minibuf.c    return BASE_EQ (buffer, (Fcar (Fnthcdr (make_fixnum (minibuf_level),</span>
<span class='curline'><a href='../S/2126.html#L442'>buffer</a>            442 src/minibuf.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2126.html#L445'>buffer</a>            445 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2126.html#L446'>buffer</a>            446 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2126.html#L447'>buffer</a>            447 src/minibuf.c    depth = this_minibuffer_depth (buffer);</span>
<span class='curline'><a href='../S/2126.html#L457'>buffer</a>            457 src/minibuf.c  this_minibuffer_depth (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2126.html#L462'>buffer</a>            462 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2126.html#L463'>buffer</a>            463 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2126.html#L467'>buffer</a>            467 src/minibuf.c      if (EQ (Fcar (bufs), buffer))</span>
<span class='curline'><a href='../S/2257.html#L1322'>buffer</a>           1322 src/msdos.c          struct buffer *b = XBUFFER (sw-&gt;contents);</span>
<span class='curline'><a href='../S/2257.html#L3899'>buffer</a>           3899 src/msdos.c    readlinkat (int fd, char const *name, char *buffer, size_t buffer_size)</span>
<span class='curline'><a href='../S/2257.html#L3916'>buffer</a>           3916 src/msdos.c      return readlink (name, buffer, buffer_size);</span>
<span class='curline'><a href='../S/2257.html#L3965'>buffer</a>           3965 src/msdos.c                  char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2257.html#L3969'>buffer</a>           3969 src/msdos.c      if (!buffer)</span>
<span class='curline'><a href='../S/2257.html#L3976'>buffer</a>           3976 src/msdos.c          buffer = NULL;</span>
<span class='curline'><a href='../S/2257.html#L3980'>buffer</a>           3980 src/msdos.c          ssize_t len = preadlinkat (fd, filename, buffer, buffer_size);</span>
<span class='curline'><a href='../S/2257.html#L3983'>buffer</a>           3983 src/msdos.c    	buffer = NULL;</span>
<span class='curline'><a href='../S/2257.html#L3985'>buffer</a>           3985 src/msdos.c    	buffer[len + 1] = '\0';</span>
<span class='curline'><a href='../S/2257.html#L3987'>buffer</a>           3987 src/msdos.c      return buffer;</span>
<span class='curline'><a href='../S/2158.html#L2123'>buffer</a>           2123 src/pdumper.c    if (marker-&gt;buffer)</span>
<span class='curline'><a href='../S/2158.html#L2125'>buffer</a>           2125 src/pdumper.c        dump_field_lv_rawptr (ctx, out, marker, &amp;marker-&gt;buffer,</span>
<span class='curline'><a href='../S/2158.html#L2748'>buffer</a>           2748 src/pdumper.c  dump_buffer (struct dump_context *ctx, const struct buffer *in_buffer)</span>
<span class='curline'><a href='../S/2158.html#L2753'>buffer</a>           2753 src/pdumper.c    struct buffer munged_buffer = *in_buffer;</span>
<span class='curline'><a href='../S/2158.html#L2754'>buffer</a>           2754 src/pdumper.c    struct buffer *buffer = &amp;munged_buffer;</span>
<span class='curline'><a href='../S/2158.html#L2757'>buffer</a>           2757 src/pdumper.c    if (buffer-&gt;base_buffer == NULL)</span>
<span class='curline'><a href='../S/2158.html#L2758'>buffer</a>           2758 src/pdumper.c      buffer-&gt;window_count = 0;</span>
<span class='curline'><a href='../S/2158.html#L2760'>buffer</a>           2760 src/pdumper.c      eassert (buffer-&gt;window_count == -1);</span>
<span class='curline'><a href='../S/2158.html#L2761'>buffer</a>           2761 src/pdumper.c    buffer-&gt;local_minor_modes_ = Qnil;</span>
<span class='curline'><a href='../S/2158.html#L2762'>buffer</a>           2762 src/pdumper.c    buffer-&gt;last_selected_window_ = Qnil;</span>
<span class='curline'><a href='../S/2158.html#L2763'>buffer</a>           2763 src/pdumper.c    buffer-&gt;display_count_ = make_fixnum (0);</span>
<span class='curline'><a href='../S/2158.html#L2764'>buffer</a>           2764 src/pdumper.c    buffer-&gt;clip_changed = 0;</span>
<span class='curline'><a href='../S/2158.html#L2765'>buffer</a>           2765 src/pdumper.c    buffer-&gt;last_window_start = -1;</span>
<span class='curline'><a href='../S/2158.html#L2766'>buffer</a>           2766 src/pdumper.c    buffer-&gt;point_before_scroll_ = Qnil;</span>
<span class='curline'><a href='../S/2158.html#L2769'>buffer</a>           2769 src/pdumper.c    if (buffer-&gt;base_buffer)</span>
<span class='curline'><a href='../S/2158.html#L2771'>buffer</a>           2771 src/pdumper.c        eassert (buffer-&gt;base_buffer-&gt;base_buffer == NULL);</span>
<span class='curline'><a href='../S/2158.html#L2774'>buffer</a>           2774 src/pdumper.c  	 make_lisp_ptr (buffer-&gt;base_buffer, Lisp_Vectorlike));</span>
<span class='curline'><a href='../S/2158.html#L2777'>buffer</a>           2777 src/pdumper.c    eassert ((base_offset == 0 &amp;&amp; buffer-&gt;text == &amp;in_buffer-&gt;own_text)</span>
<span class='curline'><a href='../S/2158.html#L2778'>buffer</a>           2778 src/pdumper.c  	   || (base_offset &gt; 0 &amp;&amp; buffer-&gt;text != &amp;in_buffer-&gt;own_text));</span>
<span class='curline'><a href='../S/2158.html#L2780'>buffer</a>           2780 src/pdumper.c    START_DUMP_PVEC (ctx, &amp;buffer-&gt;header, struct buffer, out);</span>
<span class='curline'><a href='../S/2158.html#L2781'>buffer</a>           2781 src/pdumper.c    dump_pseudovector_lisp_fields (ctx, &amp;out-&gt;header, &amp;buffer-&gt;header);</span>
<span class='curline'><a href='../S/2158.html#L2785'>buffer</a>           2785 src/pdumper.c    if (buffer-&gt;base_buffer == NULL)</span>
<span class='curline'><a href='../S/2158.html#L2789'>buffer</a>           2789 src/pdumper.c        if (BUFFER_LIVE_P (buffer))</span>
<span class='curline'><a href='../S/2158.html#L2791'>buffer</a>           2791 src/pdumper.c            dump_field_fixup_later (ctx, out, buffer, &amp;buffer-&gt;own_text.beg);</span>
<span class='curline'><a href='../S/2158.html#L2797'>buffer</a>           2797 src/pdumper.c          eassert (buffer-&gt;own_text.beg == NULL);</span>
<span class='curline'><a href='../S/2158.html#L2799'>buffer</a>           2799 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.gpt);</span>
<span class='curline'><a href='../S/2158.html#L2800'>buffer</a>           2800 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.z);</span>
<span class='curline'><a href='../S/2158.html#L2801'>buffer</a>           2801 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.gpt_byte);</span>
<span class='curline'><a href='../S/2158.html#L2802'>buffer</a>           2802 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.z_byte);</span>
<span class='curline'><a href='../S/2158.html#L2803'>buffer</a>           2803 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.gap_size);</span>
<span class='curline'><a href='../S/2158.html#L2804'>buffer</a>           2804 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.modiff);</span>
<span class='curline'><a href='../S/2158.html#L2805'>buffer</a>           2805 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.chars_modiff);</span>
<span class='curline'><a href='../S/2158.html#L2806'>buffer</a>           2806 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.save_modiff);</span>
<span class='curline'><a href='../S/2158.html#L2807'>buffer</a>           2807 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.overlay_modiff);</span>
<span class='curline'><a href='../S/2158.html#L2808'>buffer</a>           2808 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.compact);</span>
<span class='curline'><a href='../S/2158.html#L2809'>buffer</a>           2809 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.beg_unchanged);</span>
<span class='curline'><a href='../S/2158.html#L2810'>buffer</a>           2810 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.end_unchanged);</span>
<span class='curline'><a href='../S/2158.html#L2811'>buffer</a>           2811 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.unchanged_modified);</span>
<span class='curline'><a href='../S/2158.html#L2812'>buffer</a>           2812 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.overlay_unchanged_modified);</span>
<span class='curline'><a href='../S/2158.html#L2813'>buffer</a>           2813 src/pdumper.c        if (buffer-&gt;own_text.intervals)</span>
<span class='curline'><a href='../S/2158.html#L2814'>buffer</a>           2814 src/pdumper.c          dump_field_fixup_later (ctx, out, buffer, &amp;buffer-&gt;own_text.intervals);</span>
<span class='curline'><a href='../S/2158.html#L2815'>buffer</a>           2815 src/pdumper.c        dump_field_lv_rawptr (ctx, out, buffer, &amp;buffer-&gt;own_text.markers,</span>
<span class='curline'><a href='../S/2158.html#L2817'>buffer</a>           2817 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.inhibit_shrinking);</span>
<span class='curline'><a href='../S/2158.html#L2818'>buffer</a>           2818 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.redisplay);</span>
<span class='curline'><a href='../S/2158.html#L2824'>buffer</a>           2824 src/pdumper.c       ctx-&gt;obj_offset + dump_offsetof (struct buffer, text),</span>
<span class='curline'><a href='../S/2158.html#L2825'>buffer</a>           2825 src/pdumper.c       base_offset + dump_offsetof (struct buffer, own_text));</span>
<span class='curline'><a href='../S/2158.html#L2827'>buffer</a>           2827 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, pt);</span>
<span class='curline'><a href='../S/2158.html#L2828'>buffer</a>           2828 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, pt_byte);</span>
<span class='curline'><a href='../S/2158.html#L2829'>buffer</a>           2829 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, begv);</span>
<span class='curline'><a href='../S/2158.html#L2830'>buffer</a>           2830 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, begv_byte);</span>
<span class='curline'><a href='../S/2158.html#L2831'>buffer</a>           2831 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, zv);</span>
<span class='curline'><a href='../S/2158.html#L2832'>buffer</a>           2832 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, zv_byte);</span>
<span class='curline'><a href='../S/2158.html#L2834'>buffer</a>           2834 src/pdumper.c    if (buffer-&gt;base_buffer)</span>
<span class='curline'><a href='../S/2158.html#L2837'>buffer</a>           2837 src/pdumper.c        dump_field_ptr_to_dump_offset (ctx, out, buffer, &amp;buffer-&gt;base_buffer,</span>
<span class='curline'><a href='../S/2158.html#L2841'>buffer</a>           2841 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, indirections);</span>
<span class='curline'><a href='../S/2158.html#L2842'>buffer</a>           2842 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, window_count);</span>
<span class='curline'><a href='../S/2158.html#L2845'>buffer</a>           2845 src/pdumper.c            &amp;buffer-&gt;local_flags,</span>
<span class='curline'><a href='../S/2158.html#L2847'>buffer</a>           2847 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, modtime);</span>
<span class='curline'><a href='../S/2158.html#L2848'>buffer</a>           2848 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, modtime_size);</span>
<span class='curline'><a href='../S/2158.html#L2849'>buffer</a>           2849 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, auto_save_modified);</span>
<span class='curline'><a href='../S/2158.html#L2850'>buffer</a>           2850 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, display_error_modiff);</span>
<span class='curline'><a href='../S/2158.html#L2851'>buffer</a>           2851 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, auto_save_failure_time);</span>
<span class='curline'><a href='../S/2158.html#L2852'>buffer</a>           2852 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, last_window_start);</span>
<span class='curline'><a href='../S/2158.html#L2859'>buffer</a>           2859 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, prevent_redisplay_optimizations_p);</span>
<span class='curline'><a href='../S/2158.html#L2860'>buffer</a>           2860 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, clip_changed);</span>
<span class='curline'><a href='../S/2158.html#L2861'>buffer</a>           2861 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, inhibit_buffer_hooks);</span>
<span class='curline'><a href='../S/2158.html#L2862'>buffer</a>           2862 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, long_line_optimizations_p);</span>
<span class='curline'><a href='../S/2158.html#L2864'>buffer</a>           2864 src/pdumper.c    if (!itree_empty_p (buffer-&gt;overlays))</span>
<span class='curline'><a href='../S/2158.html#L2870'>buffer</a>           2870 src/pdumper.c    dump_field_lv (ctx, out, buffer, &amp;buffer-&gt;undo_list_,</span>
<span class='curline'><a href='../S/2158.html#L2873'>buffer</a>           2873 src/pdumper.c    if (!buffer-&gt;base_buffer &amp;&amp; buffer-&gt;own_text.intervals)</span>
<span class='curline'><a href='../S/2158.html#L2876'>buffer</a>           2876 src/pdumper.c         offset + dump_offsetof (struct buffer, own_text.intervals),</span>
<span class='curline'><a href='../S/2158.html#L2877'>buffer</a>           2877 src/pdumper.c         dump_interval_tree (ctx, buffer-&gt;own_text.intervals, 0));</span>
<span class='curline'><a href='../S/2158.html#L3427'>buffer</a>           3427 src/pdumper.c    struct buffer *b = XBUFFER (data);</span>
<span class='curline'><a href='../S/2158.html#L3441'>buffer</a>           3441 src/pdumper.c       buffer_offset + dump_offsetof (struct buffer, own_text.beg),</span>
<span class='curline'><a href='../S/2077.html#L3121'>buffer</a>           3121 src/pgtkfns.c    struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/2195.html#L259'>buffer</a>            259 src/pgtkmenu.c       struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2195.html#L260'>buffer</a>            260 src/pgtkmenu.c       Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2195.html#L272'>buffer</a>            272 src/pgtkmenu.c       buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/2195.html#L285'>buffer</a>            285 src/pgtkmenu.c       set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2084.html#L71'>buffer</a>             71 src/print.c      char *buffer;			/* Allocated buffer.  */</span>
<span class='curline'><a href='../S/2084.html#L103'>buffer</a>            103 src/print.c      xfree (print_buffer.buffer);</span>
<span class='curline'><a href='../S/2084.html#L104'>buffer</a>            104 src/print.c      print_buffer.buffer = NULL;</span>
<span class='curline'><a href='../S/2084.html#L112'>buffer</a>            112 src/print.c      memcpy (print_buffer.buffer, SDATA (saved_text), SCHARS (saved_text));</span>
<span class='curline'><a href='../S/2084.html#L154'>buffer</a>            154 src/print.c          if (! XMARKER (printcharfun)-&gt;buffer)</span>
<span class='curline'><a href='../S/2084.html#L156'>buffer</a>            156 src/print.c          if (XMARKER (printcharfun)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/2084.html#L157'>buffer</a>            157 src/print.c    	set_buffer_internal (XMARKER (printcharfun)-&gt;buffer);</span>
<span class='curline'><a href='../S/2084.html#L177'>buffer</a>            177 src/print.c          if (print_buffer.buffer != NULL)</span>
<span class='curline'><a href='../S/2084.html#L179'>buffer</a>            179 src/print.c    	  Lisp_Object string = make_string_from_bytes (print_buffer.buffer,</span>
<span class='curline'><a href='../S/2084.html#L187'>buffer</a>            187 src/print.c    	  print_buffer.buffer = xmalloc (new_size);</span>
<span class='curline'><a href='../S/2084.html#L210'>buffer</a>            210 src/print.c    	  copy_text ((unsigned char *) print_buffer.buffer, temp,</span>
<span class='curline'><a href='../S/2084.html#L217'>buffer</a>            217 src/print.c    	insert_1_both (print_buffer.buffer, print_buffer.pos,</span>
<span class='curline'><a href='../S/2084.html#L320'>buffer</a>            320 src/print.c    	    print_buffer.buffer = xpalloc (print_buffer.buffer,</span>
<span class='curline'><a href='../S/2084.html#L323'>buffer</a>            323 src/print.c    	  memcpy (print_buffer.buffer + print_buffer.pos_byte, str, len);</span>
<span class='curline'><a href='../S/2084.html#L386'>buffer</a>            386 src/print.c    	print_buffer.buffer = xpalloc (print_buffer.buffer,</span>
<span class='curline'><a href='../S/2084.html#L388'>buffer</a>            388 src/print.c          memcpy (print_buffer.buffer + print_buffer.pos_byte, ptr, size_byte);</span>
<span class='curline'><a href='../S/2084.html#L513'>buffer</a>            513 src/print.c    	  char *buffer = SAFE_ALLOCA (nbytes);</span>
<span class='curline'><a href='../S/2084.html#L514'>buffer</a>            514 src/print.c    	  memcpy (buffer, SDATA (string), nbytes);</span>
<span class='curline'><a href='../S/2084.html#L516'>buffer</a>            516 src/print.c    	  strout (buffer, chars, nbytes, printcharfun);</span>
<span class='curline'><a href='../S/2084.html#L587'>buffer</a>            587 src/print.c      register struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2084.html#L818'>buffer</a>            818 src/print.c      struct buffer *previous = current_buffer;</span>
<span class='curline'><a href='../S/2084.html#L1027'>buffer</a>           1027 src/print.c      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2084.html#L1713'>buffer</a>           1713 src/print.c          if (! XMARKER (obj)-&gt;buffer)</span>
<span class='curline'><a href='../S/2084.html#L1719'>buffer</a>           1719 src/print.c    	  print_string (BVAR (XMARKER (obj)-&gt;buffer, name), printcharfun);</span>
<span class='curline'><a href='../S/2084.html#L1811'>buffer</a>           1811 src/print.c    	if (NILP (XXWIDGET (obj)-&gt;buffer))</span>
<span class='curline'><a href='../S/2129.html#L344'>buffer</a>            344 src/process.c    p-&gt;buffer = val;</span>
<span class='curline'><a href='../S/2129.html#L1275'>buffer</a>           1275 src/process.c    Lisp_Object buffer = p-&gt;buffer;</span>
<span class='curline'><a href='../S/2129.html#L1276'>buffer</a>           1276 src/process.c    if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/2129.html#L1277'>buffer</a>           1277 src/process.c      set_marker_both (p-&gt;mark, buffer,</span>
<span class='curline'><a href='../S/2129.html#L1278'>buffer</a>           1278 src/process.c  		     BUF_ZV (XBUFFER (buffer)),</span>
<span class='curline'><a href='../S/2129.html#L1279'>buffer</a>           1279 src/process.c  		     BUF_ZV_BYTE (XBUFFER (buffer)));</span>
<span class='curline'><a href='../S/2129.html#L1286'>buffer</a>           1286 src/process.c    (register Lisp_Object process, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2129.html#L1291'>buffer</a>           1291 src/process.c    if (!NILP (buffer))</span>
<span class='curline'><a href='../S/2129.html#L1292'>buffer</a>           1292 src/process.c      CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2129.html#L1294'>buffer</a>           1294 src/process.c    if (!EQ (p-&gt;buffer, buffer))</span>
<span class='curline'><a href='../S/2129.html#L1296'>buffer</a>           1296 src/process.c        pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/2129.html#L1300'>buffer</a>           1300 src/process.c      pset_childp (p, plist_put (p-&gt;childp, QCbuffer, buffer));</span>
<span class='curline'><a href='../S/2129.html#L1302'>buffer</a>           1302 src/process.c    return buffer;</span>
<span class='curline'><a href='../S/2129.html#L1312'>buffer</a>           1312 src/process.c    return XPROCESS (process)-&gt;buffer;</span>
<span class='curline'><a href='../S/2129.html#L1798'>buffer</a>           1798 src/process.c    Lisp_Object buffer, name, command, program, proc, contact, current_dir, tem;</span>
<span class='curline'><a href='../S/2129.html#L1817'>buffer</a>           1817 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/2129.html#L1818'>buffer</a>           1818 src/process.c    if (!NILP (buffer))</span>
<span class='curline'><a href='../S/2129.html#L1819'>buffer</a>           1819 src/process.c      buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/2129.html#L1867'>buffer</a>           1867 src/process.c    pset_buffer (XPROCESS (proc), buffer);</span>
<span class='curline'><a href='../S/2129.html#L1936'>buffer</a>           1936 src/process.c  	args2[i++] = buffer;</span>
<span class='curline'><a href='../S/2129.html#L1966'>buffer</a>           1966 src/process.c  	    args2[i++] = buffer;</span>
<span class='curline'><a href='../S/2129.html#L1991'>buffer</a>           1991 src/process.c      = !(NILP (buffer) || !inherit_process_coding_system);</span>
<span class='curline'><a href='../S/2129.html#L2405'>buffer</a>           2405 src/process.c    Lisp_Object name, buffer;</span>
<span class='curline'><a href='../S/2129.html#L2446'>buffer</a>           2446 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/2129.html#L2447'>buffer</a>           2447 src/process.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2129.html#L2448'>buffer</a>           2448 src/process.c      buffer = name;</span>
<span class='curline'><a href='../S/2129.html#L2449'>buffer</a>           2449 src/process.c    buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/2129.html#L2450'>buffer</a>           2450 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/2129.html#L2491'>buffer</a>           2491 src/process.c      else if ((!NILP (buffer) &amp;&amp; NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/2129.html#L2492'>buffer</a>           2492 src/process.c  	     || (NILP (buffer) &amp;&amp; NILP (BVAR (&amp;buffer_defaults, enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/2129.html#L3143'>buffer</a>           3143 src/process.c    Lisp_Object name, buffer;</span>
<span class='curline'><a href='../S/2129.html#L3181'>buffer</a>           3181 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/2129.html#L3182'>buffer</a>           3182 src/process.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2129.html#L3183'>buffer</a>           3183 src/process.c      buffer = name;</span>
<span class='curline'><a href='../S/2129.html#L3184'>buffer</a>           3184 src/process.c    buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/2129.html#L3185'>buffer</a>           3185 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/2129.html#L3216'>buffer</a>           3216 src/process.c    else if ((!NILP (buffer) &amp;&amp; NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/2129.html#L3217'>buffer</a>           3217 src/process.c  	   || (NILP (buffer) &amp;&amp; NILP (BVAR (&amp;buffer_defaults, enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/2129.html#L3230'>buffer</a>           3230 src/process.c    else if ((!NILP (buffer) &amp;&amp; NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/2129.html#L3231'>buffer</a>           3231 src/process.c  	   || (NILP (buffer) &amp;&amp; NILP (BVAR (&amp;buffer_defaults, enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/2129.html#L3240'>buffer</a>           3240 src/process.c      = !(!NILP (tem) || NILP (buffer) || !inherit_process_coding_system);</span>
<span class='curline'><a href='../S/2129.html#L3272'>buffer</a>           3272 src/process.c    else if ((!NILP (p-&gt;buffer)</span>
<span class='curline'><a href='../S/2129.html#L3273'>buffer</a>           3273 src/process.c  	    &amp;&amp; NILP (BVAR (XBUFFER (p-&gt;buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/2129.html#L3274'>buffer</a>           3274 src/process.c  	   || (NILP (p-&gt;buffer)</span>
<span class='curline'><a href='../S/2129.html#L3287'>buffer</a>           3287 src/process.c  				Qopen_network_stream, name, p-&gt;buffer,</span>
<span class='curline'><a href='../S/2129.html#L3316'>buffer</a>           3316 src/process.c  				    Qopen_network_stream, name, p-&gt;buffer,</span>
<span class='curline'><a href='../S/2129.html#L3333'>buffer</a>           3333 src/process.c      = !(!NILP (tem) || NILP (p-&gt;buffer) || !inherit_process_coding_system);</span>
<span class='curline'><a href='../S/2129.html#L3935'>buffer</a>           3935 src/process.c    Lisp_Object name, buffer, host, service, address;</span>
<span class='curline'><a href='../S/2129.html#L3973'>buffer</a>           3973 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/2129.html#L4212'>buffer</a>           4212 src/process.c    if (!NILP (buffer))</span>
<span class='curline'><a href='../S/2129.html#L4213'>buffer</a>           4213 src/process.c      buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/2129.html#L4225'>buffer</a>           4225 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/2129.html#L4906'>buffer</a>           4906 src/process.c    Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2129.html#L4998'>buffer</a>           4998 src/process.c      buffer = Qnil;</span>
<span class='curline'><a href='../S/2129.html#L5001'>buffer</a>           5001 src/process.c        buffer = ps-&gt;buffer;</span>
<span class='curline'><a href='../S/2129.html#L5002'>buffer</a>           5002 src/process.c        if (!NILP (buffer))</span>
<span class='curline'><a href='../S/2129.html#L5003'>buffer</a>           5003 src/process.c  	buffer = Fbuffer_name (buffer);</span>
<span class='curline'><a href='../S/2129.html#L5005'>buffer</a>           5005 src/process.c  	buffer = ps-&gt;name;</span>
<span class='curline'><a href='../S/2129.html#L5006'>buffer</a>           5006 src/process.c        if (!NILP (buffer))</span>
<span class='curline'><a href='../S/2129.html#L5008'>buffer</a>           5008 src/process.c  	  args[1] = buffer;</span>
<span class='curline'><a href='../S/2129.html#L5009'>buffer</a>           5009 src/process.c  	  buffer = Fget_buffer_create (Fformat (nargs, args), Qnil);</span>
<span class='curline'><a href='../S/2129.html#L5046'>buffer</a>           5046 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/2129.html#L5080'>buffer</a>           5080 src/process.c      = (NILP (buffer) ? 0 : ps-&gt;inherit_coding_system_flag);</span>
<span class='curline'><a href='../S/2129.html#L6322'>buffer</a>           6322 src/process.c    if (!NILP (p-&gt;buffer) &amp;&amp; BUFFER_LIVE_P (XBUFFER (p-&gt;buffer)))</span>
<span class='curline'><a href='../S/2129.html#L6328'>buffer</a>           6328 src/process.c        struct buffer *b;</span>
<span class='curline'><a href='../S/2129.html#L6330'>buffer</a>           6330 src/process.c        Fset_buffer (p-&gt;buffer);</span>
<span class='curline'><a href='../S/2129.html#L6341'>buffer</a>           6341 src/process.c        if (XMARKER (p-&gt;mark)-&gt;buffer)</span>
<span class='curline'><a href='../S/2129.html#L6367'>buffer</a>           6367 src/process.c        if (BUFFERP (p-&gt;buffer)</span>
<span class='curline'><a href='../S/2129.html#L6368'>buffer</a>           6368 src/process.c  	  &amp;&amp; (b = XBUFFER (p-&gt;buffer), b != current_buffer))</span>
<span class='curline'><a href='../S/2129.html#L6369'>buffer</a>           6369 src/process.c  	set_marker_both (p-&gt;mark, p-&gt;buffer, BUF_PT (b), BUF_PT_BYTE (b));</span>
<span class='curline'><a href='../S/2129.html#L6371'>buffer</a>           6371 src/process.c  	set_marker_both (p-&gt;mark, p-&gt;buffer, PT, PT_BYTE);</span>
<span class='curline'><a href='../S/2129.html#L6558'>buffer</a>           6558 src/process.c  	  struct buffer *cur = current_buffer;</span>
<span class='curline'><a href='../S/2129.html#L7667'>buffer</a>           7667 src/process.c  	  if (BUFFERP (p-&gt;buffer))</span>
<span class='curline'><a href='../S/2129.html#L7669'>buffer</a>           7669 src/process.c  	    bset_update_mode_line (XBUFFER (p-&gt;buffer));</span>
<span class='curline'><a href='../S/2129.html#L7682'>buffer</a>           7682 src/process.c    Lisp_Object buffer, symbol;</span>
<span class='curline'><a href='../S/2129.html#L7686'>buffer</a>           7686 src/process.c    buffer = p-&gt;buffer;</span>
<span class='curline'><a href='../S/2129.html#L7691'>buffer</a>           7691 src/process.c    if (!EQ (symbol, Qrun) &amp;&amp; !NILP (buffer))</span>
<span class='curline'><a href='../S/2129.html#L7694'>buffer</a>           7694 src/process.c        struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2129.html#L7700'>buffer</a>           7700 src/process.c        if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/2129.html#L7702'>buffer</a>           7702 src/process.c        Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2129.html#L7713'>buffer</a>           7713 src/process.c        if (XMARKER (p-&gt;mark)-&gt;buffer)</span>
<span class='curline'><a href='../S/2129.html#L7729'>buffer</a>           7729 src/process.c        set_marker_both (p-&gt;mark, p-&gt;buffer, PT, PT_BYTE);</span>
<span class='curline'><a href='../S/2129.html#L8125'>buffer</a>           8125 src/process.c        &amp;&amp; BUFFERP (p-&gt;buffer))</span>
<span class='curline'><a href='../S/2129.html#L8127'>buffer</a>           8127 src/process.c        if (NILP (BVAR (XBUFFER (p-&gt;buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/2129.html#L8145'>buffer</a>           8145 src/process.c    (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2129.html#L8150'>buffer</a>           8150 src/process.c    if (NILP (buffer)) return Qnil;</span>
<span class='curline'><a href='../S/2129.html#L8151'>buffer</a>           8151 src/process.c    buf = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/2129.html#L8155'>buffer</a>           8155 src/process.c      if (EQ (XPROCESS (proc)-&gt;buffer, buf))</span>
<span class='curline'><a href='../S/2129.html#L8184'>buffer</a>           8184 src/process.c  kill_buffer_processes (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2129.html#L8190'>buffer</a>           8190 src/process.c      if (NILP (buffer) || EQ (XPROCESS (proc)-&gt;buffer, buffer))</span>
<span class='curline'><a href='../S/2211.html#L68'>buffer</a>             68 src/process.h      Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2136.html#L740'>buffer</a>            740 src/regex-emacs.c   re_char *buffer = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2136.html#L742'>buffer</a>            742 src/regex-emacs.c   print_partial_compiled_pattern (buffer, buffer + bufp-&gt;used);</span>
<span class='curline'><a href='../S/2136.html#L1038'>buffer</a>           1038 src/regex-emacs.c       eassert (FAILURE_PAT (failure) &gt;= bufp-&gt;buffer			\</span>
<span class='curline'><a href='../S/2136.html#L1039'>buffer</a>           1039 src/regex-emacs.c 	       &amp;&amp; FAILURE_PAT (failure) &lt;= bufp-&gt;buffer + bufp-&gt;used);	\</span>
<span class='curline'><a href='../S/2136.html#L1186'>buffer</a>           1186 src/regex-emacs.c     if (bufp-&gt;buffer + bufp-&gt;allocated - b &lt; (n))			\</span>
<span class='curline'><a href='../S/2136.html#L1187'>buffer</a>           1187 src/regex-emacs.c       EXTEND_BUFFER ((n) - (bufp-&gt;buffer + bufp-&gt;allocated - b))</span>
<span class='curline'><a href='../S/2136.html#L1236'>buffer</a>           1236 src/regex-emacs.c     unsigned char *old_buffer = bufp-&gt;buffer;				\</span>
<span class='curline'><a href='../S/2136.html#L1246'>buffer</a>           1246 src/regex-emacs.c     bufp-&gt;buffer = xpalloc (bufp-&gt;buffer, &amp;bufp-&gt;allocated,		\</span>
<span class='curline'><a href='../S/2136.html#L1248'>buffer</a>           1248 src/regex-emacs.c     unsigned char *new_buffer = bufp-&gt;buffer;				\</span>
<span class='curline'><a href='../S/2136.html#L1786'>buffer</a>           1786 src/regex-emacs.c       bufp-&gt;buffer = xrealloc (bufp-&gt;buffer, INIT_BUF_SIZE);</span>
<span class='curline'><a href='../S/2136.html#L1790'>buffer</a>           1790 src/regex-emacs.c   begalt = b = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2136.html#L2251'>buffer</a>           2251 src/regex-emacs.c 		COMPILE_STACK_TOP.begalt_offset = begalt - bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2136.html#L2253'>buffer</a>           2253 src/regex-emacs.c 		  = fixup_alt_jump ? fixup_alt_jump - bufp-&gt;buffer + 1 : 0;</span>
<span class='curline'><a href='../S/2136.html#L2254'>buffer</a>           2254 src/regex-emacs.c 		COMPILE_STACK_TOP.laststart_offset = b - bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2136.html#L2294'>buffer</a>           2294 src/regex-emacs.c 		begalt = bufp-&gt;buffer + COMPILE_STACK_TOP.begalt_offset;</span>
<span class='curline'><a href='../S/2136.html#L2297'>buffer</a>           2297 src/regex-emacs.c 		    ? bufp-&gt;buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1</span>
<span class='curline'><a href='../S/2136.html#L2299'>buffer</a>           2299 src/regex-emacs.c 		laststart = bufp-&gt;buffer + COMPILE_STACK_TOP.laststart_offset;</span>
<span class='curline'><a href='../S/2136.html#L2666'>buffer</a>           2666 src/regex-emacs.c   bufp-&gt;used = b - bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2136.html#L3127'>buffer</a>           3127 src/regex-emacs.c   eassert (fastmap &amp;&amp; bufp-&gt;buffer);</span>
<span class='curline'><a href='../S/2136.html#L3134'>buffer</a>           3134 src/regex-emacs.c   analysis = analyze_first (bufp-&gt;buffer, bufp-&gt;buffer + bufp-&gt;used,</span>
<span class='curline'><a href='../S/2136.html#L3240'>buffer</a>           3240 src/regex-emacs.c   if (bufp-&gt;used &gt; 0 &amp;&amp; (re_opcode_t) bufp-&gt;buffer[0] == begbuf &amp;&amp; range &gt; 0)</span>
<span class='curline'><a href='../S/2136.html#L3250'>buffer</a>           3250 src/regex-emacs.c   if (bufp-&gt;used &gt; 0 &amp;&amp; (re_opcode_t) bufp-&gt;buffer[0] == at_dot &amp;&amp; range &gt; 0)</span>
<span class='curline'><a href='../S/2136.html#L3262'>buffer</a>           3262 src/regex-emacs.c   anchored_start = (bufp-&gt;buffer[0] == begline);</span>
<span class='curline'><a href='../S/2136.html#L3653'>buffer</a>           3653 src/regex-emacs.c   unsigned char *pend = bufp-&gt;buffer + bufp-&gt;used;</span>
<span class='curline'><a href='../S/2136.html#L3656'>buffer</a>           3656 src/regex-emacs.c   eassert (p1 &gt;= bufp-&gt;buffer &amp;&amp; p1 &lt; pend</span>
<span class='curline'><a href='../S/2136.html#L3657'>buffer</a>           3657 src/regex-emacs.c 	   &amp;&amp; p2 &gt;= bufp-&gt;buffer &amp;&amp; p2 &lt;= pend);</span>
<span class='curline'><a href='../S/2136.html#L3668'>buffer</a>           3668 src/regex-emacs.c   eassert (p1 &gt;= bufp-&gt;buffer &amp;&amp; p1 &lt; pend</span>
<span class='curline'><a href='../S/2136.html#L3669'>buffer</a>           3669 src/regex-emacs.c 	   &amp;&amp; p2 &gt;= bufp-&gt;buffer &amp;&amp; p2 &lt;= pend);</span>
<span class='curline'><a href='../S/2136.html#L3883'>buffer</a>           3883 src/regex-emacs.c   struct buffer *b = (struct buffer *) ptr;</span>
<span class='curline'><a href='../S/2136.html#L3919'>buffer</a>           3919 src/regex-emacs.c   re_char *p = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2136.html#L5092'>buffer</a>           5092 src/regex-emacs.c 	  eassert (p &gt;= bufp-&gt;buffer &amp;&amp; p &lt;= pend);</span>
<span class='curline'><a href='../S/2068.html#L69'>buffer</a>             69 src/regex-emacs.h   unsigned char *buffer;</span>
<span class='curline'><a href='../S/2068.html#L131'>buffer</a>            131 src/regex-emacs.h 				       struct re_pattern_buffer *buffer);</span>
<span class='curline'><a href='../S/2068.html#L139'>buffer</a>            139 src/regex-emacs.h extern ptrdiff_t re_search (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/2068.html#L147'>buffer</a>            147 src/regex-emacs.h extern ptrdiff_t re_search_2 (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/2068.html#L157'>buffer</a>            157 src/regex-emacs.h extern ptrdiff_t re_match_2 (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/2068.html#L176'>buffer</a>            176 src/regex-emacs.h extern void re_set_registers (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/2146.html#L125'>buffer</a>            125 src/region-cache.c static void revalidate_region_cache (struct buffer *buf, struct region_cache *c);</span>
<span class='curline'><a href='../S/2146.html#L458'>buffer</a>            458 src/region-cache.c invalidate_region_cache (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/2146.html#L537'>buffer</a>            537 src/region-cache.c revalidate_region_cache (struct buffer *buf, struct region_cache *c)</span>
<span class='curline'><a href='../S/2146.html#L665'>buffer</a>            665 src/region-cache.c know_region_cache (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/2146.html#L681'>buffer</a>            681 src/region-cache.c region_cache_forward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/2146.html#L719'>buffer</a>            719 src/region-cache.c region_cache_backward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/1997.html#L65'>buffer</a>             65 src/region-cache.h struct buffer;</span>
<span class='curline'><a href='../S/1997.html#L76'>buffer</a>             76 src/region-cache.h extern void know_region_cache (struct buffer *BUF,</span>
<span class='curline'><a href='../S/1997.html#L88'>buffer</a>             88 src/region-cache.h extern void invalidate_region_cache (struct buffer *BUF,</span>
<span class='curline'><a href='../S/1997.html#L105'>buffer</a>            105 src/region-cache.h extern int region_cache_forward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/1997.html#L109'>buffer</a>            109 src/region-cache.h extern int region_cache_backward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/2233.html#L147'>buffer</a>            147 src/search.c           cp-&gt;buf.buffer = xrealloc (cp-&gt;buf.buffer, cp-&gt;buf.used);</span>
<span class='curline'><a href='../S/2233.html#L598'>buffer</a>            598 src/search.c   newline_cache_on_off (struct buffer *buf)</span>
<span class='curline'><a href='../S/2233.html#L600'>buffer</a>            600 src/search.c     struct buffer *base_buf = buf;</span>
<span class='curline'><a href='../S/2233.html#L676'>buffer</a>            676 src/search.c     struct buffer *cache_buffer;</span>
<span class='curline'><a href='../S/2233.html#L3026'>buffer</a>           3026 src/search.c   		if (XMARKER (marker)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/2233.html#L3029'>buffer</a>           3029 src/search.c   		  XSETBUFFER (last_thing_searched, XMARKER (marker)-&gt;buffer);</span>
<span class='curline'><a href='../S/2233.html#L3046'>buffer</a>           3046 src/search.c   	    if (MARKERP (marker) &amp;&amp; XMARKER (marker)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/2233.html#L3303'>buffer</a>           3303 src/search.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2233.html#L3305'>buffer</a>           3305 src/search.c     struct buffer *buf, *old = NULL;</span>
<span class='curline'><a href='../S/2233.html#L3310'>buffer</a>           3310 src/search.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2233.html#L3314'>buffer</a>           3314 src/search.c         CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2233.html#L3315'>buffer</a>           3315 src/search.c         buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2233.html#L3465'>buffer</a>           3465 src/search.c         searchbufs[i].buf.buffer = xmalloc (100);</span>
<span class='curline'><a href='../S/2200.html#L223'>buffer</a>            223 src/sound.c      void (* write) (struct sound_device *sd, const char *buffer,</span>
<span class='curline'><a href='../S/2200.html#L571'>buffer</a>            571 src/sound.c          char *buffer = SAFE_ALLOCA (blksize);</span>
<span class='curline'><a href='../S/2200.html#L574'>buffer</a>            574 src/sound.c                 &amp;&amp; (nbytes = emacs_read (s-&gt;fd, buffer, blksize)) &gt; 0)</span>
<span class='curline'><a href='../S/2200.html#L579'>buffer</a>            579 src/sound.c              sd-&gt;write (sd, buffer, nbytes);</span>
<span class='curline'><a href='../S/2200.html#L666'>buffer</a>            666 src/sound.c          char *buffer = SAFE_ALLOCA (blksize);</span>
<span class='curline'><a href='../S/2200.html#L667'>buffer</a>            667 src/sound.c          while ((nbytes = emacs_read (s-&gt;fd, buffer, blksize)) &gt; 0)</span>
<span class='curline'><a href='../S/2200.html#L668'>buffer</a>            668 src/sound.c    	sd-&gt;write (sd, buffer, nbytes);</span>
<span class='curline'><a href='../S/2200.html#L868'>buffer</a>            868 src/sound.c    vox_write (struct sound_device *sd, const char *buffer, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/2200.html#L870'>buffer</a>            870 src/sound.c      if (emacs_write_sig (sd-&gt;fd, buffer, nbytes) != nbytes)</span>
<span class='curline'><a href='../S/2200.html#L1126'>buffer</a>           1126 src/sound.c    alsa_write (struct sound_device *sd, const char *buffer, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/2200.html#L1140'>buffer</a>           1140 src/sound.c          err = snd_pcm_writei (p-&gt;handle, buffer + nwritten, frames);</span>
<span class='curline'><a href='../S/2202.html#L176'>buffer</a>            176 src/syntax.c   static struct buffer *find_start_buffer;</span>
<span class='curline'><a href='../S/2202.html#L193'>buffer</a>            193 src/syntax.c   bset_syntax_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/2202.html#L278'>buffer</a>            278 src/syntax.c         struct buffer *buf = XBUFFER (gl_state.object);</span>
<span class='curline'><a href='../S/2178.html#L2285'>buffer</a>           2285 src/sysdep.c     void *buffer;</span>
<span class='curline'><a href='../S/2178.html#L2290'>buffer</a>           2290 src/sysdep.c         buffer = thread_backtrace_buffer;</span>
<span class='curline'><a href='../S/2178.html#L2295'>buffer</a>           2295 src/sysdep.c         buffer = main_backtrace_buffer;</span>
<span class='curline'><a href='../S/2178.html#L2300'>buffer</a>           2300 src/sysdep.c   	  backtrace (buffer, 1);</span>
<span class='curline'><a href='../S/2178.html#L2304'>buffer</a>           2304 src/sysdep.c         npointers = backtrace (buffer, bounded_limit + 1);</span>
<span class='curline'><a href='../S/2178.html#L2310'>buffer</a>           2310 src/sysdep.c         backtrace_symbols_fd (buffer, npointers, STDERR_FILENO);</span>
<span class='curline'><a href='../S/2108.html#L3448'>buffer</a>           3448 src/term.c       struct buffer *buffer;</span>
<span class='curline'><a href='../S/2108.html#L3458'>buffer</a>           3458 src/term.c       set_buffer_internal (data-&gt;buffer);</span>
<span class='curline'><a href='../S/2001.html#L56'>buffer</a>             56 src/textconv.c 	     char *buffer)</span>
<span class='curline'><a href='../S/2001.html#L78'>buffer</a>             78 src/textconv.c   memcpy (buffer, BYTE_POS_ADDR (beg0), size);</span>
<span class='curline'><a href='../S/2001.html#L80'>buffer</a>             80 src/textconv.c     memcpy (buffer, BEG_ADDR + beg1, end1 - beg1);</span>
<span class='curline'><a href='../S/2001.html#L106'>buffer</a>            106 src/textconv.c   char *buffer;</span>
<span class='curline'><a href='../S/2001.html#L263'>buffer</a>            263 src/textconv.c   buffer = xmalloc (end_byte - pos_byte);</span>
<span class='curline'><a href='../S/2001.html#L264'>buffer</a>            264 src/textconv.c   copy_buffer (pos, pos_byte, end, end_byte, buffer);</span>
<span class='curline'><a href='../S/2001.html#L265'>buffer</a>            265 src/textconv.c   query-&gt;text.text = buffer;</span>
<span class='curline'><a href='../S/2165.html#L78'>buffer</a>             78 src/textprop.c modify_text_properties (Lisp_Object buffer, Lisp_Object start, Lisp_Object end)</span>
<span class='curline'><a href='../S/2165.html#L81'>buffer</a>             81 src/textprop.c   struct buffer *buf = XBUFFER (buffer), *old = current_buffer;</span>
<span class='curline'><a href='../S/2165.html#L154'>buffer</a>            154 src/textprop.c       register struct buffer *b = XBUFFER (object);</span>
<span class='curline'><a href='../S/2165.html#L537'>buffer</a>            537 src/textprop.c       register struct buffer *b = XBUFFER (object);</span>
<span class='curline'><a href='../S/2165.html#L636'>buffer</a>            636 src/textprop.c       struct buffer *b = XBUFFER (object);</span>
<span class='curline'><a href='../S/2165.html#L1901'>buffer</a>           1901 src/textprop.c text_property_stickiness (Lisp_Object prop, Lisp_Object pos, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2165.html#L1909'>buffer</a>           1909 src/textprop.c   if (NILP (buffer))</span>
<span class='curline'><a href='../S/2165.html#L1910'>buffer</a>           1910 src/textprop.c     XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/2165.html#L1912'>buffer</a>           1912 src/textprop.c   ignore_previous_character = XFIXNUM (pos) &lt;= BUF_BEGV (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2165.html#L1919'>buffer</a>           1919 src/textprop.c 	= Fget_text_property (prev_pos, Qrear_nonsticky, buffer);</span>
<span class='curline'><a href='../S/2165.html#L1931'>buffer</a>           1931 src/textprop.c   front_sticky = Fget_text_property (pos, Qfront_sticky, buffer);</span>
<span class='curline'><a href='../S/2165.html#L1952'>buffer</a>           1952 src/textprop.c       || NILP (Fget_text_property (prev_pos, prop, buffer)))</span>
<span class='curline'><a href='../S/2165.html#L2184'>buffer</a>           2184 src/textprop.c verify_interval_modification (struct buffer *buf,</span>
<span class='curline'><a href='../S/2021.html#L1095'>buffer</a>           1095 src/thread.c   thread_check_current_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/2021.html#L1104'>buffer</a>           1104 src/thread.c         if (iter-&gt;m_current_buffer == buffer)</span>
<span class='curline'><a href='../S/2240.html#L132'>buffer</a>            132 src/thread.h     struct buffer *m_current_buffer;</span>
<span class='curline'><a href='../S/2240.html#L327'>buffer</a>            327 src/thread.h   bool thread_check_current_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/2169.html#L1342'>buffer</a>           1342 src/timefns.c    char buffer[4000];</span>
<span class='curline'><a href='../S/2169.html#L1343'>buffer</a>           1343 src/timefns.c    char *buf = buffer;</span>
<span class='curline'><a href='../S/2169.html#L1344'>buffer</a>           1344 src/timefns.c    ptrdiff_t size = sizeof buffer;</span>
<span class='curline'><a href='../S/2187.html#L792'>buffer</a>            792 src/treesit.c    struct buffer *base_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2187.html#L921'>buffer</a>            921 src/treesit.c    struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L927'>buffer</a>            927 src/treesit.c        XTS_PARSER (parser)-&gt;visible_beg = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2187.html#L928'>buffer</a>            928 src/treesit.c        XTS_PARSER (parser)-&gt;visible_end = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2187.html#L937'>buffer</a>            937 src/treesit.c    eassert (BUF_BEGV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/2187.html#L938'>buffer</a>            938 src/treesit.c    eassert (BUF_ZV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/2187.html#L942'>buffer</a>            942 src/treesit.c    if (visible_beg != BUF_BEGV_BYTE (buffer)</span>
<span class='curline'><a href='../S/2187.html#L943'>buffer</a>            943 src/treesit.c        || visible_end != BUF_ZV_BYTE (buffer))</span>
<span class='curline'><a href='../S/2187.html#L955'>buffer</a>            955 src/treesit.c    if (visible_beg &gt; BUF_BEGV_BYTE (buffer))</span>
<span class='curline'><a href='../S/2187.html#L958'>buffer</a>            958 src/treesit.c        treesit_tree_edit_1 (tree, 0, 0, visible_beg - BUF_BEGV_BYTE (buffer));</span>
<span class='curline'><a href='../S/2187.html#L959'>buffer</a>            959 src/treesit.c        visible_beg = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2187.html#L963'>buffer</a>            963 src/treesit.c    if (visible_end &lt; BUF_ZV_BYTE (buffer))</span>
<span class='curline'><a href='../S/2187.html#L968'>buffer</a>            968 src/treesit.c  			   BUF_ZV_BYTE (buffer) - visible_beg);</span>
<span class='curline'><a href='../S/2187.html#L969'>buffer</a>            969 src/treesit.c        visible_end = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2187.html#L972'>buffer</a>            972 src/treesit.c    else if (visible_end &gt; BUF_ZV_BYTE (buffer))</span>
<span class='curline'><a href='../S/2187.html#L975'>buffer</a>            975 src/treesit.c        treesit_tree_edit_1 (tree, BUF_ZV_BYTE (buffer) - visible_beg,</span>
<span class='curline'><a href='../S/2187.html#L977'>buffer</a>            977 src/treesit.c  			   BUF_ZV_BYTE (buffer) - visible_beg);</span>
<span class='curline'><a href='../S/2187.html#L978'>buffer</a>            978 src/treesit.c        visible_end = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2187.html#L982'>buffer</a>            982 src/treesit.c    if (visible_beg &lt; BUF_BEGV_BYTE (buffer))</span>
<span class='curline'><a href='../S/2187.html#L985'>buffer</a>            985 src/treesit.c        treesit_tree_edit_1 (tree, 0, BUF_BEGV_BYTE (buffer) - visible_beg, 0);</span>
<span class='curline'><a href='../S/2187.html#L986'>buffer</a>            986 src/treesit.c        visible_beg = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2187.html#L991'>buffer</a>            991 src/treesit.c    eassert (visible_beg == BUF_BEGV_BYTE (buffer));</span>
<span class='curline'><a href='../S/2187.html#L992'>buffer</a>            992 src/treesit.c    eassert (visible_end == BUF_ZV_BYTE (buffer));</span>
<span class='curline'><a href='../S/2187.html#L999'>buffer</a>            999 src/treesit.c  treesit_check_buffer_size (struct buffer *buffer)</span>
<span class='curline'><a href='../S/2187.html#L1001'>buffer</a>           1001 src/treesit.c    ptrdiff_t buffer_size_bytes = (BUF_Z_BYTE (buffer) - BUF_BEG_BYTE (buffer));</span>
<span class='curline'><a href='../S/2187.html#L1008'>buffer</a>           1008 src/treesit.c  static Lisp_Object treesit_make_ranges (const TSRange *, uint32_t, struct buffer *);</span>
<span class='curline'><a href='../S/2187.html#L1017'>buffer</a>           1017 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L1027'>buffer</a>           1027 src/treesit.c        struct buffer *oldbuf = current_buffer;</span>
<span class='curline'><a href='../S/2187.html#L1049'>buffer</a>           1049 src/treesit.c    struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L1052'>buffer</a>           1052 src/treesit.c    treesit_check_buffer_size (buffer);</span>
<span class='curline'><a href='../S/2187.html#L1077'>buffer</a>           1077 src/treesit.c        XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/2187.html#L1101'>buffer</a>           1101 src/treesit.c    struct buffer *buffer = XBUFFER (((struct Lisp_TS_Parser *) parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L1108'>buffer</a>           1108 src/treesit.c    eassert (visible_beg = BUF_BEGV_BYTE (buffer));</span>
<span class='curline'><a href='../S/2187.html#L1109'>buffer</a>           1109 src/treesit.c    eassert (visible_end = BUF_ZV_BYTE (buffer));</span>
<span class='curline'><a href='../S/2187.html#L1121'>buffer</a>           1121 src/treesit.c    if (!BUFFER_LIVE_P (buffer))</span>
<span class='curline'><a href='../S/2187.html#L1135'>buffer</a>           1135 src/treesit.c        beg = (char *) BUF_BYTE_ADDRESS (buffer, byte_pos);</span>
<span class='curline'><a href='../S/2187.html#L1151'>buffer</a>           1151 src/treesit.c  make_treesit_parser (Lisp_Object buffer, TSParser *parser,</span>
<span class='curline'><a href='../S/2187.html#L1157'>buffer</a>           1157 src/treesit.c  				       buffer, PVEC_TS_PARSER);</span>
<span class='curline'><a href='../S/2187.html#L1161'>buffer</a>           1161 src/treesit.c    lisp_parser-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/2187.html#L1167'>buffer</a>           1167 src/treesit.c    lisp_parser-&gt;visible_beg = BUF_BEGV_BYTE (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2187.html#L1168'>buffer</a>           1168 src/treesit.c    lisp_parser-&gt;visible_end = BUF_ZV_BYTE (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2187.html#L1391'>buffer</a>           1391 src/treesit.c    (Lisp_Object language, Lisp_Object buffer, Lisp_Object no_reuse)</span>
<span class='curline'><a href='../S/2187.html#L1396'>buffer</a>           1396 src/treesit.c    struct buffer *buf;</span>
<span class='curline'><a href='../S/2187.html#L1397'>buffer</a>           1397 src/treesit.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2187.html#L1401'>buffer</a>           1401 src/treesit.c        CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2187.html#L1402'>buffer</a>           1402 src/treesit.c        buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2187.html#L1453'>buffer</a>           1453 src/treesit.c    Lisp_Object buffer = XTS_PARSER (parser)-&gt;buffer;</span>
<span class='curline'><a href='../S/2187.html#L1454'>buffer</a>           1454 src/treesit.c    struct buffer *buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2187.html#L1471'>buffer</a>           1471 src/treesit.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2187.html#L1473'>buffer</a>           1473 src/treesit.c    struct buffer *buf;</span>
<span class='curline'><a href='../S/2187.html#L1474'>buffer</a>           1474 src/treesit.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2187.html#L1478'>buffer</a>           1478 src/treesit.c        CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2187.html#L1479'>buffer</a>           1479 src/treesit.c        buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2187.html#L1505'>buffer</a>           1505 src/treesit.c    XSETBUFFER (buf, XBUFFER (XTS_PARSER (parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/2187.html#L1526'>buffer</a>           1526 src/treesit.c  	  (!NILP (Fbuffer_live_p (XTS_PARSER (parser)-&gt;buffer))));</span>
<span class='curline'><a href='../S/2187.html#L1550'>buffer</a>           1550 src/treesit.c    struct buffer *buffer = current_buffer;</span>
<span class='curline'><a href='../S/2187.html#L1551'>buffer</a>           1551 src/treesit.c    ptrdiff_t point_min = BUF_BEGV (buffer);</span>
<span class='curline'><a href='../S/2187.html#L1552'>buffer</a>           1552 src/treesit.c    ptrdiff_t point_max = BUF_ZV (buffer);</span>
<span class='curline'><a href='../S/2187.html#L1586'>buffer</a>           1586 src/treesit.c  		     struct buffer *buffer)</span>
<span class='curline'><a href='../S/2187.html#L1592'>buffer</a>           1592 src/treesit.c        uint32_t beg_byte = range.start_byte + BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2187.html#L1593'>buffer</a>           1593 src/treesit.c        uint32_t end_byte = range.end_byte + BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/2187.html#L1594'>buffer</a>           1594 src/treesit.c        eassert (BUF_BEGV_BYTE (buffer) &lt;= beg_byte);</span>
<span class='curline'><a href='../S/2187.html#L1596'>buffer</a>           1596 src/treesit.c        eassert (end_byte &lt;= BUF_ZV_BYTE (buffer));</span>
<span class='curline'><a href='../S/2187.html#L1599'>buffer</a>           1599 src/treesit.c  	= Fcons (make_fixnum (buf_bytepos_to_charpos (buffer, beg_byte)),</span>
<span class='curline'><a href='../S/2187.html#L1600'>buffer</a>           1600 src/treesit.c  		 make_fixnum (buf_bytepos_to_charpos (buffer, end_byte)));</span>
<span class='curline'><a href='../S/2187.html#L1627'>buffer</a>           1627 src/treesit.c    treesit_check_buffer_size (XBUFFER (XTS_PARSER (parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/2187.html#L1650'>buffer</a>           1650 src/treesit.c        struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L1658'>buffer</a>           1658 src/treesit.c  	  ptrdiff_t beg_byte = buf_charpos_to_bytepos (buffer,</span>
<span class='curline'><a href='../S/2187.html#L1660'>buffer</a>           1660 src/treesit.c  	  ptrdiff_t end_byte = buf_charpos_to_bytepos (buffer,</span>
<span class='curline'><a href='../S/2187.html#L1664'>buffer</a>           1664 src/treesit.c  	  eassert (beg_byte - BUF_BEGV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/2187.html#L1665'>buffer</a>           1665 src/treesit.c  	  eassert (end_byte - BUF_BEGV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/2187.html#L1669'>buffer</a>           1669 src/treesit.c  			(uint32_t) beg_byte - BUF_BEGV_BYTE (buffer),</span>
<span class='curline'><a href='../S/2187.html#L1670'>buffer</a>           1670 src/treesit.c  			(uint32_t) end_byte - BUF_BEGV_BYTE (buffer)};</span>
<span class='curline'><a href='../S/2187.html#L1713'>buffer</a>           1713 src/treesit.c    treesit_check_buffer_size (XBUFFER (XTS_PARSER (parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/2187.html#L1716'>buffer</a>           1716 src/treesit.c    struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L1717'>buffer</a>           1717 src/treesit.c    return treesit_make_ranges (ranges, len, buffer);</span>
<span class='curline'><a href='../S/2187.html#L1800'>buffer</a>           1800 src/treesit.c  treesit_check_position (Lisp_Object obj, struct buffer *buf)</span>
<span class='curline'><a href='../S/2187.html#L1843'>buffer</a>           1843 src/treesit.c    struct buffer *buffer</span>
<span class='curline'><a href='../S/2187.html#L1844'>buffer</a>           1844 src/treesit.c      = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L1846'>buffer</a>           1846 src/treesit.c      = buf_bytepos_to_charpos (buffer,</span>
<span class='curline'><a href='../S/2187.html#L1864'>buffer</a>           1864 src/treesit.c    struct buffer *buffer</span>
<span class='curline'><a href='../S/2187.html#L1865'>buffer</a>           1865 src/treesit.c      = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L1867'>buffer</a>           1867 src/treesit.c      = buf_bytepos_to_charpos (buffer, end_byte_offset + visible_beg);</span>
<span class='curline'><a href='../S/2187.html#L2208'>buffer</a>           2208 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L2244'>buffer</a>           2244 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L2532'>buffer</a>           2532 src/treesit.c    struct buffer *old_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2187.html#L2533'>buffer</a>           2533 src/treesit.c    set_buffer_internal (XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/2187.html#L2888'>buffer</a>           2888 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (lisp_parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L2944'>buffer</a>           2944 src/treesit.c    struct buffer *old_buf = current_buffer;</span>
<span class='curline'><a href='../S/1992.html#L45'>buffer</a>             45 src/treesit.h    Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2045.html#L212'>buffer</a>            212 src/undo.c       struct buffer *base_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2045.html#L231'>buffer</a>            231 src/undo.c     			Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2045.html#L234'>buffer</a>            234 src/undo.c       struct buffer *buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2045.html#L290'>buffer</a>            290 src/undo.c     truncate_undo_list (struct buffer *b)</span>
<span class='curline'><a href='../S/2041.html#L283'>buffer</a>            283 src/unexcw.c         char buffer[4096];</span>
<span class='curline'><a href='../S/2041.html#L284'>buffer</a>            284 src/unexcw.c         ret = read (fd_in, buffer, sizeof (buffer));</span>
<span class='curline'><a href='../S/2041.html#L292'>buffer</a>            292 src/unexcw.c         ret2 = write (fd_out, buffer, ret);</span>
<span class='curline'><a href='../S/2121.html#L217'>buffer</a>            217 src/unexhp9k800.c   int buffer[8192];  /* word aligned will be faster */</span>
<span class='curline'><a href='../S/2121.html#L221'>buffer</a>            221 src/unexhp9k800.c       len = min (size, sizeof (buffer));</span>
<span class='curline'><a href='../S/2121.html#L222'>buffer</a>            222 src/unexhp9k800.c       if (read (old, buffer, len) != len)</span>
<span class='curline'><a href='../S/2121.html#L224'>buffer</a>            224 src/unexhp9k800.c       if (write (new, buffer, len) != len)</span>
<span class='curline'><a href='../S/2121.html#L234'>buffer</a>            234 src/unexhp9k800.c   int buffer[4096];</span>
<span class='curline'><a href='../S/2121.html#L238'>buffer</a>            238 src/unexhp9k800.c   while ((len = read (old, buffer, sizeof (buffer))) &gt; 0)</span>
<span class='curline'><a href='../S/2121.html#L239'>buffer</a>            239 src/unexhp9k800.c     if (write (new, buffer, len) != len) break;</span>
<span class='curline'><a href='../S/2191.html#L3931'>buffer</a>           3931 src/w32.c        char *buffer;</span>
<span class='curline'><a href='../S/2191.html#L3941'>buffer</a>           3941 src/w32.c            buffer = alloca (bufsize);</span>
<span class='curline'><a href='../S/2191.html#L3942'>buffer</a>           3942 src/w32.c            result = WNetEnumResourceW (henum, &amp;count, buffer, &amp;bufsize);</span>
<span class='curline'><a href='../S/2191.html#L3946'>buffer</a>           3946 src/w32.c            ptrw = ((LPNETRESOURCEW) buffer)-&gt;lpRemoteName;</span>
<span class='curline'><a href='../S/2191.html#L3958'>buffer</a>           3958 src/w32.c            buffer = alloca (bufsize);</span>
<span class='curline'><a href='../S/2191.html#L3959'>buffer</a>           3959 src/w32.c            result = WNetEnumResourceA (henum, &amp;count, buffer, &amp;bufsize);</span>
<span class='curline'><a href='../S/2191.html#L3962'>buffer</a>           3962 src/w32.c            ptra = ((LPNETRESOURCEA) buffer)-&gt;lpRemoteName;</span>
<span class='curline'><a href='../S/2191.html#L6364'>buffer</a>           6364 src/w32.c      readlinkat (int fd, char const *name, char *buffer,</span>
<span class='curline'><a href='../S/2191.html#L6382'>buffer</a>           6382 src/w32.c        return readlink (name, buffer, buffer_size);</span>
<span class='curline'><a href='../S/2191.html#L6803'>buffer</a>           6803 src/w32.c                    char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2191.html#L6814'>buffer</a>           6814 src/w32.c            char *retval = buffer;</span>
<span class='curline'><a href='../S/2191.html#L9005'>buffer</a>           9005 src/w32.c      sys_read (int fd, char * buffer, unsigned int count)</span>
<span class='curline'><a href='../S/2191.html#L9010'>buffer</a>           9010 src/w32.c        char * orig_buffer = buffer;</span>
<span class='curline'><a href='../S/2191.html#L9034'>buffer</a>           9034 src/w32.c      	  *buffer++ = 0x0d;</span>
<span class='curline'><a href='../S/2191.html#L9076'>buffer</a>           9076 src/w32.c      	      *buffer++ = cp-&gt;chr;</span>
<span class='curline'><a href='../S/2191.html#L9098'>buffer</a>           9098 src/w32.c      		nchars += _read (fd, buffer, to_read);</span>
<span class='curline'><a href='../S/2191.html#L9129'>buffer</a>           9129 src/w32.c      		  if (!ReadFile (hnd, buffer, count, (DWORD*) &amp;rc, ovl))</span>
<span class='curline'><a href='../S/2191.html#L9182'>buffer</a>           9182 src/w32.c      		  int res = pfn_recv (SOCK_HANDLE (fd), buffer, count, 0);</span>
<span class='curline'><a href='../S/2191.html#L9196'>buffer</a>           9196 src/w32.c      	  int nread = _read (fd, buffer, count);</span>
<span class='curline'><a href='../S/2191.html#L9221'>buffer</a>           9221 src/w32.c          nchars = _read (fd, buffer, count);</span>
<span class='curline'><a href='../S/2191.html#L9230'>buffer</a>           9230 src/w32.c      sys_write (int fd, const void * buffer, unsigned int count)</span>
<span class='curline'><a href='../S/2191.html#L9253'>buffer</a>           9253 src/w32.c      	  const unsigned char * src = buffer;</span>
<span class='curline'><a href='../S/2191.html#L9281'>buffer</a>           9281 src/w32.c      	  buffer = tmpbuf;</span>
<span class='curline'><a href='../S/2191.html#L9295'>buffer</a>           9295 src/w32.c            if (!WriteFile (hnd, buffer, count, (DWORD*) &amp;nchars, ovl))</span>
<span class='curline'><a href='../S/2191.html#L9367'>buffer</a>           9367 src/w32.c            nchars =  pfn_send (SOCK_HANDLE (fd), buffer, count, 0);</span>
<span class='curline'><a href='../S/2191.html#L9392'>buffer</a>           9392 src/w32.c            const unsigned char *p = buffer;</span>
<span class='curline'><a href='../S/2191.html#L10345'>buffer</a>           10345 src/w32.c      	  char *buffer = alloca (1024</span>
<span class='curline'><a href='../S/2191.html#L10348'>buffer</a>           10348 src/w32.c      	  char *msg = buffer;</span>
<span class='curline'><a href='../S/2191.html#L10351'>buffer</a>           10351 src/w32.c      	  sprintf (buffer,</span>
<span class='curline'><a href='../S/2191.html#L10362'>buffer</a>           10362 src/w32.c      					 buffer, -1, NULL, 0);</span>
<span class='curline'><a href='../S/2191.html#L10367'>buffer</a>           10367 src/w32.c      	      pMultiByteToWideChar (CP_UTF8, multiByteToWideCharFlags, buffer,</span>
<span class='curline'><a href='../S/2078.html#L177'>buffer</a>            177 src/w32fns.c     (IN HIMC context, IN DWORD index, OUT LPVOID buffer, IN DWORD bufLen);</span>
<span class='curline'><a href='../S/2078.html#L4610'>buffer</a>           4610 src/w32fns.c   	  wchar_t * buffer;</span>
<span class='curline'><a href='../S/2078.html#L4620'>buffer</a>           4620 src/w32fns.c   	  buffer = alloca (size);</span>
<span class='curline'><a href='../S/2078.html#L4622'>buffer</a>           4622 src/w32fns.c   					    buffer, size);</span>
<span class='curline'><a href='../S/2078.html#L4628'>buffer</a>           4628 src/w32fns.c   	      my_post_msg (&amp;wmsg, hwnd, WM_UNICHAR, (WPARAM) buffer[i],</span>
<span class='curline'><a href='../S/2078.html#L7389'>buffer</a>           7389 src/w32fns.c     struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/2078.html#L11127'>buffer</a>           11127 src/w32fns.c   w32_backtrace (void **buffer, int limit)</span>
<span class='curline'><a href='../S/2078.html#L11140'>buffer</a>           11140 src/w32fns.c   					buffer, NULL);</span>
<span class='curline'><a href='../S/2227.html#L286'>buffer</a>            286 src/w32menu.c        struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2227.html#L287'>buffer</a>            287 src/w32menu.c        Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2227.html#L299'>buffer</a>            299 src/w32menu.c        buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/2227.html#L313'>buffer</a>            313 src/w32menu.c        set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2147.html#L592'>buffer</a>            592 src/w32select.c   char buffer[20] = "";</span>
<span class='curline'><a href='../S/2147.html#L598'>buffer</a>            598 src/w32select.c   GetLocaleInfo (lcid, variant, buffer, sizeof (buffer));</span>
<span class='curline'><a href='../S/2147.html#L599'>buffer</a>            599 src/w32select.c   cp = strtoul (buffer, NULL, 10);</span>
<span class='curline'><a href='../S/2147.html#L612'>buffer</a>            612 src/w32select.c   char buffer[30];</span>
<span class='curline'><a href='../S/2147.html#L613'>buffer</a>            613 src/w32select.c   sprintf (buffer, "cp%d-dos", (int) codepage);</span>
<span class='curline'><a href='../S/2147.html#L614'>buffer</a>            614 src/w32select.c   return intern (buffer);</span>
<span class='curline'><a href='../S/2109.html#L7423'>buffer</a>           7423 src/w32term.c    char *buffer = xmalloc (strlen (xrm_option) + 2);</span>
<span class='curline'><a href='../S/2109.html#L7424'>buffer</a>           7424 src/w32term.c    char *current = buffer;</span>
<span class='curline'><a href='../S/2109.html#L7459'>buffer</a>           7459 src/w32term.c    return buffer;</span>
<span class='curline'><a href='../S/2230.html#L283'>buffer</a>            283 src/widget.c     char buffer[sizeof wmshell-&gt;wm.size_hints];</span>
<span class='curline'><a href='../S/2230.html#L287'>buffer</a>            287 src/widget.c     memcpy (buffer, &amp;wmshell-&gt;wm.size_hints,</span>
<span class='curline'><a href='../S/2230.html#L316'>buffer</a>            316 src/widget.c     return memcmp (hints_ptr + sizeof (long), buffer + sizeof (long),</span>
<span class='curline'><a href='../S/2012.html#L230'>buffer</a>            230 src/window.c     struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2012.html#L280'>buffer</a>            280 src/window.c         struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2012.html#L1821'>buffer</a>           1821 src/window.c     struct buffer *b;</span>
<span class='curline'><a href='../S/2012.html#L1841'>buffer</a>           1841 src/window.c         struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/2012.html#L1892'>buffer</a>           1892 src/window.c   	  struct buffer *old_buffer = current_buffer;</span>
<span class='curline'><a href='../S/2012.html#L1976'>buffer</a>           1976 src/window.c     struct buffer *buf;</span>
<span class='curline'><a href='../S/2012.html#L2043'>buffer</a>           2043 src/window.c     register struct buffer *b;</span>
<span class='curline'><a href='../S/2012.html#L2178'>buffer</a>           2178 src/window.c     struct buffer *b;</span>
<span class='curline'><a href='../S/2012.html#L2414'>buffer</a>           2414 src/window.c         struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2012.html#L2440'>buffer</a>           2440 src/window.c     struct buffer *b = XBUFFER (buf);</span>
<span class='curline'><a href='../S/2012.html#L2442'>buffer</a>           2442 src/window.c     eassert (b == XMARKER (w-&gt;pointm)-&gt;buffer);</span>
<span class='curline'><a href='../S/2012.html#L3185'>buffer</a>           3185 src/window.c   		struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2012.html#L3189'>buffer</a>           3189 src/window.c   		if (!MARKERP (w-&gt;start) || XMARKER (w-&gt;start)-&gt;buffer != b)</span>
<span class='curline'><a href='../S/2012.html#L3191'>buffer</a>           3191 src/window.c   		if (!MARKERP (w-&gt;pointm) || XMARKER (w-&gt;pointm)-&gt;buffer != b)</span>
<span class='curline'><a href='../S/2012.html#L3233'>buffer</a>           3233 src/window.c     Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2012.html#L3236'>buffer</a>           3236 src/window.c       buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/2012.html#L3238'>buffer</a>           3238 src/window.c       buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/2012.html#L3240'>buffer</a>           3240 src/window.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/2012.html#L3241'>buffer</a>           3241 src/window.c       return window_loop (GET_BUFFER_WINDOW, buffer, true, all_frames);</span>
<span class='curline'><a href='../S/2012.html#L3486'>buffer</a>           3486 src/window.c   	  struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/2012.html#L3515'>buffer</a>           3515 src/window.c   replace_buffer_in_windows (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2012.html#L3517'>buffer</a>           3517 src/window.c     call1 (Qreplace_buffer_in_windows, buffer);</span>
<span class='curline'><a href='../S/2012.html#L3524'>buffer</a>           3524 src/window.c   replace_buffer_in_windows_safely (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2012.html#L3526'>buffer</a>           3526 src/window.c     if (buffer_window_count (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/2012.html#L3534'>buffer</a>           3534 src/window.c   	window_loop (REPLACE_BUFFER_IN_WINDOWS_SAFELY, buffer, true, frame);</span>
<span class='curline'><a href='../S/2012.html#L3603'>buffer</a>           3603 src/window.c   	Lisp_Object buffer = Fwindow_buffer (window);</span>
<span class='curline'><a href='../S/2012.html#L3605'>buffer</a>           3605 src/window.c   				      buffer)))</span>
<span class='curline'><a href='../S/2012.html#L3611'>buffer</a>           3611 src/window.c   					   buffer));</span>
<span class='curline'><a href='../S/2012.html#L3790'>buffer</a>           3790 src/window.c   run_window_change_functions_1 (Lisp_Object symbol, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/2012.html#L3795'>buffer</a>           3795 src/window.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/2012.html#L3797'>buffer</a>           3797 src/window.c     else if (!NILP (Fassoc (symbol, BVAR (XBUFFER (buffer), local_var_alist),</span>
<span class='curline'><a href='../S/2012.html#L3800'>buffer</a>           3800 src/window.c       funs = buffer_local_value (symbol, buffer);</span>
<span class='curline'><a href='../S/2012.html#L3805'>buffer</a>           3805 src/window.c   	  &amp;&amp; (NILP (buffer)</span>
<span class='curline'><a href='../S/2012.html#L3937'>buffer</a>           3937 src/window.c   	  Lisp_Object buffer = WINDOW_BUFFER (w);</span>
<span class='curline'><a href='../S/2012.html#L3951'>buffer</a>           3951 src/window.c   	     &amp;&amp; (!EQ (buffer, w-&gt;old_buffer)</span>
<span class='curline'><a href='../S/2012.html#L3979'>buffer</a>           3979 src/window.c   	      (Qwindow_buffer_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/2012.html#L3983'>buffer</a>           3983 src/window.c   	      (Qwindow_size_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/2012.html#L3996'>buffer</a>           3996 src/window.c   	      (Qwindow_selection_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/2012.html#L4011'>buffer</a>           4011 src/window.c   	      (Qwindow_state_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/2012.html#L4095'>buffer</a>           4095 src/window.c   set_window_buffer (Lisp_Object window, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/2012.html#L4099'>buffer</a>           4099 src/window.c     struct buffer *b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2012.html#L4101'>buffer</a>           4101 src/window.c     bool samebuf = EQ (buffer, w-&gt;contents);</span>
<span class='curline'><a href='../S/2012.html#L4103'>buffer</a>           4103 src/window.c     wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/2012.html#L4128'>buffer</a>           4128 src/window.c         set_marker_both (w-&gt;pointm, buffer, BUF_PT (b), BUF_PT_BYTE (b));</span>
<span class='curline'><a href='../S/2012.html#L4129'>buffer</a>           4129 src/window.c         set_marker_both (w-&gt;old_pointm, buffer, BUF_PT (b), BUF_PT_BYTE (b));</span>
<span class='curline'><a href='../S/2012.html#L4132'>buffer</a>           4132 src/window.c   			     buffer);</span>
<span class='curline'><a href='../S/2012.html#L4143'>buffer</a>           4143 src/window.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/2012.html#L4201'>buffer</a>           4201 src/window.c     register Lisp_Object tem, buffer;</span>
<span class='curline'><a href='../S/2012.html#L4205'>buffer</a>           4205 src/window.c     buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/2012.html#L4206'>buffer</a>           4206 src/window.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2012.html#L4207'>buffer</a>           4207 src/window.c     if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/2012.html#L4215'>buffer</a>           4215 src/window.c         if (!EQ (tem, buffer))</span>
<span class='curline'><a href='../S/2012.html#L4232'>buffer</a>           4232 src/window.c     set_window_buffer (window, buffer, true, !NILP (keep_margins));</span>
<span class='curline'><a href='../S/2012.html#L4238'>buffer</a>           4238 src/window.c   display_buffer (Lisp_Object buffer, Lisp_Object not_this_window_p, Lisp_Object override_frame)</span>
<span class='curline'><a href='../S/2012.html#L4240'>buffer</a>           4240 src/window.c     return call3 (Qdisplay_buffer, buffer, not_this_window_p, override_frame);</span>
<span class='curline'><a href='../S/2012.html#L4290'>buffer</a>           4290 src/window.c     register struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2012.html#L5577'>buffer</a>           5577 src/window.c     struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2012.html#L6588'>buffer</a>           6588 src/window.c     struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/2012.html#L6651'>buffer</a>           6651 src/window.c     struct buffer *buf = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2012.html#L7020'>buffer</a>           7020 src/window.c     Lisp_Object window, buffer, start, pointm, old_pointm;</span>
<span class='curline'><a href='../S/2012.html#L7159'>buffer</a>           7159 src/window.c   	      &amp;&amp; !EQ (w-&gt;contents, p-&gt;buffer)</span>
<span class='curline'><a href='../S/2012.html#L7160'>buffer</a>           7160 src/window.c   	      &amp;&amp; BUFFER_LIVE_P (XBUFFER (p-&gt;buffer))</span>
<span class='curline'><a href='../S/2012.html#L7161'>buffer</a>           7161 src/window.c   	      &amp;&amp; (NILP (Fminibufferp (p-&gt;buffer, Qnil))))</span>
<span class='curline'><a href='../S/2012.html#L7291'>buffer</a>           7291 src/window.c   	      &amp;&amp; BUFFERP (p-&gt;buffer) &amp;&amp; BUFFER_LIVE_P (XBUFFER (p-&gt;buffer)))</span>
<span class='curline'><a href='../S/2012.html#L7295'>buffer</a>           7295 src/window.c   	      wset_buffer (w, p-&gt;buffer);</span>
<span class='curline'><a href='../S/2012.html#L7303'>buffer</a>           7303 src/window.c   	      if (!EQ (p-&gt;buffer, new_current_buffer)</span>
<span class='curline'><a href='../S/2012.html#L7304'>buffer</a>           7304 src/window.c   		  &amp;&amp; XBUFFER (p-&gt;buffer) == current_buffer)</span>
<span class='curline'><a href='../S/2012.html#L7311'>buffer</a>           7311 src/window.c   	      if (XMARKER (w-&gt;start)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/2012.html#L7313'>buffer</a>           7313 src/window.c   	      if (XMARKER (w-&gt;pointm)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/2012.html#L7318'>buffer</a>           7318 src/window.c   	      if (XMARKER (w-&gt;old_pointm)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/2012.html#L7581'>buffer</a>           7581 src/window.c         p-&gt;buffer = (WINDOW_LEAF_P (w) ? w-&gt;contents : Qnil);</span>
<span class='curline'><a href='../S/2012.html#L8287'>buffer</a>           8287 src/window.c   	  || !EQ (sw1-&gt;buffer, sw2-&gt;buffer)</span>
<span class='curline'><a href='../S/2205.html#L1108'>buffer</a>           1108 src/window.h   void set_window_buffer (Lisp_Object window, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/2205.html#L1138'>buffer</a>           1138 src/window.h   extern void bset_redisplay (struct buffer *b);</span>
<span class='curline'><a href='../S/2205.html#L1144'>buffer</a>           1144 src/window.h   extern void bset_update_mode_line (struct buffer *b);</span>
<span class='curline'><a href='../S/2118.html#L659'>buffer</a>            659 src/xdisp.c    static struct buffer *this_line_buffer;</span>
<span class='curline'><a href='../S/2118.html#L847'>buffer</a>            847 src/xdisp.c    bset_redisplay (struct buffer *b)</span>
<span class='curline'><a href='../S/2118.html#L863'>buffer</a>            863 src/xdisp.c    bset_update_mode_line (struct buffer *b)</span>
<span class='curline'><a href='../S/2118.html#L936'>buffer</a>            936 src/xdisp.c    static struct buffer *displayed_buffer;</span>
<span class='curline'><a href='../S/2118.html#L1510'>buffer</a>           1510 src/xdisp.c      struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/2118.html#L1557'>buffer</a>           1557 src/xdisp.c          struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L1655'>buffer</a>           1655 src/xdisp.c      struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/2118.html#L4522'>buffer</a>           4522 src/xdisp.c          struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L11600'>buffer</a>           11600 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L11601'>buffer</a>           11601 src/xdisp.c      struct buffer *old_b = NULL;</span>
<span class='curline'><a href='../S/2118.html#L11638'>buffer</a>           11638 src/xdisp.c      struct buffer *b = (NILP (buffer_or_name)</span>
<span class='curline'><a href='../S/2118.html#L11641'>buffer</a>           11641 src/xdisp.c      Lisp_Object buffer, value;</span>
<span class='curline'><a href='../S/2118.html#L11644'>buffer</a>           11644 src/xdisp.c      XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/2118.html#L11656'>buffer</a>           11656 src/xdisp.c      if (!EQ (buffer, w-&gt;contents))</span>
<span class='curline'><a href='../S/2118.html#L11658'>buffer</a>           11658 src/xdisp.c          wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/2118.html#L11659'>buffer</a>           11659 src/xdisp.c          set_marker_both (w-&gt;pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/2118.html#L11660'>buffer</a>           11660 src/xdisp.c          set_marker_both (w-&gt;old_pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/2118.html#L11682'>buffer</a>           11682 src/xdisp.c      struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L11764'>buffer</a>           11764 src/xdisp.c      char *buffer = SAFE_ALLOCA (len);</span>
<span class='curline'><a href='../S/2118.html#L11765'>buffer</a>           11765 src/xdisp.c      memcpy (buffer, SDATA (msg), len);</span>
<span class='curline'><a href='../S/2118.html#L11767'>buffer</a>           11767 src/xdisp.c      message_dolog (buffer, len - 1, true, STRING_MULTIBYTE (msg));</span>
<span class='curline'><a href='../S/2118.html#L11801'>buffer</a>           11801 src/xdisp.c          struct buffer *oldbuf;</span>
<span class='curline'><a href='../S/2118.html#L12035'>buffer</a>           12035 src/xdisp.c          char *buffer;</span>
<span class='curline'><a href='../S/2118.html#L12037'>buffer</a>           12037 src/xdisp.c          SAFE_ALLOCA_STRING (buffer, m);</span>
<span class='curline'><a href='../S/2118.html#L12038'>buffer</a>           12038 src/xdisp.c          message_dolog (buffer, nbytes, true, multibyte);</span>
<span class='curline'><a href='../S/2118.html#L12338'>buffer</a>           12338 src/xdisp.c      Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2118.html#L12374'>buffer</a>           12374 src/xdisp.c      buffer = echo_area_buffer[this_one];</span>
<span class='curline'><a href='../S/2118.html#L12378'>buffer</a>           12378 src/xdisp.c      if (echo_kboard == NULL &amp;&amp; EQ (buffer, echo_message_buffer))</span>
<span class='curline'><a href='../S/2118.html#L12391'>buffer</a>           12391 src/xdisp.c      set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2118.html#L12394'>buffer</a>           12394 src/xdisp.c          wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/2118.html#L12395'>buffer</a>           12395 src/xdisp.c          set_marker_both (w-&gt;pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/2118.html#L12396'>buffer</a>           12396 src/xdisp.c          set_marker_both (w-&gt;old_pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/2118.html#L12477'>buffer</a>           12477 src/xdisp.c          Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2118.html#L12480'>buffer</a>           12480 src/xdisp.c          buffer = AREF (vector, 4);</span>
<span class='curline'><a href='../S/2118.html#L12482'>buffer</a>           12482 src/xdisp.c          wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/2118.html#L12483'>buffer</a>           12483 src/xdisp.c          set_marker_restricted_both (w-&gt;pointm, buffer,</span>
<span class='curline'><a href='../S/2118.html#L12486'>buffer</a>           12486 src/xdisp.c          set_marker_restricted_both (w-&gt;old_pointm, buffer,</span>
<span class='curline'><a href='../S/2118.html#L12489'>buffer</a>           12489 src/xdisp.c          set_marker_restricted_both (w-&gt;start, buffer,</span>
<span class='curline'><a href='../S/2118.html#L12742'>buffer</a>           12742 src/xdisp.c          struct buffer *old_current_buffer = NULL;</span>
<span class='curline'><a href='../S/2118.html#L13254'>buffer</a>           13254 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L13339'>buffer</a>           13339 src/xdisp.c    			      struct buffer *obuf,</span>
<span class='curline'><a href='../S/2118.html#L13368'>buffer</a>           13368 src/xdisp.c          Lisp_Object buffer = XWINDOW (target_frame-&gt;selected_window)-&gt;contents;</span>
<span class='curline'><a href='../S/2118.html#L13369'>buffer</a>           13369 src/xdisp.c          struct buffer *b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2118.html#L13370'>buffer</a>           13370 src/xdisp.c          struct buffer *cb = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L13382'>buffer</a>           13382 src/xdisp.c          ASET (vector, 10, buffer);</span>
<span class='curline'><a href='../S/2118.html#L13434'>buffer</a>           13434 src/xdisp.c    	  Lisp_Object buffer = AREF (vector, 10);</span>
<span class='curline'><a href='../S/2118.html#L13436'>buffer</a>           13436 src/xdisp.c    	  if (BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/2118.html#L13438'>buffer</a>           13438 src/xdisp.c    	      struct buffer *cb = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L13440'>buffer</a>           13440 src/xdisp.c    	      current_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2118.html#L13635'>buffer</a>           13635 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L13642'>buffer</a>           13642 src/xdisp.c              &amp;&amp; !buffer-&gt;text-&gt;redisplay</span>
<span class='curline'><a href='../S/2118.html#L13812'>buffer</a>           13812 src/xdisp.c    	  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L13979'>buffer</a>           13979 src/xdisp.c    	  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L14904'>buffer</a>           14904 src/xdisp.c    	  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L15929'>buffer</a>           15929 src/xdisp.c    	      struct buffer *saved_current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L16031'>buffer</a>           16031 src/xdisp.c    		  struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L16238'>buffer</a>           16238 src/xdisp.c    	  &amp;&amp; current_buffer == XMARKER (val)-&gt;buffer)</span>
<span class='curline'><a href='../S/2118.html#L16275'>buffer</a>           16275 src/xdisp.c    	  struct buffer *buf = XMARKER (val)-&gt;buffer;</span>
<span class='curline'><a href='../S/2118.html#L16347'>buffer</a>           16347 src/xdisp.c    	  &amp;&amp; current_buffer == XMARKER (val)-&gt;buffer</span>
<span class='curline'><a href='../S/2118.html#L16377'>buffer</a>           16377 src/xdisp.c    check_point_in_composition (struct buffer *prev_buf, ptrdiff_t prev_pt,</span>
<span class='curline'><a href='../S/2118.html#L16378'>buffer</a>           16378 src/xdisp.c    			    struct buffer *buf, ptrdiff_t pt)</span>
<span class='curline'><a href='../S/2118.html#L16382'>buffer</a>           16382 src/xdisp.c      Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2118.html#L16384'>buffer</a>           16384 src/xdisp.c      XSETBUFFER (buffer, buf);</span>
<span class='curline'><a href='../S/2118.html#L16394'>buffer</a>           16394 src/xdisp.c    	  &amp;&amp; find_composition (prev_pt, -1, &amp;start, &amp;end, &amp;prop, buffer)</span>
<span class='curline'><a href='../S/2118.html#L16404'>buffer</a>           16404 src/xdisp.c    	  &amp;&amp; find_composition (pt, -1, &amp;start, &amp;end, &amp;prop, buffer)</span>
<span class='curline'><a href='../S/2118.html#L16414'>buffer</a>           16414 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L16418'>buffer</a>           16418 src/xdisp.c          &amp;&amp; w-&gt;current_matrix-&gt;buffer == b</span>
<span class='curline'><a href='../S/2118.html#L16432'>buffer</a>           16432 src/xdisp.c          if ((w-&gt;current_matrix-&gt;buffer != b || pt != w-&gt;last_point)</span>
<span class='curline'><a href='../S/2118.html#L16433'>buffer</a>           16433 src/xdisp.c    	  &amp;&amp; check_point_in_composition (w-&gt;current_matrix-&gt;buffer,</span>
<span class='curline'><a href='../S/2118.html#L16455'>buffer</a>           16455 src/xdisp.c          struct buffer *thisb = XBUFFER (thisw-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L17419'>buffer</a>           17419 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L17440'>buffer</a>           17440 src/xdisp.c          w-&gt;current_matrix-&gt;buffer = b;</span>
<span class='curline'><a href='../S/2118.html#L19322'>buffer</a>           19322 src/xdisp.c          struct buffer *buf = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L19335'>buffer</a>           19335 src/xdisp.c    	  struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L19370'>buffer</a>           19370 src/xdisp.c          struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L19371'>buffer</a>           19371 src/xdisp.c          struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/2118.html#L19518'>buffer</a>           19518 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L19519'>buffer</a>           19519 src/xdisp.c      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L19551'>buffer</a>           19551 src/xdisp.c      eassert (XMARKER (w-&gt;start)-&gt;buffer == buffer);</span>
<span class='curline'><a href='../S/2118.html#L19552'>buffer</a>           19552 src/xdisp.c      eassert (XMARKER (w-&gt;pointm)-&gt;buffer == buffer);</span>
<span class='curline'><a href='../S/2118.html#L19562'>buffer</a>           19562 src/xdisp.c    		      || buffer-&gt;clip_changed</span>
<span class='curline'><a href='../S/2118.html#L19563'>buffer</a>           19563 src/xdisp.c    		      || buffer-&gt;prevent_redisplay_optimizations_p);</span>
<span class='curline'><a href='../S/2118.html#L19646'>buffer</a>           19646 src/xdisp.c          if (XMARKER (w-&gt;start)-&gt;buffer == current_buffer)</span>
<span class='curline'><a href='../S/2118.html#L19703'>buffer</a>           19703 src/xdisp.c    	  struct buffer *buf = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L19732'>buffer</a>           19732 src/xdisp.c      if (XMARKER (w-&gt;start)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/2118.html#L20070'>buffer</a>           20070 src/xdisp.c    	  &amp;&amp; XMARKER (w-&gt;start)-&gt;buffer == current_buffer</span>
<span class='curline'><a href='../S/2118.html#L22643'>buffer</a>           22643 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L22646'>buffer</a>           22646 src/xdisp.c    	   BUF_PT (buffer), BUF_BEGV (buffer), BUF_ZV (buffer));</span>
<span class='curline'><a href='../S/2118.html#L22814'>buffer</a>           22814 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L22815'>buffer</a>           22815 src/xdisp.c      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L22824'>buffer</a>           22824 src/xdisp.c      set_buffer_temp (buffer);</span>
<span class='curline'><a href='../S/2118.html#L22830'>buffer</a>           22830 src/xdisp.c      multibyte_p = !NILP (BVAR (buffer, enable_multibyte_characters));</span>
<span class='curline'><a href='../S/2118.html#L25660'>buffer</a>           25660 src/xdisp.c      (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2118.html#L25662'>buffer</a>           25662 src/xdisp.c      struct buffer *buf = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L25663'>buffer</a>           25663 src/xdisp.c      struct buffer *old = buf;</span>
<span class='curline'><a href='../S/2118.html#L25665'>buffer</a>           25665 src/xdisp.c      if (! NILP (buffer))</span>
<span class='curline'><a href='../S/2118.html#L25667'>buffer</a>           25667 src/xdisp.c          CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2118.html#L25668'>buffer</a>           25668 src/xdisp.c          buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/2118.html#L25784'>buffer</a>           25784 src/xdisp.c      struct buffer *buf = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L25785'>buffer</a>           25785 src/xdisp.c      struct buffer *old = buf;</span>
<span class='curline'><a href='../S/2118.html#L25902'>buffer</a>           25902 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L26376'>buffer</a>           26376 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L26762'>buffer</a>           26762 src/xdisp.c    	  struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L27663'>buffer</a>           27663 src/xdisp.c          Lisp_Object window, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2118.html#L27668'>buffer</a>           27668 src/xdisp.c      struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/2118.html#L27678'>buffer</a>           27678 src/xdisp.c      if (NILP (buffer))</span>
<span class='curline'><a href='../S/2118.html#L27679'>buffer</a>           27679 src/xdisp.c        buffer = w-&gt;contents;</span>
<span class='curline'><a href='../S/2118.html#L27680'>buffer</a>           27680 src/xdisp.c      CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2118.html#L27712'>buffer</a>           27712 src/xdisp.c      set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2118.html#L28008'>buffer</a>           28008 src/xdisp.c      struct buffer *b = current_buffer;</span>
<span class='curline'><a href='../S/2118.html#L33027'>buffer</a>           33027 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/2118.html#L35162'>buffer</a>           35162 src/xdisp.c      struct buffer *b;</span>
<span class='curline'><a href='../S/2118.html#L35382'>buffer</a>           35382 src/xdisp.c          struct buffer *obuf;</span>
<span class='curline'><a href='../S/2118.html#L35579'>buffer</a>           35579 src/xdisp.c    	      Lisp_Object buffer UNINIT;</span>
<span class='curline'><a href='../S/2118.html#L35593'>buffer</a>           35593 src/xdisp.c    		      buffer = w-&gt;contents;</span>
<span class='curline'><a href='../S/2118.html#L35599'>buffer</a>           35599 src/xdisp.c    		  buffer = object;</span>
<span class='curline'><a href='../S/2118.html#L35618'>buffer</a>           35618 src/xdisp.c    		    = NILP (BVAR (XBUFFER (buffer), bidi_display_reordering))</span>
<span class='curline'><a href='../S/2118.html#L35622'>buffer</a>           35622 src/xdisp.c    		    = NILP (BVAR (XBUFFER (buffer), bidi_display_reordering))</span>
<span class='curline'><a href='../S/2118.html#L35623'>buffer</a>           35623 src/xdisp.c    		    ? make_fixnum (BUF_Z (XBUFFER (buffer))</span>
<span class='curline'><a href='../S/2118.html#L35631'>buffer</a>           35631 src/xdisp.c    			(make_fixnum (pos + 1), Qmouse_face, buffer, lim1);</span>
<span class='curline'><a href='../S/2118.html#L35633'>buffer</a>           35633 src/xdisp.c    			(make_fixnum (pos), Qmouse_face, buffer, lim2);</span>
<span class='curline'><a href='../S/2118.html#L35653'>buffer</a>           35653 src/xdisp.c    					      ? BUF_Z (XBUFFER (buffer))</span>
<span class='curline'><a href='../S/2118.html#L36173'>buffer</a>           36173 src/xdisp.c          struct buffer *oldbuf = current_buffer;</span>
<span class='curline'><a href='../S/2188.html#L9008'>buffer</a>           9008 src/xfns.c       struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/2010.html#L967'>buffer</a>            967 src/xmenu.c          struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/2010.html#L968'>buffer</a>            968 src/xmenu.c          Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2010.html#L980'>buffer</a>            980 src/xmenu.c          buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/2010.html#L993'>buffer</a>            993 src/xmenu.c          set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/2181.html#L2413'>buffer</a>           2413 src/xterm.c      char *buffer;</span>
<span class='curline'><a href='../S/2181.html#L2461'>buffer</a>           2461 src/xterm.c      buffer = dpyinfo-&gt;motif_drag_atom_name;</span>
<span class='curline'><a href='../S/2181.html#L2465'>buffer</a>           2465 src/xterm.c          sprintf (buffer, "_EMACS_ATOM_%lu", i + 1);</span>
<span class='curline'><a href='../S/2181.html#L2479'>buffer</a>           2479 src/xterm.c          sprintf (buffer, "_EMACS_ATOM_%lu", nitems + 1);</span>
<span class='curline'><a href='../S/2181.html#L2480'>buffer</a>           2480 src/xterm.c          atom = XInternAtom (dpyinfo-&gt;display, buffer, False);</span>
<span class='curline'><a href='../S/2181.html#L29381'>buffer</a>           29381 src/xterm.c      char *dpyinfo_pointer, *name, *value, *buffer;</span>
<span class='curline'><a href='../S/2181.html#L29391'>buffer</a>           29391 src/xterm.c      buffer = alloca (45 + INT_STRLEN_BOUND (int));</span>
<span class='curline'><a href='../S/2181.html#L29432'>buffer</a>           29432 src/xterm.c    	  sprintf (buffer, "_XSETTINGS_S%d",</span>
<span class='curline'><a href='../S/2181.html#L29434'>buffer</a>           29434 src/xterm.c    	  return xstrdup (buffer);</span>
<span class='curline'><a href='../S/2181.html#L29439'>buffer</a>           29439 src/xterm.c    	  sprintf (buffer, "_NET_WM_CM_S%d",</span>
<span class='curline'><a href='../S/2181.html#L29441'>buffer</a>           29441 src/xterm.c    	  return xstrdup (buffer);</span>
<span class='curline'><a href='../S/2222.html#L214'>buffer</a>            214 src/xwidget.c    if (NILP (xw-&gt;buffer))</span>
<span class='curline'><a href='../S/2222.html#L297'>buffer</a>            297 src/xwidget.c     Lisp_Object arguments, Lisp_Object buffer, Lisp_Object related)</span>
<span class='curline'><a href='../S/2222.html#L316'>buffer</a>            316 src/xwidget.c    xw-&gt;buffer = (NILP (buffer) ? Fcurrent_buffer ()</span>
<span class='curline'><a href='../S/2222.html#L317'>buffer</a>            317 src/xwidget.c  		: Fget_buffer_create (buffer, Qnil));</span>
<span class='curline'><a href='../S/2222.html#L467'>buffer</a>            467 src/xwidget.c  	   &amp;&amp; !NILP (XXWIDGET (object)-&gt;buffer))</span>
<span class='curline'><a href='../S/2222.html#L679'>buffer</a>            679 src/xwidget.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2222.html#L683'>buffer</a>            683 src/xwidget.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2222.html#L685'>buffer</a>            685 src/xwidget.c    buffer = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/2222.html#L686'>buffer</a>            686 src/xwidget.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/2222.html#L694'>buffer</a>            694 src/xwidget.c        if (XWIDGETP (xw) &amp;&amp; EQ (Fxwidget_buffer (xw), buffer))</span>
<span class='curline'><a href='../S/2222.html#L1311'>buffer</a>           1311 src/xwidget.c    if (NILP (XXWIDGET (view-&gt;model)-&gt;buffer))</span>
<span class='curline'><a href='../S/2222.html#L1378'>buffer</a>           1378 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/2222.html#L1430'>buffer</a>           1430 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/2222.html#L1480'>buffer</a>           1480 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/2222.html#L1934'>buffer</a>           1934 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/2222.html#L2169'>buffer</a>           2169 src/xwidget.c    if (NILP (w-&gt;buffer))</span>
<span class='curline'><a href='../S/2222.html#L2201'>buffer</a>           2201 src/xwidget.c    if (NILP (w-&gt;buffer))</span>
<span class='curline'><a href='../S/2222.html#L2989'>buffer</a>           2989 src/xwidget.c    if (!NILP (xww-&gt;buffer))</span>
<span class='curline'><a href='../S/2222.html#L3009'>buffer</a>           3009 src/xwidget.c    if (!NILP (xww-&gt;buffer))</span>
<span class='curline'><a href='../S/2222.html#L3022'>buffer</a>           3022 src/xwidget.c    if (NILP (xw-&gt;buffer) || !EQ (xw-&gt;type, Qwebkit))	\</span>
<span class='curline'><a href='../S/2222.html#L3412'>buffer</a>           3412 src/xwidget.c    if (xw-&gt;embedder_view == xv &amp;&amp; !NILP (xw-&gt;buffer))</span>
<span class='curline'><a href='../S/2222.html#L3474'>buffer</a>           3474 src/xwidget.c    return XXWIDGET (xwidget)-&gt;buffer;</span>
<span class='curline'><a href='../S/2222.html#L3481'>buffer</a>           3481 src/xwidget.c    (Lisp_Object xwidget, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2222.html#L3484'>buffer</a>           3484 src/xwidget.c    CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/2222.html#L3486'>buffer</a>           3486 src/xwidget.c    XXWIDGET (xwidget)-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/2222.html#L4225'>buffer</a>           4225 src/xwidget.c    xw-&gt;buffer = Qnil;</span>
<span class='curline'><a href='../S/2222.html#L4259'>buffer</a>           4259 src/xwidget.c  kill_buffer_xwidgets (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/2222.html#L4262'>buffer</a>           4262 src/xwidget.c    for (tail = Fget_buffer_xwidgets (buffer); CONSP (tail); tail = XCDR (tail))</span>
<span class='curline'><a href='../S/2153.html#L61'>buffer</a>             61 src/xwidget.h    Lisp_Object buffer;</span>
<span class='curline'><a href='../S/2153.html#L163'>buffer</a>            163 src/xwidget.h  #define XWIDGET_LIVE_P(w) (!NILP ((w)-&gt;buffer))</span>
<span class='curline'><a href='../S/3866.html#L221'>buffer</a>            221 test/manual/etags/c-src/abbrev.c   register char *buffer, *p;</span>
<span class='curline'><a href='../S/3866.html#L270'>buffer</a>            270 test/manual/etags/c-src/abbrev.c   p = buffer = (char *) alloca (wordend_byte - wordstart_byte);</span>
<span class='curline'><a href='../S/3866.html#L284'>buffer</a>            284 test/manual/etags/c-src/abbrev.c     sym = oblookup (current_buffer-&gt;abbrev_table, buffer,</span>
<span class='curline'><a href='../S/3866.html#L289'>buffer</a>            289 test/manual/etags/c-src/abbrev.c     sym = oblookup (Vglobal_abbrev_table, buffer,</span>
<span class='curline'><a href='../S/3858.html#L313'>buffer</a>            313 test/manual/etags/c-src/emacs/src/keyboard.c static void recursive_edit_unwind (Lisp_Object buffer);</span>
<span class='curline'><a href='../S/3858.html#L447'>buffer</a>            447 test/manual/etags/c-src/emacs/src/keyboard.c   char *buffer = initbuf;</span>
<span class='curline'><a href='../S/3858.html#L448'>buffer</a>            448 test/manual/etags/c-src/emacs/src/keyboard.c   char *ptr = buffer;</span>
<span class='curline'><a href='../S/3858.html#L464'>buffer</a>            464 test/manual/etags/c-src/emacs/src/keyboard.c       if (size - (ptr - buffer) &lt; nbytes)</span>
<span class='curline'><a href='../S/3858.html#L466'>buffer</a>            466 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptrdiff_t offset = ptr - buffer;</span>
<span class='curline'><a href='../S/3858.html#L468'>buffer</a>            468 test/manual/etags/c-src/emacs/src/keyboard.c 	  buffer = SAFE_ALLOCA (size);</span>
<span class='curline'><a href='../S/3858.html#L469'>buffer</a>            469 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptr = buffer + offset;</span>
<span class='curline'><a href='../S/3858.html#L482'>buffer</a>            482 test/manual/etags/c-src/emacs/src/keyboard.c       if (size - (ptr - buffer) &lt; len)</span>
<span class='curline'><a href='../S/3858.html#L484'>buffer</a>            484 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptrdiff_t offset = ptr - buffer;</span>
<span class='curline'><a href='../S/3858.html#L486'>buffer</a>            486 test/manual/etags/c-src/emacs/src/keyboard.c 	  buffer = SAFE_ALLOCA (size);</span>
<span class='curline'><a href='../S/3858.html#L487'>buffer</a>            487 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptr = buffer + offset;</span>
<span class='curline'><a href='../S/3858.html#L519'>buffer</a>            519 test/manual/etags/c-src/emacs/src/keyboard.c      concat2 (echo_string, make_string (buffer, ptr - buffer)));</span>
<span class='curline'><a href='../S/3858.html#L772'>buffer</a>            772 test/manual/etags/c-src/emacs/src/keyboard.c   Lisp_Object buffer;</span>
<span class='curline'><a href='../S/3858.html#L781'>buffer</a>            781 test/manual/etags/c-src/emacs/src/keyboard.c     buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/3858.html#L783'>buffer</a>            783 test/manual/etags/c-src/emacs/src/keyboard.c     buffer = Qnil;</span>
<span class='curline'><a href='../S/3858.html#L790'>buffer</a>            790 test/manual/etags/c-src/emacs/src/keyboard.c   record_unwind_protect (recursive_edit_unwind, buffer);</span>
<span class='curline'><a href='../S/3858.html#L804'>buffer</a>            804 test/manual/etags/c-src/emacs/src/keyboard.c recursive_edit_unwind (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/3858.html#L806'>buffer</a>            806 test/manual/etags/c-src/emacs/src/keyboard.c   if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/3858.html#L807'>buffer</a>            807 test/manual/etags/c-src/emacs/src/keyboard.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/3858.html#L1300'>buffer</a>           1300 test/manual/etags/c-src/emacs/src/keyboard.c   struct buffer *prev_buffer = NULL;</span>
<span class='curline'><a href='../S/3858.html#L1442'>buffer</a>           1442 test/manual/etags/c-src/emacs/src/keyboard.c 	  struct buffer *b;</span>
<span class='curline'><a href='../S/3858.html#L1596'>buffer</a>           1596 test/manual/etags/c-src/emacs/src/keyboard.c 		  &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer</span>
<span class='curline'><a href='../S/3858.html#L2918'>buffer</a>           2918 test/manual/etags/c-src/emacs/src/keyboard.c       struct buffer *prev_buffer = current_buffer;</span>
<span class='curline'><a href='../S/3858.html#L8981'>buffer</a>           8981 test/manual/etags/c-src/emacs/src/keyboard.c   struct buffer *starting_buffer;</span>
<span class='curline'><a href='../S/3861.html#L1027'>buffer</a>           1027 test/manual/etags/c-src/emacs/src/lisp.h INLINE struct buffer *</span>
<span class='curline'><a href='../S/3861.html#L2000'>buffer</a>           2000 test/manual/etags/c-src/emacs/src/lisp.h   struct buffer *buffer;</span>
<span class='curline'><a href='../S/3861.html#L3624'>buffer</a>           3624 test/manual/etags/c-src/emacs/src/lisp.h extern void make_gap_1 (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/3861.html#L3638'>buffer</a>           3638 test/manual/etags/c-src/emacs/src/lisp.h extern void insert_from_buffer (struct buffer *, ptrdiff_t, ptrdiff_t, bool);</span>
<span class='curline'><a href='../S/3861.html#L3655'>buffer</a>           3655 test/manual/etags/c-src/emacs/src/lisp.h extern void invalidate_buffer_caches (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/3861.html#L3884'>buffer</a>           3884 test/manual/etags/c-src/emacs/src/lisp.h extern struct buffer * allocate_buffer (void);</span>
<span class='curline'><a href='../S/3861.html#L4088'>buffer</a>           4088 test/manual/etags/c-src/emacs/src/lisp.h extern void clear_charpos_cache (struct buffer *);</span>
<span class='curline'><a href='../S/3861.html#L4089'>buffer</a>           4089 test/manual/etags/c-src/emacs/src/lisp.h extern ptrdiff_t buf_charpos_to_bytepos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/3861.html#L4090'>buffer</a>           4090 test/manual/etags/c-src/emacs/src/lisp.h extern ptrdiff_t buf_bytepos_to_charpos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/3861.html#L4096'>buffer</a>           4096 test/manual/etags/c-src/emacs/src/lisp.h extern Lisp_Object build_marker (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/3861.html#L4329'>buffer</a>           4329 test/manual/etags/c-src/emacs/src/lisp.h extern void truncate_undo_list (struct buffer *);</span>
<span class='curline'><a href='../S/3861.html#L4386'>buffer</a>           4386 test/manual/etags/c-src/emacs/src/lisp.h extern void unlock_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/3860.html#L341'>buffer</a>            341 test/manual/etags/c-src/emacs/src/regex.h   unsigned char *buffer;</span>
<span class='curline'><a href='../S/3865.html#L238'>buffer</a>            238 test/manual/etags/c-src/etags.c   char *buffer;</span>
<span class='curline'><a href='../S/3865.html#L1213'>buffer</a>           1213 test/manual/etags/c-src/etags.c 		    process_file_name (filename_lb.buffer, lang);</span>
<span class='curline'><a href='../S/3865.html#L1226'>buffer</a>           1226 test/manual/etags/c-src/etags.c   free (lb.buffer);</span>
<span class='curline'><a href='../S/3865.html#L1227'>buffer</a>           1227 test/manual/etags/c-src/etags.c   free (filebuf.buffer);</span>
<span class='curline'><a href='../S/3865.html#L1228'>buffer</a>           1228 test/manual/etags/c-src/etags.c   free (token_name.buffer);</span>
<span class='curline'><a href='../S/3865.html#L1683'>buffer</a>           1683 test/manual/etags/c-src/etags.c       &amp;&amp; lb.buffer[0] == '#'</span>
<span class='curline'><a href='../S/3865.html#L1684'>buffer</a>           1684 test/manual/etags/c-src/etags.c       &amp;&amp; lb.buffer[1] == '!')</span>
<span class='curline'><a href='../S/3865.html#L1691'>buffer</a>           1691 test/manual/etags/c-src/etags.c       lp = strrchr (lb.buffer+2, '/');</span>
<span class='curline'><a href='../S/3865.html#L1695'>buffer</a>           1695 test/manual/etags/c-src/etags.c 	lp = skip_spaces (lb.buffer + 2);</span>
<span class='curline'><a href='../S/3865.html#L2573'>buffer</a>           2573 test/manual/etags/c-src/etags.c       cn-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/3865.html#L2579'>buffer</a>           2579 test/manual/etags/c-src/etags.c       strcpy (cn-&gt;buffer, cstack.cname[0]);</span>
<span class='curline'><a href='../S/3865.html#L2587'>buffer</a>           2587 test/manual/etags/c-src/etags.c       len += sprintf (cn-&gt;buffer + len, "%s%s", qualifier, s);</span>
<span class='curline'><a href='../S/3865.html#L2803'>buffer</a>           2803 test/manual/etags/c-src/etags.c 	   memcpy (token_name.buffer, str, len);</span>
<span class='curline'><a href='../S/3865.html#L2804'>buffer</a>           2804 test/manual/etags/c-src/etags.c 	   token_name.buffer[len] = '\0';</span>
<span class='curline'><a href='../S/3865.html#L2819'>buffer</a>           2819 test/manual/etags/c-src/etags.c 	   memcpy (token_name.buffer + oldlen, str, len);</span>
<span class='curline'><a href='../S/3865.html#L2820'>buffer</a>           2820 test/manual/etags/c-src/etags.c 	   token_name.buffer[oldlen + len] = '\0';</span>
<span class='curline'><a href='../S/3865.html#L2942'>buffer</a>           2942 test/manual/etags/c-src/etags.c   lp = curlb.buffer;							\</span>
<span class='curline'><a href='../S/3865.html#L2965'>buffer</a>           2965 test/manual/etags/c-src/etags.c     make_tag (token_name.buffer, token_name.len, isfun, token.line,</span>
<span class='curline'><a href='../S/3865.html#L2969'>buffer</a>           2969 test/manual/etags/c-src/etags.c       make_tag (concat ("INVALID TOKEN:--&gt;", token_name.buffer, ""),</span>
<span class='curline'><a href='../S/3865.html#L3020'>buffer</a>           3020 test/manual/etags/c-src/etags.c   lp = curlb.buffer;</span>
<span class='curline'><a href='../S/3865.html#L3170'>buffer</a>           3170 test/manual/etags/c-src/etags.c 	      for (cp = newlb.buffer; cp &lt; lp-1; cp++)</span>
<span class='curline'><a href='../S/3865.html#L3243'>buffer</a>           3243 test/manual/etags/c-src/etags.c 			  || consider_token (newlb.buffer + tokoff, toklen, c,</span>
<span class='curline'><a href='../S/3865.html#L3268'>buffer</a>           3268 test/manual/etags/c-src/etags.c 			      sprintf (token_name.buffer + len, "%s%.*s",</span>
<span class='curline'><a href='../S/3865.html#L3269'>buffer</a>           3269 test/manual/etags/c-src/etags.c 				       qualifier, toklen, newlb.buffer + tokoff);</span>
<span class='curline'><a href='../S/3865.html#L3277'>buffer</a>           3277 test/manual/etags/c-src/etags.c 			      sprintf (token_name.buffer, "%s(%.*s)",</span>
<span class='curline'><a href='../S/3865.html#L3278'>buffer</a>           3278 test/manual/etags/c-src/etags.c 				       objtag, toklen, newlb.buffer + tokoff);</span>
<span class='curline'><a href='../S/3865.html#L3290'>buffer</a>           3290 test/manual/etags/c-src/etags.c 			      bool defun = (newlb.buffer[tokoff] == 'F');</span>
<span class='curline'><a href='../S/3865.html#L3302'>buffer</a>           3302 test/manual/etags/c-src/etags.c 			      memcpy (token_name.buffer,</span>
<span class='curline'><a href='../S/3865.html#L3303'>buffer</a>           3303 test/manual/etags/c-src/etags.c 				      newlb.buffer + off, len);</span>
<span class='curline'><a href='../S/3865.html#L3304'>buffer</a>           3304 test/manual/etags/c-src/etags.c 			      token_name.buffer[len] = '\0';</span>
<span class='curline'><a href='../S/3865.html#L3307'>buffer</a>           3307 test/manual/etags/c-src/etags.c 				  if (token_name.buffer[len] == '_')</span>
<span class='curline'><a href='../S/3865.html#L3308'>buffer</a>           3308 test/manual/etags/c-src/etags.c 				    token_name.buffer[len] = '-';</span>
<span class='curline'><a href='../S/3865.html#L3314'>buffer</a>           3314 test/manual/etags/c-src/etags.c 			      memcpy (token_name.buffer,</span>
<span class='curline'><a href='../S/3865.html#L3315'>buffer</a>           3315 test/manual/etags/c-src/etags.c 				      newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/3865.html#L3316'>buffer</a>           3316 test/manual/etags/c-src/etags.c 			      token_name.buffer[toklen] = '\0';</span>
<span class='curline'><a href='../S/3865.html#L3331'>buffer</a>           3331 test/manual/etags/c-src/etags.c 			  token.line = newlb.buffer;</span>
<span class='curline'><a href='../S/3865.html#L3402'>buffer</a>           3402 test/manual/etags/c-src/etags.c 	      if (!yacc_rules || lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/3865.html#L3404'>buffer</a>           3404 test/manual/etags/c-src/etags.c 		  tokoff = lp - 1 - newlb.buffer;</span>
<span class='curline'><a href='../S/3865.html#L3438'>buffer</a>           3438 test/manual/etags/c-src/etags.c 	      strcpy (token_name.buffer + toklen, ":");</span>
<span class='curline'><a href='../S/3865.html#L3726'>buffer</a>           3726 test/manual/etags/c-src/etags.c 	  if (!ignoreindent &amp;&amp; lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/3865.html#L3824'>buffer</a>           3824 test/manual/etags/c-src/etags.c   free (lbs[0].lb.buffer);</span>
<span class='curline'><a href='../S/3865.html#L3825'>buffer</a>           3825 test/manual/etags/c-src/etags.c   free (lbs[1].lb.buffer);</span>
<span class='curline'><a href='../S/3865.html#L3880'>buffer</a>           3880 test/manual/etags/c-src/etags.c            char_pointer = line_buffer.buffer,				\</span>
<span class='curline'><a href='../S/3865.html#L3945'>buffer</a>           3945 test/manual/etags/c-src/etags.c       dbp = lb.buffer;</span>
<span class='curline'><a href='../S/3865.html#L3956'>buffer</a>           3956 test/manual/etags/c-src/etags.c 	    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4033'>buffer</a>           4033 test/manual/etags/c-src/etags.c 			  lb.buffer, dbp - lb.buffer, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4065'>buffer</a>           4065 test/manual/etags/c-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/3865.html#L4106'>buffer</a>           4106 test/manual/etags/c-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4244'>buffer</a>           4244 test/manual/etags/c-src/etags.c 	    make_tag (lb.buffer, cp - lb.buffer, true,</span>
<span class='curline'><a href='../S/3865.html#L4245'>buffer</a>           4245 test/manual/etags/c-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4289'>buffer</a>           4289 test/manual/etags/c-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4300'>buffer</a>           4300 test/manual/etags/c-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4343'>buffer</a>           4343 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4370'>buffer</a>           4370 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4402'>buffer</a>           4402 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4415'>buffer</a>           4415 test/manual/etags/c-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4428'>buffer</a>           4428 test/manual/etags/c-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4443'>buffer</a>           4443 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4453'>buffer</a>           4453 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4484'>buffer</a>           4484 test/manual/etags/c-src/etags.c 		  lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4508'>buffer</a>           4508 test/manual/etags/c-src/etags.c 	  char * namestart = skip_spaces (lb.buffer);</span>
<span class='curline'><a href='../S/3865.html#L4513'>buffer</a>           4513 test/manual/etags/c-src/etags.c 		    lb.buffer, bp - lb.buffer + 2, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4550'>buffer</a>           4550 test/manual/etags/c-src/etags.c   dbp = lb.buffer;</span>
<span class='curline'><a href='../S/3865.html#L4567'>buffer</a>           4567 test/manual/etags/c-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/3865.html#L4649'>buffer</a>           4649 test/manual/etags/c-src/etags.c 			tline.buffer, taglen, save_lineno, save_lcno);</span>
<span class='curline'><a href='../S/3865.html#L4666'>buffer</a>           4666 test/manual/etags/c-src/etags.c 	  strcpy (tline.buffer, lb.buffer);</span>
<span class='curline'><a href='../S/3865.html#L4669'>buffer</a>           4669 test/manual/etags/c-src/etags.c 	  name = tline.buffer + (dbp - lb.buffer);</span>
<span class='curline'><a href='../S/3865.html#L4671'>buffer</a>           4671 test/manual/etags/c-src/etags.c 	  taglen = cp - lb.buffer + 1;</span>
<span class='curline'><a href='../S/3865.html#L4697'>buffer</a>           4697 test/manual/etags/c-src/etags.c   free (tline.buffer);</span>
<span class='curline'><a href='../S/3865.html#L4824'>buffer</a>           4824 test/manual/etags/c-src/etags.c 		    lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L4950'>buffer</a>           4950 test/manual/etags/c-src/etags.c 	  for (key = TEX_toktab; key-&gt;buffer != NULL; key++)</span>
<span class='curline'><a href='../S/3865.html#L4951'>buffer</a>           4951 test/manual/etags/c-src/etags.c 	    if (strneq (cp, key-&gt;buffer, key-&gt;len))</span>
<span class='curline'><a href='../S/3865.html#L4974'>buffer</a>           4974 test/manual/etags/c-src/etags.c 		    linelen = p - lb.buffer + 1;</span>
<span class='curline'><a href='../S/3865.html#L4977'>buffer</a>           4977 test/manual/etags/c-src/etags.c 			  lb.buffer, linelen, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L5053'>buffer</a>           5053 test/manual/etags/c-src/etags.c 	  TEX_toktab[i].buffer = savenstr (env, p - env);</span>
<span class='curline'><a href='../S/3865.html#L5061'>buffer</a>           5061 test/manual/etags/c-src/etags.c 	  TEX_toktab[i].buffer = NULL; /* Mark end of table. */</span>
<span class='curline'><a href='../S/3865.html#L5081'>buffer</a>           5081 test/manual/etags/c-src/etags.c 		  lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L5146'>buffer</a>           5146 test/manual/etags/c-src/etags.c 		memcpy (token_name.buffer, dbp, end - dbp);</span>
<span class='curline'><a href='../S/3865.html#L5147'>buffer</a>           5147 test/manual/etags/c-src/etags.c 		token_name.buffer[end - dbp] = '\0';</span>
<span class='curline'><a href='../S/3865.html#L5172'>buffer</a>           5172 test/manual/etags/c-src/etags.c 	    make_tag (token_name.buffer, token_name.len, true,</span>
<span class='curline'><a href='../S/3865.html#L5261'>buffer</a>           5261 test/manual/etags/c-src/etags.c       for (cp = plb-&gt;buffer; *cp != '\0'; cp++)</span>
<span class='curline'><a href='../S/3865.html#L5617'>buffer</a>           5617 test/manual/etags/c-src/etags.c 	  analyze_regex (regexbuf.buffer);</span>
<span class='curline'><a href='../S/3865.html#L5618'>buffer</a>           5618 test/manual/etags/c-src/etags.c 	free (regexbuf.buffer);</span>
<span class='curline'><a href='../S/3865.html#L5838'>buffer</a>           5838 test/manual/etags/c-src/etags.c   char *buffer = filebuf.buffer;</span>
<span class='curline'><a href='../S/3865.html#L5860'>buffer</a>           5860 test/manual/etags/c-src/etags.c 	  match = re_search (rp-&gt;pat, buffer, filebuf.len, charno,</span>
<span class='curline'><a href='../S/3865.html#L5891'>buffer</a>           5891 test/manual/etags/c-src/etags.c 		if (buffer[charno++] == '\n')</span>
<span class='curline'><a href='../S/3865.html#L5897'>buffer</a>           5897 test/manual/etags/c-src/etags.c 		name = substitute (buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/3865.html#L5900'>buffer</a>           5900 test/manual/etags/c-src/etags.c 		pfnote (name, true, buffer + linecharno,</span>
<span class='curline'><a href='../S/3865.html#L5903'>buffer</a>           5903 test/manual/etags/c-src/etags.c 		make_tag (name, strlen (name), true, buffer + linecharno,</span>
<span class='curline'><a href='../S/3865.html#L5938'>buffer</a>           5938 test/manual/etags/c-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L5961'>buffer</a>           5961 test/manual/etags/c-src/etags.c   char *buffer = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/3865.html#L5962'>buffer</a>           5962 test/manual/etags/c-src/etags.c   register char *p = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/3865.html#L5975'>buffer</a>           5975 test/manual/etags/c-src/etags.c 	  xrnew (buffer, lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/3865.html#L5976'>buffer</a>           5976 test/manual/etags/c-src/etags.c 	  p += buffer - lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/3865.html#L5977'>buffer</a>           5977 test/manual/etags/c-src/etags.c 	  pend = buffer + lbp-&gt;size;</span>
<span class='curline'><a href='../S/3865.html#L5978'>buffer</a>           5978 test/manual/etags/c-src/etags.c 	  lbp-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/3865.html#L5988'>buffer</a>           5988 test/manual/etags/c-src/etags.c 	  if (p &gt; buffer &amp;&amp; p[-1] == '\r')</span>
<span class='curline'><a href='../S/3865.html#L6011'>buffer</a>           6011 test/manual/etags/c-src/etags.c   lbp-&gt;len = p - buffer;</span>
<span class='curline'><a href='../S/3865.html#L6020'>buffer</a>           6020 test/manual/etags/c-src/etags.c 	  xrnew (filebuf.buffer, filebuf.size, char);</span>
<span class='curline'><a href='../S/3865.html#L6022'>buffer</a>           6022 test/manual/etags/c-src/etags.c       memcpy (filebuf.buffer + filebuf.len, lbp-&gt;buffer, lbp-&gt;len);</span>
<span class='curline'><a href='../S/3865.html#L6024'>buffer</a>           6024 test/manual/etags/c-src/etags.c       filebuf.buffer[filebuf.len++] = '\n';</span>
<span class='curline'><a href='../S/3865.html#L6025'>buffer</a>           6025 test/manual/etags/c-src/etags.c       filebuf.buffer[filebuf.len] = '\0';</span>
<span class='curline'><a href='../S/3865.html#L6052'>buffer</a>           6052 test/manual/etags/c-src/etags.c       if (result &gt; 12 &amp;&amp; strneq (lbp-&gt;buffer, "#line ", 6))</span>
<span class='curline'><a href='../S/3865.html#L6057'>buffer</a>           6057 test/manual/etags/c-src/etags.c 	  if (sscanf (lbp-&gt;buffer, "#line %u \"%n", &amp;lno, &amp;start) &gt;= 1</span>
<span class='curline'><a href='../S/3865.html#L6060'>buffer</a>           6060 test/manual/etags/c-src/etags.c 	      char *endp = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/3865.html#L6073'>buffer</a>           6073 test/manual/etags/c-src/etags.c 		  name = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/3865.html#L6182'>buffer</a>           6182 test/manual/etags/c-src/etags.c 	  match = re_match (rp-&gt;pat, lbp-&gt;buffer, lbp-&gt;len, 0, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/3865.html#L6211'>buffer</a>           6211 test/manual/etags/c-src/etags.c 		name = substitute (lbp-&gt;buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/3865.html#L6214'>buffer</a>           6214 test/manual/etags/c-src/etags.c 		pfnote (name, true, lbp-&gt;buffer, match, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L6217'>buffer</a>           6217 test/manual/etags/c-src/etags.c 			  lbp-&gt;buffer, match, lineno, linecharno);</span>
<span class='curline'><a href='../S/3865.html#L6517'>buffer</a>           6517 test/manual/etags/c-src/etags.c   lbp-&gt;buffer = xnew (lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/3865.html#L6518'>buffer</a>           6518 test/manual/etags/c-src/etags.c   lbp-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/3865.html#L6529'>buffer</a>           6529 test/manual/etags/c-src/etags.c       xrnew (lbp-&gt;buffer, lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/3855.html#L119'>buffer</a>            119 test/manual/etags/c-src/h.h struct re_pattern_buffer { unsigned char *buffer; };</span>
<span class='curline'><a href='../S/3882.html#L88'>buffer</a>             88 test/manual/etags/objc-src/PackInsp.h -subprocess:(Subprocess *)sender output:(char *)buffer;</span>
<span class='curline'><a href='../S/3996.html#L729'>buffer</a>            729 test/src/emacs-module-resources/mod-test.c   char *buffer = length == 0 ? NULL : malloc (length);</span>
<span class='curline'><a href='../S/3996.html#L730'>buffer</a>            730 test/src/emacs-module-resources/mod-test.c   if (buffer == NULL &amp;&amp; length != 0)</span>
<span class='curline'><a href='../S/3996.html#L735'>buffer</a>            735 test/src/emacs-module-resources/mod-test.c   memset (buffer, 'a', length);</span>
<span class='curline'><a href='../S/3996.html#L736'>buffer</a>            736 test/src/emacs-module-resources/mod-test.c   emacs_value ret = multibyte ? env-&gt;make_string (env, buffer, length)</span>
<span class='curline'><a href='../S/3996.html#L737'>buffer</a>            737 test/src/emacs-module-resources/mod-test.c                               : env-&gt;make_unibyte_string (env, buffer, length);</span>
<span class='curline'><a href='../S/3996.html#L738'>buffer</a>            738 test/src/emacs-module-resources/mod-test.c   free (buffer);</span>
</pre>
</body>
</html>
