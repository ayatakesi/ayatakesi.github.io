<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>node</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.7' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/2778.html#L393'>node</a>              393 lib-src/etags.c static void add_node (node *, node **);</span>
<span class='curline'><a href='../S/2778.html#L398'>node</a>              398 lib-src/etags.c static void free_tree (node *);</span>
<span class='curline'><a href='../S/2778.html#L401'>node</a>              401 lib-src/etags.c static void invalidate_nodes (fdesc *, node **);</span>
<span class='curline'><a href='../S/2778.html#L402'>node</a>              402 lib-src/etags.c static void put_entries (node *);</span>
<span class='curline'><a href='../S/2778.html#L449'>node</a>              449 lib-src/etags.c static node *nodehead;		/* the head of the binary tree of tags */</span>
<span class='curline'><a href='../S/2778.html#L450'>node</a>              450 lib-src/etags.c static node *last_node;		/* the last node created */</span>
<span class='curline'><a href='../S/2778.html#L1815'>node</a>             1815 lib-src/etags.c       node *np, *prev;</span>
<span class='curline'><a href='../S/2778.html#L1937'>node</a>             1937 lib-src/etags.c       node *old_last_node = last_node;</span>
<span class='curline'><a href='../S/2778.html#L2074'>node</a>             2074 lib-src/etags.c   register node *np;</span>
<span class='curline'><a href='../S/2778.html#L2083'>node</a>             2083 lib-src/etags.c   np = xnew (1, node);</span>
<span class='curline'><a href='../S/2778.html#L2129'>node</a>             2129 lib-src/etags.c   node *np;</span>
<span class='curline'><a href='../S/2778.html#L2134'>node</a>             2134 lib-src/etags.c push_node (node *np, stkentry **stack_top)</span>
<span class='curline'><a href='../S/2778.html#L2146'>node</a>             2146 lib-src/etags.c static node *</span>
<span class='curline'><a href='../S/2778.html#L2149'>node</a>             2149 lib-src/etags.c   node *ret = NULL;</span>
<span class='curline'><a href='../S/2778.html#L2167'>node</a>             2167 lib-src/etags.c free_tree (register node *np)</span>
<span class='curline'><a href='../S/2778.html#L2180'>node</a>             2180 lib-src/etags.c       node *node_right = np-&gt;right;</span>
<span class='curline'><a href='../S/2778.html#L2226'>node</a>             2226 lib-src/etags.c add_node (node *np, node **cur_node_p)</span>
<span class='curline'><a href='../S/2778.html#L2228'>node</a>             2228 lib-src/etags.c   node *cur_node = *cur_node_p;</span>
<span class='curline'><a href='../S/2778.html#L2286'>node</a>             2286 lib-src/etags.c       node **next_node = &amp;cur_node;</span>
<span class='curline'><a href='../S/2778.html#L2332'>node</a>             2332 lib-src/etags.c invalidate_nodes (fdesc *badfdp, node **npp)</span>
<span class='curline'><a href='../S/2778.html#L2334'>node</a>             2334 lib-src/etags.c   node *np = *npp;</span>
<span class='curline'><a href='../S/2778.html#L2369'>node</a>             2369 lib-src/etags.c       node super_root, *np_parent = NULL;</span>
<span class='curline'><a href='../S/2778.html#L2399'>node</a>             2399 lib-src/etags.c static ptrdiff_t total_size_of_entries (node *);</span>
<span class='curline'><a href='../S/2778.html#L2419'>node</a>             2419 lib-src/etags.c total_size_of_entries (node *np)</span>
<span class='curline'><a href='../S/2778.html#L2439'>node</a>             2439 lib-src/etags.c put_entry (node *np)</span>
<span class='curline'><a href='../S/2778.html#L2512'>node</a>             2512 lib-src/etags.c put_entries (node *np)</span>
<span class='curline'><a href='../S/2782.html#L43'>node</a>               43 lib-src/pop.c  int sys_getaddrinfo (const char * node, const char * service,</span>
<span class='curline'><a href='../S/2782.html#L1604'>node</a>             1604 lib-src/pop.c  sys_getaddrinfo (const char *node, const char *service,</span>
<span class='curline'><a href='../S/2782.html#L1616'>node</a>             1616 lib-src/pop.c      rc = pfn_getaddrinfo (node, service, hints, res);</span>
<span class='curline'><a href='../S/2782.html#L1630'>node</a>             1630 lib-src/pop.c        if (!node)</span>
<span class='curline'><a href='../S/2782.html#L1647'>node</a>             1647 lib-src/pop.c        host_info = gethostbyname (node);</span>
<span class='curline'><a href='../S/2767.html#L41'>node</a>               41 lib/regcomp.c  static reg_errcode_t optimize_subexps (void *extra, bin_tree_t *node);</span>
<span class='curline'><a href='../S/2767.html#L42'>node</a>               42 lib/regcomp.c  static reg_errcode_t lower_subexps (void *extra, bin_tree_t *node);</span>
<span class='curline'><a href='../S/2767.html#L44'>node</a>               44 lib/regcomp.c  				 bin_tree_t *node);</span>
<span class='curline'><a href='../S/2767.html#L45'>node</a>               45 lib/regcomp.c  static reg_errcode_t calc_first (void *extra, bin_tree_t *node);</span>
<span class='curline'><a href='../S/2767.html#L46'>node</a>               46 lib/regcomp.c  static reg_errcode_t calc_next (void *extra, bin_tree_t *node);</span>
<span class='curline'><a href='../S/2767.html#L47'>node</a>               47 lib/regcomp.c  static reg_errcode_t link_nfa_nodes (void *extra, bin_tree_t *node);</span>
<span class='curline'><a href='../S/2767.html#L53'>node</a>               53 lib/regcomp.c  					 Idx node, bool root);</span>
<span class='curline'><a href='../S/2767.html#L110'>node</a>              110 lib/regcomp.c  static void free_token (re_token_t *node);</span>
<span class='curline'><a href='../S/2767.html#L111'>node</a>              111 lib/regcomp.c  static reg_errcode_t free_tree (void *extra, bin_tree_t *node);</span>
<span class='curline'><a href='../S/2767.html#L112'>node</a>              112 lib/regcomp.c  static reg_errcode_t mark_opt_subexp (void *extra, bin_tree_t *node);</span>
<span class='curline'><a href='../S/2767.html#L289'>node</a>              289 lib/regcomp.c        Idx node = init_state-&gt;nodes.elems[node_cnt];</span>
<span class='curline'><a href='../S/2767.html#L290'>node</a>              290 lib/regcomp.c        re_token_type_t type = dfa-&gt;nodes[node].type;</span>
<span class='curline'><a href='../S/2767.html#L294'>node</a>              294 lib/regcomp.c  	  re_set_fastmap (fastmap, icase, dfa-&gt;nodes[node].opr.c);</span>
<span class='curline'><a href='../S/2767.html#L303'>node</a>              303 lib/regcomp.c  	      *p++ = dfa-&gt;nodes[node].opr.c;</span>
<span class='curline'><a href='../S/2767.html#L304'>node</a>              304 lib/regcomp.c  	      while (++node &lt; dfa-&gt;nodes_len</span>
<span class='curline'><a href='../S/2767.html#L305'>node</a>              305 lib/regcomp.c  		     &amp;&amp;	dfa-&gt;nodes[node].type == CHARACTER</span>
<span class='curline'><a href='../S/2767.html#L306'>node</a>              306 lib/regcomp.c  		     &amp;&amp; dfa-&gt;nodes[node].mb_partial)</span>
<span class='curline'><a href='../S/2767.html#L307'>node</a>              307 lib/regcomp.c  		*p++ = dfa-&gt;nodes[node].opr.c;</span>
<span class='curline'><a href='../S/2767.html#L322'>node</a>              322 lib/regcomp.c  	      bitset_word_t w = dfa-&gt;nodes[node].opr.sbcset[i];</span>
<span class='curline'><a href='../S/2767.html#L330'>node</a>              330 lib/regcomp.c  	  re_charset_t *cset = dfa-&gt;nodes[node].opr.mbcset;</span>
<span class='curline'><a href='../S/2767.html#L1048'>node</a>             1048 lib/regcomp.c    Idx node;</span>
<span class='curline'><a href='../S/2767.html#L1053'>node</a>             1053 lib/regcomp.c    for (node = 0; node &lt; dfa-&gt;nodes_len; ++node)</span>
<span class='curline'><a href='../S/2767.html#L1054'>node</a>             1054 lib/regcomp.c      switch (dfa-&gt;nodes[node].type)</span>
<span class='curline'><a href='../S/2767.html#L1057'>node</a>             1057 lib/regcomp.c  	if (dfa-&gt;nodes[node].opr.c &gt;= ASCII_CHARS)</span>
<span class='curline'><a href='../S/2767.html#L1061'>node</a>             1061 lib/regcomp.c  	switch (dfa-&gt;nodes[node].opr.ctx_type)</span>
<span class='curline'><a href='../S/2767.html#L1095'>node</a>             1095 lib/regcomp.c  	      if (dfa-&gt;nodes[node].opr.sbcset[i] &gt;&gt; rshift != 0)</span>
<span class='curline'><a href='../S/2767.html#L1106'>node</a>             1106 lib/regcomp.c      for (node = 0; node &lt; dfa-&gt;nodes_len; ++node)</span>
<span class='curline'><a href='../S/2767.html#L1108'>node</a>             1108 lib/regcomp.c  	if (dfa-&gt;nodes[node].type == CHARACTER</span>
<span class='curline'><a href='../S/2767.html#L1109'>node</a>             1109 lib/regcomp.c  	    &amp;&amp; dfa-&gt;nodes[node].opr.c &gt;= ASCII_CHARS)</span>
<span class='curline'><a href='../S/2767.html#L1110'>node</a>             1110 lib/regcomp.c  	  dfa-&gt;nodes[node].mb_partial = 0;</span>
<span class='curline'><a href='../S/2767.html#L1111'>node</a>             1111 lib/regcomp.c  	else if (dfa-&gt;nodes[node].type == OP_PERIOD)</span>
<span class='curline'><a href='../S/2767.html#L1112'>node</a>             1112 lib/regcomp.c  	  dfa-&gt;nodes[node].type = OP_UTF8_PERIOD;</span>
<span class='curline'><a href='../S/2767.html#L1191'>node</a>             1191 lib/regcomp.c    bin_tree_t *node, *prev;</span>
<span class='curline'><a href='../S/2767.html#L1193'>node</a>             1193 lib/regcomp.c    for (node = root; ; )</span>
<span class='curline'><a href='../S/2767.html#L1197'>node</a>             1197 lib/regcomp.c        while (node-&gt;left || node-&gt;right)</span>
<span class='curline'><a href='../S/2767.html#L1198'>node</a>             1198 lib/regcomp.c  	if (node-&gt;left)</span>
<span class='curline'><a href='../S/2767.html#L1199'>node</a>             1199 lib/regcomp.c  	  node = node-&gt;left;</span>
<span class='curline'><a href='../S/2767.html#L1201'>node</a>             1201 lib/regcomp.c  	  node = node-&gt;right;</span>
<span class='curline'><a href='../S/2767.html#L1205'>node</a>             1205 lib/regcomp.c  	  reg_errcode_t err = fn (extra, node);</span>
<span class='curline'><a href='../S/2767.html#L1208'>node</a>             1208 lib/regcomp.c  	  if (node-&gt;parent == NULL)</span>
<span class='curline'><a href='../S/2767.html#L1210'>node</a>             1210 lib/regcomp.c  	  prev = node;</span>
<span class='curline'><a href='../S/2767.html#L1211'>node</a>             1211 lib/regcomp.c  	  node = node-&gt;parent;</span>
<span class='curline'><a href='../S/2767.html#L1214'>node</a>             1214 lib/regcomp.c        while (node-&gt;right == prev || node-&gt;right == NULL);</span>
<span class='curline'><a href='../S/2767.html#L1215'>node</a>             1215 lib/regcomp.c        node = node-&gt;right;</span>
<span class='curline'><a href='../S/2767.html#L1223'>node</a>             1223 lib/regcomp.c    bin_tree_t *node;</span>
<span class='curline'><a href='../S/2767.html#L1225'>node</a>             1225 lib/regcomp.c    for (node = root; ; )</span>
<span class='curline'><a href='../S/2767.html#L1227'>node</a>             1227 lib/regcomp.c        reg_errcode_t err = fn (extra, node);</span>
<span class='curline'><a href='../S/2767.html#L1232'>node</a>             1232 lib/regcomp.c        if (node-&gt;left)</span>
<span class='curline'><a href='../S/2767.html#L1233'>node</a>             1233 lib/regcomp.c  	node = node-&gt;left;</span>
<span class='curline'><a href='../S/2767.html#L1237'>node</a>             1237 lib/regcomp.c  	  while (node-&gt;right == prev || node-&gt;right == NULL)</span>
<span class='curline'><a href='../S/2767.html#L1239'>node</a>             1239 lib/regcomp.c  	      prev = node;</span>
<span class='curline'><a href='../S/2767.html#L1240'>node</a>             1240 lib/regcomp.c  	      node = node-&gt;parent;</span>
<span class='curline'><a href='../S/2767.html#L1241'>node</a>             1241 lib/regcomp.c  	      if (!node)</span>
<span class='curline'><a href='../S/2767.html#L1244'>node</a>             1244 lib/regcomp.c  	  node = node-&gt;right;</span>
<span class='curline'><a href='../S/2767.html#L1253'>node</a>             1253 lib/regcomp.c  optimize_subexps (void *extra, bin_tree_t *node)</span>
<span class='curline'><a href='../S/2767.html#L1257'>node</a>             1257 lib/regcomp.c    if (node-&gt;token.type == OP_BACK_REF &amp;&amp; dfa-&gt;subexp_map)</span>
<span class='curline'><a href='../S/2767.html#L1259'>node</a>             1259 lib/regcomp.c        int idx = node-&gt;token.opr.idx;</span>
<span class='curline'><a href='../S/2767.html#L1260'>node</a>             1260 lib/regcomp.c        node-&gt;token.opr.idx = dfa-&gt;subexp_map[idx];</span>
<span class='curline'><a href='../S/2767.html#L1261'>node</a>             1261 lib/regcomp.c        dfa-&gt;used_bkref_map |= 1 &lt;&lt; node-&gt;token.opr.idx;</span>
<span class='curline'><a href='../S/2767.html#L1264'>node</a>             1264 lib/regcomp.c    else if (node-&gt;token.type == SUBEXP</span>
<span class='curline'><a href='../S/2767.html#L1265'>node</a>             1265 lib/regcomp.c  	   &amp;&amp; node-&gt;left &amp;&amp; node-&gt;left-&gt;token.type == SUBEXP)</span>
<span class='curline'><a href='../S/2767.html#L1267'>node</a>             1267 lib/regcomp.c        Idx other_idx = node-&gt;left-&gt;token.opr.idx;</span>
<span class='curline'><a href='../S/2767.html#L1269'>node</a>             1269 lib/regcomp.c        node-&gt;left = node-&gt;left-&gt;left;</span>
<span class='curline'><a href='../S/2767.html#L1270'>node</a>             1270 lib/regcomp.c        if (node-&gt;left)</span>
<span class='curline'><a href='../S/2767.html#L1271'>node</a>             1271 lib/regcomp.c  	node-&gt;left-&gt;parent = node;</span>
<span class='curline'><a href='../S/2767.html#L1273'>node</a>             1273 lib/regcomp.c        dfa-&gt;subexp_map[other_idx] = dfa-&gt;subexp_map[node-&gt;token.opr.idx];</span>
<span class='curline'><a href='../S/2767.html#L1284'>node</a>             1284 lib/regcomp.c  lower_subexps (void *extra, bin_tree_t *node)</span>
<span class='curline'><a href='../S/2767.html#L1289'>node</a>             1289 lib/regcomp.c    if (node-&gt;left &amp;&amp; node-&gt;left-&gt;token.type == SUBEXP)</span>
<span class='curline'><a href='../S/2767.html#L1291'>node</a>             1291 lib/regcomp.c        node-&gt;left = lower_subexp (&amp;err, preg, node-&gt;left);</span>
<span class='curline'><a href='../S/2767.html#L1292'>node</a>             1292 lib/regcomp.c        if (node-&gt;left)</span>
<span class='curline'><a href='../S/2767.html#L1293'>node</a>             1293 lib/regcomp.c  	node-&gt;left-&gt;parent = node;</span>
<span class='curline'><a href='../S/2767.html#L1295'>node</a>             1295 lib/regcomp.c    if (node-&gt;right &amp;&amp; node-&gt;right-&gt;token.type == SUBEXP)</span>
<span class='curline'><a href='../S/2767.html#L1297'>node</a>             1297 lib/regcomp.c        node-&gt;right = lower_subexp (&amp;err, preg, node-&gt;right);</span>
<span class='curline'><a href='../S/2767.html#L1298'>node</a>             1298 lib/regcomp.c        if (node-&gt;right)</span>
<span class='curline'><a href='../S/2767.html#L1299'>node</a>             1299 lib/regcomp.c  	node-&gt;right-&gt;parent = node;</span>
<span class='curline'><a href='../S/2767.html#L1306'>node</a>             1306 lib/regcomp.c  lower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)</span>
<span class='curline'><a href='../S/2767.html#L1309'>node</a>             1309 lib/regcomp.c    bin_tree_t *body = node-&gt;left;</span>
<span class='curline'><a href='../S/2767.html#L1317'>node</a>             1317 lib/regcomp.c        &amp;&amp; node-&gt;left != NULL</span>
<span class='curline'><a href='../S/2767.html#L1318'>node</a>             1318 lib/regcomp.c        &amp;&amp; (node-&gt;token.opr.idx &gt;= BITSET_WORD_BITS</span>
<span class='curline'><a href='../S/2767.html#L1320'>node</a>             1320 lib/regcomp.c  	       &amp; ((bitset_word_t) 1 &lt;&lt; node-&gt;token.opr.idx))))</span>
<span class='curline'><a href='../S/2767.html#L1321'>node</a>             1321 lib/regcomp.c      return node-&gt;left;</span>
<span class='curline'><a href='../S/2767.html#L1336'>node</a>             1336 lib/regcomp.c    op-&gt;token.opr.idx = cls-&gt;token.opr.idx = node-&gt;token.opr.idx;</span>
<span class='curline'><a href='../S/2767.html#L1337'>node</a>             1337 lib/regcomp.c    op-&gt;token.opt_subexp = cls-&gt;token.opt_subexp = node-&gt;token.opt_subexp;</span>
<span class='curline'><a href='../S/2767.html#L1344'>node</a>             1344 lib/regcomp.c  calc_first (void *extra, bin_tree_t *node)</span>
<span class='curline'><a href='../S/2767.html#L1347'>node</a>             1347 lib/regcomp.c    if (node-&gt;token.type == CONCAT)</span>
<span class='curline'><a href='../S/2767.html#L1349'>node</a>             1349 lib/regcomp.c        node-&gt;first = node-&gt;left-&gt;first;</span>
<span class='curline'><a href='../S/2767.html#L1350'>node</a>             1350 lib/regcomp.c        node-&gt;node_idx = node-&gt;left-&gt;node_idx;</span>
<span class='curline'><a href='../S/2767.html#L1354'>node</a>             1354 lib/regcomp.c        node-&gt;first = node;</span>
<span class='curline'><a href='../S/2767.html#L1355'>node</a>             1355 lib/regcomp.c        node-&gt;node_idx = re_dfa_add_node (dfa, node-&gt;token);</span>
<span class='curline'><a href='../S/2767.html#L1356'>node</a>             1356 lib/regcomp.c        if (__glibc_unlikely (node-&gt;node_idx == -1))</span>
<span class='curline'><a href='../S/2767.html#L1358'>node</a>             1358 lib/regcomp.c        if (node-&gt;token.type == ANCHOR)</span>
<span class='curline'><a href='../S/2767.html#L1359'>node</a>             1359 lib/regcomp.c  	dfa-&gt;nodes[node-&gt;node_idx].constraint = node-&gt;token.opr.ctx_type;</span>
<span class='curline'><a href='../S/2767.html#L1366'>node</a>             1366 lib/regcomp.c  calc_next (void *extra, bin_tree_t *node)</span>
<span class='curline'><a href='../S/2767.html#L1368'>node</a>             1368 lib/regcomp.c    switch (node-&gt;token.type)</span>
<span class='curline'><a href='../S/2767.html#L1371'>node</a>             1371 lib/regcomp.c        node-&gt;left-&gt;next = node;</span>
<span class='curline'><a href='../S/2767.html#L1374'>node</a>             1374 lib/regcomp.c        node-&gt;left-&gt;next = node-&gt;right-&gt;first;</span>
<span class='curline'><a href='../S/2767.html#L1375'>node</a>             1375 lib/regcomp.c        node-&gt;right-&gt;next = node-&gt;next;</span>
<span class='curline'><a href='../S/2767.html#L1378'>node</a>             1378 lib/regcomp.c        if (node-&gt;left)</span>
<span class='curline'><a href='../S/2767.html#L1379'>node</a>             1379 lib/regcomp.c  	node-&gt;left-&gt;next = node-&gt;next;</span>
<span class='curline'><a href='../S/2767.html#L1380'>node</a>             1380 lib/regcomp.c        if (node-&gt;right)</span>
<span class='curline'><a href='../S/2767.html#L1381'>node</a>             1381 lib/regcomp.c  	node-&gt;right-&gt;next = node-&gt;next;</span>
<span class='curline'><a href='../S/2767.html#L1389'>node</a>             1389 lib/regcomp.c  link_nfa_nodes (void *extra, bin_tree_t *node)</span>
<span class='curline'><a href='../S/2767.html#L1392'>node</a>             1392 lib/regcomp.c    Idx idx = node-&gt;node_idx;</span>
<span class='curline'><a href='../S/2767.html#L1395'>node</a>             1395 lib/regcomp.c    switch (node-&gt;token.type)</span>
<span class='curline'><a href='../S/2767.html#L1401'>node</a>             1401 lib/regcomp.c        DEBUG_ASSERT (node-&gt;next == NULL);</span>
<span class='curline'><a href='../S/2767.html#L1409'>node</a>             1409 lib/regcomp.c  	if (node-&gt;left != NULL)</span>
<span class='curline'><a href='../S/2767.html#L1410'>node</a>             1410 lib/regcomp.c  	  left = node-&gt;left-&gt;first-&gt;node_idx;</span>
<span class='curline'><a href='../S/2767.html#L1412'>node</a>             1412 lib/regcomp.c  	  left = node-&gt;next-&gt;node_idx;</span>
<span class='curline'><a href='../S/2767.html#L1413'>node</a>             1413 lib/regcomp.c  	if (node-&gt;right != NULL)</span>
<span class='curline'><a href='../S/2767.html#L1414'>node</a>             1414 lib/regcomp.c  	  right = node-&gt;right-&gt;first-&gt;node_idx;</span>
<span class='curline'><a href='../S/2767.html#L1416'>node</a>             1416 lib/regcomp.c  	  right = node-&gt;next-&gt;node_idx;</span>
<span class='curline'><a href='../S/2767.html#L1426'>node</a>             1426 lib/regcomp.c        err = re_node_set_init_1 (dfa-&gt;edests + idx, node-&gt;next-&gt;node_idx);</span>
<span class='curline'><a href='../S/2767.html#L1430'>node</a>             1430 lib/regcomp.c        dfa-&gt;nexts[idx] = node-&gt;next-&gt;node_idx;</span>
<span class='curline'><a href='../S/2767.html#L1431'>node</a>             1431 lib/regcomp.c        if (node-&gt;token.type == OP_BACK_REF)</span>
<span class='curline'><a href='../S/2767.html#L1436'>node</a>             1436 lib/regcomp.c        DEBUG_ASSERT (!IS_EPSILON_NODE (node-&gt;token.type));</span>
<span class='curline'><a href='../S/2767.html#L1437'>node</a>             1437 lib/regcomp.c        dfa-&gt;nexts[idx] = node-&gt;next-&gt;node_idx;</span>
<span class='curline'><a href='../S/2767.html#L1655'>node</a>             1655 lib/regcomp.c  calc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, Idx node, bool root)</span>
<span class='curline'><a href='../S/2767.html#L1661'>node</a>             1661 lib/regcomp.c    err = re_node_set_alloc (&amp;eclosure, dfa-&gt;edests[node].nelem + 1);</span>
<span class='curline'><a href='../S/2767.html#L1666'>node</a>             1666 lib/regcomp.c    eclosure.elems[eclosure.nelem++] = node;</span>
<span class='curline'><a href='../S/2767.html#L1670'>node</a>             1670 lib/regcomp.c    dfa-&gt;eclosures[node].nelem = -1;</span>
<span class='curline'><a href='../S/2767.html#L1674'>node</a>             1674 lib/regcomp.c    if (dfa-&gt;nodes[node].constraint</span>
<span class='curline'><a href='../S/2767.html#L1675'>node</a>             1675 lib/regcomp.c        &amp;&amp; dfa-&gt;edests[node].nelem</span>
<span class='curline'><a href='../S/2767.html#L1676'>node</a>             1676 lib/regcomp.c        &amp;&amp; !dfa-&gt;nodes[dfa-&gt;edests[node].elems[0]].duplicated)</span>
<span class='curline'><a href='../S/2767.html#L1678'>node</a>             1678 lib/regcomp.c        err = duplicate_node_closure (dfa, node, node, node,</span>
<span class='curline'><a href='../S/2767.html#L1679'>node</a>             1679 lib/regcomp.c  				    dfa-&gt;nodes[node].constraint);</span>
<span class='curline'><a href='../S/2767.html#L1685'>node</a>             1685 lib/regcomp.c    if (IS_EPSILON_NODE(dfa-&gt;nodes[node].type))</span>
<span class='curline'><a href='../S/2767.html#L1686'>node</a>             1686 lib/regcomp.c      for (i = 0; i &lt; dfa-&gt;edests[node].nelem; ++i)</span>
<span class='curline'><a href='../S/2767.html#L1689'>node</a>             1689 lib/regcomp.c  	Idx edest = dfa-&gt;edests[node].elems[i];</span>
<span class='curline'><a href='../S/2767.html#L1721'>node</a>             1721 lib/regcomp.c      dfa-&gt;eclosures[node].nelem = 0;</span>
<span class='curline'><a href='../S/2767.html#L1723'>node</a>             1723 lib/regcomp.c      dfa-&gt;eclosures[node] = eclosure;</span>
<span class='curline'><a href='../S/2767.html#L3714'>node</a>             3714 lib/regcomp.c  mark_opt_subexp (void *extra, bin_tree_t *node)</span>
<span class='curline'><a href='../S/2767.html#L3717'>node</a>             3717 lib/regcomp.c    if (node-&gt;token.type == SUBEXP &amp;&amp; node-&gt;token.opr.idx == idx)</span>
<span class='curline'><a href='../S/2767.html#L3718'>node</a>             3718 lib/regcomp.c      node-&gt;token.opt_subexp = 1;</span>
<span class='curline'><a href='../S/2767.html#L3726'>node</a>             3726 lib/regcomp.c  free_token (re_token_t *node)</span>
<span class='curline'><a href='../S/2767.html#L3728'>node</a>             3728 lib/regcomp.c    if (node-&gt;type == COMPLEX_BRACKET &amp;&amp; node-&gt;duplicated == 0)</span>
<span class='curline'><a href='../S/2767.html#L3729'>node</a>             3729 lib/regcomp.c      free_charset (node-&gt;opr.mbcset);</span>
<span class='curline'><a href='../S/2767.html#L3730'>node</a>             3730 lib/regcomp.c    else if (node-&gt;type == SIMPLE_BRACKET &amp;&amp; node-&gt;duplicated == 0)</span>
<span class='curline'><a href='../S/2767.html#L3731'>node</a>             3731 lib/regcomp.c      re_free (node-&gt;opr.sbcset);</span>
<span class='curline'><a href='../S/2767.html#L3738'>node</a>             3738 lib/regcomp.c  free_tree (void *extra, bin_tree_t *node)</span>
<span class='curline'><a href='../S/2767.html#L3740'>node</a>             3740 lib/regcomp.c    free_token (&amp;node-&gt;token);</span>
<span class='curline'><a href='../S/2767.html#L3753'>node</a>             3753 lib/regcomp.c    const bin_tree_t *node;</span>
<span class='curline'><a href='../S/2767.html#L3757'>node</a>             3757 lib/regcomp.c    for (node = root; ; )</span>
<span class='curline'><a href='../S/2767.html#L3760'>node</a>             3760 lib/regcomp.c        *p_new = create_token_tree (dfa, NULL, NULL, &amp;node-&gt;token);</span>
<span class='curline'><a href='../S/2767.html#L3768'>node</a>             3768 lib/regcomp.c        if (node-&gt;left)</span>
<span class='curline'><a href='../S/2767.html#L3770'>node</a>             3770 lib/regcomp.c  	  node = node-&gt;left;</span>
<span class='curline'><a href='../S/2767.html#L3776'>node</a>             3776 lib/regcomp.c  	  while (node-&gt;right == prev || node-&gt;right == NULL)</span>
<span class='curline'><a href='../S/2767.html#L3778'>node</a>             3778 lib/regcomp.c  	      prev = node;</span>
<span class='curline'><a href='../S/2767.html#L3779'>node</a>             3779 lib/regcomp.c  	      node = node-&gt;parent;</span>
<span class='curline'><a href='../S/2767.html#L3781'>node</a>             3781 lib/regcomp.c  	      if (!node)</span>
<span class='curline'><a href='../S/2767.html#L3784'>node</a>             3784 lib/regcomp.c  	  node = node-&gt;right;</span>
<span class='curline'><a href='../S/2596.html#L1612'>node</a>             1612 lib/regex_internal.c       re_token_t *node = dfa-&gt;nodes + nodes-&gt;elems[i];</span>
<span class='curline'><a href='../S/2596.html#L1613'>node</a>             1613 lib/regex_internal.c       re_token_type_t type = node-&gt;type;</span>
<span class='curline'><a href='../S/2596.html#L1614'>node</a>             1614 lib/regex_internal.c       if (type == CHARACTER &amp;&amp; !node-&gt;constraint)</span>
<span class='curline'><a href='../S/2596.html#L1616'>node</a>             1616 lib/regex_internal.c       newstate-&gt;accept_mb |= node-&gt;accept_mb;</span>
<span class='curline'><a href='../S/2596.html#L1623'>node</a>             1623 lib/regex_internal.c       else if (type == ANCHOR || node-&gt;constraint)</span>
<span class='curline'><a href='../S/2596.html#L1662'>node</a>             1662 lib/regex_internal.c       re_token_t *node = dfa-&gt;nodes + nodes-&gt;elems[i];</span>
<span class='curline'><a href='../S/2596.html#L1663'>node</a>             1663 lib/regex_internal.c       re_token_type_t type = node-&gt;type;</span>
<span class='curline'><a href='../S/2596.html#L1664'>node</a>             1664 lib/regex_internal.c       unsigned int constraint = node-&gt;constraint;</span>
<span class='curline'><a href='../S/2596.html#L1668'>node</a>             1668 lib/regex_internal.c       newstate-&gt;accept_mb |= node-&gt;accept_mb;</span>
<span class='curline'><a href='../S/2551.html#L550'>node</a>              550 lib/regex_internal.h   Idx node;</span>
<span class='curline'><a href='../S/2551.html#L562'>node</a>              562 lib/regex_internal.h   Idx node;</span>
<span class='curline'><a href='../S/2551.html#L571'>node</a>              571 lib/regex_internal.h   Idx node;</span>
<span class='curline'><a href='../S/2551.html#L614'>node</a>              614 lib/regex_internal.h   Idx node;</span>
<span class='curline'><a href='../S/2747.html#L24'>node</a>               24 lib/regexec.c  static reg_errcode_t match_ctx_add_entry (re_match_context_t *cache, Idx node,</span>
<span class='curline'><a href='../S/2747.html#L27'>node</a>               27 lib/regexec.c  static reg_errcode_t match_ctx_add_subtop (re_match_context_t *mctx, Idx node,</span>
<span class='curline'><a href='../S/2747.html#L30'>node</a>               30 lib/regexec.c  						    Idx node, Idx str_idx);</span>
<span class='curline'><a href='../S/2747.html#L94'>node</a>               94 lib/regexec.c  				      Idx node, Idx str_idx,</span>
<span class='curline'><a href='../S/2747.html#L166'>node</a>              166 lib/regexec.c  			       const re_token_t *node, Idx idx);</span>
<span class='curline'><a href='../S/2747.html#L1162'>node</a>             1162 lib/regexec.c  check_halt_node_context (const re_dfa_t *dfa, Idx node, unsigned int context)</span>
<span class='curline'><a href='../S/2747.html#L1164'>node</a>             1164 lib/regexec.c    re_token_type_t type = dfa-&gt;nodes[node].type;</span>
<span class='curline'><a href='../S/2747.html#L1165'>node</a>             1165 lib/regexec.c    unsigned int constraint = dfa-&gt;nodes[node].constraint;</span>
<span class='curline'><a href='../S/2747.html#L1201'>node</a>             1201 lib/regexec.c  		   Idx *pidx, Idx node, re_node_set *eps_via_nodes,</span>
<span class='curline'><a href='../S/2747.html#L1205'>node</a>             1205 lib/regexec.c    if (IS_EPSILON_NODE (dfa-&gt;nodes[node].type))</span>
<span class='curline'><a href='../S/2747.html#L1208'>node</a>             1208 lib/regexec.c        re_node_set *edests = &amp;dfa-&gt;edests[node];</span>
<span class='curline'><a href='../S/2747.html#L1210'>node</a>             1210 lib/regexec.c        if (! re_node_set_contains (eps_via_nodes, node))</span>
<span class='curline'><a href='../S/2747.html#L1212'>node</a>             1212 lib/regexec.c            bool ok = re_node_set_insert (eps_via_nodes, node);</span>
<span class='curline'><a href='../S/2747.html#L1249'>node</a>             1249 lib/regexec.c        re_token_type_t type = dfa-&gt;nodes[node].type;</span>
<span class='curline'><a href='../S/2747.html#L1251'>node</a>             1251 lib/regexec.c        if (dfa-&gt;nodes[node].accept_mb)</span>
<span class='curline'><a href='../S/2747.html#L1252'>node</a>             1252 lib/regexec.c  	naccepted = check_node_accept_bytes (dfa, node, &amp;mctx-&gt;input, *pidx);</span>
<span class='curline'><a href='../S/2747.html#L1255'>node</a>             1255 lib/regexec.c  	  Idx subexp_idx = dfa-&gt;nodes[node].opr.idx + 1;</span>
<span class='curline'><a href='../S/2747.html#L1278'>node</a>             1278 lib/regexec.c  	      bool ok = re_node_set_insert (eps_via_nodes, node);</span>
<span class='curline'><a href='../S/2747.html#L1281'>node</a>             1281 lib/regexec.c  	      dest_node = dfa-&gt;edests[node].elems[0];</span>
<span class='curline'><a href='../S/2747.html#L1289'>node</a>             1289 lib/regexec.c  	  || check_node_accept (mctx, dfa-&gt;nodes + node, *pidx))</span>
<span class='curline'><a href='../S/2747.html#L1291'>node</a>             1291 lib/regexec.c  	  Idx dest_node = dfa-&gt;nexts[node];</span>
<span class='curline'><a href='../S/2747.html#L1323'>node</a>             1323 lib/regexec.c    fs-&gt;stack[num].node = dest_node;</span>
<span class='curline'><a href='../S/2747.html#L1348'>node</a>             1348 lib/regexec.c    DEBUG_ASSERT (0 &lt;= fs-&gt;stack[num].node);</span>
<span class='curline'><a href='../S/2747.html#L1349'>node</a>             1349 lib/regexec.c    return fs-&gt;stack[num].node;</span>
<span class='curline'><a href='../S/2747.html#L1541'>node</a>             1541 lib/regexec.c  #define STATE_NODE_CONTAINS(state,node) \</span>
<span class='curline'><a href='../S/2747.html#L1542'>node</a>             1542 lib/regexec.c    ((state) != NULL &amp;&amp; re_node_set_contains (&amp;(state)-&gt;nodes, node))</span>
<span class='curline'><a href='../S/2747.html#L1785'>node</a>             1785 lib/regexec.c  sub_epsilon_src_nodes (const re_dfa_t *dfa, Idx node, re_node_set *dest_nodes,</span>
<span class='curline'><a href='../S/2747.html#L1790'>node</a>             1790 lib/regexec.c      re_node_set *inv_eclosure = dfa-&gt;inveclosures + node;</span>
<span class='curline'><a href='../S/2747.html#L1796'>node</a>             1796 lib/regexec.c  	if (cur_node == node)</span>
<span class='curline'><a href='../S/2747.html#L1846'>node</a>             1846 lib/regexec.c        subexp_idx = dfa-&gt;nodes[ent-&gt;node].opr.idx;</span>
<span class='curline'><a href='../S/2747.html#L1879'>node</a>             1879 lib/regexec.c        Idx node = eclosures-&gt;elems[node_idx];</span>
<span class='curline'><a href='../S/2747.html#L1880'>node</a>             1880 lib/regexec.c        switch (dfa-&gt;nodes[node].type)</span>
<span class='curline'><a href='../S/2747.html#L1891'>node</a>             1891 lib/regexec.c  		  if (ent-&gt;node != node)</span>
<span class='curline'><a href='../S/2747.html#L1905'>node</a>             1905 lib/regexec.c  		  dst = dfa-&gt;edests[node].elems[0];</span>
<span class='curline'><a href='../S/2747.html#L1931'>node</a>             1931 lib/regexec.c  	  if ((boundaries &amp; 1) &amp;&amp; subexp_idx == dfa-&gt;nodes[node].opr.idx)</span>
<span class='curline'><a href='../S/2747.html#L1936'>node</a>             1936 lib/regexec.c  	  if ((boundaries &amp; 2) &amp;&amp; subexp_idx == dfa-&gt;nodes[node].opr.idx)</span>
<span class='curline'><a href='../S/2747.html#L1994'>node</a>             1994 lib/regexec.c        subexp_idx = dfa-&gt;nodes[ent-&gt;node].opr.idx;</span>
<span class='curline'><a href='../S/2747.html#L2001'>node</a>             2001 lib/regexec.c  	      Idx node = dest_nodes-&gt;elems[node_idx];</span>
<span class='curline'><a href='../S/2747.html#L2002'>node</a>             2002 lib/regexec.c  	      re_token_type_t type = dfa-&gt;nodes[node].type;</span>
<span class='curline'><a href='../S/2747.html#L2004'>node</a>             2004 lib/regexec.c  		  &amp;&amp; subexp_idx == dfa-&gt;nodes[node].opr.idx)</span>
<span class='curline'><a href='../S/2747.html#L2005'>node</a>             2005 lib/regexec.c  		ops_node = node;</span>
<span class='curline'><a href='../S/2747.html#L2007'>node</a>             2007 lib/regexec.c  		       &amp;&amp; subexp_idx == dfa-&gt;nodes[node].opr.idx)</span>
<span class='curline'><a href='../S/2747.html#L2008'>node</a>             2008 lib/regexec.c  		cls_node = node;</span>
<span class='curline'><a href='../S/2747.html#L2025'>node</a>             2025 lib/regexec.c  		Idx node = dest_nodes-&gt;elems[node_idx];</span>
<span class='curline'><a href='../S/2747.html#L2026'>node</a>             2026 lib/regexec.c  		if (!re_node_set_contains (dfa-&gt;inveclosures + node,</span>
<span class='curline'><a href='../S/2747.html#L2028'>node</a>             2028 lib/regexec.c  		    &amp;&amp; !re_node_set_contains (dfa-&gt;eclosures + node,</span>
<span class='curline'><a href='../S/2747.html#L2033'>node</a>             2033 lib/regexec.c  		    err = sub_epsilon_src_nodes (dfa, node, dest_nodes,</span>
<span class='curline'><a href='../S/2747.html#L2045'>node</a>             2045 lib/regexec.c  	      Idx node = dest_nodes-&gt;elems[node_idx];</span>
<span class='curline'><a href='../S/2747.html#L2046'>node</a>             2046 lib/regexec.c  	      re_token_type_t type = dfa-&gt;nodes[node].type;</span>
<span class='curline'><a href='../S/2747.html#L2049'>node</a>             2049 lib/regexec.c  		  if (subexp_idx != dfa-&gt;nodes[node].opr.idx)</span>
<span class='curline'><a href='../S/2747.html#L2053'>node</a>             2053 lib/regexec.c  		  err = sub_epsilon_src_nodes (dfa, node, dest_nodes,</span>
<span class='curline'><a href='../S/2747.html#L2071'>node</a>             2071 lib/regexec.c    Idx node_idx, node;</span>
<span class='curline'><a href='../S/2747.html#L2085'>node</a>             2085 lib/regexec.c        node = candidates-&gt;elems[node_idx];</span>
<span class='curline'><a href='../S/2747.html#L2086'>node</a>             2086 lib/regexec.c        type = dfa-&gt;nodes[node].type;</span>
<span class='curline'><a href='../S/2747.html#L2088'>node</a>             2088 lib/regexec.c        if (node == sctx-&gt;last_node &amp;&amp; str_idx == sctx-&gt;last_str_idx)</span>
<span class='curline'><a href='../S/2747.html#L2103'>node</a>             2103 lib/regexec.c  	  if (entry-&gt;node != node)</span>
<span class='curline'><a href='../S/2747.html#L2107'>node</a>             2107 lib/regexec.c  	  dst_node = (subexp_len ? dfa-&gt;nexts[node]</span>
<span class='curline'><a href='../S/2747.html#L2108'>node</a>             2108 lib/regexec.c  		      : dfa-&gt;edests[node].elems[0]);</span>
<span class='curline'><a href='../S/2747.html#L2113'>node</a>             2113 lib/regexec.c  	      || check_dst_limits (mctx, &amp;sctx-&gt;limits, node,</span>
<span class='curline'><a href='../S/2747.html#L2124'>node</a>             2124 lib/regexec.c  	  local_sctx.last_node = node;</span>
<span class='curline'><a href='../S/2747.html#L2370'>node</a>             2370 lib/regexec.c        Idx node = cur_nodes-&gt;elems[node_idx];</span>
<span class='curline'><a href='../S/2747.html#L2371'>node</a>             2371 lib/regexec.c        if (dfa-&gt;nodes[node].type == OP_OPEN_SUBEXP</span>
<span class='curline'><a href='../S/2747.html#L2372'>node</a>             2372 lib/regexec.c  	  &amp;&amp; dfa-&gt;nodes[node].opr.idx &lt; BITSET_WORD_BITS</span>
<span class='curline'><a href='../S/2747.html#L2374'>node</a>             2374 lib/regexec.c  	      &amp; ((bitset_word_t) 1 &lt;&lt; dfa-&gt;nodes[node].opr.idx)))</span>
<span class='curline'><a href='../S/2747.html#L2376'>node</a>             2376 lib/regexec.c  	  err = match_ctx_add_subtop (mctx, node, str_idx);</span>
<span class='curline'><a href='../S/2747.html#L2507'>node</a>             2507 lib/regexec.c        const re_token_t *node = dfa-&gt;nodes + node_idx;</span>
<span class='curline'><a href='../S/2747.html#L2511'>node</a>             2511 lib/regexec.c        if (node-&gt;type != OP_BACK_REF)</span>
<span class='curline'><a href='../S/2747.html#L2514'>node</a>             2514 lib/regexec.c        if (node-&gt;constraint)</span>
<span class='curline'><a href='../S/2747.html#L2518'>node</a>             2518 lib/regexec.c  	  if (NOT_SATISFY_NEXT_CONSTRAINT (node-&gt;constraint, context))</span>
<span class='curline'><a href='../S/2747.html#L2538'>node</a>             2538 lib/regexec.c  	  if (bkref_ent-&gt;node != node_idx || bkref_ent-&gt;str_idx != cur_str_idx)</span>
<span class='curline'><a href='../S/2747.html#L2619'>node</a>             2619 lib/regexec.c  	if (entry-&gt;node == bkref_node)</span>
<span class='curline'><a href='../S/2747.html#L2634'>node</a>             2634 lib/regexec.c        if (dfa-&gt;nodes[sub_top-&gt;node].opr.idx != subexp_num)</span>
<span class='curline'><a href='../S/2747.html#L2731'>node</a>             2731 lib/regexec.c  	  err = check_arrival (mctx, sub_top-&gt;path, sub_top-&gt;node,</span>
<span class='curline'><a href='../S/2747.html#L2766'>node</a>             2766 lib/regexec.c    err = check_arrival (mctx, &amp;sub_last-&gt;path, sub_last-&gt;node,</span>
<span class='curline'><a href='../S/2747.html#L2795'>node</a>             2795 lib/regexec.c        const re_token_t *node = dfa-&gt;nodes + cls_node;</span>
<span class='curline'><a href='../S/2747.html#L2796'>node</a>             2796 lib/regexec.c        if (node-&gt;type == type</span>
<span class='curline'><a href='../S/2747.html#L2797'>node</a>             2797 lib/regexec.c  	  &amp;&amp; node-&gt;opr.idx == subexp_idx)</span>
<span class='curline'><a href='../S/2747.html#L3165'>node</a>             3165 lib/regexec.c        if (!re_node_set_contains (cur_nodes, ent-&gt;node))</span>
<span class='curline'><a href='../S/2747.html#L3177'>node</a>             3177 lib/regexec.c  	  next_node = dfa-&gt;edests[ent-&gt;node].elems[0];</span>
<span class='curline'><a href='../S/2747.html#L3197'>node</a>             3197 lib/regexec.c  	  next_node = dfa-&gt;nexts[ent-&gt;node];</span>
<span class='curline'><a href='../S/2747.html#L3439'>node</a>             3439 lib/regexec.c        re_token_t *node = &amp;dfa-&gt;nodes[cur_nodes-&gt;elems[i]];</span>
<span class='curline'><a href='../S/2747.html#L3440'>node</a>             3440 lib/regexec.c        re_token_type_t type = node-&gt;type;</span>
<span class='curline'><a href='../S/2747.html#L3441'>node</a>             3441 lib/regexec.c        unsigned int constraint = node-&gt;constraint;</span>
<span class='curline'><a href='../S/2747.html#L3445'>node</a>             3445 lib/regexec.c  	bitset_set (accepts, node-&gt;opr.c);</span>
<span class='curline'><a href='../S/2747.html#L3448'>node</a>             3448 lib/regexec.c  	  bitset_merge (accepts, node-&gt;opr.sbcset);</span>
<span class='curline'><a href='../S/2747.html#L3497'>node</a>             3497 lib/regexec.c  	      if (type == CHARACTER &amp;&amp; !node-&gt;word_char)</span>
<span class='curline'><a href='../S/2747.html#L3514'>node</a>             3514 lib/regexec.c  	      if (type == CHARACTER &amp;&amp; node-&gt;word_char)</span>
<span class='curline'><a href='../S/2747.html#L3540'>node</a>             3540 lib/regexec.c  	  if (type == CHARACTER &amp;&amp; !bitset_contain (dests_ch[j], node-&gt;opr.c))</span>
<span class='curline'><a href='../S/2747.html#L3615'>node</a>             3615 lib/regexec.c    const re_token_t *node = dfa-&gt;nodes + node_idx;</span>
<span class='curline'><a href='../S/2747.html#L3619'>node</a>             3619 lib/regexec.c    if (__glibc_unlikely (node-&gt;type == OP_UTF8_PERIOD))</span>
<span class='curline'><a href='../S/2747.html#L3671'>node</a>             3671 lib/regexec.c    if (node-&gt;type == OP_PERIOD)</span>
<span class='curline'><a href='../S/2747.html#L3690'>node</a>             3690 lib/regexec.c    if (node-&gt;type == COMPLEX_BRACKET)</span>
<span class='curline'><a href='../S/2747.html#L3692'>node</a>             3692 lib/regexec.c        const re_charset_t *cset = node-&gt;opr.mbcset;</span>
<span class='curline'><a href='../S/2747.html#L3900'>node</a>             3900 lib/regexec.c  check_node_accept (const re_match_context_t *mctx, const re_token_t *node,</span>
<span class='curline'><a href='../S/2747.html#L3905'>node</a>             3905 lib/regexec.c    switch (node-&gt;type)</span>
<span class='curline'><a href='../S/2747.html#L3908'>node</a>             3908 lib/regexec.c        if (node-&gt;opr.c != ch)</span>
<span class='curline'><a href='../S/2747.html#L3913'>node</a>             3913 lib/regexec.c        if (!bitset_contain (node-&gt;opr.sbcset, ch))</span>
<span class='curline'><a href='../S/2747.html#L3931'>node</a>             3931 lib/regexec.c    if (node-&gt;constraint)</span>
<span class='curline'><a href='../S/2747.html#L3937'>node</a>             3937 lib/regexec.c        if (NOT_SATISFY_NEXT_CONSTRAINT (node-&gt;constraint, context))</span>
<span class='curline'><a href='../S/2747.html#L4088'>node</a>             4088 lib/regexec.c  match_ctx_add_entry (re_match_context_t *mctx, Idx node, Idx str_idx, Idx from,</span>
<span class='curline'><a href='../S/2747.html#L4110'>node</a>             4110 lib/regexec.c    mctx-&gt;bkref_ents[mctx-&gt;nbkref_ents].node = node;</span>
<span class='curline'><a href='../S/2747.html#L4159'>node</a>             4159 lib/regexec.c  match_ctx_add_subtop (re_match_context_t *mctx, Idx node, Idx str_idx)</span>
<span class='curline'><a href='../S/2747.html#L4177'>node</a>             4177 lib/regexec.c    mctx-&gt;sub_tops[mctx-&gt;nsub_tops]-&gt;node = node;</span>
<span class='curline'><a href='../S/2747.html#L4187'>node</a>             4187 lib/regexec.c  match_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)</span>
<span class='curline'><a href='../S/2747.html#L4205'>node</a>             4205 lib/regexec.c        new_entry-&gt;node = node;</span>
<span class='curline'><a href='../S/28.html#L133'>node</a>              133 nt/inc/sys/socket.h int sys_getaddrinfo (const char * node, const char * service,</span>
<span class='curline'><a href='../S/2238.html#L3937'>node</a>             3937 src/alloc.c      struct itree_node *node = xmalloc (sizeof (*node));</span>
<span class='curline'><a href='../S/2238.html#L3938'>node</a>             3938 src/alloc.c      itree_node_init (node, front_advance, rear_advance, overlay);</span>
<span class='curline'><a href='../S/2238.html#L3939'>node</a>             3939 src/alloc.c      p-&gt;interval = node;</span>
<span class='curline'><a href='../S/2238.html#L6767'>node</a>             6767 src/alloc.c    mark_overlays (struct itree_node *node)</span>
<span class='curline'><a href='../S/2238.html#L6769'>node</a>             6769 src/alloc.c      if (node == NULL)</span>
<span class='curline'><a href='../S/2238.html#L6771'>node</a>             6771 src/alloc.c      mark_object (node-&gt;data);</span>
<span class='curline'><a href='../S/2238.html#L6772'>node</a>             6772 src/alloc.c      mark_overlays (node-&gt;left);</span>
<span class='curline'><a href='../S/2238.html#L6773'>node</a>             6773 src/alloc.c      mark_overlays (node-&gt;right);</span>
<span class='curline'><a href='../S/2049.html#L672'>node</a>              672 src/buffer.c     struct itree_node *node;</span>
<span class='curline'><a href='../S/2049.html#L674'>node</a>              674 src/buffer.c     ITREE_FOREACH (node, from-&gt;overlays, PTRDIFF_MIN, PTRDIFF_MAX, ASCENDING)</span>
<span class='curline'><a href='../S/2049.html#L676'>node</a>              676 src/buffer.c         Lisp_Object ov = node-&gt;data;</span>
<span class='curline'><a href='../S/2049.html#L677'>node</a>              677 src/buffer.c         Lisp_Object copy = build_overlay (node-&gt;front_advance,</span>
<span class='curline'><a href='../S/2049.html#L678'>node</a>              678 src/buffer.c                                           node-&gt;rear_advance,</span>
<span class='curline'><a href='../S/2049.html#L680'>node</a>              680 src/buffer.c         add_buffer_overlay (to, XOVERLAY (copy), node-&gt;begin, node-&gt;end);</span>
<span class='curline'><a href='../S/2049.html#L949'>node</a>              949 src/buffer.c     struct itree_node *node;</span>
<span class='curline'><a href='../S/2049.html#L957'>node</a>              957 src/buffer.c     ITREE_FOREACH (node, b-&gt;overlays, PTRDIFF_MIN, PTRDIFF_MAX, POST_ORDER)</span>
<span class='curline'><a href='../S/2049.html#L959'>node</a>              959 src/buffer.c         modify_overlay (b, node-&gt;begin, node-&gt;end);</span>
<span class='curline'><a href='../S/2049.html#L960'>node</a>              960 src/buffer.c         XOVERLAY (node-&gt;data)-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2049.html#L961'>node</a>              961 src/buffer.c         node-&gt;parent = NULL;</span>
<span class='curline'><a href='../S/2049.html#L962'>node</a>              962 src/buffer.c         node-&gt;left = NULL;</span>
<span class='curline'><a href='../S/2049.html#L963'>node</a>              963 src/buffer.c         node-&gt;right = NULL;</span>
<span class='curline'><a href='../S/2049.html#L1002'>node</a>             1002 src/buffer.c       struct itree_node *node, **cursor = nodes;</span>
<span class='curline'><a href='../S/2049.html#L1003'>node</a>             1003 src/buffer.c       ITREE_FOREACH (node, tree, PTRDIFF_MIN, PTRDIFF_MAX, ASCENDING)</span>
<span class='curline'><a href='../S/2049.html#L1004'>node</a>             1004 src/buffer.c         *(cursor++) = node;</span>
<span class='curline'><a href='../S/2049.html#L1009'>node</a>             1009 src/buffer.c         struct itree_node * const node = *nodes;</span>
<span class='curline'><a href='../S/2049.html#L1013'>node</a>             1013 src/buffer.c             ptrdiff_t begin = itree_node_begin (tree, node);</span>
<span class='curline'><a href='../S/2049.html#L1014'>node</a>             1014 src/buffer.c             ptrdiff_t end = itree_node_end (tree, node);</span>
<span class='curline'><a href='../S/2049.html#L1024'>node</a>             1024 src/buffer.c             itree_node_set_region (tree, node, BYTE_TO_CHAR (begin),</span>
<span class='curline'><a href='../S/2049.html#L1029'>node</a>             1029 src/buffer.c             itree_node_set_region (tree, node, CHAR_TO_BYTE (node-&gt;begin),</span>
<span class='curline'><a href='../S/2049.html#L1030'>node</a>             1030 src/buffer.c                                       CHAR_TO_BYTE (node-&gt;end));</span>
<span class='curline'><a href='../S/2049.html#L2466'>node</a>             2466 src/buffer.c     struct itree_node *node;</span>
<span class='curline'><a href='../S/2049.html#L2468'>node</a>             2468 src/buffer.c     ITREE_FOREACH (node, buffer-&gt;overlays, PTRDIFF_MIN, PTRDIFF_MAX, ASCENDING)</span>
<span class='curline'><a href='../S/2049.html#L2469'>node</a>             2469 src/buffer.c       XOVERLAY (node-&gt;data)-&gt;buffer = other;</span>
<span class='curline'><a href='../S/2049.html#L2471'>node</a>             2471 src/buffer.c     ITREE_FOREACH (node, other-&gt;overlays, PTRDIFF_MIN, PTRDIFF_MAX, ASCENDING)</span>
<span class='curline'><a href='../S/2049.html#L2472'>node</a>             2472 src/buffer.c       XOVERLAY (node-&gt;data)-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/2049.html#L3001'>node</a>             3001 src/buffer.c     struct itree_node *node;</span>
<span class='curline'><a href='../S/2049.html#L3009'>node</a>             3009 src/buffer.c     ITREE_FOREACH (node, current_buffer-&gt;overlays, beg, search_end,</span>
<span class='curline'><a href='../S/2049.html#L3012'>node</a>             3012 src/buffer.c         if (node-&gt;begin &gt; end)</span>
<span class='curline'><a href='../S/2049.html#L3014'>node</a>             3014 src/buffer.c             next = min (next, node-&gt;begin);</span>
<span class='curline'><a href='../S/2049.html#L3017'>node</a>             3017 src/buffer.c         else if (node-&gt;begin == end)</span>
<span class='curline'><a href='../S/2049.html#L3019'>node</a>             3019 src/buffer.c             next = node-&gt;begin;</span>
<span class='curline'><a href='../S/2049.html#L3022'>node</a>             3022 src/buffer.c             if (empty &amp;&amp; node-&gt;begin != node-&gt;end)</span>
<span class='curline'><a href='../S/2049.html#L3026'>node</a>             3026 src/buffer.c         if (! empty &amp;&amp; node-&gt;begin == node-&gt;end)</span>
<span class='curline'><a href='../S/2049.html#L3037'>node</a>             3037 src/buffer.c           vec[idx] = node-&gt;data;</span>
<span class='curline'><a href='../S/2049.html#L3066'>node</a>             3066 src/buffer.c     struct itree_node *node;</span>
<span class='curline'><a href='../S/2049.html#L3068'>node</a>             3068 src/buffer.c     ITREE_FOREACH (node, current_buffer-&gt;overlays, pos, next, ASCENDING)</span>
<span class='curline'><a href='../S/2049.html#L3070'>node</a>             3070 src/buffer.c         if (node-&gt;begin &gt; pos)</span>
<span class='curline'><a href='../S/2049.html#L3074'>node</a>             3074 src/buffer.c             eassert (node-&gt;begin &lt; next);</span>
<span class='curline'><a href='../S/2049.html#L3075'>node</a>             3075 src/buffer.c             next = node-&gt;begin;</span>
<span class='curline'><a href='../S/2049.html#L3078'>node</a>             3078 src/buffer.c         else if (node-&gt;begin &lt; node-&gt;end &amp;&amp; node-&gt;end &lt; next)</span>
<span class='curline'><a href='../S/2049.html#L3080'>node</a>             3080 src/buffer.c             next = node-&gt;end;</span>
<span class='curline'><a href='../S/2049.html#L3091'>node</a>             3091 src/buffer.c     struct itree_node *node;</span>
<span class='curline'><a href='../S/2049.html#L3094'>node</a>             3094 src/buffer.c     ITREE_FOREACH (node, current_buffer-&gt;overlays, prev, pos, DESCENDING)</span>
<span class='curline'><a href='../S/2049.html#L3096'>node</a>             3096 src/buffer.c         if (node-&gt;end &lt; pos)</span>
<span class='curline'><a href='../S/2049.html#L3097'>node</a>             3097 src/buffer.c           prev = node-&gt;end;</span>
<span class='curline'><a href='../S/2049.html#L3099'>node</a>             3099 src/buffer.c           prev = max (prev, node-&gt;begin);</span>
<span class='curline'><a href='../S/2049.html#L3174'>node</a>             3174 src/buffer.c     struct itree_node *node;</span>
<span class='curline'><a href='../S/2049.html#L3178'>node</a>             3178 src/buffer.c     ITREE_FOREACH (node, current_buffer-&gt;overlays, pos - 1, pos + 1, DESCENDING)</span>
<span class='curline'><a href='../S/2049.html#L3179'>node</a>             3179 src/buffer.c       if (node-&gt;begin == pos || node-&gt;end == pos)</span>
<span class='curline'><a href='../S/2049.html#L3383'>node</a>             3383 src/buffer.c     struct itree_node *node;</span>
<span class='curline'><a href='../S/2049.html#L3388'>node</a>             3388 src/buffer.c     ITREE_FOREACH (node, current_buffer-&gt;overlays, pos - 1, pos + 1, DESCENDING)</span>
<span class='curline'><a href='../S/2049.html#L3390'>node</a>             3390 src/buffer.c         Lisp_Object overlay = node-&gt;data;</span>
<span class='curline'><a href='../S/2049.html#L3393'>node</a>             3393 src/buffer.c         ptrdiff_t startpos = node-&gt;begin;</span>
<span class='curline'><a href='../S/2049.html#L3394'>node</a>             3394 src/buffer.c         ptrdiff_t endpos = node-&gt;end;</span>
<span class='curline'><a href='../S/2049.html#L3499'>node</a>             3499 src/buffer.c     struct itree_node *node;</span>
<span class='curline'><a href='../S/2049.html#L3509'>node</a>             3509 src/buffer.c     ITREE_FOREACH (node, buf-&gt;overlays, pos, pos, ASCENDING)</span>
<span class='curline'><a href='../S/2049.html#L3511'>node</a>             3511 src/buffer.c         if (node-&gt;end == pos &amp;&amp; node-&gt;begin == pos</span>
<span class='curline'><a href='../S/2049.html#L3512'>node</a>             3512 src/buffer.c             &amp;&amp; ! NILP (Foverlay_get (node-&gt;data, Qevaporate)))</span>
<span class='curline'><a href='../S/2049.html#L3513'>node</a>             3513 src/buffer.c           hit_list = Fcons (node-&gt;data, hit_list);</span>
<span class='curline'><a href='../S/2049.html#L3931'>node</a>             3931 src/buffer.c     struct itree_node *node;</span>
<span class='curline'><a href='../S/2049.html#L3933'>node</a>             3933 src/buffer.c     ITREE_FOREACH (node, current_buffer-&gt;overlays, BEG, Z, DESCENDING)</span>
<span class='curline'><a href='../S/2049.html#L3934'>node</a>             3934 src/buffer.c       overlays = Fcons (node-&gt;data, overlays);</span>
<span class='curline'><a href='../S/2049.html#L4068'>node</a>             4068 src/buffer.c         struct itree_node *node;</span>
<span class='curline'><a href='../S/2049.html#L4077'>node</a>             4077 src/buffer.c         ITREE_FOREACH (node, current_buffer-&gt;overlays,</span>
<span class='curline'><a href='../S/2049.html#L4082'>node</a>             4082 src/buffer.c             Lisp_Object overlay = node-&gt;data;</span>
<span class='curline'><a href='../S/2049.html#L4988'>node</a>             4988 src/buffer.c   make_lispy_itree_node (const struct itree_node *node)</span>
<span class='curline'><a href='../S/2049.html#L4992'>node</a>             4992 src/buffer.c                   make_fixnum (node-&gt;begin),</span>
<span class='curline'><a href='../S/2049.html#L4994'>node</a>             4994 src/buffer.c                   make_fixnum (node-&gt;end),</span>
<span class='curline'><a href='../S/2049.html#L4996'>node</a>             4996 src/buffer.c                   make_fixnum (node-&gt;limit),</span>
<span class='curline'><a href='../S/2049.html#L4998'>node</a>             4998 src/buffer.c                   make_fixnum (node-&gt;offset),</span>
<span class='curline'><a href='../S/2049.html#L5000'>node</a>             5000 src/buffer.c                   node-&gt;rear_advance ? Qt : Qnil,</span>
<span class='curline'><a href='../S/2049.html#L5002'>node</a>             5002 src/buffer.c                   node-&gt;front_advance ? Qt : Qnil);</span>
<span class='curline'><a href='../S/2049.html#L5007'>node</a>             5007 src/buffer.c                 const struct itree_node *node)</span>
<span class='curline'><a href='../S/2049.html#L5009'>node</a>             5009 src/buffer.c     if (node == ITREE_NULL)</span>
<span class='curline'><a href='../S/2049.html#L5011'>node</a>             5011 src/buffer.c     return list3 (make_lispy_itree_node (node),</span>
<span class='curline'><a href='../S/2049.html#L5012'>node</a>             5012 src/buffer.c                   overlay_tree (tree, node-&gt;left),</span>
<span class='curline'><a href='../S/2049.html#L5013'>node</a>             5013 src/buffer.c                   overlay_tree (tree, node-&gt;right));</span>
<span class='curline'><a href='../S/2208.html#L1076'>node</a>             1076 src/fns.c      	      Lisp_Object node = Fcons (elt, Qnil);</span>
<span class='curline'><a href='../S/2208.html#L1078'>node</a>             1078 src/fns.c      		result = node;</span>
<span class='curline'><a href='../S/2208.html#L1080'>node</a>             1080 src/fns.c      		XSETCDR (last, node);</span>
<span class='curline'><a href='../S/2208.html#L1081'>node</a>             1081 src/fns.c      	      last = node;</span>
<span class='curline'><a href='../S/2250.html#L621'>node</a>              621 src/gtkutil.c  xg_list_insert (xg_list_node *list, xg_list_node *node)</span>
<span class='curline'><a href='../S/2250.html#L625'>node</a>              625 src/gtkutil.c    if (list_start) list_start-&gt;prev = node;</span>
<span class='curline'><a href='../S/2250.html#L626'>node</a>              626 src/gtkutil.c    node-&gt;next = list_start;</span>
<span class='curline'><a href='../S/2250.html#L627'>node</a>              627 src/gtkutil.c    node-&gt;prev = 0;</span>
<span class='curline'><a href='../S/2250.html#L628'>node</a>              628 src/gtkutil.c    list-&gt;next = node;</span>
<span class='curline'><a href='../S/2250.html#L634'>node</a>              634 src/gtkutil.c  xg_list_remove (xg_list_node *list, xg_list_node *node)</span>
<span class='curline'><a href='../S/2250.html#L637'>node</a>              637 src/gtkutil.c    if (node == list_start)</span>
<span class='curline'><a href='../S/2250.html#L639'>node</a>              639 src/gtkutil.c        list-&gt;next = node-&gt;next;</span>
<span class='curline'><a href='../S/2250.html#L644'>node</a>              644 src/gtkutil.c        node-&gt;prev-&gt;next = node-&gt;next;</span>
<span class='curline'><a href='../S/2250.html#L645'>node</a>              645 src/gtkutil.c        if (node-&gt;next) node-&gt;next-&gt;prev = node-&gt;prev;</span>
<span class='curline'><a href='../S/2020.html#L1116'>node</a>             1116 src/haiku_font_support.cc   BNode node;</span>
<span class='curline'><a href='../S/2020.html#L1143'>node</a>             1143 src/haiku_font_support.cc   rc = node.SetTo (path.Path ());</span>
<span class='curline'><a href='../S/2020.html#L1148'>node</a>             1148 src/haiku_font_support.cc   if (node.GetNodeRef (&amp;node_ref) &lt; B_OK)</span>
<span class='curline'><a href='../S/2120.html#L5528'>node</a>             5528 src/haiku_support.cc   BNode node (path);</span>
<span class='curline'><a href='../S/2120.html#L5534'>node</a>             5534 src/haiku_support.cc   rc = node.InitCheck ();</span>
<span class='curline'><a href='../S/2120.html#L5555'>node</a>             5555 src/haiku_support.cc   result = node.WriteAttr (name, B_MIME_TYPE, 0,</span>
<span class='curline'><a href='../S/2163.html#L178'>node</a>              178 src/itree.c    itree_stack_push (struct itree_stack *stack, struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L180'>node</a>              180 src/itree.c      eassert (node);</span>
<span class='curline'><a href='../S/2163.html#L183'>node</a>              183 src/itree.c      stack-&gt;nodes[stack-&gt;length] = node;</span>
<span class='curline'><a href='../S/2163.html#L217'>node</a>              217 src/itree.c    check_subtree (struct itree_node *node,</span>
<span class='curline'><a href='../S/2163.html#L225'>node</a>              225 src/itree.c      if (node == NULL)</span>
<span class='curline'><a href='../S/2163.html#L229'>node</a>              229 src/itree.c      eassert (node-&gt;left == NULL || node-&gt;left-&gt;parent == node);</span>
<span class='curline'><a href='../S/2163.html#L230'>node</a>              230 src/itree.c      eassert (node-&gt;right == NULL || node-&gt;right-&gt;parent == node);</span>
<span class='curline'><a href='../S/2163.html#L239'>node</a>              239 src/itree.c      eassert (node-&gt;otick &lt;= tree_otick);</span>
<span class='curline'><a href='../S/2163.html#L240'>node</a>              240 src/itree.c      eassert (node-&gt;parent == NULL || node-&gt;otick &lt;= node-&gt;parent-&gt;otick);</span>
<span class='curline'><a href='../S/2163.html#L241'>node</a>              241 src/itree.c      eassert (node-&gt;otick != tree_otick || node-&gt;offset == 0);</span>
<span class='curline'><a href='../S/2163.html#L243'>node</a>              243 src/itree.c      offset += node-&gt;offset;</span>
<span class='curline'><a href='../S/2163.html#L244'>node</a>              244 src/itree.c      ptrdiff_t begin = node-&gt;begin + offset;</span>
<span class='curline'><a href='../S/2163.html#L245'>node</a>              245 src/itree.c      ptrdiff_t end = node-&gt;end + offset;</span>
<span class='curline'><a href='../S/2163.html#L246'>node</a>              246 src/itree.c      ptrdiff_t limit = node-&gt;limit + offset;</span>
<span class='curline'><a href='../S/2163.html#L254'>node</a>              254 src/itree.c        = check_subtree (node-&gt;left, check_red_black_invariants,</span>
<span class='curline'><a href='../S/2163.html#L257'>node</a>              257 src/itree.c        = check_subtree (node-&gt;right, check_red_black_invariants,</span>
<span class='curline'><a href='../S/2163.html#L267'>node</a>              267 src/itree.c          eassert (node-&gt;parent == NULL || !node-&gt;red || !node-&gt;parent-&gt;red);</span>
<span class='curline'><a href='../S/2163.html#L272'>node</a>              272 src/itree.c      result.black_height = (node-&gt;red ? 0 : 1) + left_result.black_height;</span>
<span class='curline'><a href='../S/2163.html#L297'>node</a>              297 src/itree.c      struct itree_node *node = tree-&gt;root;</span>
<span class='curline'><a href='../S/2163.html#L299'>node</a>              299 src/itree.c        = check_subtree (node, check_red_black_invariants, tree-&gt;otick,</span>
<span class='curline'><a href='../S/2163.html#L300'>node</a>              300 src/itree.c    		     node-&gt;offset, PTRDIFF_MIN,</span>
<span class='curline'><a href='../S/2163.html#L313'>node</a>              313 src/itree.c    null_safe_is_red (struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L315'>node</a>              315 src/itree.c      return node != NULL &amp;&amp; node-&gt;red;</span>
<span class='curline'><a href='../S/2163.html#L319'>node</a>              319 src/itree.c    null_safe_is_black (struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L321'>node</a>              321 src/itree.c      return node == NULL || !node-&gt;red; /* NULL nodes are black */</span>
<span class='curline'><a href='../S/2163.html#L325'>node</a>              325 src/itree.c    itree_newlimit (struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L327'>node</a>              327 src/itree.c      eassert (node != NULL);</span>
<span class='curline'><a href='../S/2163.html#L328'>node</a>              328 src/itree.c      return max (node-&gt;end,</span>
<span class='curline'><a href='../S/2163.html#L329'>node</a>              329 src/itree.c    	      max (node-&gt;left == NULL</span>
<span class='curline'><a href='../S/2163.html#L331'>node</a>              331 src/itree.c    		     : node-&gt;left-&gt;limit + node-&gt;left-&gt;offset,</span>
<span class='curline'><a href='../S/2163.html#L332'>node</a>              332 src/itree.c    		   node-&gt;right == NULL</span>
<span class='curline'><a href='../S/2163.html#L334'>node</a>              334 src/itree.c    		     : node-&gt;right-&gt;limit + node-&gt;right-&gt;offset));</span>
<span class='curline'><a href='../S/2163.html#L340'>node</a>              340 src/itree.c    itree_update_limit (struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L342'>node</a>              342 src/itree.c      if (node == NULL)</span>
<span class='curline'><a href='../S/2163.html#L345'>node</a>              345 src/itree.c      node-&gt;limit = itree_newlimit (node);</span>
<span class='curline'><a href='../S/2163.html#L355'>node</a>              355 src/itree.c    itree_inherit_offset (uintmax_t otick, struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L357'>node</a>              357 src/itree.c      eassert (node-&gt;parent == NULL || node-&gt;parent-&gt;otick &gt;= node-&gt;otick);</span>
<span class='curline'><a href='../S/2163.html#L358'>node</a>              358 src/itree.c      if (node-&gt;otick == otick)</span>
<span class='curline'><a href='../S/2163.html#L360'>node</a>              360 src/itree.c          eassert (node-&gt;offset == 0);</span>
<span class='curline'><a href='../S/2163.html#L370'>node</a>              370 src/itree.c      if (node-&gt;offset)</span>
<span class='curline'><a href='../S/2163.html#L372'>node</a>              372 src/itree.c          node-&gt;begin += node-&gt;offset;</span>
<span class='curline'><a href='../S/2163.html#L373'>node</a>              373 src/itree.c          node-&gt;end   += node-&gt;offset;</span>
<span class='curline'><a href='../S/2163.html#L374'>node</a>              374 src/itree.c          node-&gt;limit += node-&gt;offset;</span>
<span class='curline'><a href='../S/2163.html#L375'>node</a>              375 src/itree.c          if (node-&gt;left != NULL)</span>
<span class='curline'><a href='../S/2163.html#L376'>node</a>              376 src/itree.c    	node-&gt;left-&gt;offset += node-&gt;offset;</span>
<span class='curline'><a href='../S/2163.html#L377'>node</a>              377 src/itree.c          if (node-&gt;right != NULL)</span>
<span class='curline'><a href='../S/2163.html#L378'>node</a>              378 src/itree.c    	node-&gt;right-&gt;offset += node-&gt;offset;</span>
<span class='curline'><a href='../S/2163.html#L379'>node</a>              379 src/itree.c          node-&gt;offset = 0;</span>
<span class='curline'><a href='../S/2163.html#L384'>node</a>              384 src/itree.c      if (node-&gt;parent == NULL || node-&gt;parent-&gt;otick == otick)</span>
<span class='curline'><a href='../S/2163.html#L385'>node</a>              385 src/itree.c        node-&gt;otick = otick;</span>
<span class='curline'><a href='../S/2163.html#L392'>node</a>              392 src/itree.c    itree_propagate_limit (struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L396'>node</a>              396 src/itree.c      if (node == NULL)</span>
<span class='curline'><a href='../S/2163.html#L401'>node</a>              401 src/itree.c          newlimit = itree_newlimit (node);</span>
<span class='curline'><a href='../S/2163.html#L403'>node</a>              403 src/itree.c          if (newlimit == node-&gt;limit)</span>
<span class='curline'><a href='../S/2163.html#L405'>node</a>              405 src/itree.c          node-&gt;limit = newlimit;</span>
<span class='curline'><a href='../S/2163.html#L406'>node</a>              406 src/itree.c          if (node-&gt;parent == NULL)</span>
<span class='curline'><a href='../S/2163.html#L408'>node</a>              408 src/itree.c          node = node-&gt;parent;</span>
<span class='curline'><a href='../S/2163.html#L413'>node</a>              413 src/itree.c    itree_validate (struct itree_tree *tree, struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L416'>node</a>              416 src/itree.c      if (tree-&gt;otick == node-&gt;otick || node == NULL)</span>
<span class='curline'><a href='../S/2163.html#L417'>node</a>              417 src/itree.c        return node;</span>
<span class='curline'><a href='../S/2163.html#L418'>node</a>              418 src/itree.c      if (node != tree-&gt;root)</span>
<span class='curline'><a href='../S/2163.html#L419'>node</a>              419 src/itree.c        itree_validate (tree, node-&gt;parent);</span>
<span class='curline'><a href='../S/2163.html#L421'>node</a>              421 src/itree.c      itree_inherit_offset (tree-&gt;otick, node);</span>
<span class='curline'><a href='../S/2163.html#L422'>node</a>              422 src/itree.c      return node;</span>
<span class='curline'><a href='../S/2163.html#L432'>node</a>              432 src/itree.c    itree_node_init (struct itree_node *node,</span>
<span class='curline'><a href='../S/2163.html#L436'>node</a>              436 src/itree.c      node-&gt;parent = NULL;</span>
<span class='curline'><a href='../S/2163.html#L437'>node</a>              437 src/itree.c      node-&gt;left = NULL;</span>
<span class='curline'><a href='../S/2163.html#L438'>node</a>              438 src/itree.c      node-&gt;right = NULL;</span>
<span class='curline'><a href='../S/2163.html#L439'>node</a>              439 src/itree.c      node-&gt;begin = -1;</span>
<span class='curline'><a href='../S/2163.html#L440'>node</a>              440 src/itree.c      node-&gt;end = -1;</span>
<span class='curline'><a href='../S/2163.html#L441'>node</a>              441 src/itree.c      node-&gt;front_advance = front_advance;</span>
<span class='curline'><a href='../S/2163.html#L442'>node</a>              442 src/itree.c      node-&gt;rear_advance = rear_advance;</span>
<span class='curline'><a href='../S/2163.html#L443'>node</a>              443 src/itree.c      node-&gt;data = data;</span>
<span class='curline'><a href='../S/2163.html#L450'>node</a>              450 src/itree.c    		  struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L452'>node</a>              452 src/itree.c      itree_validate (tree, node);</span>
<span class='curline'><a href='../S/2163.html#L453'>node</a>              453 src/itree.c      return node-&gt;begin;</span>
<span class='curline'><a href='../S/2163.html#L460'>node</a>              460 src/itree.c    		struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L462'>node</a>              462 src/itree.c      itree_validate (tree, node);</span>
<span class='curline'><a href='../S/2163.html#L463'>node</a>              463 src/itree.c      return node-&gt;end;</span>
<span class='curline'><a href='../S/2163.html#L516'>node</a>              516 src/itree.c    			   struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L518'>node</a>              518 src/itree.c      eassert (node-&gt;right != NULL);</span>
<span class='curline'><a href='../S/2163.html#L520'>node</a>              520 src/itree.c      struct itree_node *right = node-&gt;right;</span>
<span class='curline'><a href='../S/2163.html#L522'>node</a>              522 src/itree.c      itree_inherit_offset (tree-&gt;otick, node);</span>
<span class='curline'><a href='../S/2163.html#L526'>node</a>              526 src/itree.c      node-&gt;right = right-&gt;left;</span>
<span class='curline'><a href='../S/2163.html#L528'>node</a>              528 src/itree.c        right-&gt;left-&gt;parent = node;</span>
<span class='curline'><a href='../S/2163.html#L532'>node</a>              532 src/itree.c        right-&gt;parent = node-&gt;parent;</span>
<span class='curline'><a href='../S/2163.html#L535'>node</a>              535 src/itree.c      if (node != tree-&gt;root)</span>
<span class='curline'><a href='../S/2163.html#L537'>node</a>              537 src/itree.c          if (node == node-&gt;parent-&gt;left)</span>
<span class='curline'><a href='../S/2163.html#L538'>node</a>              538 src/itree.c    	node-&gt;parent-&gt;left = right;</span>
<span class='curline'><a href='../S/2163.html#L540'>node</a>              540 src/itree.c    	node-&gt;parent-&gt;right = right;</span>
<span class='curline'><a href='../S/2163.html#L546'>node</a>              546 src/itree.c      right-&gt;left = node;</span>
<span class='curline'><a href='../S/2163.html#L547'>node</a>              547 src/itree.c      if (node != NULL)</span>
<span class='curline'><a href='../S/2163.html#L548'>node</a>              548 src/itree.c        node-&gt;parent = right;</span>
<span class='curline'><a href='../S/2163.html#L551'>node</a>              551 src/itree.c      itree_update_limit (node);</span>
<span class='curline'><a href='../S/2163.html#L559'>node</a>              559 src/itree.c    			    struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L561'>node</a>              561 src/itree.c      eassert (tree &amp;&amp; node &amp;&amp; node-&gt;left != NULL);</span>
<span class='curline'><a href='../S/2163.html#L563'>node</a>              563 src/itree.c      struct itree_node *left = node-&gt;left;</span>
<span class='curline'><a href='../S/2163.html#L565'>node</a>              565 src/itree.c      itree_inherit_offset (tree-&gt;otick, node);</span>
<span class='curline'><a href='../S/2163.html#L568'>node</a>              568 src/itree.c      node-&gt;left = left-&gt;right;</span>
<span class='curline'><a href='../S/2163.html#L570'>node</a>              570 src/itree.c        left-&gt;right-&gt;parent = node;</span>
<span class='curline'><a href='../S/2163.html#L573'>node</a>              573 src/itree.c        left-&gt;parent = node-&gt;parent;</span>
<span class='curline'><a href='../S/2163.html#L574'>node</a>              574 src/itree.c      if (node != tree-&gt;root)</span>
<span class='curline'><a href='../S/2163.html#L576'>node</a>              576 src/itree.c          if (node == node-&gt;parent-&gt;right)</span>
<span class='curline'><a href='../S/2163.html#L577'>node</a>              577 src/itree.c    	node-&gt;parent-&gt;right = left;</span>
<span class='curline'><a href='../S/2163.html#L579'>node</a>              579 src/itree.c    	node-&gt;parent-&gt;left = left;</span>
<span class='curline'><a href='../S/2163.html#L584'>node</a>              584 src/itree.c      left-&gt;right = node;</span>
<span class='curline'><a href='../S/2163.html#L585'>node</a>              585 src/itree.c      if (node != NULL)</span>
<span class='curline'><a href='../S/2163.html#L586'>node</a>              586 src/itree.c        node-&gt;parent = left;</span>
<span class='curline'><a href='../S/2163.html#L589'>node</a>              589 src/itree.c      itree_update_limit (node);</span>
<span class='curline'><a href='../S/2163.html#L598'>node</a>              598 src/itree.c    			  struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L602'>node</a>              602 src/itree.c      while (null_safe_is_red (node-&gt;parent))</span>
<span class='curline'><a href='../S/2163.html#L606'>node</a>              606 src/itree.c          eassert (node-&gt;red);</span>
<span class='curline'><a href='../S/2163.html#L608'>node</a>              608 src/itree.c          if (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left)</span>
<span class='curline'><a href='../S/2163.html#L612'>node</a>              612 src/itree.c    	  struct itree_node *uncle = node-&gt;parent-&gt;parent-&gt;right;</span>
<span class='curline'><a href='../S/2163.html#L619'>node</a>              619 src/itree.c    	      node-&gt;parent-&gt;red = false;</span>
<span class='curline'><a href='../S/2163.html#L621'>node</a>              621 src/itree.c    	      node-&gt;parent-&gt;parent-&gt;red = true;</span>
<span class='curline'><a href='../S/2163.html#L622'>node</a>              622 src/itree.c    	      node = node-&gt;parent-&gt;parent;</span>
<span class='curline'><a href='../S/2163.html#L628'>node</a>              628 src/itree.c    	      if (node == node-&gt;parent-&gt;right) /* case 2.a */</span>
<span class='curline'><a href='../S/2163.html#L630'>node</a>              630 src/itree.c    		  node = node-&gt;parent;</span>
<span class='curline'><a href='../S/2163.html#L631'>node</a>              631 src/itree.c    		  itree_rotate_left (tree, node);</span>
<span class='curline'><a href='../S/2163.html#L634'>node</a>              634 src/itree.c    	      node-&gt;parent-&gt;red = false;</span>
<span class='curline'><a href='../S/2163.html#L635'>node</a>              635 src/itree.c    	      node-&gt;parent-&gt;parent-&gt;red = true;</span>
<span class='curline'><a href='../S/2163.html#L636'>node</a>              636 src/itree.c    	      itree_rotate_right (tree, node-&gt;parent-&gt;parent);</span>
<span class='curline'><a href='../S/2163.html#L642'>node</a>              642 src/itree.c    	  struct itree_node *uncle = node-&gt;parent-&gt;parent-&gt;left;</span>
<span class='curline'><a href='../S/2163.html#L646'>node</a>              646 src/itree.c    	      node-&gt;parent-&gt;red = false;</span>
<span class='curline'><a href='../S/2163.html#L648'>node</a>              648 src/itree.c    	      node-&gt;parent-&gt;parent-&gt;red = true;</span>
<span class='curline'><a href='../S/2163.html#L649'>node</a>              649 src/itree.c    	      node = node-&gt;parent-&gt;parent;</span>
<span class='curline'><a href='../S/2163.html#L653'>node</a>              653 src/itree.c    	      if (node == node-&gt;parent-&gt;left) /* case 2.b */</span>
<span class='curline'><a href='../S/2163.html#L655'>node</a>              655 src/itree.c    		  node = node-&gt;parent;</span>
<span class='curline'><a href='../S/2163.html#L656'>node</a>              656 src/itree.c    		  itree_rotate_right (tree, node);</span>
<span class='curline'><a href='../S/2163.html#L659'>node</a>              659 src/itree.c    	      node-&gt;parent-&gt;red = false;</span>
<span class='curline'><a href='../S/2163.html#L660'>node</a>              660 src/itree.c    	      node-&gt;parent-&gt;parent-&gt;red = true;</span>
<span class='curline'><a href='../S/2163.html#L661'>node</a>              661 src/itree.c    	      itree_rotate_left (tree, node-&gt;parent-&gt;parent);</span>
<span class='curline'><a href='../S/2163.html#L676'>node</a>              676 src/itree.c    itree_insert_node (struct itree_tree *tree, struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L678'>node</a>              678 src/itree.c      eassert (node &amp;&amp; node-&gt;begin &lt;= node-&gt;end);</span>
<span class='curline'><a href='../S/2163.html#L679'>node</a>              679 src/itree.c      eassert (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL</span>
<span class='curline'><a href='../S/2163.html#L680'>node</a>              680 src/itree.c    	   &amp;&amp; node-&gt;parent == NULL);</span>
<span class='curline'><a href='../S/2163.html#L688'>node</a>              688 src/itree.c      eassert (node-&gt;otick == otick);</span>
<span class='curline'><a href='../S/2163.html#L697'>node</a>              697 src/itree.c          child-&gt;limit = max (child-&gt;limit, node-&gt;end);</span>
<span class='curline'><a href='../S/2163.html#L700'>node</a>              700 src/itree.c          child = node-&gt;begin &lt;= child-&gt;begin ? child-&gt;left : child-&gt;right;</span>
<span class='curline'><a href='../S/2163.html#L705'>node</a>              705 src/itree.c        tree-&gt;root = node;</span>
<span class='curline'><a href='../S/2163.html#L706'>node</a>              706 src/itree.c      else if (node-&gt;begin &lt;= parent-&gt;begin)</span>
<span class='curline'><a href='../S/2163.html#L707'>node</a>              707 src/itree.c        parent-&gt;left = node;</span>
<span class='curline'><a href='../S/2163.html#L709'>node</a>              709 src/itree.c        parent-&gt;right = node;</span>
<span class='curline'><a href='../S/2163.html#L712'>node</a>              712 src/itree.c      node-&gt;parent = parent;</span>
<span class='curline'><a href='../S/2163.html#L713'>node</a>              713 src/itree.c      node-&gt;left = NULL;</span>
<span class='curline'><a href='../S/2163.html#L714'>node</a>              714 src/itree.c      node-&gt;right = NULL;</span>
<span class='curline'><a href='../S/2163.html#L715'>node</a>              715 src/itree.c      node-&gt;offset = 0;</span>
<span class='curline'><a href='../S/2163.html#L716'>node</a>              716 src/itree.c      node-&gt;limit = node-&gt;end;</span>
<span class='curline'><a href='../S/2163.html#L717'>node</a>              717 src/itree.c      eassert (node-&gt;parent == NULL || node-&gt;parent-&gt;otick &gt;= node-&gt;otick);</span>
<span class='curline'><a href='../S/2163.html#L721'>node</a>              721 src/itree.c      if (node == tree-&gt;root)</span>
<span class='curline'><a href='../S/2163.html#L722'>node</a>              722 src/itree.c        node-&gt;red = false;</span>
<span class='curline'><a href='../S/2163.html#L725'>node</a>              725 src/itree.c          node-&gt;red = true;</span>
<span class='curline'><a href='../S/2163.html#L727'>node</a>              727 src/itree.c          itree_insert_fix (tree, node);</span>
<span class='curline'><a href='../S/2163.html#L732'>node</a>              732 src/itree.c    itree_insert (struct itree_tree *tree, struct itree_node *node,</span>
<span class='curline'><a href='../S/2163.html#L735'>node</a>              735 src/itree.c      node-&gt;begin = begin;</span>
<span class='curline'><a href='../S/2163.html#L736'>node</a>              736 src/itree.c      node-&gt;end = end;</span>
<span class='curline'><a href='../S/2163.html#L737'>node</a>              737 src/itree.c      node-&gt;otick = tree-&gt;otick;</span>
<span class='curline'><a href='../S/2163.html#L738'>node</a>              738 src/itree.c      itree_insert_node (tree, node);</span>
<span class='curline'><a href='../S/2163.html#L745'>node</a>              745 src/itree.c    		       struct itree_node *node,</span>
<span class='curline'><a href='../S/2163.html#L748'>node</a>              748 src/itree.c      itree_validate (tree, node);</span>
<span class='curline'><a href='../S/2163.html#L749'>node</a>              749 src/itree.c      if (begin != node-&gt;begin)</span>
<span class='curline'><a href='../S/2163.html#L751'>node</a>              751 src/itree.c          itree_remove (tree, node);</span>
<span class='curline'><a href='../S/2163.html#L752'>node</a>              752 src/itree.c          node-&gt;begin = min (begin, PTRDIFF_MAX - 1);</span>
<span class='curline'><a href='../S/2163.html#L753'>node</a>              753 src/itree.c          node-&gt;end = max (node-&gt;begin, end);</span>
<span class='curline'><a href='../S/2163.html#L754'>node</a>              754 src/itree.c          itree_insert_node (tree, node);</span>
<span class='curline'><a href='../S/2163.html#L756'>node</a>              756 src/itree.c      else if (end != node-&gt;end)</span>
<span class='curline'><a href='../S/2163.html#L758'>node</a>              758 src/itree.c          node-&gt;end = max (node-&gt;begin, end);</span>
<span class='curline'><a href='../S/2163.html#L759'>node</a>              759 src/itree.c          eassert (node != NULL);</span>
<span class='curline'><a href='../S/2163.html#L760'>node</a>              760 src/itree.c          itree_propagate_limit (node);</span>
<span class='curline'><a href='../S/2163.html#L767'>node</a>              767 src/itree.c    itree_contains (struct itree_tree *tree, struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L769'>node</a>              769 src/itree.c      eassert (node);</span>
<span class='curline'><a href='../S/2163.html#L771'>node</a>              771 src/itree.c      ITREE_FOREACH (other, tree, node-&gt;begin, PTRDIFF_MAX, ASCENDING)</span>
<span class='curline'><a href='../S/2163.html#L772'>node</a>              772 src/itree.c        if (other == node)</span>
<span class='curline'><a href='../S/2163.html#L779'>node</a>              779 src/itree.c    itree_limit_is_stable (struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L781'>node</a>              781 src/itree.c      if (node == NULL)</span>
<span class='curline'><a href='../S/2163.html#L783'>node</a>              783 src/itree.c      ptrdiff_t newlimit = itree_newlimit (node);</span>
<span class='curline'><a href='../S/2163.html#L784'>node</a>              784 src/itree.c      return (newlimit == node-&gt;limit);</span>
<span class='curline'><a href='../S/2163.html#L788'>node</a>              788 src/itree.c    itree_subtree_min (uintmax_t otick, struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L790'>node</a>              790 src/itree.c      if (node == NULL)</span>
<span class='curline'><a href='../S/2163.html#L791'>node</a>              791 src/itree.c        return node;</span>
<span class='curline'><a href='../S/2163.html#L792'>node</a>              792 src/itree.c      while ((itree_inherit_offset (otick, node),</span>
<span class='curline'><a href='../S/2163.html#L793'>node</a>              793 src/itree.c    	  node-&gt;left != NULL))</span>
<span class='curline'><a href='../S/2163.html#L794'>node</a>              794 src/itree.c        node = node-&gt;left;</span>
<span class='curline'><a href='../S/2163.html#L795'>node</a>              795 src/itree.c      return node;</span>
<span class='curline'><a href='../S/2163.html#L804'>node</a>              804 src/itree.c    			  struct itree_node *node,</span>
<span class='curline'><a href='../S/2163.html#L808'>node</a>              808 src/itree.c        eassert (node == tree-&gt;root);</span>
<span class='curline'><a href='../S/2163.html#L810'>node</a>              810 src/itree.c        eassert (node == NULL || node-&gt;parent == parent);</span>
<span class='curline'><a href='../S/2163.html#L812'>node</a>              812 src/itree.c      while (parent != NULL &amp;&amp; null_safe_is_black (node))</span>
<span class='curline'><a href='../S/2163.html#L814'>node</a>              814 src/itree.c          eassert (node == parent-&gt;left || node == parent-&gt;right);</span>
<span class='curline'><a href='../S/2163.html#L816'>node</a>              816 src/itree.c          if (node == parent-&gt;left)</span>
<span class='curline'><a href='../S/2163.html#L832'>node</a>              832 src/itree.c    	      node = parent;</span>
<span class='curline'><a href='../S/2163.html#L833'>node</a>              833 src/itree.c    	      eassert (node != NULL);</span>
<span class='curline'><a href='../S/2163.html#L834'>node</a>              834 src/itree.c    	      parent = node-&gt;parent;</span>
<span class='curline'><a href='../S/2163.html#L849'>node</a>              849 src/itree.c    	      node = tree-&gt;root;</span>
<span class='curline'><a href='../S/2163.html#L869'>node</a>              869 src/itree.c    	      node = parent;</span>
<span class='curline'><a href='../S/2163.html#L870'>node</a>              870 src/itree.c    	      eassert (node != NULL);</span>
<span class='curline'><a href='../S/2163.html#L871'>node</a>              871 src/itree.c    	      parent = node-&gt;parent;</span>
<span class='curline'><a href='../S/2163.html#L887'>node</a>              887 src/itree.c    	      node = tree-&gt;root;</span>
<span class='curline'><a href='../S/2163.html#L893'>node</a>              893 src/itree.c      if (node != NULL)</span>
<span class='curline'><a href='../S/2163.html#L894'>node</a>              894 src/itree.c        node-&gt;red = false;</span>
<span class='curline'><a href='../S/2163.html#L899'>node</a>              899 src/itree.c    itree_total_offset (struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L901'>node</a>              901 src/itree.c      eassert (node != NULL);</span>
<span class='curline'><a href='../S/2163.html#L903'>node</a>              903 src/itree.c      while (node-&gt;parent != NULL)</span>
<span class='curline'><a href='../S/2163.html#L905'>node</a>              905 src/itree.c          node = node-&gt;parent;</span>
<span class='curline'><a href='../S/2163.html#L906'>node</a>              906 src/itree.c          offset += node-&gt;offset;</span>
<span class='curline'><a href='../S/2163.html#L962'>node</a>              962 src/itree.c    itree_remove (struct itree_tree *tree, struct itree_node *node)</span>
<span class='curline'><a href='../S/2163.html#L964'>node</a>              964 src/itree.c      eassert (itree_contains (tree, node));</span>
<span class='curline'><a href='../S/2163.html#L970'>node</a>              970 src/itree.c      itree_inherit_offset (tree-&gt;otick, node);</span>
<span class='curline'><a href='../S/2163.html#L972'>node</a>              972 src/itree.c        = (node-&gt;left == NULL || node-&gt;right == NULL)</span>
<span class='curline'><a href='../S/2163.html#L973'>node</a>              973 src/itree.c    	? node</span>
<span class='curline'><a href='../S/2163.html#L974'>node</a>              974 src/itree.c    	: itree_subtree_min (tree-&gt;otick, node-&gt;right);</span>
<span class='curline'><a href='../S/2163.html#L986'>node</a>              986 src/itree.c        = (splice-&gt;parent != node) ? splice-&gt;parent : splice;</span>
<span class='curline'><a href='../S/2163.html#L1002'>node</a>             1002 src/itree.c      if (splice != node)</span>
<span class='curline'><a href='../S/2163.html#L1004'>node</a>             1004 src/itree.c          itree_transplant (tree, splice, node);</span>
<span class='curline'><a href='../S/2163.html#L1021'>node</a>             1021 src/itree.c      node-&gt;red = false;</span>
<span class='curline'><a href='../S/2163.html#L1022'>node</a>             1022 src/itree.c      node-&gt;right = node-&gt;left = node-&gt;parent = NULL;</span>
<span class='curline'><a href='../S/2163.html#L1023'>node</a>             1023 src/itree.c      node-&gt;limit = 0;</span>
<span class='curline'><a href='../S/2163.html#L1027'>node</a>             1027 src/itree.c      eassert (node-&gt;otick == tree-&gt;otick);</span>
<span class='curline'><a href='../S/2163.html#L1028'>node</a>             1028 src/itree.c      eassert (node-&gt;offset == 0);</span>
<span class='curline'><a href='../S/2163.html#L1030'>node</a>             1030 src/itree.c      return node;</span>
<span class='curline'><a href='../S/2163.html#L1060'>node</a>             1060 src/itree.c      struct itree_node *node = NULL;</span>
<span class='curline'><a href='../S/2163.html#L1064'>node</a>             1064 src/itree.c          ITREE_FOREACH (node, tree, pos, pos + 1, PRE_ORDER)</span>
<span class='curline'><a href='../S/2163.html#L1066'>node</a>             1066 src/itree.c    	  if (node-&gt;begin == pos &amp;&amp; node-&gt;front_advance</span>
<span class='curline'><a href='../S/2163.html#L1070'>node</a>             1070 src/itree.c    	      &amp;&amp; (node-&gt;begin != node-&gt;end || node-&gt;rear_advance))</span>
<span class='curline'><a href='../S/2163.html#L1071'>node</a>             1071 src/itree.c    	    itree_stack_push (saved, node);</span>
<span class='curline'><a href='../S/2163.html#L1084'>node</a>             1084 src/itree.c          while ((node = itree_stack_pop (stack)))</span>
<span class='curline'><a href='../S/2163.html#L1087'>node</a>             1087 src/itree.c    	  itree_inherit_offset (tree-&gt;otick, node);</span>
<span class='curline'><a href='../S/2163.html#L1088'>node</a>             1088 src/itree.c    	  if (pos &gt; node-&gt;limit)</span>
<span class='curline'><a href='../S/2163.html#L1090'>node</a>             1090 src/itree.c    	  if (node-&gt;right != NULL)</span>
<span class='curline'><a href='../S/2163.html#L1092'>node</a>             1092 src/itree.c    	      if (node-&gt;begin &gt; pos)</span>
<span class='curline'><a href='../S/2163.html#L1095'>node</a>             1095 src/itree.c    		  node-&gt;right-&gt;offset += length;</span>
<span class='curline'><a href='../S/2163.html#L1099'>node</a>             1099 src/itree.c    		itree_stack_push (stack, node-&gt;right);</span>
<span class='curline'><a href='../S/2163.html#L1101'>node</a>             1101 src/itree.c    	  if (node-&gt;left != NULL)</span>
<span class='curline'><a href='../S/2163.html#L1102'>node</a>             1102 src/itree.c    	    itree_stack_push (stack, node-&gt;left);</span>
<span class='curline'><a href='../S/2163.html#L1105'>node</a>             1105 src/itree.c    	      ? node-&gt;begin &gt;= pos</span>
<span class='curline'><a href='../S/2163.html#L1106'>node</a>             1106 src/itree.c    	      : node-&gt;begin &gt; pos) /* node-&gt;begin == pos =&gt; !front-advance  */</span>
<span class='curline'><a href='../S/2163.html#L1107'>node</a>             1107 src/itree.c    	    node-&gt;begin += length;</span>
<span class='curline'><a href='../S/2163.html#L1108'>node</a>             1108 src/itree.c    	  if (node-&gt;end &gt; pos</span>
<span class='curline'><a href='../S/2163.html#L1109'>node</a>             1109 src/itree.c    	      || (node-&gt;end == pos &amp;&amp; (before_markers || node-&gt;rear_advance)))</span>
<span class='curline'><a href='../S/2163.html#L1111'>node</a>             1111 src/itree.c    	      node-&gt;end += length;</span>
<span class='curline'><a href='../S/2163.html#L1112'>node</a>             1112 src/itree.c    	      eassert (node != NULL);</span>
<span class='curline'><a href='../S/2163.html#L1113'>node</a>             1113 src/itree.c    	      itree_propagate_limit (node);</span>
<span class='curline'><a href='../S/2163.html#L1121'>node</a>             1121 src/itree.c      while ((node = itree_stack_pop (saved)))</span>
<span class='curline'><a href='../S/2163.html#L1123'>node</a>             1123 src/itree.c          eassert (node-&gt;otick == ootick);</span>
<span class='curline'><a href='../S/2163.html#L1124'>node</a>             1124 src/itree.c          eassert (node-&gt;begin == pos);</span>
<span class='curline'><a href='../S/2163.html#L1125'>node</a>             1125 src/itree.c          eassert (node-&gt;end &gt; pos || node-&gt;rear_advance);</span>
<span class='curline'><a href='../S/2163.html#L1126'>node</a>             1126 src/itree.c          node-&gt;begin += length;</span>
<span class='curline'><a href='../S/2163.html#L1127'>node</a>             1127 src/itree.c          node-&gt;end += length;</span>
<span class='curline'><a href='../S/2163.html#L1128'>node</a>             1128 src/itree.c          node-&gt;otick = notick;</span>
<span class='curline'><a href='../S/2163.html#L1129'>node</a>             1129 src/itree.c          itree_insert_node (tree, node);</span>
<span class='curline'><a href='../S/2163.html#L1151'>node</a>             1151 src/itree.c      struct itree_node *node;</span>
<span class='curline'><a href='../S/2163.html#L1154'>node</a>             1154 src/itree.c      while ((node = itree_stack_pop (stack)))</span>
<span class='curline'><a href='../S/2163.html#L1156'>node</a>             1156 src/itree.c          itree_inherit_offset (tree-&gt;otick, node);</span>
<span class='curline'><a href='../S/2163.html#L1157'>node</a>             1157 src/itree.c          if (pos &gt; node-&gt;limit)</span>
<span class='curline'><a href='../S/2163.html#L1159'>node</a>             1159 src/itree.c          if (node-&gt;right != NULL)</span>
<span class='curline'><a href='../S/2163.html#L1161'>node</a>             1161 src/itree.c    	  if (node-&gt;begin &gt; pos + length)</span>
<span class='curline'><a href='../S/2163.html#L1164'>node</a>             1164 src/itree.c    	      node-&gt;right-&gt;offset -= length;</span>
<span class='curline'><a href='../S/2163.html#L1168'>node</a>             1168 src/itree.c    	    itree_stack_push (stack, node-&gt;right);</span>
<span class='curline'><a href='../S/2163.html#L1170'>node</a>             1170 src/itree.c          if (node-&gt;left != NULL)</span>
<span class='curline'><a href='../S/2163.html#L1171'>node</a>             1171 src/itree.c    	itree_stack_push (stack, node-&gt;left);</span>
<span class='curline'><a href='../S/2163.html#L1173'>node</a>             1173 src/itree.c          if (pos &lt; node-&gt;begin)</span>
<span class='curline'><a href='../S/2163.html#L1174'>node</a>             1174 src/itree.c    	node-&gt;begin = max (pos, node-&gt;begin - length);</span>
<span class='curline'><a href='../S/2163.html#L1175'>node</a>             1175 src/itree.c          if (node-&gt;end &gt; pos)</span>
<span class='curline'><a href='../S/2163.html#L1177'>node</a>             1177 src/itree.c    	  node-&gt;end = max (pos , node-&gt;end - length);</span>
<span class='curline'><a href='../S/2163.html#L1178'>node</a>             1178 src/itree.c    	  eassert (node != NULL);</span>
<span class='curline'><a href='../S/2163.html#L1179'>node</a>             1179 src/itree.c    	  itree_propagate_limit (node);</span>
<span class='curline'><a href='../S/2163.html#L1200'>node</a>             1200 src/itree.c    itree_node_intersects (const struct itree_node *node,</span>
<span class='curline'><a href='../S/2163.html#L1203'>node</a>             1203 src/itree.c      return (begin &lt; node-&gt;end &amp;&amp; node-&gt;begin &lt; end)</span>
<span class='curline'><a href='../S/2163.html#L1204'>node</a>             1204 src/itree.c        || (node-&gt;begin == node-&gt;end &amp;&amp; begin == node-&gt;begin);</span>
<span class='curline'><a href='../S/2163.html#L1220'>node</a>             1220 src/itree.c    itree_iter_next_in_subtree (struct itree_node *node,</span>
<span class='curline'><a href='../S/2163.html#L1232'>node</a>             1232 src/itree.c          next = node-&gt;right;</span>
<span class='curline'><a href='../S/2163.html#L1235'>node</a>             1235 src/itree.c              while ((next = node-&gt;parent)</span>
<span class='curline'><a href='../S/2163.html#L1236'>node</a>             1236 src/itree.c                     &amp;&amp; next-&gt;right == node)</span>
<span class='curline'><a href='../S/2163.html#L1237'>node</a>             1237 src/itree.c                node = next;</span>
<span class='curline'><a href='../S/2163.html#L1240'>node</a>             1240 src/itree.c              node = next;</span>
<span class='curline'><a href='../S/2163.html#L1244'>node</a>             1244 src/itree.c              node = next;</span>
<span class='curline'><a href='../S/2163.html#L1245'>node</a>             1245 src/itree.c              itree_inherit_offset (iter-&gt;otick, node);</span>
<span class='curline'><a href='../S/2163.html#L1246'>node</a>             1246 src/itree.c              while ((next = node-&gt;left)</span>
<span class='curline'><a href='../S/2163.html#L1249'>node</a>             1249 src/itree.c                node = next;</span>
<span class='curline'><a href='../S/2163.html#L1251'>node</a>             1251 src/itree.c          if (node-&gt;begin &gt; iter-&gt;end)</span>
<span class='curline'><a href='../S/2163.html#L1253'>node</a>             1253 src/itree.c          return node;</span>
<span class='curline'><a href='../S/2163.html#L1256'>node</a>             1256 src/itree.c          next = node-&gt;left;</span>
<span class='curline'><a href='../S/2163.html#L1261'>node</a>             1261 src/itree.c              while ((next = node-&gt;parent)</span>
<span class='curline'><a href='../S/2163.html#L1262'>node</a>             1262 src/itree.c                     &amp;&amp; next-&gt;left == node)</span>
<span class='curline'><a href='../S/2163.html#L1263'>node</a>             1263 src/itree.c                node = next;</span>
<span class='curline'><a href='../S/2163.html#L1266'>node</a>             1266 src/itree.c              node = next;</span>
<span class='curline'><a href='../S/2163.html#L1270'>node</a>             1270 src/itree.c              node = next;</span>
<span class='curline'><a href='../S/2163.html#L1271'>node</a>             1271 src/itree.c              while (node-&gt;begin &lt;= iter-&gt;end</span>
<span class='curline'><a href='../S/2163.html#L1272'>node</a>             1272 src/itree.c                     &amp;&amp; (next = node-&gt;right))</span>
<span class='curline'><a href='../S/2163.html#L1275'>node</a>             1275 src/itree.c                  node = next;</span>
<span class='curline'><a href='../S/2163.html#L1278'>node</a>             1278 src/itree.c          return node;</span>
<span class='curline'><a href='../S/2163.html#L1281'>node</a>             1281 src/itree.c          next = node-&gt;left;</span>
<span class='curline'><a href='../S/2163.html#L1286'>node</a>             1286 src/itree.c          next = node-&gt;right;</span>
<span class='curline'><a href='../S/2163.html#L1287'>node</a>             1287 src/itree.c          if (node-&gt;begin &lt;= iter-&gt;end &amp;&amp; next)</span>
<span class='curline'><a href='../S/2163.html#L1292'>node</a>             1292 src/itree.c          while ((next = node-&gt;parent))</span>
<span class='curline'><a href='../S/2163.html#L1294'>node</a>             1294 src/itree.c              if (next-&gt;right == node)</span>
<span class='curline'><a href='../S/2163.html#L1295'>node</a>             1295 src/itree.c                node = next;</span>
<span class='curline'><a href='../S/2163.html#L1298'>node</a>             1298 src/itree.c                  eassert (next-&gt;left == node);</span>
<span class='curline'><a href='../S/2163.html#L1299'>node</a>             1299 src/itree.c                  node = next;</span>
<span class='curline'><a href='../S/2163.html#L1300'>node</a>             1300 src/itree.c                  next = node-&gt;right;</span>
<span class='curline'><a href='../S/2163.html#L1301'>node</a>             1301 src/itree.c                  if (node-&gt;begin &lt;= iter-&gt;end &amp;&amp; next)</span>
<span class='curline'><a href='../S/2163.html#L1311'>node</a>             1311 src/itree.c          next = node-&gt;parent;</span>
<span class='curline'><a href='../S/2163.html#L1312'>node</a>             1312 src/itree.c          if (!next || next-&gt;right == node)</span>
<span class='curline'><a href='../S/2163.html#L1314'>node</a>             1314 src/itree.c          eassert (next-&gt;left == node);</span>
<span class='curline'><a href='../S/2163.html#L1315'>node</a>             1315 src/itree.c          node = next;</span>
<span class='curline'><a href='../S/2163.html#L1316'>node</a>             1316 src/itree.c          next = node-&gt;right;</span>
<span class='curline'><a href='../S/2163.html#L1317'>node</a>             1317 src/itree.c          if (!(node-&gt;begin &lt;= iter-&gt;end &amp;&amp; next))</span>
<span class='curline'><a href='../S/2163.html#L1318'>node</a>             1318 src/itree.c            return node;</span>
<span class='curline'><a href='../S/2163.html#L1319'>node</a>             1319 src/itree.c          node = next;</span>
<span class='curline'><a href='../S/2163.html#L1320'>node</a>             1320 src/itree.c          itree_inherit_offset (iter-&gt;otick, node);</span>
<span class='curline'><a href='../S/2163.html#L1321'>node</a>             1321 src/itree.c          while (((next = node-&gt;left)</span>
<span class='curline'><a href='../S/2163.html#L1324'>node</a>             1324 src/itree.c                 || (node-&gt;begin &lt;= iter-&gt;end</span>
<span class='curline'><a href='../S/2163.html#L1325'>node</a>             1325 src/itree.c                     &amp;&amp; (next = node-&gt;right)</span>
<span class='curline'><a href='../S/2163.html#L1327'>node</a>             1327 src/itree.c            node = next;</span>
<span class='curline'><a href='../S/2163.html#L1328'>node</a>             1328 src/itree.c          return node;</span>
<span class='curline'><a href='../S/2163.html#L1339'>node</a>             1339 src/itree.c      struct itree_node *node = tree-&gt;root;</span>
<span class='curline'><a href='../S/2163.html#L1340'>node</a>             1340 src/itree.c      if (node)</span>
<span class='curline'><a href='../S/2163.html#L1346'>node</a>             1346 src/itree.c          itree_inherit_offset (iter-&gt;otick, node);</span>
<span class='curline'><a href='../S/2163.html#L1350'>node</a>             1350 src/itree.c              dummy.right = node;</span>
<span class='curline'><a href='../S/2163.html#L1352'>node</a>             1352 src/itree.c              node = itree_iter_next_in_subtree (&amp;dummy, iter);</span>
<span class='curline'><a href='../S/2163.html#L1356'>node</a>             1356 src/itree.c              dummy.left = node;</span>
<span class='curline'><a href='../S/2163.html#L1357'>node</a>             1357 src/itree.c              node = itree_iter_next_in_subtree (&amp;dummy, iter);</span>
<span class='curline'><a href='../S/2163.html#L1366'>node</a>             1366 src/itree.c              dummy.right = node;</span>
<span class='curline'><a href='../S/2163.html#L1368'>node</a>             1368 src/itree.c              node = itree_iter_next_in_subtree (&amp;dummy, iter);</span>
<span class='curline'><a href='../S/2163.html#L1374'>node</a>             1374 src/itree.c      return node;</span>
<span class='curline'><a href='../S/2163.html#L1396'>node</a>             1396 src/itree.c      iter-&gt;node = itree_iterator_first_node (tree, iter);</span>
<span class='curline'><a href='../S/2163.html#L1403'>node</a>             1403 src/itree.c      struct itree_node *node = iter-&gt;node;</span>
<span class='curline'><a href='../S/2163.html#L1404'>node</a>             1404 src/itree.c      while (node</span>
<span class='curline'><a href='../S/2163.html#L1405'>node</a>             1405 src/itree.c             &amp;&amp; !itree_node_intersects (node, iter-&gt;begin, iter-&gt;end))</span>
<span class='curline'><a href='../S/2163.html#L1407'>node</a>             1407 src/itree.c          node = itree_iter_next_in_subtree (node, iter);</span>
<span class='curline'><a href='../S/2163.html#L1408'>node</a>             1408 src/itree.c          eassert (itree_limit_is_stable (node));</span>
<span class='curline'><a href='../S/2163.html#L1410'>node</a>             1410 src/itree.c      iter-&gt;node = node ? itree_iter_next_in_subtree (node, iter) : NULL;</span>
<span class='curline'><a href='../S/2163.html#L1411'>node</a>             1411 src/itree.c      return node;</span>
<span class='curline'><a href='../S/2033.html#L147'>node</a>              147 src/itree.h        struct itree_node *node;</span>
<span class='curline'><a href='../S/2158.html#L2136'>node</a>             2136 src/pdumper.c  dump_interval_node (struct dump_context *ctx, struct itree_node *node,</span>
<span class='curline'><a href='../S/2158.html#L2144'>node</a>             2144 src/pdumper.c    if (node-&gt;parent)</span>
<span class='curline'><a href='../S/2158.html#L2145'>node</a>             2145 src/pdumper.c      dump_field_fixup_later (ctx, &amp;out, node, &amp;node-&gt;parent);</span>
<span class='curline'><a href='../S/2158.html#L2146'>node</a>             2146 src/pdumper.c    if (node-&gt;left)</span>
<span class='curline'><a href='../S/2158.html#L2147'>node</a>             2147 src/pdumper.c      dump_field_fixup_later (ctx, &amp;out, node, &amp;node-&gt;parent);</span>
<span class='curline'><a href='../S/2158.html#L2148'>node</a>             2148 src/pdumper.c    if (node-&gt;right)</span>
<span class='curline'><a href='../S/2158.html#L2149'>node</a>             2149 src/pdumper.c      dump_field_fixup_later (ctx, &amp;out, node, &amp;node-&gt;parent);</span>
<span class='curline'><a href='../S/2158.html#L2150'>node</a>             2150 src/pdumper.c    DUMP_FIELD_COPY (&amp;out, node, begin);</span>
<span class='curline'><a href='../S/2158.html#L2151'>node</a>             2151 src/pdumper.c    DUMP_FIELD_COPY (&amp;out, node, end);</span>
<span class='curline'><a href='../S/2158.html#L2152'>node</a>             2152 src/pdumper.c    DUMP_FIELD_COPY (&amp;out, node, limit);</span>
<span class='curline'><a href='../S/2158.html#L2153'>node</a>             2153 src/pdumper.c    DUMP_FIELD_COPY (&amp;out, node, offset);</span>
<span class='curline'><a href='../S/2158.html#L2154'>node</a>             2154 src/pdumper.c    DUMP_FIELD_COPY (&amp;out, node, otick);</span>
<span class='curline'><a href='../S/2158.html#L2155'>node</a>             2155 src/pdumper.c    dump_field_lv (ctx, &amp;out, node, &amp;node-&gt;data, WEIGHT_STRONG);</span>
<span class='curline'><a href='../S/2158.html#L2156'>node</a>             2156 src/pdumper.c    DUMP_FIELD_COPY (&amp;out, node, red);</span>
<span class='curline'><a href='../S/2158.html#L2157'>node</a>             2157 src/pdumper.c    DUMP_FIELD_COPY (&amp;out, node, rear_advance);</span>
<span class='curline'><a href='../S/2158.html#L2158'>node</a>             2158 src/pdumper.c    DUMP_FIELD_COPY (&amp;out, node, front_advance);</span>
<span class='curline'><a href='../S/2158.html#L2160'>node</a>             2160 src/pdumper.c    if (node-&gt;parent)</span>
<span class='curline'><a href='../S/2158.html#L2164'>node</a>             2164 src/pdumper.c  	 dump_interval_node (ctx, node-&gt;parent, offset));</span>
<span class='curline'><a href='../S/2158.html#L2165'>node</a>             2165 src/pdumper.c    if (node-&gt;left)</span>
<span class='curline'><a href='../S/2158.html#L2169'>node</a>             2169 src/pdumper.c  	 dump_interval_node (ctx, node-&gt;left, offset));</span>
<span class='curline'><a href='../S/2158.html#L2170'>node</a>             2170 src/pdumper.c    if (node-&gt;right)</span>
<span class='curline'><a href='../S/2158.html#L2174'>node</a>             2174 src/pdumper.c  	 dump_interval_node (ctx, node-&gt;right, offset));</span>
<span class='curline'><a href='../S/2084.html#L2036'>node</a>             2036 src/print.c          bool named = treesit_named_node_p (XTS_NODE (obj)-&gt;node);</span>
<span class='curline'><a href='../S/2165.html#L637'>node</a>              637 src/textprop.c       struct itree_node *node;</span>
<span class='curline'><a href='../S/2165.html#L647'>node</a>              647 src/textprop.c       ITREE_FOREACH (node, b-&gt;overlays, pos, pos + 1, ASCENDING)</span>
<span class='curline'><a href='../S/2165.html#L649'>node</a>              649 src/textprop.c 	  Lisp_Object tem = Foverlay_get (node-&gt;data, prop);</span>
<span class='curline'><a href='../S/2165.html#L652'>node</a>              652 src/textprop.c 	  if (NILP (tem) || node-&gt;end &lt; pos + 1</span>
<span class='curline'><a href='../S/2165.html#L653'>node</a>              653 src/textprop.c 	      || (w &amp;&amp; ! overlay_matches_window (w, node-&gt;data)))</span>
<span class='curline'><a href='../S/2165.html#L657'>node</a>              657 src/textprop.c           make_sortvec_item (this, node-&gt;data);</span>
<span class='curline'><a href='../S/2187.html#L1178'>node</a>             1178 src/treesit.c  make_treesit_node (Lisp_Object parser, TSNode node)</span>
<span class='curline'><a href='../S/2187.html#L1185'>node</a>             1185 src/treesit.c    lisp_node-&gt;node = node;</span>
<span class='curline'><a href='../S/2187.html#L1225'>node</a>             1225 src/treesit.c  treesit_named_node_p (TSNode node)</span>
<span class='curline'><a href='../S/2187.html#L1227'>node</a>             1227 src/treesit.c    return ts_node_is_named (node);</span>
<span class='curline'><a href='../S/2187.html#L1370'>node</a>             1370 src/treesit.c    (Lisp_Object node)</span>
<span class='curline'><a href='../S/2187.html#L1372'>node</a>             1372 src/treesit.c    CHECK_TS_NODE (node);</span>
<span class='curline'><a href='../S/2187.html#L1373'>node</a>             1373 src/treesit.c    return XTS_NODE (node)-&gt;parser;</span>
<span class='curline'><a href='../S/2187.html#L1819'>node</a>             1819 src/treesit.c    (Lisp_Object node)</span>
<span class='curline'><a href='../S/2187.html#L1821'>node</a>             1821 src/treesit.c    if (NILP (node)) return Qnil;</span>
<span class='curline'><a href='../S/2187.html#L1822'>node</a>             1822 src/treesit.c    treesit_check_node (node);</span>
<span class='curline'><a href='../S/2187.html#L1825'>node</a>             1825 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L1834'>node</a>             1834 src/treesit.c    (Lisp_Object node)</span>
<span class='curline'><a href='../S/2187.html#L1836'>node</a>             1836 src/treesit.c    if (NILP (node)) return Qnil;</span>
<span class='curline'><a href='../S/2187.html#L1837'>node</a>             1837 src/treesit.c    treesit_check_node (node);</span>
<span class='curline'><a href='../S/2187.html#L1840'>node</a>             1840 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L1841'>node</a>             1841 src/treesit.c    ptrdiff_t visible_beg = XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;visible_beg;</span>
<span class='curline'><a href='../S/2187.html#L1844'>node</a>             1844 src/treesit.c      = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L1855'>node</a>             1855 src/treesit.c    (Lisp_Object node)</span>
<span class='curline'><a href='../S/2187.html#L1857'>node</a>             1857 src/treesit.c    if (NILP (node)) return Qnil;</span>
<span class='curline'><a href='../S/2187.html#L1858'>node</a>             1858 src/treesit.c    treesit_check_node (node);</span>
<span class='curline'><a href='../S/2187.html#L1861'>node</a>             1861 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L1862'>node</a>             1862 src/treesit.c    ptrdiff_t visible_beg = XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;visible_beg;</span>
<span class='curline'><a href='../S/2187.html#L1865'>node</a>             1865 src/treesit.c      = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L1875'>node</a>             1875 src/treesit.c    (Lisp_Object node)</span>
<span class='curline'><a href='../S/2187.html#L1877'>node</a>             1877 src/treesit.c    if (NILP (node)) return Qnil;</span>
<span class='curline'><a href='../S/2187.html#L1878'>node</a>             1878 src/treesit.c    treesit_check_node (node);</span>
<span class='curline'><a href='../S/2187.html#L1881'>node</a>             1881 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L1892'>node</a>             1892 src/treesit.c    (Lisp_Object node)</span>
<span class='curline'><a href='../S/2187.html#L1894'>node</a>             1894 src/treesit.c    if (NILP (node)) return Qnil;</span>
<span class='curline'><a href='../S/2187.html#L1895'>node</a>             1895 src/treesit.c    treesit_check_node (node);</span>
<span class='curline'><a href='../S/2187.html#L1900'>node</a>             1900 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L1901'>node</a>             1901 src/treesit.c    Lisp_Object parser = XTS_NODE (node)-&gt;parser;</span>
<span class='curline'><a href='../S/2187.html#L1924'>node</a>             1924 src/treesit.c    (Lisp_Object node, Lisp_Object n, Lisp_Object named)</span>
<span class='curline'><a href='../S/2187.html#L1926'>node</a>             1926 src/treesit.c    if (NILP (node)) return Qnil;</span>
<span class='curline'><a href='../S/2187.html#L1927'>node</a>             1927 src/treesit.c    treesit_check_node (node);</span>
<span class='curline'><a href='../S/2187.html#L1933'>node</a>             1933 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L1957'>node</a>             1957 src/treesit.c    return make_treesit_node (XTS_NODE (node)-&gt;parser, child);</span>
<span class='curline'><a href='../S/2187.html#L1985'>node</a>             1985 src/treesit.c    (Lisp_Object node, Lisp_Object property)</span>
<span class='curline'><a href='../S/2187.html#L1987'>node</a>             1987 src/treesit.c    if (NILP (node)) return Qnil;</span>
<span class='curline'><a href='../S/2187.html#L1988'>node</a>             1988 src/treesit.c    CHECK_TS_NODE (node);</span>
<span class='curline'><a href='../S/2187.html#L1992'>node</a>             1992 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L1996'>node</a>             1996 src/treesit.c      return treesit_node_uptodate_p (node) ? Qnil : Qt;</span>
<span class='curline'><a href='../S/2187.html#L1998'>node</a>             1998 src/treesit.c    treesit_check_node (node);</span>
<span class='curline'><a href='../S/2187.html#L2008'>node</a>             2008 src/treesit.c      result = treesit_parser_live_p (XTS_NODE (node)-&gt;parser);</span>
<span class='curline'><a href='../S/2187.html#L2027'>node</a>             2027 src/treesit.c    (Lisp_Object node, Lisp_Object n)</span>
<span class='curline'><a href='../S/2187.html#L2029'>node</a>             2029 src/treesit.c    if (NILP (node))</span>
<span class='curline'><a href='../S/2187.html#L2031'>node</a>             2031 src/treesit.c    treesit_check_node (node);</span>
<span class='curline'><a href='../S/2187.html#L2036'>node</a>             2036 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L2062'>node</a>             2062 src/treesit.c    (Lisp_Object node, Lisp_Object named)</span>
<span class='curline'><a href='../S/2187.html#L2064'>node</a>             2064 src/treesit.c    if (NILP (node))</span>
<span class='curline'><a href='../S/2187.html#L2066'>node</a>             2066 src/treesit.c    treesit_check_node (node);</span>
<span class='curline'><a href='../S/2187.html#L2069'>node</a>             2069 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L2083'>node</a>             2083 src/treesit.c    (Lisp_Object node, Lisp_Object field_name)</span>
<span class='curline'><a href='../S/2187.html#L2085'>node</a>             2085 src/treesit.c    if (NILP (node))</span>
<span class='curline'><a href='../S/2187.html#L2087'>node</a>             2087 src/treesit.c    treesit_check_node (node);</span>
<span class='curline'><a href='../S/2187.html#L2092'>node</a>             2092 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L2100'>node</a>             2100 src/treesit.c    return make_treesit_node (XTS_NODE (node)-&gt;parser, child);</span>
<span class='curline'><a href='../S/2187.html#L2110'>node</a>             2110 src/treesit.c    (Lisp_Object node, Lisp_Object named)</span>
<span class='curline'><a href='../S/2187.html#L2112'>node</a>             2112 src/treesit.c    if (NILP (node)) return Qnil;</span>
<span class='curline'><a href='../S/2187.html#L2113'>node</a>             2113 src/treesit.c    treesit_check_node (node);</span>
<span class='curline'><a href='../S/2187.html#L2116'>node</a>             2116 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L2126'>node</a>             2126 src/treesit.c    return make_treesit_node (XTS_NODE (node)-&gt;parser, sibling);</span>
<span class='curline'><a href='../S/2187.html#L2137'>node</a>             2137 src/treesit.c    (Lisp_Object node, Lisp_Object named)</span>
<span class='curline'><a href='../S/2187.html#L2139'>node</a>             2139 src/treesit.c    if (NILP (node)) return Qnil;</span>
<span class='curline'><a href='../S/2187.html#L2140'>node</a>             2140 src/treesit.c    treesit_check_node (node);</span>
<span class='curline'><a href='../S/2187.html#L2143'>node</a>             2143 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L2154'>node</a>             2154 src/treesit.c    return make_treesit_node (XTS_NODE (node)-&gt;parser, sibling);</span>
<span class='curline'><a href='../S/2187.html#L2172'>node</a>             2172 src/treesit.c    TSNode node = ts_tree_cursor_current_node (cursor);</span>
<span class='curline'><a href='../S/2187.html#L2173'>node</a>             2173 src/treesit.c    while (ts_node_end_byte (node) &lt;= pos)</span>
<span class='curline'><a href='../S/2187.html#L2176'>node</a>             2176 src/treesit.c  	node = ts_tree_cursor_current_node (cursor);</span>
<span class='curline'><a href='../S/2187.html#L2181'>node</a>             2181 src/treesit.c    while (named &amp;&amp; (!ts_node_is_named (node)))</span>
<span class='curline'><a href='../S/2187.html#L2184'>node</a>             2184 src/treesit.c  	node = ts_tree_cursor_current_node (cursor);</span>
<span class='curline'><a href='../S/2187.html#L2202'>node</a>             2202 src/treesit.c    (Lisp_Object node, Lisp_Object pos, Lisp_Object named)</span>
<span class='curline'><a href='../S/2187.html#L2204'>node</a>             2204 src/treesit.c    if (NILP (node))</span>
<span class='curline'><a href='../S/2187.html#L2206'>node</a>             2206 src/treesit.c    treesit_check_node (node);</span>
<span class='curline'><a href='../S/2187.html#L2208'>node</a>             2208 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L2209'>node</a>             2209 src/treesit.c    ptrdiff_t visible_beg = XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;visible_beg;</span>
<span class='curline'><a href='../S/2187.html#L2215'>node</a>             2215 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L2227'>node</a>             2227 src/treesit.c    return make_treesit_node (XTS_NODE (node)-&gt;parser, child);</span>
<span class='curline'><a href='../S/2187.html#L2239'>node</a>             2239 src/treesit.c    (Lisp_Object node, Lisp_Object beg, Lisp_Object end, Lisp_Object named)</span>
<span class='curline'><a href='../S/2187.html#L2241'>node</a>             2241 src/treesit.c    if (NILP (node)) return Qnil;</span>
<span class='curline'><a href='../S/2187.html#L2242'>node</a>             2242 src/treesit.c    treesit_check_node (node);</span>
<span class='curline'><a href='../S/2187.html#L2244'>node</a>             2244 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/2187.html#L2245'>node</a>             2245 src/treesit.c    ptrdiff_t visible_beg = XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;visible_beg;</span>
<span class='curline'><a href='../S/2187.html#L2254'>node</a>             2254 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L2267'>node</a>             2267 src/treesit.c    return make_treesit_node (XTS_NODE (node)-&gt;parser, child);</span>
<span class='curline'><a href='../S/2187.html#L2275'>node</a>             2275 src/treesit.c    TSNode treesit_node_1 = XTS_NODE (node1)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L2276'>node</a>             2276 src/treesit.c    TSNode treesit_node_2 = XTS_NODE (node2)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L2493'>node</a>             2493 src/treesit.c  					Lisp_Object *node,</span>
<span class='curline'><a href='../S/2187.html#L2496'>node</a>             2496 src/treesit.c    *node = Qnil;</span>
<span class='curline'><a href='../S/2187.html#L2502'>node</a>             2502 src/treesit.c  	  *node = XCDR (XCAR (tail));</span>
<span class='curline'><a href='../S/2187.html#L2507'>node</a>             2507 src/treesit.c    if (NILP (*node))</span>
<span class='curline'><a href='../S/2187.html#L2528'>node</a>             2528 src/treesit.c    Lisp_Object node = Qnil;</span>
<span class='curline'><a href='../S/2187.html#L2529'>node</a>             2529 src/treesit.c    if (!treesit_predicate_capture_name_to_node (name, captures, &amp;node, signal_data))</span>
<span class='curline'><a href='../S/2187.html#L2533'>node</a>             2533 src/treesit.c    set_buffer_internal (XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/2187.html#L2534'>node</a>             2534 src/treesit.c    *text = Fbuffer_substring (Ftreesit_node_start (node),</span>
<span class='curline'><a href='../S/2187.html#L2535'>node</a>             2535 src/treesit.c  			     Ftreesit_node_end (node));</span>
<span class='curline'><a href='../S/2187.html#L2607'>node</a>             2607 src/treesit.c    Lisp_Object node = Qnil;</span>
<span class='curline'><a href='../S/2187.html#L2608'>node</a>             2608 src/treesit.c    if (!treesit_predicate_capture_name_to_node (capture_name, captures, &amp;node,</span>
<span class='curline'><a href='../S/2187.html#L2612'>node</a>             2612 src/treesit.c    TSNode treesit_node = XTS_NODE (node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L2613'>node</a>             2613 src/treesit.c    ptrdiff_t visible_beg = XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;visible_beg;</span>
<span class='curline'><a href='../S/2187.html#L2663'>node</a>             2663 src/treesit.c      Lisp_Object node = Qnil;</span>
<span class='curline'><a href='../S/2187.html#L2664'>node</a>             2664 src/treesit.c      if (!treesit_predicate_capture_name_to_node (XCAR (tail), captures, &amp;node,</span>
<span class='curline'><a href='../S/2187.html#L2667'>node</a>             2667 src/treesit.c      nodes = Fcons (node, nodes);</span>
<span class='curline'><a href='../S/2187.html#L2868'>node</a>             2868 src/treesit.c    (Lisp_Object node, Lisp_Object query,</span>
<span class='curline'><a href='../S/2187.html#L2878'>node</a>             2878 src/treesit.c    Lisp_Object lisp_node = treesit_resolve_node (node);</span>
<span class='curline'><a href='../S/2187.html#L2881'>node</a>             2881 src/treesit.c    TSNode treesit_node = XTS_NODE (lisp_node)-&gt;node;</span>
<span class='curline'><a href='../S/2187.html#L2958'>node</a>             2958 src/treesit.c  							 capture.node);</span>
<span class='curline'><a href='../S/2187.html#L3081'>node</a>             3081 src/treesit.c  treesit_cursor_helper (TSTreeCursor *cursor, TSNode node, Lisp_Object parser)</span>
<span class='curline'><a href='../S/2187.html#L3083'>node</a>             3083 src/treesit.c    uint32_t end_pos = ts_node_end_byte (node);</span>
<span class='curline'><a href='../S/2187.html#L3086'>node</a>             3086 src/treesit.c    bool success = treesit_cursor_helper_1 (cursor, &amp;node, end_pos,</span>
<span class='curline'><a href='../S/2187.html#L3352'>node</a>             3352 src/treesit.c    TSNode node = ts_tree_cursor_current_node (cursor);</span>
<span class='curline'><a href='../S/2187.html#L3353'>node</a>             3353 src/treesit.c    if (named &amp;&amp; !ts_node_is_named (node))</span>
<span class='curline'><a href='../S/2187.html#L3358'>node</a>             3358 src/treesit.c        const char *type = ts_node_type (node);</span>
<span class='curline'><a href='../S/2187.html#L3363'>node</a>             3363 src/treesit.c        Lisp_Object lisp_node = make_treesit_node (parser, node);</span>
<span class='curline'><a href='../S/2187.html#L3395'>node</a>             3395 src/treesit.c  	  const char *type = ts_node_type (node);</span>
<span class='curline'><a href='../S/2187.html#L3399'>node</a>             3399 src/treesit.c  	  Lisp_Object lisp_node = make_treesit_node (parser, node);</span>
<span class='curline'><a href='../S/2187.html#L3520'>node</a>             3520 src/treesit.c    (Lisp_Object node, Lisp_Object predicate, Lisp_Object backward,</span>
<span class='curline'><a href='../S/2187.html#L3523'>node</a>             3523 src/treesit.c    CHECK_TS_NODE (node);</span>
<span class='curline'><a href='../S/2187.html#L3538'>node</a>             3538 src/treesit.c    Lisp_Object parser = XTS_NODE (node)-&gt;parser;</span>
<span class='curline'><a href='../S/2187.html#L3548'>node</a>             3548 src/treesit.c    if (!treesit_cursor_helper (&amp;cursor, XTS_NODE (node)-&gt;node, parser))</span>
<span class='curline'><a href='../S/2187.html#L3557'>node</a>             3557 src/treesit.c        TSNode node = ts_tree_cursor_current_node (&amp;cursor);</span>
<span class='curline'><a href='../S/2187.html#L3558'>node</a>             3558 src/treesit.c        return_value = make_treesit_node (parser, node);</span>
<span class='curline'><a href='../S/2187.html#L3613'>node</a>             3613 src/treesit.c    if (!treesit_cursor_helper (&amp;cursor, XTS_NODE (start)-&gt;node, parser))</span>
<span class='curline'><a href='../S/2187.html#L3622'>node</a>             3622 src/treesit.c        TSNode node = ts_tree_cursor_current_node (&amp;cursor);</span>
<span class='curline'><a href='../S/2187.html#L3623'>node</a>             3623 src/treesit.c        return_value = make_treesit_node (parser, node);</span>
<span class='curline'><a href='../S/2187.html#L3645'>node</a>             3645 src/treesit.c        TSNode node = ts_tree_cursor_current_node (cursor);</span>
<span class='curline'><a href='../S/2187.html#L3646'>node</a>             3646 src/treesit.c        Lisp_Object lisp_node = make_treesit_node (parser, node);</span>
<span class='curline'><a href='../S/2187.html#L3746'>node</a>             3746 src/treesit.c    TSTreeCursor cursor = ts_tree_cursor_new (XTS_NODE (root)-&gt;node);</span>
<span class='curline'><a href='../S/2187.html#L3772'>node</a>             3772 src/treesit.c    (Lisp_Object node, Lisp_Object predicate)</span>
<span class='curline'><a href='../S/2187.html#L3774'>node</a>             3774 src/treesit.c    CHECK_TS_NODE (node);</span>
<span class='curline'><a href='../S/2187.html#L3776'>node</a>             3776 src/treesit.c    Lisp_Object parser = XTS_NODE (node)-&gt;parser;</span>
<span class='curline'><a href='../S/2187.html#L3784'>node</a>             3784 src/treesit.c    TSTreeCursor cursor = ts_tree_cursor_new (XTS_NODE (node)-&gt;node);</span>
<span class='curline'><a href='../S/2187.html#L3807'>node</a>             3807 src/treesit.c    (Lisp_Object node)</span>
<span class='curline'><a href='../S/2187.html#L3811'>node</a>             3811 src/treesit.c    CHECK_TS_NODE (node);</span>
<span class='curline'><a href='../S/2187.html#L3815'>node</a>             3815 src/treesit.c    TSTreeCursor cursor = ts_tree_cursor_new (XTS_NODE (node)-&gt;node);</span>
<span class='curline'><a href='../S/1992.html#L89'>node</a>               89 src/treesit.h    TSNode node;</span>
<span class='curline'><a href='../S/1992.html#L170'>node</a>              170 src/treesit.h  CHECK_TS_NODE (Lisp_Object node)</span>
<span class='curline'><a href='../S/1992.html#L172'>node</a>              172 src/treesit.h    CHECK_TYPE (TS_NODEP (node), Qtreesit_node_p, node);</span>
<span class='curline'><a href='../S/2191.html#L8262'>node</a>             8262 src/w32.c      sys_getaddrinfo (const char *node, const char *service,</span>
<span class='curline'><a href='../S/2191.html#L8275'>node</a>             8275 src/w32.c          rc = pfn_getaddrinfo (node, service, hints, res);</span>
<span class='curline'><a href='../S/2191.html#L8289'>node</a>             8289 src/w32.c            if (!node)</span>
<span class='curline'><a href='../S/2191.html#L8315'>node</a>             8315 src/w32.c            host_info = sys_gethostbyname (node);</span>
<span class='curline'><a href='../S/2191.html#L8325'>node</a>             8325 src/w32.c      	  unsigned long numeric_addr = sys_inet_addr (node);</span>
<span class='curline'><a href='../S/2118.html#L6751'>node</a>             6751 src/xdisp.c      struct itree_node *node;</span>
<span class='curline'><a href='../S/2118.html#L6786'>node</a>             6786 src/xdisp.c      ITREE_FOREACH (node, current_buffer-&gt;overlays, charpos - 1, charpos + 1, DESCENDING)</span>
<span class='curline'><a href='../S/2118.html#L6788'>node</a>             6788 src/xdisp.c          Lisp_Object overlay = node-&gt;data;</span>
<span class='curline'><a href='../S/2118.html#L6790'>node</a>             6790 src/xdisp.c          ptrdiff_t start = node-&gt;begin;</span>
<span class='curline'><a href='../S/2118.html#L6791'>node</a>             6791 src/xdisp.c          ptrdiff_t end = node-&gt;end;</span>
<span class='curline'><a href='../S/2118.html#L7225'>node</a>             7225 src/xdisp.c      struct itree_node *node;</span>
<span class='curline'><a href='../S/2118.html#L7227'>node</a>             7227 src/xdisp.c      ITREE_FOREACH (node, current_buffer-&gt;overlays, startpos, endpos, DESCENDING)</span>
<span class='curline'><a href='../S/2118.html#L7229'>node</a>             7229 src/xdisp.c          Lisp_Object overlay = node-&gt;data;</span>
<span class='curline'><a href='../S/2118.html#L7237'>node</a>             7237 src/xdisp.c          ptrdiff_t ostart = node-&gt;begin;</span>
<span class='curline'><a href='../S/2118.html#L7238'>node</a>             7238 src/xdisp.c          ptrdiff_t oend = node-&gt;end;</span>
<span class='curline'><a href='../S/2024.html#L123'>node</a>              123 src/xml.c      make_dom (xmlNode *node)</span>
<span class='curline'><a href='../S/2024.html#L125'>node</a>              125 src/xml.c        if (node-&gt;type == XML_ELEMENT_NODE)</span>
<span class='curline'><a href='../S/2024.html#L127'>node</a>              127 src/xml.c            Lisp_Object result = list1 (intern ((char *) node-&gt;name));</span>
<span class='curline'><a href='../S/2024.html#L133'>node</a>              133 src/xml.c            property = node-&gt;properties;</span>
<span class='curline'><a href='../S/2024.html#L149'>node</a>              149 src/xml.c            child = node-&gt;children;</span>
<span class='curline'><a href='../S/2024.html#L158'>node</a>              158 src/xml.c        else if (node-&gt;type == XML_TEXT_NODE || node-&gt;type == XML_CDATA_SECTION_NODE)</span>
<span class='curline'><a href='../S/2024.html#L160'>node</a>              160 src/xml.c            if (node-&gt;content)</span>
<span class='curline'><a href='../S/2024.html#L161'>node</a>              161 src/xml.c      	return build_string ((char *) node-&gt;content);</span>
<span class='curline'><a href='../S/2024.html#L165'>node</a>              165 src/xml.c        else if (node-&gt;type == XML_COMMENT_NODE)</span>
<span class='curline'><a href='../S/2024.html#L167'>node</a>              167 src/xml.c            if (node-&gt;content)</span>
<span class='curline'><a href='../S/2024.html#L169'>node</a>              169 src/xml.c      		      build_string ((char *) node-&gt;content));</span>
<span class='curline'><a href='../S/2024.html#L257'>node</a>              257 src/xml.c      	xmlNode *node = xmlDocGetRootElement (doc);</span>
<span class='curline'><a href='../S/2024.html#L258'>node</a>              258 src/xml.c      	if (node != NULL)</span>
<span class='curline'><a href='../S/2024.html#L259'>node</a>              259 src/xml.c      	  result = make_dom (node);</span>
<span class='curline'><a href='../S/3856.html#L162'>node</a>              162 test/manual/etags/c-src/c.c node *lasta = NULL;</span>
<span class='curline'><a href='../S/3856.html#L168'>node</a>              168 test/manual/etags/c-src/c.c node *lastb = NULL;</span>
<span class='curline'><a href='../S/3865.html#L315'>node</a>              315 test/manual/etags/c-src/etags.c static void add_node (node *, node **);</span>
<span class='curline'><a href='../S/3865.html#L321'>node</a>              321 test/manual/etags/c-src/etags.c static void free_tree (node *);</span>
<span class='curline'><a href='../S/3865.html#L324'>node</a>              324 test/manual/etags/c-src/etags.c static void invalidate_nodes (fdesc *, node **);</span>
<span class='curline'><a href='../S/3865.html#L325'>node</a>              325 test/manual/etags/c-src/etags.c static void put_entries (node *);</span>
<span class='curline'><a href='../S/3865.html#L363'>node</a>              363 test/manual/etags/c-src/etags.c static node *nodehead;		/* the head of the binary tree of tags */</span>
<span class='curline'><a href='../S/3865.html#L364'>node</a>              364 test/manual/etags/c-src/etags.c static node *last_node;		/* the last node created */</span>
<span class='curline'><a href='../S/3865.html#L1595'>node</a>             1595 test/manual/etags/c-src/etags.c       node *np, *prev;</span>
<span class='curline'><a href='../S/3865.html#L1729'>node</a>             1729 test/manual/etags/c-src/etags.c       node *old_last_node = last_node;</span>
<span class='curline'><a href='../S/3865.html#L1865'>node</a>             1865 test/manual/etags/c-src/etags.c   register node *np;</span>
<span class='curline'><a href='../S/3865.html#L1871'>node</a>             1871 test/manual/etags/c-src/etags.c   np = xnew (1, node);</span>
<span class='curline'><a href='../S/3865.html#L1917'>node</a>             1917 test/manual/etags/c-src/etags.c free_tree (register node *np)</span>
<span class='curline'><a href='../S/3865.html#L1921'>node</a>             1921 test/manual/etags/c-src/etags.c       register node *node_right = np-&gt;right;</span>
<span class='curline'><a href='../S/3865.html#L1955'>node</a>             1955 test/manual/etags/c-src/etags.c add_node (node *np, node **cur_node_p)</span>
<span class='curline'><a href='../S/3865.html#L1958'>node</a>             1958 test/manual/etags/c-src/etags.c   register node *cur_node = *cur_node_p;</span>
<span class='curline'><a href='../S/3865.html#L2035'>node</a>             2035 test/manual/etags/c-src/etags.c invalidate_nodes (fdesc *badfdp, node **npp)</span>
<span class='curline'><a href='../S/3865.html#L2037'>node</a>             2037 test/manual/etags/c-src/etags.c   node *np = *npp;</span>
<span class='curline'><a href='../S/3865.html#L2067'>node</a>             2067 test/manual/etags/c-src/etags.c static int total_size_of_entries (node *);</span>
<span class='curline'><a href='../S/3865.html#L2087'>node</a>             2087 test/manual/etags/c-src/etags.c total_size_of_entries (register node *np)</span>
<span class='curline'><a href='../S/3865.html#L2107'>node</a>             2107 test/manual/etags/c-src/etags.c put_entries (register node *np)</span>
<span class='curline'><a href='../S/3908.html#L81'>node</a>               81 test/manual/etags/y-src/parse.c typedef struct node *YYSTYPE;</span>
<span class='curline'><a href='../S/3908.html#L1148'>node</a>             1148 test/manual/etags/y-src/parse.c 		(yyvsp[-3])-&gt;n_x.v_subs[1]=(struct node *)0;</span>
<span class='curline'><a href='../S/3908.html#L1175'>node</a>             1175 test/manual/etags/y-src/parse.c 		(yyvsp[-3])-&gt;n_x.v_subs[0]=(struct node *)0;</span>
<span class='curline'><a href='../S/3908.html#L1242'>node</a>             1242 test/manual/etags/y-src/parse.c 		(yyvsp[-3])-&gt;n_x.v_subs[0]=(struct node *)0;</span>
<span class='curline'><a href='../S/3908.html#L1361'>node</a>             1361 test/manual/etags/y-src/parse.c 			yyvsp[-1]-&gt;n_x.v_subs[1]=(struct node *)0;</span>
<span class='curline'><a href='../S/3908.html#L1369'>node</a>             1369 test/manual/etags/y-src/parse.c 		yyvsp[-1]-&gt;n_x.v_subs[1]=(struct node *)0;</span>
<span class='curline'><a href='../S/3908.html#L1667'>node</a>             1667 test/manual/etags/y-src/parse.c extern struct node *yylval;</span>
<span class='curline'><a href='../S/3908.html#L1679'>node</a>             1679 test/manual/etags/y-src/parse.c 	struct node *new;</span>
<span class='curline'><a href='../S/3908.html#L1701'>node</a>             1701 test/manual/etags/y-src/parse.c 	new=(struct node *)obstack_alloc(&amp;tmp_mem,sizeof(struct node));</span>
<span class='curline'><a href='../S/3905.html#L73'>node</a>               73 test/manual/etags/y-src/parse.y typedef struct node *YYSTYPE;</span>
<span class='curline'><a href='../S/3905.html#L101'>node</a>              101 test/manual/etags/y-src/parse.y 		($1)-&gt;n_x.v_subs[1]=(struct node *)0;</span>
<span class='curline'><a href='../S/3905.html#L116'>node</a>              116 test/manual/etags/y-src/parse.y 		($1)-&gt;n_x.v_subs[0]=(struct node *)0;</span>
<span class='curline'><a href='../S/3905.html#L161'>node</a>              161 test/manual/etags/y-src/parse.y 		($1)-&gt;n_x.v_subs[0]=(struct node *)0;</span>
<span class='curline'><a href='../S/3905.html#L239'>node</a>              239 test/manual/etags/y-src/parse.y 			$1-&gt;n_x.v_subs[1]=(struct node *)0;</span>
<span class='curline'><a href='../S/3905.html#L244'>node</a>              244 test/manual/etags/y-src/parse.y 		$1-&gt;n_x.v_subs[1]=(struct node *)0;</span>
<span class='curline'><a href='../S/3905.html#L306'>node</a>              306 test/manual/etags/y-src/parse.y extern struct node *yylval;</span>
<span class='curline'><a href='../S/3905.html#L318'>node</a>              318 test/manual/etags/y-src/parse.y 	struct node *new;</span>
<span class='curline'><a href='../S/3905.html#L340'>node</a>              340 test/manual/etags/y-src/parse.y 	new=(struct node *)obstack_alloc(&amp;tmp_mem,sizeof(struct node));</span>
<span class='curline'><a href='../S/3851.html#L750'>node</a>              750 test/manual/noverlay/itree-tests.c   struct itree_node node = {0}, *n;</span>
<span class='curline'><a href='../S/3851.html#L754'>node</a>              754 test/manual/noverlay/itree-tests.c   itree_insert (&amp;tree, &amp;node, 10, 20);</span>
<span class='curline'><a href='../S/3851.html#L757'>node</a>              757 test/manual/noverlay/itree-tests.c   ck_assert_ptr_eq (n, &amp;node);</span>
<span class='curline'><a href='../S/3851.html#L783'>node</a>              783 test/manual/noverlay/itree-tests.c       struct itree_node *node = itree_iterator_next (g);</span>
<span class='curline'><a href='../S/3851.html#L784'>node</a>              784 test/manual/noverlay/itree-tests.c       ck_assert_ptr_nonnull (node);</span>
<span class='curline'><a href='../S/3851.html#L785'>node</a>              785 test/manual/noverlay/itree-tests.c       ck_assert_int_eq (node-&gt;begin, va_arg (ap, ptrdiff_t));</span>
<span class='curline'><a href='../S/3851.html#L832'>node</a>              832 test/manual/noverlay/itree-tests.c       struct itree_node *node = &amp;nodes[index[i]];</span>
<span class='curline'><a href='../S/3851.html#L833'>node</a>              833 test/manual/noverlay/itree-tests.c       itree_insert (&amp;tree, node, node-&gt;begin, node-&gt;end);</span>
</pre>
</body>
</html>
