<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>buffer</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.7' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/3802.html#L99'>buffer</a>             99 exec/exec.c      static char buffer[PATH_MAX], *start;</span>
<span class='curline'><a href='../S/3802.html#L112'>buffer</a>            112 exec/exec.c      rc = read (fd, buffer, PATH_MAX);</span>
<span class='curline'><a href='../S/3802.html#L118'>buffer</a>            118 exec/exec.c      start = buffer;</span>
<span class='curline'><a href='../S/3802.html#L486'>buffer</a>            486 exec/exec.c      char buffer[PATH_MAX + 1];</span>
<span class='curline'><a href='../S/3802.html#L493'>buffer</a>            493 exec/exec.c      rc = pread (fd, buffer, size, prog_header-&gt;p_offset);</span>
<span class='curline'><a href='../S/3802.html#L498'>buffer</a>            498 exec/exec.c      buffer[size] = '\0';</span>
<span class='curline'><a href='../S/3802.html#L503'>buffer</a>            503 exec/exec.c      if (access (buffer, X_OK))</span>
<span class='curline'><a href='../S/3802.html#L512'>buffer</a>            512 exec/exec.c      fd = open (buffer, O_RDONLY);</span>
<span class='curline'><a href='../S/3802.html#L565'>buffer</a>            565 exec/exec.c      if (write_open_command (buffer, true))</span>
<span class='curline'><a href='../S/3802.html#L574'>buffer</a>            574 exec/exec.c          if (process_interpreter_1 (buffer, fd, &amp;program,</span>
<span class='curline'><a href='../S/3802.html#L925'>buffer</a>            925 exec/exec.c      char buffer[80], buffer1[PATH_MAX + 80], *rewrite;</span>
<span class='curline'><a href='../S/3802.html#L946'>buffer</a>            946 exec/exec.c    	  memset (buffer, 0, sizeof buffer);</span>
<span class='curline'><a href='../S/3802.html#L950'>buffer</a>            950 exec/exec.c    	  rewrite = stpcpy (buffer, "/proc/");</span>
<span class='curline'><a href='../S/3802.html#L956'>buffer</a>            956 exec/exec.c    	  link_size = readlink (buffer, buffer1,</span>
<span class='curline'><a href='../S/3796.html#L143'>buffer</a>            143 exec/trace.c   read_memory (struct exec_tracee *tracee, char *buffer,</span>
<span class='curline'><a href='../S/3796.html#L153'>buffer</a>            153 exec/trace.c     iov.iov_base = buffer;</span>
<span class='curline'><a href='../S/3796.html#L182'>buffer</a>            182 exec/trace.c         memcpy (buffer, &amp;word, sizeof word);</span>
<span class='curline'><a href='../S/3796.html#L183'>buffer</a>            183 exec/trace.c         buffer += sizeof word;</span>
<span class='curline'><a href='../S/3796.html#L198'>buffer</a>            198 exec/trace.c         memcpy (buffer, &amp;word, n_bytes);</span>
<span class='curline'><a href='../S/3796.html#L280'>buffer</a>            280 exec/trace.c   user_copy (struct exec_tracee *tracee, const unsigned char *buffer,</span>
<span class='curline'><a href='../S/3796.html#L291'>buffer</a>            291 exec/trace.c     iov.iov_base = (void *) buffer;</span>
<span class='curline'><a href='../S/3796.html#L314'>buffer</a>            314 exec/trace.c   	  memcpy (&amp;word, buffer, sizeof word);</span>
<span class='curline'><a href='../S/3796.html#L315'>buffer</a>            315 exec/trace.c   	  buffer += sizeof word;</span>
<span class='curline'><a href='../S/3796.html#L332'>buffer</a>            332 exec/trace.c   	  memcpy (bytes, buffer, end - start);</span>
<span class='curline'><a href='../S/3796.html#L686'>buffer</a>            686 exec/trace.c     char buffer[PATH_MAX + 80], *area;</span>
<span class='curline'><a href='../S/3796.html#L697'>buffer</a>            697 exec/trace.c     read_memory (tracee, buffer, PATH_MAX,</span>
<span class='curline'><a href='../S/3796.html#L702'>buffer</a>            702 exec/trace.c     if (!memchr (buffer, '\0', PATH_MAX))</span>
<span class='curline'><a href='../S/3796.html#L713'>buffer</a>            713 exec/trace.c     area = exec_0 (buffer, tracee, &amp;size, regs);</span>
<span class='curline'><a href='../S/3796.html#L780'>buffer</a>            780 exec/trace.c     tracee-&gt;exec_file = strdup (buffer);</span>
<span class='curline'><a href='../S/3796.html#L924'>buffer</a>            924 exec/trace.c     char buffer[PATH_MAX + 1];</span>
<span class='curline'><a href='../S/3796.html#L945'>buffer</a>            945 exec/trace.c     read_memory (tracee, buffer, PATH_MAX, address);</span>
<span class='curline'><a href='../S/3796.html#L949'>buffer</a>            949 exec/trace.c     if (!memchr (buffer, '\0', PATH_MAX))</span>
<span class='curline'><a href='../S/3796.html#L960'>buffer</a>            960 exec/trace.c     if (strcmp (buffer, "/proc/self/exe") || !tracee-&gt;exec_file)</span>
<span class='curline'><a href='../S/3796.html#L968'>buffer</a>            968 exec/trace.c     strncpy (buffer, tracee-&gt;exec_file, length);</span>
<span class='curline'><a href='../S/3796.html#L970'>buffer</a>            970 exec/trace.c     if (user_copy (tracee, (unsigned char *) buffer,</span>
<span class='curline'><a href='../S/3973.html#L501'>buffer</a>            501 java/org/gnu/emacs/EmacsDocumentsProvider.java     byte buffer[];</span>
<span class='curline'><a href='../S/3973.html#L540'>buffer</a>            540 java/org/gnu/emacs/EmacsDocumentsProvider.java 	buffer = new byte[4096];</span>
<span class='curline'><a href='../S/3973.html#L542'>buffer</a>            542 java/org/gnu/emacs/EmacsDocumentsProvider.java 	while ((length = inputStream.read (buffer)) &gt; 0)</span>
<span class='curline'><a href='../S/3973.html#L543'>buffer</a>            543 java/org/gnu/emacs/EmacsDocumentsProvider.java 	  outputStream.write (buffer, 0, length);</span>
<span class='curline'><a href='../S/3998.html#L147'>buffer</a>            147 java/org/gnu/emacs/EmacsOpenActivity.java     char[] buffer;</span>
<span class='curline'><a href='../S/3998.html#L169'>buffer</a>            169 java/org/gnu/emacs/EmacsOpenActivity.java 	buffer = new char[2048];</span>
<span class='curline'><a href='../S/3998.html#L171'>buffer</a>            171 java/org/gnu/emacs/EmacsOpenActivity.java 	while ((rc = reader.read (buffer, 0, 2048)) != -1)</span>
<span class='curline'><a href='../S/3998.html#L172'>buffer</a>            172 java/org/gnu/emacs/EmacsOpenActivity.java 	  builder.append (buffer, 0, rc);</span>
<span class='curline'><a href='../S/3998.html#L231'>buffer</a>            231 java/org/gnu/emacs/EmacsOpenActivity.java     byte buffer[];</span>
<span class='curline'><a href='../S/3998.html#L253'>buffer</a>            253 java/org/gnu/emacs/EmacsOpenActivity.java     buffer = new byte[4098];</span>
<span class='curline'><a href='../S/3998.html#L264'>buffer</a>            264 java/org/gnu/emacs/EmacsOpenActivity.java 	while ((read = stream.read (buffer)) &gt;= 0)</span>
<span class='curline'><a href='../S/3998.html#L265'>buffer</a>            265 java/org/gnu/emacs/EmacsOpenActivity.java 	  outStream.write (buffer, 0, read);</span>
<span class='curline'><a href='../S/43.html#L3558'>buffer</a>           3558 lib-src/ebrowse.c   static char *buffer;</span>
<span class='curline'><a href='../S/43.html#L3572'>buffer</a>           3572 lib-src/ebrowse.c 	  buffer = (char *) xrealloc (buffer, buffer_size);</span>
<span class='curline'><a href='../S/43.html#L3575'>buffer</a>           3575 lib-src/ebrowse.c       char *z = stpcpy (buffer, path-&gt;path);</span>
<span class='curline'><a href='../S/43.html#L3578'>buffer</a>           3578 lib-src/ebrowse.c       fp = fopen (buffer, "r");</span>
<span class='curline'><a href='../S/43.html#L3701'>buffer</a>           3701 lib-src/ebrowse.c   static char *buffer;</span>
<span class='curline'><a href='../S/43.html#L3710'>buffer</a>           3710 lib-src/ebrowse.c 	  buffer = (char *) xrealloc (buffer, buffer_size);</span>
<span class='curline'><a href='../S/43.html#L3713'>buffer</a>           3713 lib-src/ebrowse.c       buffer[i++] = c;</span>
<span class='curline'><a href='../S/43.html#L3722'>buffer</a>           3722 lib-src/ebrowse.c       buffer = (char *) xrealloc (buffer, buffer_size);</span>
<span class='curline'><a href='../S/43.html#L3725'>buffer</a>           3725 lib-src/ebrowse.c   buffer[i] = '\0';</span>
<span class='curline'><a href='../S/43.html#L3726'>buffer</a>           3726 lib-src/ebrowse.c   if (i &gt; 0 &amp;&amp; buffer[i - 1] == '\r')</span>
<span class='curline'><a href='../S/43.html#L3727'>buffer</a>           3727 lib-src/ebrowse.c     buffer[i - 1] = '\0';</span>
<span class='curline'><a href='../S/43.html#L3728'>buffer</a>           3728 lib-src/ebrowse.c   return buffer;</span>
<span class='curline'><a href='../S/37.html#L377'>buffer</a>            377 lib-src/emacsclient.c 	  char *buffer = xmalloc (size);</span>
<span class='curline'><a href='../S/37.html#L378'>buffer</a>            378 lib-src/emacsclient.c 	  if (ExpandEnvironmentStrings (value, buffer, size))</span>
<span class='curline'><a href='../S/37.html#L382'>buffer</a>            382 lib-src/emacsclient.c 	      return buffer;</span>
<span class='curline'><a href='../S/37.html#L386'>buffer</a>            386 lib-src/emacsclient.c 	  free (buffer);</span>
<span class='curline'><a href='../S/40.html#L310'>buffer</a>            310 lib-src/etags.c   char *buffer;</span>
<span class='curline'><a href='../S/40.html#L1342'>buffer</a>           1342 lib-src/etags.c 		    process_file_name (filename_lb.buffer, lang);</span>
<span class='curline'><a href='../S/40.html#L1357'>buffer</a>           1357 lib-src/etags.c   free (lb.buffer);</span>
<span class='curline'><a href='../S/40.html#L1358'>buffer</a>           1358 lib-src/etags.c   free (filebuf.buffer);</span>
<span class='curline'><a href='../S/40.html#L1359'>buffer</a>           1359 lib-src/etags.c   free (token_name.buffer);</span>
<span class='curline'><a href='../S/40.html#L1471'>buffer</a>           1471 lib-src/etags.c       if (strstr (line.buffer, buf) == NULL)</span>
<span class='curline'><a href='../S/40.html#L1473'>buffer</a>           1473 lib-src/etags.c           fprintf (otags_f, "%s\n", line.buffer);</span>
<span class='curline'><a href='../S/40.html#L1479'>buffer</a>           1479 lib-src/etags.c   free (line.buffer);</span>
<span class='curline'><a href='../S/40.html#L1887'>buffer</a>           1887 lib-src/etags.c       &amp;&amp; lb.buffer[0] == '#'</span>
<span class='curline'><a href='../S/40.html#L1888'>buffer</a>           1888 lib-src/etags.c       &amp;&amp; lb.buffer[1] == '!')</span>
<span class='curline'><a href='../S/40.html#L1895'>buffer</a>           1895 lib-src/etags.c       lp = strrchr (lb.buffer+2, '/');</span>
<span class='curline'><a href='../S/40.html#L1899'>buffer</a>           1899 lib-src/etags.c 	lp = skip_spaces (lb.buffer + 2);</span>
<span class='curline'><a href='../S/40.html#L2952'>buffer</a>           2952 lib-src/etags.c       cn-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/40.html#L2958'>buffer</a>           2958 lib-src/etags.c       strcpy (cn-&gt;buffer, cstack.cname[0]);</span>
<span class='curline'><a href='../S/40.html#L2968'>buffer</a>           2968 lib-src/etags.c       memcpyz (stpcpy (cn-&gt;buffer + len, qualifier), s, slen);</span>
<span class='curline'><a href='../S/40.html#L3203'>buffer</a>           3203 lib-src/etags.c 	   memcpyz (token_name.buffer, str, len);</span>
<span class='curline'><a href='../S/40.html#L3220'>buffer</a>           3220 lib-src/etags.c 	       memcpyz (token_name.buffer + oldlen, str, len);</span>
<span class='curline'><a href='../S/40.html#L3351'>buffer</a>           3351 lib-src/etags.c   lp = curlb.buffer;							\</span>
<span class='curline'><a href='../S/40.html#L3374'>buffer</a>           3374 lib-src/etags.c     make_tag (token_name.buffer, token_name.len, isfun, token.line,</span>
<span class='curline'><a href='../S/40.html#L3378'>buffer</a>           3378 lib-src/etags.c       make_tag (concat ("INVALID TOKEN:--&gt;", token_name.buffer, ""),</span>
<span class='curline'><a href='../S/40.html#L3434'>buffer</a>           3434 lib-src/etags.c   lp = curlb.buffer;</span>
<span class='curline'><a href='../S/40.html#L3584'>buffer</a>           3584 lib-src/etags.c 	      for (cp = newlb.buffer; cp &lt; lp-1; cp++)</span>
<span class='curline'><a href='../S/40.html#L3658'>buffer</a>           3658 lib-src/etags.c 			  || consider_token (newlb.buffer + tokoff, toklen, c,</span>
<span class='curline'><a href='../S/40.html#L3685'>buffer</a>           3685 lib-src/etags.c 				  memcpyz (stpcpy (token_name.buffer + len,</span>
<span class='curline'><a href='../S/40.html#L3687'>buffer</a>           3687 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/40.html#L3692'>buffer</a>           3692 lib-src/etags.c 				  memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/40.html#L3693'>buffer</a>           3693 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/40.html#L3704'>buffer</a>           3704 lib-src/etags.c 				  char *p1 = stpcpy (token_name.buffer, objtag);</span>
<span class='curline'><a href='../S/40.html#L3706'>buffer</a>           3706 lib-src/etags.c 				  char *p3 = mempcpy (p2, newlb.buffer + tokoff,</span>
<span class='curline'><a href='../S/40.html#L3713'>buffer</a>           3713 lib-src/etags.c 				  memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/40.html#L3714'>buffer</a>           3714 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/40.html#L3727'>buffer</a>           3727 lib-src/etags.c 			      bool defun = (newlb.buffer[tokoff] == 'F');</span>
<span class='curline'><a href='../S/40.html#L3738'>buffer</a>           3738 lib-src/etags.c 				  memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/40.html#L3739'>buffer</a>           3739 lib-src/etags.c 					   newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/40.html#L3744'>buffer</a>           3744 lib-src/etags.c 				  token.line = newlb.buffer;</span>
<span class='curline'><a href='../S/40.html#L3752'>buffer</a>           3752 lib-src/etags.c 			      memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/40.html#L3753'>buffer</a>           3753 lib-src/etags.c 				       newlb.buffer + off, len);</span>
<span class='curline'><a href='../S/40.html#L3756'>buffer</a>           3756 lib-src/etags.c 				  if (token_name.buffer[len] == '_')</span>
<span class='curline'><a href='../S/40.html#L3757'>buffer</a>           3757 lib-src/etags.c 				    token_name.buffer[len] = '-';</span>
<span class='curline'><a href='../S/40.html#L3763'>buffer</a>           3763 lib-src/etags.c 			      memcpyz (token_name.buffer,</span>
<span class='curline'><a href='../S/40.html#L3764'>buffer</a>           3764 lib-src/etags.c 				       newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/40.html#L3779'>buffer</a>           3779 lib-src/etags.c 			  token.line = newlb.buffer;</span>
<span class='curline'><a href='../S/40.html#L3854'>buffer</a>           3854 lib-src/etags.c 	      if (!yacc_rules || lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/40.html#L3856'>buffer</a>           3856 lib-src/etags.c 		  tokoff = lp - 1 - newlb.buffer;</span>
<span class='curline'><a href='../S/40.html#L3892'>buffer</a>           3892 lib-src/etags.c 		  strcpy (token_name.buffer + toklen, ":");</span>
<span class='curline'><a href='../S/40.html#L4148'>buffer</a>           4148 lib-src/etags.c 		  char *cc, *uqname = token_name.buffer;</span>
<span class='curline'><a href='../S/40.html#L4149'>buffer</a>           4149 lib-src/etags.c 		  char *tok_end = token_name.buffer + token_name.len;</span>
<span class='curline'><a href='../S/40.html#L4151'>buffer</a>           4151 lib-src/etags.c 		  for (cc = token_name.buffer; cc &lt; tok_end; cc++)</span>
<span class='curline'><a href='../S/40.html#L4159'>buffer</a>           4159 lib-src/etags.c 		  if (uqname &gt; token_name.buffer)</span>
<span class='curline'><a href='../S/40.html#L4163'>buffer</a>           4163 lib-src/etags.c 		      memmove (token_name.buffer, uqname, uqlen + 1);</span>
<span class='curline'><a href='../S/40.html#L4226'>buffer</a>           4226 lib-src/etags.c 	  if (!ignoreindent &amp;&amp; lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/40.html#L4324'>buffer</a>           4324 lib-src/etags.c   free (lbs[0].lb.buffer);</span>
<span class='curline'><a href='../S/40.html#L4325'>buffer</a>           4325 lib-src/etags.c   free (lbs[1].lb.buffer);</span>
<span class='curline'><a href='../S/40.html#L4378'>buffer</a>           4378 lib-src/etags.c 	     (char_pointer) = (line_buffer).buffer,			\</span>
<span class='curline'><a href='../S/40.html#L4442'>buffer</a>           4442 lib-src/etags.c       dbp = lb.buffer;</span>
<span class='curline'><a href='../S/40.html#L4453'>buffer</a>           4453 lib-src/etags.c 	    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L4530'>buffer</a>           4530 lib-src/etags.c 			  lb.buffer, dbp - lb.buffer, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L4558'>buffer</a>           4558 lib-src/etags.c 	  make_tag (name, cp - name, false, lb.buffer,</span>
<span class='curline'><a href='../S/40.html#L4559'>buffer</a>           4559 lib-src/etags.c 		    cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L4581'>buffer</a>           4581 lib-src/etags.c 	      make_tag (name, cp - name, true, lb.buffer,</span>
<span class='curline'><a href='../S/40.html#L4582'>buffer</a>           4582 lib-src/etags.c 			cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L4600'>buffer</a>           4600 lib-src/etags.c 	  make_tag (name, cp - name, false, lb.buffer,</span>
<span class='curline'><a href='../S/40.html#L4601'>buffer</a>           4601 lib-src/etags.c 		    cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L4629'>buffer</a>           4629 lib-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/40.html#L4669'>buffer</a>           4669 lib-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L4807'>buffer</a>           4807 lib-src/etags.c 	    make_tag (lb.buffer, cp - lb.buffer, true,</span>
<span class='curline'><a href='../S/40.html#L4808'>buffer</a>           4808 lib-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L4862'>buffer</a>           4862 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L4874'>buffer</a>           4874 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L4879'>buffer</a>           4879 lib-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L4920'>buffer</a>           4920 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L4947'>buffer</a>           4947 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L4990'>buffer</a>           4990 lib-src/etags.c 			    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L5031'>buffer</a>           5031 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L5073'>buffer</a>           5073 lib-src/etags.c 				  lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/40.html#L5083'>buffer</a>           5083 lib-src/etags.c 			pfnote (wr_name, true, lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/40.html#L5087'>buffer</a>           5087 lib-src/etags.c 				   curfdp-&gt;taggedfname, lineno, lb.buffer);</span>
<span class='curline'><a href='../S/40.html#L5094'>buffer</a>           5094 lib-src/etags.c 				    lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/40.html#L5159'>buffer</a>           5159 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1,</span>
<span class='curline'><a href='../S/40.html#L5193'>buffer</a>           5193 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L5206'>buffer</a>           5206 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L5219'>buffer</a>           5219 lib-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L5234'>buffer</a>           5234 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L5244'>buffer</a>           5244 lib-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L5275'>buffer</a>           5275 lib-src/etags.c 		  lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L5299'>buffer</a>           5299 lib-src/etags.c 	  char * namestart = skip_spaces (lb.buffer);</span>
<span class='curline'><a href='../S/40.html#L5304'>buffer</a>           5304 lib-src/etags.c 		    lb.buffer, bp - lb.buffer + 2, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L5341'>buffer</a>           5341 lib-src/etags.c   dbp = lb.buffer;</span>
<span class='curline'><a href='../S/40.html#L5358'>buffer</a>           5358 lib-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/40.html#L5440'>buffer</a>           5440 lib-src/etags.c 			tline.buffer, taglen, save_lineno, save_lcno);</span>
<span class='curline'><a href='../S/40.html#L5457'>buffer</a>           5457 lib-src/etags.c 	  strcpy (tline.buffer, lb.buffer);</span>
<span class='curline'><a href='../S/40.html#L5460'>buffer</a>           5460 lib-src/etags.c 	  name = tline.buffer + (dbp - lb.buffer);</span>
<span class='curline'><a href='../S/40.html#L5462'>buffer</a>           5462 lib-src/etags.c 	  taglen = cp - lb.buffer + 1;</span>
<span class='curline'><a href='../S/40.html#L5488'>buffer</a>           5488 lib-src/etags.c   free (tline.buffer);</span>
<span class='curline'><a href='../S/40.html#L5631'>buffer</a>           5631 lib-src/etags.c 		    lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L5687'>buffer</a>           5687 lib-src/etags.c 		      true, lb.buffer, name_end - lb.buffer,</span>
<span class='curline'><a href='../S/40.html#L5797'>buffer</a>           5797 lib-src/etags.c 	  for (key = TEX_toktab; key-&gt;buffer != NULL; key++)</span>
<span class='curline'><a href='../S/40.html#L5798'>buffer</a>           5798 lib-src/etags.c 	    if (strneq (cp, key-&gt;buffer, key-&gt;len))</span>
<span class='curline'><a href='../S/40.html#L5821'>buffer</a>           5821 lib-src/etags.c 		    linelen = p - lb.buffer + 1;</span>
<span class='curline'><a href='../S/40.html#L5824'>buffer</a>           5824 lib-src/etags.c 			  lb.buffer, linelen, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L5868'>buffer</a>           5868 lib-src/etags.c 	  TEX_toktab[i].buffer = savenstr (env, p - env);</span>
<span class='curline'><a href='../S/40.html#L5876'>buffer</a>           5876 lib-src/etags.c 	  TEX_toktab[i].buffer = NULL; /* Mark end of table. */</span>
<span class='curline'><a href='../S/40.html#L5896'>buffer</a>           5896 lib-src/etags.c 		  lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L5961'>buffer</a>           5961 lib-src/etags.c 		memcpyz (token_name.buffer, dbp, end - dbp);</span>
<span class='curline'><a href='../S/40.html#L5986'>buffer</a>           5986 lib-src/etags.c 	    make_tag (token_name.buffer, token_name.len, true,</span>
<span class='curline'><a href='../S/40.html#L6074'>buffer</a>           6074 lib-src/etags.c       for (cp = plb-&gt;buffer; *cp != '\0'; cp++)</span>
<span class='curline'><a href='../S/40.html#L6395'>buffer</a>           6395 lib-src/etags.c       for (cp = plb-&gt;buffer; *cp != '\0'; ++cp)</span>
<span class='curline'><a href='../S/40.html#L6933'>buffer</a>           6933 lib-src/etags.c 	  analyze_regex (regexbuf.buffer);</span>
<span class='curline'><a href='../S/40.html#L6934'>buffer</a>           6934 lib-src/etags.c 	free (regexbuf.buffer);</span>
<span class='curline'><a href='../S/40.html#L7153'>buffer</a>           7153 lib-src/etags.c   char *buffer = filebuf.buffer;</span>
<span class='curline'><a href='../S/40.html#L7175'>buffer</a>           7175 lib-src/etags.c 	  match = re_search (rp-&gt;pat, buffer, filebuf.len, charno,</span>
<span class='curline'><a href='../S/40.html#L7206'>buffer</a>           7206 lib-src/etags.c 		if (buffer[charno++] == '\n')</span>
<span class='curline'><a href='../S/40.html#L7212'>buffer</a>           7212 lib-src/etags.c 		name = substitute (buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/40.html#L7215'>buffer</a>           7215 lib-src/etags.c 	      pfnote (name, true, buffer + linecharno,</span>
<span class='curline'><a href='../S/40.html#L7221'>buffer</a>           7221 lib-src/etags.c 			 lineno, buffer + linecharno);</span>
<span class='curline'><a href='../S/40.html#L7255'>buffer</a>           7255 lib-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L7274'>buffer</a>           7274 lib-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L7297'>buffer</a>           7297 lib-src/etags.c   char *buffer = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/40.html#L7298'>buffer</a>           7298 lib-src/etags.c   char *p = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/40.html#L7310'>buffer</a>           7310 lib-src/etags.c 	  xrnew (buffer, lbp-&gt;size, 2);</span>
<span class='curline'><a href='../S/40.html#L7311'>buffer</a>           7311 lib-src/etags.c 	  p = buffer + lbp-&gt;size;</span>
<span class='curline'><a href='../S/40.html#L7313'>buffer</a>           7313 lib-src/etags.c 	  pend = buffer + lbp-&gt;size;</span>
<span class='curline'><a href='../S/40.html#L7314'>buffer</a>           7314 lib-src/etags.c 	  lbp-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/40.html#L7326'>buffer</a>           7326 lib-src/etags.c           if (!leave_cr &amp;&amp; p &gt; buffer &amp;&amp; p[-1] == '\r')</span>
<span class='curline'><a href='../S/40.html#L7340'>buffer</a>           7340 lib-src/etags.c   lbp-&gt;len = p - buffer;</span>
<span class='curline'><a href='../S/40.html#L7348'>buffer</a>           7348 lib-src/etags.c 	  xrnew (filebuf.buffer, filebuf.size, 2);</span>
<span class='curline'><a href='../S/40.html#L7351'>buffer</a>           7351 lib-src/etags.c       strcpy (mempcpy (filebuf.buffer + filebuf.len, lbp-&gt;buffer, lbp-&gt;len),</span>
<span class='curline'><a href='../S/40.html#L7378'>buffer</a>           7378 lib-src/etags.c       if (result &gt; 12 &amp;&amp; strneq (lbp-&gt;buffer, "#line ", 6))</span>
<span class='curline'><a href='../S/40.html#L7383'>buffer</a>           7383 lib-src/etags.c 	  if (sscanf (lbp-&gt;buffer, "#line %"SCNdMAX" \"%n", &amp;lno, &amp;start) &gt;= 1</span>
<span class='curline'><a href='../S/40.html#L7386'>buffer</a>           7386 lib-src/etags.c 	      char *endp = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/40.html#L7399'>buffer</a>           7399 lib-src/etags.c 		  name = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/40.html#L7508'>buffer</a>           7508 lib-src/etags.c 	  match = re_match (rp-&gt;pat, lbp-&gt;buffer, lbp-&gt;len, 0, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/40.html#L7537'>buffer</a>           7537 lib-src/etags.c 		name = substitute (lbp-&gt;buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/40.html#L7540'>buffer</a>           7540 lib-src/etags.c 	      pfnote (name, true, lbp-&gt;buffer, match, lineno, linecharno);</span>
<span class='curline'><a href='../S/40.html#L7545'>buffer</a>           7545 lib-src/etags.c 			 lineno, lbp-&gt;buffer);</span>
<span class='curline'><a href='../S/40.html#L7999'>buffer</a>           7999 lib-src/etags.c   lbp-&gt;buffer = xnew (lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/40.html#L8000'>buffer</a>           8000 lib-src/etags.c   lbp-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/40.html#L8011'>buffer</a>           8011 lib-src/etags.c       xrnew (lbp-&gt;buffer, lbp-&gt;size, multiplier);</span>
<span class='curline'><a href='../S/29.html#L267'>buffer</a>            267 lib-src/pop.c    server-&gt;buffer = (char *) malloc (GETLINE_MIN);</span>
<span class='curline'><a href='../S/29.html#L268'>buffer</a>            268 lib-src/pop.c    if (! server-&gt;buffer)</span>
<span class='curline'><a href='../S/29.html#L950'>buffer</a>            950 lib-src/pop.c    free (server-&gt;buffer);</span>
<span class='curline'><a href='../S/29.html#L1237'>buffer</a>           1237 lib-src/pop.c        char *cp = find_crlf (server-&gt;buffer + server-&gt;buffer_index,</span>
<span class='curline'><a href='../S/29.html#L1245'>buffer</a>           1245 lib-src/pop.c  	  data_used = (cp + 2) - server-&gt;buffer - found;</span>
<span class='curline'><a href='../S/29.html#L1254'>buffer</a>           1254 lib-src/pop.c  	    fprintf (stderr, "&lt;&lt;&lt; %s\n", server-&gt;buffer + found);</span>
<span class='curline'><a href='../S/29.html#L1255'>buffer</a>           1255 lib-src/pop.c  	  *line = server-&gt;buffer + found;</span>
<span class='curline'><a href='../S/29.html#L1260'>buffer</a>           1260 lib-src/pop.c  	  memmove (server-&gt;buffer, server-&gt;buffer + server-&gt;buffer_index,</span>
<span class='curline'><a href='../S/29.html#L1286'>buffer</a>           1286 lib-src/pop.c  	  server-&gt;buffer = (char *)realloc (server-&gt;buffer, server-&gt;buffer_size);</span>
<span class='curline'><a href='../S/29.html#L1287'>buffer</a>           1287 lib-src/pop.c  	  if (! server-&gt;buffer)</span>
<span class='curline'><a href='../S/29.html#L1294'>buffer</a>           1294 lib-src/pop.c        ret = RECV (server-&gt;file, server-&gt;buffer + server-&gt;data,</span>
<span class='curline'><a href='../S/29.html#L1313'>buffer</a>           1313 lib-src/pop.c  	  server-&gt;buffer[server-&gt;data] = '\0';</span>
<span class='curline'><a href='../S/29.html#L1315'>buffer</a>           1315 lib-src/pop.c  	  cp = find_crlf (server-&gt;buffer + search_offset,</span>
<span class='curline'><a href='../S/29.html#L1319'>buffer</a>           1319 lib-src/pop.c  	      int data_used = (cp + 2) - server-&gt;buffer;</span>
<span class='curline'><a href='../S/29.html#L1325'>buffer</a>           1325 lib-src/pop.c  		fprintf (stderr, "&lt;&lt;&lt; %s\n", server-&gt;buffer);</span>
<span class='curline'><a href='../S/29.html#L1326'>buffer</a>           1326 lib-src/pop.c  	      *line = server-&gt;buffer;</span>
<span class='curline'><a href='../S/29.html#L1531'>buffer</a>           1531 lib-src/pop.c        if (server-&gt;buffer)</span>
<span class='curline'><a href='../S/29.html#L1533'>buffer</a>           1533 lib-src/pop.c  	  free (server-&gt;buffer);</span>
<span class='curline'><a href='../S/29.html#L1534'>buffer</a>           1534 lib-src/pop.c  	  server-&gt;buffer = 0;</span>
<span class='curline'><a href='../S/41.html#L35'>buffer</a>             35 lib-src/pop.h    char *buffer;</span>
<span class='curline'><a href='../S/2280.html#L61'>buffer</a>             61 lib/af_alg.h   afalg_buffer (const char *buffer, size_t len, const char *alg,</span>
<span class='curline'><a href='../S/2280.html#L96'>buffer</a>             96 lib/af_alg.h   afalg_buffer (const char *buffer, size_t len, const char *alg,</span>
<span class='curline'><a href='../S/2198.html#L64'>buffer</a>             64 lib/careadlinkat.c               char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2198.html#L72'>buffer</a>             72 lib/careadlinkat.c   if (!buffer)</span>
<span class='curline'><a href='../S/2198.html#L74'>buffer</a>             74 lib/careadlinkat.c       buffer = stack_buf;</span>
<span class='curline'><a href='../S/2198.html#L78'>buffer</a>             78 lib/careadlinkat.c   char *buf = buffer;</span>
<span class='curline'><a href='../S/2198.html#L88'>buffer</a>             88 lib/careadlinkat.c           if (buf != buffer)</span>
<span class='curline'><a href='../S/2198.html#L112'>buffer</a>            112 lib/careadlinkat.c           if (link_size &lt; buf_size &amp;&amp; buf != buffer &amp;&amp; alloc-&gt;reallocate)</span>
<span class='curline'><a href='../S/2198.html#L123'>buffer</a>            123 lib/careadlinkat.c       if (buf != buffer)</span>
<span class='curline'><a href='../S/2198.html#L167'>buffer</a>            167 lib/careadlinkat.c               char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2198.html#L180'>buffer</a>            180 lib/careadlinkat.c   return readlink_stk (fd, filename, buffer, buffer_size, alloc,</span>
<span class='curline'><a href='../S/2273.html#L55'>buffer</a>             55 lib/careadlinkat.h                     char *restrict buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/2173.html#L34'>buffer</a>             34 lib/execinfo.in.h backtrace (void **buffer, int size)</span>
<span class='curline'><a href='../S/2173.html#L36'>buffer</a>             36 lib/execinfo.in.h   (void) buffer;</span>
<span class='curline'><a href='../S/2173.html#L42'>buffer</a>             42 lib/execinfo.in.h backtrace_symbols (void *const *buffer, int size)</span>
<span class='curline'><a href='../S/2173.html#L44'>buffer</a>             44 lib/execinfo.in.h   (void) buffer;</span>
<span class='curline'><a href='../S/2173.html#L50'>buffer</a>             50 lib/execinfo.in.h backtrace_symbols_fd (void *const *buffer, int size, int fd)</span>
<span class='curline'><a href='../S/2173.html#L52'>buffer</a>             52 lib/execinfo.in.h   (void) buffer;</span>
<span class='curline'><a href='../S/2290.html#L112'>buffer</a>            112 lib/getrandom.c getrandom (void *buffer, size_t length, unsigned int flags)</span>
<span class='curline'><a href='../S/2290.html#L128'>buffer</a>            128 lib/getrandom.c           &amp;&amp; BCryptGenRandomFunc (NULL, buffer, length,</span>
<span class='curline'><a href='../S/2290.html#L153'>buffer</a>            153 lib/getrandom.c         if (!CryptGenRandom (provider, length, buffer))</span>
<span class='curline'><a href='../S/2290.html#L165'>buffer</a>            165 lib/getrandom.c   return getrandom (buffer, length, flags);</span>
<span class='curline'><a href='../S/2290.html#L188'>buffer</a>            188 lib/getrandom.c   return read (fd, buffer, length);</span>
<span class='curline'><a href='../S/2374.html#L75'>buffer</a>             75 lib/malloc/scratch_buffer.h scratch_buffer_init (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2374.html#L77'>buffer</a>             77 lib/malloc/scratch_buffer.h   buffer-&gt;data = buffer-&gt;__space.__c;</span>
<span class='curline'><a href='../S/2374.html#L78'>buffer</a>             78 lib/malloc/scratch_buffer.h   buffer-&gt;length = sizeof (buffer-&gt;__space);</span>
<span class='curline'><a href='../S/2374.html#L83'>buffer</a>             83 lib/malloc/scratch_buffer.h scratch_buffer_free (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2374.html#L85'>buffer</a>             85 lib/malloc/scratch_buffer.h   if (buffer-&gt;data != buffer-&gt;__space.__c)</span>
<span class='curline'><a href='../S/2374.html#L86'>buffer</a>             86 lib/malloc/scratch_buffer.h     free (buffer-&gt;data);</span>
<span class='curline'><a href='../S/2374.html#L94'>buffer</a>             94 lib/malloc/scratch_buffer.h bool __libc_scratch_buffer_grow (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2374.html#L99'>buffer</a>             99 lib/malloc/scratch_buffer.h scratch_buffer_grow (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2374.html#L101'>buffer</a>            101 lib/malloc/scratch_buffer.h   return __glibc_likely (__libc_scratch_buffer_grow (buffer));</span>
<span class='curline'><a href='../S/2374.html#L106'>buffer</a>            106 lib/malloc/scratch_buffer.h bool __libc_scratch_buffer_grow_preserve (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2374.html#L111'>buffer</a>            111 lib/malloc/scratch_buffer.h scratch_buffer_grow_preserve (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2374.html#L113'>buffer</a>            113 lib/malloc/scratch_buffer.h   return __glibc_likely (__libc_scratch_buffer_grow_preserve (buffer));</span>
<span class='curline'><a href='../S/2374.html#L122'>buffer</a>            122 lib/malloc/scratch_buffer.h bool __libc_scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2374.html#L128'>buffer</a>            128 lib/malloc/scratch_buffer.h scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2374.html#L132'>buffer</a>            132 lib/malloc/scratch_buffer.h 			 (buffer, nelem, size));</span>
<span class='curline'><a href='../S/2375.html#L27'>buffer</a>             27 lib/malloc/scratch_buffer_dupfree.c __libc_scratch_buffer_dupfree (struct scratch_buffer *buffer, size_t size)</span>
<span class='curline'><a href='../S/2375.html#L29'>buffer</a>             29 lib/malloc/scratch_buffer_dupfree.c   void *data = buffer-&gt;data;</span>
<span class='curline'><a href='../S/2375.html#L30'>buffer</a>             30 lib/malloc/scratch_buffer_dupfree.c   if (data == buffer-&gt;__space.__c)</span>
<span class='curline'><a href='../S/2371.html#L27'>buffer</a>             27 lib/malloc/scratch_buffer_grow.c __libc_scratch_buffer_grow (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2371.html#L30'>buffer</a>             30 lib/malloc/scratch_buffer_grow.c   size_t new_length = buffer-&gt;length * 2;</span>
<span class='curline'><a href='../S/2371.html#L33'>buffer</a>             33 lib/malloc/scratch_buffer_grow.c   scratch_buffer_free (buffer);</span>
<span class='curline'><a href='../S/2371.html#L36'>buffer</a>             36 lib/malloc/scratch_buffer_grow.c   if (__glibc_likely (new_length &gt;= buffer-&gt;length))</span>
<span class='curline'><a href='../S/2371.html#L47'>buffer</a>             47 lib/malloc/scratch_buffer_grow.c       scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2371.html#L52'>buffer</a>             52 lib/malloc/scratch_buffer_grow.c   buffer-&gt;data = new_ptr;</span>
<span class='curline'><a href='../S/2371.html#L53'>buffer</a>             53 lib/malloc/scratch_buffer_grow.c   buffer-&gt;length = new_length;</span>
<span class='curline'><a href='../S/2370.html#L28'>buffer</a>             28 lib/malloc/scratch_buffer_grow_preserve.c __libc_scratch_buffer_grow_preserve (struct scratch_buffer *buffer)</span>
<span class='curline'><a href='../S/2370.html#L30'>buffer</a>             30 lib/malloc/scratch_buffer_grow_preserve.c   size_t new_length = 2 * buffer-&gt;length;</span>
<span class='curline'><a href='../S/2370.html#L33'>buffer</a>             33 lib/malloc/scratch_buffer_grow_preserve.c   if (buffer-&gt;data == buffer-&gt;__space.__c)</span>
<span class='curline'><a href='../S/2370.html#L40'>buffer</a>             40 lib/malloc/scratch_buffer_grow_preserve.c       memcpy (new_ptr, buffer-&gt;__space.__c, buffer-&gt;length);</span>
<span class='curline'><a href='../S/2370.html#L45'>buffer</a>             45 lib/malloc/scratch_buffer_grow_preserve.c       if (__glibc_likely (new_length &gt;= buffer-&gt;length))</span>
<span class='curline'><a href='../S/2370.html#L46'>buffer</a>             46 lib/malloc/scratch_buffer_grow_preserve.c 	new_ptr = realloc (buffer-&gt;data, new_length);</span>
<span class='curline'><a href='../S/2370.html#L56'>buffer</a>             56 lib/malloc/scratch_buffer_grow_preserve.c 	  free (buffer-&gt;data);</span>
<span class='curline'><a href='../S/2370.html#L57'>buffer</a>             57 lib/malloc/scratch_buffer_grow_preserve.c 	  scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2370.html#L63'>buffer</a>             63 lib/malloc/scratch_buffer_grow_preserve.c   buffer-&gt;data = new_ptr;</span>
<span class='curline'><a href='../S/2370.html#L64'>buffer</a>             64 lib/malloc/scratch_buffer_grow_preserve.c   buffer-&gt;length = new_length;</span>
<span class='curline'><a href='../S/2372.html#L28'>buffer</a>             28 lib/malloc/scratch_buffer_set_array_size.c __libc_scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2372.html#L39'>buffer</a>             39 lib/malloc/scratch_buffer_set_array_size.c       scratch_buffer_free (buffer);</span>
<span class='curline'><a href='../S/2372.html#L40'>buffer</a>             40 lib/malloc/scratch_buffer_set_array_size.c       scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2372.html#L45'>buffer</a>             45 lib/malloc/scratch_buffer_set_array_size.c   if (new_length &lt;= buffer-&gt;length)</span>
<span class='curline'><a href='../S/2372.html#L49'>buffer</a>             49 lib/malloc/scratch_buffer_set_array_size.c   scratch_buffer_free (buffer);</span>
<span class='curline'><a href='../S/2372.html#L55'>buffer</a>             55 lib/malloc/scratch_buffer_set_array_size.c       scratch_buffer_init (buffer);</span>
<span class='curline'><a href='../S/2372.html#L60'>buffer</a>             60 lib/malloc/scratch_buffer_set_array_size.c   buffer-&gt;data = new_ptr;</span>
<span class='curline'><a href='../S/2372.html#L61'>buffer</a>             61 lib/malloc/scratch_buffer_set_array_size.c   buffer-&gt;length = new_length;</span>
<span class='curline'><a href='../S/2360.html#L69'>buffer</a>             69 lib/md5-stream.c   char *buffer = malloc (BLOCKSIZE + 72);</span>
<span class='curline'><a href='../S/2360.html#L70'>buffer</a>             70 lib/md5-stream.c   if (!buffer)</span>
<span class='curline'><a href='../S/2360.html#L97'>buffer</a>             97 lib/md5-stream.c           n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);</span>
<span class='curline'><a href='../S/2360.html#L111'>buffer</a>            111 lib/md5-stream.c                   free (buffer);</span>
<span class='curline'><a href='../S/2360.html#L121'>buffer</a>            121 lib/md5-stream.c       md5_process_block (buffer, BLOCKSIZE, &amp;ctx);</span>
<span class='curline'><a href='../S/2360.html#L128'>buffer</a>            128 lib/md5-stream.c     md5_process_bytes (buffer, sum, &amp;ctx);</span>
<span class='curline'><a href='../S/2360.html#L132'>buffer</a>            132 lib/md5-stream.c   free (buffer);</span>
<span class='curline'><a href='../S/2182.html#L115'>buffer</a>            115 lib/md5.c        ctx-&gt;buffer[size - 2] = SWAP (ctx-&gt;total[0] &lt;&lt; 3);</span>
<span class='curline'><a href='../S/2182.html#L116'>buffer</a>            116 lib/md5.c        ctx-&gt;buffer[size - 1] = SWAP ((ctx-&gt;total[1] &lt;&lt; 3) | (ctx-&gt;total[0] &gt;&gt; 29));</span>
<span class='curline'><a href='../S/2182.html#L118'>buffer</a>            118 lib/md5.c        memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);</span>
<span class='curline'><a href='../S/2182.html#L121'>buffer</a>            121 lib/md5.c        md5_process_block (ctx-&gt;buffer, size * 4, ctx);</span>
<span class='curline'><a href='../S/2182.html#L131'>buffer</a>            131 lib/md5.c      md5_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2182.html#L139'>buffer</a>            139 lib/md5.c        md5_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2182.html#L147'>buffer</a>            147 lib/md5.c      md5_process_bytes (const void *buffer, size_t len, struct md5_ctx *ctx)</span>
<span class='curline'><a href='../S/2182.html#L156'>buffer</a>            156 lib/md5.c            memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2182.html#L161'>buffer</a>            161 lib/md5.c                md5_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2182.html#L166'>buffer</a>            166 lib/md5.c                memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2182.html#L167'>buffer</a>            167 lib/md5.c                        &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~63],</span>
<span class='curline'><a href='../S/2182.html#L171'>buffer</a>            171 lib/md5.c            buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2182.html#L180'>buffer</a>            180 lib/md5.c            if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2182.html#L183'>buffer</a>            183 lib/md5.c                  md5_process_block (memcpy (ctx-&gt;buffer, buffer, 64), 64, ctx);</span>
<span class='curline'><a href='../S/2182.html#L184'>buffer</a>            184 lib/md5.c                  buffer = (const char *) buffer + 64;</span>
<span class='curline'><a href='../S/2182.html#L190'>buffer</a>            190 lib/md5.c                md5_process_block (buffer, len &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2182.html#L191'>buffer</a>            191 lib/md5.c                buffer = (const char *) buffer + (len &amp; ~63);</span>
<span class='curline'><a href='../S/2182.html#L201'>buffer</a>            201 lib/md5.c            memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2182.html#L205'>buffer</a>            205 lib/md5.c                md5_process_block (ctx-&gt;buffer, 64, ctx);</span>
<span class='curline'><a href='../S/2182.html#L209'>buffer</a>            209 lib/md5.c                memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2182.html#L229'>buffer</a>            229 lib/md5.c      md5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)</span>
<span class='curline'><a href='../S/2182.html#L232'>buffer</a>            232 lib/md5.c        const uint32_t *words = buffer;</span>
<span class='curline'><a href='../S/2297.html#L86'>buffer</a>             86 lib/md5.h        uint32_t buffer[32]; /* 128 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2297.html#L102'>buffer</a>            102 lib/md5.h      extern void __md5_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2297.html#L109'>buffer</a>            109 lib/md5.h      extern void __md5_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2297.html#L131'>buffer</a>            131 lib/md5.h      extern void *__md5_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2193.html#L253'>buffer</a>            253 lib/regcomp.c    re_dfa_t *dfa = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2193.html#L284'>buffer</a>            284 lib/regcomp.c    re_dfa_t *dfa = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2193.html#L445'>buffer</a>            445 lib/regcomp.c    preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2193.html#L609'>buffer</a>            609 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2193.html#L615'>buffer</a>            615 lib/regcomp.c    preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2193.html#L649'>buffer</a>            649 lib/regcomp.c        if (!re_comp_buf.buffer)</span>
<span class='curline'><a href='../S/2193.html#L654'>buffer</a>            654 lib/regcomp.c    if (re_comp_buf.buffer)</span>
<span class='curline'><a href='../S/2193.html#L717'>buffer</a>            717 lib/regcomp.c    dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2193.html#L724'>buffer</a>            724 lib/regcomp.c        dfa = re_realloc (preg-&gt;buffer, re_dfa_t, 1);</span>
<span class='curline'><a href='../S/2193.html#L728'>buffer</a>            728 lib/regcomp.c        preg-&gt;buffer = dfa;</span>
<span class='curline'><a href='../S/2193.html#L738'>buffer</a>            738 lib/regcomp.c        preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2193.html#L757'>buffer</a>            757 lib/regcomp.c        preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2193.html#L788'>buffer</a>            788 lib/regcomp.c        preg-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/2193.html#L944'>buffer</a>            944 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2193.html#L1127'>buffer</a>           1127 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2193.html#L1308'>buffer</a>           1308 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2193.html#L2084'>buffer</a>           2084 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2193.html#L2118'>buffer</a>           2118 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2193.html#L2168'>buffer</a>           2168 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2193.html#L2212'>buffer</a>           2212 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2193.html#L2444'>buffer</a>           2444 lib/regcomp.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2210.html#L417'>buffer</a>            417 lib/regex.h      struct re_dfa_t *__REPB_PREFIX(buffer);</span>
<span class='curline'><a href='../S/2345.html#L192'>buffer</a>            192 lib/regexec.c    re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2345.html#L372'>buffer</a>            372 lib/regexec.c    re_dfa_t *dfa = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/2345.html#L585'>buffer</a>            585 lib/regexec.c    const re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2345.html#L1368'>buffer</a>           1368 lib/regexec.c    const re_dfa_t *dfa = preg-&gt;buffer;</span>
<span class='curline'><a href='../S/2356.html#L67'>buffer</a>             67 lib/scratch_buffer.h extern void scratch_buffer_init (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2356.html#L72'>buffer</a>             72 lib/scratch_buffer.h extern void scratch_buffer_free (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2356.html#L81'>buffer</a>             81 lib/scratch_buffer.h extern bool scratch_buffer_grow (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2356.html#L87'>buffer</a>             87 lib/scratch_buffer.h extern bool scratch_buffer_grow_preserve (struct scratch_buffer *buffer);</span>
<span class='curline'><a href='../S/2356.html#L97'>buffer</a>             97 lib/scratch_buffer.h extern bool scratch_buffer_set_array_size (struct scratch_buffer *buffer,</span>
<span class='curline'><a href='../S/2309.html#L104'>buffer</a>            104 lib/sha1.c       ctx-&gt;buffer[size - 2] = SWAP ((ctx-&gt;total[1] &lt;&lt; 3) | (ctx-&gt;total[0] &gt;&gt; 29));</span>
<span class='curline'><a href='../S/2309.html#L105'>buffer</a>            105 lib/sha1.c       ctx-&gt;buffer[size - 1] = SWAP (ctx-&gt;total[0] &lt;&lt; 3);</span>
<span class='curline'><a href='../S/2309.html#L107'>buffer</a>            107 lib/sha1.c       memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);</span>
<span class='curline'><a href='../S/2309.html#L110'>buffer</a>            110 lib/sha1.c       sha1_process_block (ctx-&gt;buffer, size * 4, ctx);</span>
<span class='curline'><a href='../S/2309.html#L120'>buffer</a>            120 lib/sha1.c     sha1_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2309.html#L128'>buffer</a>            128 lib/sha1.c       sha1_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2309.html#L135'>buffer</a>            135 lib/sha1.c     sha1_process_bytes (const void *buffer, size_t len, struct sha1_ctx *ctx)</span>
<span class='curline'><a href='../S/2309.html#L144'>buffer</a>            144 lib/sha1.c           memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2309.html#L149'>buffer</a>            149 lib/sha1.c               sha1_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2309.html#L154'>buffer</a>            154 lib/sha1.c               memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2309.html#L155'>buffer</a>            155 lib/sha1.c                       &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~63],</span>
<span class='curline'><a href='../S/2309.html#L159'>buffer</a>            159 lib/sha1.c           buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2309.html#L168'>buffer</a>            168 lib/sha1.c           if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2309.html#L171'>buffer</a>            171 lib/sha1.c                 sha1_process_block (memcpy (ctx-&gt;buffer, buffer, 64), 64, ctx);</span>
<span class='curline'><a href='../S/2309.html#L172'>buffer</a>            172 lib/sha1.c                 buffer = (const char *) buffer + 64;</span>
<span class='curline'><a href='../S/2309.html#L178'>buffer</a>            178 lib/sha1.c               sha1_process_block (buffer, len &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2309.html#L179'>buffer</a>            179 lib/sha1.c               buffer = (const char *) buffer + (len &amp; ~63);</span>
<span class='curline'><a href='../S/2309.html#L189'>buffer</a>            189 lib/sha1.c           memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2309.html#L193'>buffer</a>            193 lib/sha1.c               sha1_process_block (ctx-&gt;buffer, 64, ctx);</span>
<span class='curline'><a href='../S/2309.html#L197'>buffer</a>            197 lib/sha1.c               memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2309.html#L222'>buffer</a>            222 lib/sha1.c     sha1_process_block (const void *buffer, size_t len, struct sha1_ctx *ctx)</span>
<span class='curline'><a href='../S/2309.html#L224'>buffer</a>            224 lib/sha1.c       const uint32_t *words = buffer;</span>
<span class='curline'><a href='../S/2341.html#L58'>buffer</a>             58 lib/sha1.h       uint32_t buffer[32]; /* 128 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2341.html#L68'>buffer</a>             68 lib/sha1.h     extern void sha1_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2341.html#L75'>buffer</a>             75 lib/sha1.h     extern void sha1_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2341.html#L95'>buffer</a>             95 lib/sha1.h     extern void *sha1_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2189.html#L137'>buffer</a>            137 lib/sha256.c     set_uint32 ((char *) &amp;ctx-&gt;buffer[size - 2],</span>
<span class='curline'><a href='../S/2189.html#L139'>buffer</a>            139 lib/sha256.c     set_uint32 ((char *) &amp;ctx-&gt;buffer[size - 1],</span>
<span class='curline'><a href='../S/2189.html#L142'>buffer</a>            142 lib/sha256.c     memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);</span>
<span class='curline'><a href='../S/2189.html#L145'>buffer</a>            145 lib/sha256.c     sha256_process_block (ctx-&gt;buffer, size * 4, ctx);</span>
<span class='curline'><a href='../S/2189.html#L167'>buffer</a>            167 lib/sha256.c   sha256_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2189.html#L175'>buffer</a>            175 lib/sha256.c     sha256_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2189.html#L182'>buffer</a>            182 lib/sha256.c   sha224_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2189.html#L190'>buffer</a>            190 lib/sha256.c     sha256_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2189.html#L197'>buffer</a>            197 lib/sha256.c   sha256_process_bytes (const void *buffer, size_t len, struct sha256_ctx *ctx)</span>
<span class='curline'><a href='../S/2189.html#L206'>buffer</a>            206 lib/sha256.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2189.html#L211'>buffer</a>            211 lib/sha256.c             sha256_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2189.html#L216'>buffer</a>            216 lib/sha256.c             memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2189.html#L217'>buffer</a>            217 lib/sha256.c                     &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~63],</span>
<span class='curline'><a href='../S/2189.html#L221'>buffer</a>            221 lib/sha256.c         buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2189.html#L230'>buffer</a>            230 lib/sha256.c         if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2189.html#L233'>buffer</a>            233 lib/sha256.c               sha256_process_block (memcpy (ctx-&gt;buffer, buffer, 64), 64, ctx);</span>
<span class='curline'><a href='../S/2189.html#L234'>buffer</a>            234 lib/sha256.c               buffer = (const char *) buffer + 64;</span>
<span class='curline'><a href='../S/2189.html#L240'>buffer</a>            240 lib/sha256.c             sha256_process_block (buffer, len &amp; ~63, ctx);</span>
<span class='curline'><a href='../S/2189.html#L241'>buffer</a>            241 lib/sha256.c             buffer = (const char *) buffer + (len &amp; ~63);</span>
<span class='curline'><a href='../S/2189.html#L251'>buffer</a>            251 lib/sha256.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2189.html#L255'>buffer</a>            255 lib/sha256.c             sha256_process_block (ctx-&gt;buffer, 64, ctx);</span>
<span class='curline'><a href='../S/2189.html#L259'>buffer</a>            259 lib/sha256.c             memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2189.html#L297'>buffer</a>            297 lib/sha256.c   sha256_process_block (const void *buffer, size_t len, struct sha256_ctx *ctx)</span>
<span class='curline'><a href='../S/2189.html#L299'>buffer</a>            299 lib/sha256.c     const uint32_t *words = buffer;</span>
<span class='curline'><a href='../S/2311.html#L56'>buffer</a>             56 lib/sha256.h     uint32_t buffer[32]; /* 128 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2311.html#L67'>buffer</a>             67 lib/sha256.h   extern void sha256_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2311.html#L74'>buffer</a>             74 lib/sha256.h   extern void sha256_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2311.html#L98'>buffer</a>             98 lib/sha256.h   extern void *sha256_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2311.html#L100'>buffer</a>            100 lib/sha256.h   extern void *sha224_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2349.html#L137'>buffer</a>            137 lib/sha512.c     set_uint64 ((char *) &amp;ctx-&gt;buffer[size - 2],</span>
<span class='curline'><a href='../S/2349.html#L140'>buffer</a>            140 lib/sha512.c     set_uint64 ((char *) &amp;ctx-&gt;buffer[size - 1],</span>
<span class='curline'><a href='../S/2349.html#L143'>buffer</a>            143 lib/sha512.c     memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 8 - bytes);</span>
<span class='curline'><a href='../S/2349.html#L146'>buffer</a>            146 lib/sha512.c     sha512_process_block (ctx-&gt;buffer, size * 8, ctx);</span>
<span class='curline'><a href='../S/2349.html#L168'>buffer</a>            168 lib/sha512.c   sha512_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2349.html#L176'>buffer</a>            176 lib/sha512.c     sha512_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2349.html#L183'>buffer</a>            183 lib/sha512.c   sha384_buffer (const char *buffer, size_t len, void *resblock)</span>
<span class='curline'><a href='../S/2349.html#L191'>buffer</a>            191 lib/sha512.c     sha512_process_bytes (buffer, len, &amp;ctx);</span>
<span class='curline'><a href='../S/2349.html#L198'>buffer</a>            198 lib/sha512.c   sha512_process_bytes (const void *buffer, size_t len, struct sha512_ctx *ctx)</span>
<span class='curline'><a href='../S/2349.html#L207'>buffer</a>            207 lib/sha512.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</span>
<span class='curline'><a href='../S/2349.html#L212'>buffer</a>            212 lib/sha512.c             sha512_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~127, ctx);</span>
<span class='curline'><a href='../S/2349.html#L217'>buffer</a>            217 lib/sha512.c             memcpy (ctx-&gt;buffer,</span>
<span class='curline'><a href='../S/2349.html#L218'>buffer</a>            218 lib/sha512.c                     &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~127],</span>
<span class='curline'><a href='../S/2349.html#L222'>buffer</a>            222 lib/sha512.c         buffer = (const char *) buffer + add;</span>
<span class='curline'><a href='../S/2349.html#L231'>buffer</a>            231 lib/sha512.c         if (UNALIGNED_P (buffer))</span>
<span class='curline'><a href='../S/2349.html#L234'>buffer</a>            234 lib/sha512.c               sha512_process_block (memcpy (ctx-&gt;buffer, buffer, 128), 128, ctx);</span>
<span class='curline'><a href='../S/2349.html#L235'>buffer</a>            235 lib/sha512.c               buffer = (const char *) buffer + 128;</span>
<span class='curline'><a href='../S/2349.html#L241'>buffer</a>            241 lib/sha512.c             sha512_process_block (buffer, len &amp; ~127, ctx);</span>
<span class='curline'><a href='../S/2349.html#L242'>buffer</a>            242 lib/sha512.c             buffer = (const char *) buffer + (len &amp; ~127);</span>
<span class='curline'><a href='../S/2349.html#L252'>buffer</a>            252 lib/sha512.c         memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</span>
<span class='curline'><a href='../S/2349.html#L256'>buffer</a>            256 lib/sha512.c             sha512_process_block (ctx-&gt;buffer, 128, ctx);</span>
<span class='curline'><a href='../S/2349.html#L260'>buffer</a>            260 lib/sha512.c             memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</span>
<span class='curline'><a href='../S/2349.html#L322'>buffer</a>            322 lib/sha512.c   sha512_process_block (const void *buffer, size_t len, struct sha512_ctx *ctx)</span>
<span class='curline'><a href='../S/2349.html#L324'>buffer</a>            324 lib/sha512.c     u64 const *words = buffer;</span>
<span class='curline'><a href='../S/2322.html#L56'>buffer</a>             56 lib/sha512.h     u64 buffer[32]; /* 256 bytes; the first buflen bytes are in use */</span>
<span class='curline'><a href='../S/2322.html#L67'>buffer</a>             67 lib/sha512.h   extern void sha512_process_block (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2322.html#L74'>buffer</a>             74 lib/sha512.h   extern void sha512_process_bytes (const void *buffer, size_t len,</span>
<span class='curline'><a href='../S/2322.html#L101'>buffer</a>            101 lib/sha512.h   extern void *sha512_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2322.html#L103'>buffer</a>            103 lib/sha512.h   extern void *sha384_buffer (const char *buffer, size_t len,</span>
<span class='curline'><a href='../S/2287.html#L79'>buffer</a>             79 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags)</span>
<span class='curline'><a href='../S/2287.html#L82'>buffer</a>             82 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags));</span>
<span class='curline'><a href='../S/2287.html#L86'>buffer</a>             86 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags)</span>
<span class='curline'><a href='../S/2287.html#L90'>buffer</a>             90 lib/sys_random.in.h                   (void *buffer, size_t length, unsigned int flags));</span>
<span class='curline'><a href='../S/2300.html#L1236'>buffer</a>           1236 lib/unistd.in.h _GL_FUNCDECL_RPL (getentropy, int, (void *buffer, size_t length));</span>
<span class='curline'><a href='../S/2300.html#L1237'>buffer</a>           1237 lib/unistd.in.h _GL_CXXALIAS_RPL (getentropy, int, (void *buffer, size_t length));</span>
<span class='curline'><a href='../S/2300.html#L1240'>buffer</a>           1240 lib/unistd.in.h _GL_FUNCDECL_SYS (getentropy, int, (void *buffer, size_t length));</span>
<span class='curline'><a href='../S/2300.html#L1242'>buffer</a>           1242 lib/unistd.in.h _GL_CXXALIAS_SYS (getentropy, int, (void *buffer, size_t length));</span>
<span class='curline'><a href='../S/4098.html#L43'>buffer</a>             43 nt/cmdproxy.c  extern int _snprintf (char *buffer, size_t count, const char *format, ...);</span>
<span class='curline'><a href='../S/4098.html#L284'>buffer</a>            284 nt/cmdproxy.c  search_dir (const char *dir, const char *exec, int bufsize, char *buffer)</span>
<span class='curline'><a href='../S/4098.html#L307'>buffer</a>            307 nt/cmdproxy.c        rc = SearchPath (dir, exec_ext, NULL, bufsize, buffer, &amp;dummy);</span>
<span class='curline'><a href='../S/4098.html#L315'>buffer</a>            315 nt/cmdproxy.c  	  rc = SearchPath (dir, exec_ext, NULL, bufsize, buffer, &amp;dummy);</span>
<span class='curline'><a href='../S/4098.html#L324'>buffer</a>            324 nt/cmdproxy.c  	  rc = SearchPath (dir, exec, exts[i], bufsize, buffer, &amp;dummy);</span>
<span class='curline'><a href='../S/111.html#L478'>buffer</a>            478 src/alloc.c    static void mark_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/111.html#L3372'>buffer</a>           3372 src/alloc.c          eassert (! PSEUDOVEC_STRUCT (vector, Lisp_Marker)-&gt;buffer);</span>
<span class='curline'><a href='../S/111.html#L3628'>buffer</a>           3628 src/alloc.c    struct buffer *</span>
<span class='curline'><a href='../S/111.html#L3631'>buffer</a>           3631 src/alloc.c      struct buffer *b</span>
<span class='curline'><a href='../S/111.html#L3632'>buffer</a>           3632 src/alloc.c        = ALLOCATE_PSEUDOVECTOR (struct buffer, cursor_in_non_selected_windows_,</span>
<span class='curline'><a href='../S/111.html#L3953'>buffer</a>           3953 src/alloc.c      p-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/111.html#L3964'>buffer</a>           3964 src/alloc.c      p-&gt;buffer = 0;</span>
<span class='curline'><a href='../S/111.html#L3977'>buffer</a>           3977 src/alloc.c    build_marker (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t bytepos)</span>
<span class='curline'><a href='../S/111.html#L3987'>buffer</a>           3987 src/alloc.c      m-&gt;buffer = buf;</span>
<span class='curline'><a href='../S/111.html#L6250'>buffer</a>           6250 src/alloc.c                       struct buffer *buffer,</span>
<span class='curline'><a href='../S/111.html#L6255'>buffer</a>           6255 src/alloc.c      eassert (buffer-&gt;base_buffer == NULL);</span>
<span class='curline'><a href='../S/111.html#L6256'>buffer</a>           6256 src/alloc.c      eassert (buffer-&gt;overlays == NULL);</span>
<span class='curline'><a href='../S/111.html#L6259'>buffer</a>           6259 src/alloc.c      visit_vectorlike_root (visitor, (struct Lisp_Vector *) buffer, type);</span>
<span class='curline'><a href='../S/111.html#L6413'>buffer</a>           6413 src/alloc.c      Lisp_Object tail, buffer;</span>
<span class='curline'><a href='../S/111.html#L6431'>buffer</a>           6431 src/alloc.c      FOR_EACH_LIVE_BUFFER (tail, buffer)</span>
<span class='curline'><a href='../S/111.html#L6432'>buffer</a>           6432 src/alloc.c        compact_buffer (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/111.html#L6541'>buffer</a>           6541 src/alloc.c      FOR_EACH_LIVE_BUFFER (tail, buffer)</span>
<span class='curline'><a href='../S/111.html#L6543'>buffer</a>           6543 src/alloc.c          struct buffer *nextb = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/111.html#L6683'>buffer</a>           6683 src/alloc.c        list3 (Qbuffers, make_fixnum (sizeof (struct buffer)),</span>
<span class='curline'><a href='../S/111.html#L6844'>buffer</a>           6844 src/alloc.c    mark_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/111.html#L6847'>buffer</a>           6847 src/alloc.c      mark_vectorlike (&amp;buffer-&gt;header);</span>
<span class='curline'><a href='../S/111.html#L6851'>buffer</a>           6851 src/alloc.c      mark_interval_tree (buffer_intervals (buffer));</span>
<span class='curline'><a href='../S/111.html#L6859'>buffer</a>           6859 src/alloc.c      if (!BUFFER_LIVE_P (buffer))</span>
<span class='curline'><a href='../S/111.html#L6860'>buffer</a>           6860 src/alloc.c          mark_object (BVAR (buffer, undo_list));</span>
<span class='curline'><a href='../S/111.html#L6862'>buffer</a>           6862 src/alloc.c      if (!itree_empty_p (buffer-&gt;overlays))</span>
<span class='curline'><a href='../S/111.html#L6863'>buffer</a>           6863 src/alloc.c        mark_overlays (buffer-&gt;overlays-&gt;root);</span>
<span class='curline'><a href='../S/111.html#L6866'>buffer</a>           6866 src/alloc.c      if (buffer-&gt;base_buffer &amp;&amp;</span>
<span class='curline'><a href='../S/111.html#L6867'>buffer</a>           6867 src/alloc.c          !vectorlike_marked_p (&amp;buffer-&gt;base_buffer-&gt;header))</span>
<span class='curline'><a href='../S/111.html#L6868'>buffer</a>           6868 src/alloc.c        mark_buffer (buffer-&gt;base_buffer);</span>
<span class='curline'><a href='../S/111.html#L7198'>buffer</a>           7198 src/alloc.c    		mark_buffer ((struct buffer *) ptr);</span>
<span class='curline'><a href='../S/111.html#L7719'>buffer</a>           7719 src/alloc.c    unchain_dead_markers (struct buffer *buffer)</span>
<span class='curline'><a href='../S/111.html#L7721'>buffer</a>           7721 src/alloc.c      struct Lisp_Marker *this, **prev = &amp;BUF_MARKERS (buffer);</span>
<span class='curline'><a href='../S/111.html#L7728'>buffer</a>           7728 src/alloc.c            this-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/111.html#L7742'>buffer</a>           7742 src/alloc.c          struct buffer *buffer = XBUFFER (buf);</span>
<span class='curline'><a href='../S/111.html#L7744'>buffer</a>           7744 src/alloc.c          buffer-&gt;text-&gt;intervals = balance_intervals (buffer-&gt;text-&gt;intervals);</span>
<span class='curline'><a href='../S/111.html#L7745'>buffer</a>           7745 src/alloc.c          unchain_dead_markers (buffer);</span>
<span class='curline'><a href='../S/293.html#L302'>buffer</a>            302 src/android-asset.h android_asset_read_internal (AAsset *asset, int nbytes, char *buffer)</span>
<span class='curline'><a href='../S/293.html#L352'>buffer</a>            352 src/android-asset.h       (*env)-&gt;GetByteArrayRegion (env, stash, 0, bytes_read, buffer);</span>
<span class='curline'><a href='../S/293.html#L354'>buffer</a>            354 src/android-asset.h       buffer += bytes_read;</span>
<span class='curline'><a href='../S/293.html#L387'>buffer</a>            387 src/android-asset.h   char *buffer;</span>
<span class='curline'><a href='../S/293.html#L394'>buffer</a>            394 src/android-asset.h   buffer = malloc (length);</span>
<span class='curline'><a href='../S/293.html#L396'>buffer</a>            396 src/android-asset.h   if (!buffer)</span>
<span class='curline'><a href='../S/293.html#L399'>buffer</a>            399 src/android-asset.h   if (android_asset_read_internal (asset, length, buffer)</span>
<span class='curline'><a href='../S/293.html#L402'>buffer</a>            402 src/android-asset.h       xfree (buffer);</span>
<span class='curline'><a href='../S/293.html#L406'>buffer</a>            406 src/android-asset.h   return buffer;</span>
<span class='curline'><a href='../S/293.html#L410'>buffer</a>            410 src/android-asset.h AAsset_read (AAsset *asset, void *buffer, size_t size)</span>
<span class='curline'><a href='../S/293.html#L413'>buffer</a>            413 src/android-asset.h 				      buffer);</span>
<span class='curline'><a href='../S/165.html#L885'>buffer</a>            885 src/android.c  		    char *restrict buffer, size_t n)</span>
<span class='curline'><a href='../S/165.html#L948'>buffer</a>            948 src/android.c  	  memcpy (buffer, format, n);</span>
<span class='curline'><a href='../S/165.html#L949'>buffer</a>            949 src/android.c  	  buffer += len;</span>
<span class='curline'><a href='../S/165.html#L959'>buffer</a>            959 src/android.c  	  *(buffer++) = character;</span>
<span class='curline'><a href='../S/165.html#L970'>buffer</a>            970 src/android.c    *buffer = '\0';</span>
<span class='curline'><a href='../S/165.html#L985'>buffer</a>            985 src/android.c    static char buffer[PATH_MAX + 1];</span>
<span class='curline'><a href='../S/165.html#L1006'>buffer</a>           1006 src/android.c    head = stpcpy (buffer, "content:/");</span>
<span class='curline'><a href='../S/165.html#L1016'>buffer</a>           1016 src/android.c        n = PATH_MAX - (head - buffer);</span>
<span class='curline'><a href='../S/165.html#L1103'>buffer</a>           1103 src/android.c    return buffer;</span>
<span class='curline'><a href='../S/165.html#L1224'>buffer</a>           1224 src/android.c    char buffer[sizeof fingerprint * 2 + 1];</span>
<span class='curline'><a href='../S/165.html#L1226'>buffer</a>           1226 src/android.c    memset (buffer, 0, sizeof buffer);</span>
<span class='curline'><a href='../S/165.html#L1227'>buffer</a>           1227 src/android.c    hexbuf_digest (buffer, (char *) fingerprint,</span>
<span class='curline'><a href='../S/165.html#L1230'>buffer</a>           1230 src/android.c    return (*env)-&gt;NewStringUTF (env, buffer);</span>
<span class='curline'><a href='../S/165.html#L1429'>buffer</a>           1429 src/android.c    char *buffer;</span>
<span class='curline'><a href='../S/165.html#L1433'>buffer</a>           1433 src/android.c    buffer = android_proc_name (fd);</span>
<span class='curline'><a href='../S/165.html#L1434'>buffer</a>           1434 src/android.c    if (!buffer)</span>
<span class='curline'><a href='../S/165.html#L1439'>buffer</a>           1439 src/android.c    length = strlen (buffer);</span>
<span class='curline'><a href='../S/165.html#L1445'>buffer</a>           1445 src/android.c  			      (jbyte *) buffer);</span>
<span class='curline'><a href='../S/165.html#L1448'>buffer</a>           1448 src/android.c    free (buffer);</span>
<span class='curline'><a href='../S/165.html#L5367'>buffer</a>           5367 src/android.c    const char *buffer;</span>
<span class='curline'><a href='../S/165.html#L5375'>buffer</a>           5375 src/android.c    buffer = (*android_java_env)-&gt;GetStringUTFChars (android_java_env,</span>
<span class='curline'><a href='../S/165.html#L5378'>buffer</a>           5378 src/android.c    android_exception_check_nonnull ((void *) buffer, string);</span>
<span class='curline'><a href='../S/165.html#L5379'>buffer</a>           5379 src/android.c    strncpy (name_return, buffer, size - 1);</span>
<span class='curline'><a href='../S/165.html#L5384'>buffer</a>           5384 src/android.c  					      buffer);</span>
<span class='curline'><a href='../S/165.html#L6051'>buffer</a>           6051 src/android.c    const char *buffer;</span>
<span class='curline'><a href='../S/165.html#L6067'>buffer</a>           6067 src/android.c    buffer = (*android_java_env)-&gt;GetStringUTFChars (android_java_env,</span>
<span class='curline'><a href='../S/165.html#L6073'>buffer</a>           6073 src/android.c    tem = build_string_from_utf8 (buffer);</span>
<span class='curline'><a href='../S/165.html#L6077'>buffer</a>           6077 src/android.c  					      buffer);</span>
<span class='curline'><a href='../S/269.html#L2192'>buffer</a>           2192 src/androidfns.c   struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/290.html#L364'>buffer</a>            364 src/androidselect.c   char *buffer, *start;</span>
<span class='curline'><a href='../S/290.html#L416'>buffer</a>            416 src/androidselect.c       buffer = xmalloc (MIN (length, PTRDIFF_MAX));</span>
<span class='curline'><a href='../S/290.html#L417'>buffer</a>            417 src/androidselect.c       record_unwind_protect_ptr (xfree, buffer);</span>
<span class='curline'><a href='../S/290.html#L419'>buffer</a>            419 src/androidselect.c       rc = emacs_read_quit (fd, buffer,</span>
<span class='curline'><a href='../S/290.html#L427'>buffer</a>            427 src/androidselect.c       return unbind_to (ref, make_unibyte_string (buffer, rc));</span>
<span class='curline'><a href='../S/290.html#L431'>buffer</a>            431 src/androidselect.c   buffer = xmalloc (BUFSIZ);</span>
<span class='curline'><a href='../S/290.html#L433'>buffer</a>            433 src/androidselect.c   start = buffer;</span>
<span class='curline'><a href='../S/290.html#L435'>buffer</a>            435 src/androidselect.c   record_unwind_protect_ptr (android_xfree_inside, &amp;buffer);</span>
<span class='curline'><a href='../S/290.html#L459'>buffer</a>            459 src/androidselect.c       buffer = xrealloc (buffer, length + BUFSIZ);</span>
<span class='curline'><a href='../S/290.html#L460'>buffer</a>            460 src/androidselect.c       start = buffer + length;</span>
<span class='curline'><a href='../S/290.html#L463'>buffer</a>            463 src/androidselect.c   return unbind_to (ref, make_unibyte_string (buffer, rc));</span>
<span class='curline'><a href='../S/263.html#L4651'>buffer</a>           4651 src/androidterm.c   unsigned short *buffer;</span>
<span class='curline'><a href='../S/263.html#L4654'>buffer</a>           4654 src/androidterm.c   buffer = malloc (size * sizeof *buffer);</span>
<span class='curline'><a href='../S/263.html#L4656'>buffer</a>           4656 src/androidterm.c   if (!buffer)</span>
<span class='curline'><a href='../S/263.html#L4663'>buffer</a>           4663 src/androidterm.c       free (buffer);</span>
<span class='curline'><a href='../S/263.html#L4668'>buffer</a>           4668 src/androidterm.c     buffer[i] = java[i];</span>
<span class='curline'><a href='../S/263.html#L4672'>buffer</a>           4672 src/androidterm.c   return buffer;</span>
<span class='curline'><a href='../S/263.html#L4886'>buffer</a>           4886 src/androidterm.c android_text_to_string (JNIEnv *env, char *buffer, ptrdiff_t n,</span>
<span class='curline'><a href='../S/263.html#L4909'>buffer</a>           4909 src/androidterm.c 	  utf16[index] = buffer[index];</span>
<span class='curline'><a href='../S/263.html#L4932'>buffer</a>           4932 src/androidterm.c       eassert (CHAR_HEAD_P (*buffer));</span>
<span class='curline'><a href='../S/263.html#L4933'>buffer</a>           4933 src/androidterm.c       encoded = STRING_CHAR ((unsigned char *) buffer);</span>
<span class='curline'><a href='../S/263.html#L4954'>buffer</a>           4954 src/androidterm.c       buffer += BYTES_BY_CHAR_HEAD (*buffer);</span>
<span class='curline'><a href='../S/263.html#L5154'>buffer</a>           5154 src/androidterm.c   struct buffer *b;</span>
<span class='curline'><a href='../S/263.html#L5960'>buffer</a>           5960 src/androidterm.c   struct buffer *b;</span>
<span class='curline'><a href='../S/263.html#L6065'>buffer</a>           6065 src/androidterm.c   struct buffer *buffer;</span>
<span class='curline'><a href='../S/263.html#L6077'>buffer</a>           6077 src/androidterm.c   buffer = XBUFFER (WINDOW_BUFFER (w));</span>
<span class='curline'><a href='../S/263.html#L6081'>buffer</a>           6081 src/androidterm.c 	   ? BVAR (buffer, text_conversion_style)</span>
<span class='curline'><a href='../S/263.html#L6128'>buffer</a>           6128 src/androidterm.c 		   struct buffer *buffer)</span>
<span class='curline'><a href='../S/263.html#L6221'>buffer</a>           6221 src/androidterm.c   static char buffer[64];</span>
<span class='curline'><a href='../S/263.html#L6224'>buffer</a>           6224 src/androidterm.c   android_get_keysym_name (keysym, buffer, 64);</span>
<span class='curline'><a href='../S/263.html#L6228'>buffer</a>           6228 src/androidterm.c   return buffer;</span>
<span class='curline'><a href='../S/199.html#L909'>buffer</a>            909 src/androidvfs.c android_unix_readlink (struct android_vnode *vnode, char *buffer,</span>
<span class='curline'><a href='../S/199.html#L915'>buffer</a>            915 src/androidvfs.c   return readlink (vp-&gt;name, buffer, size);</span>
<span class='curline'><a href='../S/199.html#L2163'>buffer</a>           2163 src/androidvfs.c android_afs_readlink (struct android_vnode *vnode, char *buffer,</span>
<span class='curline'><a href='../S/199.html#L2660'>buffer</a>           2660 src/androidvfs.c android_content_readlink (struct android_vnode *vnode, char *buffer,</span>
<span class='curline'><a href='../S/199.html#L2826'>buffer</a>           2826 src/androidvfs.c   char *fill, *buffer;</span>
<span class='curline'><a href='../S/199.html#L2852'>buffer</a>           2852 src/androidvfs.c   buffer = xmalloc (sizeof "content://" + length);</span>
<span class='curline'><a href='../S/199.html#L2853'>buffer</a>           2853 src/androidvfs.c   sprintf (buffer, "content://%s", filename);</span>
<span class='curline'><a href='../S/199.html#L2854'>buffer</a>           2854 src/androidvfs.c   return buffer;</span>
<span class='curline'><a href='../S/199.html#L3236'>buffer</a>           3236 src/androidvfs.c android_authority_readlink (struct android_vnode *vnode, char *buffer,</span>
<span class='curline'><a href='../S/199.html#L3656'>buffer</a>           3656 src/androidvfs.c android_saf_root_readlink (struct android_vnode *vnode, char *buffer,</span>
<span class='curline'><a href='../S/199.html#L5220'>buffer</a>           5220 src/androidvfs.c android_saf_tree_readlink (struct android_vnode *vnode, char *buffer,</span>
<span class='curline'><a href='../S/199.html#L6224'>buffer</a>           6224 src/androidvfs.c android_saf_new_readlink (struct android_vnode *vnode, char *buffer,</span>
<span class='curline'><a href='../S/199.html#L6412'>buffer</a>           6412 src/androidvfs.c   char buffer[PATH_MAX + 1], *head;</span>
<span class='curline'><a href='../S/199.html#L6428'>buffer</a>           6428 src/androidvfs.c   head = buffer;</span>
<span class='curline'><a href='../S/199.html#L6450'>buffer</a>           6450 src/androidvfs.c 	    head = buffer, *head++ = '/', nslash = 0;</span>
<span class='curline'><a href='../S/199.html#L6467'>buffer</a>           6467 src/androidvfs.c   if (head == buffer || buffer[0] != '/')</span>
<span class='curline'><a href='../S/199.html#L6468'>buffer</a>           6468 src/androidvfs.c     return android_unix_vnode (buffer);</span>
<span class='curline'><a href='../S/199.html#L6475'>buffer</a>           6475 src/androidvfs.c   return (*vp-&gt;ops-&gt;name) (vp, buffer + 1, head - buffer - 1);</span>
<span class='curline'><a href='../S/199.html#L6882'>buffer</a>           6882 src/androidvfs.c 		   char *restrict buffer, size_t size)</span>
<span class='curline'><a href='../S/199.html#L6897'>buffer</a>           6897 src/androidvfs.c       snprintf (buffer, size, "/assets%s%s", dir_name,</span>
<span class='curline'><a href='../S/199.html#L6910'>buffer</a>           6910 src/androidvfs.c       snprintf (buffer, size, "%s/%s", dir_name,</span>
<span class='curline'><a href='../S/199.html#L6922'>buffer</a>           6922 src/androidvfs.c 	snprintf (buffer, size, "/content/storage/%s/%s",</span>
<span class='curline'><a href='../S/199.html#L6925'>buffer</a>           6925 src/androidvfs.c 	snprintf (buffer, size, "/content/storage/%s",</span>
<span class='curline'><a href='../S/199.html#L6937'>buffer</a>           6937 src/androidvfs.c       snprintf (buffer, size, "%s%s", vdir1-&gt;name, filename);</span>
<span class='curline'><a href='../S/199.html#L6957'>buffer</a>           6957 src/androidvfs.c   char buffer[PATH_MAX + 1];</span>
<span class='curline'><a href='../S/199.html#L6971'>buffer</a>           6971 src/androidvfs.c   if (!android_fstatat_1 (dirfd, pathname, buffer, PATH_MAX + 1))</span>
<span class='curline'><a href='../S/199.html#L6973'>buffer</a>           6973 src/androidvfs.c       pathname = buffer;</span>
<span class='curline'><a href='../S/199.html#L6997'>buffer</a>           6997 src/androidvfs.c   char buffer[PATH_MAX + 1];</span>
<span class='curline'><a href='../S/199.html#L7011'>buffer</a>           7011 src/androidvfs.c   if (!android_fstatat_1 (dirfd, pathname, buffer, PATH_MAX + 1))</span>
<span class='curline'><a href='../S/199.html#L7013'>buffer</a>           7013 src/androidvfs.c       pathname = buffer;</span>
<span class='curline'><a href='../S/199.html#L7037'>buffer</a>           7037 src/androidvfs.c   char buffer[PATH_MAX + 1];</span>
<span class='curline'><a href='../S/199.html#L7047'>buffer</a>           7047 src/androidvfs.c   if (!android_fstatat_1 (dirfd, pathname, buffer, PATH_MAX + 1))</span>
<span class='curline'><a href='../S/199.html#L7049'>buffer</a>           7049 src/androidvfs.c       pathname = buffer;</span>
<span class='curline'><a href='../S/199.html#L7073'>buffer</a>           7073 src/androidvfs.c   char buffer[PATH_MAX + 1];</span>
<span class='curline'><a href='../S/199.html#L7083'>buffer</a>           7083 src/androidvfs.c   if (!android_fstatat_1 (dirfd, pathname, buffer, PATH_MAX + 1))</span>
<span class='curline'><a href='../S/199.html#L7085'>buffer</a>           7085 src/androidvfs.c       pathname = buffer;</span>
<span class='curline'><a href='../S/199.html#L7283'>buffer</a>           7283 src/androidvfs.c 			 void *buffer, size_t size)</span>
<span class='curline'><a href='../S/199.html#L7286'>buffer</a>           7286 src/androidvfs.c     return emacs_read_quit (asset.fd, buffer, size);</span>
<span class='curline'><a href='../S/199.html#L7290'>buffer</a>           7290 src/androidvfs.c   return AAsset_read (asset.asset, buffer, size);</span>
<span class='curline'><a href='../S/199.html#L7298'>buffer</a>           7298 src/androidvfs.c 		    void *buffer, size_t size)</span>
<span class='curline'><a href='../S/199.html#L7301'>buffer</a>           7301 src/androidvfs.c     return read (asset.fd, buffer, size);</span>
<span class='curline'><a href='../S/199.html#L7305'>buffer</a>           7305 src/androidvfs.c   return AAsset_read (asset.asset, buffer, size);</span>
<span class='curline'><a href='../S/298.html#L1496'>buffer</a>           1496 src/bidi.c       struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/298.html#L1557'>buffer</a>           1557 src/bidi.c       struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/291.html#L68'>buffer</a>             68 src/buffer.c   struct buffer buffer_defaults;</span>
<span class='curline'><a href='../S/291.html#L87'>buffer</a>             87 src/buffer.c   struct buffer buffer_local_flags;</span>
<span class='curline'><a href='../S/291.html#L92'>buffer</a>             92 src/buffer.c   struct buffer buffer_local_symbols;</span>
<span class='curline'><a href='../S/291.html#L116'>buffer</a>            116 src/buffer.c   static void reset_buffer_local_variables (struct buffer *, bool);</span>
<span class='curline'><a href='../S/291.html#L125'>buffer</a>            125 src/buffer.c   static void alloc_buffer_text (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/291.html#L126'>buffer</a>            126 src/buffer.c   static void free_buffer_text (struct buffer *b);</span>
<span class='curline'><a href='../S/291.html#L127'>buffer</a>            127 src/buffer.c   static void copy_overlays (struct buffer *, struct buffer *);</span>
<span class='curline'><a href='../S/291.html#L128'>buffer</a>            128 src/buffer.c   static void modify_overlay (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/291.html#L129'>buffer</a>            129 src/buffer.c   static Lisp_Object buffer_lisp_local_variables (struct buffer *, bool);</span>
<span class='curline'><a href='../S/291.html#L130'>buffer</a>            130 src/buffer.c   static Lisp_Object buffer_local_variables_1 (struct buffer *buf, int offset, Lisp_Object sym);</span>
<span class='curline'><a href='../S/291.html#L158'>buffer</a>            158 src/buffer.c   bset_abbrev_mode (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L163'>buffer</a>            163 src/buffer.c   bset_abbrev_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L168'>buffer</a>            168 src/buffer.c   bset_auto_fill_function (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L173'>buffer</a>            173 src/buffer.c   bset_auto_save_file_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L178'>buffer</a>            178 src/buffer.c   bset_auto_save_file_name (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L183'>buffer</a>            183 src/buffer.c   bset_backed_up (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L188'>buffer</a>            188 src/buffer.c   bset_begv_marker (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L193'>buffer</a>            193 src/buffer.c   bset_bidi_display_reordering (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L198'>buffer</a>            198 src/buffer.c   bset_bidi_paragraph_start_re (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L203'>buffer</a>            203 src/buffer.c   bset_bidi_paragraph_separate_re (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L208'>buffer</a>            208 src/buffer.c   bset_buffer_file_coding_system (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L213'>buffer</a>            213 src/buffer.c   bset_case_fold_search (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L218'>buffer</a>            218 src/buffer.c   bset_ctl_arrow (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L223'>buffer</a>            223 src/buffer.c   bset_cursor_in_non_selected_windows (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L228'>buffer</a>            228 src/buffer.c   bset_cursor_type (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L233'>buffer</a>            233 src/buffer.c   bset_display_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L238'>buffer</a>            238 src/buffer.c   bset_extra_line_spacing (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L244'>buffer</a>            244 src/buffer.c   bset_ts_parser_list (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L250'>buffer</a>            250 src/buffer.c   bset_file_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L255'>buffer</a>            255 src/buffer.c   bset_file_truename (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L260'>buffer</a>            260 src/buffer.c   bset_fringe_cursor_alist (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L265'>buffer</a>            265 src/buffer.c   bset_fringe_indicator_alist (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L270'>buffer</a>            270 src/buffer.c   bset_fringes_outside_margins (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L275'>buffer</a>            275 src/buffer.c   bset_header_line_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L280'>buffer</a>            280 src/buffer.c   bset_tab_line_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L285'>buffer</a>            285 src/buffer.c   bset_indicate_buffer_boundaries (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L290'>buffer</a>            290 src/buffer.c   bset_indicate_empty_lines (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L295'>buffer</a>            295 src/buffer.c   bset_invisibility_spec (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L300'>buffer</a>            300 src/buffer.c   bset_left_fringe_width (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L305'>buffer</a>            305 src/buffer.c   bset_major_mode (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L310'>buffer</a>            310 src/buffer.c   bset_local_minor_modes (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L315'>buffer</a>            315 src/buffer.c   bset_mark (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L320'>buffer</a>            320 src/buffer.c   bset_mode_line_format (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L325'>buffer</a>            325 src/buffer.c   bset_mode_name (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L330'>buffer</a>            330 src/buffer.c   bset_name (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L335'>buffer</a>            335 src/buffer.c   bset_overwrite_mode (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L340'>buffer</a>            340 src/buffer.c   bset_pt_marker (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L345'>buffer</a>            345 src/buffer.c   bset_right_fringe_width (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L350'>buffer</a>            350 src/buffer.c   bset_save_length (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L355'>buffer</a>            355 src/buffer.c   bset_scroll_bar_width (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L360'>buffer</a>            360 src/buffer.c   bset_scroll_bar_height (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L365'>buffer</a>            365 src/buffer.c   bset_scroll_down_aggressively (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L370'>buffer</a>            370 src/buffer.c   bset_scroll_up_aggressively (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L375'>buffer</a>            375 src/buffer.c   bset_selective_display (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L380'>buffer</a>            380 src/buffer.c   bset_selective_display_ellipses (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L385'>buffer</a>            385 src/buffer.c   bset_vertical_scroll_bar_type (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L390'>buffer</a>            390 src/buffer.c   bset_horizontal_scroll_bar_type (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L395'>buffer</a>            395 src/buffer.c   bset_word_wrap (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L400'>buffer</a>            400 src/buffer.c   bset_zv_marker (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/291.html#L540'>buffer</a>            540 src/buffer.c   run_buffer_list_update_hook (struct buffer *buf)</span>
<span class='curline'><a href='../S/291.html#L564'>buffer</a>            564 src/buffer.c     register Lisp_Object buffer, name;</span>
<span class='curline'><a href='../S/291.html#L565'>buffer</a>            565 src/buffer.c     register struct buffer *b;</span>
<span class='curline'><a href='../S/291.html#L567'>buffer</a>            567 src/buffer.c     buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/291.html#L568'>buffer</a>            568 src/buffer.c     if (!NILP (buffer))</span>
<span class='curline'><a href='../S/291.html#L569'>buffer</a>            569 src/buffer.c       return buffer;</span>
<span class='curline'><a href='../S/291.html#L647'>buffer</a>            647 src/buffer.c     XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/291.html#L648'>buffer</a>            648 src/buffer.c     Vbuffer_alist = nconc2 (Vbuffer_alist, list1 (Fcons (name, buffer)));</span>
<span class='curline'><a href='../S/291.html#L652'>buffer</a>            652 src/buffer.c     return buffer;</span>
<span class='curline'><a href='../S/291.html#L656'>buffer</a>            656 src/buffer.c   add_buffer_overlay (struct buffer *b, struct Lisp_Overlay *ov,</span>
<span class='curline'><a href='../S/291.html#L659'>buffer</a>            659 src/buffer.c     eassert (! ov-&gt;buffer);</span>
<span class='curline'><a href='../S/291.html#L662'>buffer</a>            662 src/buffer.c     ov-&gt;buffer = b;</span>
<span class='curline'><a href='../S/291.html#L669'>buffer</a>            669 src/buffer.c   copy_overlays (struct buffer *from, struct buffer *to)</span>
<span class='curline'><a href='../S/291.html#L698'>buffer</a>            698 src/buffer.c   clone_per_buffer_values (struct buffer *from, struct buffer *to)</span>
<span class='curline'><a href='../S/291.html#L711'>buffer</a>            711 src/buffer.c         if (MARKERP (obj) &amp;&amp; XMARKER (obj)-&gt;buffer == from)</span>
<span class='curline'><a href='../S/291.html#L736'>buffer</a>            736 src/buffer.c   record_buffer_markers (struct buffer *b)</span>
<span class='curline'><a href='../S/291.html#L740'>buffer</a>            740 src/buffer.c         Lisp_Object buffer;</span>
<span class='curline'><a href='../S/291.html#L745'>buffer</a>            745 src/buffer.c         XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/291.html#L746'>buffer</a>            746 src/buffer.c         set_marker_both (BVAR (b, pt_marker), buffer, b-&gt;pt, b-&gt;pt_byte);</span>
<span class='curline'><a href='../S/291.html#L747'>buffer</a>            747 src/buffer.c         set_marker_both (BVAR (b, begv_marker), buffer, b-&gt;begv, b-&gt;begv_byte);</span>
<span class='curline'><a href='../S/291.html#L748'>buffer</a>            748 src/buffer.c         set_marker_both (BVAR (b, zv_marker), buffer, b-&gt;zv, b-&gt;zv_byte);</span>
<span class='curline'><a href='../S/291.html#L757'>buffer</a>            757 src/buffer.c   fetch_buffer_markers (struct buffer *b)</span>
<span class='curline'><a href='../S/291.html#L797'>buffer</a>            797 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/291.html#L897'>buffer</a>            897 src/buffer.c         struct buffer *old_b = current_buffer;</span>
<span class='curline'><a href='../S/291.html#L924'>buffer</a>            924 src/buffer.c   remove_buffer_overlay (struct buffer *b, struct Lisp_Overlay *ov)</span>
<span class='curline'><a href='../S/291.html#L927'>buffer</a>            927 src/buffer.c     eassert (ov-&gt;buffer == b);</span>
<span class='curline'><a href='../S/291.html#L928'>buffer</a>            928 src/buffer.c     itree_remove (ov-&gt;buffer-&gt;overlays, ov-&gt;interval);</span>
<span class='curline'><a href='../S/291.html#L929'>buffer</a>            929 src/buffer.c     ov-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/291.html#L937'>buffer</a>            937 src/buffer.c     if (! ov-&gt;buffer)</span>
<span class='curline'><a href='../S/291.html#L940'>buffer</a>            940 src/buffer.c     modify_overlay (ov-&gt;buffer, overlay_start (ov), overlay_end (ov));</span>
<span class='curline'><a href='../S/291.html#L941'>buffer</a>            941 src/buffer.c     remove_buffer_overlay (ov-&gt;buffer, ov);</span>
<span class='curline'><a href='../S/291.html#L947'>buffer</a>            947 src/buffer.c   delete_all_overlays (struct buffer *b)</span>
<span class='curline'><a href='../S/291.html#L960'>buffer</a>            960 src/buffer.c         XOVERLAY (node-&gt;data)-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/291.html#L969'>buffer</a>            969 src/buffer.c   free_buffer_overlays (struct buffer *b)</span>
<span class='curline'><a href='../S/291.html#L1044'>buffer</a>           1044 src/buffer.c   reset_buffer (register struct buffer *b)</span>
<span class='curline'><a href='../S/291.html#L1091'>buffer</a>           1091 src/buffer.c   reset_buffer_local_variables (struct buffer *b, bool permanent_too)</span>
<span class='curline'><a href='../S/291.html#L1122'>buffer</a>           1122 src/buffer.c         Lisp_Object buffer;</span>
<span class='curline'><a href='../S/291.html#L1123'>buffer</a>           1123 src/buffer.c         XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/291.html#L1139'>buffer</a>           1139 src/buffer.c             if (BASE_EQ (SYMBOL_BLV (XSYMBOL (sym))-&gt;where, buffer))</span>
<span class='curline'><a href='../S/291.html#L1260'>buffer</a>           1260 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L1262'>buffer</a>           1262 src/buffer.c     return BVAR (decode_buffer (buffer), name);</span>
<span class='curline'><a href='../S/291.html#L1268'>buffer</a>           1268 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L1270'>buffer</a>           1270 src/buffer.c     return BVAR (decode_buffer (buffer), filename);</span>
<span class='curline'><a href='../S/291.html#L1278'>buffer</a>           1278 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L1280'>buffer</a>           1280 src/buffer.c     struct buffer *base = decode_buffer (buffer)-&gt;base_buffer;</span>
<span class='curline'><a href='../S/291.html#L1281'>buffer</a>           1281 src/buffer.c     return base ? (XSETBUFFER (buffer, base), buffer) : Qnil;</span>
<span class='curline'><a href='../S/291.html#L1289'>buffer</a>           1289 src/buffer.c     (register Lisp_Object variable, register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L1291'>buffer</a>           1291 src/buffer.c     register Lisp_Object result = buffer_local_value (variable, buffer);</span>
<span class='curline'><a href='../S/291.html#L1304'>buffer</a>           1304 src/buffer.c   buffer_local_value (Lisp_Object variable, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L1306'>buffer</a>           1306 src/buffer.c     register struct buffer *buf;</span>
<span class='curline'><a href='../S/291.html#L1311'>buffer</a>           1311 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/291.html#L1312'>buffer</a>           1312 src/buffer.c     buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/291.html#L1368'>buffer</a>           1368 src/buffer.c   buffer_lisp_local_variables (struct buffer *buf, bool clone)</span>
<span class='curline'><a href='../S/291.html#L1403'>buffer</a>           1403 src/buffer.c   buffer_local_variables_1 (struct buffer *buf, int offset, Lisp_Object sym)</span>
<span class='curline'><a href='../S/291.html#L1423'>buffer</a>           1423 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L1425'>buffer</a>           1425 src/buffer.c     struct buffer *buf = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/291.html#L1456'>buffer</a>           1456 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L1458'>buffer</a>           1458 src/buffer.c     struct buffer *buf = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/291.html#L1538'>buffer</a>           1538 src/buffer.c     struct buffer *b = current_buffer-&gt;base_buffer</span>
<span class='curline'><a href='../S/291.html#L1588'>buffer</a>           1588 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L1590'>buffer</a>           1590 src/buffer.c     return modiff_to_integer (BUF_MODIFF (decode_buffer (buffer)));</span>
<span class='curline'><a href='../S/291.html#L1598'>buffer</a>           1598 src/buffer.c     (Lisp_Object tick, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L1601'>buffer</a>           1601 src/buffer.c     BUF_MODIFF (decode_buffer (buffer)) = XFIXNUM (tick);</span>
<span class='curline'><a href='../S/291.html#L1615'>buffer</a>           1615 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L1617'>buffer</a>           1617 src/buffer.c     return modiff_to_integer (BUF_CHARS_MODIFF (decode_buffer (buffer)));</span>
<span class='curline'><a href='../S/291.html#L1682'>buffer</a>           1682 src/buffer.c   candidate_buffer (Lisp_Object b, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L1684'>buffer</a>           1684 src/buffer.c     return (BUFFERP (b) &amp;&amp; !BASE_EQ (b, buffer)</span>
<span class='curline'><a href='../S/291.html#L1700'>buffer</a>           1700 src/buffer.c     (Lisp_Object buffer, Lisp_Object visible_ok, Lisp_Object frame)</span>
<span class='curline'><a href='../S/291.html#L1710'>buffer</a>           1710 src/buffer.c         if (candidate_buffer (buf, buffer)</span>
<span class='curline'><a href='../S/291.html#L1726'>buffer</a>           1726 src/buffer.c         if (candidate_buffer (buf, buffer)</span>
<span class='curline'><a href='../S/291.html#L1750'>buffer</a>           1750 src/buffer.c   other_buffer_safely (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L1755'>buffer</a>           1755 src/buffer.c       if (candidate_buffer (buf, buffer))</span>
<span class='curline'><a href='../S/291.html#L1777'>buffer</a>           1777 src/buffer.c     (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L1781'>buffer</a>           1781 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/291.html#L1785'>buffer</a>           1785 src/buffer.c         real_buffer = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/291.html#L1787'>buffer</a>           1787 src/buffer.c   	nsberror (buffer);</span>
<span class='curline'><a href='../S/291.html#L1799'>buffer</a>           1799 src/buffer.c   compact_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/291.html#L1801'>buffer</a>           1801 src/buffer.c     BUFFER_CHECK_INDIRECTION (buffer);</span>
<span class='curline'><a href='../S/291.html#L1805'>buffer</a>           1805 src/buffer.c     if (BUFFER_LIVE_P (buffer)</span>
<span class='curline'><a href='../S/291.html#L1806'>buffer</a>           1806 src/buffer.c         &amp;&amp; (buffer-&gt;base_buffer == NULL)</span>
<span class='curline'><a href='../S/291.html#L1807'>buffer</a>           1807 src/buffer.c         &amp;&amp; (BUF_COMPACT (buffer) != BUF_MODIFF (buffer)))</span>
<span class='curline'><a href='../S/291.html#L1813'>buffer</a>           1813 src/buffer.c         if (!EQ (BVAR(buffer, undo_list), Qt))</span>
<span class='curline'><a href='../S/291.html#L1814'>buffer</a>           1814 src/buffer.c   	truncate_undo_list (buffer);</span>
<span class='curline'><a href='../S/291.html#L1817'>buffer</a>           1817 src/buffer.c         if (!buffer-&gt;text-&gt;inhibit_shrinking)</span>
<span class='curline'><a href='../S/291.html#L1823'>buffer</a>           1823 src/buffer.c   					   BUF_Z_BYTE (buffer) / 10,</span>
<span class='curline'><a href='../S/291.html#L1825'>buffer</a>           1825 src/buffer.c   	  if (BUF_GAP_SIZE (buffer) &gt; size)</span>
<span class='curline'><a href='../S/291.html#L1826'>buffer</a>           1826 src/buffer.c   	    make_gap_1 (buffer, -(BUF_GAP_SIZE (buffer) - size));</span>
<span class='curline'><a href='../S/291.html#L1828'>buffer</a>           1828 src/buffer.c         BUF_COMPACT (buffer) = BUF_MODIFF (buffer);</span>
<span class='curline'><a href='../S/291.html#L1852'>buffer</a>           1852 src/buffer.c     Lisp_Object buffer;</span>
<span class='curline'><a href='../S/291.html#L1853'>buffer</a>           1853 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/291.html#L1858'>buffer</a>           1858 src/buffer.c       buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/291.html#L1860'>buffer</a>           1860 src/buffer.c       buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/291.html#L1861'>buffer</a>           1861 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/291.html#L1864'>buffer</a>           1864 src/buffer.c     b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/291.html#L1900'>buffer</a>           1900 src/buffer.c   	if (NILP (call1 (Qkill_buffer__possibly_save, buffer)))</span>
<span class='curline'><a href='../S/291.html#L1942'>buffer</a>           1942 src/buffer.c     if (BASE_EQ (buffer, XWINDOW (minibuf_window)-&gt;contents))</span>
<span class='curline'><a href='../S/291.html#L1966'>buffer</a>           1966 src/buffer.c     replace_buffer_in_windows (buffer);</span>
<span class='curline'><a href='../S/291.html#L1976'>buffer</a>           1976 src/buffer.c         tem = Fother_buffer (buffer, Qnil, Qnil);</span>
<span class='curline'><a href='../S/291.html#L1986'>buffer</a>           1986 src/buffer.c         &amp;&amp; BASE_EQ (buffer, Fother_buffer (buffer, Qnil, Qnil)))</span>
<span class='curline'><a href='../S/291.html#L1994'>buffer</a>           1994 src/buffer.c     kill_buffer_processes (buffer);</span>
<span class='curline'><a href='../S/291.html#L1995'>buffer</a>           1995 src/buffer.c     kill_buffer_xwidgets (buffer);</span>
<span class='curline'><a href='../S/291.html#L2004'>buffer</a>           2004 src/buffer.c     frames_discard_buffer (buffer);</span>
<span class='curline'><a href='../S/291.html#L2014'>buffer</a>           2014 src/buffer.c     Vbuffer_alist = Fdelq (Frassq (buffer, Vbuffer_alist), Vbuffer_alist);</span>
<span class='curline'><a href='../S/291.html#L2016'>buffer</a>           2016 src/buffer.c     replace_buffer_in_windows_safely (buffer);</span>
<span class='curline'><a href='../S/291.html#L2028'>buffer</a>           2028 src/buffer.c   	  if (m-&gt;buffer == b)</span>
<span class='curline'><a href='../S/291.html#L2030'>buffer</a>           2030 src/buffer.c   	      m-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/291.html#L2052'>buffer</a>           2052 src/buffer.c   	  m-&gt;buffer = 0;</span>
<span class='curline'><a href='../S/291.html#L2125'>buffer</a>           2125 src/buffer.c   record_buffer (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L2130'>buffer</a>           2130 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/291.html#L2137'>buffer</a>           2137 src/buffer.c     aelt = Frassq (buffer, Vbuffer_alist);</span>
<span class='curline'><a href='../S/291.html#L2145'>buffer</a>           2145 src/buffer.c     fset_buffer_list (f, Fcons (buffer, Fdelq (buffer, f-&gt;buffer_list)));</span>
<span class='curline'><a href='../S/291.html#L2146'>buffer</a>           2146 src/buffer.c     fset_buried_buffer_list (f, Fdelq (buffer, f-&gt;buried_buffer_list));</span>
<span class='curline'><a href='../S/291.html#L2148'>buffer</a>           2148 src/buffer.c     run_buffer_list_update_hook (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/291.html#L2161'>buffer</a>           2161 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L2166'>buffer</a>           2166 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/291.html#L2173'>buffer</a>           2173 src/buffer.c     aelt = Frassq (buffer, Vbuffer_alist);</span>
<span class='curline'><a href='../S/291.html#L2181'>buffer</a>           2181 src/buffer.c     fset_buffer_list (f, Fdelq (buffer, f-&gt;buffer_list));</span>
<span class='curline'><a href='../S/291.html#L2183'>buffer</a>           2183 src/buffer.c       (f, Fcons (buffer, Fdelq (buffer, f-&gt;buried_buffer_list)));</span>
<span class='curline'><a href='../S/291.html#L2185'>buffer</a>           2185 src/buffer.c     run_buffer_list_update_hook (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/291.html#L2196'>buffer</a>           2196 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L2200'>buffer</a>           2200 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/291.html#L2202'>buffer</a>           2202 src/buffer.c     if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/291.html#L2205'>buffer</a>           2205 src/buffer.c     if (strcmp (SSDATA (BVAR (XBUFFER (buffer), name)), "*scratch*") == 0)</span>
<span class='curline'><a href='../S/291.html#L2227'>buffer</a>           2227 src/buffer.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/291.html#L2246'>buffer</a>           2246 src/buffer.c   set_buffer_internal_1 (register struct buffer *b)</span>
<span class='curline'><a href='../S/291.html#L2262'>buffer</a>           2262 src/buffer.c   void set_buffer_internal_2 (register struct buffer *b)</span>
<span class='curline'><a href='../S/291.html#L2264'>buffer</a>           2264 src/buffer.c     register struct buffer *old_buf;</span>
<span class='curline'><a href='../S/291.html#L2318'>buffer</a>           2318 src/buffer.c   set_buffer_temp (struct buffer *b)</span>
<span class='curline'><a href='../S/291.html#L2320'>buffer</a>           2320 src/buffer.c     register struct buffer *old_buf;</span>
<span class='curline'><a href='../S/291.html#L2347'>buffer</a>           2347 src/buffer.c     register Lisp_Object buffer;</span>
<span class='curline'><a href='../S/291.html#L2348'>buffer</a>           2348 src/buffer.c     buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/291.html#L2349'>buffer</a>           2349 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/291.html#L2351'>buffer</a>           2351 src/buffer.c     if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/291.html#L2353'>buffer</a>           2353 src/buffer.c     set_buffer_internal (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/291.html#L2354'>buffer</a>           2354 src/buffer.c     return buffer;</span>
<span class='curline'><a href='../S/291.html#L2366'>buffer</a>           2366 src/buffer.c   set_buffer_if_live (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L2368'>buffer</a>           2368 src/buffer.c     if (BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/291.html#L2369'>buffer</a>           2369 src/buffer.c       set_buffer_internal (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/291.html#L2464'>buffer</a>           2464 src/buffer.c   swap_buffer_overlays (struct buffer *buffer, struct buffer *other)</span>
<span class='curline'><a href='../S/291.html#L2468'>buffer</a>           2468 src/buffer.c     ITREE_FOREACH (node, buffer-&gt;overlays, PTRDIFF_MIN, PTRDIFF_MAX, ASCENDING)</span>
<span class='curline'><a href='../S/291.html#L2469'>buffer</a>           2469 src/buffer.c       XOVERLAY (node-&gt;data)-&gt;buffer = other;</span>
<span class='curline'><a href='../S/291.html#L2472'>buffer</a>           2472 src/buffer.c       XOVERLAY (node-&gt;data)-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/291.html#L2475'>buffer</a>           2475 src/buffer.c     void *tmp = buffer-&gt;overlays;</span>
<span class='curline'><a href='../S/291.html#L2476'>buffer</a>           2476 src/buffer.c     buffer-&gt;overlays = other-&gt;overlays;</span>
<span class='curline'><a href='../S/291.html#L2485'>buffer</a>           2485 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L2487'>buffer</a>           2487 src/buffer.c     struct buffer *other_buffer;</span>
<span class='curline'><a href='../S/291.html#L2488'>buffer</a>           2488 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/291.html#L2489'>buffer</a>           2489 src/buffer.c     other_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/291.html#L2581'>buffer</a>           2581 src/buffer.c         if (m-&gt;buffer == other_buffer)</span>
<span class='curline'><a href='../S/291.html#L2582'>buffer</a>           2582 src/buffer.c   	m-&gt;buffer = current_buffer;</span>
<span class='curline'><a href='../S/291.html#L2586'>buffer</a>           2586 src/buffer.c   	eassert (!m-&gt;buffer);</span>
<span class='curline'><a href='../S/291.html#L2588'>buffer</a>           2588 src/buffer.c         if (m-&gt;buffer == current_buffer)</span>
<span class='curline'><a href='../S/291.html#L2589'>buffer</a>           2589 src/buffer.c   	m-&gt;buffer = other_buffer;</span>
<span class='curline'><a href='../S/291.html#L2593'>buffer</a>           2593 src/buffer.c   	eassert (!m-&gt;buffer);</span>
<span class='curline'><a href='../S/291.html#L2633'>buffer</a>           2633 src/buffer.c       (eassert (BASE_EQ (current_buffer-&gt;text-&gt;intervals-&gt;up.obj, buffer)),</span>
<span class='curline'><a href='../S/291.html#L2906'>buffer</a>           2906 src/buffer.c         struct buffer *o = XBUFFER (other);</span>
<span class='curline'><a href='../S/291.html#L3482'>buffer</a>           3482 src/buffer.c         struct buffer *base = current_buffer-&gt;base_buffer</span>
<span class='curline'><a href='../S/291.html#L3495'>buffer</a>           3495 src/buffer.c   adjust_overlays_for_delete_in_buffer (struct buffer * buf,</span>
<span class='curline'><a href='../S/291.html#L3527'>buffer</a>           3527 src/buffer.c         struct buffer *base = current_buffer-&gt;base_buffer</span>
<span class='curline'><a href='../S/291.html#L3556'>buffer</a>           3556 src/buffer.c     (Lisp_Object beg, Lisp_Object end, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/291.html#L3560'>buffer</a>           3560 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/291.html#L3562'>buffer</a>           3562 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/291.html#L3563'>buffer</a>           3563 src/buffer.c       XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/291.html#L3565'>buffer</a>           3565 src/buffer.c       CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/291.html#L3567'>buffer</a>           3567 src/buffer.c     b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/291.html#L3571'>buffer</a>           3571 src/buffer.c     if (MARKERP (beg) &amp;&amp; !BASE_EQ (Fmarker_buffer (beg), buffer))</span>
<span class='curline'><a href='../S/291.html#L3573'>buffer</a>           3573 src/buffer.c     if (MARKERP (end) &amp;&amp; !BASE_EQ (Fmarker_buffer (end), buffer))</span>
<span class='curline'><a href='../S/291.html#L3600'>buffer</a>           3600 src/buffer.c   modify_overlay (struct buffer *buf, ptrdiff_t start, ptrdiff_t end)</span>
<span class='curline'><a href='../S/291.html#L3621'>buffer</a>           3621 src/buffer.c     (Lisp_Object overlay, Lisp_Object beg, Lisp_Object end, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L3623'>buffer</a>           3623 src/buffer.c     struct buffer *b, *ob = 0;</span>
<span class='curline'><a href='../S/291.html#L3629'>buffer</a>           3629 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/291.html#L3630'>buffer</a>           3630 src/buffer.c       buffer = Foverlay_buffer (overlay);</span>
<span class='curline'><a href='../S/291.html#L3631'>buffer</a>           3631 src/buffer.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/291.html#L3632'>buffer</a>           3632 src/buffer.c       XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/291.html#L3633'>buffer</a>           3633 src/buffer.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/291.html#L3635'>buffer</a>           3635 src/buffer.c     if (NILP (Fbuffer_live_p (buffer)))</span>
<span class='curline'><a href='../S/291.html#L3638'>buffer</a>           3638 src/buffer.c     if (MARKERP (beg) &amp;&amp; !BASE_EQ (Fmarker_buffer (beg), buffer))</span>
<span class='curline'><a href='../S/291.html#L3640'>buffer</a>           3640 src/buffer.c     if (MARKERP (end) &amp;&amp; !BASE_EQ (Fmarker_buffer (end), buffer))</span>
<span class='curline'><a href='../S/291.html#L3655'>buffer</a>           3655 src/buffer.c     b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/291.html#L3668'>buffer</a>           3668 src/buffer.c     if (! BASE_EQ (buffer, obuffer))</span>
<span class='curline'><a href='../S/291.html#L3672'>buffer</a>           3672 src/buffer.c         add_buffer_overlay (XBUFFER (buffer), XOVERLAY (overlay), n_beg, n_end);</span>
<span class='curline'><a href='../S/291.html#L3679'>buffer</a>           3679 src/buffer.c     if (!BASE_EQ (buffer, obuffer))</span>
<span class='curline'><a href='../S/291.html#L3719'>buffer</a>           3719 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/291.html#L3748'>buffer</a>           3748 src/buffer.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L3750'>buffer</a>           3750 src/buffer.c     delete_all_overlays (decode_buffer (buffer));</span>
<span class='curline'><a href='../S/291.html#L3783'>buffer</a>           3783 src/buffer.c     Lisp_Object buffer;</span>
<span class='curline'><a href='../S/291.html#L3790'>buffer</a>           3790 src/buffer.c     XSETBUFFER (buffer, OVERLAY_BUFFER (overlay));</span>
<span class='curline'><a href='../S/291.html#L3792'>buffer</a>           3792 src/buffer.c     return buffer;</span>
<span class='curline'><a href='../S/291.html#L3969'>buffer</a>           3969 src/buffer.c     struct buffer *b;</span>
<span class='curline'><a href='../S/291.html#L4520'>buffer</a>           4520 src/buffer.c   alloc_buffer_text (struct buffer *b, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/291.html#L4547'>buffer</a>           4547 src/buffer.c   enlarge_buffer_text (struct buffer *b, ptrdiff_t delta)</span>
<span class='curline'><a href='../S/291.html#L4589'>buffer</a>           4589 src/buffer.c   free_buffer_text (struct buffer *b)</span>
<span class='curline'><a href='../S/291.html#L4863'>buffer</a>           4863 src/buffer.c         Lisp_Object tail, buffer;</span>
<span class='curline'><a href='../S/291.html#L4889'>buffer</a>           4889 src/buffer.c         FOR_EACH_LIVE_BUFFER (tail, buffer)</span>
<span class='curline'><a href='../S/291.html#L4891'>buffer</a>           4891 src/buffer.c   	  struct buffer *b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/291.html#L5020'>buffer</a>           5020 src/buffer.c        (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/291.html#L5022'>buffer</a>           5022 src/buffer.c     struct buffer *b = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/252.html#L162'>buffer</a>            162 src/buffer.h   extern void temp_set_point (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/252.html#L164'>buffer</a>            164 src/buffer.h   extern void temp_set_point_both (struct buffer *,</span>
<span class='curline'><a href='../S/252.html#L167'>buffer</a>            167 src/buffer.h   extern void enlarge_buffer_text (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/252.html#L190'>buffer</a>            190 src/buffer.h   BUF_TEMP_SET_PT (struct buffer *buffer, ptrdiff_t position)</span>
<span class='curline'><a href='../S/252.html#L192'>buffer</a>            192 src/buffer.h     temp_set_point (buffer, position);</span>
<span class='curline'><a href='../S/252.html#L611'>buffer</a>            611 src/buffer.h     struct buffer *base_buffer;</span>
<span class='curline'><a href='../S/252.html#L729'>buffer</a>            729 src/buffer.h   INLINE struct buffer *</span>
<span class='curline'><a href='../S/252.html#L733'>buffer</a>            733 src/buffer.h     return XUNTAG (a, Lisp_Vectorlike, struct buffer);</span>
<span class='curline'><a href='../S/252.html#L740'>buffer</a>            740 src/buffer.h   bset_bidi_paragraph_direction (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L745'>buffer</a>            745 src/buffer.h   bset_cache_long_scans (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L750'>buffer</a>            750 src/buffer.h   bset_case_canon_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L755'>buffer</a>            755 src/buffer.h   bset_case_eqv_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L760'>buffer</a>            760 src/buffer.h   bset_directory (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L765'>buffer</a>            765 src/buffer.h   bset_display_count (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L770'>buffer</a>            770 src/buffer.h   bset_left_margin_cols (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L775'>buffer</a>            775 src/buffer.h   bset_right_margin_cols (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L780'>buffer</a>            780 src/buffer.h   bset_display_time (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L785'>buffer</a>            785 src/buffer.h   bset_downcase_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L790'>buffer</a>            790 src/buffer.h   bset_enable_multibyte_characters (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L795'>buffer</a>            795 src/buffer.h   bset_filename (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L800'>buffer</a>            800 src/buffer.h   bset_keymap (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L805'>buffer</a>            805 src/buffer.h   bset_last_selected_window (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L810'>buffer</a>            810 src/buffer.h   bset_local_var_alist (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L815'>buffer</a>            815 src/buffer.h   bset_mark_active (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L820'>buffer</a>            820 src/buffer.h   bset_point_before_scroll (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L825'>buffer</a>            825 src/buffer.h   bset_read_only (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L830'>buffer</a>            830 src/buffer.h   bset_truncate_lines (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L835'>buffer</a>            835 src/buffer.h   bset_undo_list (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L840'>buffer</a>            840 src/buffer.h   bset_upcase_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L845'>buffer</a>            845 src/buffer.h   bset_width_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L851'>buffer</a>            851 src/buffer.h   bset_text_conversion_style (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/252.html#L878'>buffer</a>            878 src/buffer.h   BUF_BEGV (struct buffer *buf)</span>
<span class='curline'><a href='../S/252.html#L886'>buffer</a>            886 src/buffer.h   BUF_BEGV_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/252.html#L895'>buffer</a>            895 src/buffer.h   BUF_PT (struct buffer *buf)</span>
<span class='curline'><a href='../S/252.html#L903'>buffer</a>            903 src/buffer.h   BUF_PT_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/252.html#L912'>buffer</a>            912 src/buffer.h   BUF_ZV (struct buffer *buf)</span>
<span class='curline'><a href='../S/252.html#L920'>buffer</a>            920 src/buffer.h   BUF_ZV_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/252.html#L931'>buffer</a>            931 src/buffer.h   BUF_BEG (struct buffer *buf)</span>
<span class='curline'><a href='../S/252.html#L937'>buffer</a>            937 src/buffer.h   BUF_BEG_BYTE (struct buffer *buf)</span>
<span class='curline'><a href='../S/252.html#L944'>buffer</a>            944 src/buffer.h   BUF_GPT_ADDR (struct buffer *buf)</span>
<span class='curline'><a href='../S/252.html#L951'>buffer</a>            951 src/buffer.h   BUF_Z_ADDR (struct buffer *buf)</span>
<span class='curline'><a href='../S/252.html#L958'>buffer</a>            958 src/buffer.h   BUF_GAP_END_ADDR (struct buffer *buf)</span>
<span class='curline'><a href='../S/252.html#L968'>buffer</a>            968 src/buffer.h   BUF_COMPUTE_UNCHANGED (struct buffer *buf, ptrdiff_t start, ptrdiff_t end)</span>
<span class='curline'><a href='../S/252.html#L995'>buffer</a>            995 src/buffer.h   SET_BUF_BEGV (struct buffer *buf, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/252.html#L1002'>buffer</a>           1002 src/buffer.h   SET_BUF_ZV (struct buffer *buf, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/252.html#L1009'>buffer</a>           1009 src/buffer.h   SET_BUF_BEGV_BOTH (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t byte)</span>
<span class='curline'><a href='../S/252.html#L1016'>buffer</a>           1016 src/buffer.h   SET_BUF_ZV_BOTH (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t byte)</span>
<span class='curline'><a href='../S/252.html#L1023'>buffer</a>           1023 src/buffer.h   SET_BUF_PT_BOTH (struct buffer *buf, ptrdiff_t charpos, ptrdiff_t byte)</span>
<span class='curline'><a href='../S/252.html#L1083'>buffer</a>           1083 src/buffer.h   enum { BUFFER_LISP_SIZE = PSEUDOVECSIZE (struct buffer,</span>
<span class='curline'><a href='../S/252.html#L1089'>buffer</a>           1089 src/buffer.h   enum { BUFFER_REST_SIZE = VECSIZE (struct buffer) - BUFFER_LISP_SIZE };</span>
<span class='curline'><a href='../S/252.html#L1096'>buffer</a>           1096 src/buffer.h   BUFFER_PVEC_INIT (struct buffer *b)</span>
<span class='curline'><a href='../S/252.html#L1104'>buffer</a>           1104 src/buffer.h   BUFFER_LIVE_P (struct buffer *b)</span>
<span class='curline'><a href='../S/252.html#L1113'>buffer</a>           1113 src/buffer.h   BUFFER_HIDDEN_P (struct buffer *b)</span>
<span class='curline'><a href='../S/252.html#L1121'>buffer</a>           1121 src/buffer.h   BUFFER_CHECK_INDIRECTION (struct buffer *b)</span>
<span class='curline'><a href='../S/252.html#L1142'>buffer</a>           1142 src/buffer.h   extern struct buffer buffer_defaults;</span>
<span class='curline'><a href='../S/252.html#L1158'>buffer</a>           1158 src/buffer.h   extern struct buffer buffer_local_flags;</span>
<span class='curline'><a href='../S/252.html#L1164'>buffer</a>           1164 src/buffer.h   extern struct buffer buffer_local_symbols;</span>
<span class='curline'><a href='../S/252.html#L1174'>buffer</a>           1174 src/buffer.h   extern void delete_all_overlays (struct buffer *);</span>
<span class='curline'><a href='../S/252.html#L1175'>buffer</a>           1175 src/buffer.h   extern void reset_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/252.html#L1176'>buffer</a>           1176 src/buffer.h   extern void compact_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/252.html#L1183'>buffer</a>           1183 src/buffer.h   extern void recenter_overlay_lists (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/252.html#L1186'>buffer</a>           1186 src/buffer.h   extern void set_buffer_internal_1 (struct buffer *);</span>
<span class='curline'><a href='../S/252.html#L1187'>buffer</a>           1187 src/buffer.h   extern void set_buffer_internal_2 (struct buffer *);</span>
<span class='curline'><a href='../S/252.html#L1188'>buffer</a>           1188 src/buffer.h   extern void set_buffer_temp (struct buffer *);</span>
<span class='curline'><a href='../S/252.html#L1191'>buffer</a>           1191 src/buffer.h   extern void fix_overlays_before (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/252.html#L1199'>buffer</a>           1199 src/buffer.h   INLINE struct buffer *</span>
<span class='curline'><a href='../S/252.html#L1215'>buffer</a>           1215 src/buffer.h   set_buffer_internal (struct buffer *b)</span>
<span class='curline'><a href='../S/252.html#L1260'>buffer</a>           1260 src/buffer.h   buffer_intervals (struct buffer *b)</span>
<span class='curline'><a href='../S/252.html#L1269'>buffer</a>           1269 src/buffer.h   set_buffer_intervals (struct buffer *b, INTERVAL i)</span>
<span class='curline'><a href='../S/252.html#L1303'>buffer</a>           1303 src/buffer.h   BUF_FETCH_MULTIBYTE_CHAR (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/252.html#L1338'>buffer</a>           1338 src/buffer.h   BUF_BYTE_ADDRESS (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/252.html#L1348'>buffer</a>           1348 src/buffer.h   BUF_CHAR_ADDRESS (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/252.html#L1358'>buffer</a>           1358 src/buffer.h   BUF_PTR_BYTE_POS (struct buffer *buf, unsigned char *ptr)</span>
<span class='curline'><a href='../S/252.html#L1368'>buffer</a>           1368 src/buffer.h   BUF_FETCH_BYTE (struct buffer *buf, ptrdiff_t n)</span>
<span class='curline'><a href='../S/252.html#L1378'>buffer</a>           1378 src/buffer.h   BUF_FETCH_CHAR_AS_MULTIBYTE (struct buffer *buf, ptrdiff_t pos)</span>
<span class='curline'><a href='../S/252.html#L1388'>buffer</a>           1388 src/buffer.h   buffer_window_count (struct buffer *b)</span>
<span class='curline'><a href='../S/252.html#L1401'>buffer</a>           1401 src/buffer.h     if (! ov-&gt;buffer)</span>
<span class='curline'><a href='../S/252.html#L1403'>buffer</a>           1403 src/buffer.h     return itree_node_begin (ov-&gt;buffer-&gt;overlays, ov-&gt;interval);</span>
<span class='curline'><a href='../S/252.html#L1409'>buffer</a>           1409 src/buffer.h     if (! ov-&gt;buffer)</span>
<span class='curline'><a href='../S/252.html#L1411'>buffer</a>           1411 src/buffer.h     return itree_node_end (ov-&gt;buffer-&gt;overlays, ov-&gt;interval);</span>
<span class='curline'><a href='../S/252.html#L1441'>buffer</a>           1441 src/buffer.h   INLINE struct buffer *</span>
<span class='curline'><a href='../S/252.html#L1444'>buffer</a>           1444 src/buffer.h     return XOVERLAY (ov)-&gt;buffer;</span>
<span class='curline'><a href='../S/252.html#L1472'>buffer</a>           1472 src/buffer.h     offsetof (struct buffer, VAR ## _)</span>
<span class='curline'><a href='../S/252.html#L1498'>buffer</a>           1498 src/buffer.h   PER_BUFFER_VALUE_P (struct buffer *b, int idx)</span>
<span class='curline'><a href='../S/252.html#L1508'>buffer</a>           1508 src/buffer.h   SET_PER_BUFFER_VALUE_P (struct buffer *b, int idx, bool val)</span>
<span class='curline'><a href='../S/252.html#L1559'>buffer</a>           1559 src/buffer.h   per_buffer_value (struct buffer *b, int offset)</span>
<span class='curline'><a href='../S/252.html#L1565'>buffer</a>           1565 src/buffer.h   set_per_buffer_value (struct buffer *b, int offset, Lisp_Object value)</span>
<span class='curline'><a href='../S/252.html#L1612'>buffer</a>           1612 src/buffer.h   SANE_TAB_WIDTH (struct buffer *buf)</span>
<span class='curline'><a href='../S/252.html#L1692'>buffer</a>           1692 src/buffer.h   buf_next_char_len (struct buffer *buf, ptrdiff_t pos_byte)</span>
<span class='curline'><a href='../S/252.html#L1708'>buffer</a>           1708 src/buffer.h   buf_prev_char_len (struct buffer *buf, ptrdiff_t pos_byte)</span>
<span class='curline'><a href='../S/134.html#L246'>buffer</a>            246 src/callproc.c call_process_cleanup (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/134.html#L248'>buffer</a>            248 src/callproc.c   Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/134.html#L358'>buffer</a>            358 src/callproc.c   Lisp_Object buffer, current_dir, path;</span>
<span class='curline'><a href='../S/134.html#L445'>buffer</a>            445 src/callproc.c     buffer = Qnil;</span>
<span class='curline'><a href='../S/134.html#L448'>buffer</a>            448 src/callproc.c       buffer = args[2];</span>
<span class='curline'><a href='../S/134.html#L453'>buffer</a>            453 src/callproc.c       if (CONSP (buffer) &amp;&amp; !EQ (XCAR (buffer), QCfile))</span>
<span class='curline'><a href='../S/134.html#L455'>buffer</a>            455 src/callproc.c 	  if (CONSP (XCDR (buffer)))</span>
<span class='curline'><a href='../S/134.html#L458'>buffer</a>            458 src/callproc.c 	      stderr_file = XCAR (XCDR (buffer));</span>
<span class='curline'><a href='../S/134.html#L466'>buffer</a>            466 src/callproc.c 	  buffer = XCAR (buffer);</span>
<span class='curline'><a href='../S/134.html#L470'>buffer</a>            470 src/callproc.c       if (CONSP (buffer) &amp;&amp; EQ (XCAR (buffer), QCfile))</span>
<span class='curline'><a href='../S/134.html#L472'>buffer</a>            472 src/callproc.c 	  Lisp_Object ofile = XCDR (buffer);</span>
<span class='curline'><a href='../S/134.html#L479'>buffer</a>            479 src/callproc.c 	  buffer = Qnil;</span>
<span class='curline'><a href='../S/134.html#L482'>buffer</a>            482 src/callproc.c       if (! (NILP (buffer) || EQ (buffer, Qt) || FIXNUMP (buffer)))</span>
<span class='curline'><a href='../S/134.html#L484'>buffer</a>            484 src/callproc.c 	  Lisp_Object spec_buffer = buffer;</span>
<span class='curline'><a href='../S/134.html#L485'>buffer</a>            485 src/callproc.c 	  buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/134.html#L487'>buffer</a>            487 src/callproc.c 	  if (NILP (buffer))</span>
<span class='curline'><a href='../S/134.html#L489'>buffer</a>            489 src/callproc.c 	  CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/134.html#L555'>buffer</a>            555 src/callproc.c   discard_output = FIXNUMP (buffer) || (NILP (buffer) &amp;&amp; NILP (output_file));</span>
<span class='curline'><a href='../S/134.html#L686'>buffer</a>            686 src/callproc.c       if (FIXNUMP (buffer))</span>
<span class='curline'><a href='../S/134.html#L719'>buffer</a>            719 src/callproc.c   if (FIXNUMP (buffer))</span>
<span class='curline'><a href='../S/134.html#L722'>buffer</a>            722 src/callproc.c   if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/134.html#L723'>buffer</a>            723 src/callproc.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/97.html#L40'>buffer</a>             40 src/category.c bset_category_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/287.html#L913'>buffer</a>            913 src/coding.c         struct buffer *buf = XBUFFER (coding-&gt;src_object);</span>
<span class='curline'><a href='../S/287.html#L1030'>buffer</a>           1030 src/coding.c         struct buffer *buf = XBUFFER (coding-&gt;dst_object);</span>
<span class='curline'><a href='../S/287.html#L7874'>buffer</a>           7874 src/coding.c         struct buffer *current = current_buffer;</span>
<span class='curline'><a href='../S/287.html#L7895'>buffer</a>           7895 src/coding.c     struct buffer *buf = XBUFFER (XCDR (arg));</span>
<span class='curline'><a href='../S/287.html#L8394'>buffer</a>           8394 src/coding.c   	  struct buffer *current = current_buffer;</span>
<span class='curline'><a href='../S/287.html#L9447'>buffer</a>           9447 src/coding.c         struct buffer *buf = XBUFFER (dst_object);</span>
<span class='curline'><a href='../S/287.html#L9596'>buffer</a>           9596 src/coding.c         struct buffer *buf = XBUFFER (dst_object);</span>
<span class='curline'><a href='../S/287.html#L9630'>buffer</a>           9630 src/coding.c   get_buffer_gap_address (Lisp_Object buffer, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/287.html#L9632'>buffer</a>           9632 src/coding.c     struct buffer *buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/287.html#L9636'>buffer</a>           9636 src/coding.c         struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/287.html#L9743'>buffer</a>           9743 src/coding.c   encode_string_utf_8 (Lisp_Object string, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/287.html#L9748'>buffer</a>           9748 src/coding.c     if (NILP (buffer) &amp;&amp; nchars == nbytes &amp;&amp; nocopy)</span>
<span class='curline'><a href='../S/287.html#L9918'>buffer</a>           9918 src/coding.c   	  if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/287.html#L9921'>buffer</a>           9921 src/coding.c   	      dst = get_buffer_gap_address (buffer, nbytes);</span>
<span class='curline'><a href='../S/287.html#L9936'>buffer</a>           9936 src/coding.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/287.html#L9938'>buffer</a>           9938 src/coding.c         struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/287.html#L9940'>buffer</a>           9940 src/coding.c         current_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/287.html#L10020'>buffer</a>           10020 src/coding.c   		     Lisp_Object buffer, bool nocopy,</span>
<span class='curline'><a href='../S/287.html#L10097'>buffer</a>           10097 src/coding.c         &amp;&amp; NILP (buffer))</span>
<span class='curline'><a href='../S/287.html#L10166'>buffer</a>           10166 src/coding.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/287.html#L10169'>buffer</a>           10169 src/coding.c         dst = get_buffer_gap_address (buffer, outbytes);</span>
<span class='curline'><a href='../S/287.html#L10246'>buffer</a>           10246 src/coding.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/287.html#L10248'>buffer</a>           10248 src/coding.c         struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/287.html#L10250'>buffer</a>           10250 src/coding.c         current_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/287.html#L10274'>buffer</a>           10274 src/coding.c     (Lisp_Object string, Lisp_Object buffer, Lisp_Object nocopy,</span>
<span class='curline'><a href='../S/287.html#L10284'>buffer</a>           10284 src/coding.c     if (! NILP (buffer)</span>
<span class='curline'><a href='../S/287.html#L10285'>buffer</a>           10285 src/coding.c         &amp;&amp; (! BUFFERP (buffer)</span>
<span class='curline'><a href='../S/287.html#L10286'>buffer</a>           10286 src/coding.c   	  || ! NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/287.html#L10307'>buffer</a>           10307 src/coding.c   	val = encode_string_utf_8 (string, buffer, ! NILP (nocopy),</span>
<span class='curline'><a href='../S/287.html#L10330'>buffer</a>           10330 src/coding.c     (Lisp_Object string, Lisp_Object buffer, Lisp_Object nocopy,</span>
<span class='curline'><a href='../S/287.html#L10340'>buffer</a>           10340 src/coding.c     if (! NILP (buffer)</span>
<span class='curline'><a href='../S/287.html#L10341'>buffer</a>           10341 src/coding.c         &amp;&amp; (! BUFFERP (buffer)</span>
<span class='curline'><a href='../S/287.html#L10342'>buffer</a>           10342 src/coding.c   	  || NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/287.html#L10363'>buffer</a>           10363 src/coding.c   	val = decode_string_utf_8 (string, buffer, ! NILP (nocopy),</span>
<span class='curline'><a href='../S/287.html#L10368'>buffer</a>           10368 src/coding.c         if (! BUFFERP (buffer))</span>
<span class='curline'><a href='../S/287.html#L10369'>buffer</a>           10369 src/coding.c   	buffer = Qt;</span>
<span class='curline'><a href='../S/287.html#L10371'>buffer</a>           10371 src/coding.c   	val = code_convert_string (string, Qutf_8_unix, buffer, false,</span>
<span class='curline'><a href='../S/287.html#L10470'>buffer</a>           10470 src/coding.c     (Lisp_Object string, Lisp_Object coding_system, Lisp_Object nocopy, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/287.html#L10472'>buffer</a>           10472 src/coding.c     return code_convert_string (string, coding_system, buffer,</span>
<span class='curline'><a href='../S/287.html#L10490'>buffer</a>           10490 src/coding.c     (Lisp_Object string, Lisp_Object coding_system, Lisp_Object nocopy, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/287.html#L10492'>buffer</a>           10492 src/coding.c     return code_convert_string (string, coding_system, buffer,</span>
<span class='curline'><a href='../S/203.html#L1371'>buffer</a>           1371 src/data.c     			 struct buffer *buf)</span>
<span class='curline'><a href='../S/203.html#L1410'>buffer</a>           1410 src/data.c     	      struct buffer *b = XBUFFER (buf);</span>
<span class='curline'><a href='../S/203.html#L1727'>buffer</a>           1727 src/data.c     	struct buffer *buf</span>
<span class='curline'><a href='../S/203.html#L2034'>buffer</a>           2034 src/data.c     		    struct buffer *b = XBUFFER (buf);</span>
<span class='curline'><a href='../S/203.html#L2341'>buffer</a>           2341 src/data.c       (Lisp_Object variable, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/203.html#L2343'>buffer</a>           2343 src/data.c       struct buffer *buf = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/203.html#L2392'>buffer</a>           2392 src/data.c       (register Lisp_Object variable, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/203.html#L2410'>buffer</a>           2410 src/data.c     	return Flocal_variable_p (variable, buffer);</span>
<span class='curline'><a href='../S/203.html#L2964'>buffer</a>           2964 src/data.c     fixnum_to_string (EMACS_INT number, char *buffer, char *end)</span>
<span class='curline'><a href='../S/203.html#L2973'>buffer</a>           2973 src/data.c           eassume (p &gt; buffer &amp;&amp; p - 1 &lt; end);</span>
<span class='curline'><a href='../S/203.html#L2989'>buffer</a>           2989 src/data.c       char buffer[max (FLOAT_TO_STRING_BUFSIZE, INT_BUFSIZE_BOUND (EMACS_INT))];</span>
<span class='curline'><a href='../S/203.html#L2993'>buffer</a>           2993 src/data.c           char *end = buffer + sizeof buffer;</span>
<span class='curline'><a href='../S/203.html#L2994'>buffer</a>           2994 src/data.c           char *p = fixnum_to_string (XFIXNUM (number), buffer, end);</span>
<span class='curline'><a href='../S/203.html#L3002'>buffer</a>           3002 src/data.c         return make_unibyte_string (buffer,</span>
<span class='curline'><a href='../S/203.html#L3003'>buffer</a>           3003 src/data.c     				float_to_string (buffer, XFLOAT_DATA (number)));</span>
<span class='curline'><a href='../S/173.html#L827'>buffer</a>            827 src/dispextern.h   struct buffer *buffer;</span>
<span class='curline'><a href='../S/167.html#L1489'>buffer</a>           1489 src/dispnew.c    struct buffer *saved = current_buffer;</span>
<span class='curline'><a href='../S/167.html#L1490'>buffer</a>           1490 src/dispnew.c    struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/167.html#L1497'>buffer</a>           1497 src/dispnew.c    set_buffer_temp (buffer);</span>
<span class='curline'><a href='../S/76.html#L152'>buffer</a>            152 src/doprnt.c   doprnt_non_null_end (char *buffer, ptrdiff_t bufsize, char const *format,</span>
<span class='curline'><a href='../S/76.html#L160'>buffer</a>            160 src/doprnt.c     ptrdiff_t nbytes = doprnt (buffer, bufsize, fmt, NULL, ap);</span>
<span class='curline'><a href='../S/76.html#L186'>buffer</a>            186 src/doprnt.c   doprnt (char *buffer, ptrdiff_t bufsize, const char *format,</span>
<span class='curline'><a href='../S/76.html#L190'>buffer</a>            190 src/doprnt.c       return doprnt_non_null_end (buffer, bufsize, format, format_end, ap);</span>
<span class='curline'><a href='../S/76.html#L193'>buffer</a>            193 src/doprnt.c     char *bufptr = buffer;	/* Pointer into output buffer.  */</span>
<span class='curline'><a href='../S/76.html#L534'>buffer</a>            534 src/doprnt.c     return bufptr - buffer;</span>
<span class='curline'><a href='../S/86.html#L320'>buffer</a>            320 src/editfns.c        struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/86.html#L820'>buffer</a>            820 src/editfns.c    Lisp_Object buffer = Fmarker_buffer (marker);</span>
<span class='curline'><a href='../S/86.html#L823'>buffer</a>            823 src/editfns.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/86.html#L826'>buffer</a>            826 src/editfns.c    Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/86.html#L891'>buffer</a>            891 src/editfns.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/86.html#L893'>buffer</a>            893 src/editfns.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/86.html#L897'>buffer</a>            897 src/editfns.c        CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/86.html#L898'>buffer</a>            898 src/editfns.c        return make_fixnum (BUF_Z (XBUFFER (buffer))</span>
<span class='curline'><a href='../S/86.html#L899'>buffer</a>            899 src/editfns.c  			  - BUF_BEG (XBUFFER (buffer)));</span>
<span class='curline'><a href='../S/86.html#L1739'>buffer</a>           1739 src/editfns.c    (Lisp_Object buffer, Lisp_Object start, Lisp_Object end)</span>
<span class='curline'><a href='../S/86.html#L1742'>buffer</a>           1742 src/editfns.c    register struct buffer *bp, *obuf;</span>
<span class='curline'><a href='../S/86.html#L1745'>buffer</a>           1745 src/editfns.c    buf = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/86.html#L1747'>buffer</a>           1747 src/editfns.c      nsberror (buffer);</span>
<span class='curline'><a href='../S/86.html#L1785'>buffer</a>           1785 src/editfns.c    register struct buffer *bp1, *bp2;</span>
<span class='curline'><a href='../S/86.html#L1916'>buffer</a>           1916 src/editfns.c    struct buffer *buffer_a;                      \</span>
<span class='curline'><a href='../S/86.html#L1917'>buffer</a>           1917 src/editfns.c    struct buffer *buffer_b;                      \</span>
<span class='curline'><a href='../S/86.html#L1976'>buffer</a>           1976 src/editfns.c    struct buffer *a = current_buffer;</span>
<span class='curline'><a href='../S/86.html#L1980'>buffer</a>           1980 src/editfns.c    struct buffer *b = XBUFFER (source_buffer);</span>
<span class='curline'><a href='../S/86.html#L2041'>buffer</a>           2041 src/editfns.c    ptrdiff_t *buffer;</span>
<span class='curline'><a href='../S/86.html#L2043'>buffer</a>           2043 src/editfns.c    if (ckd_mul (&amp;bytes_needed, diags, 2 * sizeof *buffer)</span>
<span class='curline'><a href='../S/86.html#L2047'>buffer</a>           2047 src/editfns.c    buffer = SAFE_ALLOCA (bytes_needed);</span>
<span class='curline'><a href='../S/86.html#L2048'>buffer</a>           2048 src/editfns.c    unsigned char *deletions_insertions = memset (buffer + 2 * diags, 0,</span>
<span class='curline'><a href='../S/86.html#L2064'>buffer</a>           2064 src/editfns.c      .fdiag = buffer + size_b + 1,</span>
<span class='curline'><a href='../S/86.html#L2065'>buffer</a>           2065 src/editfns.c      .bdiag = buffer + diags + size_b + 1,</span>
<span class='curline'><a href='../S/86.html#L3052'>buffer</a>           3052 src/editfns.c    struct buffer *cur = NULL;</span>
<span class='curline'><a href='../S/86.html#L3053'>buffer</a>           3053 src/editfns.c    struct buffer *buf = (CONSP (data)</span>
<span class='curline'><a href='../S/86.html#L3054'>buffer</a>           3054 src/editfns.c  			? XMARKER (XCAR (data))-&gt;buffer</span>
<span class='curline'><a href='../S/86.html#L3071'>buffer</a>           3071 src/editfns.c        eassert (buf == end-&gt;buffer);</span>
<span class='curline'><a href='../S/211.html#L1128'>buffer</a>           1128 src/emacs.c    read_full (int fd, void *buffer, ptrdiff_t size)</span>
<span class='curline'><a href='../S/211.html#L1131'>buffer</a>           1131 src/emacs.c      eassert (buffer != NULL);</span>
<span class='curline'><a href='../S/211.html#L1147'>buffer</a>           1147 src/emacs.c      char *ptr = buffer;</span>
<span class='curline'><a href='../S/211.html#L1171'>buffer</a>           1171 src/emacs.c      void *buffer = NULL;</span>
<span class='curline'><a href='../S/211.html#L1208'>buffer</a>           1208 src/emacs.c      buffer = malloc (size + 1);</span>
<span class='curline'><a href='../S/211.html#L1209'>buffer</a>           1209 src/emacs.c      if (buffer == NULL)</span>
<span class='curline'><a href='../S/211.html#L1214'>buffer</a>           1214 src/emacs.c      ptrdiff_t read = read_full (fd, buffer, size + 1);</span>
<span class='curline'><a href='../S/211.html#L1232'>buffer</a>           1232 src/emacs.c      program.filter = buffer;</span>
<span class='curline'><a href='../S/211.html#L1254'>buffer</a>           1254 src/emacs.c      free (buffer);</span>
<span class='curline'><a href='../S/122.html#L2079'>buffer</a>           2079 src/eval.c       char *buffer = buf;</span>
<span class='curline'><a href='../S/122.html#L2083'>buffer</a>           2083 src/eval.c       used = evxprintf (&amp;buffer, &amp;size, buf, size_max, m, ap);</span>
<span class='curline'><a href='../S/122.html#L2084'>buffer</a>           2084 src/eval.c       string = make_string (buffer, used);</span>
<span class='curline'><a href='../S/122.html#L2085'>buffer</a>           2085 src/eval.c       if (buffer != buf)</span>
<span class='curline'><a href='../S/122.html#L2086'>buffer</a>           2086 src/eval.c         xfree (buffer);</span>
<span class='curline'><a href='../S/208.html#L3858'>buffer</a>           3858 src/fileio.c     Lisp_Object buffer = XCDR (tmp);</span>
<span class='curline'><a href='../S/208.html#L3860'>buffer</a>           3860 src/fileio.c     set_buffer_internal (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/208.html#L4018'>buffer</a>           4018 src/fileio.c   maybe_move_gap (struct buffer *b)</span>
<span class='curline'><a href='../S/208.html#L4022'>buffer</a>           4022 src/fileio.c         struct buffer *cb = current_buffer;</span>
<span class='curline'><a href='../S/208.html#L4313'>buffer</a>           4313 src/fileio.c   		  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/208.html#L4315'>buffer</a>           4315 src/fileio.c   		  struct buffer *buf;</span>
<span class='curline'><a href='../S/208.html#L5400'>buffer</a>           5400 src/fileio.c     struct buffer *given_buffer;</span>
<span class='curline'><a href='../S/208.html#L5762'>buffer</a>           5762 src/fileio.c         struct buffer *given_buffer = current_buffer;</span>
<span class='curline'><a href='../S/208.html#L5799'>buffer</a>           5799 src/fileio.c         struct buffer *given_buffer = current_buffer;</span>
<span class='curline'><a href='../S/208.html#L5988'>buffer</a>           5988 src/fileio.c     struct buffer *b = decode_buffer (buf);</span>
<span class='curline'><a href='../S/208.html#L6016'>buffer</a>           6016 src/fileio.c   buffer_visited_file_modtime (struct buffer *buf)</span>
<span class='curline'><a href='../S/208.html#L6193'>buffer</a>           6193 src/fileio.c     struct buffer *old = current_buffer, *b;</span>
<span class='curline'><a href='../S/338.html#L629'>buffer</a>            629 src/filelock.c   register struct buffer *b;</span>
<span class='curline'><a href='../S/338.html#L723'>buffer</a>            723 src/filelock.c unlock_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/338.html#L725'>buffer</a>            725 src/filelock.c   if (BUF_SAVE_MODIFF (buffer) &lt; BUF_MODIFF (buffer)</span>
<span class='curline'><a href='../S/338.html#L726'>buffer</a>            726 src/filelock.c       &amp;&amp; STRINGP (BVAR (buffer, file_truename)))</span>
<span class='curline'><a href='../S/338.html#L727'>buffer</a>            727 src/filelock.c     Funlock_file (BVAR (buffer, file_truename));</span>
<span class='curline'><a href='../S/119.html#L2845'>buffer</a>           2845 src/fns.c      	    return (XMARKER (o1)-&gt;buffer == XMARKER (o2)-&gt;buffer</span>
<span class='curline'><a href='../S/119.html#L2846'>buffer</a>           2846 src/fns.c      		    &amp;&amp; (XMARKER (o1)-&gt;buffer == 0</span>
<span class='curline'><a href='../S/119.html#L5156'>buffer</a>           5156 src/fns.c      	      = XMARKER (obj)-&gt;buffer ? XMARKER (obj)-&gt;bytepos : 0;</span>
<span class='curline'><a href='../S/119.html#L5158'>buffer</a>           5158 src/fns.c      	      = sxhash_combine ((intptr_t) XMARKER (obj)-&gt;buffer, bytepos);</span>
<span class='curline'><a href='../S/119.html#L5654'>buffer</a>           5654 src/fns.c            struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/119.html#L5659'>buffer</a>           5659 src/fns.c            struct buffer *bp = XBUFFER (object);</span>
<span class='curline'><a href='../S/119.html#L5923'>buffer</a>           5923 src/fns.c        Lisp_Object buffer;</span>
<span class='curline'><a href='../S/119.html#L5924'>buffer</a>           5924 src/fns.c        struct buffer *b;</span>
<span class='curline'><a href='../S/119.html#L5928'>buffer</a>           5928 src/fns.c          buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/119.html#L5930'>buffer</a>           5930 src/fns.c          buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/119.html#L5931'>buffer</a>           5931 src/fns.c        if (NILP (buffer))</span>
<span class='curline'><a href='../S/119.html#L5934'>buffer</a>           5934 src/fns.c        b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/119.html#L5963'>buffer</a>           5963 src/fns.c        Lisp_Object buffer;</span>
<span class='curline'><a href='../S/119.html#L5966'>buffer</a>           5966 src/fns.c        struct buffer *b;</span>
<span class='curline'><a href='../S/119.html#L5969'>buffer</a>           5969 src/fns.c          buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/119.html#L5971'>buffer</a>           5971 src/fns.c          buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/119.html#L5972'>buffer</a>           5972 src/fns.c        if (NILP (buffer))</span>
<span class='curline'><a href='../S/119.html#L5975'>buffer</a>           5975 src/fns.c        b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/119.html#L6171'>buffer</a>           6171 src/fns.c            if (XMARKER (position)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/140.html#L419'>buffer</a>            419 src/font.h       unsigned char *buffer;</span>
<span class='curline'><a href='../S/317.html#L3135'>buffer</a>           3135 src/frame.c    frames_discard_buffer (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/317.html#L3142'>buffer</a>           3142 src/frame.c    	(XFRAME (frame), Fdelq (buffer, XFRAME (frame)-&gt;buffer_list));</span>
<span class='curline'><a href='../S/317.html#L3144'>buffer</a>           3144 src/frame.c    	(XFRAME (frame), Fdelq (buffer, XFRAME (frame)-&gt;buried_buffer_list));</span>
<span class='curline'><a href='../S/324.html#L934'>buffer</a>            934 src/fringe.c     struct buffer *oldbuf = current_buffer;</span>
<span class='curline'><a href='../S/213.html#L1665'>buffer</a>           1665 src/ftfont.c     bitmap-&gt;buffer = ft_face-&gt;glyph-&gt;bitmap.buffer;</span>
<span class='curline'><a href='../S/47.html#L1429'>buffer</a>           1429 src/gtkutil.c        char buffer[sizeof format];</span>
<span class='curline'><a href='../S/47.html#L1430'>buffer</a>           1430 src/gtkutil.c        int n = snprintf(buffer, sizeof buffer, format,</span>
<span class='curline'><a href='../S/47.html#L1433'>buffer</a>           1433 src/gtkutil.c        eassert (n &lt; sizeof buffer);</span>
<span class='curline'><a href='../S/47.html#L1435'>buffer</a>           1435 src/gtkutil.c        gtk_css_provider_load_from_data (provider, buffer, -1, NULL);</span>
<span class='curline'><a href='../S/144.html#L612'>buffer</a>            612 src/haiku_select.cc   char buffer[INT_STRLEN_BOUND (team_id)</span>
<span class='curline'><a href='../S/144.html#L635'>buffer</a>            635 src/haiku_select.cc   sprintf (buffer, "%d.%jd", my_team_id (), id);</span>
<span class='curline'><a href='../S/144.html#L636'>buffer</a>            636 src/haiku_select.cc   notification.SetMessageID (BString (buffer));</span>
<span class='curline'><a href='../S/144.html#L657'>buffer</a>            657 src/haiku_select.cc   notification.AddOnClickArg (BString ("-Notification,") += buffer);</span>
<span class='curline'><a href='../S/235.html#L5581'>buffer</a>           5581 src/haiku_support.cc   char *buffer;</span>
<span class='curline'><a href='../S/235.html#L5594'>buffer</a>           5594 src/haiku_support.cc   buffer = new (std::nothrow) char[flat];</span>
<span class='curline'><a href='../S/235.html#L5595'>buffer</a>           5595 src/haiku_support.cc   if (!buffer)</span>
<span class='curline'><a href='../S/235.html#L5598'>buffer</a>           5598 src/haiku_support.cc   rc = msg-&gt;Flatten (buffer, flat);</span>
<span class='curline'><a href='../S/235.html#L5601'>buffer</a>           5601 src/haiku_support.cc       delete[] buffer;</span>
<span class='curline'><a href='../S/235.html#L5606'>buffer</a>           5606 src/haiku_support.cc 			   buffer, flat);</span>
<span class='curline'><a href='../S/235.html#L5607'>buffer</a>           5607 src/haiku_support.cc   delete[] buffer;</span>
<span class='curline'><a href='../S/283.html#L2401'>buffer</a>           2401 src/haikufns.c   struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/212.html#L563'>buffer</a>            563 src/haikumenu.c   struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/212.html#L564'>buffer</a>            564 src/haikumenu.c   Lisp_Object buffer;</span>
<span class='curline'><a href='../S/212.html#L617'>buffer</a>            617 src/haikumenu.c       buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/212.html#L630'>buffer</a>            630 src/haikumenu.c       set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/344.html#L4823'>buffer</a>           4823 src/image.c      char buffer[BUFSIZ];</span>
<span class='curline'><a href='../S/344.html#L4832'>buffer</a>           4832 src/image.c         LA1 = xbm_scan (&amp;s, end, buffer, &amp;value)</span>
<span class='curline'><a href='../S/344.html#L4844'>buffer</a>           4844 src/image.c         if (LA1 == XBM_TK_IDENT &amp;&amp; strcmp (buffer, (IDENT)) == 0)	\</span>
<span class='curline'><a href='../S/344.html#L4852'>buffer</a>           4852 src/image.c      LA1 = xbm_scan (&amp;s, end, buffer, &amp;value);</span>
<span class='curline'><a href='../S/344.html#L4863'>buffer</a>           4863 src/image.c    	  char *q = strrchr (buffer, '_');</span>
<span class='curline'><a href='../S/344.html#L4864'>buffer</a>           4864 src/image.c    	  q = q ? q + 1 : buffer;</span>
<span class='curline'><a href='../S/344.html#L4886'>buffer</a>           4886 src/image.c          if (strcmp (buffer, "unsigned") == 0)</span>
<span class='curline'><a href='../S/344.html#L4891'>buffer</a>           4891 src/image.c          else if (strcmp (buffer, "short") == 0)</span>
<span class='curline'><a href='../S/344.html#L4898'>buffer</a>           4898 src/image.c          else if (strcmp (buffer, "char") == 0)</span>
<span class='curline'><a href='../S/344.html#L5749'>buffer</a>           5749 src/image.c          Lisp_Object buffer = image_spec_value (img-&gt;spec, QCdata, NULL);</span>
<span class='curline'><a href='../S/344.html#L5750'>buffer</a>           5750 src/image.c          if (!STRINGP (buffer))</span>
<span class='curline'><a href='../S/344.html#L5752'>buffer</a>           5752 src/image.c    	  image_error ("Invalid image data `%s'", buffer);</span>
<span class='curline'><a href='../S/344.html#L5762'>buffer</a>           5762 src/image.c          rc = XpmCreateImageFromBuffer (&amp;hdc, SSDATA (buffer),</span>
<span class='curline'><a href='../S/344.html#L5766'>buffer</a>           5766 src/image.c          rc = XpmCreateImageFromBuffer (FRAME_X_DISPLAY (f), SSDATA (buffer),</span>
<span class='curline'><a href='../S/344.html#L6108'>buffer</a>           6108 src/image.c      char buffer[BUFSIZ];</span>
<span class='curline'><a href='../S/344.html#L6156'>buffer</a>           6156 src/image.c      memcpy (buffer, beg, len);</span>
<span class='curline'><a href='../S/344.html#L6157'>buffer</a>           6157 src/image.c      buffer[len] = '\0';</span>
<span class='curline'><a href='../S/344.html#L6158'>buffer</a>           6158 src/image.c      if (sscanf (buffer, "%d %d %d %d", &amp;width, &amp;height,</span>
<span class='curline'><a href='../S/344.html#L6210'>buffer</a>           6210 src/image.c          memcpy (buffer, beg + chars_per_pixel, len - chars_per_pixel);</span>
<span class='curline'><a href='../S/344.html#L6211'>buffer</a>           6211 src/image.c          buffer[len - chars_per_pixel] = '\0';</span>
<span class='curline'><a href='../S/344.html#L6213'>buffer</a>           6213 src/image.c          str = strtok (buffer, " \t");</span>
<span class='curline'><a href='../S/344.html#L8664'>buffer</a>           8664 src/image.c      JOCTET *buffer;</span>
<span class='curline'><a href='../S/344.html#L8686'>buffer</a>           8686 src/image.c          bytes = fread (src-&gt;buffer, 1, JPEG_STDIO_BUFFER_SIZE, src-&gt;file);</span>
<span class='curline'><a href='../S/344.html#L8693'>buffer</a>           8693 src/image.c              src-&gt;buffer[0] = (JOCTET) 0xFF;</span>
<span class='curline'><a href='../S/344.html#L8694'>buffer</a>           8694 src/image.c              src-&gt;buffer[1] = (JOCTET) JPEG_EOI;</span>
<span class='curline'><a href='../S/344.html#L8697'>buffer</a>           8697 src/image.c          src-&gt;mgr.next_input_byte = src-&gt;buffer;</span>
<span class='curline'><a href='../S/344.html#L8748'>buffer</a>           8748 src/image.c          src-&gt;buffer = cinfo-&gt;mem-&gt;alloc_small ((j_common_ptr) cinfo,</span>
<span class='curline'><a href='../S/344.html#L8773'>buffer</a>           8773 src/image.c      JSAMPARRAY buffer;</span>
<span class='curline'><a href='../S/344.html#L8919'>buffer</a>           8919 src/image.c      buffer = mgr-&gt;cinfo.mem-&gt;alloc_sarray ((j_common_ptr) &amp;mgr-&gt;cinfo,</span>
<span class='curline'><a href='../S/344.html#L8923'>buffer</a>           8923 src/image.c          jpeg_read_scanlines (&amp;mgr-&gt;cinfo, buffer, 1);</span>
<span class='curline'><a href='../S/344.html#L8925'>buffer</a>           8925 src/image.c    	PUT_PIXEL (ximg, x, y, colors[buffer[0][x]]);</span>
<span class='curline'><a href='../S/344.html#L12338'>buffer</a>           12338 src/image.c      char buffer[sizeof " " + 2 * INT_STRLEN_BOUND (intmax_t)];</span>
<span class='curline'><a href='../S/344.html#L12390'>buffer</a>           12390 src/image.c        = make_formatted_string (buffer, "%"PRIuMAX" %"PRIuMAX,</span>
<span class='curline'><a href='../S/344.html#L12396'>buffer</a>           12396 src/image.c        = make_formatted_string (buffer, "%"PRIuMAX" %"PRIuMAX,</span>
<span class='curline'><a href='../S/319.html#L127'>buffer</a>            127 src/indent.c   recompute_width_table (struct buffer *buf, struct Lisp_Char_Table *disptab)</span>
<span class='curline'><a href='../S/319.html#L147'>buffer</a>            147 src/indent.c     struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/319.html#L220'>buffer</a>            220 src/indent.c     Lisp_Object buffer, tmp;</span>
<span class='curline'><a href='../S/319.html#L225'>buffer</a>            225 src/indent.c     XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/319.html#L233'>buffer</a>            233 src/indent.c     proplimit = Fnext_property_change (position, buffer, Qt);</span>
<span class='curline'><a href='../S/319.html#L250'>buffer</a>            250 src/indent.c   					  buffer, proplimit);</span>
<span class='curline'><a href='../S/319.html#L267'>buffer</a>            267 src/indent.c   			      &amp;&amp; EQ (XWINDOW (window)-&gt;contents, buffer))</span>
<span class='curline'><a href='../S/319.html#L268'>buffer</a>            268 src/indent.c   			     ? window : buffer);</span>
<span class='curline'><a href='../S/319.html#L1245'>buffer</a>           1245 src/indent.c     struct buffer *cache_buffer = current_buffer;</span>
<span class='curline'><a href='../S/319.html#L2047'>buffer</a>           2047 src/indent.c         struct buffer *old_buf = current_buffer;</span>
<span class='curline'><a href='../S/319.html#L2062'>buffer</a>           2062 src/indent.c   	       &amp;&amp; XBUFFER (w-&gt;contents) == XMARKER (w-&gt;start)-&gt;buffer))</span>
<span class='curline'><a href='../S/233.html#L57'>buffer</a>             57 src/indent.h   void recompute_width_table (struct buffer *buf,</span>
<span class='curline'><a href='../S/318.html#L324'>buffer</a>            324 src/inotify.c    char *buffer = SAFE_ALLOCA (to_read);</span>
<span class='curline'><a href='../S/318.html#L325'>buffer</a>            325 src/inotify.c    ssize_t n = read (fd, buffer, to_read);</span>
<span class='curline'><a href='../S/318.html#L335'>buffer</a>            335 src/inotify.c        struct inotify_event *ev = (struct inotify_event *) &amp;buffer[i];</span>
<span class='curline'><a href='../S/270.html#L40'>buffer</a>             40 src/insdel.c   static void insert_from_buffer_1 (struct buffer *, ptrdiff_t, ptrdiff_t, bool);</span>
<span class='curline'><a href='../S/270.html#L73'>buffer</a>             73 src/insdel.c         if (tail-&gt;buffer-&gt;text != current_buffer-&gt;text)</span>
<span class='curline'><a href='../S/270.html#L600'>buffer</a>            600 src/insdel.c   make_gap_1 (struct buffer *b, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/270.html#L602'>buffer</a>            602 src/insdel.c     struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/270.html#L1177'>buffer</a>           1177 src/insdel.c   insert_from_buffer (struct buffer *buf,</span>
<span class='curline'><a href='../S/270.html#L1202'>buffer</a>           1202 src/insdel.c   insert_from_buffer_1 (struct buffer *buf,</span>
<span class='curline'><a href='../S/270.html#L2008'>buffer</a>           2008 src/insdel.c     struct buffer *base_buffer;</span>
<span class='curline'><a href='../S/270.html#L2059'>buffer</a>           2059 src/insdel.c         &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer</span>
<span class='curline'><a href='../S/270.html#L2086'>buffer</a>           2086 src/insdel.c   invalidate_buffer_caches (struct buffer *buf, ptrdiff_t start, ptrdiff_t end)</span>
<span class='curline'><a href='../S/270.html#L2113'>buffer</a>           2113 src/insdel.c   	      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/248.html#L468'>buffer</a>            468 src/intervals.c buffer_balance_intervals (struct buffer *b)</span>
<span class='curline'><a href='../S/248.html#L1309'>buffer</a>           1309 src/intervals.c adjust_intervals_for_deletion (struct buffer *buffer,</span>
<span class='curline'><a href='../S/248.html#L1313'>buffer</a>           1313 src/intervals.c   INTERVAL tree = buffer_intervals (buffer);</span>
<span class='curline'><a href='../S/248.html#L1328'>buffer</a>           1328 src/intervals.c       set_buffer_intervals (buffer, NULL);</span>
<span class='curline'><a href='../S/248.html#L1345'>buffer</a>           1345 src/intervals.c       tree = buffer_intervals (buffer);</span>
<span class='curline'><a href='../S/248.html#L1348'>buffer</a>           1348 src/intervals.c 	  set_buffer_intervals (buffer, NULL);</span>
<span class='curline'><a href='../S/248.html#L1360'>buffer</a>           1360 src/intervals.c offset_intervals (struct buffer *buffer, ptrdiff_t start, ptrdiff_t length)</span>
<span class='curline'><a href='../S/248.html#L1362'>buffer</a>           1362 src/intervals.c   if (!buffer_intervals (buffer) || length == 0)</span>
<span class='curline'><a href='../S/248.html#L1366'>buffer</a>           1366 src/intervals.c     adjust_intervals_for_insertion (buffer_intervals (buffer),</span>
<span class='curline'><a href='../S/248.html#L1369'>buffer</a>           1369 src/intervals.c     adjust_intervals_for_deletion (buffer, start, -length);</span>
<span class='curline'><a href='../S/248.html#L1569'>buffer</a>           1569 src/intervals.c 			     ptrdiff_t length, struct buffer *buffer,</span>
<span class='curline'><a href='../S/248.html#L1572'>buffer</a>           1572 src/intervals.c   INTERVAL tree = buffer_intervals (buffer);</span>
<span class='curline'><a href='../S/248.html#L1585'>buffer</a>           1585 src/intervals.c 	  XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/248.html#L1592'>buffer</a>           1592 src/intervals.c       buffer_balance_intervals (buffer);</span>
<span class='curline'><a href='../S/248.html#L1598'>buffer</a>           1598 src/intervals.c   if ((BUF_Z (buffer) - BUF_BEG (buffer)) == length)</span>
<span class='curline'><a href='../S/248.html#L1604'>buffer</a>           1604 src/intervals.c       XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/248.html#L1605'>buffer</a>           1605 src/intervals.c       set_buffer_intervals (buffer, reproduce_tree_obj (source, buf));</span>
<span class='curline'><a href='../S/248.html#L1606'>buffer</a>           1606 src/intervals.c       buffer_intervals (buffer)-&gt;position = BUF_BEG (buffer);</span>
<span class='curline'><a href='../S/248.html#L1607'>buffer</a>           1607 src/intervals.c       eassert (buffer_intervals (buffer)-&gt;up_obj == 1);</span>
<span class='curline'><a href='../S/248.html#L1616'>buffer</a>           1616 src/intervals.c 	XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/248.html#L1699'>buffer</a>           1699 src/intervals.c   buffer_balance_intervals (buffer);</span>
<span class='curline'><a href='../S/248.html#L1753'>buffer</a>           1753 src/intervals.c temp_set_point_both (struct buffer *buffer,</span>
<span class='curline'><a href='../S/248.html#L1757'>buffer</a>           1757 src/intervals.c   eassert (BUF_ZV (buffer) != BUF_ZV_BYTE (buffer) || charpos == bytepos);</span>
<span class='curline'><a href='../S/248.html#L1760'>buffer</a>           1760 src/intervals.c   eassert (charpos &lt;= BUF_ZV (buffer) || BUF_BEGV (buffer) &lt;= charpos);</span>
<span class='curline'><a href='../S/248.html#L1762'>buffer</a>           1762 src/intervals.c   SET_BUF_PT_BOTH (buffer, charpos, bytepos);</span>
<span class='curline'><a href='../S/248.html#L1768'>buffer</a>           1768 src/intervals.c temp_set_point (struct buffer *buffer, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/248.html#L1770'>buffer</a>           1770 src/intervals.c   temp_set_point_both (buffer, charpos,</span>
<span class='curline'><a href='../S/248.html#L1771'>buffer</a>           1771 src/intervals.c 		       buf_charpos_to_bytepos (buffer, charpos));</span>
<span class='curline'><a href='../S/248.html#L1793'>buffer</a>           1793 src/intervals.c   if (XMARKER (marker)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/248.html#L2178'>buffer</a>           2178 src/intervals.c get_local_map (ptrdiff_t position, struct buffer *buffer, Lisp_Object type)</span>
<span class='curline'><a href='../S/248.html#L2184'>buffer</a>           2184 src/intervals.c   position = clip_to_bounds (BUF_BEGV (buffer), position, BUF_ZV (buffer));</span>
<span class='curline'><a href='../S/248.html#L2188'>buffer</a>           2188 src/intervals.c   old_begv = BUF_BEGV (buffer);</span>
<span class='curline'><a href='../S/248.html#L2189'>buffer</a>           2189 src/intervals.c   old_zv = BUF_ZV (buffer);</span>
<span class='curline'><a href='../S/248.html#L2190'>buffer</a>           2190 src/intervals.c   old_begv_byte = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/248.html#L2191'>buffer</a>           2191 src/intervals.c   old_zv_byte = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/248.html#L2194'>buffer</a>           2194 src/intervals.c   SET_BUF_BEGV_BOTH (buffer, BUF_BEG (buffer), BUF_BEG_BYTE (buffer));</span>
<span class='curline'><a href='../S/248.html#L2195'>buffer</a>           2195 src/intervals.c   SET_BUF_ZV_BOTH (buffer, BUF_Z (buffer), BUF_Z_BYTE (buffer));</span>
<span class='curline'><a href='../S/248.html#L2198'>buffer</a>           2198 src/intervals.c   XSETBUFFER (lispy_buffer, buffer);</span>
<span class='curline'><a href='../S/248.html#L2209'>buffer</a>           2209 src/intervals.c   SET_BUF_BEGV_BOTH (buffer, old_begv, old_begv_byte);</span>
<span class='curline'><a href='../S/248.html#L2210'>buffer</a>           2210 src/intervals.c   SET_BUF_ZV_BOTH (buffer, old_zv, old_zv_byte);</span>
<span class='curline'><a href='../S/248.html#L2221'>buffer</a>           2221 src/intervals.c     return BVAR (buffer, keymap);</span>
<span class='curline'><a href='../S/248.html#L2269'>buffer</a>           2269 src/intervals.c copy_intervals_to_string (Lisp_Object string, struct buffer *buffer,</span>
<span class='curline'><a href='../S/248.html#L2272'>buffer</a>           2272 src/intervals.c   INTERVAL interval_copy = copy_intervals (buffer_intervals (buffer),</span>
<span class='curline'><a href='../S/343.html#L259'>buffer</a>            259 src/intervals.h extern void offset_intervals (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/343.html#L261'>buffer</a>            261 src/intervals.h                                          struct buffer *, bool);</span>
<span class='curline'><a href='../S/343.html#L262'>buffer</a>            262 src/intervals.h extern void verify_interval_modification (struct buffer *,</span>
<span class='curline'><a href='../S/343.html#L265'>buffer</a>            265 src/intervals.h extern void copy_intervals_to_string (Lisp_Object, struct buffer *,</span>
<span class='curline'><a href='../S/343.html#L274'>buffer</a>            274 src/intervals.h extern Lisp_Object get_local_map (ptrdiff_t, struct buffer *, Lisp_Object);</span>
<span class='curline'><a href='../S/343.html#L301'>buffer</a>            301 src/intervals.h                                      Lisp_Object buffer);</span>
<span class='curline'><a href='../S/328.html#L644'>buffer</a>            644 src/json.c       const char *buffer;</span>
<span class='curline'><a href='../S/328.html#L665'>buffer</a>            665 src/json.c     	  buffer_and_size-&gt;buffer, len);</span>
<span class='curline'><a href='../S/328.html#L701'>buffer</a>            701 src/json.c     json_insert_callback (const char *buffer, size_t size, void *data)</span>
<span class='curline'><a href='../S/328.html#L705'>buffer</a>            705 src/json.c         = {.buffer = buffer, .size = size, .inserted_bytes = d-&gt;inserted_bytes};</span>
<span class='curline'><a href='../S/328.html#L1009'>buffer</a>           1009 src/json.c     json_read_buffer_callback (void *buffer, size_t buflen, void *data)</span>
<span class='curline'><a href='../S/328.html#L1020'>buffer</a>           1020 src/json.c       memcpy (buffer, BYTE_POS_ADDR (point), count);</span>
<span class='curline'><a href='../S/55.html#L237'>buffer</a>            237 src/keyboard.c struct buffer *buffer_before_last_command_or_undo;</span>
<span class='curline'><a href='../S/55.html#L335'>buffer</a>            335 src/keyboard.c static void recursive_edit_unwind (Lisp_Object buffer);</span>
<span class='curline'><a href='../S/55.html#L504'>buffer</a>            504 src/keyboard.c   char *buffer = initbuf;</span>
<span class='curline'><a href='../S/55.html#L505'>buffer</a>            505 src/keyboard.c   char *ptr = buffer;</span>
<span class='curline'><a href='../S/55.html#L523'>buffer</a>            523 src/keyboard.c       if (size - (ptr - buffer) &lt; nbytes)</span>
<span class='curline'><a href='../S/55.html#L525'>buffer</a>            525 src/keyboard.c 	  ptrdiff_t offset = ptr - buffer;</span>
<span class='curline'><a href='../S/55.html#L527'>buffer</a>            527 src/keyboard.c 	  buffer = SAFE_ALLOCA (size);</span>
<span class='curline'><a href='../S/55.html#L528'>buffer</a>            528 src/keyboard.c 	  ptr = buffer + offset;</span>
<span class='curline'><a href='../S/55.html#L535'>buffer</a>            535 src/keyboard.c   Lisp_Object new_string = make_string (buffer, ptr - buffer);</span>
<span class='curline'><a href='../S/55.html#L800'>buffer</a>            800 src/keyboard.c   Lisp_Object buffer;</span>
<span class='curline'><a href='../S/55.html#L809'>buffer</a>            809 src/keyboard.c     buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/55.html#L811'>buffer</a>            811 src/keyboard.c     buffer = Qnil;</span>
<span class='curline'><a href='../S/55.html#L818'>buffer</a>            818 src/keyboard.c   record_unwind_protect (recursive_edit_unwind, buffer);</span>
<span class='curline'><a href='../S/55.html#L832'>buffer</a>            832 src/keyboard.c recursive_edit_unwind (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/55.html#L834'>buffer</a>            834 src/keyboard.c   if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/55.html#L835'>buffer</a>            835 src/keyboard.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/55.html#L1304'>buffer</a>           1304 src/keyboard.c   struct buffer *prev_buffer = NULL;</span>
<span class='curline'><a href='../S/55.html#L1442'>buffer</a>           1442 src/keyboard.c 	  struct buffer *b;</span>
<span class='curline'><a href='../S/55.html#L1609'>buffer</a>           1609 src/keyboard.c 		  &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer</span>
<span class='curline'><a href='../S/55.html#L3053'>buffer</a>           3053 src/keyboard.c       struct buffer *prev_buffer = current_buffer;</span>
<span class='curline'><a href='../S/55.html#L10359'>buffer</a>           10359 src/keyboard.c   struct buffer *starting_buffer;</span>
<span class='curline'><a href='../S/275.html#L268'>buffer</a>            268 src/keyboard.h extern struct buffer *buffer_before_last_command_or_undo;</span>
<span class='curline'><a href='../S/275.html#L270'>buffer</a>            270 src/keyboard.h extern struct buffer *prev_buffer;</span>
<span class='curline'><a href='../S/305.html#L2346'>buffer</a>           2346 src/keymap.c   	  char *buffer = SAFE_ALLOCA (len + 3);</span>
<span class='curline'><a href='../S/305.html#L2347'>buffer</a>           2347 src/keymap.c   	  memcpy (buffer, sym, i);</span>
<span class='curline'><a href='../S/305.html#L2348'>buffer</a>           2348 src/keymap.c   	  buffer[i] = '&lt;';</span>
<span class='curline'><a href='../S/305.html#L2349'>buffer</a>           2349 src/keymap.c   	  memcpy (buffer + i + 1, sym + i, len - i);</span>
<span class='curline'><a href='../S/305.html#L2350'>buffer</a>           2350 src/keymap.c   	  buffer [len + 1] = '&gt;';</span>
<span class='curline'><a href='../S/305.html#L2351'>buffer</a>           2351 src/keymap.c   	  buffer [len + 2] = '\0';</span>
<span class='curline'><a href='../S/305.html#L2352'>buffer</a>           2352 src/keymap.c   	  Lisp_Object result = build_string (buffer);</span>
<span class='curline'><a href='../S/305.html#L2836'>buffer</a>           2836 src/keymap.c     (Lisp_Object buffer, Lisp_Object prefix, Lisp_Object menus)</span>
<span class='curline'><a href='../S/305.html#L2846'>buffer</a>           2846 src/keymap.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/305.html#L2890'>buffer</a>           2890 src/keymap.c   	     msg, nomenu, Qt, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/305.html#L2904'>buffer</a>           2904 src/keymap.c   	     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/305.html#L2917'>buffer</a>           2917 src/keymap.c   	     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/305.html#L2927'>buffer</a>           2927 src/keymap.c         Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/305.html#L2932'>buffer</a>           2932 src/keymap.c         start1 = get_local_map (BUF_PT (XBUFFER (buffer)),</span>
<span class='curline'><a href='../S/305.html#L2933'>buffer</a>           2933 src/keymap.c   			      XBUFFER (buffer), Qkeymap);</span>
<span class='curline'><a href='../S/305.html#L2940'>buffer</a>           2940 src/keymap.c   		 msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/305.html#L2973'>buffer</a>           2973 src/keymap.c   		 msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/305.html#L2978'>buffer</a>           2978 src/keymap.c         start1 = get_local_map (BUF_PT (XBUFFER (buffer)),</span>
<span class='curline'><a href='../S/305.html#L2979'>buffer</a>           2979 src/keymap.c   			      XBUFFER (buffer), Qlocal_map);</span>
<span class='curline'><a href='../S/305.html#L2982'>buffer</a>           2982 src/keymap.c   	  if (EQ (start1, BVAR (XBUFFER (buffer), keymap)))</span>
<span class='curline'><a href='../S/305.html#L2987'>buffer</a>           2987 src/keymap.c   		       XBUFFER (buffer)-&gt;major_mode_);</span>
<span class='curline'><a href='../S/305.html#L2991'>buffer</a>           2991 src/keymap.c   		     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/305.html#L2999'>buffer</a>           2999 src/keymap.c   		     msg, nomenu, Qnil, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/305.html#L3010'>buffer</a>           3010 src/keymap.c   	 msg, nomenu, Qnil, Qt, Qnil, buffer);</span>
<span class='curline'><a href='../S/305.html#L3019'>buffer</a>           3019 src/keymap.c   	     msg, nomenu, Qt, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/305.html#L3029'>buffer</a>           3029 src/keymap.c   	     msg, nomenu, Qt, Qnil, Qnil, buffer);</span>
<span class='curline'><a href='../S/305.html#L3319'>buffer</a>           3319 src/keymap.c   	      char *buffer =</span>
<span class='curline'><a href='../S/305.html#L3321'>buffer</a>           3321 src/keymap.c   	      esprintf (buffer, fmt, SDATA (SYMBOL_NAME (shadowed_by)));</span>
<span class='curline'><a href='../S/305.html#L3322'>buffer</a>           3322 src/keymap.c   	      insert_string (buffer);</span>
<span class='curline'><a href='../S/131.html#L647'>buffer</a>            647 src/lisp.h     extern char *fixnum_to_string (EMACS_INT number, char *buffer, char *end);</span>
<span class='curline'><a href='../S/131.html#L2571'>buffer</a>           2571 src/lisp.h       struct buffer *buffer;</span>
<span class='curline'><a href='../S/131.html#L2611'>buffer</a>           2611 src/lisp.h         struct buffer *buffer;        /* eassert (live buffer || NULL). */</span>
<span class='curline'><a href='../S/131.html#L4096'>buffer</a>           4096 src/lisp.h     extern void make_gap_1 (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/131.html#L4111'>buffer</a>           4111 src/lisp.h     extern void insert_from_buffer (struct buffer *, ptrdiff_t, ptrdiff_t, bool);</span>
<span class='curline'><a href='../S/131.html#L4129'>buffer</a>           4129 src/lisp.h     extern void invalidate_buffer_caches (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/131.html#L4438'>buffer</a>           4438 src/lisp.h     extern struct buffer *allocate_buffer (void) ATTRIBUTE_RETURNS_NONNULL;</span>
<span class='curline'><a href='../S/131.html#L4724'>buffer</a>           4724 src/lisp.h     extern void clear_charpos_cache (struct buffer *);</span>
<span class='curline'><a href='../S/131.html#L4725'>buffer</a>           4725 src/lisp.h     extern ptrdiff_t buf_charpos_to_bytepos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/131.html#L4726'>buffer</a>           4726 src/lisp.h     extern ptrdiff_t buf_bytepos_to_charpos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/131.html#L4733'>buffer</a>           4733 src/lisp.h     extern Lisp_Object build_marker (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/131.html#L4760'>buffer</a>           4760 src/lisp.h     extern Lisp_Object buffer_visited_file_modtime (struct buffer *);</span>
<span class='curline'><a href='../S/131.html#L5024'>buffer</a>           5024 src/lisp.h     extern void truncate_undo_list (struct buffer *);</span>
<span class='curline'><a href='../S/131.html#L5118'>buffer</a>           5118 src/lisp.h     extern void unlock_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/131.html#L5254'>buffer</a>           5254 src/lisp.h     				 struct buffer *);</span>
<span class='curline'><a href='../S/174.html#L304'>buffer</a>            304 src/lread.c          register struct buffer *inbuffer = XBUFFER (readcharfun);</span>
<span class='curline'><a href='../S/174.html#L337'>buffer</a>            337 src/lread.c          register struct buffer *inbuffer = XMARKER (readcharfun)-&gt;buffer;</span>
<span class='curline'><a href='../S/174.html#L518'>buffer</a>            518 src/lread.c          struct buffer *b = XBUFFER (readcharfun);</span>
<span class='curline'><a href='../S/174.html#L531'>buffer</a>            531 src/lread.c          struct buffer *b = XMARKER (readcharfun)-&gt;buffer;</span>
<span class='curline'><a href='../S/174.html#L2433'>buffer</a>           2433 src/lread.c      struct buffer *b = 0;</span>
<span class='curline'><a href='../S/174.html#L2461'>buffer</a>           2461 src/lread.c        b = XMARKER (readcharfun)-&gt;buffer;</span>
<span class='curline'><a href='../S/174.html#L2569'>buffer</a>           2569 src/lread.c    		  struct buffer *buf = XBUFFER (readcharfun);</span>
<span class='curline'><a href='../S/174.html#L2642'>buffer</a>           2642 src/lread.c      (Lisp_Object buffer, Lisp_Object printflag, Lisp_Object filename, Lisp_Object unibyte, Lisp_Object do_allow_print)</span>
<span class='curline'><a href='../S/174.html#L2647'>buffer</a>           2647 src/lread.c      if (NILP (buffer))</span>
<span class='curline'><a href='../S/174.html#L2650'>buffer</a>           2650 src/lread.c        buf = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/174.html#L5662'>buffer</a>           5662 src/lread.c          char *buffer = SAFE_ALLOCA (sizeof format - 3 * (sizeof "%s" - 1)</span>
<span class='curline'><a href='../S/174.html#L5664'>buffer</a>           5664 src/lread.c          ptrdiff_t message_len = esprintf (buffer, format, use, SSDATA (dirname),</span>
<span class='curline'><a href='../S/174.html#L5666'>buffer</a>           5666 src/lread.c          message_dolog (buffer, message_len, 0, STRING_MULTIBYTE (dirname));</span>
<span class='curline'><a href='../S/255.html#L33'>buffer</a>             33 src/marker.c   static struct buffer *cached_buffer;</span>
<span class='curline'><a href='../S/255.html#L42'>buffer</a>             42 src/marker.c   extern int count_markers (struct buffer *) EXTERNALLY_VISIBLE;</span>
<span class='curline'><a href='../S/255.html#L46'>buffer</a>             46 src/marker.c   byte_char_debug_check (struct buffer *b, ptrdiff_t charpos, ptrdiff_t bytepos)</span>
<span class='curline'><a href='../S/255.html#L74'>buffer</a>             74 src/marker.c   clear_charpos_cache (struct buffer *b)</span>
<span class='curline'><a href='../S/255.html#L162'>buffer</a>            162 src/marker.c   buf_charpos_to_bytepos (struct buffer *b, ptrdiff_t charpos)</span>
<span class='curline'><a href='../S/255.html#L319'>buffer</a>            319 src/marker.c   buf_bytepos_to_charpos (struct buffer *b, ptrdiff_t bytepos)</span>
<span class='curline'><a href='../S/255.html#L437'>buffer</a>            437 src/marker.c     if (XMARKER (marker)-&gt;buffer)</span>
<span class='curline'><a href='../S/255.html#L439'>buffer</a>            439 src/marker.c         XSETBUFFER (buf, XMARKER (marker)-&gt;buffer);</span>
<span class='curline'><a href='../S/255.html#L455'>buffer</a>            455 src/marker.c     if (XMARKER (marker)-&gt;buffer)</span>
<span class='curline'><a href='../S/255.html#L464'>buffer</a>            464 src/marker.c   attach_marker (struct Lisp_Marker *m, struct buffer *b,</span>
<span class='curline'><a href='../S/255.html#L477'>buffer</a>            477 src/marker.c     if (m-&gt;buffer != b)</span>
<span class='curline'><a href='../S/255.html#L480'>buffer</a>            480 src/marker.c         m-&gt;buffer = b;</span>
<span class='curline'><a href='../S/255.html#L490'>buffer</a>            490 src/marker.c   static struct buffer *</span>
<span class='curline'><a href='../S/255.html#L491'>buffer</a>            491 src/marker.c   live_buffer (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/255.html#L493'>buffer</a>            493 src/marker.c     struct buffer *b = decode_buffer (buffer);</span>
<span class='curline'><a href='../S/255.html#L502'>buffer</a>            502 src/marker.c   		     Lisp_Object buffer, bool restricted)</span>
<span class='curline'><a href='../S/255.html#L505'>buffer</a>            505 src/marker.c     struct buffer *b = live_buffer (buffer);</span>
<span class='curline'><a href='../S/255.html#L513'>buffer</a>            513 src/marker.c         || (MARKERP (position) &amp;&amp; !XMARKER (position)-&gt;buffer)</span>
<span class='curline'><a href='../S/255.html#L519'>buffer</a>            519 src/marker.c     else if (MARKERP (position) &amp;&amp; b == XMARKER (position)-&gt;buffer</span>
<span class='curline'><a href='../S/255.html#L520'>buffer</a>            520 src/marker.c   	   &amp;&amp; b == m-&gt;buffer)</span>
<span class='curline'><a href='../S/255.html#L561'>buffer</a>            561 src/marker.c   	  || !(MARKERP (position) &amp;&amp; XMARKER (position)-&gt;buffer == b))</span>
<span class='curline'><a href='../S/255.html#L587'>buffer</a>            587 src/marker.c     if (m-&gt;buffer</span>
<span class='curline'><a href='../S/255.html#L588'>buffer</a>            588 src/marker.c         &amp;&amp; EQ (marker, BVAR (m-&gt;buffer, mark))</span>
<span class='curline'><a href='../S/255.html#L589'>buffer</a>            589 src/marker.c         &amp;&amp; !NILP (BVAR (m-&gt;buffer, mark_active))</span>
<span class='curline'><a href='../S/255.html#L590'>buffer</a>            590 src/marker.c         &amp;&amp; buffer_window_count (m-&gt;buffer))</span>
<span class='curline'><a href='../S/255.html#L591'>buffer</a>            591 src/marker.c       bset_redisplay (m-&gt;buffer);</span>
<span class='curline'><a href='../S/255.html#L603'>buffer</a>            603 src/marker.c     (Lisp_Object marker, Lisp_Object position, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/255.html#L605'>buffer</a>            605 src/marker.c     return set_marker_internal (marker, position, buffer, false);</span>
<span class='curline'><a href='../S/255.html#L612'>buffer</a>            612 src/marker.c   		       Lisp_Object buffer)</span>
<span class='curline'><a href='../S/255.html#L614'>buffer</a>            614 src/marker.c     return set_marker_internal (marker, position, buffer, true);</span>
<span class='curline'><a href='../S/255.html#L621'>buffer</a>            621 src/marker.c   set_marker_both (Lisp_Object marker, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/255.html#L625'>buffer</a>            625 src/marker.c     register struct buffer *b = live_buffer (buffer);</span>
<span class='curline'><a href='../S/255.html#L640'>buffer</a>            640 src/marker.c   set_marker_restricted_both (Lisp_Object marker, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/255.html#L644'>buffer</a>            644 src/marker.c     register struct buffer *b = live_buffer (buffer);</span>
<span class='curline'><a href='../S/255.html#L677'>buffer</a>            677 src/marker.c     register struct buffer *b = marker-&gt;buffer;</span>
<span class='curline'><a href='../S/255.html#L686'>buffer</a>            686 src/marker.c         marker-&gt;buffer = NULL;</span>
<span class='curline'><a href='../S/255.html#L698'>buffer</a>            698 src/marker.c   		if (tail-&gt;next &amp;&amp; b-&gt;text != tail-&gt;next-&gt;buffer-&gt;text)</span>
<span class='curline'><a href='../S/255.html#L718'>buffer</a>            718 src/marker.c     register struct buffer *buf = m-&gt;buffer;</span>
<span class='curline'><a href='../S/255.html#L734'>buffer</a>            734 src/marker.c     register struct buffer *buf = m-&gt;buffer;</span>
<span class='curline'><a href='../S/255.html#L793'>buffer</a>            793 src/marker.c   count_markers (struct buffer *buf)</span>
<span class='curline'><a href='../S/68.html#L388'>buffer</a>            388 src/minibuf.c  live_minibuffer_p (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/68.html#L393'>buffer</a>            393 src/minibuf.c    if (EQ (buffer, Fcar (Vminibuffer_list)))</span>
<span class='curline'><a href='../S/68.html#L398'>buffer</a>            398 src/minibuf.c      if (EQ (Fcar (tem), buffer))</span>
<span class='curline'><a href='../S/68.html#L409'>buffer</a>            409 src/minibuf.c    (Lisp_Object buffer, Lisp_Object live)</span>
<span class='curline'><a href='../S/68.html#L411'>buffer</a>            411 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/68.html#L412'>buffer</a>            412 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/68.html#L413'>buffer</a>            413 src/minibuf.c    else if (STRINGP (buffer))</span>
<span class='curline'><a href='../S/68.html#L414'>buffer</a>            414 src/minibuf.c      buffer = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/68.html#L416'>buffer</a>            416 src/minibuf.c      CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/68.html#L419'>buffer</a>            419 src/minibuf.c            ? !NILP (Fmemq (buffer, Vminibuffer_list))</span>
<span class='curline'><a href='../S/68.html#L420'>buffer</a>            420 src/minibuf.c            : live_minibuffer_p (buffer))</span>
<span class='curline'><a href='../S/68.html#L428'>buffer</a>            428 src/minibuf.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/68.html#L430'>buffer</a>            430 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/68.html#L431'>buffer</a>            431 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/68.html#L432'>buffer</a>            432 src/minibuf.c    return BASE_EQ (buffer, (Fcar (Fnthcdr (make_fixnum (minibuf_level),</span>
<span class='curline'><a href='../S/68.html#L442'>buffer</a>            442 src/minibuf.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/68.html#L445'>buffer</a>            445 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/68.html#L446'>buffer</a>            446 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/68.html#L447'>buffer</a>            447 src/minibuf.c    depth = this_minibuffer_depth (buffer);</span>
<span class='curline'><a href='../S/68.html#L457'>buffer</a>            457 src/minibuf.c  this_minibuffer_depth (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/68.html#L462'>buffer</a>            462 src/minibuf.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/68.html#L463'>buffer</a>            463 src/minibuf.c      buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/68.html#L467'>buffer</a>            467 src/minibuf.c      if (EQ (Fcar (bufs), buffer))</span>
<span class='curline'><a href='../S/330.html#L1329'>buffer</a>           1329 src/msdos.c          struct buffer *b = XBUFFER (sw-&gt;contents);</span>
<span class='curline'><a href='../S/330.html#L3906'>buffer</a>           3906 src/msdos.c    readlinkat (int fd, char const *name, char *buffer, size_t buffer_size)</span>
<span class='curline'><a href='../S/330.html#L3923'>buffer</a>           3923 src/msdos.c      return readlink (name, buffer, buffer_size);</span>
<span class='curline'><a href='../S/330.html#L3972'>buffer</a>           3972 src/msdos.c                  char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/330.html#L3976'>buffer</a>           3976 src/msdos.c      if (!buffer)</span>
<span class='curline'><a href='../S/330.html#L3983'>buffer</a>           3983 src/msdos.c          buffer = NULL;</span>
<span class='curline'><a href='../S/330.html#L3987'>buffer</a>           3987 src/msdos.c          ssize_t len = preadlinkat (fd, filename, buffer, buffer_size);</span>
<span class='curline'><a href='../S/330.html#L3990'>buffer</a>           3990 src/msdos.c    	buffer = NULL;</span>
<span class='curline'><a href='../S/330.html#L3992'>buffer</a>           3992 src/msdos.c    	buffer[len + 1] = '\0';</span>
<span class='curline'><a href='../S/330.html#L3994'>buffer</a>           3994 src/msdos.c      return buffer;</span>
<span class='curline'><a href='../S/331.html#L2123'>buffer</a>           2123 src/pdumper.c    if (marker-&gt;buffer)</span>
<span class='curline'><a href='../S/331.html#L2125'>buffer</a>           2125 src/pdumper.c        dump_field_lv_rawptr (ctx, out, marker, &amp;marker-&gt;buffer,</span>
<span class='curline'><a href='../S/331.html#L2748'>buffer</a>           2748 src/pdumper.c  dump_buffer (struct dump_context *ctx, const struct buffer *in_buffer)</span>
<span class='curline'><a href='../S/331.html#L2753'>buffer</a>           2753 src/pdumper.c    struct buffer munged_buffer = *in_buffer;</span>
<span class='curline'><a href='../S/331.html#L2754'>buffer</a>           2754 src/pdumper.c    struct buffer *buffer = &amp;munged_buffer;</span>
<span class='curline'><a href='../S/331.html#L2757'>buffer</a>           2757 src/pdumper.c    if (buffer-&gt;base_buffer == NULL)</span>
<span class='curline'><a href='../S/331.html#L2758'>buffer</a>           2758 src/pdumper.c      buffer-&gt;window_count = 0;</span>
<span class='curline'><a href='../S/331.html#L2760'>buffer</a>           2760 src/pdumper.c      eassert (buffer-&gt;window_count == -1);</span>
<span class='curline'><a href='../S/331.html#L2761'>buffer</a>           2761 src/pdumper.c    buffer-&gt;local_minor_modes_ = Qnil;</span>
<span class='curline'><a href='../S/331.html#L2762'>buffer</a>           2762 src/pdumper.c    buffer-&gt;last_selected_window_ = Qnil;</span>
<span class='curline'><a href='../S/331.html#L2763'>buffer</a>           2763 src/pdumper.c    buffer-&gt;display_count_ = make_fixnum (0);</span>
<span class='curline'><a href='../S/331.html#L2764'>buffer</a>           2764 src/pdumper.c    buffer-&gt;clip_changed = 0;</span>
<span class='curline'><a href='../S/331.html#L2765'>buffer</a>           2765 src/pdumper.c    buffer-&gt;last_window_start = -1;</span>
<span class='curline'><a href='../S/331.html#L2766'>buffer</a>           2766 src/pdumper.c    buffer-&gt;point_before_scroll_ = Qnil;</span>
<span class='curline'><a href='../S/331.html#L2769'>buffer</a>           2769 src/pdumper.c    if (buffer-&gt;base_buffer)</span>
<span class='curline'><a href='../S/331.html#L2771'>buffer</a>           2771 src/pdumper.c        eassert (buffer-&gt;base_buffer-&gt;base_buffer == NULL);</span>
<span class='curline'><a href='../S/331.html#L2774'>buffer</a>           2774 src/pdumper.c  	 make_lisp_ptr (buffer-&gt;base_buffer, Lisp_Vectorlike));</span>
<span class='curline'><a href='../S/331.html#L2777'>buffer</a>           2777 src/pdumper.c    eassert ((base_offset == 0 &amp;&amp; buffer-&gt;text == &amp;in_buffer-&gt;own_text)</span>
<span class='curline'><a href='../S/331.html#L2778'>buffer</a>           2778 src/pdumper.c  	   || (base_offset &gt; 0 &amp;&amp; buffer-&gt;text != &amp;in_buffer-&gt;own_text));</span>
<span class='curline'><a href='../S/331.html#L2780'>buffer</a>           2780 src/pdumper.c    START_DUMP_PVEC (ctx, &amp;buffer-&gt;header, struct buffer, out);</span>
<span class='curline'><a href='../S/331.html#L2781'>buffer</a>           2781 src/pdumper.c    dump_pseudovector_lisp_fields (ctx, &amp;out-&gt;header, &amp;buffer-&gt;header);</span>
<span class='curline'><a href='../S/331.html#L2785'>buffer</a>           2785 src/pdumper.c    if (buffer-&gt;base_buffer == NULL)</span>
<span class='curline'><a href='../S/331.html#L2789'>buffer</a>           2789 src/pdumper.c        if (BUFFER_LIVE_P (buffer))</span>
<span class='curline'><a href='../S/331.html#L2791'>buffer</a>           2791 src/pdumper.c            dump_field_fixup_later (ctx, out, buffer, &amp;buffer-&gt;own_text.beg);</span>
<span class='curline'><a href='../S/331.html#L2797'>buffer</a>           2797 src/pdumper.c          eassert (buffer-&gt;own_text.beg == NULL);</span>
<span class='curline'><a href='../S/331.html#L2799'>buffer</a>           2799 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.gpt);</span>
<span class='curline'><a href='../S/331.html#L2800'>buffer</a>           2800 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.z);</span>
<span class='curline'><a href='../S/331.html#L2801'>buffer</a>           2801 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.gpt_byte);</span>
<span class='curline'><a href='../S/331.html#L2802'>buffer</a>           2802 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.z_byte);</span>
<span class='curline'><a href='../S/331.html#L2803'>buffer</a>           2803 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.gap_size);</span>
<span class='curline'><a href='../S/331.html#L2804'>buffer</a>           2804 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.modiff);</span>
<span class='curline'><a href='../S/331.html#L2805'>buffer</a>           2805 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.chars_modiff);</span>
<span class='curline'><a href='../S/331.html#L2806'>buffer</a>           2806 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.save_modiff);</span>
<span class='curline'><a href='../S/331.html#L2807'>buffer</a>           2807 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.overlay_modiff);</span>
<span class='curline'><a href='../S/331.html#L2808'>buffer</a>           2808 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.compact);</span>
<span class='curline'><a href='../S/331.html#L2809'>buffer</a>           2809 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.beg_unchanged);</span>
<span class='curline'><a href='../S/331.html#L2810'>buffer</a>           2810 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.end_unchanged);</span>
<span class='curline'><a href='../S/331.html#L2811'>buffer</a>           2811 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.unchanged_modified);</span>
<span class='curline'><a href='../S/331.html#L2812'>buffer</a>           2812 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.overlay_unchanged_modified);</span>
<span class='curline'><a href='../S/331.html#L2813'>buffer</a>           2813 src/pdumper.c        if (buffer-&gt;own_text.intervals)</span>
<span class='curline'><a href='../S/331.html#L2814'>buffer</a>           2814 src/pdumper.c          dump_field_fixup_later (ctx, out, buffer, &amp;buffer-&gt;own_text.intervals);</span>
<span class='curline'><a href='../S/331.html#L2815'>buffer</a>           2815 src/pdumper.c        dump_field_lv_rawptr (ctx, out, buffer, &amp;buffer-&gt;own_text.markers,</span>
<span class='curline'><a href='../S/331.html#L2817'>buffer</a>           2817 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.inhibit_shrinking);</span>
<span class='curline'><a href='../S/331.html#L2818'>buffer</a>           2818 src/pdumper.c        DUMP_FIELD_COPY (out, buffer, own_text.redisplay);</span>
<span class='curline'><a href='../S/331.html#L2824'>buffer</a>           2824 src/pdumper.c       ctx-&gt;obj_offset + dump_offsetof (struct buffer, text),</span>
<span class='curline'><a href='../S/331.html#L2825'>buffer</a>           2825 src/pdumper.c       base_offset + dump_offsetof (struct buffer, own_text));</span>
<span class='curline'><a href='../S/331.html#L2827'>buffer</a>           2827 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, pt);</span>
<span class='curline'><a href='../S/331.html#L2828'>buffer</a>           2828 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, pt_byte);</span>
<span class='curline'><a href='../S/331.html#L2829'>buffer</a>           2829 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, begv);</span>
<span class='curline'><a href='../S/331.html#L2830'>buffer</a>           2830 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, begv_byte);</span>
<span class='curline'><a href='../S/331.html#L2831'>buffer</a>           2831 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, zv);</span>
<span class='curline'><a href='../S/331.html#L2832'>buffer</a>           2832 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, zv_byte);</span>
<span class='curline'><a href='../S/331.html#L2834'>buffer</a>           2834 src/pdumper.c    if (buffer-&gt;base_buffer)</span>
<span class='curline'><a href='../S/331.html#L2837'>buffer</a>           2837 src/pdumper.c        dump_field_ptr_to_dump_offset (ctx, out, buffer, &amp;buffer-&gt;base_buffer,</span>
<span class='curline'><a href='../S/331.html#L2841'>buffer</a>           2841 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, indirections);</span>
<span class='curline'><a href='../S/331.html#L2842'>buffer</a>           2842 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, window_count);</span>
<span class='curline'><a href='../S/331.html#L2845'>buffer</a>           2845 src/pdumper.c            &amp;buffer-&gt;local_flags,</span>
<span class='curline'><a href='../S/331.html#L2847'>buffer</a>           2847 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, modtime);</span>
<span class='curline'><a href='../S/331.html#L2848'>buffer</a>           2848 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, modtime_size);</span>
<span class='curline'><a href='../S/331.html#L2849'>buffer</a>           2849 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, auto_save_modified);</span>
<span class='curline'><a href='../S/331.html#L2850'>buffer</a>           2850 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, display_error_modiff);</span>
<span class='curline'><a href='../S/331.html#L2851'>buffer</a>           2851 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, auto_save_failure_time);</span>
<span class='curline'><a href='../S/331.html#L2852'>buffer</a>           2852 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, last_window_start);</span>
<span class='curline'><a href='../S/331.html#L2859'>buffer</a>           2859 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, prevent_redisplay_optimizations_p);</span>
<span class='curline'><a href='../S/331.html#L2860'>buffer</a>           2860 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, clip_changed);</span>
<span class='curline'><a href='../S/331.html#L2861'>buffer</a>           2861 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, inhibit_buffer_hooks);</span>
<span class='curline'><a href='../S/331.html#L2862'>buffer</a>           2862 src/pdumper.c    DUMP_FIELD_COPY (out, buffer, long_line_optimizations_p);</span>
<span class='curline'><a href='../S/331.html#L2864'>buffer</a>           2864 src/pdumper.c    if (!itree_empty_p (buffer-&gt;overlays))</span>
<span class='curline'><a href='../S/331.html#L2870'>buffer</a>           2870 src/pdumper.c    dump_field_lv (ctx, out, buffer, &amp;buffer-&gt;undo_list_,</span>
<span class='curline'><a href='../S/331.html#L2873'>buffer</a>           2873 src/pdumper.c    if (!buffer-&gt;base_buffer &amp;&amp; buffer-&gt;own_text.intervals)</span>
<span class='curline'><a href='../S/331.html#L2876'>buffer</a>           2876 src/pdumper.c         offset + dump_offsetof (struct buffer, own_text.intervals),</span>
<span class='curline'><a href='../S/331.html#L2877'>buffer</a>           2877 src/pdumper.c         dump_interval_tree (ctx, buffer-&gt;own_text.intervals, 0));</span>
<span class='curline'><a href='../S/331.html#L3427'>buffer</a>           3427 src/pdumper.c    struct buffer *b = XBUFFER (data);</span>
<span class='curline'><a href='../S/331.html#L3441'>buffer</a>           3441 src/pdumper.c       buffer_offset + dump_offsetof (struct buffer, own_text.beg),</span>
<span class='curline'><a href='../S/130.html#L3121'>buffer</a>           3121 src/pgtkfns.c    struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/352.html#L259'>buffer</a>            259 src/pgtkmenu.c       struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/352.html#L260'>buffer</a>            260 src/pgtkmenu.c       Lisp_Object buffer;</span>
<span class='curline'><a href='../S/352.html#L272'>buffer</a>            272 src/pgtkmenu.c       buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/352.html#L285'>buffer</a>            285 src/pgtkmenu.c       set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/138.html#L71'>buffer</a>             71 src/print.c      char *buffer;			/* Allocated buffer.  */</span>
<span class='curline'><a href='../S/138.html#L103'>buffer</a>            103 src/print.c      xfree (print_buffer.buffer);</span>
<span class='curline'><a href='../S/138.html#L104'>buffer</a>            104 src/print.c      print_buffer.buffer = NULL;</span>
<span class='curline'><a href='../S/138.html#L112'>buffer</a>            112 src/print.c      memcpy (print_buffer.buffer, SDATA (saved_text), SCHARS (saved_text));</span>
<span class='curline'><a href='../S/138.html#L154'>buffer</a>            154 src/print.c          if (! XMARKER (printcharfun)-&gt;buffer)</span>
<span class='curline'><a href='../S/138.html#L156'>buffer</a>            156 src/print.c          if (XMARKER (printcharfun)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/138.html#L157'>buffer</a>            157 src/print.c    	set_buffer_internal (XMARKER (printcharfun)-&gt;buffer);</span>
<span class='curline'><a href='../S/138.html#L177'>buffer</a>            177 src/print.c          if (print_buffer.buffer != NULL)</span>
<span class='curline'><a href='../S/138.html#L179'>buffer</a>            179 src/print.c    	  Lisp_Object string = make_string_from_bytes (print_buffer.buffer,</span>
<span class='curline'><a href='../S/138.html#L187'>buffer</a>            187 src/print.c    	  print_buffer.buffer = xmalloc (new_size);</span>
<span class='curline'><a href='../S/138.html#L210'>buffer</a>            210 src/print.c    	  copy_text ((unsigned char *) print_buffer.buffer, temp,</span>
<span class='curline'><a href='../S/138.html#L217'>buffer</a>            217 src/print.c    	insert_1_both (print_buffer.buffer, print_buffer.pos,</span>
<span class='curline'><a href='../S/138.html#L320'>buffer</a>            320 src/print.c    	    print_buffer.buffer = xpalloc (print_buffer.buffer,</span>
<span class='curline'><a href='../S/138.html#L323'>buffer</a>            323 src/print.c    	  memcpy (print_buffer.buffer + print_buffer.pos_byte, str, len);</span>
<span class='curline'><a href='../S/138.html#L386'>buffer</a>            386 src/print.c    	print_buffer.buffer = xpalloc (print_buffer.buffer,</span>
<span class='curline'><a href='../S/138.html#L388'>buffer</a>            388 src/print.c          memcpy (print_buffer.buffer + print_buffer.pos_byte, ptr, size_byte);</span>
<span class='curline'><a href='../S/138.html#L513'>buffer</a>            513 src/print.c    	  char *buffer = SAFE_ALLOCA (nbytes);</span>
<span class='curline'><a href='../S/138.html#L514'>buffer</a>            514 src/print.c    	  memcpy (buffer, SDATA (string), nbytes);</span>
<span class='curline'><a href='../S/138.html#L516'>buffer</a>            516 src/print.c    	  strout (buffer, chars, nbytes, printcharfun);</span>
<span class='curline'><a href='../S/138.html#L587'>buffer</a>            587 src/print.c      register struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/138.html#L817'>buffer</a>            817 src/print.c      struct buffer *previous = current_buffer;</span>
<span class='curline'><a href='../S/138.html#L1026'>buffer</a>           1026 src/print.c      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/138.html#L1712'>buffer</a>           1712 src/print.c          if (! XMARKER (obj)-&gt;buffer)</span>
<span class='curline'><a href='../S/138.html#L1718'>buffer</a>           1718 src/print.c    	  print_string (BVAR (XMARKER (obj)-&gt;buffer, name), printcharfun);</span>
<span class='curline'><a href='../S/138.html#L1810'>buffer</a>           1810 src/print.c    	if (NILP (XXWIDGET (obj)-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L349'>buffer</a>            349 src/process.c    p-&gt;buffer = val;</span>
<span class='curline'><a href='../S/57.html#L1281'>buffer</a>           1281 src/process.c    Lisp_Object buffer = p-&gt;buffer;</span>
<span class='curline'><a href='../S/57.html#L1282'>buffer</a>           1282 src/process.c    if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/57.html#L1283'>buffer</a>           1283 src/process.c      set_marker_both (p-&gt;mark, buffer,</span>
<span class='curline'><a href='../S/57.html#L1284'>buffer</a>           1284 src/process.c  		     BUF_ZV (XBUFFER (buffer)),</span>
<span class='curline'><a href='../S/57.html#L1285'>buffer</a>           1285 src/process.c  		     BUF_ZV_BYTE (XBUFFER (buffer)));</span>
<span class='curline'><a href='../S/57.html#L1292'>buffer</a>           1292 src/process.c    (register Lisp_Object process, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/57.html#L1297'>buffer</a>           1297 src/process.c    if (!NILP (buffer))</span>
<span class='curline'><a href='../S/57.html#L1298'>buffer</a>           1298 src/process.c      CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/57.html#L1300'>buffer</a>           1300 src/process.c    if (!EQ (p-&gt;buffer, buffer))</span>
<span class='curline'><a href='../S/57.html#L1302'>buffer</a>           1302 src/process.c        pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/57.html#L1306'>buffer</a>           1306 src/process.c      pset_childp (p, plist_put (p-&gt;childp, QCbuffer, buffer));</span>
<span class='curline'><a href='../S/57.html#L1308'>buffer</a>           1308 src/process.c    return buffer;</span>
<span class='curline'><a href='../S/57.html#L1318'>buffer</a>           1318 src/process.c    return XPROCESS (process)-&gt;buffer;</span>
<span class='curline'><a href='../S/57.html#L1816'>buffer</a>           1816 src/process.c    Lisp_Object buffer, command, program, proc, contact, current_dir, tem;</span>
<span class='curline'><a href='../S/57.html#L1835'>buffer</a>           1835 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/57.html#L1836'>buffer</a>           1836 src/process.c    if (!NILP (buffer))</span>
<span class='curline'><a href='../S/57.html#L1837'>buffer</a>           1837 src/process.c      buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/57.html#L1884'>buffer</a>           1884 src/process.c    pset_buffer (XPROCESS (proc), buffer);</span>
<span class='curline'><a href='../S/57.html#L1953'>buffer</a>           1953 src/process.c  	args2[i++] = buffer;</span>
<span class='curline'><a href='../S/57.html#L1983'>buffer</a>           1983 src/process.c  	    args2[i++] = buffer;</span>
<span class='curline'><a href='../S/57.html#L2008'>buffer</a>           2008 src/process.c      = !(NILP (buffer) || !inherit_process_coding_system);</span>
<span class='curline'><a href='../S/57.html#L2422'>buffer</a>           2422 src/process.c    Lisp_Object buffer;</span>
<span class='curline'><a href='../S/57.html#L2462'>buffer</a>           2462 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/57.html#L2463'>buffer</a>           2463 src/process.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/57.html#L2464'>buffer</a>           2464 src/process.c      buffer = name;</span>
<span class='curline'><a href='../S/57.html#L2465'>buffer</a>           2465 src/process.c    buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/57.html#L2466'>buffer</a>           2466 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/57.html#L2507'>buffer</a>           2507 src/process.c      else if ((!NILP (buffer) &amp;&amp; NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/57.html#L2508'>buffer</a>           2508 src/process.c  	     || (NILP (buffer) &amp;&amp; NILP (BVAR (&amp;buffer_defaults, enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/57.html#L3159'>buffer</a>           3159 src/process.c    Lisp_Object name, buffer;</span>
<span class='curline'><a href='../S/57.html#L3197'>buffer</a>           3197 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/57.html#L3198'>buffer</a>           3198 src/process.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/57.html#L3199'>buffer</a>           3199 src/process.c      buffer = name;</span>
<span class='curline'><a href='../S/57.html#L3200'>buffer</a>           3200 src/process.c    buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/57.html#L3201'>buffer</a>           3201 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/57.html#L3232'>buffer</a>           3232 src/process.c    else if ((!NILP (buffer) &amp;&amp; NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/57.html#L3233'>buffer</a>           3233 src/process.c  	   || (NILP (buffer) &amp;&amp; NILP (BVAR (&amp;buffer_defaults, enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/57.html#L3246'>buffer</a>           3246 src/process.c    else if ((!NILP (buffer) &amp;&amp; NILP (BVAR (XBUFFER (buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/57.html#L3247'>buffer</a>           3247 src/process.c  	   || (NILP (buffer) &amp;&amp; NILP (BVAR (&amp;buffer_defaults, enable_multibyte_characters))))</span>
<span class='curline'><a href='../S/57.html#L3256'>buffer</a>           3256 src/process.c      = !(!NILP (tem) || NILP (buffer) || !inherit_process_coding_system);</span>
<span class='curline'><a href='../S/57.html#L3288'>buffer</a>           3288 src/process.c    else if ((!NILP (p-&gt;buffer)</span>
<span class='curline'><a href='../S/57.html#L3289'>buffer</a>           3289 src/process.c  	    &amp;&amp; NILP (BVAR (XBUFFER (p-&gt;buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/57.html#L3290'>buffer</a>           3290 src/process.c  	   || (NILP (p-&gt;buffer)</span>
<span class='curline'><a href='../S/57.html#L3303'>buffer</a>           3303 src/process.c  				Qopen_network_stream, name, p-&gt;buffer,</span>
<span class='curline'><a href='../S/57.html#L3332'>buffer</a>           3332 src/process.c  				    Qopen_network_stream, name, p-&gt;buffer,</span>
<span class='curline'><a href='../S/57.html#L3349'>buffer</a>           3349 src/process.c      = !(!NILP (tem) || NILP (p-&gt;buffer) || !inherit_process_coding_system);</span>
<span class='curline'><a href='../S/57.html#L3951'>buffer</a>           3951 src/process.c    Lisp_Object buffer, host, service, address;</span>
<span class='curline'><a href='../S/57.html#L3989'>buffer</a>           3989 src/process.c    buffer = plist_get (contact, QCbuffer);</span>
<span class='curline'><a href='../S/57.html#L4227'>buffer</a>           4227 src/process.c    if (!NILP (buffer))</span>
<span class='curline'><a href='../S/57.html#L4228'>buffer</a>           4228 src/process.c      buffer = Fget_buffer_create (buffer, Qnil);</span>
<span class='curline'><a href='../S/57.html#L4240'>buffer</a>           4240 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/57.html#L4921'>buffer</a>           4921 src/process.c    Lisp_Object buffer;</span>
<span class='curline'><a href='../S/57.html#L5013'>buffer</a>           5013 src/process.c      buffer = Qnil;</span>
<span class='curline'><a href='../S/57.html#L5016'>buffer</a>           5016 src/process.c        buffer = ps-&gt;buffer;</span>
<span class='curline'><a href='../S/57.html#L5017'>buffer</a>           5017 src/process.c        if (!NILP (buffer))</span>
<span class='curline'><a href='../S/57.html#L5018'>buffer</a>           5018 src/process.c  	buffer = Fbuffer_name (buffer);</span>
<span class='curline'><a href='../S/57.html#L5020'>buffer</a>           5020 src/process.c  	buffer = ps-&gt;name;</span>
<span class='curline'><a href='../S/57.html#L5021'>buffer</a>           5021 src/process.c        if (!NILP (buffer))</span>
<span class='curline'><a href='../S/57.html#L5023'>buffer</a>           5023 src/process.c  	  args[1] = buffer;</span>
<span class='curline'><a href='../S/57.html#L5024'>buffer</a>           5024 src/process.c  	  buffer = Fget_buffer_create (Fformat (nargs, args), Qnil);</span>
<span class='curline'><a href='../S/57.html#L5061'>buffer</a>           5061 src/process.c    pset_buffer (p, buffer);</span>
<span class='curline'><a href='../S/57.html#L5095'>buffer</a>           5095 src/process.c      = (NILP (buffer) ? 0 : ps-&gt;inherit_coding_system_flag);</span>
<span class='curline'><a href='../S/57.html#L6348'>buffer</a>           6348 src/process.c    if (!NILP (p-&gt;buffer) &amp;&amp; BUFFER_LIVE_P (XBUFFER (p-&gt;buffer)))</span>
<span class='curline'><a href='../S/57.html#L6354'>buffer</a>           6354 src/process.c        struct buffer *b;</span>
<span class='curline'><a href='../S/57.html#L6356'>buffer</a>           6356 src/process.c        Fset_buffer (p-&gt;buffer);</span>
<span class='curline'><a href='../S/57.html#L6367'>buffer</a>           6367 src/process.c        if (XMARKER (p-&gt;mark)-&gt;buffer)</span>
<span class='curline'><a href='../S/57.html#L6393'>buffer</a>           6393 src/process.c        if (BUFFERP (p-&gt;buffer)</span>
<span class='curline'><a href='../S/57.html#L6394'>buffer</a>           6394 src/process.c  	  &amp;&amp; (b = XBUFFER (p-&gt;buffer), b != current_buffer))</span>
<span class='curline'><a href='../S/57.html#L6395'>buffer</a>           6395 src/process.c  	set_marker_both (p-&gt;mark, p-&gt;buffer, BUF_PT (b), BUF_PT_BYTE (b));</span>
<span class='curline'><a href='../S/57.html#L6397'>buffer</a>           6397 src/process.c  	set_marker_both (p-&gt;mark, p-&gt;buffer, PT, PT_BYTE);</span>
<span class='curline'><a href='../S/57.html#L6584'>buffer</a>           6584 src/process.c  	  struct buffer *cur = current_buffer;</span>
<span class='curline'><a href='../S/57.html#L7703'>buffer</a>           7703 src/process.c  	  if (BUFFERP (p-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L7705'>buffer</a>           7705 src/process.c  	    bset_update_mode_line (XBUFFER (p-&gt;buffer));</span>
<span class='curline'><a href='../S/57.html#L7718'>buffer</a>           7718 src/process.c    Lisp_Object buffer, symbol;</span>
<span class='curline'><a href='../S/57.html#L7722'>buffer</a>           7722 src/process.c    buffer = p-&gt;buffer;</span>
<span class='curline'><a href='../S/57.html#L7727'>buffer</a>           7727 src/process.c    if (!EQ (symbol, Qrun) &amp;&amp; !NILP (buffer))</span>
<span class='curline'><a href='../S/57.html#L7730'>buffer</a>           7730 src/process.c        struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/57.html#L7736'>buffer</a>           7736 src/process.c        if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/57.html#L7738'>buffer</a>           7738 src/process.c        Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/57.html#L7749'>buffer</a>           7749 src/process.c        if (XMARKER (p-&gt;mark)-&gt;buffer)</span>
<span class='curline'><a href='../S/57.html#L7765'>buffer</a>           7765 src/process.c        set_marker_both (p-&gt;mark, p-&gt;buffer, PT, PT_BYTE);</span>
<span class='curline'><a href='../S/57.html#L8161'>buffer</a>           8161 src/process.c        &amp;&amp; BUFFERP (p-&gt;buffer))</span>
<span class='curline'><a href='../S/57.html#L8163'>buffer</a>           8163 src/process.c        if (NILP (BVAR (XBUFFER (p-&gt;buffer), enable_multibyte_characters)))</span>
<span class='curline'><a href='../S/57.html#L8181'>buffer</a>           8181 src/process.c    (register Lisp_Object buffer)</span>
<span class='curline'><a href='../S/57.html#L8186'>buffer</a>           8186 src/process.c    if (NILP (buffer)) return Qnil;</span>
<span class='curline'><a href='../S/57.html#L8187'>buffer</a>           8187 src/process.c    buf = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/57.html#L8191'>buffer</a>           8191 src/process.c      if (EQ (XPROCESS (proc)-&gt;buffer, buf))</span>
<span class='curline'><a href='../S/57.html#L8220'>buffer</a>           8220 src/process.c  kill_buffer_processes (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/57.html#L8226'>buffer</a>           8226 src/process.c      if (NILP (buffer) || EQ (XPROCESS (proc)-&gt;buffer, buffer))</span>
<span class='curline'><a href='../S/272.html#L68'>buffer</a>             68 src/process.h      Lisp_Object buffer;</span>
<span class='curline'><a href='../S/71.html#L747'>buffer</a>            747 src/regex-emacs.c   re_char *buffer = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/71.html#L749'>buffer</a>            749 src/regex-emacs.c   print_partial_compiled_pattern (buffer, buffer + bufp-&gt;used);</span>
<span class='curline'><a href='../S/71.html#L1045'>buffer</a>           1045 src/regex-emacs.c       eassert (FAILURE_PAT (failure) &gt;= bufp-&gt;buffer			\</span>
<span class='curline'><a href='../S/71.html#L1046'>buffer</a>           1046 src/regex-emacs.c 	       &amp;&amp; FAILURE_PAT (failure) &lt;= bufp-&gt;buffer + bufp-&gt;used);	\</span>
<span class='curline'><a href='../S/71.html#L1193'>buffer</a>           1193 src/regex-emacs.c     if (bufp-&gt;buffer + bufp-&gt;allocated - b &lt; (n))			\</span>
<span class='curline'><a href='../S/71.html#L1194'>buffer</a>           1194 src/regex-emacs.c       EXTEND_BUFFER ((n) - (bufp-&gt;buffer + bufp-&gt;allocated - b))</span>
<span class='curline'><a href='../S/71.html#L1243'>buffer</a>           1243 src/regex-emacs.c     unsigned char *old_buffer = bufp-&gt;buffer;				\</span>
<span class='curline'><a href='../S/71.html#L1253'>buffer</a>           1253 src/regex-emacs.c     bufp-&gt;buffer = xpalloc (bufp-&gt;buffer, &amp;bufp-&gt;allocated,		\</span>
<span class='curline'><a href='../S/71.html#L1255'>buffer</a>           1255 src/regex-emacs.c     unsigned char *new_buffer = bufp-&gt;buffer;				\</span>
<span class='curline'><a href='../S/71.html#L1793'>buffer</a>           1793 src/regex-emacs.c       bufp-&gt;buffer = xrealloc (bufp-&gt;buffer, INIT_BUF_SIZE);</span>
<span class='curline'><a href='../S/71.html#L1797'>buffer</a>           1797 src/regex-emacs.c   begalt = b = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/71.html#L2251'>buffer</a>           2251 src/regex-emacs.c 		COMPILE_STACK_TOP.begalt_offset = begalt - bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/71.html#L2253'>buffer</a>           2253 src/regex-emacs.c 		  = fixup_alt_jump ? fixup_alt_jump - bufp-&gt;buffer + 1 : 0;</span>
<span class='curline'><a href='../S/71.html#L2254'>buffer</a>           2254 src/regex-emacs.c 		COMPILE_STACK_TOP.laststart_offset = b - bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/71.html#L2294'>buffer</a>           2294 src/regex-emacs.c 		begalt = bufp-&gt;buffer + COMPILE_STACK_TOP.begalt_offset;</span>
<span class='curline'><a href='../S/71.html#L2297'>buffer</a>           2297 src/regex-emacs.c 		    ? bufp-&gt;buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1</span>
<span class='curline'><a href='../S/71.html#L2299'>buffer</a>           2299 src/regex-emacs.c 		laststart = bufp-&gt;buffer + COMPILE_STACK_TOP.laststart_offset;</span>
<span class='curline'><a href='../S/71.html#L2666'>buffer</a>           2666 src/regex-emacs.c   bufp-&gt;used = b - bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/71.html#L3127'>buffer</a>           3127 src/regex-emacs.c   eassert (fastmap &amp;&amp; bufp-&gt;buffer);</span>
<span class='curline'><a href='../S/71.html#L3134'>buffer</a>           3134 src/regex-emacs.c   analysis = analyze_first (bufp-&gt;buffer, bufp-&gt;buffer + bufp-&gt;used,</span>
<span class='curline'><a href='../S/71.html#L3240'>buffer</a>           3240 src/regex-emacs.c   if (bufp-&gt;used &gt; 0 &amp;&amp; (re_opcode_t) bufp-&gt;buffer[0] == begbuf &amp;&amp; range &gt; 0)</span>
<span class='curline'><a href='../S/71.html#L3250'>buffer</a>           3250 src/regex-emacs.c   if (bufp-&gt;used &gt; 0 &amp;&amp; (re_opcode_t) bufp-&gt;buffer[0] == at_dot &amp;&amp; range &gt; 0)</span>
<span class='curline'><a href='../S/71.html#L3262'>buffer</a>           3262 src/regex-emacs.c   anchored_start = (bufp-&gt;buffer[0] == begline);</span>
<span class='curline'><a href='../S/71.html#L3653'>buffer</a>           3653 src/regex-emacs.c   unsigned char *pend = bufp-&gt;buffer + bufp-&gt;used;</span>
<span class='curline'><a href='../S/71.html#L3656'>buffer</a>           3656 src/regex-emacs.c   eassert (p1 &gt;= bufp-&gt;buffer &amp;&amp; p1 &lt; pend</span>
<span class='curline'><a href='../S/71.html#L3657'>buffer</a>           3657 src/regex-emacs.c 	   &amp;&amp; p2 &gt;= bufp-&gt;buffer &amp;&amp; p2 &lt;= pend);</span>
<span class='curline'><a href='../S/71.html#L3668'>buffer</a>           3668 src/regex-emacs.c   eassert (p1 &gt;= bufp-&gt;buffer &amp;&amp; p1 &lt; pend</span>
<span class='curline'><a href='../S/71.html#L3669'>buffer</a>           3669 src/regex-emacs.c 	   &amp;&amp; p2 &gt;= bufp-&gt;buffer &amp;&amp; p2 &lt;= pend);</span>
<span class='curline'><a href='../S/71.html#L3883'>buffer</a>           3883 src/regex-emacs.c   struct buffer *b = (struct buffer *) ptr;</span>
<span class='curline'><a href='../S/71.html#L3919'>buffer</a>           3919 src/regex-emacs.c   re_char *p = bufp-&gt;buffer;</span>
<span class='curline'><a href='../S/71.html#L5092'>buffer</a>           5092 src/regex-emacs.c 	  eassert (p &gt;= bufp-&gt;buffer &amp;&amp; p &lt;= pend);</span>
<span class='curline'><a href='../S/184.html#L69'>buffer</a>             69 src/regex-emacs.h   unsigned char *buffer;</span>
<span class='curline'><a href='../S/184.html#L131'>buffer</a>            131 src/regex-emacs.h 				       struct re_pattern_buffer *buffer);</span>
<span class='curline'><a href='../S/184.html#L139'>buffer</a>            139 src/regex-emacs.h extern ptrdiff_t re_search (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/184.html#L147'>buffer</a>            147 src/regex-emacs.h extern ptrdiff_t re_search_2 (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/184.html#L157'>buffer</a>            157 src/regex-emacs.h extern ptrdiff_t re_match_2 (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/184.html#L176'>buffer</a>            176 src/regex-emacs.h extern void re_set_registers (struct re_pattern_buffer *buffer,</span>
<span class='curline'><a href='../S/225.html#L125'>buffer</a>            125 src/region-cache.c static void revalidate_region_cache (struct buffer *buf, struct region_cache *c);</span>
<span class='curline'><a href='../S/225.html#L458'>buffer</a>            458 src/region-cache.c invalidate_region_cache (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/225.html#L537'>buffer</a>            537 src/region-cache.c revalidate_region_cache (struct buffer *buf, struct region_cache *c)</span>
<span class='curline'><a href='../S/225.html#L665'>buffer</a>            665 src/region-cache.c know_region_cache (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/225.html#L681'>buffer</a>            681 src/region-cache.c region_cache_forward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/225.html#L719'>buffer</a>            719 src/region-cache.c region_cache_backward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/348.html#L65'>buffer</a>             65 src/region-cache.h struct buffer;</span>
<span class='curline'><a href='../S/348.html#L76'>buffer</a>             76 src/region-cache.h extern void know_region_cache (struct buffer *BUF,</span>
<span class='curline'><a href='../S/348.html#L88'>buffer</a>             88 src/region-cache.h extern void invalidate_region_cache (struct buffer *BUF,</span>
<span class='curline'><a href='../S/348.html#L105'>buffer</a>            105 src/region-cache.h extern int region_cache_forward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/348.html#L109'>buffer</a>            109 src/region-cache.h extern int region_cache_backward (struct buffer *buf, struct region_cache *c,</span>
<span class='curline'><a href='../S/237.html#L147'>buffer</a>            147 src/search.c           cp-&gt;buf.buffer = xrealloc (cp-&gt;buf.buffer, cp-&gt;buf.used);</span>
<span class='curline'><a href='../S/237.html#L599'>buffer</a>            599 src/search.c   newline_cache_on_off (struct buffer *buf)</span>
<span class='curline'><a href='../S/237.html#L601'>buffer</a>            601 src/search.c     struct buffer *base_buf = buf;</span>
<span class='curline'><a href='../S/237.html#L677'>buffer</a>            677 src/search.c     struct buffer *cache_buffer;</span>
<span class='curline'><a href='../S/237.html#L3029'>buffer</a>           3029 src/search.c   		if (XMARKER (marker)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/237.html#L3032'>buffer</a>           3032 src/search.c   		  XSETBUFFER (last_thing_searched, XMARKER (marker)-&gt;buffer);</span>
<span class='curline'><a href='../S/237.html#L3049'>buffer</a>           3049 src/search.c   	    if (MARKERP (marker) &amp;&amp; XMARKER (marker)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/237.html#L3306'>buffer</a>           3306 src/search.c     (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/237.html#L3308'>buffer</a>           3308 src/search.c     struct buffer *buf, *old = NULL;</span>
<span class='curline'><a href='../S/237.html#L3313'>buffer</a>           3313 src/search.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/237.html#L3317'>buffer</a>           3317 src/search.c         CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/237.html#L3318'>buffer</a>           3318 src/search.c         buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/237.html#L3468'>buffer</a>           3468 src/search.c         searchbufs[i].buf.buffer = xmalloc (100);</span>
<span class='curline'><a href='../S/90.html#L805'>buffer</a>            805 src/sfnt.c       char buffer[3 + 4 + 4];</span>
<span class='curline'><a href='../S/90.html#L845'>buffer</a>            845 src/sfnt.c           if (read (fd, buffer, sizeof buffer) &lt; sizeof buffer)</span>
<span class='curline'><a href='../S/90.html#L853'>buffer</a>            853 src/sfnt.c     	= sfnt_read_24 ((unsigned char *) buffer);</span>
<span class='curline'><a href='../S/90.html#L857'>buffer</a>            857 src/sfnt.c     	      buffer + 3,</span>
<span class='curline'><a href='../S/90.html#L860'>buffer</a>            860 src/sfnt.c     	      buffer + 7,</span>
<span class='curline'><a href='../S/90.html#L12860'>buffer</a>           12860 src/sfnt.c       char *buffer;</span>
<span class='curline'><a href='../S/90.html#L12885'>buffer</a>           12885 src/sfnt.c       buffer = NULL;</span>
<span class='curline'><a href='../S/90.html#L13015'>buffer</a>           13015 src/sfnt.c         buffer = alloca (fvar-&gt;instance_size);</span>
<span class='curline'><a href='../S/90.html#L13017'>buffer</a>           13017 src/sfnt.c         buffer = xmalloc (fvar-&gt;instance_size);</span>
<span class='curline'><a href='../S/90.html#L13023'>buffer</a>           13023 src/sfnt.c           rc = read (fd, buffer, fvar-&gt;instance_size);</span>
<span class='curline'><a href='../S/90.html#L13029'>buffer</a>           13029 src/sfnt.c           fvar-&gt;instance[i].name_id = *((uint16_t *) buffer);</span>
<span class='curline'><a href='../S/90.html#L13030'>buffer</a>           13030 src/sfnt.c           fvar-&gt;instance[i].flags = *((uint16_t *) buffer + 1);</span>
<span class='curline'><a href='../S/90.html#L13041'>buffer</a>           13041 src/sfnt.c           memcpy (fvar-&gt;instance[i].coords, buffer + 4,</span>
<span class='curline'><a href='../S/90.html#L13055'>buffer</a>           13055 src/sfnt.c     	    = *(uint16_t *) (buffer + 4 + (sizeof *fvar-&gt;instance[i].coords</span>
<span class='curline'><a href='../S/90.html#L13062'>buffer</a>           13062 src/sfnt.c       if (buffer &amp;&amp; fvar-&gt;instance_size &gt;= 1024 * 16)</span>
<span class='curline'><a href='../S/90.html#L13063'>buffer</a>           13063 src/sfnt.c         xfree (buffer);</span>
<span class='curline'><a href='../S/90.html#L13069'>buffer</a>           13069 src/sfnt.c       if (buffer &amp;&amp; fvar-&gt;instance_size &gt;= 1024 * 16)</span>
<span class='curline'><a href='../S/90.html#L13070'>buffer</a>           13070 src/sfnt.c         xfree (buffer);</span>
<span class='curline'><a href='../S/90.html#L13254'>buffer</a>           13254 src/sfnt.c       uint16_t *buffer;</span>
<span class='curline'><a href='../S/90.html#L13294'>buffer</a>           13294 src/sfnt.c       buffer = xmalloc (size);</span>
<span class='curline'><a href='../S/90.html#L13295'>buffer</a>           13295 src/sfnt.c       rc = read (fd, buffer, size);</span>
<span class='curline'><a href='../S/90.html#L13300'>buffer</a>           13300 src/sfnt.c       for (i = 0; i &lt; size / sizeof *buffer; ++i)</span>
<span class='curline'><a href='../S/90.html#L13301'>buffer</a>           13301 src/sfnt.c         sfnt_swap16 (&amp;buffer[i]);</span>
<span class='curline'><a href='../S/90.html#L13311'>buffer</a>           13311 src/sfnt.c           if (k &gt;= size / sizeof *buffer)</span>
<span class='curline'><a href='../S/90.html#L13319'>buffer</a>           13319 src/sfnt.c     			    * buffer[k], min_size, &amp;min_size))</span>
<span class='curline'><a href='../S/90.html#L13324'>buffer</a>           13324 src/sfnt.c           j = k + 1 + buffer[k] * 2;</span>
<span class='curline'><a href='../S/90.html#L13325'>buffer</a>           13325 src/sfnt.c           if (j &gt; size / sizeof *buffer)</span>
<span class='curline'><a href='../S/90.html#L13343'>buffer</a>           13343 src/sfnt.c           avar-&gt;segments[i].pair_count = buffer[k++];</span>
<span class='curline'><a href='../S/90.html#L13348'>buffer</a>           13348 src/sfnt.c     	  correspondences-&gt;from_coord = buffer[k++];</span>
<span class='curline'><a href='../S/90.html#L13349'>buffer</a>           13349 src/sfnt.c     	  correspondences-&gt;to_coord = buffer[k++];</span>
<span class='curline'><a href='../S/90.html#L13355'>buffer</a>           13355 src/sfnt.c       xfree (buffer);</span>
<span class='curline'><a href='../S/90.html#L13359'>buffer</a>           13359 src/sfnt.c       xfree (buffer);</span>
<span class='curline'><a href='../S/90.html#L13558'>buffer</a>           13558 src/sfnt.c       unsigned char *buffer, *data, *end, *tuple;</span>
<span class='curline'><a href='../S/90.html#L13595'>buffer</a>           13595 src/sfnt.c       buffer = xmalloc (size);</span>
<span class='curline'><a href='../S/90.html#L13596'>buffer</a>           13596 src/sfnt.c       rc = read (fd, buffer, size);</span>
<span class='curline'><a href='../S/90.html#L13605'>buffer</a>           13605 src/sfnt.c       end = buffer + size;</span>
<span class='curline'><a href='../S/90.html#L13612'>buffer</a>           13612 src/sfnt.c       data = buffer + data_offset;</span>
<span class='curline'><a href='../S/90.html#L13613'>buffer</a>           13613 src/sfnt.c       tuple = buffer;</span>
<span class='curline'><a href='../S/90.html#L13642'>buffer</a>           13642 src/sfnt.c           data = buffer + data_offset;</span>
<span class='curline'><a href='../S/90.html#L13702'>buffer</a>           13702 src/sfnt.c       tuple = buffer;</span>
<span class='curline'><a href='../S/90.html#L13710'>buffer</a>           13710 src/sfnt.c           data = buffer + data_offset;</span>
<span class='curline'><a href='../S/90.html#L13860'>buffer</a>           13860 src/sfnt.c       xfree (buffer);</span>
<span class='curline'><a href='../S/90.html#L13867'>buffer</a>           13867 src/sfnt.c       xfree (buffer);</span>
<span class='curline'><a href='../S/90.html#L18826'>buffer</a>           18826 src/sfnt.c       char buffer[80];</span>
<span class='curline'><a href='../S/90.html#L18830'>buffer</a>           18830 src/sfnt.c       sprintf (buffer, "opcode:IP:depth: 0x%x:%d:%d",</span>
<span class='curline'><a href='../S/90.html#L18840'>buffer</a>           18840 src/sfnt.c       XDrawString (display, window, point_gc, 0, 13, buffer,</span>
<span class='curline'><a href='../S/90.html#L18841'>buffer</a>           18841 src/sfnt.c     	       strlen (buffer));</span>
<span class='curline'><a href='../S/90.html#L18845'>buffer</a>           18845 src/sfnt.c       sprintf (buffer, "opcode: %s",</span>
<span class='curline'><a href='../S/90.html#L18848'>buffer</a>           18848 src/sfnt.c       XDrawString (display, window, point_gc, 14, 27, buffer,</span>
<span class='curline'><a href='../S/90.html#L18849'>buffer</a>           18849 src/sfnt.c     	       strlen (buffer));</span>
<span class='curline'><a href='../S/90.html#L18860'>buffer</a>           18860 src/sfnt.c       sprintf (buffer, "projection function: %s", name);</span>
<span class='curline'><a href='../S/90.html#L18862'>buffer</a>           18862 src/sfnt.c       XDrawString (display, window, point_gc, 28, 42, buffer,</span>
<span class='curline'><a href='../S/90.html#L18863'>buffer</a>           18863 src/sfnt.c     	       strlen (buffer));</span>
<span class='curline'><a href='../S/90.html#L18925'>buffer</a>           18925 src/sfnt.c       static char buffer[256];</span>
<span class='curline'><a href='../S/90.html#L18935'>buffer</a>           18935 src/sfnt.c           sprintf (buffer, "prep+%td",</span>
<span class='curline'><a href='../S/90.html#L18937'>buffer</a>           18937 src/sfnt.c           return buffer;</span>
<span class='curline'><a href='../S/90.html#L18945'>buffer</a>           18945 src/sfnt.c           sprintf (buffer, "fpgm+%td",</span>
<span class='curline'><a href='../S/90.html#L18947'>buffer</a>           18947 src/sfnt.c           return buffer;</span>
<span class='curline'><a href='../S/90.html#L18950'>buffer</a>           18950 src/sfnt.c       sprintf (buffer, "IP+%td", where - interpreter-&gt;instructions);</span>
<span class='curline'><a href='../S/90.html#L18951'>buffer</a>           18951 src/sfnt.c       return buffer;</span>
<span class='curline'><a href='../S/163.html#L76'>buffer</a>             76 src/sfntfont-android.c #define GET_SCANLINE_BUFFER(buffer, height, stride)		\</span>
<span class='curline'><a href='../S/163.html#L85'>buffer</a>             85 src/sfntfont-android.c 	(buffer) = alloca (_size);				\</span>
<span class='curline'><a href='../S/163.html#L90'>buffer</a>             90 src/sfntfont-android.c 	      (buffer)						\</span>
<span class='curline'><a href='../S/163.html#L97'>buffer</a>             97 src/sfntfont-android.c 	    (buffer) = scanline_buffer.buffer_data;		\</span>
<span class='curline'><a href='../S/163.html#L109'>buffer</a>            109 src/sfntfont-android.c #define GET_SCANLINE_BUFFER(buffer, height, stride)		\</span>
<span class='curline'><a href='../S/163.html#L123'>buffer</a>            123 src/sfntfont-android.c 	  (buffer)						\</span>
<span class='curline'><a href='../S/163.html#L129'>buffer</a>            129 src/sfntfont-android.c 	(buffer) = scanline_buffer.buffer_data;			\</span>
<span class='curline'><a href='../S/163.html#L316'>buffer</a>            316 src/sfntfont-android.c sfntfont_android_composite_bitmap (unsigned char *restrict buffer,</span>
<span class='curline'><a href='../S/163.html#L348'>buffer</a>            348 src/sfntfont-android.c 	  src_row = (unsigned int *) ((buffer + src_y * stride));</span>
<span class='curline'><a href='../S/163.html#L410'>buffer</a>            410 src/sfntfont-android.c   unsigned int *buffer, *row;</span>
<span class='curline'><a href='../S/163.html#L491'>buffer</a>            491 src/sfntfont-android.c   stride = ((text_rectangle.width * sizeof *buffer) + 7) &amp; ~7;</span>
<span class='curline'><a href='../S/163.html#L493'>buffer</a>            493 src/sfntfont-android.c   stride = ((text_rectangle.width * sizeof *buffer) + 15) &amp; ~15;</span>
<span class='curline'><a href='../S/163.html#L495'>buffer</a>            495 src/sfntfont-android.c   GET_SCANLINE_BUFFER (buffer, text_rectangle.height, stride);</span>
<span class='curline'><a href='../S/163.html#L502'>buffer</a>            502 src/sfntfont-android.c     memset (buffer, 0, text_rectangle.height * stride);</span>
<span class='curline'><a href='../S/163.html#L518'>buffer</a>            518 src/sfntfont-android.c 	  row = (unsigned int *) ((unsigned char *) buffer</span>
<span class='curline'><a href='../S/163.html#L547'>buffer</a>            547 src/sfntfont-android.c 	  row = (unsigned int *) ((unsigned char *) buffer</span>
<span class='curline'><a href='../S/163.html#L584'>buffer</a>            584 src/sfntfont-android.c 	  sfntfont_android_composite_bitmap ((unsigned char *) buffer,</span>
<span class='curline'><a href='../S/163.html#L591'>buffer</a>            591 src/sfntfont-android.c     sfntfont_android_composite_bitmap ((unsigned char *) buffer,</span>
<span class='curline'><a href='../S/62.html#L223'>buffer</a>            223 src/sound.c      void (* write) (struct sound_device *sd, const char *buffer,</span>
<span class='curline'><a href='../S/62.html#L571'>buffer</a>            571 src/sound.c          char *buffer = SAFE_ALLOCA (blksize);</span>
<span class='curline'><a href='../S/62.html#L574'>buffer</a>            574 src/sound.c                 &amp;&amp; (nbytes = emacs_read (s-&gt;fd, buffer, blksize)) &gt; 0)</span>
<span class='curline'><a href='../S/62.html#L579'>buffer</a>            579 src/sound.c              sd-&gt;write (sd, buffer, nbytes);</span>
<span class='curline'><a href='../S/62.html#L666'>buffer</a>            666 src/sound.c          char *buffer = SAFE_ALLOCA (blksize);</span>
<span class='curline'><a href='../S/62.html#L667'>buffer</a>            667 src/sound.c          while ((nbytes = emacs_read (s-&gt;fd, buffer, blksize)) &gt; 0)</span>
<span class='curline'><a href='../S/62.html#L668'>buffer</a>            668 src/sound.c    	sd-&gt;write (sd, buffer, nbytes);</span>
<span class='curline'><a href='../S/62.html#L868'>buffer</a>            868 src/sound.c    vox_write (struct sound_device *sd, const char *buffer, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/62.html#L870'>buffer</a>            870 src/sound.c      if (emacs_write_sig (sd-&gt;fd, buffer, nbytes) != nbytes)</span>
<span class='curline'><a href='../S/62.html#L1126'>buffer</a>           1126 src/sound.c    alsa_write (struct sound_device *sd, const char *buffer, ptrdiff_t nbytes)</span>
<span class='curline'><a href='../S/62.html#L1140'>buffer</a>           1140 src/sound.c          err = snd_pcm_writei (p-&gt;handle, buffer + nwritten, frames);</span>
<span class='curline'><a href='../S/159.html#L176'>buffer</a>            176 src/syntax.c   static struct buffer *find_start_buffer;</span>
<span class='curline'><a href='../S/159.html#L193'>buffer</a>            193 src/syntax.c   bset_syntax_table (struct buffer *b, Lisp_Object val)</span>
<span class='curline'><a href='../S/159.html#L278'>buffer</a>            278 src/syntax.c         struct buffer *buf = XBUFFER (gl_state.object);</span>
<span class='curline'><a href='../S/268.html#L2355'>buffer</a>           2355 src/sysdep.c     void *buffer;</span>
<span class='curline'><a href='../S/268.html#L2360'>buffer</a>           2360 src/sysdep.c         buffer = thread_backtrace_buffer;</span>
<span class='curline'><a href='../S/268.html#L2365'>buffer</a>           2365 src/sysdep.c         buffer = main_backtrace_buffer;</span>
<span class='curline'><a href='../S/268.html#L2370'>buffer</a>           2370 src/sysdep.c   	  backtrace (buffer, 1);</span>
<span class='curline'><a href='../S/268.html#L2374'>buffer</a>           2374 src/sysdep.c         npointers = backtrace (buffer, bounded_limit + 1);</span>
<span class='curline'><a href='../S/268.html#L2380'>buffer</a>           2380 src/sysdep.c         backtrace_symbols_fd (buffer, npointers, STDERR_FILENO);</span>
<span class='curline'><a href='../S/56.html#L3516'>buffer</a>           3516 src/term.c       struct buffer *buffer;</span>
<span class='curline'><a href='../S/56.html#L3526'>buffer</a>           3526 src/term.c       set_buffer_internal (data-&gt;buffer);</span>
<span class='curline'><a href='../S/58.html#L88'>buffer</a>             88 src/textconv.c 		  char *buffer)</span>
<span class='curline'><a href='../S/58.html#L110'>buffer</a>            110 src/textconv.c   memcpy (buffer, BYTE_POS_ADDR (beg0), size);</span>
<span class='curline'><a href='../S/58.html#L112'>buffer</a>            112 src/textconv.c     memcpy (buffer + size, BEG_ADDR + beg1, end1 - beg1);</span>
<span class='curline'><a href='../S/58.html#L126'>buffer</a>            126 src/textconv.c       &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer)</span>
<span class='curline'><a href='../S/58.html#L180'>buffer</a>            180 src/textconv.c   char *buffer;</span>
<span class='curline'><a href='../S/58.html#L395'>buffer</a>            395 src/textconv.c   buffer = xmalloc (end_byte - pos_byte);</span>
<span class='curline'><a href='../S/58.html#L396'>buffer</a>            396 src/textconv.c   copy_buffer_text (pos, pos_byte, end, end_byte, buffer);</span>
<span class='curline'><a href='../S/58.html#L397'>buffer</a>            397 src/textconv.c   query-&gt;text.text = buffer;</span>
<span class='curline'><a href='../S/58.html#L462'>buffer</a>            462 src/textconv.c   Lisp_Object buffer, beg_marker, end_marker;</span>
<span class='curline'><a href='../S/58.html#L464'>buffer</a>            464 src/textconv.c   XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/58.html#L486'>buffer</a>            486 src/textconv.c     = Fcons (list4 (buffer, beg_marker, end_marker,</span>
<span class='curline'><a href='../S/58.html#L1223'>buffer</a>           1223 src/textconv.c   struct buffer *buffer UNINIT;</span>
<span class='curline'><a href='../S/58.html#L1255'>buffer</a>           1255 src/textconv.c       buffer = XBUFFER (WINDOW_BUFFER (w));</span>
<span class='curline'><a href='../S/58.html#L1276'>buffer</a>           1276 src/textconv.c 	text_interface-&gt;point_changed (f, w, buffer);</span>
<span class='curline'><a href='../S/58.html#L1706'>buffer</a>           1706 src/textconv.c   char *buffer;</span>
<span class='curline'><a href='../S/58.html#L1722'>buffer</a>           1722 src/textconv.c   buffer = NULL;</span>
<span class='curline'><a href='../S/58.html#L1737'>buffer</a>           1737 src/textconv.c 	  &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer)</span>
<span class='curline'><a href='../S/58.html#L1769'>buffer</a>           1769 src/textconv.c   buffer = xmalloc (end_byte - start_byte);</span>
<span class='curline'><a href='../S/58.html#L1770'>buffer</a>           1770 src/textconv.c   copy_buffer_text (start, start_byte, end, end_byte, buffer);</span>
<span class='curline'><a href='../S/58.html#L1795'>buffer</a>           1795 src/textconv.c   return buffer;</span>
<span class='curline'><a href='../S/58.html#L1817'>buffer</a>           1817 src/textconv.c   char *buffer;</span>
<span class='curline'><a href='../S/58.html#L1833'>buffer</a>           1833 src/textconv.c   buffer = NULL;</span>
<span class='curline'><a href='../S/58.html#L1874'>buffer</a>           1874 src/textconv.c   buffer = xmalloc (end_byte - start_byte);</span>
<span class='curline'><a href='../S/58.html#L1875'>buffer</a>           1875 src/textconv.c   copy_buffer_text (start, start_byte, end, end_byte, buffer);</span>
<span class='curline'><a href='../S/58.html#L1895'>buffer</a>           1895 src/textconv.c   return buffer;</span>
<span class='curline'><a href='../S/58.html#L1951'>buffer</a>           1951 src/textconv.c 		     struct buffer *buffer)</span>
<span class='curline'><a href='../S/58.html#L1959'>buffer</a>           1959 src/textconv.c     text_interface-&gt;point_changed (f, window, buffer);</span>
<span class='curline'><a href='../S/58.html#L2037'>buffer</a>           2037 src/textconv.c   Lisp_Object buffer, tail, frame;</span>
<span class='curline'><a href='../S/58.html#L2038'>buffer</a>           2038 src/textconv.c   struct buffer *b;</span>
<span class='curline'><a href='../S/58.html#L2041'>buffer</a>           2041 src/textconv.c   buffer = postponed_buffers;</span>
<span class='curline'><a href='../S/58.html#L2047'>buffer</a>           2047 src/textconv.c   FOR_EACH_TAIL (buffer)</span>
<span class='curline'><a href='../S/58.html#L2049'>buffer</a>           2049 src/textconv.c       b = XBUFFER (XCAR (buffer));</span>
<span class='curline'><a href='../S/58.html#L2072'>buffer</a>           2072 src/textconv.c 		     XCAR (buffer)))</span>
<span class='curline'><a href='../S/58.html#L2110'>buffer</a>           2110 src/textconv.c   Lisp_Object buffer;</span>
<span class='curline'><a href='../S/58.html#L2122'>buffer</a>           2122 src/textconv.c       buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/58.html#L2130'>buffer</a>           2130 src/textconv.c 	  if (NILP (Fmemq (buffer, postponed_buffers)))</span>
<span class='curline'><a href='../S/58.html#L2134'>buffer</a>           2134 src/textconv.c 	    postponed_buffers = Fcons (buffer, postponed_buffers);</span>
<span class='curline'><a href='../S/58.html#L2145'>buffer</a>           2145 src/textconv.c 		      buffer)</span>
<span class='curline'><a href='../S/280.html#L43'>buffer</a>             43 src/textconv.h 			 struct buffer *);</span>
<span class='curline'><a href='../S/150.html#L78'>buffer</a>             78 src/textprop.c modify_text_properties (Lisp_Object buffer, Lisp_Object start, Lisp_Object end)</span>
<span class='curline'><a href='../S/150.html#L81'>buffer</a>             81 src/textprop.c   struct buffer *buf = XBUFFER (buffer), *old = current_buffer;</span>
<span class='curline'><a href='../S/150.html#L154'>buffer</a>            154 src/textprop.c       register struct buffer *b = XBUFFER (object);</span>
<span class='curline'><a href='../S/150.html#L537'>buffer</a>            537 src/textprop.c       register struct buffer *b = XBUFFER (object);</span>
<span class='curline'><a href='../S/150.html#L636'>buffer</a>            636 src/textprop.c       struct buffer *b = XBUFFER (object);</span>
<span class='curline'><a href='../S/150.html#L1901'>buffer</a>           1901 src/textprop.c text_property_stickiness (Lisp_Object prop, Lisp_Object pos, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/150.html#L1909'>buffer</a>           1909 src/textprop.c   if (NILP (buffer))</span>
<span class='curline'><a href='../S/150.html#L1910'>buffer</a>           1910 src/textprop.c     XSETBUFFER (buffer, current_buffer);</span>
<span class='curline'><a href='../S/150.html#L1912'>buffer</a>           1912 src/textprop.c   ignore_previous_character = XFIXNUM (pos) &lt;= BUF_BEGV (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/150.html#L1919'>buffer</a>           1919 src/textprop.c 	= Fget_text_property (prev_pos, Qrear_nonsticky, buffer);</span>
<span class='curline'><a href='../S/150.html#L1931'>buffer</a>           1931 src/textprop.c   front_sticky = Fget_text_property (pos, Qfront_sticky, buffer);</span>
<span class='curline'><a href='../S/150.html#L1952'>buffer</a>           1952 src/textprop.c       || NILP (Fget_text_property (prev_pos, prop, buffer)))</span>
<span class='curline'><a href='../S/150.html#L2184'>buffer</a>           2184 src/textprop.c verify_interval_modification (struct buffer *buf,</span>
<span class='curline'><a href='../S/162.html#L1095'>buffer</a>           1095 src/thread.c   thread_check_current_buffer (struct buffer *buffer)</span>
<span class='curline'><a href='../S/162.html#L1104'>buffer</a>           1104 src/thread.c         if (iter-&gt;m_current_buffer == buffer)</span>
<span class='curline'><a href='../S/117.html#L132'>buffer</a>            132 src/thread.h     struct buffer *m_current_buffer;</span>
<span class='curline'><a href='../S/117.html#L327'>buffer</a>            327 src/thread.h   bool thread_check_current_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/337.html#L1342'>buffer</a>           1342 src/timefns.c    char buffer[4000];</span>
<span class='curline'><a href='../S/337.html#L1343'>buffer</a>           1343 src/timefns.c    char *buf = buffer;</span>
<span class='curline'><a href='../S/337.html#L1344'>buffer</a>           1344 src/timefns.c    ptrdiff_t size = sizeof buffer;</span>
<span class='curline'><a href='../S/220.html#L792'>buffer</a>            792 src/treesit.c    struct buffer *base_buffer = current_buffer;</span>
<span class='curline'><a href='../S/220.html#L921'>buffer</a>            921 src/treesit.c    struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/220.html#L927'>buffer</a>            927 src/treesit.c        XTS_PARSER (parser)-&gt;visible_beg = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/220.html#L928'>buffer</a>            928 src/treesit.c        XTS_PARSER (parser)-&gt;visible_end = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/220.html#L937'>buffer</a>            937 src/treesit.c    eassert (BUF_BEGV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/220.html#L938'>buffer</a>            938 src/treesit.c    eassert (BUF_ZV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/220.html#L942'>buffer</a>            942 src/treesit.c    if (visible_beg != BUF_BEGV_BYTE (buffer)</span>
<span class='curline'><a href='../S/220.html#L943'>buffer</a>            943 src/treesit.c        || visible_end != BUF_ZV_BYTE (buffer))</span>
<span class='curline'><a href='../S/220.html#L955'>buffer</a>            955 src/treesit.c    if (visible_beg &gt; BUF_BEGV_BYTE (buffer))</span>
<span class='curline'><a href='../S/220.html#L958'>buffer</a>            958 src/treesit.c        treesit_tree_edit_1 (tree, 0, 0, visible_beg - BUF_BEGV_BYTE (buffer));</span>
<span class='curline'><a href='../S/220.html#L959'>buffer</a>            959 src/treesit.c        visible_beg = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/220.html#L963'>buffer</a>            963 src/treesit.c    if (visible_end &lt; BUF_ZV_BYTE (buffer))</span>
<span class='curline'><a href='../S/220.html#L968'>buffer</a>            968 src/treesit.c  			   BUF_ZV_BYTE (buffer) - visible_beg);</span>
<span class='curline'><a href='../S/220.html#L969'>buffer</a>            969 src/treesit.c        visible_end = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/220.html#L972'>buffer</a>            972 src/treesit.c    else if (visible_end &gt; BUF_ZV_BYTE (buffer))</span>
<span class='curline'><a href='../S/220.html#L975'>buffer</a>            975 src/treesit.c        treesit_tree_edit_1 (tree, BUF_ZV_BYTE (buffer) - visible_beg,</span>
<span class='curline'><a href='../S/220.html#L977'>buffer</a>            977 src/treesit.c  			   BUF_ZV_BYTE (buffer) - visible_beg);</span>
<span class='curline'><a href='../S/220.html#L978'>buffer</a>            978 src/treesit.c        visible_end = BUF_ZV_BYTE (buffer);</span>
<span class='curline'><a href='../S/220.html#L982'>buffer</a>            982 src/treesit.c    if (visible_beg &lt; BUF_BEGV_BYTE (buffer))</span>
<span class='curline'><a href='../S/220.html#L985'>buffer</a>            985 src/treesit.c        treesit_tree_edit_1 (tree, 0, BUF_BEGV_BYTE (buffer) - visible_beg, 0);</span>
<span class='curline'><a href='../S/220.html#L986'>buffer</a>            986 src/treesit.c        visible_beg = BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/220.html#L991'>buffer</a>            991 src/treesit.c    eassert (visible_beg == BUF_BEGV_BYTE (buffer));</span>
<span class='curline'><a href='../S/220.html#L992'>buffer</a>            992 src/treesit.c    eassert (visible_end == BUF_ZV_BYTE (buffer));</span>
<span class='curline'><a href='../S/220.html#L999'>buffer</a>            999 src/treesit.c  treesit_check_buffer_size (struct buffer *buffer)</span>
<span class='curline'><a href='../S/220.html#L1001'>buffer</a>           1001 src/treesit.c    ptrdiff_t buffer_size_bytes = (BUF_Z_BYTE (buffer) - BUF_BEG_BYTE (buffer));</span>
<span class='curline'><a href='../S/220.html#L1008'>buffer</a>           1008 src/treesit.c  static Lisp_Object treesit_make_ranges (const TSRange *, uint32_t, struct buffer *);</span>
<span class='curline'><a href='../S/220.html#L1017'>buffer</a>           1017 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/220.html#L1027'>buffer</a>           1027 src/treesit.c        struct buffer *oldbuf = current_buffer;</span>
<span class='curline'><a href='../S/220.html#L1049'>buffer</a>           1049 src/treesit.c    struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/220.html#L1052'>buffer</a>           1052 src/treesit.c    treesit_check_buffer_size (buffer);</span>
<span class='curline'><a href='../S/220.html#L1077'>buffer</a>           1077 src/treesit.c        XSETBUFFER (buf, buffer);</span>
<span class='curline'><a href='../S/220.html#L1101'>buffer</a>           1101 src/treesit.c    struct buffer *buffer = XBUFFER (((struct Lisp_TS_Parser *) parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/220.html#L1108'>buffer</a>           1108 src/treesit.c    eassert (visible_beg = BUF_BEGV_BYTE (buffer));</span>
<span class='curline'><a href='../S/220.html#L1109'>buffer</a>           1109 src/treesit.c    eassert (visible_end = BUF_ZV_BYTE (buffer));</span>
<span class='curline'><a href='../S/220.html#L1121'>buffer</a>           1121 src/treesit.c    if (!BUFFER_LIVE_P (buffer))</span>
<span class='curline'><a href='../S/220.html#L1135'>buffer</a>           1135 src/treesit.c        beg = (char *) BUF_BYTE_ADDRESS (buffer, byte_pos);</span>
<span class='curline'><a href='../S/220.html#L1151'>buffer</a>           1151 src/treesit.c  make_treesit_parser (Lisp_Object buffer, TSParser *parser,</span>
<span class='curline'><a href='../S/220.html#L1157'>buffer</a>           1157 src/treesit.c  				       buffer, PVEC_TS_PARSER);</span>
<span class='curline'><a href='../S/220.html#L1161'>buffer</a>           1161 src/treesit.c    lisp_parser-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/220.html#L1167'>buffer</a>           1167 src/treesit.c    lisp_parser-&gt;visible_beg = BUF_BEGV_BYTE (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/220.html#L1168'>buffer</a>           1168 src/treesit.c    lisp_parser-&gt;visible_end = BUF_ZV_BYTE (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/220.html#L1391'>buffer</a>           1391 src/treesit.c    (Lisp_Object language, Lisp_Object buffer, Lisp_Object no_reuse)</span>
<span class='curline'><a href='../S/220.html#L1396'>buffer</a>           1396 src/treesit.c    struct buffer *buf;</span>
<span class='curline'><a href='../S/220.html#L1397'>buffer</a>           1397 src/treesit.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/220.html#L1401'>buffer</a>           1401 src/treesit.c        CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/220.html#L1402'>buffer</a>           1402 src/treesit.c        buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/220.html#L1453'>buffer</a>           1453 src/treesit.c    Lisp_Object buffer = XTS_PARSER (parser)-&gt;buffer;</span>
<span class='curline'><a href='../S/220.html#L1454'>buffer</a>           1454 src/treesit.c    struct buffer *buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/220.html#L1471'>buffer</a>           1471 src/treesit.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/220.html#L1473'>buffer</a>           1473 src/treesit.c    struct buffer *buf;</span>
<span class='curline'><a href='../S/220.html#L1474'>buffer</a>           1474 src/treesit.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/220.html#L1478'>buffer</a>           1478 src/treesit.c        CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/220.html#L1479'>buffer</a>           1479 src/treesit.c        buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/220.html#L1505'>buffer</a>           1505 src/treesit.c    XSETBUFFER (buf, XBUFFER (XTS_PARSER (parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/220.html#L1526'>buffer</a>           1526 src/treesit.c  	  (!NILP (Fbuffer_live_p (XTS_PARSER (parser)-&gt;buffer))));</span>
<span class='curline'><a href='../S/220.html#L1550'>buffer</a>           1550 src/treesit.c    struct buffer *buffer = current_buffer;</span>
<span class='curline'><a href='../S/220.html#L1551'>buffer</a>           1551 src/treesit.c    ptrdiff_t point_min = BUF_BEGV (buffer);</span>
<span class='curline'><a href='../S/220.html#L1552'>buffer</a>           1552 src/treesit.c    ptrdiff_t point_max = BUF_ZV (buffer);</span>
<span class='curline'><a href='../S/220.html#L1586'>buffer</a>           1586 src/treesit.c  		     struct buffer *buffer)</span>
<span class='curline'><a href='../S/220.html#L1592'>buffer</a>           1592 src/treesit.c        uint32_t beg_byte = range.start_byte + BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/220.html#L1593'>buffer</a>           1593 src/treesit.c        uint32_t end_byte = range.end_byte + BUF_BEGV_BYTE (buffer);</span>
<span class='curline'><a href='../S/220.html#L1594'>buffer</a>           1594 src/treesit.c        eassert (BUF_BEGV_BYTE (buffer) &lt;= beg_byte);</span>
<span class='curline'><a href='../S/220.html#L1596'>buffer</a>           1596 src/treesit.c        eassert (end_byte &lt;= BUF_ZV_BYTE (buffer));</span>
<span class='curline'><a href='../S/220.html#L1599'>buffer</a>           1599 src/treesit.c  	= Fcons (make_fixnum (buf_bytepos_to_charpos (buffer, beg_byte)),</span>
<span class='curline'><a href='../S/220.html#L1600'>buffer</a>           1600 src/treesit.c  		 make_fixnum (buf_bytepos_to_charpos (buffer, end_byte)));</span>
<span class='curline'><a href='../S/220.html#L1627'>buffer</a>           1627 src/treesit.c    treesit_check_buffer_size (XBUFFER (XTS_PARSER (parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/220.html#L1650'>buffer</a>           1650 src/treesit.c        struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/220.html#L1658'>buffer</a>           1658 src/treesit.c  	  ptrdiff_t beg_byte = buf_charpos_to_bytepos (buffer,</span>
<span class='curline'><a href='../S/220.html#L1660'>buffer</a>           1660 src/treesit.c  	  ptrdiff_t end_byte = buf_charpos_to_bytepos (buffer,</span>
<span class='curline'><a href='../S/220.html#L1664'>buffer</a>           1664 src/treesit.c  	  eassert (beg_byte - BUF_BEGV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/220.html#L1665'>buffer</a>           1665 src/treesit.c  	  eassert (end_byte - BUF_BEGV_BYTE (buffer) &lt;= UINT32_MAX);</span>
<span class='curline'><a href='../S/220.html#L1669'>buffer</a>           1669 src/treesit.c  			(uint32_t) beg_byte - BUF_BEGV_BYTE (buffer),</span>
<span class='curline'><a href='../S/220.html#L1670'>buffer</a>           1670 src/treesit.c  			(uint32_t) end_byte - BUF_BEGV_BYTE (buffer)};</span>
<span class='curline'><a href='../S/220.html#L1713'>buffer</a>           1713 src/treesit.c    treesit_check_buffer_size (XBUFFER (XTS_PARSER (parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/220.html#L1716'>buffer</a>           1716 src/treesit.c    struct buffer *buffer = XBUFFER (XTS_PARSER (parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/220.html#L1717'>buffer</a>           1717 src/treesit.c    return treesit_make_ranges (ranges, len, buffer);</span>
<span class='curline'><a href='../S/220.html#L1800'>buffer</a>           1800 src/treesit.c  treesit_check_position (Lisp_Object obj, struct buffer *buf)</span>
<span class='curline'><a href='../S/220.html#L1843'>buffer</a>           1843 src/treesit.c    struct buffer *buffer</span>
<span class='curline'><a href='../S/220.html#L1844'>buffer</a>           1844 src/treesit.c      = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/220.html#L1846'>buffer</a>           1846 src/treesit.c      = buf_bytepos_to_charpos (buffer,</span>
<span class='curline'><a href='../S/220.html#L1864'>buffer</a>           1864 src/treesit.c    struct buffer *buffer</span>
<span class='curline'><a href='../S/220.html#L1865'>buffer</a>           1865 src/treesit.c      = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/220.html#L1867'>buffer</a>           1867 src/treesit.c      = buf_bytepos_to_charpos (buffer, end_byte_offset + visible_beg);</span>
<span class='curline'><a href='../S/220.html#L2212'>buffer</a>           2212 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/220.html#L2248'>buffer</a>           2248 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/220.html#L2536'>buffer</a>           2536 src/treesit.c    struct buffer *old_buffer = current_buffer;</span>
<span class='curline'><a href='../S/220.html#L2537'>buffer</a>           2537 src/treesit.c    set_buffer_internal (XBUFFER (XTS_PARSER (XTS_NODE (node)-&gt;parser)-&gt;buffer));</span>
<span class='curline'><a href='../S/220.html#L2892'>buffer</a>           2892 src/treesit.c    struct buffer *buf = XBUFFER (XTS_PARSER (lisp_parser)-&gt;buffer);</span>
<span class='curline'><a href='../S/220.html#L2948'>buffer</a>           2948 src/treesit.c    struct buffer *old_buf = current_buffer;</span>
<span class='curline'><a href='../S/256.html#L45'>buffer</a>             45 src/treesit.h    Lisp_Object buffer;</span>
<span class='curline'><a href='../S/94.html#L212'>buffer</a>            212 src/undo.c       struct buffer *base_buffer = current_buffer;</span>
<span class='curline'><a href='../S/94.html#L231'>buffer</a>            231 src/undo.c     			Lisp_Object buffer)</span>
<span class='curline'><a href='../S/94.html#L234'>buffer</a>            234 src/undo.c       struct buffer *buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/94.html#L290'>buffer</a>            290 src/undo.c     truncate_undo_list (struct buffer *b)</span>
<span class='curline'><a href='../S/332.html#L283'>buffer</a>            283 src/unexcw.c         char buffer[4096];</span>
<span class='curline'><a href='../S/332.html#L284'>buffer</a>            284 src/unexcw.c         ret = read (fd_in, buffer, sizeof (buffer));</span>
<span class='curline'><a href='../S/332.html#L292'>buffer</a>            292 src/unexcw.c         ret2 = write (fd_out, buffer, ret);</span>
<span class='curline'><a href='../S/151.html#L217'>buffer</a>            217 src/unexhp9k800.c   int buffer[8192];  /* word aligned will be faster */</span>
<span class='curline'><a href='../S/151.html#L221'>buffer</a>            221 src/unexhp9k800.c       len = min (size, sizeof (buffer));</span>
<span class='curline'><a href='../S/151.html#L222'>buffer</a>            222 src/unexhp9k800.c       if (read (old, buffer, len) != len)</span>
<span class='curline'><a href='../S/151.html#L224'>buffer</a>            224 src/unexhp9k800.c       if (write (new, buffer, len) != len)</span>
<span class='curline'><a href='../S/151.html#L234'>buffer</a>            234 src/unexhp9k800.c   int buffer[4096];</span>
<span class='curline'><a href='../S/151.html#L238'>buffer</a>            238 src/unexhp9k800.c   while ((len = read (old, buffer, sizeof (buffer))) &gt; 0)</span>
<span class='curline'><a href='../S/151.html#L239'>buffer</a>            239 src/unexhp9k800.c     if (write (new, buffer, len) != len) break;</span>
<span class='curline'><a href='../S/218.html#L3931'>buffer</a>           3931 src/w32.c        char *buffer;</span>
<span class='curline'><a href='../S/218.html#L3941'>buffer</a>           3941 src/w32.c            buffer = alloca (bufsize);</span>
<span class='curline'><a href='../S/218.html#L3942'>buffer</a>           3942 src/w32.c            result = WNetEnumResourceW (henum, &amp;count, buffer, &amp;bufsize);</span>
<span class='curline'><a href='../S/218.html#L3946'>buffer</a>           3946 src/w32.c            ptrw = ((LPNETRESOURCEW) buffer)-&gt;lpRemoteName;</span>
<span class='curline'><a href='../S/218.html#L3958'>buffer</a>           3958 src/w32.c            buffer = alloca (bufsize);</span>
<span class='curline'><a href='../S/218.html#L3959'>buffer</a>           3959 src/w32.c            result = WNetEnumResourceA (henum, &amp;count, buffer, &amp;bufsize);</span>
<span class='curline'><a href='../S/218.html#L3962'>buffer</a>           3962 src/w32.c            ptra = ((LPNETRESOURCEA) buffer)-&gt;lpRemoteName;</span>
<span class='curline'><a href='../S/218.html#L6364'>buffer</a>           6364 src/w32.c      readlinkat (int fd, char const *name, char *buffer,</span>
<span class='curline'><a href='../S/218.html#L6382'>buffer</a>           6382 src/w32.c        return readlink (name, buffer, buffer_size);</span>
<span class='curline'><a href='../S/218.html#L6803'>buffer</a>           6803 src/w32.c                    char *buffer, size_t buffer_size,</span>
<span class='curline'><a href='../S/218.html#L6814'>buffer</a>           6814 src/w32.c            char *retval = buffer;</span>
<span class='curline'><a href='../S/218.html#L9005'>buffer</a>           9005 src/w32.c      sys_read (int fd, char * buffer, unsigned int count)</span>
<span class='curline'><a href='../S/218.html#L9010'>buffer</a>           9010 src/w32.c        char * orig_buffer = buffer;</span>
<span class='curline'><a href='../S/218.html#L9034'>buffer</a>           9034 src/w32.c      	  *buffer++ = 0x0d;</span>
<span class='curline'><a href='../S/218.html#L9076'>buffer</a>           9076 src/w32.c      	      *buffer++ = cp-&gt;chr;</span>
<span class='curline'><a href='../S/218.html#L9098'>buffer</a>           9098 src/w32.c      		nchars += _read (fd, buffer, to_read);</span>
<span class='curline'><a href='../S/218.html#L9129'>buffer</a>           9129 src/w32.c      		  if (!ReadFile (hnd, buffer, count, (DWORD*) &amp;rc, ovl))</span>
<span class='curline'><a href='../S/218.html#L9182'>buffer</a>           9182 src/w32.c      		  int res = pfn_recv (SOCK_HANDLE (fd), buffer, count, 0);</span>
<span class='curline'><a href='../S/218.html#L9196'>buffer</a>           9196 src/w32.c      	  int nread = _read (fd, buffer, count);</span>
<span class='curline'><a href='../S/218.html#L9221'>buffer</a>           9221 src/w32.c          nchars = _read (fd, buffer, count);</span>
<span class='curline'><a href='../S/218.html#L9230'>buffer</a>           9230 src/w32.c      sys_write (int fd, const void * buffer, unsigned int count)</span>
<span class='curline'><a href='../S/218.html#L9253'>buffer</a>           9253 src/w32.c      	  const unsigned char * src = buffer;</span>
<span class='curline'><a href='../S/218.html#L9281'>buffer</a>           9281 src/w32.c      	  buffer = tmpbuf;</span>
<span class='curline'><a href='../S/218.html#L9295'>buffer</a>           9295 src/w32.c            if (!WriteFile (hnd, buffer, count, (DWORD*) &amp;nchars, ovl))</span>
<span class='curline'><a href='../S/218.html#L9367'>buffer</a>           9367 src/w32.c            nchars =  pfn_send (SOCK_HANDLE (fd), buffer, count, 0);</span>
<span class='curline'><a href='../S/218.html#L9392'>buffer</a>           9392 src/w32.c            const unsigned char *p = buffer;</span>
<span class='curline'><a href='../S/218.html#L10346'>buffer</a>           10346 src/w32.c      	  char *buffer = alloca (1024</span>
<span class='curline'><a href='../S/218.html#L10349'>buffer</a>           10349 src/w32.c      	  char *msg = buffer;</span>
<span class='curline'><a href='../S/218.html#L10352'>buffer</a>           10352 src/w32.c      	  sprintf (buffer,</span>
<span class='curline'><a href='../S/218.html#L10363'>buffer</a>           10363 src/w32.c      					 buffer, -1, NULL, 0);</span>
<span class='curline'><a href='../S/218.html#L10368'>buffer</a>           10368 src/w32.c      	      pMultiByteToWideChar (CP_UTF8, multiByteToWideCharFlags, buffer,</span>
<span class='curline'><a href='../S/103.html#L177'>buffer</a>            177 src/w32fns.c     (IN HIMC context, IN DWORD index, OUT LPVOID buffer, IN DWORD bufLen);</span>
<span class='curline'><a href='../S/103.html#L4610'>buffer</a>           4610 src/w32fns.c   	  wchar_t * buffer;</span>
<span class='curline'><a href='../S/103.html#L4620'>buffer</a>           4620 src/w32fns.c   	  buffer = alloca (size);</span>
<span class='curline'><a href='../S/103.html#L4622'>buffer</a>           4622 src/w32fns.c   					    buffer, size);</span>
<span class='curline'><a href='../S/103.html#L4628'>buffer</a>           4628 src/w32fns.c   	      my_post_msg (&amp;wmsg, hwnd, WM_UNICHAR, (WPARAM) buffer[i],</span>
<span class='curline'><a href='../S/103.html#L7389'>buffer</a>           7389 src/w32fns.c     struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/103.html#L11127'>buffer</a>           11127 src/w32fns.c   w32_backtrace (void **buffer, int limit)</span>
<span class='curline'><a href='../S/103.html#L11140'>buffer</a>           11140 src/w32fns.c   					buffer, NULL);</span>
<span class='curline'><a href='../S/296.html#L286'>buffer</a>            286 src/w32menu.c        struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/296.html#L287'>buffer</a>            287 src/w32menu.c        Lisp_Object buffer;</span>
<span class='curline'><a href='../S/296.html#L299'>buffer</a>            299 src/w32menu.c        buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/296.html#L313'>buffer</a>            313 src/w32menu.c        set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/99.html#L592'>buffer</a>            592 src/w32select.c   char buffer[20] = "";</span>
<span class='curline'><a href='../S/99.html#L598'>buffer</a>            598 src/w32select.c   GetLocaleInfo (lcid, variant, buffer, sizeof (buffer));</span>
<span class='curline'><a href='../S/99.html#L599'>buffer</a>            599 src/w32select.c   cp = strtoul (buffer, NULL, 10);</span>
<span class='curline'><a href='../S/99.html#L612'>buffer</a>            612 src/w32select.c   char buffer[30];</span>
<span class='curline'><a href='../S/99.html#L613'>buffer</a>            613 src/w32select.c   sprintf (buffer, "cp%d-dos", (int) codepage);</span>
<span class='curline'><a href='../S/99.html#L614'>buffer</a>            614 src/w32select.c   return intern (buffer);</span>
<span class='curline'><a href='../S/313.html#L7423'>buffer</a>           7423 src/w32term.c    char *buffer = xmalloc (strlen (xrm_option) + 2);</span>
<span class='curline'><a href='../S/313.html#L7424'>buffer</a>           7424 src/w32term.c    char *current = buffer;</span>
<span class='curline'><a href='../S/313.html#L7459'>buffer</a>           7459 src/w32term.c    return buffer;</span>
<span class='curline'><a href='../S/326.html#L283'>buffer</a>            283 src/widget.c     char buffer[sizeof wmshell-&gt;wm.size_hints];</span>
<span class='curline'><a href='../S/326.html#L287'>buffer</a>            287 src/widget.c     memcpy (buffer, &amp;wmshell-&gt;wm.size_hints,</span>
<span class='curline'><a href='../S/326.html#L316'>buffer</a>            316 src/widget.c     return memcmp (hints_ptr + sizeof (long), buffer + sizeof (long),</span>
<span class='curline'><a href='../S/265.html#L230'>buffer</a>            230 src/window.c     struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/265.html#L280'>buffer</a>            280 src/window.c         struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/265.html#L1821'>buffer</a>           1821 src/window.c     struct buffer *b;</span>
<span class='curline'><a href='../S/265.html#L1841'>buffer</a>           1841 src/window.c         struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/265.html#L1892'>buffer</a>           1892 src/window.c   	  struct buffer *old_buffer = current_buffer;</span>
<span class='curline'><a href='../S/265.html#L1976'>buffer</a>           1976 src/window.c     struct buffer *buf;</span>
<span class='curline'><a href='../S/265.html#L2043'>buffer</a>           2043 src/window.c     register struct buffer *b;</span>
<span class='curline'><a href='../S/265.html#L2178'>buffer</a>           2178 src/window.c     struct buffer *b;</span>
<span class='curline'><a href='../S/265.html#L2414'>buffer</a>           2414 src/window.c         struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/265.html#L2440'>buffer</a>           2440 src/window.c     struct buffer *b = XBUFFER (buf);</span>
<span class='curline'><a href='../S/265.html#L2442'>buffer</a>           2442 src/window.c     eassert (b == XMARKER (w-&gt;pointm)-&gt;buffer);</span>
<span class='curline'><a href='../S/265.html#L3185'>buffer</a>           3185 src/window.c   		struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/265.html#L3189'>buffer</a>           3189 src/window.c   		if (!MARKERP (w-&gt;start) || XMARKER (w-&gt;start)-&gt;buffer != b)</span>
<span class='curline'><a href='../S/265.html#L3191'>buffer</a>           3191 src/window.c   		if (!MARKERP (w-&gt;pointm) || XMARKER (w-&gt;pointm)-&gt;buffer != b)</span>
<span class='curline'><a href='../S/265.html#L3233'>buffer</a>           3233 src/window.c     Lisp_Object buffer;</span>
<span class='curline'><a href='../S/265.html#L3236'>buffer</a>           3236 src/window.c       buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/265.html#L3238'>buffer</a>           3238 src/window.c       buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/265.html#L3240'>buffer</a>           3240 src/window.c     if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/265.html#L3241'>buffer</a>           3241 src/window.c       return window_loop (GET_BUFFER_WINDOW, buffer, true, all_frames);</span>
<span class='curline'><a href='../S/265.html#L3486'>buffer</a>           3486 src/window.c   	  struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/265.html#L3515'>buffer</a>           3515 src/window.c   replace_buffer_in_windows (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/265.html#L3520'>buffer</a>           3520 src/window.c       call1 (Qreplace_buffer_in_windows, buffer);</span>
<span class='curline'><a href='../S/265.html#L3527'>buffer</a>           3527 src/window.c   replace_buffer_in_windows_safely (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/265.html#L3529'>buffer</a>           3529 src/window.c     if (buffer_window_count (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/265.html#L3537'>buffer</a>           3537 src/window.c   	window_loop (REPLACE_BUFFER_IN_WINDOWS_SAFELY, buffer, true, frame);</span>
<span class='curline'><a href='../S/265.html#L3606'>buffer</a>           3606 src/window.c   	Lisp_Object buffer = Fwindow_buffer (window);</span>
<span class='curline'><a href='../S/265.html#L3608'>buffer</a>           3608 src/window.c   				      buffer)))</span>
<span class='curline'><a href='../S/265.html#L3614'>buffer</a>           3614 src/window.c   					   buffer));</span>
<span class='curline'><a href='../S/265.html#L3793'>buffer</a>           3793 src/window.c   run_window_change_functions_1 (Lisp_Object symbol, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/265.html#L3798'>buffer</a>           3798 src/window.c     if (NILP (buffer))</span>
<span class='curline'><a href='../S/265.html#L3800'>buffer</a>           3800 src/window.c     else if (!NILP (Fassoc (symbol, BVAR (XBUFFER (buffer), local_var_alist),</span>
<span class='curline'><a href='../S/265.html#L3803'>buffer</a>           3803 src/window.c       funs = buffer_local_value (symbol, buffer);</span>
<span class='curline'><a href='../S/265.html#L3808'>buffer</a>           3808 src/window.c   	  &amp;&amp; (NILP (buffer)</span>
<span class='curline'><a href='../S/265.html#L3940'>buffer</a>           3940 src/window.c   	  Lisp_Object buffer = WINDOW_BUFFER (w);</span>
<span class='curline'><a href='../S/265.html#L3954'>buffer</a>           3954 src/window.c   	     &amp;&amp; (!EQ (buffer, w-&gt;old_buffer)</span>
<span class='curline'><a href='../S/265.html#L3982'>buffer</a>           3982 src/window.c   	      (Qwindow_buffer_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/265.html#L3986'>buffer</a>           3986 src/window.c   	      (Qwindow_size_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/265.html#L3999'>buffer</a>           3999 src/window.c   	      (Qwindow_selection_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/265.html#L4014'>buffer</a>           4014 src/window.c   	      (Qwindow_state_change_functions, buffer, window);</span>
<span class='curline'><a href='../S/265.html#L4098'>buffer</a>           4098 src/window.c   set_window_buffer (Lisp_Object window, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/265.html#L4102'>buffer</a>           4102 src/window.c     struct buffer *b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/265.html#L4104'>buffer</a>           4104 src/window.c     bool samebuf = EQ (buffer, w-&gt;contents);</span>
<span class='curline'><a href='../S/265.html#L4106'>buffer</a>           4106 src/window.c     wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/265.html#L4131'>buffer</a>           4131 src/window.c         set_marker_both (w-&gt;pointm, buffer, BUF_PT (b), BUF_PT_BYTE (b));</span>
<span class='curline'><a href='../S/265.html#L4132'>buffer</a>           4132 src/window.c         set_marker_both (w-&gt;old_pointm, buffer, BUF_PT (b), BUF_PT_BYTE (b));</span>
<span class='curline'><a href='../S/265.html#L4135'>buffer</a>           4135 src/window.c   			     buffer);</span>
<span class='curline'><a href='../S/265.html#L4146'>buffer</a>           4146 src/window.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/265.html#L4204'>buffer</a>           4204 src/window.c     register Lisp_Object tem, buffer;</span>
<span class='curline'><a href='../S/265.html#L4208'>buffer</a>           4208 src/window.c     buffer = Fget_buffer (buffer_or_name);</span>
<span class='curline'><a href='../S/265.html#L4209'>buffer</a>           4209 src/window.c     CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/265.html#L4210'>buffer</a>           4210 src/window.c     if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/265.html#L4218'>buffer</a>           4218 src/window.c         if (!EQ (tem, buffer))</span>
<span class='curline'><a href='../S/265.html#L4235'>buffer</a>           4235 src/window.c     set_window_buffer (window, buffer, true, !NILP (keep_margins));</span>
<span class='curline'><a href='../S/265.html#L4241'>buffer</a>           4241 src/window.c   display_buffer (Lisp_Object buffer, Lisp_Object not_this_window_p, Lisp_Object override_frame)</span>
<span class='curline'><a href='../S/265.html#L4243'>buffer</a>           4243 src/window.c     return call3 (Qdisplay_buffer, buffer, not_this_window_p, override_frame);</span>
<span class='curline'><a href='../S/265.html#L4293'>buffer</a>           4293 src/window.c     register struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/265.html#L5580'>buffer</a>           5580 src/window.c     struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/265.html#L6591'>buffer</a>           6591 src/window.c     struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/265.html#L6654'>buffer</a>           6654 src/window.c     struct buffer *buf = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/265.html#L7023'>buffer</a>           7023 src/window.c     Lisp_Object window, buffer, start, pointm, old_pointm;</span>
<span class='curline'><a href='../S/265.html#L7162'>buffer</a>           7162 src/window.c   	      &amp;&amp; !EQ (w-&gt;contents, p-&gt;buffer)</span>
<span class='curline'><a href='../S/265.html#L7163'>buffer</a>           7163 src/window.c   	      &amp;&amp; BUFFER_LIVE_P (XBUFFER (p-&gt;buffer))</span>
<span class='curline'><a href='../S/265.html#L7164'>buffer</a>           7164 src/window.c   	      &amp;&amp; (NILP (Fminibufferp (p-&gt;buffer, Qnil))))</span>
<span class='curline'><a href='../S/265.html#L7294'>buffer</a>           7294 src/window.c   	      &amp;&amp; BUFFERP (p-&gt;buffer) &amp;&amp; BUFFER_LIVE_P (XBUFFER (p-&gt;buffer)))</span>
<span class='curline'><a href='../S/265.html#L7298'>buffer</a>           7298 src/window.c   	      wset_buffer (w, p-&gt;buffer);</span>
<span class='curline'><a href='../S/265.html#L7306'>buffer</a>           7306 src/window.c   	      if (!EQ (p-&gt;buffer, new_current_buffer)</span>
<span class='curline'><a href='../S/265.html#L7307'>buffer</a>           7307 src/window.c   		  &amp;&amp; XBUFFER (p-&gt;buffer) == current_buffer)</span>
<span class='curline'><a href='../S/265.html#L7314'>buffer</a>           7314 src/window.c   	      if (XMARKER (w-&gt;start)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/265.html#L7316'>buffer</a>           7316 src/window.c   	      if (XMARKER (w-&gt;pointm)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/265.html#L7321'>buffer</a>           7321 src/window.c   	      if (XMARKER (w-&gt;old_pointm)-&gt;buffer == 0)</span>
<span class='curline'><a href='../S/265.html#L7584'>buffer</a>           7584 src/window.c         p-&gt;buffer = (WINDOW_LEAF_P (w) ? w-&gt;contents : Qnil);</span>
<span class='curline'><a href='../S/265.html#L8290'>buffer</a>           8290 src/window.c   	  || !EQ (sw1-&gt;buffer, sw2-&gt;buffer)</span>
<span class='curline'><a href='../S/314.html#L1127'>buffer</a>           1127 src/window.h   void set_window_buffer (Lisp_Object window, Lisp_Object buffer,</span>
<span class='curline'><a href='../S/314.html#L1157'>buffer</a>           1157 src/window.h   extern void bset_redisplay (struct buffer *b);</span>
<span class='curline'><a href='../S/314.html#L1163'>buffer</a>           1163 src/window.h   extern void bset_update_mode_line (struct buffer *b);</span>
<span class='curline'><a href='../S/249.html#L694'>buffer</a>            694 src/xdisp.c    static struct buffer *this_line_buffer;</span>
<span class='curline'><a href='../S/249.html#L882'>buffer</a>            882 src/xdisp.c    bset_redisplay (struct buffer *b)</span>
<span class='curline'><a href='../S/249.html#L898'>buffer</a>            898 src/xdisp.c    bset_update_mode_line (struct buffer *b)</span>
<span class='curline'><a href='../S/249.html#L971'>buffer</a>            971 src/xdisp.c    static struct buffer *displayed_buffer;</span>
<span class='curline'><a href='../S/249.html#L1545'>buffer</a>           1545 src/xdisp.c      struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/249.html#L1592'>buffer</a>           1592 src/xdisp.c          struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L1690'>buffer</a>           1690 src/xdisp.c      struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/249.html#L4569'>buffer</a>           4569 src/xdisp.c          struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L11655'>buffer</a>           11655 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L11656'>buffer</a>           11656 src/xdisp.c      struct buffer *old_b = NULL;</span>
<span class='curline'><a href='../S/249.html#L11693'>buffer</a>           11693 src/xdisp.c      struct buffer *b = (NILP (buffer_or_name)</span>
<span class='curline'><a href='../S/249.html#L11696'>buffer</a>           11696 src/xdisp.c      Lisp_Object buffer, value;</span>
<span class='curline'><a href='../S/249.html#L11699'>buffer</a>           11699 src/xdisp.c      XSETBUFFER (buffer, b);</span>
<span class='curline'><a href='../S/249.html#L11711'>buffer</a>           11711 src/xdisp.c      if (!EQ (buffer, w-&gt;contents))</span>
<span class='curline'><a href='../S/249.html#L11713'>buffer</a>           11713 src/xdisp.c          wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/249.html#L11714'>buffer</a>           11714 src/xdisp.c          set_marker_both (w-&gt;pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/249.html#L11715'>buffer</a>           11715 src/xdisp.c          set_marker_both (w-&gt;old_pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/249.html#L11737'>buffer</a>           11737 src/xdisp.c      struct buffer *oldb = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L11819'>buffer</a>           11819 src/xdisp.c      char *buffer = SAFE_ALLOCA (len);</span>
<span class='curline'><a href='../S/249.html#L11820'>buffer</a>           11820 src/xdisp.c      memcpy (buffer, SDATA (msg), len);</span>
<span class='curline'><a href='../S/249.html#L11822'>buffer</a>           11822 src/xdisp.c      message_dolog (buffer, len - 1, true, STRING_MULTIBYTE (msg));</span>
<span class='curline'><a href='../S/249.html#L11856'>buffer</a>           11856 src/xdisp.c          struct buffer *oldbuf;</span>
<span class='curline'><a href='../S/249.html#L12090'>buffer</a>           12090 src/xdisp.c          char *buffer;</span>
<span class='curline'><a href='../S/249.html#L12092'>buffer</a>           12092 src/xdisp.c          SAFE_ALLOCA_STRING (buffer, m);</span>
<span class='curline'><a href='../S/249.html#L12093'>buffer</a>           12093 src/xdisp.c          message_dolog (buffer, nbytes, true, multibyte);</span>
<span class='curline'><a href='../S/249.html#L12393'>buffer</a>           12393 src/xdisp.c      Lisp_Object buffer;</span>
<span class='curline'><a href='../S/249.html#L12429'>buffer</a>           12429 src/xdisp.c      buffer = echo_area_buffer[this_one];</span>
<span class='curline'><a href='../S/249.html#L12433'>buffer</a>           12433 src/xdisp.c      if (echo_kboard == NULL &amp;&amp; EQ (buffer, echo_message_buffer))</span>
<span class='curline'><a href='../S/249.html#L12446'>buffer</a>           12446 src/xdisp.c      set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/249.html#L12449'>buffer</a>           12449 src/xdisp.c          wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/249.html#L12450'>buffer</a>           12450 src/xdisp.c          set_marker_both (w-&gt;pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/249.html#L12451'>buffer</a>           12451 src/xdisp.c          set_marker_both (w-&gt;old_pointm, buffer, BEG, BEG_BYTE);</span>
<span class='curline'><a href='../S/249.html#L12532'>buffer</a>           12532 src/xdisp.c          Lisp_Object buffer;</span>
<span class='curline'><a href='../S/249.html#L12535'>buffer</a>           12535 src/xdisp.c          buffer = AREF (vector, 4);</span>
<span class='curline'><a href='../S/249.html#L12537'>buffer</a>           12537 src/xdisp.c          wset_buffer (w, buffer);</span>
<span class='curline'><a href='../S/249.html#L12538'>buffer</a>           12538 src/xdisp.c          set_marker_restricted_both (w-&gt;pointm, buffer,</span>
<span class='curline'><a href='../S/249.html#L12541'>buffer</a>           12541 src/xdisp.c          set_marker_restricted_both (w-&gt;old_pointm, buffer,</span>
<span class='curline'><a href='../S/249.html#L12544'>buffer</a>           12544 src/xdisp.c          set_marker_restricted_both (w-&gt;start, buffer,</span>
<span class='curline'><a href='../S/249.html#L12797'>buffer</a>           12797 src/xdisp.c          struct buffer *old_current_buffer = NULL;</span>
<span class='curline'><a href='../S/249.html#L13309'>buffer</a>           13309 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L13394'>buffer</a>           13394 src/xdisp.c    			      struct buffer *obuf,</span>
<span class='curline'><a href='../S/249.html#L13423'>buffer</a>           13423 src/xdisp.c          Lisp_Object buffer = XWINDOW (target_frame-&gt;selected_window)-&gt;contents;</span>
<span class='curline'><a href='../S/249.html#L13424'>buffer</a>           13424 src/xdisp.c          struct buffer *b = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/249.html#L13425'>buffer</a>           13425 src/xdisp.c          struct buffer *cb = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L13437'>buffer</a>           13437 src/xdisp.c          ASET (vector, 10, buffer);</span>
<span class='curline'><a href='../S/249.html#L13489'>buffer</a>           13489 src/xdisp.c    	  Lisp_Object buffer = AREF (vector, 10);</span>
<span class='curline'><a href='../S/249.html#L13491'>buffer</a>           13491 src/xdisp.c    	  if (BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/249.html#L13493'>buffer</a>           13493 src/xdisp.c    	      struct buffer *cb = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L13495'>buffer</a>           13495 src/xdisp.c    	      current_buffer = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/249.html#L13690'>buffer</a>           13690 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L13697'>buffer</a>           13697 src/xdisp.c              &amp;&amp; !buffer-&gt;text-&gt;redisplay</span>
<span class='curline'><a href='../S/249.html#L13867'>buffer</a>           13867 src/xdisp.c    	  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L14034'>buffer</a>           14034 src/xdisp.c    	  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L15002'>buffer</a>           15002 src/xdisp.c    	  struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L16104'>buffer</a>           16104 src/xdisp.c    	      struct buffer *saved_current_buffer;</span>
<span class='curline'><a href='../S/249.html#L16206'>buffer</a>           16206 src/xdisp.c    		  struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L16413'>buffer</a>           16413 src/xdisp.c    	  &amp;&amp; current_buffer == XMARKER (val)-&gt;buffer)</span>
<span class='curline'><a href='../S/249.html#L16450'>buffer</a>           16450 src/xdisp.c    	  struct buffer *buf = XMARKER (val)-&gt;buffer;</span>
<span class='curline'><a href='../S/249.html#L16522'>buffer</a>           16522 src/xdisp.c    	  &amp;&amp; current_buffer == XMARKER (val)-&gt;buffer</span>
<span class='curline'><a href='../S/249.html#L16552'>buffer</a>           16552 src/xdisp.c    check_point_in_composition (struct buffer *prev_buf, ptrdiff_t prev_pt,</span>
<span class='curline'><a href='../S/249.html#L16553'>buffer</a>           16553 src/xdisp.c    			    struct buffer *buf, ptrdiff_t pt)</span>
<span class='curline'><a href='../S/249.html#L16557'>buffer</a>           16557 src/xdisp.c      Lisp_Object buffer;</span>
<span class='curline'><a href='../S/249.html#L16559'>buffer</a>           16559 src/xdisp.c      XSETBUFFER (buffer, buf);</span>
<span class='curline'><a href='../S/249.html#L16569'>buffer</a>           16569 src/xdisp.c    	  &amp;&amp; find_composition (prev_pt, -1, &amp;start, &amp;end, &amp;prop, buffer)</span>
<span class='curline'><a href='../S/249.html#L16579'>buffer</a>           16579 src/xdisp.c    	  &amp;&amp; find_composition (pt, -1, &amp;start, &amp;end, &amp;prop, buffer)</span>
<span class='curline'><a href='../S/249.html#L16589'>buffer</a>           16589 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L16593'>buffer</a>           16593 src/xdisp.c          &amp;&amp; w-&gt;current_matrix-&gt;buffer == b</span>
<span class='curline'><a href='../S/249.html#L16607'>buffer</a>           16607 src/xdisp.c          if ((w-&gt;current_matrix-&gt;buffer != b || pt != w-&gt;last_point)</span>
<span class='curline'><a href='../S/249.html#L16608'>buffer</a>           16608 src/xdisp.c    	  &amp;&amp; check_point_in_composition (w-&gt;current_matrix-&gt;buffer,</span>
<span class='curline'><a href='../S/249.html#L16630'>buffer</a>           16630 src/xdisp.c          struct buffer *thisb = XBUFFER (thisw-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L17594'>buffer</a>           17594 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L17618'>buffer</a>           17618 src/xdisp.c          w-&gt;current_matrix-&gt;buffer = b;</span>
<span class='curline'><a href='../S/249.html#L17641'>buffer</a>           17641 src/xdisp.c          if (XMARKER (BVAR (b, mark))-&gt;buffer == b</span>
<span class='curline'><a href='../S/249.html#L19548'>buffer</a>           19548 src/xdisp.c          struct buffer *buf = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L19561'>buffer</a>           19561 src/xdisp.c    	  struct buffer *obuf = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L19596'>buffer</a>           19596 src/xdisp.c          struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L19597'>buffer</a>           19597 src/xdisp.c          struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/249.html#L19744'>buffer</a>           19744 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L19745'>buffer</a>           19745 src/xdisp.c      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L19777'>buffer</a>           19777 src/xdisp.c      eassert (XMARKER (w-&gt;start)-&gt;buffer == buffer);</span>
<span class='curline'><a href='../S/249.html#L19778'>buffer</a>           19778 src/xdisp.c      eassert (XMARKER (w-&gt;pointm)-&gt;buffer == buffer);</span>
<span class='curline'><a href='../S/249.html#L19788'>buffer</a>           19788 src/xdisp.c    		      || buffer-&gt;clip_changed</span>
<span class='curline'><a href='../S/249.html#L19789'>buffer</a>           19789 src/xdisp.c    		      || buffer-&gt;prevent_redisplay_optimizations_p);</span>
<span class='curline'><a href='../S/249.html#L19872'>buffer</a>           19872 src/xdisp.c          if (XMARKER (w-&gt;start)-&gt;buffer == current_buffer)</span>
<span class='curline'><a href='../S/249.html#L19929'>buffer</a>           19929 src/xdisp.c    	  struct buffer *buf = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L19958'>buffer</a>           19958 src/xdisp.c      if (XMARKER (w-&gt;start)-&gt;buffer != current_buffer)</span>
<span class='curline'><a href='../S/249.html#L20296'>buffer</a>           20296 src/xdisp.c    	  &amp;&amp; XMARKER (w-&gt;start)-&gt;buffer == current_buffer</span>
<span class='curline'><a href='../S/249.html#L22869'>buffer</a>           22869 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L22872'>buffer</a>           22872 src/xdisp.c    	   BUF_PT (buffer), BUF_BEGV (buffer), BUF_ZV (buffer));</span>
<span class='curline'><a href='../S/249.html#L23040'>buffer</a>           23040 src/xdisp.c      struct buffer *buffer = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L23041'>buffer</a>           23041 src/xdisp.c      struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L23050'>buffer</a>           23050 src/xdisp.c      set_buffer_temp (buffer);</span>
<span class='curline'><a href='../S/249.html#L23056'>buffer</a>           23056 src/xdisp.c      multibyte_p = !NILP (BVAR (buffer, enable_multibyte_characters));</span>
<span class='curline'><a href='../S/249.html#L25886'>buffer</a>           25886 src/xdisp.c      (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/249.html#L25888'>buffer</a>           25888 src/xdisp.c      struct buffer *buf = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L25889'>buffer</a>           25889 src/xdisp.c      struct buffer *old = buf;</span>
<span class='curline'><a href='../S/249.html#L25891'>buffer</a>           25891 src/xdisp.c      if (! NILP (buffer))</span>
<span class='curline'><a href='../S/249.html#L25893'>buffer</a>           25893 src/xdisp.c          CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/249.html#L25894'>buffer</a>           25894 src/xdisp.c          buf = XBUFFER (buffer);</span>
<span class='curline'><a href='../S/249.html#L26010'>buffer</a>           26010 src/xdisp.c      struct buffer *buf = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L26011'>buffer</a>           26011 src/xdisp.c      struct buffer *old = buf;</span>
<span class='curline'><a href='../S/249.html#L26128'>buffer</a>           26128 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L26602'>buffer</a>           26602 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L27000'>buffer</a>           27000 src/xdisp.c    	  struct buffer *old = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L27901'>buffer</a>           27901 src/xdisp.c          Lisp_Object window, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/249.html#L27906'>buffer</a>           27906 src/xdisp.c      struct buffer *old_buffer = NULL;</span>
<span class='curline'><a href='../S/249.html#L27916'>buffer</a>           27916 src/xdisp.c      if (NILP (buffer))</span>
<span class='curline'><a href='../S/249.html#L27917'>buffer</a>           27917 src/xdisp.c        buffer = w-&gt;contents;</span>
<span class='curline'><a href='../S/249.html#L27918'>buffer</a>           27918 src/xdisp.c      CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/249.html#L27919'>buffer</a>           27919 src/xdisp.c      if (!BUFFER_LIVE_P (XBUFFER (buffer)))</span>
<span class='curline'><a href='../S/249.html#L27952'>buffer</a>           27952 src/xdisp.c      set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/249.html#L28248'>buffer</a>           28248 src/xdisp.c      struct buffer *b = current_buffer;</span>
<span class='curline'><a href='../S/249.html#L33272'>buffer</a>           33272 src/xdisp.c      struct buffer *b = XBUFFER (w-&gt;contents);</span>
<span class='curline'><a href='../S/249.html#L35416'>buffer</a>           35416 src/xdisp.c      struct buffer *b;</span>
<span class='curline'><a href='../S/249.html#L35637'>buffer</a>           35637 src/xdisp.c          struct buffer *obuf;</span>
<span class='curline'><a href='../S/249.html#L35834'>buffer</a>           35834 src/xdisp.c    	      Lisp_Object buffer UNINIT;</span>
<span class='curline'><a href='../S/249.html#L35848'>buffer</a>           35848 src/xdisp.c    		      buffer = w-&gt;contents;</span>
<span class='curline'><a href='../S/249.html#L35854'>buffer</a>           35854 src/xdisp.c    		  buffer = object;</span>
<span class='curline'><a href='../S/249.html#L35873'>buffer</a>           35873 src/xdisp.c    		    = NILP (BVAR (XBUFFER (buffer), bidi_display_reordering))</span>
<span class='curline'><a href='../S/249.html#L35877'>buffer</a>           35877 src/xdisp.c    		    = NILP (BVAR (XBUFFER (buffer), bidi_display_reordering))</span>
<span class='curline'><a href='../S/249.html#L35878'>buffer</a>           35878 src/xdisp.c    		    ? make_fixnum (BUF_Z (XBUFFER (buffer))</span>
<span class='curline'><a href='../S/249.html#L35886'>buffer</a>           35886 src/xdisp.c    			(make_fixnum (pos + 1), Qmouse_face, buffer, lim1);</span>
<span class='curline'><a href='../S/249.html#L35888'>buffer</a>           35888 src/xdisp.c    			(make_fixnum (pos), Qmouse_face, buffer, lim2);</span>
<span class='curline'><a href='../S/249.html#L35908'>buffer</a>           35908 src/xdisp.c    					      ? BUF_Z (XBUFFER (buffer))</span>
<span class='curline'><a href='../S/249.html#L36428'>buffer</a>           36428 src/xdisp.c          struct buffer *oldbuf = current_buffer;</span>
<span class='curline'><a href='../S/72.html#L9022'>buffer</a>           9022 src/xfns.c       struct buffer *old_buffer;</span>
<span class='curline'><a href='../S/81.html#L967'>buffer</a>            967 src/xmenu.c          struct buffer *prev = current_buffer;</span>
<span class='curline'><a href='../S/81.html#L968'>buffer</a>            968 src/xmenu.c          Lisp_Object buffer;</span>
<span class='curline'><a href='../S/81.html#L980'>buffer</a>            980 src/xmenu.c          buffer = XWINDOW (FRAME_SELECTED_WINDOW (f))-&gt;contents;</span>
<span class='curline'><a href='../S/81.html#L993'>buffer</a>            993 src/xmenu.c          set_buffer_internal_1 (XBUFFER (buffer));</span>
<span class='curline'><a href='../S/48.html#L2417'>buffer</a>           2417 src/xterm.c      char *buffer;</span>
<span class='curline'><a href='../S/48.html#L2465'>buffer</a>           2465 src/xterm.c      buffer = dpyinfo-&gt;motif_drag_atom_name;</span>
<span class='curline'><a href='../S/48.html#L2469'>buffer</a>           2469 src/xterm.c          sprintf (buffer, "_EMACS_ATOM_%lu", i + 1);</span>
<span class='curline'><a href='../S/48.html#L2483'>buffer</a>           2483 src/xterm.c          sprintf (buffer, "_EMACS_ATOM_%lu", nitems + 1);</span>
<span class='curline'><a href='../S/48.html#L2484'>buffer</a>           2484 src/xterm.c          atom = XInternAtom (dpyinfo-&gt;display, buffer, False);</span>
<span class='curline'><a href='../S/48.html#L29601'>buffer</a>           29601 src/xterm.c      char *dpyinfo_pointer, *name, *value, *buffer;</span>
<span class='curline'><a href='../S/48.html#L29611'>buffer</a>           29611 src/xterm.c      buffer = alloca (45 + INT_STRLEN_BOUND (int));</span>
<span class='curline'><a href='../S/48.html#L29652'>buffer</a>           29652 src/xterm.c    	  sprintf (buffer, "_XSETTINGS_S%d",</span>
<span class='curline'><a href='../S/48.html#L29654'>buffer</a>           29654 src/xterm.c    	  return xstrdup (buffer);</span>
<span class='curline'><a href='../S/48.html#L29659'>buffer</a>           29659 src/xterm.c    	  sprintf (buffer, "_NET_WM_CM_S%d",</span>
<span class='curline'><a href='../S/48.html#L29661'>buffer</a>           29661 src/xterm.c    	  return xstrdup (buffer);</span>
<span class='curline'><a href='../S/60.html#L214'>buffer</a>            214 src/xwidget.c    if (NILP (xw-&gt;buffer))</span>
<span class='curline'><a href='../S/60.html#L297'>buffer</a>            297 src/xwidget.c     Lisp_Object arguments, Lisp_Object buffer, Lisp_Object related)</span>
<span class='curline'><a href='../S/60.html#L316'>buffer</a>            316 src/xwidget.c    xw-&gt;buffer = (NILP (buffer) ? Fcurrent_buffer ()</span>
<span class='curline'><a href='../S/60.html#L317'>buffer</a>            317 src/xwidget.c  		: Fget_buffer_create (buffer, Qnil));</span>
<span class='curline'><a href='../S/60.html#L467'>buffer</a>            467 src/xwidget.c  	   &amp;&amp; !NILP (XXWIDGET (object)-&gt;buffer))</span>
<span class='curline'><a href='../S/60.html#L679'>buffer</a>            679 src/xwidget.c    (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/60.html#L683'>buffer</a>            683 src/xwidget.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/60.html#L685'>buffer</a>            685 src/xwidget.c    buffer = Fget_buffer (buffer);</span>
<span class='curline'><a href='../S/60.html#L686'>buffer</a>            686 src/xwidget.c    if (NILP (buffer))</span>
<span class='curline'><a href='../S/60.html#L694'>buffer</a>            694 src/xwidget.c        if (XWIDGETP (xw) &amp;&amp; EQ (Fxwidget_buffer (xw), buffer))</span>
<span class='curline'><a href='../S/60.html#L1311'>buffer</a>           1311 src/xwidget.c    if (NILP (XXWIDGET (view-&gt;model)-&gt;buffer))</span>
<span class='curline'><a href='../S/60.html#L1378'>buffer</a>           1378 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/60.html#L1430'>buffer</a>           1430 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/60.html#L1480'>buffer</a>           1480 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/60.html#L1934'>buffer</a>           1934 src/xwidget.c    if (NILP (model-&gt;buffer))</span>
<span class='curline'><a href='../S/60.html#L2169'>buffer</a>           2169 src/xwidget.c    if (NILP (w-&gt;buffer))</span>
<span class='curline'><a href='../S/60.html#L2201'>buffer</a>           2201 src/xwidget.c    if (NILP (w-&gt;buffer))</span>
<span class='curline'><a href='../S/60.html#L2989'>buffer</a>           2989 src/xwidget.c    if (!NILP (xww-&gt;buffer))</span>
<span class='curline'><a href='../S/60.html#L3009'>buffer</a>           3009 src/xwidget.c    if (!NILP (xww-&gt;buffer))</span>
<span class='curline'><a href='../S/60.html#L3022'>buffer</a>           3022 src/xwidget.c    if (NILP (xw-&gt;buffer) || !EQ (xw-&gt;type, Qwebkit))	\</span>
<span class='curline'><a href='../S/60.html#L3412'>buffer</a>           3412 src/xwidget.c    if (xw-&gt;embedder_view == xv &amp;&amp; !NILP (xw-&gt;buffer))</span>
<span class='curline'><a href='../S/60.html#L3474'>buffer</a>           3474 src/xwidget.c    return XXWIDGET (xwidget)-&gt;buffer;</span>
<span class='curline'><a href='../S/60.html#L3481'>buffer</a>           3481 src/xwidget.c    (Lisp_Object xwidget, Lisp_Object buffer)</span>
<span class='curline'><a href='../S/60.html#L3484'>buffer</a>           3484 src/xwidget.c    CHECK_BUFFER (buffer);</span>
<span class='curline'><a href='../S/60.html#L3486'>buffer</a>           3486 src/xwidget.c    XXWIDGET (xwidget)-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/60.html#L4225'>buffer</a>           4225 src/xwidget.c    xw-&gt;buffer = Qnil;</span>
<span class='curline'><a href='../S/60.html#L4259'>buffer</a>           4259 src/xwidget.c  kill_buffer_xwidgets (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/60.html#L4262'>buffer</a>           4262 src/xwidget.c    for (tail = Fget_buffer_xwidgets (buffer); CONSP (tail); tail = XCDR (tail))</span>
<span class='curline'><a href='../S/65.html#L61'>buffer</a>             61 src/xwidget.h    Lisp_Object buffer;</span>
<span class='curline'><a href='../S/65.html#L163'>buffer</a>            163 src/xwidget.h  #define XWIDGET_LIVE_P(w) (!NILP ((w)-&gt;buffer))</span>
<span class='curline'><a href='../S/3680.html#L221'>buffer</a>            221 test/manual/etags/c-src/abbrev.c   register char *buffer, *p;</span>
<span class='curline'><a href='../S/3680.html#L270'>buffer</a>            270 test/manual/etags/c-src/abbrev.c   p = buffer = (char *) alloca (wordend_byte - wordstart_byte);</span>
<span class='curline'><a href='../S/3680.html#L284'>buffer</a>            284 test/manual/etags/c-src/abbrev.c     sym = oblookup (current_buffer-&gt;abbrev_table, buffer,</span>
<span class='curline'><a href='../S/3680.html#L289'>buffer</a>            289 test/manual/etags/c-src/abbrev.c     sym = oblookup (Vglobal_abbrev_table, buffer,</span>
<span class='curline'><a href='../S/3693.html#L313'>buffer</a>            313 test/manual/etags/c-src/emacs/src/keyboard.c static void recursive_edit_unwind (Lisp_Object buffer);</span>
<span class='curline'><a href='../S/3693.html#L447'>buffer</a>            447 test/manual/etags/c-src/emacs/src/keyboard.c   char *buffer = initbuf;</span>
<span class='curline'><a href='../S/3693.html#L448'>buffer</a>            448 test/manual/etags/c-src/emacs/src/keyboard.c   char *ptr = buffer;</span>
<span class='curline'><a href='../S/3693.html#L464'>buffer</a>            464 test/manual/etags/c-src/emacs/src/keyboard.c       if (size - (ptr - buffer) &lt; nbytes)</span>
<span class='curline'><a href='../S/3693.html#L466'>buffer</a>            466 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptrdiff_t offset = ptr - buffer;</span>
<span class='curline'><a href='../S/3693.html#L468'>buffer</a>            468 test/manual/etags/c-src/emacs/src/keyboard.c 	  buffer = SAFE_ALLOCA (size);</span>
<span class='curline'><a href='../S/3693.html#L469'>buffer</a>            469 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptr = buffer + offset;</span>
<span class='curline'><a href='../S/3693.html#L482'>buffer</a>            482 test/manual/etags/c-src/emacs/src/keyboard.c       if (size - (ptr - buffer) &lt; len)</span>
<span class='curline'><a href='../S/3693.html#L484'>buffer</a>            484 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptrdiff_t offset = ptr - buffer;</span>
<span class='curline'><a href='../S/3693.html#L486'>buffer</a>            486 test/manual/etags/c-src/emacs/src/keyboard.c 	  buffer = SAFE_ALLOCA (size);</span>
<span class='curline'><a href='../S/3693.html#L487'>buffer</a>            487 test/manual/etags/c-src/emacs/src/keyboard.c 	  ptr = buffer + offset;</span>
<span class='curline'><a href='../S/3693.html#L519'>buffer</a>            519 test/manual/etags/c-src/emacs/src/keyboard.c      concat2 (echo_string, make_string (buffer, ptr - buffer)));</span>
<span class='curline'><a href='../S/3693.html#L772'>buffer</a>            772 test/manual/etags/c-src/emacs/src/keyboard.c   Lisp_Object buffer;</span>
<span class='curline'><a href='../S/3693.html#L781'>buffer</a>            781 test/manual/etags/c-src/emacs/src/keyboard.c     buffer = Fcurrent_buffer ();</span>
<span class='curline'><a href='../S/3693.html#L783'>buffer</a>            783 test/manual/etags/c-src/emacs/src/keyboard.c     buffer = Qnil;</span>
<span class='curline'><a href='../S/3693.html#L790'>buffer</a>            790 test/manual/etags/c-src/emacs/src/keyboard.c   record_unwind_protect (recursive_edit_unwind, buffer);</span>
<span class='curline'><a href='../S/3693.html#L804'>buffer</a>            804 test/manual/etags/c-src/emacs/src/keyboard.c recursive_edit_unwind (Lisp_Object buffer)</span>
<span class='curline'><a href='../S/3693.html#L806'>buffer</a>            806 test/manual/etags/c-src/emacs/src/keyboard.c   if (BUFFERP (buffer))</span>
<span class='curline'><a href='../S/3693.html#L807'>buffer</a>            807 test/manual/etags/c-src/emacs/src/keyboard.c     Fset_buffer (buffer);</span>
<span class='curline'><a href='../S/3693.html#L1300'>buffer</a>           1300 test/manual/etags/c-src/emacs/src/keyboard.c   struct buffer *prev_buffer = NULL;</span>
<span class='curline'><a href='../S/3693.html#L1442'>buffer</a>           1442 test/manual/etags/c-src/emacs/src/keyboard.c 	  struct buffer *b;</span>
<span class='curline'><a href='../S/3693.html#L1596'>buffer</a>           1596 test/manual/etags/c-src/emacs/src/keyboard.c 		  &amp;&amp; XMARKER (BVAR (current_buffer, mark))-&gt;buffer</span>
<span class='curline'><a href='../S/3693.html#L2918'>buffer</a>           2918 test/manual/etags/c-src/emacs/src/keyboard.c       struct buffer *prev_buffer = current_buffer;</span>
<span class='curline'><a href='../S/3693.html#L8981'>buffer</a>           8981 test/manual/etags/c-src/emacs/src/keyboard.c   struct buffer *starting_buffer;</span>
<span class='curline'><a href='../S/3694.html#L1027'>buffer</a>           1027 test/manual/etags/c-src/emacs/src/lisp.h INLINE struct buffer *</span>
<span class='curline'><a href='../S/3694.html#L2000'>buffer</a>           2000 test/manual/etags/c-src/emacs/src/lisp.h   struct buffer *buffer;</span>
<span class='curline'><a href='../S/3694.html#L3624'>buffer</a>           3624 test/manual/etags/c-src/emacs/src/lisp.h extern void make_gap_1 (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/3694.html#L3638'>buffer</a>           3638 test/manual/etags/c-src/emacs/src/lisp.h extern void insert_from_buffer (struct buffer *, ptrdiff_t, ptrdiff_t, bool);</span>
<span class='curline'><a href='../S/3694.html#L3655'>buffer</a>           3655 test/manual/etags/c-src/emacs/src/lisp.h extern void invalidate_buffer_caches (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/3694.html#L3884'>buffer</a>           3884 test/manual/etags/c-src/emacs/src/lisp.h extern struct buffer * allocate_buffer (void);</span>
<span class='curline'><a href='../S/3694.html#L4088'>buffer</a>           4088 test/manual/etags/c-src/emacs/src/lisp.h extern void clear_charpos_cache (struct buffer *);</span>
<span class='curline'><a href='../S/3694.html#L4089'>buffer</a>           4089 test/manual/etags/c-src/emacs/src/lisp.h extern ptrdiff_t buf_charpos_to_bytepos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/3694.html#L4090'>buffer</a>           4090 test/manual/etags/c-src/emacs/src/lisp.h extern ptrdiff_t buf_bytepos_to_charpos (struct buffer *, ptrdiff_t);</span>
<span class='curline'><a href='../S/3694.html#L4096'>buffer</a>           4096 test/manual/etags/c-src/emacs/src/lisp.h extern Lisp_Object build_marker (struct buffer *, ptrdiff_t, ptrdiff_t);</span>
<span class='curline'><a href='../S/3694.html#L4329'>buffer</a>           4329 test/manual/etags/c-src/emacs/src/lisp.h extern void truncate_undo_list (struct buffer *);</span>
<span class='curline'><a href='../S/3694.html#L4386'>buffer</a>           4386 test/manual/etags/c-src/emacs/src/lisp.h extern void unlock_buffer (struct buffer *);</span>
<span class='curline'><a href='../S/3695.html#L341'>buffer</a>            341 test/manual/etags/c-src/emacs/src/regex.h   unsigned char *buffer;</span>
<span class='curline'><a href='../S/3691.html#L238'>buffer</a>            238 test/manual/etags/c-src/etags.c   char *buffer;</span>
<span class='curline'><a href='../S/3691.html#L1213'>buffer</a>           1213 test/manual/etags/c-src/etags.c 		    process_file_name (filename_lb.buffer, lang);</span>
<span class='curline'><a href='../S/3691.html#L1226'>buffer</a>           1226 test/manual/etags/c-src/etags.c   free (lb.buffer);</span>
<span class='curline'><a href='../S/3691.html#L1227'>buffer</a>           1227 test/manual/etags/c-src/etags.c   free (filebuf.buffer);</span>
<span class='curline'><a href='../S/3691.html#L1228'>buffer</a>           1228 test/manual/etags/c-src/etags.c   free (token_name.buffer);</span>
<span class='curline'><a href='../S/3691.html#L1683'>buffer</a>           1683 test/manual/etags/c-src/etags.c       &amp;&amp; lb.buffer[0] == '#'</span>
<span class='curline'><a href='../S/3691.html#L1684'>buffer</a>           1684 test/manual/etags/c-src/etags.c       &amp;&amp; lb.buffer[1] == '!')</span>
<span class='curline'><a href='../S/3691.html#L1691'>buffer</a>           1691 test/manual/etags/c-src/etags.c       lp = strrchr (lb.buffer+2, '/');</span>
<span class='curline'><a href='../S/3691.html#L1695'>buffer</a>           1695 test/manual/etags/c-src/etags.c 	lp = skip_spaces (lb.buffer + 2);</span>
<span class='curline'><a href='../S/3691.html#L2573'>buffer</a>           2573 test/manual/etags/c-src/etags.c       cn-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/3691.html#L2579'>buffer</a>           2579 test/manual/etags/c-src/etags.c       strcpy (cn-&gt;buffer, cstack.cname[0]);</span>
<span class='curline'><a href='../S/3691.html#L2587'>buffer</a>           2587 test/manual/etags/c-src/etags.c       len += sprintf (cn-&gt;buffer + len, "%s%s", qualifier, s);</span>
<span class='curline'><a href='../S/3691.html#L2803'>buffer</a>           2803 test/manual/etags/c-src/etags.c 	   memcpy (token_name.buffer, str, len);</span>
<span class='curline'><a href='../S/3691.html#L2804'>buffer</a>           2804 test/manual/etags/c-src/etags.c 	   token_name.buffer[len] = '\0';</span>
<span class='curline'><a href='../S/3691.html#L2819'>buffer</a>           2819 test/manual/etags/c-src/etags.c 	   memcpy (token_name.buffer + oldlen, str, len);</span>
<span class='curline'><a href='../S/3691.html#L2820'>buffer</a>           2820 test/manual/etags/c-src/etags.c 	   token_name.buffer[oldlen + len] = '\0';</span>
<span class='curline'><a href='../S/3691.html#L2942'>buffer</a>           2942 test/manual/etags/c-src/etags.c   lp = curlb.buffer;							\</span>
<span class='curline'><a href='../S/3691.html#L2965'>buffer</a>           2965 test/manual/etags/c-src/etags.c     make_tag (token_name.buffer, token_name.len, isfun, token.line,</span>
<span class='curline'><a href='../S/3691.html#L2969'>buffer</a>           2969 test/manual/etags/c-src/etags.c       make_tag (concat ("INVALID TOKEN:--&gt;", token_name.buffer, ""),</span>
<span class='curline'><a href='../S/3691.html#L3020'>buffer</a>           3020 test/manual/etags/c-src/etags.c   lp = curlb.buffer;</span>
<span class='curline'><a href='../S/3691.html#L3170'>buffer</a>           3170 test/manual/etags/c-src/etags.c 	      for (cp = newlb.buffer; cp &lt; lp-1; cp++)</span>
<span class='curline'><a href='../S/3691.html#L3243'>buffer</a>           3243 test/manual/etags/c-src/etags.c 			  || consider_token (newlb.buffer + tokoff, toklen, c,</span>
<span class='curline'><a href='../S/3691.html#L3268'>buffer</a>           3268 test/manual/etags/c-src/etags.c 			      sprintf (token_name.buffer + len, "%s%.*s",</span>
<span class='curline'><a href='../S/3691.html#L3269'>buffer</a>           3269 test/manual/etags/c-src/etags.c 				       qualifier, toklen, newlb.buffer + tokoff);</span>
<span class='curline'><a href='../S/3691.html#L3277'>buffer</a>           3277 test/manual/etags/c-src/etags.c 			      sprintf (token_name.buffer, "%s(%.*s)",</span>
<span class='curline'><a href='../S/3691.html#L3278'>buffer</a>           3278 test/manual/etags/c-src/etags.c 				       objtag, toklen, newlb.buffer + tokoff);</span>
<span class='curline'><a href='../S/3691.html#L3290'>buffer</a>           3290 test/manual/etags/c-src/etags.c 			      bool defun = (newlb.buffer[tokoff] == 'F');</span>
<span class='curline'><a href='../S/3691.html#L3302'>buffer</a>           3302 test/manual/etags/c-src/etags.c 			      memcpy (token_name.buffer,</span>
<span class='curline'><a href='../S/3691.html#L3303'>buffer</a>           3303 test/manual/etags/c-src/etags.c 				      newlb.buffer + off, len);</span>
<span class='curline'><a href='../S/3691.html#L3304'>buffer</a>           3304 test/manual/etags/c-src/etags.c 			      token_name.buffer[len] = '\0';</span>
<span class='curline'><a href='../S/3691.html#L3307'>buffer</a>           3307 test/manual/etags/c-src/etags.c 				  if (token_name.buffer[len] == '_')</span>
<span class='curline'><a href='../S/3691.html#L3308'>buffer</a>           3308 test/manual/etags/c-src/etags.c 				    token_name.buffer[len] = '-';</span>
<span class='curline'><a href='../S/3691.html#L3314'>buffer</a>           3314 test/manual/etags/c-src/etags.c 			      memcpy (token_name.buffer,</span>
<span class='curline'><a href='../S/3691.html#L3315'>buffer</a>           3315 test/manual/etags/c-src/etags.c 				      newlb.buffer + tokoff, toklen);</span>
<span class='curline'><a href='../S/3691.html#L3316'>buffer</a>           3316 test/manual/etags/c-src/etags.c 			      token_name.buffer[toklen] = '\0';</span>
<span class='curline'><a href='../S/3691.html#L3331'>buffer</a>           3331 test/manual/etags/c-src/etags.c 			  token.line = newlb.buffer;</span>
<span class='curline'><a href='../S/3691.html#L3402'>buffer</a>           3402 test/manual/etags/c-src/etags.c 	      if (!yacc_rules || lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/3691.html#L3404'>buffer</a>           3404 test/manual/etags/c-src/etags.c 		  tokoff = lp - 1 - newlb.buffer;</span>
<span class='curline'><a href='../S/3691.html#L3438'>buffer</a>           3438 test/manual/etags/c-src/etags.c 	      strcpy (token_name.buffer + toklen, ":");</span>
<span class='curline'><a href='../S/3691.html#L3726'>buffer</a>           3726 test/manual/etags/c-src/etags.c 	  if (!ignoreindent &amp;&amp; lp == newlb.buffer + 1)</span>
<span class='curline'><a href='../S/3691.html#L3824'>buffer</a>           3824 test/manual/etags/c-src/etags.c   free (lbs[0].lb.buffer);</span>
<span class='curline'><a href='../S/3691.html#L3825'>buffer</a>           3825 test/manual/etags/c-src/etags.c   free (lbs[1].lb.buffer);</span>
<span class='curline'><a href='../S/3691.html#L3880'>buffer</a>           3880 test/manual/etags/c-src/etags.c            char_pointer = line_buffer.buffer,				\</span>
<span class='curline'><a href='../S/3691.html#L3945'>buffer</a>           3945 test/manual/etags/c-src/etags.c       dbp = lb.buffer;</span>
<span class='curline'><a href='../S/3691.html#L3956'>buffer</a>           3956 test/manual/etags/c-src/etags.c 	    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4033'>buffer</a>           4033 test/manual/etags/c-src/etags.c 			  lb.buffer, dbp - lb.buffer, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4065'>buffer</a>           4065 test/manual/etags/c-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/3691.html#L4106'>buffer</a>           4106 test/manual/etags/c-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4244'>buffer</a>           4244 test/manual/etags/c-src/etags.c 	    make_tag (lb.buffer, cp - lb.buffer, true,</span>
<span class='curline'><a href='../S/3691.html#L4245'>buffer</a>           4245 test/manual/etags/c-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4289'>buffer</a>           4289 test/manual/etags/c-src/etags.c 		      lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4300'>buffer</a>           4300 test/manual/etags/c-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4343'>buffer</a>           4343 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4370'>buffer</a>           4370 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4402'>buffer</a>           4402 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4415'>buffer</a>           4415 test/manual/etags/c-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4428'>buffer</a>           4428 test/manual/etags/c-src/etags.c 			lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4443'>buffer</a>           4443 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4453'>buffer</a>           4453 test/manual/etags/c-src/etags.c 		    lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4484'>buffer</a>           4484 test/manual/etags/c-src/etags.c 		  lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4508'>buffer</a>           4508 test/manual/etags/c-src/etags.c 	  char * namestart = skip_spaces (lb.buffer);</span>
<span class='curline'><a href='../S/3691.html#L4513'>buffer</a>           4513 test/manual/etags/c-src/etags.c 		    lb.buffer, bp - lb.buffer + 2, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4550'>buffer</a>           4550 test/manual/etags/c-src/etags.c   dbp = lb.buffer;</span>
<span class='curline'><a href='../S/3691.html#L4567'>buffer</a>           4567 test/manual/etags/c-src/etags.c 	  dbp = lb.buffer;</span>
<span class='curline'><a href='../S/3691.html#L4649'>buffer</a>           4649 test/manual/etags/c-src/etags.c 			tline.buffer, taglen, save_lineno, save_lcno);</span>
<span class='curline'><a href='../S/3691.html#L4666'>buffer</a>           4666 test/manual/etags/c-src/etags.c 	  strcpy (tline.buffer, lb.buffer);</span>
<span class='curline'><a href='../S/3691.html#L4669'>buffer</a>           4669 test/manual/etags/c-src/etags.c 	  name = tline.buffer + (dbp - lb.buffer);</span>
<span class='curline'><a href='../S/3691.html#L4671'>buffer</a>           4671 test/manual/etags/c-src/etags.c 	  taglen = cp - lb.buffer + 1;</span>
<span class='curline'><a href='../S/3691.html#L4697'>buffer</a>           4697 test/manual/etags/c-src/etags.c   free (tline.buffer);</span>
<span class='curline'><a href='../S/3691.html#L4824'>buffer</a>           4824 test/manual/etags/c-src/etags.c 		    lb.buffer, ep - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L4950'>buffer</a>           4950 test/manual/etags/c-src/etags.c 	  for (key = TEX_toktab; key-&gt;buffer != NULL; key++)</span>
<span class='curline'><a href='../S/3691.html#L4951'>buffer</a>           4951 test/manual/etags/c-src/etags.c 	    if (strneq (cp, key-&gt;buffer, key-&gt;len))</span>
<span class='curline'><a href='../S/3691.html#L4974'>buffer</a>           4974 test/manual/etags/c-src/etags.c 		    linelen = p - lb.buffer + 1;</span>
<span class='curline'><a href='../S/3691.html#L4977'>buffer</a>           4977 test/manual/etags/c-src/etags.c 			  lb.buffer, linelen, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L5053'>buffer</a>           5053 test/manual/etags/c-src/etags.c 	  TEX_toktab[i].buffer = savenstr (env, p - env);</span>
<span class='curline'><a href='../S/3691.html#L5061'>buffer</a>           5061 test/manual/etags/c-src/etags.c 	  TEX_toktab[i].buffer = NULL; /* Mark end of table. */</span>
<span class='curline'><a href='../S/3691.html#L5081'>buffer</a>           5081 test/manual/etags/c-src/etags.c 		  lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L5146'>buffer</a>           5146 test/manual/etags/c-src/etags.c 		memcpy (token_name.buffer, dbp, end - dbp);</span>
<span class='curline'><a href='../S/3691.html#L5147'>buffer</a>           5147 test/manual/etags/c-src/etags.c 		token_name.buffer[end - dbp] = '\0';</span>
<span class='curline'><a href='../S/3691.html#L5172'>buffer</a>           5172 test/manual/etags/c-src/etags.c 	    make_tag (token_name.buffer, token_name.len, true,</span>
<span class='curline'><a href='../S/3691.html#L5261'>buffer</a>           5261 test/manual/etags/c-src/etags.c       for (cp = plb-&gt;buffer; *cp != '\0'; cp++)</span>
<span class='curline'><a href='../S/3691.html#L5617'>buffer</a>           5617 test/manual/etags/c-src/etags.c 	  analyze_regex (regexbuf.buffer);</span>
<span class='curline'><a href='../S/3691.html#L5618'>buffer</a>           5618 test/manual/etags/c-src/etags.c 	free (regexbuf.buffer);</span>
<span class='curline'><a href='../S/3691.html#L5838'>buffer</a>           5838 test/manual/etags/c-src/etags.c   char *buffer = filebuf.buffer;</span>
<span class='curline'><a href='../S/3691.html#L5860'>buffer</a>           5860 test/manual/etags/c-src/etags.c 	  match = re_search (rp-&gt;pat, buffer, filebuf.len, charno,</span>
<span class='curline'><a href='../S/3691.html#L5891'>buffer</a>           5891 test/manual/etags/c-src/etags.c 		if (buffer[charno++] == '\n')</span>
<span class='curline'><a href='../S/3691.html#L5897'>buffer</a>           5897 test/manual/etags/c-src/etags.c 		name = substitute (buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/3691.html#L5900'>buffer</a>           5900 test/manual/etags/c-src/etags.c 		pfnote (name, true, buffer + linecharno,</span>
<span class='curline'><a href='../S/3691.html#L5903'>buffer</a>           5903 test/manual/etags/c-src/etags.c 		make_tag (name, strlen (name), true, buffer + linecharno,</span>
<span class='curline'><a href='../S/3691.html#L5938'>buffer</a>           5938 test/manual/etags/c-src/etags.c 		lb.buffer, cp - lb.buffer + 1, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L5961'>buffer</a>           5961 test/manual/etags/c-src/etags.c   char *buffer = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/3691.html#L5962'>buffer</a>           5962 test/manual/etags/c-src/etags.c   register char *p = lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/3691.html#L5975'>buffer</a>           5975 test/manual/etags/c-src/etags.c 	  xrnew (buffer, lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/3691.html#L5976'>buffer</a>           5976 test/manual/etags/c-src/etags.c 	  p += buffer - lbp-&gt;buffer;</span>
<span class='curline'><a href='../S/3691.html#L5977'>buffer</a>           5977 test/manual/etags/c-src/etags.c 	  pend = buffer + lbp-&gt;size;</span>
<span class='curline'><a href='../S/3691.html#L5978'>buffer</a>           5978 test/manual/etags/c-src/etags.c 	  lbp-&gt;buffer = buffer;</span>
<span class='curline'><a href='../S/3691.html#L5988'>buffer</a>           5988 test/manual/etags/c-src/etags.c 	  if (p &gt; buffer &amp;&amp; p[-1] == '\r')</span>
<span class='curline'><a href='../S/3691.html#L6011'>buffer</a>           6011 test/manual/etags/c-src/etags.c   lbp-&gt;len = p - buffer;</span>
<span class='curline'><a href='../S/3691.html#L6020'>buffer</a>           6020 test/manual/etags/c-src/etags.c 	  xrnew (filebuf.buffer, filebuf.size, char);</span>
<span class='curline'><a href='../S/3691.html#L6022'>buffer</a>           6022 test/manual/etags/c-src/etags.c       memcpy (filebuf.buffer + filebuf.len, lbp-&gt;buffer, lbp-&gt;len);</span>
<span class='curline'><a href='../S/3691.html#L6024'>buffer</a>           6024 test/manual/etags/c-src/etags.c       filebuf.buffer[filebuf.len++] = '\n';</span>
<span class='curline'><a href='../S/3691.html#L6025'>buffer</a>           6025 test/manual/etags/c-src/etags.c       filebuf.buffer[filebuf.len] = '\0';</span>
<span class='curline'><a href='../S/3691.html#L6052'>buffer</a>           6052 test/manual/etags/c-src/etags.c       if (result &gt; 12 &amp;&amp; strneq (lbp-&gt;buffer, "#line ", 6))</span>
<span class='curline'><a href='../S/3691.html#L6057'>buffer</a>           6057 test/manual/etags/c-src/etags.c 	  if (sscanf (lbp-&gt;buffer, "#line %u \"%n", &amp;lno, &amp;start) &gt;= 1</span>
<span class='curline'><a href='../S/3691.html#L6060'>buffer</a>           6060 test/manual/etags/c-src/etags.c 	      char *endp = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/3691.html#L6073'>buffer</a>           6073 test/manual/etags/c-src/etags.c 		  name = lbp-&gt;buffer + start;</span>
<span class='curline'><a href='../S/3691.html#L6182'>buffer</a>           6182 test/manual/etags/c-src/etags.c 	  match = re_match (rp-&gt;pat, lbp-&gt;buffer, lbp-&gt;len, 0, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/3691.html#L6211'>buffer</a>           6211 test/manual/etags/c-src/etags.c 		name = substitute (lbp-&gt;buffer, rp-&gt;name, &amp;rp-&gt;regs);</span>
<span class='curline'><a href='../S/3691.html#L6214'>buffer</a>           6214 test/manual/etags/c-src/etags.c 		pfnote (name, true, lbp-&gt;buffer, match, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L6217'>buffer</a>           6217 test/manual/etags/c-src/etags.c 			  lbp-&gt;buffer, match, lineno, linecharno);</span>
<span class='curline'><a href='../S/3691.html#L6517'>buffer</a>           6517 test/manual/etags/c-src/etags.c   lbp-&gt;buffer = xnew (lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/3691.html#L6518'>buffer</a>           6518 test/manual/etags/c-src/etags.c   lbp-&gt;buffer[0] = '\0';</span>
<span class='curline'><a href='../S/3691.html#L6529'>buffer</a>           6529 test/manual/etags/c-src/etags.c       xrnew (lbp-&gt;buffer, lbp-&gt;size, char);</span>
<span class='curline'><a href='../S/3681.html#L119'>buffer</a>            119 test/manual/etags/c-src/h.h struct re_pattern_buffer { unsigned char *buffer; };</span>
<span class='curline'><a href='../S/3733.html#L88'>buffer</a>             88 test/manual/etags/objc-src/PackInsp.h -subprocess:(Subprocess *)sender output:(char *)buffer;</span>
<span class='curline'><a href='../S/2584.html#L729'>buffer</a>            729 test/src/emacs-module-resources/mod-test.c   char *buffer = length == 0 ? NULL : malloc (length);</span>
<span class='curline'><a href='../S/2584.html#L730'>buffer</a>            730 test/src/emacs-module-resources/mod-test.c   if (buffer == NULL &amp;&amp; length != 0)</span>
<span class='curline'><a href='../S/2584.html#L735'>buffer</a>            735 test/src/emacs-module-resources/mod-test.c   memset (buffer, 'a', length);</span>
<span class='curline'><a href='../S/2584.html#L736'>buffer</a>            736 test/src/emacs-module-resources/mod-test.c   emacs_value ret = multibyte ? env-&gt;make_string (env, buffer, length)</span>
<span class='curline'><a href='../S/2584.html#L737'>buffer</a>            737 test/src/emacs-module-resources/mod-test.c                               : env-&gt;make_unibyte_string (env, buffer, length);</span>
<span class='curline'><a href='../S/2584.html#L738'>buffer</a>            738 test/src/emacs-module-resources/mod-test.c   free (buffer);</span>
</pre>
</body>
</html>
