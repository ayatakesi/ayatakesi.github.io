<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>header_size</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.7' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/111.html#L2434'>header_size</a>      2434 src/alloc.c      EMACS_INT needed_elements = ((bool_header_size - header_size + word_bytes</span>
<span class='curline'><a href='../S/111.html#L3072'>header_size</a>      3072 src/alloc.c    enum { VBLOCK_BYTES_MIN = vroundup_ct (header_size + sizeof (Lisp_Object)) };</span>
<span class='curline'><a href='../S/111.html#L3174'>header_size</a>      3174 src/alloc.c      eassume (header_size &lt;= nbytes);</span>
<span class='curline'><a href='../S/111.html#L3175'>header_size</a>      3175 src/alloc.c      ptrdiff_t nwords = (nbytes - header_size) / word_size;</span>
<span class='curline'><a href='../S/111.html#L3181'>header_size</a>      3181 src/alloc.c      ASAN_POISON_VECTOR_CONTENTS (v, nbytes - header_size);</span>
<span class='curline'><a href='../S/111.html#L3229'>header_size</a>      3229 src/alloc.c          ASAN_UNPOISON_VECTOR_CONTENTS (vector, nbytes - header_size);</span>
<span class='curline'><a href='../S/111.html#L3243'>header_size</a>      3243 src/alloc.c    	ASAN_UNPOISON_VECTOR_CONTENTS (vector, nbytes - header_size);</span>
<span class='curline'><a href='../S/111.html#L3298'>header_size</a>      3298 src/alloc.c    	  verify (header_size &lt;= bool_header_size);</span>
<span class='curline'><a href='../S/111.html#L3299'>header_size</a>      3299 src/alloc.c    	  nwords = (boolvec_bytes - header_size + word_size - 1) / word_size;</span>
<span class='curline'><a href='../S/111.html#L3308'>header_size</a>      3308 src/alloc.c      return vroundup (header_size + word_size * nwords);</span>
<span class='curline'><a href='../S/111.html#L3316'>header_size</a>      3316 src/alloc.c      verify_expr ((header_size + VECSIZE (struct t) * word_size \</span>
<span class='curline'><a href='../S/111.html#L3504'>header_size</a>      3504 src/alloc.c    		: header_size / word_size + vector-&gt;header.size);</span>
<span class='curline'><a href='../S/111.html#L3520'>header_size</a>      3520 src/alloc.c       min (((min (PTRDIFF_MAX, SIZE_MAX) - header_size - large_vector_offset) \</span>
<span class='curline'><a href='../S/111.html#L3532'>header_size</a>      3532 src/alloc.c      ptrdiff_t nbytes = header_size + len * word_size;</span>
<span class='curline'><a href='../S/111.html#L5837'>header_size</a>      5837 src/alloc.c      size_t size = header_size + len * word_size;</span>
<span class='curline'><a href='../S/111.html#L6672'>header_size</a>      6672 src/alloc.c    	   make_fixnum (header_size + sizeof (Lisp_Object)),</span>
<span class='curline'><a href='../S/119.html#L4510'>header_size</a>      4510 src/fns.c      		      - header_size - GCALIGNMENT) \</span>
<span class='curline'><a href='../S/131.html#L2001'>header_size</a>      2001 src/lisp.h       ((sizeof (type) - header_size + word_size - 1) / word_size)</span>
<span class='curline'><a href='../S/131.html#L2008'>header_size</a>      2008 src/lisp.h       (offsetof (type, lastlispfield) + word_size &lt; header_size		\</span>
<span class='curline'><a href='../S/131.html#L2009'>header_size</a>      2009 src/lisp.h        ? 0 : (offsetof (type, lastlispfield) + word_size - header_size) / word_size)</span>
<span class='curline'><a href='../S/131.html#L2236'>header_size</a>      2236 src/lisp.h     verify (offsetof (struct Lisp_Char_Table, defalt) == header_size);</span>
<span class='curline'><a href='../S/131.html#L2238'>header_size</a>      2238 src/lisp.h     	== header_size + CHAR_TABLE_STANDARD_SLOTS * sizeof (Lisp_Object));</span>
<span class='curline'><a href='../S/131.html#L2240'>header_size</a>      2240 src/lisp.h     	== header_size + SUB_CHAR_TABLE_OFFSET * sizeof (Lisp_Object));</span>
<span class='curline'><a href='../S/131.html#L2476'>header_size</a>      2476 src/lisp.h     verify (offsetof (struct Lisp_Hash_Table, weak) == header_size);</span>
<span class='curline'><a href='../S/131.html#L3737'>header_size</a>      3737 src/lisp.h       void *w = p + header_size + i * word_size;</span>
<span class='curline'><a href='../S/62.html#L254'>header_size</a>       254 src/sound.c      int header_size;</span>
<span class='curline'><a href='../S/62.html#L512'>header_size</a>       512 src/sound.c      if (s-&gt;header_size &lt; sizeof *header</span>
<span class='curline'><a href='../S/62.html#L620'>header_size</a>       620 src/sound.c      if (s-&gt;header_size &lt; sizeof *header</span>
<span class='curline'><a href='../S/62.html#L1394'>header_size</a>      1394 src/sound.c          current_sound-&gt;header_size</span>
<span class='curline'><a href='../S/62.html#L1397'>header_size</a>      1397 src/sound.c          if (current_sound-&gt;header_size &lt; 0)</span>
<span class='curline'><a href='../S/62.html#L1403'>header_size</a>      1403 src/sound.c          current_sound-&gt;header_size = min (MAX_SOUND_HEADER_BYTES, SBYTES (current_sound-&gt;data));</span>
<span class='curline'><a href='../S/62.html#L1405'>header_size</a>      1405 src/sound.c    	      current_sound-&gt;header_size);</span>
<span class='curline'><a href='../S/3694.html#L1532'>header_size</a>      1532 test/manual/etags/c-src/emacs/src/lisp.h   ((sizeof (type) - header_size + word_size - 1) / word_size)</span>
<span class='curline'><a href='../S/3694.html#L1539'>header_size</a>      1539 test/manual/etags/c-src/emacs/src/lisp.h   ((offsetof (type, nonlispfield) - header_size) / word_size)</span>
</pre>
</body>
</html>
