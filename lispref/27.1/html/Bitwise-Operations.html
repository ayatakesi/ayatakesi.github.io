<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 27.1.

Copyright (C) 1990-1996, 1998-2020 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "GNU General Public License," with the Front-Cover Texts
being "A GNU Manual," and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Bitwise Operations (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Bitwise Operations (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Bitwise Operations (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Numbers.html" rel="up" title="Numbers">
<link href="Math-Functions.html" rel="next" title="Math Functions">
<link href="Rounding-Operations.html" rel="prev" title="Rounding Operations">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<span id="Bitwise-Operations"></span><div class="header">
<p>
Next: <a href="Math-Functions.html" accesskey="n" rel="next">Math Functions</a>, Previous: <a href="Rounding-Operations.html" accesskey="p" rel="prev">Rounding Operations</a>, Up: <a href="Numbers.html" accesskey="u" rel="up">Numbers</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Zheng-Shu-nitaisurubitutoYan-Suan-"></span><h3 class="section">3.8 整数にたいするビット演算</h3>
<span id="index-bitwise-arithmetic"></span>
<span id="index-logical-arithmetic"></span>

<p>In a computer, an integer is represented as a binary number, a sequence of
<em>bits</em> (digits which are either zero or one).  Conceptually the bit
sequence is infinite on the left, with the most-significant bits being all
zeros or all ones.  A bitwise operation acts on the individual bits of such
a sequence.  For example, <em>shifting</em> moves the whole sequence left or
right one or more places, reproducing the same pattern moved over.
</p>
<p>Emacs Lispのビット演算は整数だけに適用されます。
</p>
<dl>
<dt id="index-ash">Function: <strong>ash</strong> <em>integer1 count</em></dt>
<dd><span id="index-arithmetic-shift"></span>
<p><code>ash</code> (<em>arithmetic shift</em>) shifts the bits in <var>integer1</var> to the
left <var>count</var> places, or to the right if <var>count</var> is negative.  Left
shifts introduce zero bits on the right; right shifts discard the rightmost
bits.  Considered as an integer operation, <code>ash</code> multiplies
<var>integer1</var> by
2**<var>count</var>,
and then converts the result to an integer by rounding downward, toward
minus infinity.
</p>
<p>Here are examples of <code>ash</code>, shifting a pattern of bits one place to the
left and to the right.  These examples show only the low-order bits of the
binary pattern; leading bits all agree with the highest-order bit shown.  As
you can see, shifting left by one is equivalent to multiplying by two,
whereas shifting right by one is equivalent to dividing by two and then
rounding toward minus infinity.
</p>
<div class="example">
<pre class="example">(ash 7 1) &rArr; 14
;; <span class="roman">Decimal 7 becomes decimal 14.</span>
&hellip;000111
     &rArr;
&hellip;001110
</pre><pre class="example">

</pre><pre class="example">(ash 7 -1) &rArr; 3
&hellip;000111
     &rArr;
&hellip;000011
</pre><pre class="example">

</pre><pre class="example">(ash -7 1) &rArr; -14
&hellip;111001
     &rArr;
&hellip;110010
</pre><pre class="example">

</pre><pre class="example">(ash -7 -1) &rArr; -4
&hellip;111001
     &rArr;
&hellip;111100
</pre></div>

<p>Here are examples of shifting left or right by two bits:
</p>
<div class="example">
<pre class="example">                  ;  <span class="roman">       binary values</span>
(ash 5 2)         ;   5  =  <span class="roman">&hellip;000101</span>
     &rArr; 20         ;      =  <span class="roman">&hellip;010100</span>
(ash -5 2)        ;  -5  =  <span class="roman">&hellip;111011</span>
     &rArr; -20        ;      =  <span class="roman">&hellip;101100</span>
</pre><pre class="example">(ash 5 -2)
     &rArr; 1          ;      =  <span class="roman">&hellip;000001</span>
</pre><pre class="example">(ash -5 -2)
     &rArr; -2         ;      =  <span class="roman">&hellip;111110</span>
</pre></div>
</dd></dl>

<dl>
<dt id="index-lsh">Function: <strong>lsh</strong> <em>integer1 count</em></dt>
<dd><span id="index-logical-shift"></span>
<p><code>lsh</code>, which is an abbreviation for <em>logical shift</em>, shifts the
bits in <var>integer1</var> to the left <var>count</var> places, or to the right if
<var>count</var> is negative, bringing zeros into the vacated bits.  If
<var>count</var> is negative, then <var>integer1</var> must be either a fixnum or a
positive bignum, and <code>lsh</code> treats a negative fixnum as if it were
unsigned by subtracting twice <code>most-negative-fixnum</code> before shifting,
producing a nonnegative result.  This quirky behavior dates back to when
Emacs supported only fixnums; nowadays <code>ash</code> is a better choice.
</p>
<p>As <code>lsh</code> behaves like <code>ash</code> except when <var>integer1</var> and
<var>count1</var> are both negative, the following examples focus on these
exceptional cases.  These examples assume 30-bit fixnums.
</p>
<div class="example">
<pre class="example">                 ; <span class="roman">     binary values</span>
(ash -7 -1)      ; -7 = <span class="roman">&hellip;111111111111111111111111111001</span>
     &rArr; -4        ;    = <span class="roman">&hellip;111111111111111111111111111100</span>
(lsh -7 -1)
     &rArr; 536870908 ;    = <span class="roman">&hellip;011111111111111111111111111100</span>
</pre><pre class="example">(ash -5 -2)      ; -5 = <span class="roman">&hellip;111111111111111111111111111011</span>
     &rArr; -2        ;    = <span class="roman">&hellip;111111111111111111111111111110</span>
(lsh -5 -2)
     &rArr; 268435454 ;    = <span class="roman">&hellip;001111111111111111111111111110</span>
</pre></div>
</dd></dl>

<dl>
<dt id="index-logand">Function: <strong>logand</strong> <em>&amp;rest ints-or-markers</em></dt>
<dd><p>この関数は引数のビットのANDをリターンする。すべての引数の<var>n</var>番目のビットが1の場合に限り、結果の<var>n</var>番目のビットが1となる。
</p>
<p>たとえば13と12では、4ビット2進数を使用すると1101と1100のビットANDは1100を生成する。この2進数ではいずれも左の2ビットがセット(つまり1)されているので、リターンされる値の左2ビットがセットされる。しかし右の2ビットにたいしては少なくとも1つの引数でそのビットが0なので、リターンされる値の右2ビットは0になる。
</p>
<p>したがって、
</p>
<div class="example">
<pre class="example">(logand 13 12)
     &rArr; 12
</pre></div>

<p><code>logand</code>に何も引数も渡さなければ、値-1がリターンされる。-1を2進数で表すとすべてのビットが1なので、-1は<code>logand</code>にたいする単位元(identity
element)である。
</p>
<div class="example">
<pre class="example">                   ; <span class="roman">       binary values</span>

(logand 14 13)     ; 14  =  <span class="roman">&hellip;001110</span>
                   ; 13  =  <span class="roman">&hellip;001101</span>
     &rArr; 12         ; 12  =  <span class="roman">&hellip;001100</span>
</pre><pre class="example">

</pre><pre class="example">(logand 14 13 4)   ; 14  =  <span class="roman">&hellip;001110</span>
                   ; 13  =  <span class="roman">&hellip;001101</span>
                   ;  4  =  <span class="roman">&hellip;000100</span>
     &rArr; 4          ;  4  =  <span class="roman">&hellip;000100</span>
</pre><pre class="example">

</pre><pre class="example">(logand)
     &rArr; -1         ; -1  =  <span class="roman">&hellip;111111</span>
</pre></div>
</dd></dl>

<dl>
<dt id="index-logior">Function: <strong>logior</strong> <em>&amp;rest ints-or-markers</em></dt>
<dd><p>この関数は、引数のビット単位の包含的ORをリターンする。少なくとも1つの引数で<var>n</var>番目のビットが1なら、結果の<var>n</var>番目のビットが1になる。引数を与えなければ、結果はこの処理にたいする単位元である0となる。<code>logior</code>に渡す引数が1つだけならその引数がリターンされる。
</p>
<div class="example">
<pre class="example">                   ; <span class="roman">       binary values</span>

(logior 12 5)      ; 12  =  <span class="roman">&hellip;001100</span>
                   ;  5  =  <span class="roman">&hellip;000101</span>
     &rArr; 13         ; 13  =  <span class="roman">&hellip;001101</span>
</pre><pre class="example">

</pre><pre class="example">(logior 12 5 7)    ; 12  =  <span class="roman">&hellip;001100</span>
                   ;  5  =  <span class="roman">&hellip;000101</span>
                   ;  7  =  <span class="roman">&hellip;000111</span>
     &rArr; 15         ; 15  =  <span class="roman">&hellip;001111</span>
</pre></div>
</dd></dl>

<dl>
<dt id="index-logxor">Function: <strong>logxor</strong> <em>&amp;rest ints-or-markers</em></dt>
<dd><p>この関数は、引数のビット単位の排他的ORをリターンする。<var>n</var>番目のビットが1であるような引数の数が奇数個の場合のみ、結果の<var>n</var>番目のビットが1となる。引数を与えなければ、結果はこの処理の単位元である0となる。<code>logxor</code>に渡す引数が1つだけならその引数がリターンされる。
</p>
<div class="example">
<pre class="example">                   ; <span class="roman">       binary values</span>

(logxor 12 5)      ; 12  =  <span class="roman">&hellip;001100</span>
                   ;  5  =  <span class="roman">&hellip;000101</span>
     &rArr; 9          ;  9  =  <span class="roman">&hellip;001001</span>
</pre><pre class="example">

</pre><pre class="example">(logxor 12 5 7)    ; 12  =  <span class="roman">&hellip;001100</span>
                   ;  5  =  <span class="roman">&hellip;000101</span>
                   ;  7  =  <span class="roman">&hellip;000111</span>
     &rArr; 14         ; 14  =  <span class="roman">&hellip;001110</span>
</pre></div>
</dd></dl>

<dl>
<dt id="index-lognot">Function: <strong>lognot</strong> <em>integer</em></dt>
<dd><p>This function returns the bitwise complement of its argument: the <var>n</var>th
bit is one in the result if, and only if, the <var>n</var>th bit is zero in
<var>integer</var>, and vice-versa.  The result equals -1 -
<var>integer</var>.
</p>
<div class="example">
<pre class="example">(lognot 5)
     &rArr; -6
;;  5  =  <span class="roman">&hellip;000101</span>
;; <span class="roman">becomes</span>
;; -6  =  <span class="roman">&hellip;111010</span>
</pre></div>
</dd></dl>

<span id="index-popcount"></span>
<span id="index-Hamming-weight"></span>
<span id="index-counting-set-bits"></span>
<dl>
<dt id="index-logcount">Function: <strong>logcount</strong> <em>integer</em></dt>
<dd><p>This function returns the <em>Hamming weight</em> of <var>integer</var>: the number
of ones in the binary representation of <var>integer</var>.  If <var>integer</var> is
negative, it returns the number of zero bits in its two&rsquo;s complement binary
representation.  The result is always nonnegative.
</p>
<div class="example">
<pre class="example">(logcount 43)     ;  43 = <span class="roman">&hellip;000101011</span>
     &rArr; 4
(logcount -43)    ; -43 = <span class="roman">&hellip;111010101</span>
     &rArr; 3
</pre></div>
</dd></dl>

<hr>
<div class="header">
<p>
Next: <a href="Math-Functions.html" accesskey="n" rel="next">Math Functions</a>, Previous: <a href="Rounding-Operations.html" accesskey="p" rel="prev">Rounding Operations</a>, Up: <a href="Numbers.html" accesskey="u" rel="up">Numbers</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
