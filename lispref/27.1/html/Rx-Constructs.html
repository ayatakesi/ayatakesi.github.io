<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 27.1.

Copyright (C) 1990-1996, 1998-2020 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "GNU General Public License," with the Front-Cover Texts
being "A GNU Manual," and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Rx Constructs (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Rx Constructs (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Rx Constructs (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Rx-Notation.html" rel="up" title="Rx Notation">
<link href="Rx-Functions.html" rel="next" title="Rx Functions">
<link href="Rx-Notation.html" rel="prev" title="Rx Notation">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<span id="Rx-Constructs"></span><div class="header">
<p>
Next: <a href="Rx-Functions.html" accesskey="n" rel="next">Rx Functions</a>, Up: <a href="Rx-Notation.html" accesskey="u" rel="up">Rx Notation</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Constructs-in-rx-regexps"></span><h4 class="subsubsection">34.3.3.1 Constructs in <code>rx</code> regexps</h4>

<p>The various forms in <code>rx</code> regexps are described below.  The shorthand
<var>rx</var> represents any <code>rx</code> form, and <var>rx</var>&hellip; means zero or
more <code>rx</code> forms.  Where the corresponding string regexp syntax is
given, <var>A</var>, <var>B</var>, &hellip; are string regexp subexpressions.
</p>
<span id="Literals"></span><h4 class="subsubheading">Literals</h4>

<dl compact="compact">
<dt><code>&quot;some-string&quot;</code></dt>
<dd><p>Match the string &lsquo;<samp>some-string</samp>&rsquo; literally.  There are no characters with
special meaning, unlike in string regexps.
</p>
</dd>
<dt><code>?C</code></dt>
<dd><p>Match the character &lsquo;<samp>C</samp>&rsquo; literally.
</p></dd>
</dl>

<span id="Sequence-and-alternative"></span><h4 class="subsubheading">Sequence and alternative</h4>

<dl compact="compact">
<dt><code>(seq <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-seq-in-rx"></span>
</dd>
<dt><code>(sequence <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-sequence-in-rx"></span>
</dd>
<dt><code>(: <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-_003a-in-rx"></span>
</dd>
<dt><code>(and <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-and-in-rx"></span>
<p>Match the <var>rx</var>s in sequence.  Without arguments, the expression matches
the empty string.<br> Corresponding string regexp:
&lsquo;<samp><var>A</var><var>B</var>&hellip;</samp>&rsquo; (subexpressions in sequence).
</p>
</dd>
<dt><code>(or <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-or-in-rx"></span>
</dd>
<dt><code>(| <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-_007c-in-rx"></span>
<p>Match exactly one of the <var>rx</var>s.  If all arguments are strings,
characters, or <code>or</code> forms so constrained, the longest possible match
will always be used.  Otherwise, either the longest match or the first (in
left-to-right order) will be used.  Without arguments, the expression will
not match anything at all.<br> Corresponding string regexp:
&lsquo;<samp><var>A</var>\|<var>B</var>\|&hellip;</samp>&rsquo;.
</p>
</dd>
<dt><code>unmatchable</code></dt>
<dd><span id="index-unmatchable-in-rx"></span>
<p>Refuse any match.  Equivalent to <code>(or)</code>.  See <a href="Regexp-Functions.html#regexp_002dunmatchable">regexp-unmatchable</a>.
</p></dd>
</dl>

<span id="Repetition"></span><h4 class="subsubheading">Repetition</h4>

<p>Normally, repetition forms are greedy, in that they attempt to match as many
times as possible.  Some forms are non-greedy; they try to match as few
times as possible (see <a href="Regexp-Special.html#Non_002dgreedy-repetition">Non-greedy repetition</a>).
</p>
<dl compact="compact">
<dt><code>(zero-or-more <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-zero_002dor_002dmore-in-rx"></span>
</dd>
<dt><code>(0+ <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-0_002b-in-rx"></span>
<p>Match the <var>rx</var>s zero or more times.  Greedy by default.<br> Corresponding
string regexp: &lsquo;<samp><var>A</var>*</samp>&rsquo; (greedy), &lsquo;<samp><var>A</var>*?</samp>&rsquo; (non-greedy)
</p>
</dd>
<dt><code>(one-or-more <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-one_002dor_002dmore-in-rx"></span>
</dd>
<dt><code>(1+ <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-1_002b-in-rx"></span>
<p>Match the <var>rx</var>s one or more times.  Greedy by default.<br> Corresponding
string regexp: &lsquo;<samp><var>A</var>+</samp>&rsquo; (greedy), &lsquo;<samp><var>A</var>+?</samp>&rsquo; (non-greedy)
</p>
</dd>
<dt><code>(zero-or-one <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-zero_002dor_002done-in-rx"></span>
</dd>
<dt><code>(optional <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-optional-in-rx"></span>
</dd>
<dt><code>(opt <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-opt-in-rx"></span>
<p>Match the <var>rx</var>s once or an empty string.  Greedy by default.<br>
Corresponding string regexp: &lsquo;<samp><var>A</var>?</samp>&rsquo; (greedy), &lsquo;<samp><var>A</var>??</samp>&rsquo;
(non-greedy).
</p>
</dd>
<dt><code>(* <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-_002a-in-rx"></span>
<p>Match the <var>rx</var>s zero or more times.  Greedy.<br> Corresponding string
regexp: &lsquo;<samp><var>A</var>*</samp>&rsquo;
</p>
</dd>
<dt><code>(+ <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-_002b-in-rx"></span>
<p>Match the <var>rx</var>s one or more times.  Greedy.<br> Corresponding string
regexp: &lsquo;<samp><var>A</var>+</samp>&rsquo;
</p>
</dd>
<dt><code>(? <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-_003f-in-rx"></span>
<p>Match the <var>rx</var>s once or an empty string.  Greedy.<br> Corresponding string
regexp: &lsquo;<samp><var>A</var>?</samp>&rsquo;
</p>
</dd>
<dt><code>(*? <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-_002a_003f-in-rx"></span>
<p>Match the <var>rx</var>s zero or more times.  Non-greedy.<br> Corresponding string
regexp: &lsquo;<samp><var>A</var>*?</samp>&rsquo;
</p>
</dd>
<dt><code>(+? <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-_002b_003f-in-rx"></span>
<p>Match the <var>rx</var>s one or more times.  Non-greedy.<br> Corresponding string
regexp: &lsquo;<samp><var>A</var>+?</samp>&rsquo;
</p>
</dd>
<dt><code>(?? <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-_003f_003f-in-rx"></span>
<p>Match the <var>rx</var>s or an empty string.  Non-greedy.<br> Corresponding string
regexp: &lsquo;<samp><var>A</var>??</samp>&rsquo;
</p>
</dd>
<dt><code>(= <var>n</var> <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-_003d-in-rx"></span>
</dd>
<dt><code>(repeat <var>n</var> <var>rx</var>)</code></dt>
<dd><p>Match the <var>rx</var>s exactly <var>n</var> times.<br> Corresponding string regexp:
&lsquo;<samp><var>A</var>\{<var>n</var>\}</samp>&rsquo;
</p>
</dd>
<dt><code>(&gt;= <var>n</var> <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-_003e_003d-in-rx"></span>
<p>Match the <var>rx</var>s <var>n</var> or more times.  Greedy.<br> Corresponding string
regexp: &lsquo;<samp><var>A</var>\{<var>n</var>,\}</samp>&rsquo;
</p>
</dd>
<dt><code>(** <var>n</var> <var>m</var> <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-_002a_002a-in-rx"></span>
</dd>
<dt><code>(repeat <var>n</var> <var>m</var> <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-repeat-in-rx"></span>
<p>Match the <var>rx</var>s at least <var>n</var> but no more than <var>m</var> times.
Greedy.<br> Corresponding string regexp: &lsquo;<samp><var>A</var>\{<var>n</var>,<var>m</var>\}</samp>&rsquo;
</p></dd>
</dl>

<p>The greediness of some repetition forms can be controlled using the
following constructs.  However, it is usually better to use the explicit
non-greedy forms above when such matching is required.
</p>
<dl compact="compact">
<dt><code>(minimal-match <var>rx</var>)</code></dt>
<dd><span id="index-minimal_002dmatch-in-rx"></span>
<p>Match <var>rx</var>, with <code>zero-or-more</code>, <code>0+</code>, <code>one-or-more</code>,
<code>1+</code>, <code>zero-or-one</code>, <code>opt</code> and <code>optional</code> using
non-greedy matching.
</p>
</dd>
<dt><code>(maximal-match <var>rx</var>)</code></dt>
<dd><span id="index-maximal_002dmatch-in-rx"></span>
<p>Match <var>rx</var>, with <code>zero-or-more</code>, <code>0+</code>, <code>one-or-more</code>,
<code>1+</code>, <code>zero-or-one</code>, <code>opt</code> and <code>optional</code> using greedy
matching.  This is the default.
</p></dd>
</dl>

<span id="Matching-single-characters"></span><h4 class="subsubheading">Matching single characters</h4>

<dl compact="compact">
<dt><code>(any <var>set</var>&hellip;)</code></dt>
<dd><span id="index-any-in-rx"></span>
</dd>
<dt><code>(char <var>set</var>&hellip;)</code></dt>
<dd><span id="index-char-in-rx"></span>
</dd>
<dt><code>(in <var>set</var>&hellip;)</code></dt>
<dd><span id="index-in-in-rx"></span>
<span id="index-character-class-in-rx"></span>
<p>Match a single character from one of the <var>set</var>s.  Each <var>set</var> is a
character, a string representing the set of its characters, a range or a
character class (see below).  A range is either a hyphen-separated string
like <code>&quot;A-Z&quot;</code>, or a cons of characters like <code>(?A . ?Z)</code>.
</p>
<p>Note that hyphen (<code>-</code>) is special in strings in this construct, since
it acts as a range separator.  To include a hyphen, add it as a separate
character or single-character string.<br> Corresponding string regexp:
&lsquo;<samp>[&hellip;]</samp>&rsquo;
</p>
</dd>
<dt><code>(not <var>charspec</var>)</code></dt>
<dd><span id="index-not-in-rx"></span>
<p>Match a character not included in <var>charspec</var>.  <var>charspec</var> can be a
character, a single-character string, an <code>any</code>, <code>not</code>, <code>or</code>,
<code>intersection</code>, <code>syntax</code> or <code>category</code> form, or a character
class.  If <var>charspec</var> is an <code>or</code> form, its arguments have the same
restrictions as those of <code>intersection</code>; see below.<br> Corresponding
string regexp: &lsquo;<samp>[^&hellip;]</samp>&rsquo;, &lsquo;<samp>\S<var>code</var></samp>&rsquo;, &lsquo;<samp>\C<var>code</var></samp>&rsquo;
</p>
</dd>
<dt><code>(intersection <var>charset</var>&hellip;)</code></dt>
<dd><span id="index-intersection-in-rx"></span>
<p>Match a character included in all of the <var>charset</var>s.  Each <var>charset</var>
can be a character, a single-character string, an <code>any</code> form without
character classes, or an <code>intersection</code>, <code>or</code> or <code>not</code> form
whose arguments are also <var>charset</var>s.
</p>
</dd>
<dt><code>not-newline</code>, <code>nonl</code></dt>
<dd><span id="index-not_002dnewline-in-rx"></span>
<span id="index-nonl-in-rx"></span>
<p>Match any character except a newline.<br> Corresponding string regexp:
&lsquo;<samp>.</samp>&rsquo; (dot)
</p>
</dd>
<dt><code>anychar</code>, <code>anything</code></dt>
<dd><span id="index-anychar-in-rx"></span>
<span id="index-anything-in-rx"></span>
<p>Match any character.<br> Corresponding string regexp: &lsquo;<samp>.\|\n</samp>&rsquo; (for
example)
</p>
</dd>
<dt>character class</dt>
<dd><span id="index-character-class-in-rx-1"></span>
<p>Match a character from a named character class:
</p>
<dl compact="compact">
<dt><code>alpha</code>, <code>alphabetic</code>, <code>letter</code></dt>
<dd><p>Match alphabetic characters.  More precisely, match characters whose Unicode
&lsquo;<samp>general-category</samp>&rsquo; property indicates that they are alphabetic.
</p>
</dd>
<dt><code>alnum</code>, <code>alphanumeric</code></dt>
<dd><p>Match alphabetic characters and digits.  More precisely, match characters
whose Unicode &lsquo;<samp>general-category</samp>&rsquo; property indicates that they are
alphabetic or decimal digits.
</p>
</dd>
<dt><code>digit</code>, <code>numeric</code>, <code>num</code></dt>
<dd><p>Match the digits &lsquo;<samp>0</samp>&rsquo;&ndash;&lsquo;<samp>9</samp>&rsquo;.
</p>
</dd>
<dt><code>xdigit</code>, <code>hex-digit</code>, <code>hex</code></dt>
<dd><p>Match the hexadecimal digits &lsquo;<samp>0</samp>&rsquo;&ndash;&lsquo;<samp>9</samp>&rsquo;, &lsquo;<samp>A</samp>&rsquo;&ndash;&lsquo;<samp>F</samp>&rsquo; and
&lsquo;<samp>a</samp>&rsquo;&ndash;&lsquo;<samp>f</samp>&rsquo;.
</p>
</dd>
<dt><code>cntrl</code>, <code>control</code></dt>
<dd><p>Match any character whose code is in the range 0&ndash;31.
</p>
</dd>
<dt><code>blank</code></dt>
<dd><p>Match horizontal whitespace.  More precisely, match characters whose Unicode
&lsquo;<samp>general-category</samp>&rsquo; property indicates that they are spacing separators.
</p>
</dd>
<dt><code>space</code>, <code>whitespace</code>, <code>white</code></dt>
<dd><p>Match any character that has whitespace syntax (see <a href="Syntax-Class-Table.html">Syntax Class Table</a>).
</p>
</dd>
<dt><code>lower</code>, <code>lower-case</code></dt>
<dd><p>Match anything lower-case, as determined by the current case table.  If
<code>case-fold-search</code> is non-nil, this also matches any upper-case letter.
</p>
</dd>
<dt><code>upper</code>, <code>upper-case</code></dt>
<dd><p>Match anything upper-case, as determined by the current case table.  If
<code>case-fold-search</code> is non-nil, this also matches any lower-case letter.
</p>
</dd>
<dt><code>graph</code>, <code>graphic</code></dt>
<dd><p>Match any character except whitespace, <acronym>ASCII</acronym> and
non-<acronym>ASCII</acronym> control characters, surrogates, and codepoints
unassigned by Unicode, as indicated by the Unicode &lsquo;<samp>general-category</samp>&rsquo;
property.
</p>
</dd>
<dt><code>print</code>, <code>printing</code></dt>
<dd><p>Match whitespace or a character matched by <code>graph</code>.
</p>
</dd>
<dt><code>punct</code>, <code>punctuation</code></dt>
<dd><p>Match any punctuation character.  (At present, for multibyte characters,
anything that has non-word syntax.)
</p>
</dd>
<dt><code>word</code>, <code>wordchar</code></dt>
<dd><p>Match any character that has word syntax (see <a href="Syntax-Class-Table.html">Syntax Class Table</a>).
</p>
</dd>
<dt><code>ascii</code></dt>
<dd><p>Match any <acronym>ASCII</acronym> character (codes 0&ndash;127).
</p>
</dd>
<dt><code>nonascii</code></dt>
<dd><p>Match any non-<acronym>ASCII</acronym> character (but not raw bytes).
</p></dd>
</dl>

<p>Corresponding string regexp: &lsquo;<samp>[[:<var>class</var>:]]</samp>&rsquo;
</p>
</dd>
<dt><code>(syntax <var>syntax</var>)</code></dt>
<dd><span id="index-syntax-in-rx"></span>
<p>Match a character with syntax <var>syntax</var>, being one of the following
names:
</p>
<table>
<thead><tr><th>Syntax name</th><th>Syntax character</th></tr></thead>
<tr><td><code>whitespace</code></td><td><code>-</code></td></tr>
<tr><td><code>punctuation</code></td><td><code>.</code></td></tr>
<tr><td><code>word</code></td><td><code>w</code></td></tr>
<tr><td><code>symbol</code></td><td><code>_</code></td></tr>
<tr><td><code>open-parenthesis</code></td><td><code>(</code></td></tr>
<tr><td><code>close-parenthesis</code></td><td><code>)</code></td></tr>
<tr><td><code>expression-prefix</code></td><td><code>'</code></td></tr>
<tr><td><code>string-quote</code></td><td><code>&quot;</code></td></tr>
<tr><td><code>paired-delimiter</code></td><td><code>$</code></td></tr>
<tr><td><code>escape</code></td><td><code>\</code></td></tr>
<tr><td><code>character-quote</code></td><td><code>/</code></td></tr>
<tr><td><code>comment-start</code></td><td><code>&lt;</code></td></tr>
<tr><td><code>comment-end</code></td><td><code>&gt;</code></td></tr>
<tr><td><code>string-delimiter</code></td><td><code>|</code></td></tr>
<tr><td><code>comment-delimiter</code></td><td><code>!</code></td></tr>
</table>

<p>For details, see <a href="Syntax-Class-Table.html">Syntax Class Table</a>.  Please note that <code>(syntax
punctuation)</code> is <em>not</em> equivalent to the character class
<code>punctuation</code>.<br> Corresponding string regexp: &lsquo;<samp>\s<var>code</var></samp>&rsquo;
</p>
</dd>
<dt><code>(category <var>category</var>)</code></dt>
<dd><span id="index-category-in-rx"></span>
<p>Match a character in category <var>category</var>, which is either one of the
names below or its category character.
</p>
<table>
<thead><tr><th>Category name</th><th>Category character</th></tr></thead>
<tr><td><code>space-for-indent</code></td><td>space</td></tr>
<tr><td><code>base</code></td><td><code>.</code></td></tr>
<tr><td><code>consonant</code></td><td><code>0</code></td></tr>
<tr><td><code>base-vowel</code></td><td><code>1</code></td></tr>
<tr><td><code>upper-diacritical-mark</code></td><td><code>2</code></td></tr>
<tr><td><code>lower-diacritical-mark</code></td><td><code>3</code></td></tr>
<tr><td><code>tone-mark</code></td><td><code>4</code></td></tr>
<tr><td><code>symbol</code></td><td><code>5</code></td></tr>
<tr><td><code>digit</code></td><td><code>6</code></td></tr>
<tr><td><code>vowel-modifying-diacritical-mark</code></td><td><code>7</code></td></tr>
<tr><td><code>vowel-sign</code></td><td><code>8</code></td></tr>
<tr><td><code>semivowel-lower</code></td><td><code>9</code></td></tr>
<tr><td><code>not-at-end-of-line</code></td><td><code>&lt;</code></td></tr>
<tr><td><code>not-at-beginning-of-line</code></td><td><code>&gt;</code></td></tr>
<tr><td><code>alpha-numeric-two-byte</code></td><td><code>A</code></td></tr>
<tr><td><code>chinese-two-byte</code></td><td><code>C</code></td></tr>
<tr><td><code>greek-two-byte</code></td><td><code>G</code></td></tr>
<tr><td><code>japanese-hiragana-two-byte</code></td><td><code>H</code></td></tr>
<tr><td><code>indian-two-byte</code></td><td><code>I</code></td></tr>
<tr><td><code>japanese-katakana-two-byte</code></td><td><code>K</code></td></tr>
<tr><td><code>strong-left-to-right</code></td><td><code>L</code></td></tr>
<tr><td><code>korean-hangul-two-byte</code></td><td><code>N</code></td></tr>
<tr><td><code>strong-right-to-left</code></td><td><code>R</code></td></tr>
<tr><td><code>cyrillic-two-byte</code></td><td><code>Y</code></td></tr>
<tr><td><code>combining-diacritic</code></td><td><code>^</code></td></tr>
<tr><td><code>ascii</code></td><td><code>a</code></td></tr>
<tr><td><code>arabic</code></td><td><code>b</code></td></tr>
<tr><td><code>chinese</code></td><td><code>c</code></td></tr>
<tr><td><code>ethiopic</code></td><td><code>e</code></td></tr>
<tr><td><code>greek</code></td><td><code>g</code></td></tr>
<tr><td><code>korean</code></td><td><code>h</code></td></tr>
<tr><td><code>indian</code></td><td><code>i</code></td></tr>
<tr><td><code>japanese</code></td><td><code>j</code></td></tr>
<tr><td><code>japanese-katakana</code></td><td><code>k</code></td></tr>
<tr><td><code>latin</code></td><td><code>l</code></td></tr>
<tr><td><code>lao</code></td><td><code>o</code></td></tr>
<tr><td><code>tibetan</code></td><td><code>q</code></td></tr>
<tr><td><code>japanese-roman</code></td><td><code>r</code></td></tr>
<tr><td><code>thai</code></td><td><code>t</code></td></tr>
<tr><td><code>vietnamese</code></td><td><code>v</code></td></tr>
<tr><td><code>hebrew</code></td><td><code>w</code></td></tr>
<tr><td><code>cyrillic</code></td><td><code>y</code></td></tr>
<tr><td><code>can-break</code></td><td><code>|</code></td></tr>
</table>

<p>For more information about currently defined categories, run the command
<kbd>M-x describe-categories <span class="key">RET</span></kbd>.  For how to define new categories,
see <a href="Categories.html">Categories</a>.<br> Corresponding string regexp: &lsquo;<samp>\c<var>code</var></samp>&rsquo;
</p></dd>
</dl>

<span id="Zero_002dwidth-assertions"></span><h4 class="subsubheading">Zero-width assertions</h4>

<p>These all match the empty string, but only in specific places.
</p>
<dl compact="compact">
<dt><code>line-start</code>, <code>bol</code></dt>
<dd><span id="index-line_002dstart-in-rx"></span>
<span id="index-bol-in-rx"></span>
<p>Match at the beginning of a line.<br> Corresponding string regexp: &lsquo;<samp>^</samp>&rsquo;
</p>
</dd>
<dt><code>line-end</code>, <code>eol</code></dt>
<dd><span id="index-line_002dend-in-rx"></span>
<span id="index-eol-in-rx"></span>
<p>Match at the end of a line.<br> Corresponding string regexp: &lsquo;<samp>$</samp>&rsquo;
</p>
</dd>
<dt><code>string-start</code>, <code>bos</code>, <code>buffer-start</code>, <code>bot</code></dt>
<dd><span id="index-string_002dstart-in-rx"></span>
<span id="index-bos-in-rx"></span>
<span id="index-buffer_002dstart-in-rx"></span>
<span id="index-bot-in-rx"></span>
<p>Match at the start of the string or buffer being matched against.<br>
Corresponding string regexp: &lsquo;<samp>\`</samp>&rsquo;
</p>
</dd>
<dt><code>string-end</code>, <code>eos</code>, <code>buffer-end</code>, <code>eot</code></dt>
<dd><span id="index-string_002dend-in-rx"></span>
<span id="index-eos-in-rx"></span>
<span id="index-buffer_002dend-in-rx"></span>
<span id="index-eot-in-rx"></span>
<p>Match at the end of the string or buffer being matched against.<br>
Corresponding string regexp: &lsquo;<samp>\'</samp>&rsquo;
</p>
</dd>
<dt><code>point</code></dt>
<dd><span id="index-point-in-rx"></span>
<p>Match at point.<br> Corresponding string regexp: &lsquo;<samp>\=</samp>&rsquo;
</p>
</dd>
<dt><code>word-start</code>, <code>bow</code></dt>
<dd><span id="index-word_002dstart-in-rx"></span>
<span id="index-bow-in-rx"></span>
<p>Match at the beginning of a word.<br> Corresponding string regexp: &lsquo;<samp>\&lt;</samp>&rsquo;
</p>
</dd>
<dt><code>word-end</code>, <code>eow</code></dt>
<dd><span id="index-word_002dend-in-rx"></span>
<span id="index-eow-in-rx"></span>
<p>Match at the end of a word.<br> Corresponding string regexp: &lsquo;<samp>\&gt;</samp>&rsquo;
</p>
</dd>
<dt><code>word-boundary</code></dt>
<dd><span id="index-word_002dboundary-in-rx"></span>
<p>Match at the beginning or end of a word.<br> Corresponding string regexp:
&lsquo;<samp>\b</samp>&rsquo;
</p>
</dd>
<dt><code>not-word-boundary</code></dt>
<dd><span id="index-not_002dword_002dboundary-in-rx"></span>
<p>Match anywhere but at the beginning or end of a word.<br> Corresponding string
regexp: &lsquo;<samp>\B</samp>&rsquo;
</p>
</dd>
<dt><code>symbol-start</code></dt>
<dd><span id="index-symbol_002dstart-in-rx"></span>
<p>Match at the beginning of a symbol.<br> Corresponding string regexp:
&lsquo;<samp>\_&lt;</samp>&rsquo;
</p>
</dd>
<dt><code>symbol-end</code></dt>
<dd><span id="index-symbol_002dend-in-rx"></span>
<p>Match at the end of a symbol.<br> Corresponding string regexp: &lsquo;<samp>\_&gt;</samp>&rsquo;
</p></dd>
</dl>

<span id="Capture-groups"></span><h4 class="subsubheading">Capture groups</h4>

<dl compact="compact">
<dt><code>(group <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-group-in-rx"></span>
</dd>
<dt><code>(submatch <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-submatch-in-rx"></span>
<p>Match the <var>rx</var>s, making the matched text and position accessible in the
match data.  The first group in a regexp is numbered 1; subsequent groups
will be numbered one higher than the previous group.<br> Corresponding string
regexp: &lsquo;<samp>\(&hellip;\)</samp>&rsquo;
</p>
</dd>
<dt><code>(group-n <var>n</var> <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-group_002dn-in-rx"></span>
</dd>
<dt><code>(submatch-n <var>n</var> <var>rx</var>&hellip;)</code></dt>
<dd><span id="index-submatch_002dn-in-rx"></span>
<p>Like <code>group</code>, but explicitly assign the group number <var>n</var>.  <var>n</var>
must be positive.<br> Corresponding string regexp: &lsquo;<samp>\(?<var>n</var>:&hellip;\)</samp>&rsquo;
</p>
</dd>
<dt><code>(backref <var>n</var>)</code></dt>
<dd><span id="index-backref-in-rx"></span>
<p>Match the text previously matched by group number <var>n</var>.  <var>n</var> must be
in the range 1&ndash;9.<br> Corresponding string regexp: &lsquo;<samp>\<var>n</var></samp>&rsquo;
</p></dd>
</dl>

<span id="Dynamic-inclusion"></span><h4 class="subsubheading">Dynamic inclusion</h4>

<dl compact="compact">
<dt><code>(literal <var>expr</var>)</code></dt>
<dd><span id="index-literal-in-rx"></span>
<p>Match the literal string that is the result from evaluating the Lisp
expression <var>expr</var>.  The evaluation takes place at call time, in the
current lexical environment.
</p>
</dd>
<dt><code>(regexp <var>expr</var>)</code></dt>
<dd><span id="index-regexp-in-rx"></span>
</dd>
<dt><code>(regex <var>expr</var>)</code></dt>
<dd><span id="index-regex-in-rx"></span>
<p>Match the string regexp that is the result from evaluating the Lisp
expression <var>expr</var>.  The evaluation takes place at call time, in the
current lexical environment.
</p>
</dd>
<dt><code>(eval <var>expr</var>)</code></dt>
<dd><span id="index-eval-in-rx"></span>
<p>Match the rx form that is the result from evaluating the Lisp expression
<var>expr</var>.  The evaluation takes place at macro-expansion time for
<code>rx</code>, at call time for <code>rx-to-string</code>, in the current global
environment.
</p></dd>
</dl>

<hr>
<div class="header">
<p>
Next: <a href="Rx-Functions.html" accesskey="n" rel="next">Rx Functions</a>, Up: <a href="Rx-Notation.html" accesskey="u" rel="up">Rx Notation</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
