<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.1.

Copyright (C) 1990-1996, 1998-2023 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "GNU General Public License," with the Front-Cover Texts
being "A GNU Manual," and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<title>Language Grammar (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Language Grammar (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Language Grammar (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="date" content="August 2, 2023">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Parsing-Program-Source.html" rel="up" title="Parsing Program Source">
<link href="Using-Parser.html" rel="next" title="Using Parser">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="section" id="Language-Grammar">
<div class="header">
<p>
Next: <a href="Using-Parser.html" accesskey="n" rel="next">tree-sitterパーサーの使用</a>, Up: <a href="Parsing-Program-Source.html" accesskey="u" rel="up">プログラムソースの解析</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Tree_002dsitter-Language-Grammar"></span><h3 class="section">37.1 Tree-sitter Language Grammar</h3>
<span id="index-language-grammar_002c-for-tree_002dsitter"></span>

<span id="Loading-a-language-grammar"></span><h3 class="heading">Loading a language grammar</h3>
<span id="index-loading-language-grammar-for-tree_002dsitter"></span>

<span id="index-language-argument_002c-for-tree_002dsitter"></span>
<p>Tree-sitter relies on language grammar to parse text in that language.  In
Emacs, a language grammar is represented by a symbol.  For example, the C
language grammar is represented as the symbol <code>c</code>, and <code>c</code> can be
passed to tree-sitter functions as the <var>language</var> argument.
</p>
<span id="index-treesit_002dextra_002dload_002dpath"></span>
<span id="index-treesit_002dload_002dlanguage_002derror"></span>
<p>Tree-sitter language grammars are distributed as dynamic libraries.  In
order to use a language grammar in Emacs, you need to make sure that the
dynamic library is installed on the system.  Emacs looks for language
grammars in several places, in the following order:
</p>
<ul>
<li> まず変数<code>treesit-extra-load-path</code>で指定されたディレクトリーのリストから;
</li><li> それから<code>user-emacs-directory</code>で指定されるディレクトリーのサブディレクトリー<samp>tree-sitter</samp>から(<a href="Init-File.html">initファイル</a>を参照);
</li><li> 最後にシステムのダイナミックライブラリー用のデフォルト位置。
</li></ul>

<p>In each of these directories, Emacs looks for a file with file-name
extensions specified by the variable <code>dynamic-library-suffixes</code>.
</p>
<p>Emacsがライブラリーを見つけられなかったりロードに問題がある場合には、Emacsが<code>treesit-load-language-error</code>エラーをシグナルします。このシグナルのデータは以下のいずれかです:
</p>
<dl compact="compact">
<dt><span><code>(not-found <var>error-msg</var> &hellip;)</code></span></dt>
<dd><p>This means that Emacs could not find the language grammar library.
</p></dd>
<dt><span><code>(symbol-error <var>error-msg</var>)</code></span></dt>
<dd><p>This means that Emacs could not find in the library the expected function
that every language grammar library should export.
</p></dd>
<dt><span><code>(version-mismatch <var>error-msg</var>)</code></span></dt>
<dd><p>This means that the version of the language grammar library is incompatible
with that of the tree-sitter library.
</p></dd>
</dl>

<p>上記すべてのケースにおいて、<var>error-msg</var>により失敗に関する追加の詳細が提供されるかもしれません。
</p>
<dl class="def">
<dt id="index-treesit_002dlanguage_002davailable_002dp"><span class="category">Function: </span><span><strong>treesit-language-available-p</strong> <em>language &amp;optional detail</em><a href='#index-treesit_002dlanguage_002davailable_002dp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function returns non-<code>nil</code> if the language grammar for
<var>language</var> exists and can be loaded.
</p>
<p><var>detail</var>が非<code>nil</code>の場合には、<var>language</var>が利用可能なら<code>(t
. nil)</code>、利用不可なら<code>(nil
. <var>data</var>)</code>をリターンする。<var>data</var>は<code>treesit-load-language-error</code>のシグナルデータ。
</p></dd></dl>

<span id="index-treesit_002dload_002dname_002doverride_002dlist"></span>
<p>By convention, the file name of the dynamic library for <var>language</var> is
<samp>libtree-sitter-<var>language</var>.<var>ext</var></samp>, where <var>ext</var> is the
system-specific extension for dynamic libraries.  Also by convention, the
function provided by that library is named
<code>tree_sitter_<var>language</var></code>.  If a language grammar library doesn&rsquo;t
follow this convention, you should add an entry
</p>
<div class="example">
<pre class="example">(<var>language</var> <var>library-base-name</var> <var>function-name</var>)
</pre></div>

<p>to the list in the variable <code>treesit-load-name-override-list</code>, where
<var>library-base-name</var> is the basename of the dynamic library&rsquo;s file name
(usually, <samp>libtree-sitter-<var>language</var></samp>), and <var>function-name</var> is
the function provided by the library (usually,
<code>tree_sitter_<var>language</var></code>).  For example,
</p>
<div class="example">
<pre class="example">(cool-lang &quot;libtree-sitter-coool&quot; &quot;tree_sitter_cooool&quot;)
</pre></div>

<p>これは慣例に屈するには自分があまりにも&ldquo;cool&rdquo;に過ぎると考える言語の例です。
</p>
<span id="index-language-grammar-version_002c-compatibility"></span>
<dl class="def">
<dt id="index-treesit_002dlibrary_002dabi_002dversion"><span class="category">Function: </span><span><strong>treesit-library-abi-version</strong> <em>&amp;optional min-compatible</em><a href='#index-treesit_002dlibrary_002dabi_002dversion' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function returns the version of the language grammar Application Binary
Interface (<acronym>ABI</acronym>) supported by the tree-sitter library.  By default,
it returns the latest ABI version supported by the library, but if
<var>min-compatible</var> is non-<code>nil</code>, it returns the oldest ABI version
which the library still can support.  Language grammar libraries must be
built for ABI versions between the oldest and the latest versions supported
by the tree-sitter library, otherwise the library will be unable to load
them.
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dlanguage_002dabi_002dversion"><span class="category">Function: </span><span><strong>treesit-language-abi-version</strong> <em>language</em><a href='#index-treesit_002dlanguage_002dabi_002dversion' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function returns the <acronym>ABI</acronym> version of the language grammar
library loaded by Emacs for <var>language</var>.  If <var>language</var> is
unavailable, this function returns <code>nil</code>.
</p></dd></dl>

<span id="Gou-WenturinoJu-Ti-Li"></span><h3 class="heading">構文ツリーの具体例</h3>
<span id="index-syntax-tree_002c-concrete"></span>

<p>構文ツリーはパーサーによって生成されます。構文ツリーにおけるノードはそれぞれがテキストのある部分を表し、お互いが親子関係というリレーションシップによって接続されています。たとえば以下のようなソーステキストがあるとします
</p>
<div class="example">
<pre class="example">1 + 2
</pre></div>

<p>これは以下のような構文ツリーになるかもしれません
</p>
<div class="example">
<pre class="example">                  +--------------+
                  | root &quot;1 + 2&quot; |
                  +--------------+
                         |
        +--------------------------------+
        |       expression &quot;1 + 2&quot;       |
        +--------------------------------+
           |             |            |
+------------+   +--------------+   +------------+
| number &quot;1&quot; |   | operator &quot;+&quot; |   | number &quot;2&quot; |
+------------+   +--------------+   +------------+
</pre></div>

<p>これを以下のようにS式で表すことも可能です:
</p>
<div class="example">
<pre class="example">(root (expression (number) (operator) (number)))
</pre></div>

<span id="nodotaipu"></span><h4 class="subheading">ノードタイプ</h4>
<span id="index-node-types_002c-in-a-syntax-tree"></span>

<span id="index-type-of-node_002c-tree_002dsitter"></span>
<span id="tree_002dsitter-node-type"></span><span id="index-named-node_002c-tree_002dsitter"></span>
<span id="tree_002dsitter-named-node"></span><span id="index-anonymous-node_002c-tree_002dsitter"></span>
<p><code>root</code>、<code>expression</code>、<code>number</code>、<code>operator</code>のような名前はノードの<em>タイプ(type:
型)</em>を指定します。ただし構文ツリーのすべてのノードがタイプをもつ訳ではありません。タイプをもっていないノードは<em>無名ノード(anonymous
nodes)</em>、タイプをもつノードは<em>名前つきノード(named
nodes)</em>と呼ばれています。無名ノードは角カッコ&lsquo;<samp>]</samp>&rsquo;のような区切り文字や<code>return</code>のようなキーワードを含む、固定化された綴りのトークン(token:
字句単位)です。
</p>
<span id="huirudoMing-"></span><h4 class="subheading">フィールド名</h4>

<span id="index-field-name_002c-tree_002dsitter"></span>
<span id="index-tree_002dsitter-node-field-name"></span>
<span id="tree_002dsitter-node-field-name"></span><p>To make the syntax tree easier to analyze, many language grammar assign
<em>field names</em> to child nodes.  For example, a <code>function_definition</code>
node could have a <code>declarator</code> and a <code>body</code>:
</p>
<div class="example">
<pre class="example">(function_definition
 declarator: (declaration)
 body: (compound_statement))
</pre></div>

<span id="Gou-WenturinoDiao-Cha-"></span><h3 class="heading">構文ツリーの調査</h3>
<span id="index-explore-tree_002dsitter-syntax-tree"></span>
<span id="index-inspection-of-tree_002dsitter-parse-tree-nodes"></span>

<p>To aid in understanding the syntax of a language and in debugging Lisp
programs that use the syntax tree, Emacs provides an &ldquo;explore&rdquo; mode, which
displays the syntax tree of the source in the current buffer in real time.
Emacs also comes with an &ldquo;inspect mode&rdquo;, which displays information of the
nodes at point in the mode-line.
</p>
<dl class="def">
<dt id="index-treesit_002dexplore_002dmode"><span class="category">Command: </span><span><strong>treesit-explore-mode</strong><a href='#index-treesit_002dexplore_002dmode' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>このモードはカレントバッファーのソースの構文ツリーを表示するウィンドウをポップアップする。ソースバッファーでテキストを選択することによって、表示されている構文ツリーの対応する部分がハイライトされる。構文ツリーでノードをクリックすれば、ソースバッファーの対応するテキストがハイライトされる。
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dinspect_002dmode"><span class="category">Command: </span><span><strong>treesit-inspect-mode</strong><a href='#index-treesit_002dinspect_002dmode' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>このマイナーモードはポイント位置で<em>始まる</em>ノードをモードラインに表示する。たとえばモードラインに以下のように表示されるかもしれない
</p>
<div class="example">
<pre class="example"><var>parent</var> <var>field</var>: (<var>node</var> (<var>child</var> (&hellip;)))
</pre></div>

<p>ここで<var>node</var>、<var>child</var>、...等はポイント位置で始まるノード、<var>parent</var>は<var>node</var>の親である。<var>node</var>はbold書体で表示される。<var>field-name</var>は<var>node</var>、<var>child</var>、...等のフィールド名である。
</p>
<p>ポイント位置で始まるノードがない(ポイントがノードの中間にある)場合には、ポイントを跨ぐ(span)もっとも前のノード、およびそのノードの直近の親ノードがモードラインに表示される。
</p>
<p>このマイナーモード自身はパーサーを作成せず、<code>(treesit-parser-list)</code>の最初のパーサーを使用する(<a href="Using-Parser.html">tree-sitterパーサーの使用</a>を参照)。
</p></dd></dl>

<span id="guramaDing-Yi-woDu-mu"></span><h3 class="heading">グラマー定義を読む</h3>
<span id="index-reading-grammar-definition_002c-tree_002dsitter"></span>

<p>Authors of language grammars define the <em>grammar</em> of a programming
language, which determines how a parser constructs a concrete syntax tree
out of the program text.  In order to use the syntax tree effectively, you
need to consult the <em>grammar file</em>.
</p>
<p>The grammar file is usually <samp>grammar.js</samp> in a language grammar&rsquo;s
project repository.  The link to a language grammar&rsquo;s home page can be found
on <a href="https://tree-sitter.github.io/tree-sitter">tree-sitter&rsquo;s homepage</a>.
</p>
<p>The grammar definition is written in JavaScript.  For example, the rule
matching a <code>function_definition</code> node may look like
</p>
<div class="example">
<pre class="example">function_definition: $ =&gt; seq(
  $.declaration_specifiers,
  field('declarator', $.declaration),
  field('body', $.compound_statement)
)
</pre></div>

<p>ルールは単一の引数<var>$</var>を受け取る関数によって表現されます。この関数がグラマー全体を表すのです。この関数自体は他の関数によって構築されています。一連の子ノードをまとめるのが<code>seq</code>関数、子ノードにフィールド名の注釈をつけるのが<code>field</code>関数です。上記の定義を俗に<acronym>BNF</acronym>
(<em>Backus-Naur Form: バッカス・ナウア記法</em>)と呼ばれる構文で表せば以下のようになるでしょう
</p>
<div class="example">
<pre class="example">function_definition :=
  &lt;declaration_specifiers&gt; &lt;declaration&gt; &lt;compound_statement&gt;
</pre></div>

<p>そしてパーサーがリターンするノードは以下のようになります
</p>
<div class="example">
<pre class="example">(function_definition
  (declaration_specifier)
  declarator: (declaration)
  body: (compound_statement))
</pre></div>

<p>以下はグラマー定義で目にするかもしれない関数のリストです。これらの関数はいずれも引数として他のルールを受け取り新たなルールをリターンします。
</p>
<dl compact="compact">
<dt><span><code>seq(<var>rule1</var>, <var>rule2</var>, &hellip;)</code></span></dt>
<dd><p>すべてのルールに逐一マッチする。
</p></dd>
<dt><span><code>choice(<var>rule1</var>, <var>rule2</var>, &hellip;)</code></span></dt>
<dd><p>引数のルールいずれかにマッチする。
</p></dd>
<dt><span><code>repeat(<var>rule</var>)</code></span></dt>
<dd><p>matches <var>rule</var> <em>zero or more</em> times.  This is like the &lsquo;<samp>*</samp>&rsquo;
operator in regular expressions.
</p></dd>
<dt><span><code>repeat1(<var>rule</var>)</code></span></dt>
<dd><p>matches <var>rule</var> <em>one or more</em> times.  This is like the &lsquo;<samp>+</samp>&rsquo;
operator in regular expressions.
</p></dd>
<dt><span><code>optional(<var>rule</var>)</code></span></dt>
<dd><p>matches <var>rule</var> <em>zero or one</em> times.  This is like the &lsquo;<samp>?</samp>&rsquo;
operator in regular expressions.
</p></dd>
<dt><span><code>field(<var>name</var>, <var>rule</var>)</code></span></dt>
<dd><p><var>rule</var>にマッチする子ノードにフィールド名<var>name</var>を割り当てる。
</p></dd>
<dt><span><code>alias(<var>rule</var>, <var>alias</var>)</code></span></dt>
<dd><p><var>rule</var>にマッチしたノードをパーサーが生成する構文ツリーで<var>alias</var>として表示する。たとえば、
</p>
<div class="example">
<pre class="example">alias(preprocessor_call_exp, call_expression)
</pre></div>

<p>これにより<code>preprocessor_call_exp</code>がマッチしたノードが<code>call_expression</code>と表示される。
</p></dd>
</dl>

<p>Below are grammar functions of lesser importance for reading a language
grammar.
</p>
<dl compact="compact">
<dt><span><code>token(<var>rule</var>)</code></span></dt>
<dd><p>単一の葉ノード(leaf
node)として<var>rule</var>をマークする。つまり個別の子ノードをもつ親ノードではなく、その単一の葉ノードにすべてが収斂されるようなノードを生成する。<a href="Retrieving-Nodes.html">ノードの取得</a>を参照のこと。
</p></dd>
<dt><span><code>token.immediate(<var>rule</var>)</code></span></dt>
<dd><p>Normally, grammar rules ignore preceding whitespace; this changes <var>rule</var>
to match only when there is no preceding whitespace.
</p></dd>
<dt><span><code>prec(<var>n</var>, <var>rule</var>)</code></span></dt>
<dd><p><var>rule</var>にたいしてレベル<var>n</var>の優先度を与える。
</p></dd>
<dt><span><code>prec.left([<var>n</var>,] <var>rule</var>)</code></span></dt>
<dd><p><var>rule</var>にたいしてオプションとしてレベル<var>n</var>を付与して左結合(left-associative)とマークする。
</p></dd>
<dt><span><code>prec.right([<var>n</var>,] <var>rule</var>)</code></span></dt>
<dd><p><var>rule</var>にたいしてオプションとしてレベル<var>n</var>を付与して右結合(right-associative)とマークする。
</p></dd>
<dt><span><code>prec.dynamic(<var>n</var>, <var>rule</var>)</code></span></dt>
<dd><p><code>prec</code>と似ているが優先度は実行時に適用される。
</p></dd>
</dl>

<p>tree-sitterプロジェクトには<a href="https://tree-sitter.github.io/tree-sitter/creating-parsers">more about writing a grammar</a>というドキュメントがあります。特に&ldquo;The Grammar
DSL&rdquo;というセクションを読んでください。
</p>
</div>
<hr>
<div class="header">
<p>
Next: <a href="Using-Parser.html">tree-sitterパーサーの使用</a>, Up: <a href="Parsing-Program-Source.html">プログラムソースの解析</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>


This page has generated for branch:work/emacs-29_c2d95dd00e6cb0abaf4e7550f38c8c2c9ca22f2d, commit:9d0307562aa3401e2c2270ce0f146053b300ae58 to check Japanese translation.
</body>
</html>
