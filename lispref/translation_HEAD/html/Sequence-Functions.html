<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 27.1.

Copyright (C) 1990-1996, 1998-2022 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "GNU General Public License," with the Front-Cover Texts
being "A GNU Manual," and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<title>Sequence Functions (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Sequence Functions (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Sequence Functions (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="date" content="August 20, 2023">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Sequences-Arrays-Vectors.html" rel="up" title="Sequences Arrays Vectors">
<link href="Arrays.html" rel="next" title="Arrays">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="section" id="Sequence-Functions">
<div class="header">
<p>
Next: <a href="Arrays.html" accesskey="n" rel="next">配列</a>, Up: <a href="Sequences-Arrays-Vectors.html" accesskey="u" rel="up">シーケンス、配列、ベクター</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="sikensu"></span><h3 class="section">6.1 シーケンス</h3>

<p>このセクションでは任意の種類のシーケンスを許す関数を説明します。
</p>
<dl class="def">
<dt id="index-sequencep"><span class="category">Function: </span><span><strong>sequencep</strong> <em>object</em><a href='#index-sequencep' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>object</var>がリスト、ベクター、文字列、ブールベクター、文字テーブルなら<code>t</code>、それ以外は<code>nil</code>をリターンする。以下の<code>seqp</code>も参照のこと。
</p></dd></dl>

<dl class="def">
<dt id="index-length"><span class="category">Function: </span><span><strong>length</strong> <em>sequence</em><a href='#index-length' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-string-length"></span>
<span id="index-list-length"></span>
<span id="index-vector-length"></span>
<span id="index-sequence-length"></span>
<span id="index-bool_002dvector-length"></span>
<span id="index-char_002dtable-length"></span>
<span id="Definition-of-length"></span><p>この関数は<var>sequence</var>内の要素の数をリターンする。<var>sequence</var>がシーケンス以外、またはドットリストなら<code>wrong-type-argument</code>エラーをシグナルする。引数が循環リストなら<code>circular-list</code>エラーをシグナルする。文字テーブルではEmacsの最大文字コードより1大きい値が常にリターンされる。
</p>
<p>関連する関数<code>safe-length</code>については<a href="List-Elements.html#Definition-of-safe_002dlength">Definition of safe-length</a>を参照のこと。
</p>
<div class="example">
<pre class="example">(length '(1 2 3))
    &rArr; 3
</pre><pre class="example">(length ())
    &rArr; 0
</pre><pre class="example">(length &quot;foobar&quot;)
    &rArr; 6
</pre><pre class="example">(length [1 2 3])
    &rArr; 3
</pre><pre class="example">(length (make-bool-vector 5 nil))
    &rArr; 5
</pre></div>
</dd></dl>

<p><a href="Text-Representations.html">テキストの表現方法</a>の<code>string-bytes</code>も参照されたい。
</p>
<p>ディスプレー上での文字列の幅を計算する必要があるなら、文字数だけを数えて各文字のディスプレー幅を計算しない<code>length</code>ではなく、<code>string-width</code>
(<a href="Size-of-Displayed-Text.html">表示されるテキストのサイズ</a>を参照)を使用すること。
</p>
<dl class="def">
<dt id="index-length_003c"><span class="category">Function: </span><span><strong>length&lt;</strong> <em>sequence length</em><a href='#index-length_003c' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><var>sequence</var>が<var>length</var>より短ければ非<code>nil</code>をリターンする。これは<var>sequence</var>が長いリストの場合に<var>sequence</var>の長さを計算するより効率的かもしれない。
</p></dd></dl>

<dl class="def">
<dt id="index-length_003e"><span class="category">Function: </span><span><strong>length&gt;</strong> <em>sequence length</em><a href='#index-length_003e' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><var>sequence</var>が<var>length</var>より長ければ非<code>nil</code>をリターンする。
</p></dd></dl>

<dl class="def">
<dt id="index-length_003d"><span class="category">Function: </span><span><strong>length=</strong> <em>sequence length</em><a href='#index-length_003d' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><var>sequence</var>の長さが<var>length</var>なら非<code>nil</code>をリターンする。
</p></dd></dl>

<dl class="def">
<dt id="index-elt"><span class="category">Function: </span><span><strong>elt</strong> <em>sequence index</em><a href='#index-elt' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="Definition-of-elt"></span><span id="index-elements-of-sequences"></span>
<p>この関数は<var>index</var>によりインデックスづけされた、<var>sequence</var>の要素をリターンする。<var>index</var>の値として妥当なのは、0から<var>sequence</var>の長さより1小さい数までの範囲の整数。<var>sequence</var>がリストなら範囲外の値は<code>nth</code>と同じように振る舞う。<a href="List-Elements.html#Definition-of-nth">Definition of nth</a>を参照のこと。それ以外なら範囲外の値は<code>args-out-of-range</code>エラーを引き起こす。
</p>
<div class="example">
<pre class="example">(elt [1 2 3 4] 2)
     &rArr; 3
</pre><pre class="example">(elt '(1 2 3 4) 2)
     &rArr; 3
</pre><pre class="example">;; <span class="roman"><code>elt</code>がどの文字をreturnするか明確にするために<code>string</code>を使用</span>
(string (elt &quot;1234&quot; 2))
     &rArr; &quot;3&quot;
</pre><pre class="example">(elt [1 2 3 4] 4)
     error&rarr; Args out of range: [1 2 3 4], 4
</pre><pre class="example">(elt [1 2 3 4] -1)
     error&rarr; Args out of range: [1 2 3 4], -1
</pre></div>

<p>この関数は<code>aref</code> (<a href="Array-Functions.html">配列を操作する関数</a>を参照)と<code>nth</code> (<a href="List-Elements.html#Definition-of-nth">Definition of nth</a>を参照)を一般化したものである。
</p></dd></dl>

<dl class="def">
<dt id="index-copy_002dsequence"><span class="category">Function: </span><span><strong>copy-sequence</strong> <em>seqr</em><a href='#index-copy_002dsequence' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-copying-sequences"></span>
<p>この関数は<var>seqr</var>
(シーケンスかレコードであること)のコピーをリターンする。コピーはオリジナルと同じオブジェクト型であり、同じ要素を同じ順序でもつ。しかし<var>seqr</var>が空なら長さが0の文字列やベクターと同じように関数がリターンする値はコピーではないかもしれないが、<var>seqr</var>と同じ型の空のオブジェクトである。
</p>
<p>コピーに新しい要素を格納するのは元の<var>seqr</var>に影響を与えずその逆も真である。しかし新しいシーケンス内の要素はコピーではなく、元のシーケンスの要素と同一(<code>eq</code>)になる。したがってコピーされたシーケンスを介して見つかった要素を変更するとオリジナルでも変更を見ることができる。
</p>
<p>引数がテキストプロパティーをもつ文字列なら、コピー内のプロパティーリスト自身もコピーとなり、元のシーケンスのプロパティーリストと共有はされない。しかしプロパティーリストの実際の値は共有される。<a href="Text-Properties.html">テキストのプロパティ</a>を参照のこと。
</p>
<p>この関数はドットリストでは機能しない。循環リストのコピーは無限ループを起こすだろう。
</p>
<p>シーケンスをコピーする別の方法については<a href="Building-Lists.html">コンスセルおよびリストの構築</a>の<code>append</code>、<a href="Creating-Strings.html">文字列の作成</a>の<code>concat</code>、<a href="Vector-Functions.html">ベクターのための関数</a>の<code>vconcat</code>も参照されたい。
</p>
<div class="example">
<pre class="example">(setq bar (list 1 2))
     &rArr; (1 2)
</pre><pre class="example">(setq x (vector 'foo bar))
     &rArr; [foo (1 2)]
</pre><pre class="example">(setq y (copy-sequence x))
     &rArr; [foo (1 2)]
</pre><pre class="example">

</pre><pre class="example">(eq x y)
     &rArr; nil
</pre><pre class="example">(equal x y)
     &rArr; t
</pre><pre class="example">(eq (elt x 1) (elt y 1))
     &rArr; t
</pre><pre class="example">

</pre><pre class="example">;; <span class="roman">一方のシーケンスの要素を置き換え</span>
(aset x 0 'quux)
x &rArr; [quux (1 2)]
y &rArr; [foo (1 2)]
</pre><pre class="example">

</pre><pre class="example">;; <span class="roman">共有された要素の内部を変更</span>
(setcar (aref x 1) 69)
x &rArr; [quux (69 2)]
y &rArr; [foo (69 2)]
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-reverse"><span class="category">Function: </span><span><strong>reverse</strong> <em>sequence</em><a href='#index-reverse' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-string-reverse"></span>
<span id="index-list-reverse"></span>
<span id="index-vector-reverse"></span>
<span id="index-sequence-reverse"></span>
<p>この関数は<var>sequence</var>の要素を反転した要素をもつ新たなシーケンスを作成する。元となる引数<var>sequence</var>は<em>変更されない</em>。文字テーブルは反転できないことに注意。
</p>
<div class="example">
<pre class="example">(setq x '(1 2 3 4))
     &rArr; (1 2 3 4)
</pre><pre class="example">(reverse x)
     &rArr; (4 3 2 1)
x
     &rArr; (1 2 3 4)
</pre><pre class="example">(setq x [1 2 3 4])
     &rArr; [1 2 3 4]
</pre><pre class="example">(reverse x)
     &rArr; [4 3 2 1]
x
     &rArr; [1 2 3 4]
</pre><pre class="example">(setq x &quot;xyzzy&quot;)
     &rArr; &quot;xyzzy&quot;
</pre><pre class="example">(reverse x)
     &rArr; &quot;yzzyx&quot;
x
     &rArr; &quot;xyzzy&quot;
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-nreverse"><span class="category">Function: </span><span><strong>nreverse</strong> <em>sequence</em><a href='#index-nreverse' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-reversing-a-string"></span>
<span id="index-reversing-a-list"></span>
<span id="index-reversing-a-vector"></span>
<p>この関数は<var>sequence</var>の要素を反転する。<code>reverse</code>とは異なり、元となる<var>sequence</var>は変更されるかもしれない。
</p>
<p>たとえば:
</p>
<div class="example">
<pre class="example">(setq x (list 'a 'b 'c))
     &rArr; (a b c)
</pre><pre class="example">x
     &rArr; (a b c)
(nreverse x)
     &rArr; (c b a)
</pre><pre class="example">;; <span class="roman">先頭にあったコンスセルが末尾となった</span>
x
     &rArr; (a)
</pre></div>

<p>混乱しないように、通常は元となるリストを保持する同じ変数に、<code>nreverse</code>の結果を書き戻す:
</p>
<div class="example">
<pre class="example">(setq x (nreverse x))
</pre></div>

<p>お馴染の例<code>(a b c)</code>の<code>nreverse</code>を以下に図示する:
</p>
<div class="example">
<pre class="example"><span class="roman">Original list head:</span>                       <span class="roman">Reversed list:</span>
 -------------        -------------        ------------
| car  | cdr  |      | car  | cdr  |      | car | cdr  |
|   a  |  nil |&lt;--   |   b  |   o  |&lt;--   |   c |   o  |
|      |      |   |  |      |   |  |   |  |     |   |  |
 -------------    |   --------- | -    |   -------- | -
                  |             |      |            |
                   -------------        ------------
</pre></div>

<p>setqが不要なのでベクターはより単純になる:
</p>
<div class="example">
<pre class="example">(setq x (copy-sequence [1 2 3 4]))
     &rArr; [1 2 3 4]
(nreverse x)
     &rArr; [4 3 2 1]
x
     &rArr; [4 3 2 1]
</pre></div>

<p><code>reverse</code>とは異なり、この関数は文字列では機能しない。<code>aset</code>を使用して文字列データを変更できても、たとえmutableであったとしても文字列は不変として扱うことを強く推奨する。<a href="Mutability.html">可変性</a>を参照のこと。
</p>
</dd></dl>

<dl class="def">
<dt id="index-sort"><span class="category">Function: </span><span><strong>sort</strong> <em>sequence predicate</em><a href='#index-sort' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-stable-sort"></span>
<span id="index-sorting-lists"></span>
<span id="index-sorting-vectors"></span>
<p>この関数は<var>sequence</var>を安定ソートする。この関数はすべてのシーケンスにたいしては機能せず、リストとベクターにたいしてのみ使用できることに注意されたい。<var>sequence</var>がリストなら破壊的に変更される。この関数はソートされた<var>sequence</var>をリターンして、要素の比較には<var>predicate</var>を使用する。安定ソートでは、ソートキーが等しい要素の相対順序がソートの前後で保たれる。この安定性は異なる条件により要素を並べ替えるために、連続してソートを行う場合に重要となる。
</p>
<p>引数<var>predicate</var>は2つの引数を受け取る関数でなければならない。これは<var>sequence</var>の2つの要素で呼び出される。昇順でソートするなら、1つ目の要素が2つ目の要素より&ldquo;小&rdquo;なら非<code>nil</code>、それ以外なら<code>nil</code>をリターンすること。
</p>
<p>比較関数<var>predicate</var>は、少なくとも<code>sort</code>の単一の呼び出しにおいて、与えられた任意の引数ペアにたいして信頼できる結果をリターンしなければならない。これは<em>非対照的(antisymmetric)</em>、すなわち<var>a</var>が<var>b</var>より小なら、<var>b</var>が<var>a</var>より小であってはならず、<em>推移律(transitive)</em>、すなわち<var>a</var>が<var>b</var>より小、かつ<var>b</var>が<var>c</var>より小なら、<var>a</var>は<var>c</var>より小でなければならない。これらの要件に合致しない比較関数を使用すると、<code>sort</code>の結果は予想できない。
</p>
<p><code>sort</code>のリストにたいする破壊的側面は、<small>CDR</small>を変更することにより<var>sequence</var>を形成するコンスセルを再配置することにある。非破壊ソート関数は、それらのソート順に要素を格納するために、新たなコンスセルを作成するだろう。オリジナルを破壊せずにソートしたコピーを望むなら、まず<code>copy-sequence</code>でコピーしてからソートすること。
</p>
<p>ソートにより<var>sequence</var>のコンスセルの<small>CAR</small>は変化しない。元々<var>sequence</var>内で要素<code>a</code>を含むコンスセルは、ソート後もその<small>CAR</small>に<code>a</code>を保持する。しかし<small>CDR</small>の変更により、ソート後には異なる位置に出現する。たとえば:
</p>
<div class="example">
<pre class="example">(setq nums (list 1 3 2 6 5 4 0))
     &rArr; (1 3 2 6 5 4 0)
</pre><pre class="example">(sort nums #'&lt;)
     &rArr; (0 1 2 3 4 5 6)
</pre><pre class="example">nums
     &rArr; (1 2 3 4 5 6)
</pre></div>

<p><strong>警告</strong>
<code>nums</code>内のリストが0を含まないことに注意。これはソート前と同じコンスセルだがもはやリストの先頭ではない。ソート前に引数を保持していた変数がソート済みリスト全体を保持すると仮定してはならない!
かわりに<code>sort</code>の結果を保存して、それを使うこと。ほとんどの場合、わたしたちは元のリストを保持していた変数に結果を書き戻すようにしている。
</p>
<div class="example">
<pre class="example">(setq nums (sort nums #'&lt;))
</pre></div>

<p>安定ソートの何たるかをより理解するには、以下のベクターのサンプルを考えてみよ。ソート後、<code>car</code>が8であるようなすべてのアイテムは<code>vector</code>の先頭にグループ化されるが、それらの相対的な順序は保たれる。<code>car</code>が9であるようなすべてのアイテムは<code>vector</code>の末尾にグループ化されるが、それらの相対的な順序も保たれる。
</p>
<div class="example">
<pre class="example">(setq
  vector
  (vector '(8 . &quot;xxx&quot;) '(9 . &quot;aaa&quot;) '(8 . &quot;bbb&quot;) '(9 . &quot;zzz&quot;)
          '(9 . &quot;ppp&quot;) '(8 . &quot;ttt&quot;) '(8 . &quot;eee&quot;) '(9 . &quot;fff&quot;)))
     &rArr; [(8 . &quot;xxx&quot;) (9 . &quot;aaa&quot;) (8 . &quot;bbb&quot;) (9 . &quot;zzz&quot;)
         (9 . &quot;ppp&quot;) (8 . &quot;ttt&quot;) (8 . &quot;eee&quot;) (9 . &quot;fff&quot;)]
</pre><pre class="example">(sort vector (lambda (x y) (&lt; (car x) (car y))))
     &rArr; [(8 . &quot;xxx&quot;) (8 . &quot;bbb&quot;) (8 . &quot;ttt&quot;) (8 . &quot;eee&quot;)
         (9 . &quot;aaa&quot;) (9 . &quot;zzz&quot;) (9 . &quot;ppp&quot;) (9 . &quot;fff&quot;)]
</pre></div>

<p>ソートを行う他の関数については<a href="Sorting.html">テキストのソート</a>を参照のこと。<code>sort</code>の有用な例は、<a href="Accessing-Documentation.html">ドキュメント文字列へのアクセス</a>の<code>documentation</code>を参照されたい。
</p></dd></dl>

<span id="index-sequence-functions-in-seq"></span>
<span id="index-seq-library"></span>
<span id="index-sequences_002c-generalized"></span>
<p>The <samp>seq.el</samp> library provides the following additional sequence
manipulation macros and functions, prefixed with <code>seq-</code>.
</p>
<p>このライブラリー内で定義されたすべての関数は、副作用をもちません。これらは引数として渡されたすべてのシーケンス(リスト、ベクター、文字列)を変更しません。特に明記しなければ、結果は入力と同じ型のシーケンスです。述語を受け取る関数では、それらは単一の関数である必要があります。
</p>
<p><samp>seq.el</samp>ライブラリーは、シーケンシャルなデータ構造の追加型で機能するように拡張可能です。そのためにすべての関数は<code>cl-defgeneric</code>を使用して定義されています。<code>cl-defgeneric</code>を使用した拡張の追加に関する詳細は、<a href="Generic-Functions.html">ジェネリック関数</a>を参照してください。
</p>
<dl class="def">
<dt id="index-seq_002delt"><span class="category">Function: </span><span><strong>seq-elt</strong> <em>sequence index</em><a href='#index-seq_002delt' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>index</var>(有効な範囲は0から<var>sequence</var>の長さより1少ない整数)で指定された<var>sequence</var>の要素をリターンする。ビルトインのシーケンス型にたいする範囲外(out-of-range)の値にたいして、<code>seq-elt</code>は<code>elt</code>と同様に振る舞う。詳細は<a href="#Definition-of-elt">Definition of elt</a>を参照のこと。
</p>
<div class="example">
<pre class="example">(seq-elt [1 2 3 4] 2)
&rArr; 3
</pre></div>

<p><code>seq-elt</code>は<code>setf</code>を使用してセット可能なplaceをリターンする(<a href="Setting-Generalized-Variables.html"><code>setf</code>マクロ</a>を参照)。
</p>
<div class="example">
<pre class="example">(setq vec [1 2 3 4])
(setf (seq-elt vec 2) 5)
vec
&rArr; [1 2 5 4]
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dlength"><span class="category">Function: </span><span><strong>seq-length</strong> <em>sequence</em><a href='#index-seq_002dlength' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>内の要素の個数をリターンする。ビルトインのシーケンス型にたいして<code>seq-length</code>は<code>length</code>と同様に振る舞う。<a href="#Definition-of-length">Definition of length</a>を参照のこと。
</p></dd></dl>

<dl class="def">
<dt id="index-seqp"><span class="category">Function: </span><span><strong>seqp</strong> <em>object</em><a href='#index-seqp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>object</var>がシーケンス(リストか配列)、または<samp>seq.el</samp>のジェネリック関数を通じて定義されたすべての追加シーケンス型なら非<code>nil</code>をリターンする。これは<code>sequencep</code>の拡張された変種である。
</p>
<div class="example">
<pre class="example">(seqp [1 2])
&rArr; t
</pre><pre class="example">(seqp 2)
&rArr; nil
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002ddrop"><span class="category">Function: </span><span><strong>seq-drop</strong> <em>sequence n</em><a href='#index-seq_002ddrop' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の最初の<var>n</var>個(整数)を除く、すべての要素をリターンする.<var>n</var>が0以下なら結果は<var>sequence</var>。
</p>
<div class="example">
<pre class="example">(seq-drop [1 2 3 4 5 6] 3)
&rArr; [4 5 6]
</pre><pre class="example">(seq-drop &quot;hello world&quot; -4)
&rArr; &quot;hello world&quot;
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dtake"><span class="category">Function: </span><span><strong>seq-take</strong> <em>sequence n</em><a href='#index-seq_002dtake' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の最初の<var>n</var>個(整数)の要素をリターンする。<var>n</var>が0以下なら結果は<code>nil</code>。
</p>
<div class="example">
<pre class="example">(seq-take '(1 2 3 4) 3)
&rArr; (1 2 3)
</pre><pre class="example">(seq-take [1 2 3 4] 0)
&rArr; []
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dtake_002dwhile"><span class="category">Function: </span><span><strong>seq-take-while</strong> <em>predicate sequence</em><a href='#index-seq_002dtake_002dwhile' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>のメンバーを順にリターンし、<var>predicate</var>が最初に<code>nil</code>をリターンした要素の前で停止する。
</p>
<div class="example">
<pre class="example">(seq-take-while (lambda (elt) (&gt; elt 0)) '(1 2 3 -1 -2))
&rArr; (1 2 3)
</pre><pre class="example">(seq-take-while (lambda (elt) (&gt; elt 0)) [-1 4 6])
&rArr; []
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002ddrop_002dwhile"><span class="category">Function: </span><span><strong>seq-drop-while</strong> <em>predicate sequence</em><a href='#index-seq_002ddrop_002dwhile' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>predicate</var>が最初に<code>nil</code>をリターンした要素から、<var>sequence</var>のメンバーを順にリターンする。
</p>
<div class="example">
<pre class="example">(seq-drop-while (lambda (elt) (&gt; elt 0)) '(1 2 3 -1 -2))
&rArr; (-1 -2)
</pre><pre class="example">(seq-drop-while (lambda (elt) (&lt; elt 0)) [1 4 6])
&rArr; [1 4 6]
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dsplit"><span class="category">Function: </span><span><strong>seq-split</strong> <em>sequence length</em><a href='#index-seq_002dsplit' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function returns a list consisting of sub-sequences of <var>sequence</var>
of (at most) length <var>length</var>.  (The final element may be shorter than
<var>length</var> if the length of <var>sequence</var> isn&rsquo;t a multiple of
<var>length</var>.
</p>
<div class="example">
<pre class="example">(seq-split [0 1 2 3 4] 2)
&rArr; ([0 1] [2 3] [4])
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002ddo"><span class="category">Function: </span><span><strong>seq-do</strong> <em>function sequence</em><a href='#index-seq_002ddo' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の各要素にたいして、(恐らくは副作用を得るために)順番に<var>function</var>を適用して、<var>sequence</var>をリターンする。
</p></dd></dl>

<dl class="def">
<dt id="index-seq_002dmap"><span class="category">Function: </span><span><strong>seq-map</strong> <em>function sequence</em><a href='#index-seq_002dmap' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の各要素に<var>function</var>を適用した結果をリターンする。リターン値はリスト。
</p>
<div class="example">
<pre class="example">(seq-map #'1+ '(2 4 6))
&rArr; (3 5 7)
</pre><pre class="example">(seq-map #'symbol-name [foo bar])
&rArr; (&quot;foo&quot; &quot;bar&quot;)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dmap_002dindexed"><span class="category">Function: </span><span><strong>seq-map-indexed</strong> <em>function sequence</em><a href='#index-seq_002dmap_002dindexed' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の各要素および<var>seq</var>であるようなインデックスに<var>function</var>を適用した結果をリターンする。リターン値はリスト。
</p>
<div class="example">
<pre class="example">(seq-map-indexed (lambda (elt idx)
                   (list idx elt))
                 '(a b c))
&rArr; ((0 a) (1 b) (2 c))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dmapn"><span class="category">Function: </span><span><strong>seq-mapn</strong> <em>function &amp;rest sequences</em><a href='#index-seq_002dmapn' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequences</var>の各要素に<var>function</var>を適用した結果をリターンする。 <var>function</var>のarity
(関数が受け取れる引数の個数。<a href="What-Is-a-Function.html">subr-arity</a>を参照)はシーケンスの個数にマッチしなければならない。マッピングは最短のシーケンス終端で停止する。リターン値はリスト。
</p>
<div class="example">
<pre class="example">(seq-mapn #'+ '(2 4 6) '(20 40 60))
&rArr; (22 44 66)
</pre><pre class="example">(seq-mapn #'concat '(&quot;moskito&quot; &quot;bite&quot;) [&quot;bee&quot; &quot;sting&quot;])
&rArr; (&quot;moskitobee&quot; &quot;bitesting&quot;)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dfilter"><span class="category">Function: </span><span><strong>seq-filter</strong> <em>predicate sequence</em><a href='#index-seq_002dfilter' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-filtering-sequences"></span>
<p>この関数は<var>predicate</var>が非<code>nil</code>をリターンした<var>sequence</var>内のすべての要素のリストをリターンする。
</p>
<div class="example">
<pre class="example">(seq-filter (lambda (elt) (&gt; elt 0)) [1 -1 3 -3 5])
&rArr; (1 3 5)
</pre><pre class="example">(seq-filter (lambda (elt) (&gt; elt 0)) '(-1 -3 -5))
&rArr; nil
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dremove"><span class="category">Function: </span><span><strong>seq-remove</strong> <em>predicate sequence</em><a href='#index-seq_002dremove' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-removing-from-sequences"></span>
<p>この関数は<var>predicate</var>が<code>nil</code>をリターンした<var>sequence</var>内のすべての要素のリストをリターンする。
</p>
<div class="example">
<pre class="example">(seq-remove (lambda (elt) (&gt; elt 0)) [1 -1 3 -3 5])
&rArr; (-1 -3)
</pre><pre class="example">(seq-remove (lambda (elt) (&lt; elt 0)) '(-1 -3 -5))
&rArr; nil
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dremove_002dat_002dposition"><span class="category">Function: </span><span><strong>seq-remove-at-position</strong> <em>sequence n</em><a href='#index-seq_002dremove_002dat_002dposition' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-removing-from-sequences-1"></span>
<p>This function returns a copy of <var>sequence</var> where the element at
(zero-based) index <var>n</var> got removed.  The result is a sequence of the
same type as <var>sequence</var>.
</p>
<div class="example">
<pre class="example">(seq-remove-at-position [1 -1 3 -3 5] 0)
&rArr; [-1 3 -3 5]
</pre><pre class="example">(seq-remove-at-position [1 -1 3 -3 5] 3)
&rArr; [1 -1 3 5]
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dkeep"><span class="category">Function: </span><span><strong>seq-keep</strong> <em>function sequence</em><a href='#index-seq_002dkeep' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function returns a list of all non-<code>nil</code> results from calling
<var>function</var> on the elements in <var>sequence</var>.
</p>
<div class="example">
<pre class="example">(seq-keep #'cl-digit-char-p '(?6 ?a ?7))
&rArr; (6 7)
</pre></div>

</dd></dl>

<dl class="def">
<dt id="index-seq_002dreduce"><span class="category">Function: </span><span><strong>seq-reduce</strong> <em>function sequence initial-value</em><a href='#index-seq_002dreduce' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-reducing-sequences"></span>
<p>この関数は<var>initial-value</var>と<var>sequence</var>の1つ目の要素で<var>function</var>を呼び出し、次にその結果と<var>sequence</var>の2つ目の要素で<var>function</var>を呼び出し、その次にその結果と<var>sequence</var>の3つ目の要素で、...と呼び出した結果をリターンする。<var>function</var>は引数が2つの関数であること。
</p>
<p><var>function</var>は2つの引数で呼び出される。1つ目の引数として<var>intial-value</var>
(その後は累積値)、2つ目の引数として<var>sequence</var>内の要素が使用される。
</p>
<p><var>sequence</var>が空なら、<var>function</var>を呼び出さずに<var>initial-value</var>をリターンする。
</p>
<div class="example">
<pre class="example">(seq-reduce #'+ [1 2 3 4] 0)
&rArr; 10
</pre><pre class="example">(seq-reduce #'+ '(1 2 3 4) 5)
&rArr; 15
</pre><pre class="example">(seq-reduce #'+ '() 3)
&rArr; 3
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dsome"><span class="category">Function: </span><span><strong>seq-some</strong> <em>predicate sequence</em><a href='#index-seq_002dsome' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の各要素に順に<var>predicate</var>を適用してリターンされた、最初の非<code>nil</code>値をリターンする。
</p>
<div class="example">
<pre class="example">(seq-some #'numberp [&quot;abc&quot; 1 nil])
&rArr; t
</pre><pre class="example">(seq-some #'numberp [&quot;abc&quot; &quot;def&quot;])
&rArr; nil
</pre><pre class="example">(seq-some #'null [&quot;abc&quot; 1 nil])
&rArr; t
</pre><pre class="example">(seq-some #'1+ [2 4 6])
&rArr; 3
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dfind"><span class="category">Function: </span><span><strong>seq-find</strong> <em>predicate sequence &amp;optional default</em><a href='#index-seq_002dfind' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>predicate</var>が非<code>nil</code>をリターンした、<var>sequence</var>内の最初の要素をリターンする。<var>predicate</var>にマッチする要素がなければ、この関数は<var>default</var>をリターンする。
</p>
<p>この関数は見つかった要素が<var>default</var>と等しい場合、要素が見つかったかどうかを知る術がないので曖昧さをもつことに注意。
</p>
<div class="example">
<pre class="example">(seq-find #'numberp [&quot;abc&quot; 1 nil])
&rArr; 1
</pre><pre class="example">(seq-find #'numberp [&quot;abc&quot; &quot;def&quot;])
&rArr; nil
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002devery_002dp"><span class="category">Function: </span><span><strong>seq-every-p</strong> <em>predicate sequence</em><a href='#index-seq_002devery_002dp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の各要素に<var>predicate</var>を適用して、すべてが非<code>nil</code>をリターンしたら非<code>nil</code>をリターンする。
</p>
<div class="example">
<pre class="example">(seq-every-p #'numberp [2 4 6])
&rArr; t
</pre><pre class="example">(seq-every-p #'numberp [2 4 &quot;6&quot;])
&rArr; nil
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dempty_002dp"><span class="category">Function: </span><span><strong>seq-empty-p</strong> <em>sequence</em><a href='#index-seq_002dempty_002dp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>が空なら<code>nil</code>をリターンする。
</p>
<div class="example">
<pre class="example">(seq-empty-p &quot;not empty&quot;)
&rArr; nil
</pre><pre class="example">(seq-empty-p &quot;&quot;)
&rArr; t
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dcount"><span class="category">Function: </span><span><strong>seq-count</strong> <em>predicate sequence</em><a href='#index-seq_002dcount' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>内で<var>predicate</var>が非<code>nil</code>をリターンした要素の個数をリターンする。
</p>
<div class="example">
<pre class="example">(seq-count (lambda (elt) (&gt; elt 0)) [-1 2 0 3 -2])
&rArr; 2
</pre></div>
</dd></dl>

<span id="index-sorting-sequences"></span>
<dl class="def">
<dt id="index-seq_002dsort"><span class="category">Function: </span><span><strong>seq-sort</strong> <em>function sequence</em><a href='#index-seq_002dsort' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>function</var>に応じてソートされた<var>sequence</var>のコピーをリターンする。<var>function</var>は2つの引数を受け取り、1つ目の引数が2つ目より前にソートされるべきなら非<code>nil</code>をリターンする。
</p></dd></dl>

<dl class="def">
<dt id="index-seq_002dsort_002dby"><span class="category">Function: </span><span><strong>seq-sort-by</strong> <em>function predicate sequence</em><a href='#index-seq_002dsort_002dby' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<code>seq-sort</code>と似ているがソート前に<var>sequence</var>の要素に<var>function</var>を適用して変換する点が異なる。<var>function</var>は単一の引数を受け取る関数。
</p>
<div class="example">
<pre class="example">(seq-sort-by #'seq-length #'&gt; [&quot;a&quot; &quot;ab&quot; &quot;abc&quot;])
&rArr; [&quot;abc&quot; &quot;ab&quot; &quot;a&quot;]
</pre></div>
</dd></dl>


<dl class="def">
<dt id="index-seq_002dcontains_002dp"><span class="category">Function: </span><span><strong>seq-contains-p</strong> <em>sequence elt &amp;optional function</em><a href='#index-seq_002dcontains_002dp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>内の少なくとも1つの要素が<var>elt</var>とequalなら非<code>nil</code>をリターンする。オプション引数<var>function</var>が非<code>nil</code>なら、それはデフォルトの<code>equal</code>のかわりに使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<pre class="example">(seq-contains-p '(symbol1 symbol2) 'symbol1)
&rArr; t
</pre><pre class="example">(seq-contains-p '(symbol1 symbol2) 'symbol3)
&rArr; nil
</pre></div>

</dd></dl>

<dl class="def">
<dt id="index-seq_002dset_002dequal_002dp"><span class="category">Function: </span><span><strong>seq-set-equal-p</strong> <em>sequence1 sequence2 &amp;optional testfn</em><a href='#index-seq_002dset_002dequal_002dp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は順序とは無関係に<var>sequence1</var>と<var>sequence2</var>が同じ要素を含むかどうかをチェックする。オプション引数<var>testfn</var>が非<code>nil</code>なら、デフォルトの<code>equal</code>のかわりに使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<pre class="example">(seq-set-equal-p '(a b c) '(c b a))
&rArr; t
</pre><pre class="example">(seq-set-equal-p '(a b c) '(c b))
&rArr; nil
</pre><pre class="example">(seq-set-equal-p '(&quot;a&quot; &quot;b&quot; &quot;c&quot;) '(&quot;c&quot; &quot;b&quot; &quot;a&quot;))
&rArr; t
</pre><pre class="example">(seq-set-equal-p '(&quot;a&quot; &quot;b&quot; &quot;c&quot;) '(&quot;c&quot; &quot;b&quot; &quot;a&quot;) #'eq)
&rArr; nil
</pre></div>

</dd></dl>

<dl class="def">
<dt id="index-seq_002dposition"><span class="category">Function: </span><span><strong>seq-position</strong> <em>sequence elt &amp;optional function</em><a href='#index-seq_002dposition' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function returns the (zero-based) index of the first element in
<var>sequence</var> that is equal to <var>elt</var>.  If the optional argument
<var>function</var> is non-<code>nil</code>, it is a function of two arguments to use
instead of the default <code>equal</code>.
</p>
<div class="example">
<pre class="example">(seq-position '(a b c) 'b)
&rArr; 1
</pre><pre class="example">(seq-position '(a b c) 'd)
&rArr; nil
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dpositions"><span class="category">Function: </span><span><strong>seq-positions</strong> <em>sequence elt &amp;optional testfn</em><a href='#index-seq_002dpositions' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function returns a list of the (zero-based) indices of the elements in
<var>sequence</var> for which <var>testfn</var> returns non-<code>nil</code> when passed the
element and <var>elt</var> as arguments. <var>testfn</var> defaults to <code>equal</code>.
</p>
<div class="example">
<pre class="example">(seq-positions '(a b c a d) 'a)
&rArr; (0 3)
</pre><pre class="example">(seq-positions '(a b c a d) 'z)
&rArr; nil
</pre><pre class="example">(seq-positions '(11 5 7 12 9 15) 10 #'&gt;=)
&rArr; (0 3 5)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002duniq"><span class="category">Function: </span><span><strong>seq-uniq</strong> <em>sequence &amp;optional function</em><a href='#index-seq_002duniq' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は重複を削除した<var>sequence</var>の要素のリストをリターンする。オプション引数<var>function</var>が非<code>nil</code>なら、それはデフォルトの<code>equal</code>のかわりに使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<pre class="example">(seq-uniq '(1 2 2 1 3))
&rArr; (1 2 3)
</pre><pre class="example">(seq-uniq '(1 2 2.0 1.0) #'=)
&rArr; (1 2)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dsubseq"><span class="category">Function: </span><span><strong>seq-subseq</strong> <em>sequence start &amp;optional end</em><a href='#index-seq_002dsubseq' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-sub_002dsequence"></span>
<p>この関数は<var>sequence</var>の<var>start</var>から<var>end</var>(いずれも整数)までのサブセットをリターンする(<var>end</var>のデフォルトは最後の要素)。<var>start</var>か<var>end</var>が負なら<var>sequence</var>の最後から数える。
</p>
<div class="example">
<pre class="example">(seq-subseq '(1 2 3 4 5) 1)
&rArr; (2 3 4 5)
</pre><pre class="example">(seq-subseq '[1 2 3 4 5] 1 3)
&rArr; [2 3]
</pre><pre class="example">(seq-subseq '[1 2 3 4 5] -3 -1)
&rArr; [3 4]
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dconcatenate"><span class="category">Function: </span><span><strong>seq-concatenate</strong> <em>type &amp;rest sequences</em><a href='#index-seq_002dconcatenate' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequences</var>を結合して作成された<var>type</var>型のシーケンスをリターンする。<var>type</var>は<code>vector</code>、<code>list</code>、<code>string</code>のいずれか。
</p>
<div class="example">
<pre class="example">(seq-concatenate 'list '(1 2) '(3 4) [5 6])
&rArr; (1 2 3 4 5 6)
</pre><pre class="example">(seq-concatenate 'string &quot;Hello &quot; &quot;world&quot;)
&rArr; &quot;Hello world&quot;
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dmapcat"><span class="category">Function: </span><span><strong>seq-mapcat</strong> <em>function sequence &amp;optional type</em><a href='#index-seq_002dmapcat' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の各要素に<var>function</var>を適用した結果に、<code>seq-concatenate</code>を適用した結果をリターンする。結果は<var>type</var>型のシーケンス、または<var>type</var>が<code>nil</code>ならリストである。
</p>
<div class="example">
<pre class="example">(seq-mapcat #'seq-reverse '((3 2 1) (6 5 4)))
&rArr; (1 2 3 4 5 6)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dpartition"><span class="category">Function: </span><span><strong>seq-partition</strong> <em>sequence n</em><a href='#index-seq_002dpartition' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は長さ<var>n</var>のサブシーケンスへグループ化した<var>sequence</var>の要素のリストをリターンする。最後のシーケンスに含まれる要素は<var>n</var>より少ないかもしれない。<var>n</var>は整数であること。<var>n</var>が0以下の整数ならリターン値は<code>nil</code>。
</p>
<div class="example">
<pre class="example">(seq-partition '(0 1 2 3 4 5 6 7) 3)
&rArr; ((0 1 2) (3 4 5) (6 7))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dunion"><span class="category">Function: </span><span><strong>seq-union</strong> <em>sequence1 sequence2 &amp;optional function</em><a href='#index-seq_002dunion' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-sequences_002c-union-of"></span>
<span id="index-union-of-sequences"></span>
<p>この関数は<var>sequence1</var>と<var>sequence2</var>のいずれかに出現する要素のリストをリターンする。リターンされるリストの要素はすべて、2要素を比較してequalにならないという意味において一意である。オプション引数<var>function</var>が非<code>nil</code>なら、それはデフォルトの<code>equal</code>のかわりに比較に使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<pre class="example">(seq-union [1 2 3] [3 5])
&rArr; (1 2 3 5)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dintersection"><span class="category">Function: </span><span><strong>seq-intersection</strong> <em>sequence1 sequence2 &amp;optional function</em><a href='#index-seq_002dintersection' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-sequences_002c-intersection-of"></span>
<span id="index-intersection-of-sequences"></span>
<p>この関数は<var>sequence1</var>と<var>sequence2</var>の両方に出現する要素のリストをリターンする。オプション引数<var>function</var>が非<code>nil</code>なら、それはデフォルトの<code>equal</code>のかわりに比較に使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<pre class="example">(seq-intersection [2 3 4 5] [1 3 5 6 7])
&rArr; (3 5)
</pre></div>
</dd></dl>


<dl class="def">
<dt id="index-seq_002ddifference"><span class="category">Function: </span><span><strong>seq-difference</strong> <em>sequence1 sequence2 &amp;optional function</em><a href='#index-seq_002ddifference' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence1</var>に出現するが<var>sequence2</var>に出現しない要素のリストをリターンする。オプション引数<var>function</var>が非<code>nil</code>なら、それはデフォルトの<code>equal</code>のかわりに比較に使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<pre class="example">(seq-difference '(2 3 4 5) [1 3 5 6 7])
&rArr; (2 4)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dgroup_002dby"><span class="category">Function: </span><span><strong>seq-group-by</strong> <em>function sequence</em><a href='#index-seq_002dgroup_002dby' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の各要素に<var>function</var>を適用して、その結果をキーとして<var>sequence</var>をalistに分割する。キーの比較には<code>equal</code>を使用する。
</p>
<div class="example">
<pre class="example">(seq-group-by #'integerp '(1 2.1 3 2 3.2))
&rArr; ((t 1 3 2) (nil 2.1 3.2))
</pre><pre class="example">(seq-group-by #'car '((a 1) (b 2) (a 3) (c 4)))
&rArr; ((b (b 2)) (a (a 1) (a 3)) (c (c 4)))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dinto"><span class="category">Function: </span><span><strong>seq-into</strong> <em>sequence type</em><a href='#index-seq_002dinto' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-convert-sequence-to-another-type"></span>
<span id="index-list-to-vector"></span>
<span id="index-vector-to-list"></span>
<span id="index-string-to-vector"></span>
<p>この関数はシーケンス<var>sequence</var>を<var>type</var>型のシーケンスに変換する。<var>type</var>は<code>vector</code>、<code>string</code>、<code>list</code>のいずれかであること。
</p>
<div class="example">
<pre class="example">(seq-into [1 2 3] 'list)
&rArr; (1 2 3)
</pre><pre class="example">(seq-into nil 'vector)
&rArr; []
</pre><pre class="example">(seq-into &quot;hello&quot; 'vector)
&rArr; [104 101 108 108 111]
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dmin"><span class="category">Function: </span><span><strong>seq-min</strong> <em>sequence</em><a href='#index-seq_002dmin' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-minimum-value-of-sequence"></span>
<span id="index-sequence-minimum"></span>
<p>この関数は<var>sequence</var>の最小の要素をリターンする。<var>sequence</var>の要素は数字かマーカー(<a href="Markers.html">マーカー</a>を参照)でなければならない。
</p>
<div class="example">
<pre class="example">(seq-min [3 1 2])
&rArr; 1
</pre><pre class="example">(seq-min &quot;Hello&quot;)
&rArr; 72
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dmax"><span class="category">Function: </span><span><strong>seq-max</strong> <em>sequence</em><a href='#index-seq_002dmax' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-maximum-value-of-sequence"></span>
<span id="index-sequence-maximum"></span>
<p>この関数は<var>sequence</var>の最大の要素をリターンする。<var>sequence</var>の要素は数字かマーカーでなければならない。
</p>
<div class="example">
<pre class="example">(seq-max [1 3 2])
&rArr; 3
</pre><pre class="example">(seq-max &quot;Hello&quot;)
&rArr; 111
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002ddoseq"><span class="category">Macro: </span><span><strong>seq-doseq</strong> <em>(var sequence) body&hellip;</em><a href='#index-seq_002ddoseq' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-sequence-iteration"></span>
<span id="index-iteration-over-vector-or-string"></span>
<p>このマクロは<code>dolist</code> (<a href="Iteration.html">dolist</a>を参照)と同様だが、<var>sequence</var>にリスト、ベクター、文字列のいずれかを指定できる点が異なる。これ主な利点は副作用である。
</p></dd></dl>

<span id="seq_002dlet"></span><dl class="def">
<dt id="index-seq_002dlet"><span class="category">Macro: </span><span><strong>seq-let</strong> <em>var-sequence val-sequence body&hellip;</em><a href='#index-seq_002dlet' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-sequence-destructuring"></span>
<p>このマクロは<var>var-sequence</var>内で定義される変数に<var>val-sequence</var>の対応する要素をバインドする。これは<em>分割代入(destructuring
binding)</em>として知られている。<var>var-sequence</var>の要素は、ネストされた非構造化を許容することにより自身にシーケンスを含むことができる。
</p>
<p><var>var-sequence</var>シーケンスには、<var>val-sequence</var>の残りにバインドされる変数名が後続するような<code>&amp;rest</code>マーカーを含めることもできる。
</p>
<div class="example">
<pre class="example">(seq-let [first second] [1 2 3 4]
  (list first second))
&rArr; (1 2)
</pre><pre class="example">(seq-let (_ a _ b) '(1 2 3 4)
  (list a b))
&rArr; (2 4)
</pre><pre class="example">(seq-let [a [b [c]]] [1 [2 [3]]]
  (list a b c))
&rArr; (1 2 3)
</pre><pre class="example">(seq-let [a b &amp;rest others] [1 2 3 4]
  others)
</pre><pre class="example">&rArr; [3 4]
</pre></div>

<p><code>pcase</code>パターンは分割代入にたいする代替えの機能を提供する。<a href="Destructuring-with-pcase-Patterns.html"><code>pcase</code>パターンによる分解</a>を参照のこと。
</p></dd></dl>

<dl class="def">
<dt id="index-seq_002dsetq"><span class="category">Macro: </span><span><strong>seq-setq</strong> <em>var-sequence val-sequence</em><a href='#index-seq_002dsetq' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-sequence-destructuring-1"></span>
<p>このマクロは<code>seq-let</code>と同様に機能するが、<code>let</code>ではなくあたかも<code>setq</code>で値が変数にバインドされる点が異なる。
</p>
<div class="example">
<pre class="example">(let ((a nil)
      (b nil))
  (seq-setq (_ a _ b) '(1 2 3 4))
  (list a b))
&rArr; (2 4)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002drandom_002delt"><span class="category">Function: </span><span><strong>seq-random-elt</strong> <em>sequence</em><a href='#index-seq_002drandom_002delt' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の要素をランダムにリターンする。
</p>
<div class="example">
<pre class="example">(seq-random-elt [1 2 3 4])
&rArr; 3
(seq-random-elt [1 2 3 4])
&rArr; 2
(seq-random-elt [1 2 3 4])
&rArr; 4
(seq-random-elt [1 2 3 4])
&rArr; 2
(seq-random-elt [1 2 3 4])
&rArr; 1
</pre></div>

<p><var>sequence</var>が空ならこの関数はエラーをシグナルする。
</p></dd></dl>

</div>
<hr>
<div class="header">
<p>
Next: <a href="Arrays.html">配列</a>, Up: <a href="Sequences-Arrays-Vectors.html">シーケンス、配列、ベクター</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>


This page has generated for branch:master, commit:6bdeb51b4571495eab508d1e465792aca5ba6622 to check Japanese translation.
</body>
</html>
