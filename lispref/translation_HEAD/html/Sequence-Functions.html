<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 30.0.50.

Copyright (C) 1990-1996, 1998-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "GNU General Public License," with the Front-Cover Texts
being "A GNU Manual," and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<title>Sequence Functions (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Sequence Functions (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Sequence Functions (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="date" content="June 2, 2024">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Sequences-Arrays-Vectors.html" rel="up" title="Sequences Arrays Vectors">
<link href="Arrays.html" rel="next" title="Arrays">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="section" id="Sequence-Functions">
<div class="header">
<p>
Next: <a href="Arrays.html" accesskey="n" rel="next">配列</a>, Up: <a href="Sequences-Arrays-Vectors.html" accesskey="u" rel="up">シーケンス、配列、ベクター</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="sikensu"></span><h3 class="section">6.1 シーケンス</h3>

<p>このセクションでは任意の種類のシーケンスを許す関数を説明します。
</p>
<dl class="def">
<dt id="index-sequencep"><span class="category">Function: </span><span><strong>sequencep</strong> <em>object</em><a href='#index-sequencep' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>object</var>がリスト、ベクター、文字列、ブールベクター、文字テーブルなら<code>t</code>、それ以外は<code>nil</code>をリターンする。以下の<code>seqp</code>も参照のこと。
</p></dd></dl>

<dl class="def">
<dt id="index-length"><span class="category">Function: </span><span><strong>length</strong> <em>sequence</em><a href='#index-length' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-string-length"></span>
<span id="index-list-length"></span>
<span id="index-vector-length"></span>
<span id="index-sequence-length"></span>
<span id="index-bool_002dvector-length"></span>
<span id="index-char_002dtable-length"></span>
<span id="Definition-of-length"></span><p>この関数は<var>sequence</var>内の要素の数をリターンする。<var>sequence</var>がシーケンス以外、またはドットリストなら<code>wrong-type-argument</code>エラーをシグナルする。引数が循環リストなら<code>circular-list</code>エラーをシグナルする。文字テーブルではEmacsの最大文字コードより1大きい値が常にリターンされる。
</p>
<p>関連する関数<code>safe-length</code>については<a href="List-Elements.html#Definition-of-safe_002dlength">Definition of safe-length</a>を参照のこと。
</p>
<div class="example">
<pre class="example">(length '(1 2 3))
    &rArr; 3
</pre><pre class="example">(length ())
    &rArr; 0
</pre><pre class="example">(length &quot;foobar&quot;)
    &rArr; 6
</pre><pre class="example">(length [1 2 3])
    &rArr; 3
</pre><pre class="example">(length (make-bool-vector 5 nil))
    &rArr; 5
</pre></div>
</dd></dl>

<p><a href="Text-Representations.html">テキストの表現方法</a>の<code>string-bytes</code>も参照されたい。
</p>
<p>ディスプレイ上での文字列の幅を計算する必要があるなら、文字数だけを数えて各文字のディスプレイ幅を計算しない<code>length</code>ではなく、<code>string-width</code>
(<a href="Size-of-Displayed-Text.html">表示されるテキストのサイズ</a>を参照)を使用すること。
</p>
<dl class="def">
<dt id="index-length_003c"><span class="category">Function: </span><span><strong>length&lt;</strong> <em>sequence length</em><a href='#index-length_003c' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><var>sequence</var>が<var>length</var>より短ければ非<code>nil</code>をリターンする。これは<var>sequence</var>が長いリストの場合に<var>sequence</var>の長さを計算するより効率的かもしれない。
</p></dd></dl>

<dl class="def">
<dt id="index-length_003e"><span class="category">Function: </span><span><strong>length&gt;</strong> <em>sequence length</em><a href='#index-length_003e' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><var>sequence</var>が<var>length</var>より長ければ非<code>nil</code>をリターンする。
</p></dd></dl>

<dl class="def">
<dt id="index-length_003d"><span class="category">Function: </span><span><strong>length=</strong> <em>sequence length</em><a href='#index-length_003d' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><var>sequence</var>の長さが<var>length</var>なら非<code>nil</code>をリターンする。
</p></dd></dl>

<dl class="def">
<dt id="index-elt"><span class="category">Function: </span><span><strong>elt</strong> <em>sequence index</em><a href='#index-elt' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="Definition-of-elt"></span><span id="index-elements-of-sequences"></span>
<p>この関数は<var>index</var>によりインデックスづけされた、<var>sequence</var>の要素をリターンする。<var>index</var>の値として妥当なのは、0から<var>sequence</var>の長さより1小さい数までの範囲の整数。<var>sequence</var>がリストなら範囲外の値は<code>nth</code>と同じように振る舞う。<a href="List-Elements.html#Definition-of-nth">Definition of nth</a>を参照のこと。それ以外なら範囲外の値は<code>args-out-of-range</code>エラーを引き起こす。
</p>
<div class="example">
<pre class="example">(elt [1 2 3 4] 2)
     &rArr; 3
</pre><pre class="example">(elt '(1 2 3 4) 2)
     &rArr; 3
</pre><pre class="example">;; <span class="roman"><code>elt</code>がどの文字をreturnするか明確にするために<code>string</code>を使用</span>
(string (elt &quot;1234&quot; 2))
     &rArr; &quot;3&quot;
</pre><pre class="example">(elt [1 2 3 4] 4)
     error&rarr; Args out of range: [1 2 3 4], 4
</pre><pre class="example">(elt [1 2 3 4] -1)
     error&rarr; Args out of range: [1 2 3 4], -1
</pre></div>

<p>この関数は<code>aref</code> (<a href="Array-Functions.html">配列を操作する関数</a>を参照)と<code>nth</code> (<a href="List-Elements.html#Definition-of-nth">Definition of nth</a>を参照)を一般化したものである。
</p></dd></dl>

<dl class="def">
<dt id="index-copy_002dsequence"><span class="category">Function: </span><span><strong>copy-sequence</strong> <em>seqr</em><a href='#index-copy_002dsequence' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-copying-sequences"></span>
<p>この関数は<var>seqr</var>
(シーケンスかレコードであること)のコピーをリターンする。コピーはオリジナルと同じオブジェクト型であり、同じ要素を同じ順序でもつ。しかし<var>seqr</var>が空なら長さが0の文字列やベクターと同じように関数がリターンする値はコピーではないかもしれないが、<var>seqr</var>と同じ型の空のオブジェクトである。
</p>
<p>コピーに新しい要素を格納するのは元の<var>seqr</var>に影響を与えずその逆も真である。しかし新しいシーケンス内の要素はコピーではなく、元のシーケンスの要素と同一(<code>eq</code>)になる。したがってコピーされたシーケンスを介して見つかった要素を変更するとオリジナルでも変更を見ることができる。
</p>
<p>引数がテキストプロパティをもつ文字列なら、コピー内のプロパティリスト自身もコピーとなり、元のシーケンスのプロパティリストと共有はされない。しかしプロパティリストの実際の値は共有される。<a href="Text-Properties.html">テキストのプロパティ</a>を参照のこと。
</p>
<p>この関数はドットリストでは機能しない。循環リストのコピーは無限ループを起こすだろう。
</p>
<p>シーケンスをコピーする別の方法については<a href="Building-Lists.html">コンスセルおよびリストの構築</a>の<code>append</code>、<a href="Creating-Strings.html">文字列の作成</a>の<code>concat</code>、<a href="Vector-Functions.html">ベクターのための関数</a>の<code>vconcat</code>も参照されたい。
</p>
<div class="example">
<pre class="example">(setq bar (list 1 2))
     &rArr; (1 2)
</pre><pre class="example">(setq x (vector 'foo bar))
     &rArr; [foo (1 2)]
</pre><pre class="example">(setq y (copy-sequence x))
     &rArr; [foo (1 2)]
</pre><pre class="example">

</pre><pre class="example">(eq x y)
     &rArr; nil
</pre><pre class="example">(equal x y)
     &rArr; t
</pre><pre class="example">(eq (elt x 1) (elt y 1))
     &rArr; t
</pre><pre class="example">

</pre><pre class="example">;; <span class="roman">一方のシーケンスの要素を置き換え</span>
(aset x 0 'quux)
x &rArr; [quux (1 2)]
y &rArr; [foo (1 2)]
</pre><pre class="example">

</pre><pre class="example">;; <span class="roman">共有された要素の内部を変更</span>
(setcar (aref x 1) 69)
x &rArr; [quux (69 2)]
y &rArr; [foo (69 2)]
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-reverse"><span class="category">Function: </span><span><strong>reverse</strong> <em>sequence</em><a href='#index-reverse' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-string-reverse"></span>
<span id="index-list-reverse"></span>
<span id="index-vector-reverse"></span>
<span id="index-sequence-reverse"></span>
<p>この関数は<var>sequence</var>の要素を反転した要素をもつ新たなシーケンスを作成する。元となる引数<var>sequence</var>は<em>変更されない</em>。文字テーブルは反転できないことに注意。
</p>
<div class="example">
<pre class="example">(setq x '(1 2 3 4))
     &rArr; (1 2 3 4)
</pre><pre class="example">(reverse x)
     &rArr; (4 3 2 1)
x
     &rArr; (1 2 3 4)
</pre><pre class="example">(setq x [1 2 3 4])
     &rArr; [1 2 3 4]
</pre><pre class="example">(reverse x)
     &rArr; [4 3 2 1]
x
     &rArr; [1 2 3 4]
</pre><pre class="example">(setq x &quot;xyzzy&quot;)
     &rArr; &quot;xyzzy&quot;
</pre><pre class="example">(reverse x)
     &rArr; &quot;yzzyx&quot;
x
     &rArr; &quot;xyzzy&quot;
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-nreverse"><span class="category">Function: </span><span><strong>nreverse</strong> <em>sequence</em><a href='#index-nreverse' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-reversing-a-string"></span>
<span id="index-reversing-a-list"></span>
<span id="index-reversing-a-vector"></span>
<p>この関数は<var>sequence</var>の要素を反転する。<code>reverse</code>とは異なり、元となる<var>sequence</var>は変更されるかもしれない。
</p>
<p>たとえば:
</p>
<div class="example">
<pre class="example">(setq x (list 'a 'b 'c))
     &rArr; (a b c)
</pre><pre class="example">x
     &rArr; (a b c)
(nreverse x)
     &rArr; (c b a)
</pre><pre class="example">;; <span class="roman">先頭にあったコンスセルが末尾となった</span>
x
     &rArr; (a)
</pre></div>

<p>混乱しないように、通常は元となるリストを保持する同じ変数に、<code>nreverse</code>の結果を書き戻す:
</p>
<div class="example">
<pre class="example">(setq x (nreverse x))
</pre></div>

<p>お馴染の例<code>(a b c)</code>の<code>nreverse</code>を以下に図示する:
</p>
<div class="example">
<pre class="example"><span class="roman">Original list head:</span>                       <span class="roman">Reversed list:</span>
 -------------        -------------        ------------
| car  | cdr  |      | car  | cdr  |      | car | cdr  |
|   a  |  nil |&lt;--   |   b  |   o  |&lt;--   |   c |   o  |
|      |      |   |  |      |   |  |   |  |     |   |  |
 -------------    |   --------- | -    |   -------- | -
                  |             |      |            |
                   -------------        ------------
</pre></div>

<p>setqが不要なのでベクターはより単純になる:
</p>
<div class="example">
<pre class="example">(setq x (copy-sequence [1 2 3 4]))
     &rArr; [1 2 3 4]
(nreverse x)
     &rArr; [4 3 2 1]
x
     &rArr; [4 3 2 1]
</pre></div>

<p><code>reverse</code>とは異なり、この関数は文字列では機能しない。<code>aset</code>を使用して文字列データを変更できても、たとえmutableであったとしても文字列は不変として扱うことを強く推奨する。<a href="Mutability.html">可変性</a>を参照のこと。
</p>
</dd></dl>

<dl class="def">
<dt id="index-sort"><span class="category">Function: </span><span><strong>sort</strong> <em>sequence &amp;rest keyword-args</em><a href='#index-sort' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-stable-sort"></span>
<span id="index-sorting-lists"></span>
<span id="index-sorting-vectors"></span>
<p>この関数は<var>sequence</var>
(リストかベクターでなければならない)をソートして、同じタイプのソートされたシーケンスをリターンする。安定ソートを行う(ソートキーが等しい要素の相対順が保たれることを意味する)。オプションで以下のキーワード引数を受け取る:
</p>
<dl compact="compact">
<dt><span><code>:key <var>keyfunc</var></code></span></dt>
<dd><p>比較に用いるキーの生成に、<var>sequence</var>の1つの要素を単一の引数としてそのキーの値をリターンする関数<var>sequence</var>を使用する。この引数がない、あるいは<var>keyfunc</var>が<code>nil</code>なら<code>identity</code>、すなわちその要素自体がソートのキーとして使用されるものとみなす。
</p>
</dd>
<dt><span><code>:lessp <var>predicate</var></code></span></dt>
<dd><p>キーの順序を決めるために<var>predicate</var>を使用する。<var>predicate</var>は2つのソートキーを引数として、1つ目が2つ目の前のキーの場合には非<code>nil</code>をリターンする関数。この引数がない、あるいは<var>predicate</var>が<code>nil</code>なら、異なる多くのLispタイプに適し一般的には昇順でソートを行う<code>value&lt;</code>が使用される(以下の<a href="#definition-of-value_003c">definition of value&lt;</a>を参照)。
</p>
<p>一貫性を保つために、すべての述語は以下のルールにしたがわなければならない:
</p><ul>
<li> <em>反対称的(antisymmetric)</em>でなければならない:
順序が<var>a</var>が<var>b</var>、かつ<var>b</var>が<var>a</var>の前であってはならない。
</li><li> <em>推移的(transitive)</em>でなければならない:
<var>a</var>が<var>b</var>の前にあり、かつ<var>b</var>が<var>c</var>の前にあるなら、<var>a</var>も<var>c</var>の前になければならない。
</li></ul>

</dd>
<dt><span><code>:reverse <var>flag</var></code></span></dt>
<dd><p><var>flag</var>が非<code>nil</code>なら、ソート順が逆になる。デフォルトは述語<code>:lessp</code>であり、これは降順のソートを意味する。
</p>
</dd>
<dt><span><code>:in-place <var>flag</var></code></span></dt>
<dd><p><var>flag</var>が非<code>nil</code>なら、<var>sequence</var>がインプレースで(破壊的に)ソートされてリターンされる。<code>nil</code>、あるいはこの引数が与えられなければ入力のコピーをソートしてリターンして、<var>sequence</var>自体は変更されない。インプレースのソートは若干高速だが、元のシーケンスは失われる。
</p></dd>
</dl>

<p>デフォルトの挙動がニーズに適さない場合には、通常は述語<code>:lessp</code>とは異なる新たな<code>:key</code>関数を指定するほうが容易だし早い。たとえば以下の文字列のソートで考えてみよう:
</p>
<div class="example">
<pre class="example">(setq numbers '(&quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; &quot;six&quot;))
(sort numbers)
     &rArr; (&quot;five&quot; &quot;four&quot; &quot;one&quot; &quot;six&quot; &quot;three&quot; &quot;two&quot;)
</pre></div>

<p>かわりに別のkey関数としてlengthを指定して文字列をソートできる:
</p>
<div class="example">
<pre class="example">(sort numbers :key #'length)
     &rArr; (&quot;one&quot; &quot;two&quot; &quot;six&quot; &quot;four&quot; &quot;five&quot; &quot;three&quot;)
</pre></div>

<p>安定ソートのおかげで同じ長さの文字列の元の順序が保たれていることに注意。今度は長さでソートして、同じ順位なら文字列の内容で順位を決める場合を考える。要素をこの方法でソートされた値に変換するようなkey関数を指定するのが、もっとも簡単な方法だろう。<code>value&lt;</code>は合成オブジェクト(コンス、リスト、ベクター、レコード)を辞書順に比較するので、以下のように記述できる:
</p>
<div class="example">
<pre class="example">(sort numbers :key (lambda (x) (cons (length x) x)))
     &rArr; (&quot;one&quot; &quot;six&quot; &quot;two&quot; &quot;five&quot; &quot;four&quot; &quot;three&quot;)
</pre></div>

<p><code>(3 . &quot;two&quot;)</code>より順序が前の<code>(3 . &quot;six&quot;)</code>は前、といったようにソートされるだろう。
</p>
<p>前のバージョンのEmacsとの互換性のために、固定された2つの引数形式を用いて<code>sort</code>関数を呼び出すこともできる:
</p>
<div class="example">
<pre class="example">(<code>sort</code> <var>sequence</var> <var>predicate</var>)
</pre></div>

<p>ここでは<var>predicate</var>が<code>:lessp</code>引数に相当する。この形式を使用する際には、ソートは常にインプレースで行われる。
</p></dd></dl>

<p>ソートを行う他の関数については<a href="Sorting.html">テキストのソート</a>を参照してください。<code>sort</code>の有用な例は、<a href="Accessing-Documentation.html">ドキュメント文字列へのアクセス</a>の<code>documentation</code>を参照してください。
</p>
<span id="index-comparing-values"></span>
<span id="index-standard-sorting-order"></span>
<span id="definition-of-value_003c"></span><dl class="def">
<dt id="index-value_003c"><span class="category">Function: </span><span><strong>value&lt;</strong> <em>a b</em><a href='#index-value_003c' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は標準のソート順において<var>a</var>が<var>b</var>の前なら非<code>nil</code>をリターンする。これは<var>b</var>が<var>a</var>の前、あるいは順位が等しいか順序付けされていなければ<code>nil</code>をリターンすることを意味する。
</p>
<p>引数<var>a</var>と<var>b</var>は同じタイプでなければならない。特に:
</p>
<ul>
<li> 数値は<code>&lt;</code>を用いて比較される(<a href="Comparison-of-Numbers.html#definition-of-_003c">definition of &lt;</a>を参照)。
</li><li> 文字列は<code>string&lt;</code> (<a href="Text-Comparison.html#definition-of-string_003c">definition of string&lt;</a>を参照)を用いて比較される。さらにシンボルは名前を文字列として比較される。
</li><li> コンス、リスト、ベクター、レコードは辞書順で比較される。これは2つのシーケンスの要素それぞれが相違するまで左から右へと比較されて、要素の相違した最初のペアーを<code>value&lt;</code>で比較した結果となることを意味する。相違を探す間に一方のシーケンスの要素がもう一方のシーケンスの前に使い果たされた場合には、短い方のシーケンスが長いシーケンスの前になる。
</li><li> マーカーは最初にバッファー、次に位置で比較される。
</li><li> バッファー、およびプロセスは名前を文字列として比較される。死んだバッファー(名前が<code>nil</code>)のバッファーは生きたすべてのバッファーの前として比較される。
</li><li> 上記以外のタイプは順序付けされていないとみなされ、リターン値は<code>nil</code>。
</li></ul>

<p>たとえば:
</p><div class="example">
<pre class="example">(value&lt; -4 3.5) &rArr; t
(value&lt; &quot;dog&quot; &quot;cat&quot;) &rArr; nil
(value&lt; 'yip 'yip) &rArr; nil
(value&lt; '(3 2) '(3 2 0)) &rArr; t
(value&lt; [3 2 &quot;a&quot;] [3 2 &quot;b&quot;]) &rArr; t
</pre></div>

<p><code>nil</code>がシンボル、あるいは空リストのいずれとして扱われるかは、比較する対象次第であることに注意。
</p>
<div class="example">
<pre class="example">(value&lt; nil '(0)) &rArr; t
(value&lt; 'nib nil) &rArr; t
</pre></div>

<p>比較可能なシーケンス(リスト、ベクター等)の長さに制限はないが、循環していたり深くネストされたデータ構造の比較に用いるとエラーで失敗するかもしれない。
</p></dd></dl>

<span id="index-sequence-functions-in-seq"></span>
<span id="index-seq-library"></span>
<span id="index-sequences_002c-generalized"></span>
<p><samp>seq.el</samp>ライブラリーは、以下のようなプレフィクス<code>seq-</code>がついたシーケンス操作用の追加のマクロと関数を提供します。
</p>
<p>このライブラリー内で定義されたすべての関数は、副作用をもちません。これらは引数として渡されたすべてのシーケンス(リスト、ベクター、文字列)を変更しません。特に明記しなければ、結果は入力と同じ型のシーケンスです。述語を受け取る関数では、それらは単一の関数である必要があります。
</p>
<p><samp>seq.el</samp>ライブラリーは、シーケンシャルなデータ構造の追加型で機能するように拡張可能です。そのためにすべての関数は<code>cl-defgeneric</code>を使用して定義されています。<code>cl-defgeneric</code>を使用した拡張の追加に関する詳細は、<a href="Generic-Functions.html">ジェネリック関数</a>を参照してください。
</p>
<dl class="def">
<dt id="index-seq_002delt"><span class="category">Function: </span><span><strong>seq-elt</strong> <em>sequence index</em><a href='#index-seq_002delt' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>index</var>(有効な範囲は0から<var>sequence</var>の長さより1少ない整数)で指定された<var>sequence</var>の要素をリターンする。ビルトインのシーケンス型にたいする範囲外(out-of-range)の値にたいして、<code>seq-elt</code>は<code>elt</code>と同様に振る舞う。詳細は<a href="#Definition-of-elt">Definition of elt</a>を参照のこと。
</p>
<div class="example">
<pre class="example">(seq-elt [1 2 3 4] 2)
&rArr; 3
</pre></div>

<p><code>seq-elt</code>は<code>setf</code>を使用してセット可能なplaceをリターンする(<a href="Setting-Generalized-Variables.html"><code>setf</code>マクロ</a>を参照)。
</p>
<div class="example">
<pre class="example">(setq vec [1 2 3 4])
(setf (seq-elt vec 2) 5)
vec
&rArr; [1 2 5 4]
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dlength"><span class="category">Function: </span><span><strong>seq-length</strong> <em>sequence</em><a href='#index-seq_002dlength' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>内の要素の個数をリターンする。ビルトインのシーケンス型にたいして<code>seq-length</code>は<code>length</code>と同様に振る舞う。<a href="#Definition-of-length">Definition of length</a>を参照のこと。
</p></dd></dl>

<dl class="def">
<dt id="index-seqp"><span class="category">Function: </span><span><strong>seqp</strong> <em>object</em><a href='#index-seqp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>object</var>がシーケンス(リストか配列)、または<samp>seq.el</samp>のジェネリック関数を通じて定義されたすべての追加シーケンス型なら非<code>nil</code>をリターンする。これは<code>sequencep</code>の拡張された変種である。
</p>
<div class="example">
<pre class="example">(seqp [1 2])
&rArr; t
</pre><pre class="example">(seqp 2)
&rArr; nil
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002ddrop"><span class="category">Function: </span><span><strong>seq-drop</strong> <em>sequence n</em><a href='#index-seq_002ddrop' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の最初の<var>n</var>個(整数)を除く、すべての要素をリターンする.<var>n</var>が0以下なら結果は<var>sequence</var>。
</p>
<div class="example">
<pre class="example">(seq-drop [1 2 3 4 5 6] 3)
&rArr; [4 5 6]
</pre><pre class="example">(seq-drop &quot;hello world&quot; -4)
&rArr; &quot;hello world&quot;
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dtake"><span class="category">Function: </span><span><strong>seq-take</strong> <em>sequence n</em><a href='#index-seq_002dtake' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の最初の<var>n</var>個(整数)の要素をリターンする。<var>n</var>が0以下なら結果は<code>nil</code>。
</p>
<div class="example">
<pre class="example">(seq-take '(1 2 3 4) 3)
&rArr; (1 2 3)
</pre><pre class="example">(seq-take [1 2 3 4] 0)
&rArr; []
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dtake_002dwhile"><span class="category">Function: </span><span><strong>seq-take-while</strong> <em>predicate sequence</em><a href='#index-seq_002dtake_002dwhile' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>のメンバーを順にリターンし、<var>predicate</var>が最初に<code>nil</code>をリターンした要素の前で停止する。
</p>
<div class="example">
<pre class="example">(seq-take-while (lambda (elt) (&gt; elt 0)) '(1 2 3 -1 -2))
&rArr; (1 2 3)
</pre><pre class="example">(seq-take-while (lambda (elt) (&gt; elt 0)) [-1 4 6])
&rArr; []
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002ddrop_002dwhile"><span class="category">Function: </span><span><strong>seq-drop-while</strong> <em>predicate sequence</em><a href='#index-seq_002ddrop_002dwhile' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>predicate</var>が最初に<code>nil</code>をリターンした要素から、<var>sequence</var>のメンバーを順にリターンする。
</p>
<div class="example">
<pre class="example">(seq-drop-while (lambda (elt) (&gt; elt 0)) '(1 2 3 -1 -2))
&rArr; (-1 -2)
</pre><pre class="example">(seq-drop-while (lambda (elt) (&lt; elt 0)) [1 4 6])
&rArr; [1 4 6]
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dsplit"><span class="category">Function: </span><span><strong>seq-split</strong> <em>sequence length</em><a href='#index-seq_002dsplit' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は(最大で)長さ<var>length</var>の<var>sequence</var>の部分シーケンスから構成されるリストをリターンする(<var>sequence</var>の長さが<var>length</var>の倍数でなければ最後の要素の長さは<var>length</var>より短くなるかもしれない)。
</p>
<div class="example">
<pre class="example">(seq-split [0 1 2 3 4] 2)
&rArr; ([0 1] [2 3] [4])
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002ddo"><span class="category">Function: </span><span><strong>seq-do</strong> <em>function sequence</em><a href='#index-seq_002ddo' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の各要素にたいして、(恐らくは副作用を得るために)順番に<var>function</var>を適用して、<var>sequence</var>をリターンする。
</p></dd></dl>

<dl class="def">
<dt id="index-seq_002dmap"><span class="category">Function: </span><span><strong>seq-map</strong> <em>function sequence</em><a href='#index-seq_002dmap' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の各要素に<var>function</var>を適用した結果をリターンする。リターン値はリスト。
</p>
<div class="example">
<pre class="example">(seq-map #'1+ '(2 4 6))
&rArr; (3 5 7)
</pre><pre class="example">(seq-map #'symbol-name [foo bar])
&rArr; (&quot;foo&quot; &quot;bar&quot;)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dmap_002dindexed"><span class="category">Function: </span><span><strong>seq-map-indexed</strong> <em>function sequence</em><a href='#index-seq_002dmap_002dindexed' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の各要素および<var>seq</var>であるようなインデックスに<var>function</var>を適用した結果をリターンする。リターン値はリスト。
</p>
<div class="example">
<pre class="example">(seq-map-indexed (lambda (elt idx)
                   (list idx elt))
                 '(a b c))
&rArr; ((0 a) (1 b) (2 c))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dmapn"><span class="category">Function: </span><span><strong>seq-mapn</strong> <em>function &amp;rest sequences</em><a href='#index-seq_002dmapn' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequences</var>の各要素に<var>function</var>を適用した結果をリターンする。 <var>function</var>のarity
(関数が受け取れる引数の個数。<a href="What-Is-a-Function.html">subr-arity</a>を参照)はシーケンスの個数にマッチしなければならない。マッピングは最短のシーケンス終端で停止する。リターン値はリスト。
</p>
<div class="example">
<pre class="example">(seq-mapn #'+ '(2 4 6) '(20 40 60))
&rArr; (22 44 66)
</pre><pre class="example">(seq-mapn #'concat '(&quot;moskito&quot; &quot;bite&quot;) [&quot;bee&quot; &quot;sting&quot;])
&rArr; (&quot;moskitobee&quot; &quot;bitesting&quot;)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dfilter"><span class="category">Function: </span><span><strong>seq-filter</strong> <em>predicate sequence</em><a href='#index-seq_002dfilter' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-filtering-sequences"></span>
<p>この関数は<var>predicate</var>が非<code>nil</code>をリターンした<var>sequence</var>内のすべての要素のリストをリターンする。
</p>
<div class="example">
<pre class="example">(seq-filter (lambda (elt) (&gt; elt 0)) [1 -1 3 -3 5])
&rArr; (1 3 5)
</pre><pre class="example">(seq-filter (lambda (elt) (&gt; elt 0)) '(-1 -3 -5))
&rArr; nil
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dremove"><span class="category">Function: </span><span><strong>seq-remove</strong> <em>predicate sequence</em><a href='#index-seq_002dremove' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-removing-from-sequences"></span>
<p>この関数は<var>predicate</var>が<code>nil</code>をリターンした<var>sequence</var>内のすべての要素のリストをリターンする。
</p>
<div class="example">
<pre class="example">(seq-remove (lambda (elt) (&gt; elt 0)) [1 -1 3 -3 5])
&rArr; (-1 -3)
</pre><pre class="example">(seq-remove (lambda (elt) (&lt; elt 0)) '(-1 -3 -5))
&rArr; nil
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dremove_002dat_002dposition"><span class="category">Function: </span><span><strong>seq-remove-at-position</strong> <em>sequence n</em><a href='#index-seq_002dremove_002dat_002dposition' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-removing-from-sequences-1"></span>
<p>この関数はインデックス<var>n</var>
(0基準)にある要素が削除された<var>sequence</var>のコピーをリターンする。結果のタイプは<var>sequence</var>と同じ。
</p>
<div class="example">
<pre class="example">(seq-remove-at-position [1 -1 3 -3 5] 0)
&rArr; [-1 3 -3 5]
</pre><pre class="example">(seq-remove-at-position [1 -1 3 -3 5] 3)
&rArr; [1 -1 3 5]
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dkeep"><span class="category">Function: </span><span><strong>seq-keep</strong> <em>function sequence</em><a href='#index-seq_002dkeep' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の要素それぞれにたいして<var>function</var>を呼び出して、結果が非<code>nil</code>だった要素すべてからなるリストをリターンする。
</p>
<div class="example">
<pre class="example">(seq-keep #'cl-digit-char-p '(?6 ?a ?7))
&rArr; (6 7)
</pre></div>

</dd></dl>

<dl class="def">
<dt id="index-seq_002dreduce"><span class="category">Function: </span><span><strong>seq-reduce</strong> <em>function sequence initial-value</em><a href='#index-seq_002dreduce' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-reducing-sequences"></span>
<p>この関数は<var>initial-value</var>と<var>sequence</var>の1つ目の要素で<var>function</var>を呼び出し、次にその結果と<var>sequence</var>の2つ目の要素で<var>function</var>を呼び出し、その次にその結果と<var>sequence</var>の3つ目の要素で、...と呼び出した結果をリターンする。<var>function</var>は引数が2つの関数であること。
</p>
<p><var>function</var>は2つの引数で呼び出される。1つ目の引数として<var>initial-value</var>
(その後は累積値)、2つ目の引数として<var>sequence</var>内の要素が使用される。
</p>
<p><var>sequence</var>が空なら、<var>function</var>を呼び出さずに<var>initial-value</var>をリターンする。
</p>
<div class="example">
<pre class="example">(seq-reduce #'+ [1 2 3 4] 0)
&rArr; 10
</pre><pre class="example">(seq-reduce #'+ '(1 2 3 4) 5)
&rArr; 15
</pre><pre class="example">(seq-reduce #'+ '() 3)
&rArr; 3
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dsome"><span class="category">Function: </span><span><strong>seq-some</strong> <em>predicate sequence</em><a href='#index-seq_002dsome' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の各要素に順に<var>predicate</var>を適用してリターンされた、最初の非<code>nil</code>値をリターンする。
</p>
<div class="example">
<pre class="example">(seq-some #'numberp [&quot;abc&quot; 1 nil])
&rArr; t
</pre><pre class="example">(seq-some #'numberp [&quot;abc&quot; &quot;def&quot;])
&rArr; nil
</pre><pre class="example">(seq-some #'null [&quot;abc&quot; 1 nil])
&rArr; t
</pre><pre class="example">(seq-some #'1+ [2 4 6])
&rArr; 3
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dfind"><span class="category">Function: </span><span><strong>seq-find</strong> <em>predicate sequence &amp;optional default</em><a href='#index-seq_002dfind' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>predicate</var>が非<code>nil</code>をリターンした、<var>sequence</var>内の最初の要素をリターンする。<var>predicate</var>にマッチする要素がなければ、この関数は<var>default</var>をリターンする。
</p>
<p>この関数は見つかった要素が<var>default</var>と等しい場合、要素が見つかったかどうかを知る術がないので曖昧さをもつことに注意。
</p>
<div class="example">
<pre class="example">(seq-find #'numberp [&quot;abc&quot; 1 nil])
&rArr; 1
</pre><pre class="example">(seq-find #'numberp [&quot;abc&quot; &quot;def&quot;])
&rArr; nil
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002devery_002dp"><span class="category">Function: </span><span><strong>seq-every-p</strong> <em>predicate sequence</em><a href='#index-seq_002devery_002dp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の各要素に<var>predicate</var>を適用して、すべてが非<code>nil</code>をリターンしたら非<code>nil</code>をリターンする。
</p>
<div class="example">
<pre class="example">(seq-every-p #'numberp [2 4 6])
&rArr; t
</pre><pre class="example">(seq-every-p #'numberp [2 4 &quot;6&quot;])
&rArr; nil
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dempty_002dp"><span class="category">Function: </span><span><strong>seq-empty-p</strong> <em>sequence</em><a href='#index-seq_002dempty_002dp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>が空なら<code>nil</code>をリターンする。
</p>
<div class="example">
<pre class="example">(seq-empty-p &quot;not empty&quot;)
&rArr; nil
</pre><pre class="example">(seq-empty-p &quot;&quot;)
&rArr; t
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dcount"><span class="category">Function: </span><span><strong>seq-count</strong> <em>predicate sequence</em><a href='#index-seq_002dcount' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>内で<var>predicate</var>が非<code>nil</code>をリターンした要素の個数をリターンする。
</p>
<div class="example">
<pre class="example">(seq-count (lambda (elt) (&gt; elt 0)) [-1 2 0 3 -2])
&rArr; 2
</pre></div>
</dd></dl>

<span id="index-sorting-sequences"></span>
<dl class="def">
<dt id="index-seq_002dsort"><span class="category">Function: </span><span><strong>seq-sort</strong> <em>function sequence</em><a href='#index-seq_002dsort' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>function</var>に応じてソートされた<var>sequence</var>のコピーをリターンする。<var>function</var>は2つの引数を受け取り、1つ目の引数が2つ目より前にソートされるべきなら非<code>nil</code>をリターンする。
</p></dd></dl>

<dl class="def">
<dt id="index-seq_002dsort_002dby"><span class="category">Function: </span><span><strong>seq-sort-by</strong> <em>function predicate sequence</em><a href='#index-seq_002dsort_002dby' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<code>seq-sort</code>と似ているがソート前に<var>sequence</var>の要素に<var>function</var>を適用して変換する点が異なる。<var>function</var>は単一の引数を受け取る関数。
</p>
<div class="example">
<pre class="example">(seq-sort-by #'seq-length #'&gt; [&quot;a&quot; &quot;ab&quot; &quot;abc&quot;])
&rArr; [&quot;abc&quot; &quot;ab&quot; &quot;a&quot;]
</pre></div>
</dd></dl>


<dl class="def">
<dt id="index-seq_002dcontains_002dp"><span class="category">Function: </span><span><strong>seq-contains-p</strong> <em>sequence elt &amp;optional function</em><a href='#index-seq_002dcontains_002dp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>内の少なくとも1つの要素が<var>elt</var>とequalなら非<code>nil</code>をリターンする。オプション引数<var>function</var>が非<code>nil</code>なら、それはデフォルトの<code>equal</code>のかわりに使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<pre class="example">(seq-contains-p '(symbol1 symbol2) 'symbol1)
&rArr; t
</pre><pre class="example">(seq-contains-p '(symbol1 symbol2) 'symbol3)
&rArr; nil
</pre></div>

</dd></dl>

<dl class="def">
<dt id="index-seq_002dset_002dequal_002dp"><span class="category">Function: </span><span><strong>seq-set-equal-p</strong> <em>sequence1 sequence2 &amp;optional testfn</em><a href='#index-seq_002dset_002dequal_002dp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は順序とは無関係に<var>sequence1</var>と<var>sequence2</var>が同じ要素を含むかどうかをチェックする。オプション引数<var>testfn</var>が非<code>nil</code>なら、デフォルトの<code>equal</code>のかわりに使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<pre class="example">(seq-set-equal-p '(a b c) '(c b a))
&rArr; t
</pre><pre class="example">(seq-set-equal-p '(a b c) '(c b))
&rArr; nil
</pre><pre class="example">(seq-set-equal-p '(&quot;a&quot; &quot;b&quot; &quot;c&quot;) '(&quot;c&quot; &quot;b&quot; &quot;a&quot;))
&rArr; t
</pre><pre class="example">(seq-set-equal-p '(&quot;a&quot; &quot;b&quot; &quot;c&quot;) '(&quot;c&quot; &quot;b&quot; &quot;a&quot;) #'eq)
&rArr; nil
</pre></div>

</dd></dl>

<dl class="def">
<dt id="index-seq_002dposition"><span class="category">Function: </span><span><strong>seq-position</strong> <em>sequence elt &amp;optional function</em><a href='#index-seq_002dposition' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>elt</var>と<code>equal</code>であるような<var>sequence</var>内の最初の要素のインデックス(0基準)をリターンする。オプション引数<var>function</var>が非<code>nil</code>なら、それはデフォルトの<code>equal</code>のかわりに使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<pre class="example">(seq-position '(a b c) 'b)
&rArr; 1
</pre><pre class="example">(seq-position '(a b c) 'd)
&rArr; nil
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dpositions"><span class="category">Function: </span><span><strong>seq-positions</strong> <em>sequence elt &amp;optional testfn</em><a href='#index-seq_002dpositions' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の要素それぞれにたいして、<var>elt</var>とともに引数として<var>testfn</var>を呼び出し、非<code>nil</code>をリターンするような要素のインデックス(0基準)のリストをリターンする。<var>testfn</var>のデフォルトは<code>equal</code>。
</p>
<div class="example">
<pre class="example">(seq-positions '(a b c a d) 'a)
&rArr; (0 3)
</pre><pre class="example">(seq-positions '(a b c a d) 'z)
&rArr; nil
</pre><pre class="example">(seq-positions '(11 5 7 12 9 15) 10 #'&gt;=)
&rArr; (0 3 5)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002duniq"><span class="category">Function: </span><span><strong>seq-uniq</strong> <em>sequence &amp;optional function</em><a href='#index-seq_002duniq' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は重複を削除した<var>sequence</var>の要素のリストをリターンする。オプション引数<var>function</var>が非<code>nil</code>なら、それはデフォルトの<code>equal</code>のかわりに使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<pre class="example">(seq-uniq '(1 2 2 1 3))
&rArr; (1 2 3)
</pre><pre class="example">(seq-uniq '(1 2 2.0 1.0) #'=)
&rArr; (1 2)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dsubseq"><span class="category">Function: </span><span><strong>seq-subseq</strong> <em>sequence start &amp;optional end</em><a href='#index-seq_002dsubseq' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-sub_002dsequence"></span>
<p>この関数は<var>sequence</var>の<var>start</var>から<var>end</var>(いずれも整数)までのサブセットをリターンする(<var>end</var>のデフォルトは最後の要素)。<var>start</var>か<var>end</var>が負なら<var>sequence</var>の最後から数える。
</p>
<div class="example">
<pre class="example">(seq-subseq '(1 2 3 4 5) 1)
&rArr; (2 3 4 5)
</pre><pre class="example">(seq-subseq '[1 2 3 4 5] 1 3)
&rArr; [2 3]
</pre><pre class="example">(seq-subseq '[1 2 3 4 5] -3 -1)
&rArr; [3 4]
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dconcatenate"><span class="category">Function: </span><span><strong>seq-concatenate</strong> <em>type &amp;rest sequences</em><a href='#index-seq_002dconcatenate' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequences</var>を結合して作成された<var>type</var>型のシーケンスをリターンする。<var>type</var>は<code>vector</code>、<code>list</code>、<code>string</code>のいずれか。
</p>
<div class="example">
<pre class="example">(seq-concatenate 'list '(1 2) '(3 4) [5 6])
&rArr; (1 2 3 4 5 6)
</pre><pre class="example">(seq-concatenate 'string &quot;Hello &quot; &quot;world&quot;)
&rArr; &quot;Hello world&quot;
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dmapcat"><span class="category">Function: </span><span><strong>seq-mapcat</strong> <em>function sequence &amp;optional type</em><a href='#index-seq_002dmapcat' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の各要素に<var>function</var>を適用した結果に、<code>seq-concatenate</code>を適用した結果をリターンする。結果は<var>type</var>型のシーケンス、または<var>type</var>が<code>nil</code>ならリストである。
</p>
<div class="example">
<pre class="example">(seq-mapcat #'seq-reverse '((3 2 1) (6 5 4)))
&rArr; (1 2 3 4 5 6)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dpartition"><span class="category">Function: </span><span><strong>seq-partition</strong> <em>sequence n</em><a href='#index-seq_002dpartition' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は長さ<var>n</var>のサブシーケンスへグループ化した<var>sequence</var>の要素のリストをリターンする。最後のシーケンスに含まれる要素は<var>n</var>より少ないかもしれない。<var>n</var>は整数であること。<var>n</var>が0以下の整数ならリターン値は<code>nil</code>。
</p>
<div class="example">
<pre class="example">(seq-partition '(0 1 2 3 4 5 6 7) 3)
&rArr; ((0 1 2) (3 4 5) (6 7))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dunion"><span class="category">Function: </span><span><strong>seq-union</strong> <em>sequence1 sequence2 &amp;optional function</em><a href='#index-seq_002dunion' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-sequences_002c-union-of"></span>
<span id="index-union-of-sequences"></span>
<p>この関数は<var>sequence1</var>と<var>sequence2</var>のいずれかに出現する要素のリストをリターンする。リターンされるリストの要素はすべて、2要素を比較してequalにならないという意味において一意である。オプション引数<var>function</var>が非<code>nil</code>なら、それはデフォルトの<code>equal</code>のかわりに比較に使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<pre class="example">(seq-union [1 2 3] [3 5])
&rArr; (1 2 3 5)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dintersection"><span class="category">Function: </span><span><strong>seq-intersection</strong> <em>sequence1 sequence2 &amp;optional function</em><a href='#index-seq_002dintersection' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-sequences_002c-intersection-of"></span>
<span id="index-intersection-of-sequences"></span>
<p>この関数は<var>sequence1</var>と<var>sequence2</var>の両方に出現する要素のリストをリターンする。オプション引数<var>function</var>が非<code>nil</code>なら、それはデフォルトの<code>equal</code>のかわりに比較に使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<pre class="example">(seq-intersection [2 3 4 5] [1 3 5 6 7])
&rArr; (3 5)
</pre></div>
</dd></dl>


<dl class="def">
<dt id="index-seq_002ddifference"><span class="category">Function: </span><span><strong>seq-difference</strong> <em>sequence1 sequence2 &amp;optional function</em><a href='#index-seq_002ddifference' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence1</var>に出現するが<var>sequence2</var>に出現しない要素のリストをリターンする。オプション引数<var>function</var>が非<code>nil</code>なら、それはデフォルトの<code>equal</code>のかわりに比較に使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<pre class="example">(seq-difference '(2 3 4 5) [1 3 5 6 7])
&rArr; (2 4)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dgroup_002dby"><span class="category">Function: </span><span><strong>seq-group-by</strong> <em>function sequence</em><a href='#index-seq_002dgroup_002dby' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の各要素に<var>function</var>を適用して、その結果をキーとして<var>sequence</var>をalistに分割する。キーの比較には<code>equal</code>を使用する。
</p>
<div class="example">
<pre class="example">(seq-group-by #'integerp '(1 2.1 3 2 3.2))
&rArr; ((t 1 3 2) (nil 2.1 3.2))
</pre><pre class="example">(seq-group-by #'car '((a 1) (b 2) (a 3) (c 4)))
&rArr; ((b (b 2)) (a (a 1) (a 3)) (c (c 4)))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dinto"><span class="category">Function: </span><span><strong>seq-into</strong> <em>sequence type</em><a href='#index-seq_002dinto' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-convert-sequence-to-another-type"></span>
<span id="index-list-to-vector"></span>
<span id="index-vector-to-list"></span>
<span id="index-string-to-vector"></span>
<p>この関数はシーケンス<var>sequence</var>を<var>type</var>型のシーケンスに変換する。<var>type</var>は<code>vector</code>、<code>string</code>、<code>list</code>のいずれかであること。
</p>
<div class="example">
<pre class="example">(seq-into [1 2 3] 'list)
&rArr; (1 2 3)
</pre><pre class="example">(seq-into nil 'vector)
&rArr; []
</pre><pre class="example">(seq-into &quot;hello&quot; 'vector)
&rArr; [104 101 108 108 111]
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dmin"><span class="category">Function: </span><span><strong>seq-min</strong> <em>sequence</em><a href='#index-seq_002dmin' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-minimum-value-of-sequence"></span>
<span id="index-sequence-minimum"></span>
<p>この関数は<var>sequence</var>の最小の要素をリターンする。<var>sequence</var>の要素は数字かマーカー(<a href="Markers.html">マーカー</a>を参照)でなければならない。
</p>
<div class="example">
<pre class="example">(seq-min [3 1 2])
&rArr; 1
</pre><pre class="example">(seq-min &quot;Hello&quot;)
&rArr; 72
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002dmax"><span class="category">Function: </span><span><strong>seq-max</strong> <em>sequence</em><a href='#index-seq_002dmax' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-maximum-value-of-sequence"></span>
<span id="index-sequence-maximum"></span>
<p>この関数は<var>sequence</var>の最大の要素をリターンする。<var>sequence</var>の要素は数字かマーカーでなければならない。
</p>
<div class="example">
<pre class="example">(seq-max [1 3 2])
&rArr; 3
</pre><pre class="example">(seq-max &quot;Hello&quot;)
&rArr; 111
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002ddoseq"><span class="category">Macro: </span><span><strong>seq-doseq</strong> <em>(var sequence) body&hellip;</em><a href='#index-seq_002ddoseq' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-sequence-iteration"></span>
<span id="index-iteration-over-vector-or-string"></span>
<p>このマクロは<code>dolist</code> (<a href="Iteration.html">dolist</a>を参照)と同様だが、<var>sequence</var>にリスト、ベクター、文字列のいずれかを指定できる点が異なる。これ主な利点は副作用である。
</p></dd></dl>

<span id="seq_002dlet"></span><dl class="def">
<dt id="index-seq_002dlet"><span class="category">Macro: </span><span><strong>seq-let</strong> <em>var-sequence val-sequence body&hellip;</em><a href='#index-seq_002dlet' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-sequence-destructuring"></span>
<p>このマクロは<var>var-sequence</var>内で定義される変数に<var>val-sequence</var>の対応する要素をバインドする。これは<em>分割代入(destructuring
binding)</em>として知られている。<var>var-sequence</var>の要素は、ネストされた非構造化を許容することにより自身にシーケンスを含むことができる。
</p>
<p><var>var-sequence</var>シーケンスには、<var>val-sequence</var>の残りにバインドされる変数名が後続するような<code>&amp;rest</code>マーカーを含めることもできる。
</p>
<div class="example">
<pre class="example">(seq-let [first second] [1 2 3 4]
  (list first second))
&rArr; (1 2)
</pre><pre class="example">(seq-let (_ a _ b) '(1 2 3 4)
  (list a b))
&rArr; (2 4)
</pre><pre class="example">(seq-let [a [b [c]]] [1 [2 [3]]]
  (list a b c))
&rArr; (1 2 3)
</pre><pre class="example">(seq-let [a b &amp;rest others] [1 2 3 4]
  others)
</pre><pre class="example">&rArr; [3 4]
</pre></div>

<p><code>pcase</code>パターンは分割代入にたいする代替えの機能を提供する。<a href="Destructuring-with-pcase-Patterns.html"><code>pcase</code>パターンによる分解</a>を参照のこと。
</p></dd></dl>

<dl class="def">
<dt id="index-seq_002dsetq"><span class="category">Macro: </span><span><strong>seq-setq</strong> <em>var-sequence val-sequence</em><a href='#index-seq_002dsetq' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-sequence-destructuring-1"></span>
<p>このマクロは<code>seq-let</code>と同様に機能するが、<code>let</code>ではなくあたかも<code>setq</code>で値が変数にバインドされる点が異なる。
</p>
<div class="example">
<pre class="example">(let ((a nil)
      (b nil))
  (seq-setq (_ a _ b) '(1 2 3 4))
  (list a b))
&rArr; (2 4)
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-seq_002drandom_002delt"><span class="category">Function: </span><span><strong>seq-random-elt</strong> <em>sequence</em><a href='#index-seq_002drandom_002delt' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>sequence</var>の要素をランダムにリターンする。
</p>
<div class="example">
<pre class="example">(seq-random-elt [1 2 3 4])
&rArr; 3
(seq-random-elt [1 2 3 4])
&rArr; 2
(seq-random-elt [1 2 3 4])
&rArr; 4
(seq-random-elt [1 2 3 4])
&rArr; 2
(seq-random-elt [1 2 3 4])
&rArr; 1
</pre></div>

<p><var>sequence</var>が空ならこの関数はエラーをシグナルする。
</p></dd></dl>

</div>
<hr>
<div class="header">
<p>
Next: <a href="Arrays.html">配列</a>, Up: <a href="Sequences-Arrays-Vectors.html">シーケンス、配列、ベクター</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>


This page has generated for branch:work/master_4078d0fd3ee9e55c3da219aa6e7788ac6130697b, commit:a5efff48b20fab86e768679e7b1dc92ec94f238d to check Japanese translation.
</body>
</html>
