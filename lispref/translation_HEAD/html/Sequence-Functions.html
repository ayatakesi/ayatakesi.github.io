<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 30.0.91.

Copyright © 1990-1996, 1998-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "GNU General Public License," with the Front-Cover Texts
being "A GNU Manual," and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<title>Sequence Functions (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Sequence Functions (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Sequence Functions (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="date" content="October 6, 2024">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Sequences-Arrays-Vectors.html" rel="up" title="Sequences Arrays Vectors">
<link href="Arrays.html" rel="next" title="Arrays">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Sequence-Functions">
<div class="nav-panel">
<p>
Next: <a href="Arrays.html" accesskey="n" rel="next">配列</a>, Up: <a href="Sequences-Arrays-Vectors.html" accesskey="u" rel="up">シーケンス、配列、ベクター</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="sikensu"><span>6.1 シーケンス<a class="copiable-link" href="#sikensu"> &para;</a></span></h3>

<p>このセクションでは任意の種類のシーケンスを許す関数を説明します。
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-sequencep"><span class="category-def">Function: </span><span><strong class="def-name">sequencep</strong> <var class="def-var-arguments">object</var><a class="copiable-link" href="#index-sequencep"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">object</var>がリスト、ベクター、文字列、ブールベクター、文字テーブルなら<code class="code">t</code>、それ以外は<code class="code">nil</code>をリターンする。以下の<code class="code">seqp</code>も参照のこと。
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-length"><span class="category-def">Function: </span><span><strong class="def-name">length</strong> <var class="def-var-arguments">sequence</var><a class="copiable-link" href="#index-length"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-string-length"></a>
<a class="index-entry-id" id="index-list-length"></a>
<a class="index-entry-id" id="index-vector-length"></a>
<a class="index-entry-id" id="index-sequence-length"></a>
<a class="index-entry-id" id="index-bool_002dvector-length"></a>
<a class="index-entry-id" id="index-char_002dtable-length"></a>
<a class="anchor" id="Definition-of-length"></a><p>この関数は<var class="var">sequence</var>内の要素の数をリターンする。<var class="var">sequence</var>がシーケンス以外、またはドットリストなら<code class="code">wrong-type-argument</code>エラーをシグナルする。引数が循環リストなら<code class="code">circular-list</code>エラーをシグナルする。文字テーブルではEmacsの最大文字コードより1大きい値が常にリターンされる。
</p>
<p>関連する関数<code class="code">safe-length</code>については<a class="ref" href="List-Elements.html#Definition-of-safe_002dlength">Definition of safe-length</a>を参照のこと。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(length '(1 2 3))
    &rArr; 3
</pre></div><div class="group"><pre class="example-preformatted">(length ())
    &rArr; 0
</pre></div><div class="group"><pre class="example-preformatted">(length &quot;foobar&quot;)
    &rArr; 6
</pre></div><div class="group"><pre class="example-preformatted">(length [1 2 3])
    &rArr; 3
</pre></div><div class="group"><pre class="example-preformatted">(length (make-bool-vector 5 nil))
    &rArr; 5
</pre></div></div>
</dd></dl>

<p><a class="ref" href="Text-Representations.html">テキストの表現方法</a>の<code class="code">string-bytes</code>も参照されたい。
</p>
<p>ディスプレイ上での文字列の幅を計算する必要があるなら、文字数だけを数えて各文字のディスプレイ幅を計算しない<code class="code">length</code>ではなく、<code class="code">string-width</code>
(<a class="ref" href="Size-of-Displayed-Text.html">表示されるテキストのサイズ</a>を参照)を使用すること。
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-length_003c"><span class="category-def">Function: </span><span><strong class="def-name">length&lt;</strong> <var class="def-var-arguments">sequence length</var><a class="copiable-link" href="#index-length_003c"> &para;</a></span></dt>
<dd><p><var class="var">sequence</var>が<var class="var">length</var>より短ければ非<code class="code">nil</code>をリターンする。これは<var class="var">sequence</var>が長いリストの場合に<var class="var">sequence</var>の長さを計算するより効率的かもしれない。
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-length_003e"><span class="category-def">Function: </span><span><strong class="def-name">length&gt;</strong> <var class="def-var-arguments">sequence length</var><a class="copiable-link" href="#index-length_003e"> &para;</a></span></dt>
<dd><p><var class="var">sequence</var>が<var class="var">length</var>より長ければ非<code class="code">nil</code>をリターンする。
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-length_003d"><span class="category-def">Function: </span><span><strong class="def-name">length=</strong> <var class="def-var-arguments">sequence length</var><a class="copiable-link" href="#index-length_003d"> &para;</a></span></dt>
<dd><p><var class="var">sequence</var>の長さが<var class="var">length</var>なら非<code class="code">nil</code>をリターンする。
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-elt"><span class="category-def">Function: </span><span><strong class="def-name">elt</strong> <var class="def-var-arguments">sequence index</var><a class="copiable-link" href="#index-elt"> &para;</a></span></dt>
<dd><a class="anchor" id="Definition-of-elt"></a><a class="index-entry-id" id="index-elements-of-sequences"></a>
<p>この関数は<var class="var">index</var>によりインデックスづけされた、<var class="var">sequence</var>の要素をリターンする。<var class="var">index</var>の値として妥当なのは、0から<var class="var">sequence</var>の長さより1小さい数までの範囲の整数。<var class="var">sequence</var>がリストなら範囲外の値は<code class="code">nth</code>と同じように振る舞う。<a class="ref" href="List-Elements.html#Definition-of-nth">Definition of nth</a>を参照のこと。それ以外なら範囲外の値は<code class="code">args-out-of-range</code>エラーを引き起こす。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(elt [1 2 3 4] 2)
     &rArr; 3
</pre></div><div class="group"><pre class="example-preformatted">(elt '(1 2 3 4) 2)
     &rArr; 3
</pre></div><div class="group"><pre class="example-preformatted">;; <span class="r"><code class="code">elt</code>がどの文字をreturnするか明確にするために<code class="code">string</code>を使用</span>
(string (elt &quot;1234&quot; 2))
     &rArr; &quot;3&quot;
</pre></div><div class="group"><pre class="example-preformatted">(elt [1 2 3 4] 4)
     error&rarr; Args out of range: [1 2 3 4], 4
</pre></div><div class="group"><pre class="example-preformatted">(elt [1 2 3 4] -1)
     error&rarr; Args out of range: [1 2 3 4], -1
</pre></div></div>

<p>この関数は<code class="code">aref</code> (<a class="ref" href="Array-Functions.html">配列を操作する関数</a>を参照)と<code class="code">nth</code> (<a class="ref" href="List-Elements.html#Definition-of-nth">Definition of nth</a>を参照)を一般化したものである。
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-copy_002dsequence"><span class="category-def">Function: </span><span><strong class="def-name">copy-sequence</strong> <var class="def-var-arguments">seqr</var><a class="copiable-link" href="#index-copy_002dsequence"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-copying-sequences"></a>
<p>この関数は<var class="var">seqr</var>
(シーケンスかレコードであること)のコピーをリターンする。コピーはオリジナルと同じオブジェクト型であり、同じ要素を同じ順序でもつ。しかし<var class="var">seqr</var>が空なら長さが0の文字列やベクターと同じように関数がリターンする値はコピーではないかもしれないが、<var class="var">seqr</var>と同じ型の空のオブジェクトである。
</p>
<p>コピーに新しい要素を格納するのは元の<var class="var">seqr</var>に影響を与えずその逆も真である。しかし新しいシーケンス内の要素はコピーではなく、元のシーケンスの要素と同一(<code class="code">eq</code>)になる。したがってコピーされたシーケンスを介して見つかった要素を変更するとオリジナルでも変更を見ることができる。
</p>
<p>引数がテキストプロパティをもつ文字列なら、コピー内のプロパティリスト自身もコピーとなり、元のシーケンスのプロパティリストと共有はされない。しかしプロパティリストの実際の値は共有される。<a class="ref" href="Text-Properties.html">テキストのプロパティ</a>を参照のこと。
</p>
<p>この関数はドットリストでは機能しない。循環リストのコピーは無限ループを起こすだろう。
</p>
<p>シーケンスをコピーする別の方法については<a class="ref" href="Building-Lists.html">コンスセルおよびリストの構築</a>の<code class="code">append</code>、<a class="ref" href="Creating-Strings.html">文字列の作成</a>の<code class="code">concat</code>、<a class="ref" href="Vector-Functions.html">ベクターのための関数</a>の<code class="code">vconcat</code>も参照されたい。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(setq bar (list 1 2))
     &rArr; (1 2)
</pre></div><div class="group"><pre class="example-preformatted">(setq x (vector 'foo bar))
     &rArr; [foo (1 2)]
</pre></div><div class="group"><pre class="example-preformatted">(setq y (copy-sequence x))
     &rArr; [foo (1 2)]
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(eq x y)
     &rArr; nil
</pre></div><div class="group"><pre class="example-preformatted">(equal x y)
     &rArr; t
</pre></div><div class="group"><pre class="example-preformatted">(eq (elt x 1) (elt y 1))
     &rArr; t
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">;; <span class="r">一方のシーケンスの要素を置き換え</span>
(aset x 0 'quux)
x &rArr; [quux (1 2)]
y &rArr; [foo (1 2)]
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">;; <span class="r">共有された要素の内部を変更</span>
(setcar (aref x 1) 69)
x &rArr; [quux (69 2)]
y &rArr; [foo (69 2)]
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-reverse"><span class="category-def">Function: </span><span><strong class="def-name">reverse</strong> <var class="def-var-arguments">sequence</var><a class="copiable-link" href="#index-reverse"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-string-reverse"></a>
<a class="index-entry-id" id="index-list-reverse"></a>
<a class="index-entry-id" id="index-vector-reverse"></a>
<a class="index-entry-id" id="index-sequence-reverse"></a>
<p>この関数は<var class="var">sequence</var>の要素を反転した要素をもつ新たなシーケンスを作成する。元となる引数<var class="var">sequence</var>は<em class="emph">変更されない</em>。文字テーブルは反転できないことに注意。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(setq x '(1 2 3 4))
     &rArr; (1 2 3 4)
</pre></div><div class="group"><pre class="example-preformatted">(reverse x)
     &rArr; (4 3 2 1)
x
     &rArr; (1 2 3 4)
</pre></div><div class="group"><pre class="example-preformatted">(setq x [1 2 3 4])
     &rArr; [1 2 3 4]
</pre></div><div class="group"><pre class="example-preformatted">(reverse x)
     &rArr; [4 3 2 1]
x
     &rArr; [1 2 3 4]
</pre></div><div class="group"><pre class="example-preformatted">(setq x &quot;xyzzy&quot;)
     &rArr; &quot;xyzzy&quot;
</pre></div><div class="group"><pre class="example-preformatted">(reverse x)
     &rArr; &quot;yzzyx&quot;
x
     &rArr; &quot;xyzzy&quot;
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-nreverse"><span class="category-def">Function: </span><span><strong class="def-name">nreverse</strong> <var class="def-var-arguments">sequence</var><a class="copiable-link" href="#index-nreverse"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-reversing-a-string"></a>
<a class="index-entry-id" id="index-reversing-a-list"></a>
<a class="index-entry-id" id="index-reversing-a-vector"></a>
<p>この関数は<var class="var">sequence</var>の要素を反転する。<code class="code">reverse</code>とは異なり、元となる<var class="var">sequence</var>は変更されるかもしれない。
</p>
<p>たとえば:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(setq x (list 'a 'b 'c))
     &rArr; (a b c)
</pre></div><div class="group"><pre class="example-preformatted">x
     &rArr; (a b c)
(nreverse x)
     &rArr; (c b a)
</pre></div><div class="group"><pre class="example-preformatted">;; <span class="r">先頭にあったコンスセルが末尾となった</span>
x
     &rArr; (a)
</pre></div></div>

<p>混乱しないように、通常は元となるリストを保持する同じ変数に、<code class="code">nreverse</code>の結果を書き戻す:
</p>
<div class="example">
<pre class="example-preformatted">(setq x (nreverse x))
</pre></div>

<p>お馴染の例<code class="code">(a b c)</code>の<code class="code">nreverse</code>を以下に図示する:
</p>
<div class="example smallexample">
<div class="group"><pre class="example-preformatted"><span class="r">Original list head:</span>                       <span class="r">Reversed list:</span>
 -------------        -------------        ------------
| car  | cdr  |      | car  | cdr  |      | car | cdr  |
|   a  |  nil |&lt;--   |   b  |   o  |&lt;--   |   c |   o  |
|      |      |   |  |      |   |  |   |  |     |   |  |
 -------------    |   --------- | -    |   -------- | -
                  |             |      |            |
                   -------------        ------------
</pre></div></div>

<p>setqが不要なのでベクターはより単純になる:
</p>
<div class="example">
<pre class="example-preformatted">(setq x (copy-sequence [1 2 3 4]))
     &rArr; [1 2 3 4]
(nreverse x)
     &rArr; [4 3 2 1]
x
     &rArr; [4 3 2 1]
</pre></div>

<p><code class="code">reverse</code>とは異なり、この関数は文字列では機能しない。<code class="code">aset</code>を使用して文字列データを変更できても、たとえmutableであったとしても文字列は不変として扱うことを強く推奨する。<a class="ref" href="Mutability.html">可変性</a>を参照のこと。
</p>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-sort"><span class="category-def">Function: </span><span><strong class="def-name">sort</strong> <var class="def-var-arguments">sequence &amp;rest keyword-args</var><a class="copiable-link" href="#index-sort"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-stable-sort"></a>
<a class="index-entry-id" id="index-sorting-lists"></a>
<a class="index-entry-id" id="index-sorting-vectors"></a>
<p>この関数は<var class="var">sequence</var>
(リストかベクターでなければならない)をソートして、同じタイプのソートされたシーケンスをリターンする。安定ソートを行う(ソートキーが等しい要素の相対順が保たれることを意味する)。オプションで以下のキーワード引数を受け取る:
</p>
<dl class="table">
<dt><code class="code">:key <var class="var">keyfunc</var></code></dt>
<dd><p>比較に用いるキーの生成に、<var class="var">sequence</var>の1つの要素を単一の引数としてそのキーの値をリターンする関数<var class="var">sequence</var>を使用する。この引数がない、あるいは<var class="var">keyfunc</var>が<code class="code">nil</code>なら<code class="code">identity</code>、すなわちその要素自体がソートのキーとして使用されるものとみなす。
</p>
</dd>
<dt><code class="code">:lessp <var class="var">predicate</var></code></dt>
<dd><p>キーの順序を決めるために<var class="var">predicate</var>を使用する。<var class="var">predicate</var>は2つのソートキーを引数として、1つ目が2つ目の前のキーの場合には非<code class="code">nil</code>をリターンする関数。この引数がない、あるいは<var class="var">predicate</var>が<code class="code">nil</code>なら、異なる多くのLispタイプに適し一般的には昇順でソートを行う<code class="code">value&lt;</code>が使用される(以下の<a class="ref" href="#definition-of-value_003c">definition of value&lt;</a>を参照)。
</p>
<p>一貫性を保つために、すべての述語は以下のルールにしたがわなければならない:
</p><ul class="itemize mark-bullet">
<li><em class="dfn">反対称的(antisymmetric)</em>でなければならない:
順序が<var class="var">a</var>が<var class="var">b</var>、かつ<var class="var">b</var>が<var class="var">a</var>の前であってはならない。
</li><li><em class="dfn">推移的(transitive)</em>でなければならない:
<var class="var">a</var>が<var class="var">b</var>の前にあり、かつ<var class="var">b</var>が<var class="var">c</var>の前にあるなら、<var class="var">a</var>も<var class="var">c</var>の前になければならない。
</li></ul>

</dd>
<dt><code class="code">:reverse <var class="var">flag</var></code></dt>
<dd><p><var class="var">flag</var>が非<code class="code">nil</code>なら、ソート順が逆になる。デフォルトは述語<code class="code">:lessp</code>であり、これは降順のソートを意味する。
</p>
</dd>
<dt><code class="code">:in-place <var class="var">flag</var></code></dt>
<dd><p><var class="var">flag</var>が非<code class="code">nil</code>なら、<var class="var">sequence</var>がインプレースで(破壊的に)ソートされてリターンされる。<code class="code">nil</code>、あるいはこの引数が与えられなければ入力のコピーをソートしてリターンして、<var class="var">sequence</var>自体は変更されない。インプレースのソートは若干高速だが、元のシーケンスは失われる。
</p></dd>
</dl>

<p>If the default behavior is not suitable for your needs, it is usually easier
and faster to supply a new <code class="code">:key</code> function than a different
<code class="code">:lessp</code> predicate.  For example, consider sorting these strings:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(setq numbers '(&quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; &quot;six&quot;))
(sort numbers)
     &rArr; (&quot;five&quot; &quot;four&quot; &quot;one&quot; &quot;six&quot; &quot;three&quot; &quot;two&quot;)
</pre></div></div>

<p>かわりに別のkey関数としてlengthを指定して文字列をソートできる:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(sort numbers :key #'length)
     &rArr; (&quot;one&quot; &quot;two&quot; &quot;six&quot; &quot;four&quot; &quot;five&quot; &quot;three&quot;)
</pre></div></div>

<p>安定ソートのおかげで同じ長さの文字列の元の順序が保たれていることに注意。今度は長さでソートして、同じ順位なら文字列の内容で順位を決める場合を考える。要素をこの方法でソートされた値に変換するようなkey関数を指定するのが、もっとも簡単な方法だろう。<code class="code">value&lt;</code>は合成オブジェクト(コンス、リスト、ベクター、レコード)を辞書順に比較するので、以下のように記述できる:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(sort numbers :key (lambda (x) (cons (length x) x)))
     &rArr; (&quot;one&quot; &quot;six&quot; &quot;two&quot; &quot;five&quot; &quot;four&quot; &quot;three&quot;)
</pre></div></div>

<p><code class="code">(3 . &quot;two&quot;)</code>より順序が前の<code class="code">(3 . &quot;six&quot;)</code>は前、といったようにソートされるだろう。
</p>
<p>前のバージョンのEmacsとの互換性のために、固定された2つの引数形式を用いて<code class="code">sort</code>関数を呼び出すこともできる:
</p>
<div class="example">
<pre class="example-preformatted">(<code class="code">sort</code> <var class="var">sequence</var> <var class="var">predicate</var>)
</pre></div>

<p>ここでは<var class="var">predicate</var>が<code class="code">:lessp</code>引数に相当する。この形式を使用する際には、ソートは常にインプレースで行われる。
</p></dd></dl>

<p>ソートを行う他の関数については<a class="ref" href="Sorting.html">テキストのソート</a>を参照してください。<code class="code">sort</code>の有用な例は、<a class="ref" href="Accessing-Documentation.html">ドキュメント文字列へのアクセス</a>の<code class="code">documentation</code>を参照してください。
</p>
<a class="index-entry-id" id="index-comparing-values"></a>
<a class="index-entry-id" id="index-standard-sorting-order"></a>
<a class="anchor" id="definition-of-value_003c"></a><dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-value_003c"><span class="category-def">Function: </span><span><strong class="def-name">value&lt;</strong> <var class="def-var-arguments">a b</var><a class="copiable-link" href="#index-value_003c"> &para;</a></span></dt>
<dd><p>この関数は標準のソート順において<var class="var">a</var>が<var class="var">b</var>の前なら非<code class="code">nil</code>をリターンする。これは<var class="var">b</var>が<var class="var">a</var>の前、あるいは順位が等しいか順序付けされていなければ<code class="code">nil</code>をリターンすることを意味する。
</p>
<p>引数<var class="var">a</var>と<var class="var">b</var>は同じタイプでなければならない。特に:
</p>
<ul class="itemize mark-bullet">
<li>数値は<code class="code">&lt;</code>を用いて比較される(<a class="ref" href="Comparison-of-Numbers.html#definition-of-_003c">definition of &lt;</a>を参照)。
</li><li>Strings are compared using <code class="code">string-lessp</code> (see <a class="pxref" href="Text-Comparison.html#definition-of-string_002dlessp">definition of string-lessp</a>) and symbols are compared by comparing their names as strings.
</li><li>コンス、リスト、ベクター、レコードは辞書順で比較される。これは2つのシーケンスの要素それぞれが相違するまで左から右へと比較されて、要素の相違した最初のペアーを<code class="code">value&lt;</code>で比較した結果となることを意味する。相違を探す間に一方のシーケンスの要素がもう一方のシーケンスの前に使い果たされた場合には、短い方のシーケンスが長いシーケンスの前になる。
</li><li>マーカーは最初にバッファー、次に位置で比較される。
</li><li>バッファー、およびプロセスは名前を文字列として比較される。死んだバッファー(名前が<code class="code">nil</code>)のバッファーは生きたすべてのバッファーの前として比較される。
</li><li>上記以外のタイプは順序付けされていないとみなされ、リターン値は<code class="code">nil</code>。
</li></ul>

<p>たとえば:
</p><div class="example">
<pre class="example-preformatted">(value&lt; -4 3.5) &rArr; t
(value&lt; &quot;dog&quot; &quot;cat&quot;) &rArr; nil
(value&lt; 'yip 'yip) &rArr; nil
(value&lt; '(3 2) '(3 2 0)) &rArr; t
(value&lt; [3 2 &quot;a&quot;] [3 2 &quot;b&quot;]) &rArr; t
</pre></div>

<p><code class="code">nil</code>がシンボル、あるいは空リストのいずれとして扱われるかは、比較する対象次第であることに注意。
</p>
<div class="example">
<pre class="example-preformatted">(value&lt; nil '(0)) &rArr; t
(value&lt; 'nib nil) &rArr; t
</pre></div>

<p>比較可能なシーケンス(リスト、ベクター等)の長さに制限はないが、循環していたり深くネストされたデータ構造の比較に用いるとエラーで失敗するかもしれない。
</p></dd></dl>

<a class="index-entry-id" id="index-sequence-functions-in-seq"></a>
<a class="index-entry-id" id="index-seq-library"></a>
<a class="index-entry-id" id="index-sequences_002c-generalized"></a>
<p><samp class="file">seq.el</samp>ライブラリーは、以下のようなプレフィクス<code class="code">seq-</code>がついたシーケンス操作用の追加のマクロと関数を提供します。
</p>
<p>このライブラリー内で定義されたすべての関数は、副作用をもちません。これらは引数として渡されたすべてのシーケンス(リスト、ベクター、文字列)を変更しません。特に明記しなければ、結果は入力と同じ型のシーケンスです。述語を受け取る関数では、それらは単一の関数である必要があります。
</p>
<p><samp class="file">seq.el</samp>ライブラリーは、シーケンシャルなデータ構造の追加型で機能するように拡張可能です。そのためにすべての関数は<code class="code">cl-defgeneric</code>を使用して定義されています。<code class="code">cl-defgeneric</code>を使用した拡張の追加に関する詳細は、<a class="ref" href="Generic-Functions.html">ジェネリック関数</a>を参照してください。
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002delt"><span class="category-def">Function: </span><span><strong class="def-name">seq-elt</strong> <var class="def-var-arguments">sequence index</var><a class="copiable-link" href="#index-seq_002delt"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">index</var>(有効な範囲は0から<var class="var">sequence</var>の長さより1少ない整数)で指定された<var class="var">sequence</var>の要素をリターンする。ビルトインのシーケンス型にたいする範囲外(out-of-range)の値にたいして、<code class="code">seq-elt</code>は<code class="code">elt</code>と同様に振る舞う。詳細は<a class="ref" href="#Definition-of-elt">Definition of elt</a>を参照のこと。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-elt [1 2 3 4] 2)
&rArr; 3
</pre></div></div>

<p><code class="code">seq-elt</code>は<code class="code">setf</code>を使用してセット可能なplaceをリターンする(<a class="ref" href="Setting-Generalized-Variables.html"><code class="code">setf</code>マクロ</a>を参照)。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(setq vec [1 2 3 4])
(setf (seq-elt vec 2) 5)
vec
&rArr; [1 2 5 4]
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dlength"><span class="category-def">Function: </span><span><strong class="def-name">seq-length</strong> <var class="def-var-arguments">sequence</var><a class="copiable-link" href="#index-seq_002dlength"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>内の要素の個数をリターンする。ビルトインのシーケンス型にたいして<code class="code">seq-length</code>は<code class="code">length</code>と同様に振る舞う。<a class="ref" href="#Definition-of-length">Definition of length</a>を参照のこと。
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seqp"><span class="category-def">Function: </span><span><strong class="def-name">seqp</strong> <var class="def-var-arguments">object</var><a class="copiable-link" href="#index-seqp"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">object</var>がシーケンス(リストか配列)、または<samp class="file">seq.el</samp>のジェネリック関数を通じて定義されたすべての追加シーケンス型なら非<code class="code">nil</code>をリターンする。これは<code class="code">sequencep</code>の拡張された変種である。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seqp [1 2])
&rArr; t
</pre></div><div class="group"><pre class="example-preformatted">(seqp 2)
&rArr; nil
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002ddrop"><span class="category-def">Function: </span><span><strong class="def-name">seq-drop</strong> <var class="def-var-arguments">sequence n</var><a class="copiable-link" href="#index-seq_002ddrop"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>の最初の<var class="var">n</var>個(整数)を除く、すべての要素をリターンする.<var class="var">n</var>が0以下なら結果は<var class="var">sequence</var>。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-drop [1 2 3 4 5 6] 3)
&rArr; [4 5 6]
</pre></div><div class="group"><pre class="example-preformatted">(seq-drop &quot;hello world&quot; -4)
&rArr; &quot;hello world&quot;
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dtake"><span class="category-def">Function: </span><span><strong class="def-name">seq-take</strong> <var class="def-var-arguments">sequence n</var><a class="copiable-link" href="#index-seq_002dtake"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>の最初の<var class="var">n</var>個(整数)の要素をリターンする。<var class="var">n</var>が0以下なら結果は<code class="code">nil</code>。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-take '(1 2 3 4) 3)
&rArr; (1 2 3)
</pre></div><div class="group"><pre class="example-preformatted">(seq-take [1 2 3 4] 0)
&rArr; []
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dtake_002dwhile"><span class="category-def">Function: </span><span><strong class="def-name">seq-take-while</strong> <var class="def-var-arguments">predicate sequence</var><a class="copiable-link" href="#index-seq_002dtake_002dwhile"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>のメンバーを順にリターンし、<var class="var">predicate</var>が最初に<code class="code">nil</code>をリターンした要素の前で停止する。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-take-while (lambda (elt) (&gt; elt 0)) '(1 2 3 -1 -2))
&rArr; (1 2 3)
</pre></div><div class="group"><pre class="example-preformatted">(seq-take-while (lambda (elt) (&gt; elt 0)) [-1 4 6])
&rArr; []
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002ddrop_002dwhile"><span class="category-def">Function: </span><span><strong class="def-name">seq-drop-while</strong> <var class="def-var-arguments">predicate sequence</var><a class="copiable-link" href="#index-seq_002ddrop_002dwhile"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">predicate</var>が最初に<code class="code">nil</code>をリターンした要素から、<var class="var">sequence</var>のメンバーを順にリターンする。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-drop-while (lambda (elt) (&gt; elt 0)) '(1 2 3 -1 -2))
&rArr; (-1 -2)
</pre></div><div class="group"><pre class="example-preformatted">(seq-drop-while (lambda (elt) (&lt; elt 0)) [1 4 6])
&rArr; [1 4 6]
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dsplit"><span class="category-def">Function: </span><span><strong class="def-name">seq-split</strong> <var class="def-var-arguments">sequence length</var><a class="copiable-link" href="#index-seq_002dsplit"> &para;</a></span></dt>
<dd><p>この関数は(最大で)長さ<var class="var">length</var>の<var class="var">sequence</var>の部分シーケンスから構成されるリストをリターンする(<var class="var">sequence</var>の長さが<var class="var">length</var>の倍数でなければ最後の要素の長さは<var class="var">length</var>より短くなるかもしれない)。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-split [0 1 2 3 4] 2)
&rArr; ([0 1] [2 3] [4])
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002ddo"><span class="category-def">Function: </span><span><strong class="def-name">seq-do</strong> <var class="def-var-arguments">function sequence</var><a class="copiable-link" href="#index-seq_002ddo"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>の各要素にたいして、(恐らくは副作用を得るために)順番に<var class="var">function</var>を適用して、<var class="var">sequence</var>をリターンする。
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dmap"><span class="category-def">Function: </span><span><strong class="def-name">seq-map</strong> <var class="def-var-arguments">function sequence</var><a class="copiable-link" href="#index-seq_002dmap"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>の各要素に<var class="var">function</var>を適用した結果をリターンする。リターン値はリスト。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-map #'1+ '(2 4 6))
&rArr; (3 5 7)
</pre></div><div class="group"><pre class="example-preformatted">(seq-map #'symbol-name [foo bar])
&rArr; (&quot;foo&quot; &quot;bar&quot;)
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dmap_002dindexed"><span class="category-def">Function: </span><span><strong class="def-name">seq-map-indexed</strong> <var class="def-var-arguments">function sequence</var><a class="copiable-link" href="#index-seq_002dmap_002dindexed"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>の各要素および<var class="var">seq</var>であるようなインデックスに<var class="var">function</var>を適用した結果をリターンする。リターン値はリスト。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-map-indexed (lambda (elt idx)
                   (list idx elt))
                 '(a b c))
&rArr; ((0 a) (1 b) (2 c))
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dmapn"><span class="category-def">Function: </span><span><strong class="def-name">seq-mapn</strong> <var class="def-var-arguments">function &amp;rest sequences</var><a class="copiable-link" href="#index-seq_002dmapn"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequences</var>の各要素に<var class="var">function</var>を適用した結果をリターンする。 <var class="var">function</var>のarity
(関数が受け取れる引数の個数。<a class="ref" href="What-Is-a-Function.html">subr-arity</a>を参照)はシーケンスの個数にマッチしなければならない。マッピングは最短のシーケンス終端で停止する。リターン値はリスト。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-mapn #'+ '(2 4 6) '(20 40 60))
&rArr; (22 44 66)
</pre></div><div class="group"><pre class="example-preformatted">(seq-mapn #'concat '(&quot;moskito&quot; &quot;bite&quot;) [&quot;bee&quot; &quot;sting&quot;])
&rArr; (&quot;moskitobee&quot; &quot;bitesting&quot;)
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dfilter"><span class="category-def">Function: </span><span><strong class="def-name">seq-filter</strong> <var class="def-var-arguments">predicate sequence</var><a class="copiable-link" href="#index-seq_002dfilter"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-filtering-sequences"></a>
<p>この関数は<var class="var">predicate</var>が非<code class="code">nil</code>をリターンした<var class="var">sequence</var>内のすべての要素のリストをリターンする。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-filter (lambda (elt) (&gt; elt 0)) [1 -1 3 -3 5])
&rArr; (1 3 5)
</pre></div><div class="group"><pre class="example-preformatted">(seq-filter (lambda (elt) (&gt; elt 0)) '(-1 -3 -5))
&rArr; nil
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dremove"><span class="category-def">Function: </span><span><strong class="def-name">seq-remove</strong> <var class="def-var-arguments">predicate sequence</var><a class="copiable-link" href="#index-seq_002dremove"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-removing-from-sequences"></a>
<p>この関数は<var class="var">predicate</var>が<code class="code">nil</code>をリターンした<var class="var">sequence</var>内のすべての要素のリストをリターンする。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-remove (lambda (elt) (&gt; elt 0)) [1 -1 3 -3 5])
&rArr; (-1 -3)
</pre></div><div class="group"><pre class="example-preformatted">(seq-remove (lambda (elt) (&lt; elt 0)) '(-1 -3 -5))
&rArr; nil
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dremove_002dat_002dposition"><span class="category-def">Function: </span><span><strong class="def-name">seq-remove-at-position</strong> <var class="def-var-arguments">sequence n</var><a class="copiable-link" href="#index-seq_002dremove_002dat_002dposition"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-removing-from-sequences-1"></a>
<p>この関数はインデックス<var class="var">n</var>
(0基準)にある要素が削除された<var class="var">sequence</var>のコピーをリターンする。結果のタイプは<var class="var">sequence</var>と同じ。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-remove-at-position [1 -1 3 -3 5] 0)
&rArr; [-1 3 -3 5]
</pre></div><div class="group"><pre class="example-preformatted">(seq-remove-at-position [1 -1 3 -3 5] 3)
&rArr; [1 -1 3 5]
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dkeep"><span class="category-def">Function: </span><span><strong class="def-name">seq-keep</strong> <var class="def-var-arguments">function sequence</var><a class="copiable-link" href="#index-seq_002dkeep"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>の要素それぞれにたいして<var class="var">function</var>を呼び出して、結果が非<code class="code">nil</code>だった要素すべてからなるリストをリターンする。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-keep #'cl-digit-char-p '(?6 ?a ?7))
&rArr; (6 7)
</pre></div></div>

</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dreduce"><span class="category-def">Function: </span><span><strong class="def-name">seq-reduce</strong> <var class="def-var-arguments">function sequence initial-value</var><a class="copiable-link" href="#index-seq_002dreduce"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-reducing-sequences"></a>
<p>この関数は<var class="var">initial-value</var>と<var class="var">sequence</var>の1つ目の要素で<var class="var">function</var>を呼び出し、次にその結果と<var class="var">sequence</var>の2つ目の要素で<var class="var">function</var>を呼び出し、その次にその結果と<var class="var">sequence</var>の3つ目の要素で、...と呼び出した結果をリターンする。<var class="var">function</var>は引数が2つの関数であること。
</p>
<p><var class="var">function</var>は2つの引数で呼び出される。1つ目の引数として<var class="var">initial-value</var>
(その後は累積値)、2つ目の引数として<var class="var">sequence</var>内の要素が使用される。
</p>
<p><var class="var">sequence</var>が空なら、<var class="var">function</var>を呼び出さずに<var class="var">initial-value</var>をリターンする。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-reduce #'+ [1 2 3 4] 0)
&rArr; 10
</pre></div><div class="group"><pre class="example-preformatted">(seq-reduce #'+ '(1 2 3 4) 5)
&rArr; 15
</pre></div><div class="group"><pre class="example-preformatted">(seq-reduce #'+ '() 3)
&rArr; 3
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dsome"><span class="category-def">Function: </span><span><strong class="def-name">seq-some</strong> <var class="def-var-arguments">predicate sequence</var><a class="copiable-link" href="#index-seq_002dsome"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>の各要素に順に<var class="var">predicate</var>を適用してリターンされた、最初の非<code class="code">nil</code>値をリターンする。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-some #'numberp [&quot;abc&quot; 1 nil])
&rArr; t
</pre></div><div class="group"><pre class="example-preformatted">(seq-some #'numberp [&quot;abc&quot; &quot;def&quot;])
&rArr; nil
</pre></div><div class="group"><pre class="example-preformatted">(seq-some #'null [&quot;abc&quot; 1 nil])
&rArr; t
</pre></div><div class="group"><pre class="example-preformatted">(seq-some #'1+ [2 4 6])
&rArr; 3
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dfind"><span class="category-def">Function: </span><span><strong class="def-name">seq-find</strong> <var class="def-var-arguments">predicate sequence &amp;optional default</var><a class="copiable-link" href="#index-seq_002dfind"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">predicate</var>が非<code class="code">nil</code>をリターンした、<var class="var">sequence</var>内の最初の要素をリターンする。<var class="var">predicate</var>にマッチする要素がなければ、この関数は<var class="var">default</var>をリターンする。
</p>
<p>この関数は見つかった要素が<var class="var">default</var>と等しい場合、要素が見つかったかどうかを知る術がないので曖昧さをもつことに注意。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-find #'numberp [&quot;abc&quot; 1 nil])
&rArr; 1
</pre></div><div class="group"><pre class="example-preformatted">(seq-find #'numberp [&quot;abc&quot; &quot;def&quot;])
&rArr; nil
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002devery_002dp"><span class="category-def">Function: </span><span><strong class="def-name">seq-every-p</strong> <var class="def-var-arguments">predicate sequence</var><a class="copiable-link" href="#index-seq_002devery_002dp"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>の各要素に<var class="var">predicate</var>を適用して、すべてが非<code class="code">nil</code>をリターンしたら非<code class="code">nil</code>をリターンする。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-every-p #'numberp [2 4 6])
&rArr; t
</pre></div><div class="group"><pre class="example-preformatted">(seq-every-p #'numberp [2 4 &quot;6&quot;])
&rArr; nil
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dempty_002dp"><span class="category-def">Function: </span><span><strong class="def-name">seq-empty-p</strong> <var class="def-var-arguments">sequence</var><a class="copiable-link" href="#index-seq_002dempty_002dp"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>が空なら<code class="code">nil</code>をリターンする。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-empty-p &quot;not empty&quot;)
&rArr; nil
</pre></div><div class="group"><pre class="example-preformatted">(seq-empty-p &quot;&quot;)
&rArr; t
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dcount"><span class="category-def">Function: </span><span><strong class="def-name">seq-count</strong> <var class="def-var-arguments">predicate sequence</var><a class="copiable-link" href="#index-seq_002dcount"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>内で<var class="var">predicate</var>が非<code class="code">nil</code>をリターンした要素の個数をリターンする。
</p>
<div class="example">
<pre class="example-preformatted">(seq-count (lambda (elt) (&gt; elt 0)) [-1 2 0 3 -2])
&rArr; 2
</pre></div>
</dd></dl>

<a class="index-entry-id" id="index-sorting-sequences"></a>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dsort"><span class="category-def">Function: </span><span><strong class="def-name">seq-sort</strong> <var class="def-var-arguments">function sequence</var><a class="copiable-link" href="#index-seq_002dsort"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">function</var>に応じてソートされた<var class="var">sequence</var>のコピーをリターンする。<var class="var">function</var>は2つの引数を受け取り、1つ目の引数が2つ目より前にソートされるべきなら非<code class="code">nil</code>をリターンする。
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dsort_002dby"><span class="category-def">Function: </span><span><strong class="def-name">seq-sort-by</strong> <var class="def-var-arguments">function predicate sequence</var><a class="copiable-link" href="#index-seq_002dsort_002dby"> &para;</a></span></dt>
<dd><p>この関数は<code class="code">seq-sort</code>と似ているがソート前に<var class="var">sequence</var>の要素に<var class="var">function</var>を適用して変換する点が異なる。<var class="var">function</var>は単一の引数を受け取る関数。
</p>
<div class="example">
<pre class="example-preformatted">(seq-sort-by #'seq-length #'&gt; [&quot;a&quot; &quot;ab&quot; &quot;abc&quot;])
&rArr; [&quot;abc&quot; &quot;ab&quot; &quot;a&quot;]
</pre></div>
</dd></dl>


<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dcontains_002dp"><span class="category-def">Function: </span><span><strong class="def-name">seq-contains-p</strong> <var class="def-var-arguments">sequence elt &amp;optional function</var><a class="copiable-link" href="#index-seq_002dcontains_002dp"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>内の少なくとも1つの要素が<var class="var">elt</var>とequalなら非<code class="code">nil</code>をリターンする。オプション引数<var class="var">function</var>が非<code class="code">nil</code>なら、それはデフォルトの<code class="code">equal</code>のかわりに使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-contains-p '(symbol1 symbol2) 'symbol1)
&rArr; t
</pre></div><div class="group"><pre class="example-preformatted">(seq-contains-p '(symbol1 symbol2) 'symbol3)
&rArr; nil
</pre></div></div>

</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dset_002dequal_002dp"><span class="category-def">Function: </span><span><strong class="def-name">seq-set-equal-p</strong> <var class="def-var-arguments">sequence1 sequence2 &amp;optional testfn</var><a class="copiable-link" href="#index-seq_002dset_002dequal_002dp"> &para;</a></span></dt>
<dd><p>This function checks whether <var class="var">sequence1</var> and <var class="var">sequence2</var> contain the
same elements, regardless of the order.  If the optional argument
<var class="var">testfn</var> is non-<code class="code">nil</code>, it is a function of two arguments to use
instead of the default <code class="code">equal</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-set-equal-p '(a b c) '(c b a))
&rArr; t
</pre></div><div class="group"><pre class="example-preformatted">(seq-set-equal-p '(a b c) '(c b))
&rArr; nil
</pre></div><div class="group"><pre class="example-preformatted">(seq-set-equal-p '(&quot;a&quot; &quot;b&quot; &quot;c&quot;) '(&quot;c&quot; &quot;b&quot; &quot;a&quot;))
&rArr; t
</pre></div><div class="group"><pre class="example-preformatted">(seq-set-equal-p '(&quot;a&quot; &quot;b&quot; &quot;c&quot;) '(&quot;c&quot; &quot;b&quot; &quot;a&quot;) #'eq)
&rArr; nil
</pre></div></div>

</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dposition"><span class="category-def">Function: </span><span><strong class="def-name">seq-position</strong> <var class="def-var-arguments">sequence elt &amp;optional function</var><a class="copiable-link" href="#index-seq_002dposition"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">elt</var>と<code class="code">equal</code>であるような<var class="var">sequence</var>内の最初の要素のインデックス(0基準)をリターンする。オプション引数<var class="var">function</var>が非<code class="code">nil</code>なら、それはデフォルトの<code class="code">equal</code>のかわりに使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-position '(a b c) 'b)
&rArr; 1
</pre></div><div class="group"><pre class="example-preformatted">(seq-position '(a b c) 'd)
&rArr; nil
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dpositions"><span class="category-def">Function: </span><span><strong class="def-name">seq-positions</strong> <var class="def-var-arguments">sequence elt &amp;optional testfn</var><a class="copiable-link" href="#index-seq_002dpositions"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>の要素それぞれにたいして、<var class="var">elt</var>とともに引数として<var class="var">testfn</var>を呼び出し、非<code class="code">nil</code>をリターンするような要素のインデックス(0基準)のリストをリターンする。<var class="var">testfn</var>のデフォルトは<code class="code">equal</code>。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-positions '(a b c a d) 'a)
&rArr; (0 3)
</pre></div><div class="group"><pre class="example-preformatted">(seq-positions '(a b c a d) 'z)
&rArr; nil
</pre></div><div class="group"><pre class="example-preformatted">(seq-positions '(11 5 7 12 9 15) 10 #'&gt;=)
&rArr; (0 3 5)
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002duniq"><span class="category-def">Function: </span><span><strong class="def-name">seq-uniq</strong> <var class="def-var-arguments">sequence &amp;optional function</var><a class="copiable-link" href="#index-seq_002duniq"> &para;</a></span></dt>
<dd><p>この関数は重複を削除した<var class="var">sequence</var>の要素のリストをリターンする。オプション引数<var class="var">function</var>が非<code class="code">nil</code>なら、それはデフォルトの<code class="code">equal</code>のかわりに使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-uniq '(1 2 2 1 3))
&rArr; (1 2 3)
</pre></div><div class="group"><pre class="example-preformatted">(seq-uniq '(1 2 2.0 1.0) #'=)
&rArr; (1 2)
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dsubseq"><span class="category-def">Function: </span><span><strong class="def-name">seq-subseq</strong> <var class="def-var-arguments">sequence start &amp;optional end</var><a class="copiable-link" href="#index-seq_002dsubseq"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-sub_002dsequence"></a>
<p>この関数は<var class="var">sequence</var>の<var class="var">start</var>から<var class="var">end</var>(いずれも整数)までのサブセットをリターンする(<var class="var">end</var>のデフォルトは最後の要素)。<var class="var">start</var>か<var class="var">end</var>が負なら<var class="var">sequence</var>の最後から数える。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-subseq '(1 2 3 4 5) 1)
&rArr; (2 3 4 5)
</pre></div><div class="group"><pre class="example-preformatted">(seq-subseq '[1 2 3 4 5] 1 3)
&rArr; [2 3]
</pre></div><div class="group"><pre class="example-preformatted">(seq-subseq '[1 2 3 4 5] -3 -1)
&rArr; [3 4]
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dconcatenate"><span class="category-def">Function: </span><span><strong class="def-name">seq-concatenate</strong> <var class="def-var-arguments">type &amp;rest sequences</var><a class="copiable-link" href="#index-seq_002dconcatenate"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequences</var>を結合して作成された<var class="var">type</var>型のシーケンスをリターンする。<var class="var">type</var>は<code class="code">vector</code>、<code class="code">list</code>、<code class="code">string</code>のいずれか。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-concatenate 'list '(1 2) '(3 4) [5 6])
&rArr; (1 2 3 4 5 6)
</pre></div><div class="group"><pre class="example-preformatted">(seq-concatenate 'string &quot;Hello &quot; &quot;world&quot;)
&rArr; &quot;Hello world&quot;
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dmapcat"><span class="category-def">Function: </span><span><strong class="def-name">seq-mapcat</strong> <var class="def-var-arguments">function sequence &amp;optional type</var><a class="copiable-link" href="#index-seq_002dmapcat"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>の各要素に<var class="var">function</var>を適用した結果に、<code class="code">seq-concatenate</code>を適用した結果をリターンする。結果は<var class="var">type</var>型のシーケンス、または<var class="var">type</var>が<code class="code">nil</code>ならリストである。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-mapcat #'seq-reverse '((3 2 1) (6 5 4)))
&rArr; (1 2 3 4 5 6)
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dpartition"><span class="category-def">Function: </span><span><strong class="def-name">seq-partition</strong> <var class="def-var-arguments">sequence n</var><a class="copiable-link" href="#index-seq_002dpartition"> &para;</a></span></dt>
<dd><p>この関数は長さ<var class="var">n</var>のサブシーケンスへグループ化した<var class="var">sequence</var>の要素のリストをリターンする。最後のシーケンスに含まれる要素は<var class="var">n</var>より少ないかもしれない。<var class="var">n</var>は整数であること。<var class="var">n</var>が0以下の整数ならリターン値は<code class="code">nil</code>。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-partition '(0 1 2 3 4 5 6 7) 3)
&rArr; ((0 1 2) (3 4 5) (6 7))
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dunion"><span class="category-def">Function: </span><span><strong class="def-name">seq-union</strong> <var class="def-var-arguments">sequence1 sequence2 &amp;optional function</var><a class="copiable-link" href="#index-seq_002dunion"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-sequences_002c-union-of"></a>
<a class="index-entry-id" id="index-union-of-sequences"></a>
<p>この関数は<var class="var">sequence1</var>と<var class="var">sequence2</var>のいずれかに出現する要素のリストをリターンする。リターンされるリストの要素はすべて、2要素を比較してequalにならないという意味において一意である。オプション引数<var class="var">function</var>が非<code class="code">nil</code>なら、それはデフォルトの<code class="code">equal</code>のかわりに比較に使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-union [1 2 3] [3 5])
&rArr; (1 2 3 5)
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dintersection"><span class="category-def">Function: </span><span><strong class="def-name">seq-intersection</strong> <var class="def-var-arguments">sequence1 sequence2 &amp;optional function</var><a class="copiable-link" href="#index-seq_002dintersection"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-sequences_002c-intersection-of"></a>
<a class="index-entry-id" id="index-intersection-of-sequences"></a>
<p>この関数は<var class="var">sequence1</var>と<var class="var">sequence2</var>の両方に出現する要素のリストをリターンする。オプション引数<var class="var">function</var>が非<code class="code">nil</code>なら、それはデフォルトの<code class="code">equal</code>のかわりに比較に使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-intersection [2 3 4 5] [1 3 5 6 7])
&rArr; (3 5)
</pre></div></div>
</dd></dl>


<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002ddifference"><span class="category-def">Function: </span><span><strong class="def-name">seq-difference</strong> <var class="def-var-arguments">sequence1 sequence2 &amp;optional function</var><a class="copiable-link" href="#index-seq_002ddifference"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence1</var>に出現するが<var class="var">sequence2</var>に出現しない要素のリストをリターンする。オプション引数<var class="var">function</var>が非<code class="code">nil</code>なら、それはデフォルトの<code class="code">equal</code>のかわりに比較に使用する2つの引数を受け取る関数であること。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-difference '(2 3 4 5) [1 3 5 6 7])
&rArr; (2 4)
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dgroup_002dby"><span class="category-def">Function: </span><span><strong class="def-name">seq-group-by</strong> <var class="def-var-arguments">function sequence</var><a class="copiable-link" href="#index-seq_002dgroup_002dby"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>の各要素に<var class="var">function</var>を適用して、その結果をキーとして<var class="var">sequence</var>をalistに分割する。キーの比較には<code class="code">equal</code>を使用する。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-group-by #'integerp '(1 2.1 3 2 3.2))
&rArr; ((t 1 3 2) (nil 2.1 3.2))
</pre></div><div class="group"><pre class="example-preformatted">(seq-group-by #'car '((a 1) (b 2) (a 3) (c 4)))
&rArr; ((b (b 2)) (a (a 1) (a 3)) (c (c 4)))
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dinto"><span class="category-def">Function: </span><span><strong class="def-name">seq-into</strong> <var class="def-var-arguments">sequence type</var><a class="copiable-link" href="#index-seq_002dinto"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-convert-sequence-to-another-type"></a>
<a class="index-entry-id" id="index-list-to-vector"></a>
<a class="index-entry-id" id="index-vector-to-list"></a>
<a class="index-entry-id" id="index-string-to-vector"></a>
<p>この関数はシーケンス<var class="var">sequence</var>を<var class="var">type</var>型のシーケンスに変換する。<var class="var">type</var>は<code class="code">vector</code>、<code class="code">string</code>、<code class="code">list</code>のいずれかであること。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-into [1 2 3] 'list)
&rArr; (1 2 3)
</pre></div><div class="group"><pre class="example-preformatted">(seq-into nil 'vector)
&rArr; []
</pre></div><div class="group"><pre class="example-preformatted">(seq-into &quot;hello&quot; 'vector)
&rArr; [104 101 108 108 111]
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dmin"><span class="category-def">Function: </span><span><strong class="def-name">seq-min</strong> <var class="def-var-arguments">sequence</var><a class="copiable-link" href="#index-seq_002dmin"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-minimum-value-of-sequence"></a>
<a class="index-entry-id" id="index-sequence-minimum"></a>
<p>この関数は<var class="var">sequence</var>の最小の要素をリターンする。<var class="var">sequence</var>の要素は数字かマーカー(<a class="ref" href="Markers.html">マーカー</a>を参照)でなければならない。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-min [3 1 2])
&rArr; 1
</pre></div><div class="group"><pre class="example-preformatted">(seq-min &quot;Hello&quot;)
&rArr; 72
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002dmax"><span class="category-def">Function: </span><span><strong class="def-name">seq-max</strong> <var class="def-var-arguments">sequence</var><a class="copiable-link" href="#index-seq_002dmax"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-maximum-value-of-sequence"></a>
<a class="index-entry-id" id="index-sequence-maximum"></a>
<p>この関数は<var class="var">sequence</var>の最大の要素をリターンする。<var class="var">sequence</var>の要素は数字かマーカーでなければならない。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-max [1 3 2])
&rArr; 3
</pre></div><div class="group"><pre class="example-preformatted">(seq-max &quot;Hello&quot;)
&rArr; 111
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-seq_002ddoseq"><span class="category-def">Macro: </span><span><strong class="def-name">seq-doseq</strong> <var class="def-var-arguments">(var sequence) body&hellip;</var><a class="copiable-link" href="#index-seq_002ddoseq"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-sequence-iteration"></a>
<a class="index-entry-id" id="index-iteration-over-vector-or-string"></a>
<p>このマクロは<code class="code">dolist</code> (<a class="ref" href="Iteration.html">dolist</a>を参照)と同様だが、<var class="var">sequence</var>にリスト、ベクター、文字列のいずれかを指定できる点が異なる。これ主な利点は副作用である。
</p></dd></dl>

<a class="anchor" id="seq_002dlet"></a><dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-seq_002dlet"><span class="category-def">Macro: </span><span><strong class="def-name">seq-let</strong> <var class="def-var-arguments">var-sequence val-sequence body&hellip;</var><a class="copiable-link" href="#index-seq_002dlet"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-sequence-destructuring"></a>
<p>このマクロは<var class="var">var-sequence</var>内で定義される変数に<var class="var">val-sequence</var>の対応する要素をバインドする。これは<em class="dfn">分割代入(destructuring
binding)</em>として知られている。<var class="var">var-sequence</var>の要素は、ネストされた非構造化を許容することにより自身にシーケンスを含むことができる。
</p>
<p><var class="var">var-sequence</var>シーケンスには、<var class="var">val-sequence</var>の残りにバインドされる変数名が後続するような<code class="code">&amp;rest</code>マーカーを含めることもできる。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-let [first second] [1 2 3 4]
  (list first second))
&rArr; (1 2)
</pre></div><div class="group"><pre class="example-preformatted">(seq-let (_ a _ b) '(1 2 3 4)
  (list a b))
&rArr; (2 4)
</pre></div><div class="group"><pre class="example-preformatted">(seq-let [a [b [c]]] [1 [2 [3]]]
  (list a b c))
&rArr; (1 2 3)
</pre></div><div class="group"><pre class="example-preformatted">(seq-let [a b &amp;rest others] [1 2 3 4]
  others)
</pre></div><pre class="example-preformatted">&rArr; [3 4]
</pre></div>

<p><code class="code">pcase</code>パターンは分割代入にたいする代替えの機能を提供する。<a class="ref" href="Destructuring-with-pcase-Patterns.html"><code class="code">pcase</code>パターンによる分解</a>を参照のこと。
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-seq_002dsetq"><span class="category-def">Macro: </span><span><strong class="def-name">seq-setq</strong> <var class="def-var-arguments">var-sequence val-sequence</var><a class="copiable-link" href="#index-seq_002dsetq"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-sequence-destructuring-1"></a>
<p>このマクロは<code class="code">seq-let</code>と同様に機能するが、<code class="code">let</code>ではなくあたかも<code class="code">setq</code>で値が変数にバインドされる点が異なる。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(let ((a nil)
      (b nil))
  (seq-setq (_ a _ b) '(1 2 3 4))
  (list a b))
&rArr; (2 4)
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-seq_002drandom_002delt"><span class="category-def">Function: </span><span><strong class="def-name">seq-random-elt</strong> <var class="def-var-arguments">sequence</var><a class="copiable-link" href="#index-seq_002drandom_002delt"> &para;</a></span></dt>
<dd><p>この関数は<var class="var">sequence</var>の要素をランダムにリターンする。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(seq-random-elt [1 2 3 4])
&rArr; 3
(seq-random-elt [1 2 3 4])
&rArr; 2
(seq-random-elt [1 2 3 4])
&rArr; 4
(seq-random-elt [1 2 3 4])
&rArr; 2
(seq-random-elt [1 2 3 4])
&rArr; 1
</pre></div></div>

<p><var class="var">sequence</var>が空ならこの関数はエラーをシグナルする。
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Arrays.html">配列</a>, Up: <a href="Sequences-Arrays-Vectors.html">シーケンス、配列、ベクター</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>


This page has generated for branch:work/emacs-30_11e7ae3964e192b0e4bcc437a04278ee727e720b, commit:c4c5930dbd799678308f200cfc5225ca3ecf76b2 to check Japanese translation.
</body>
</html>
