<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 30.0.50.

Copyright (C) 1990-1996, 1998-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "GNU General Public License," with the Front-Cover Texts
being "A GNU Manual," and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<title>Parsing Actions (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Parsing Actions (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Parsing Actions (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="date" content="May 16, 2024">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Parsing-Expression-Grammars.html" rel="up" title="Parsing Expression Grammars">
<link href="Writing-PEG-Rules.html" rel="next" title="Writing PEG Rules">
<link href="PEX-Definitions.html" rel="prev" title="PEX Definitions">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="section" id="Parsing-Actions">
<div class="header">
<p>
Next: <a href="Writing-PEG-Rules.html" accesskey="n" rel="next">Writing PEG Rules</a>, Previous: <a href="PEX-Definitions.html" accesskey="p" rel="prev">PEX Definitions</a>, Up: <a href="Parsing-Expression-Grammars.html" accesskey="u" rel="up">Parsing Expression Grammars</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Parsing-Actions-1"></span><h3 class="section">37.2 Parsing Actions</h3>

<span id="index-parsing-actions"></span>
<span id="index-parsing-stack"></span>
<p>By default the process of parsing simply moves point in the current buffer,
ultimately returning <code>t</code> if the parsing succeeds, and <code>nil</code> if it
doesn&rsquo;t.  It&rsquo;s also possible to define <em>parsing actions</em> that can run
arbitrary Elisp at certain points in the parsed text.  These actions can
optionally affect something called the <em>parsing stack</em>, which is a list
of values returned by the parsing process.  These actions only run (and only
return values) if the parsing process ultimately succeeds; if it fails the
action code is not run at all.
</p>
<p>Actions can be added anywhere in the definition of a rule.  They are
distinguished from parsing expressions by an initial backquote (&lsquo;<samp>`</samp>&rsquo;),
followed by a parenthetical form that must contain a pair of hyphens
(&lsquo;<samp>--</samp>&rsquo;) somewhere within it.  Symbols to the left of the hyphens are
bound to values popped from the stack (they are somewhat analogous to the
argument list of a lambda form).  Values produced by code to the right of
the hyphens are pushed onto the stack (analogous to the return value of the
lambda).  For instance, the previous grammar can be augmented with actions
to return the parsed number as an actual integer:
</p>
<div class="example">
<pre class="example">(with-peg-rules ((number sign digit (* digit
                                       `(a b -- (+ (* a 10) b)))
                         `(sign val -- (* sign val)))
                 (sign (or (and &quot;+&quot; `(-- 1))
                           (and &quot;-&quot; `(-- -1))
                           (and &quot;&quot;  `(-- 1))))
                 (digit [0-9] `(-- (- (char-before) ?0))))
  (peg-run (peg number)))
</pre></div>

<p>There must be values on the stack before they can be popped and returned &ndash;
if there aren&rsquo;t enough stack values to bind to an action&rsquo;s left-hand terms,
they will be bound to <code>nil</code>.  An action with only right-hand terms will
push values to the stack; an action with only left-hand terms will consume
(and discard) values from the stack.  At the end of parsing, stack values
are returned as a flat list.
</p>
<p>To return the string matched by a <acronym>PEX</acronym> (instead of simply moving
point over it), a grammar can use a rule like this:
</p>
<div class="example">
<pre class="example">(one-word
  `(-- (point))
  (+ [word])
  `(start -- (buffer-substring start (point))))
</pre></div>

<p>The first action above pushes the initial value of point to the stack.  The
intervening <acronym>PEX</acronym> moves point over the next word.  The second action
pops the previous value from the stack (binding it to the variable
<code>start</code>), then uses that value to extract a substring from the buffer
and push it to the stack.  This pattern is so common that <acronym>PEG</acronym>
provides a shorthand function that does exactly the above, along with a few
other shorthands for common scenarios:
</p>
<dl compact="compact">
<dd><span id="index-substring-_0028a-PEG-shorthand_0029"></span>
</dd>
<dt><span><code>(substring <var>e</var>)</code></span></dt>
<dd><p>Match <acronym>PEX</acronym> <var>e</var> and push the matched string onto the stack.
</p>
<span id="index-region-_0028a-PEG-shorthand_0029"></span>
</dd>
<dt><span><code>(region <var>e</var>)</code></span></dt>
<dd><p>Match <var>e</var> and push the start and end positions of the matched region
onto the stack.
</p>
<span id="index-replace-_0028a-PEG-shorthand_0029"></span>
</dd>
<dt><span><code>(replace <var>e</var> <var>replacement</var>)</code></span></dt>
<dd><p>Match <var>e</var> and replaced the matched region with the string
<var>replacement</var>.
</p>
<span id="index-list-_0028a-PEG-shorthand_0029"></span>
</dd>
<dt><span><code>(list <var>e</var>)</code></span></dt>
<dd><p>Match <var>e</var>, collect all values produced by <var>e</var> (and its
sub-expressions) into a list, and push that list onto the stack.  Stack
values are typically returned as a flat list; this is a way of &ldquo;grouping&rdquo;
values together.
</p></dd>
</dl>

</div>
<hr>
<div class="header">
<p>
Next: <a href="Writing-PEG-Rules.html">Writing PEG Rules</a>, Previous: <a href="PEX-Definitions.html">PEX Definitions</a>, Up: <a href="Parsing-Expression-Grammars.html">Parsing Expression Grammars</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>


This page has generated for branch:work/master_4078d0fd3ee9e55c3da219aa6e7788ac6130697b, commit:e7f7ad8f94ed71a4cfd3ad348db9f89a89d0cc44 to check Japanese translation.
</body>
</html>
