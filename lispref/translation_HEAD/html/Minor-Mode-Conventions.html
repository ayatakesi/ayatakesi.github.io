<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 30.0.91.

Copyright © 1990-1996, 1998-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "GNU General Public License," with the Front-Cover Texts
being "A GNU Manual," and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<title>Minor Mode Conventions (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Minor Mode Conventions (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Minor Mode Conventions (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="date" content="December 25, 2024">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Minor-Modes.html" rel="up" title="Minor Modes">
<link href="Keymaps-and-Minor-Modes.html" rel="next" title="Keymaps and Minor Modes">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">
<div class="subsection-level-extent" id="Minor-Mode-Conventions">
<div class="nav-panel">
<p>
Next: <a href="Keymaps-and-Minor-Modes.html" accesskey="n" rel="next">キーマップとマイナーモード</a>, Up: <a href="Minor-Modes.html" accesskey="u" rel="up">マイナーモード</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="mainamodoJi-Shu-noGui-Yue-"><span>24.3.1 マイナーモード記述の規約<a class="copiable-link" href="#mainamodoJi-Shu-noGui-Yue-"> &para;</a></span></h4>
<a class="index-entry-id" id="index-minor-mode-conventions"></a>
<a class="index-entry-id" id="index-conventions-for-writing-minor-modes"></a>

<p>メジャーモードにも監修があるように(<a class="ref" href="Major-Modes.html">メジャーモード</a>を参照)、マイナーモードの記述にも慣習があります。その慣習について以下で説明します。これらの慣習にしたがうにはマクロ<code class="code">define-minor-mode</code>を使用するのがもっとも簡単な方法です。<a class="ref" href="Defining-Minor-Modes.html">マイナーモードの定義</a>を参照してください。
</p>
<ul class="itemize mark-bullet">
<li><a class="index-entry-id" id="index-mode-variable"></a>
名前が&lsquo;<samp class="samp">-mode</samp>&rsquo;で終わる変数を定義する。これを<em class="dfn">モード変数(mode
variable)</em>と呼ぶ。マイナーモードコマンドはこの変数をセットすること。値はそのモードが無効なら<code class="code">nil</code>、有効なら非<code class="code">nil</code>になる。そのマイナーモードがバッファーローカルならこの変数もバッファーローカルであること。

<p>この変数はモードラインにマイナーモードの名前を表示するために<code class="code">minor-mode-alist</code>と結合して使用される。これは<code class="code">minor-mode-map-alist</code>を通じて、そのマイナーモードのキーマップがアクティブかどうかも判定する(<a class="ref" href="Controlling-Active-Maps.html">アクティブなキーマップの制御</a>を参照)。個々のコマンドやフックもこの変数の値をチェックできる。
</p>
</li><li>モード変数と同じ名前をもつ<em class="dfn">モードコマンド(mode
command)</em>と呼ばれるコマンドを定義する。このコマンドの役目はモード変数の値のセットに加えて、そのモードの機能を使用を実際に有効や無効にするために必要な他のすべてを行うことである。

<p>モードコマンドは1つのオプション引数を受け入れること。プレフィクス引数なしでinteractiveに呼び出されたらモードをトグルする(toggle:
切り替える。たとえば無効なら有効に、有効なら無効にする)こと。プレフィクス引数とともにinteractiveに呼び出された場合にはその引数が正であればモードを有効にして、それ以外なら無効にすること。
</p>
<p>モードコマンドがLispから(つまり非interactiveに)呼び出された場合は、引数が省略または<code class="code">nil</code>ならモードを有効にすること。引数がシンボル<code class="code">toggle</code>ならモードをトグルして、それ以外なら上述の数引数とともにinteractiveに呼び出されたときと同じ方法によってその引数を扱うこと。
</p>
<p>以下はこの挙動の実装方法を示す例である(<code class="code">define-minor-mode</code>マクロが生成するコードもこれに類似する)。
</p>
<div class="example">
<pre class="example-preformatted">(interactive (list (or current-prefix-arg 'toggle)))
(let ((enable
       (if (eq arg 'toggle)
           (not foo-mode) ; <span class="r">そのモードのモード変数</span>
         (&gt; (prefix-numeric-value arg) 0))))
  (if enable
      <var class="var">do-enable</var>
    <var class="var">do-disable</var>))
</pre></div>

<p>やや複雑なこの挙動の理由は、ユーザーが簡単かつinteractiveにマイナーモードをトグルできることと、以下のようにモードフック内で簡単にマイナーモードを有効にできるからである:
</p>
<div class="example">
<pre class="example-preformatted">(add-hook 'text-mode-hook 'foo-mode)
</pre></div>

<p><code class="code">foo-mode</code>モードコマンドは引数なしでLispから呼び出されたときは無条件にそのマイナーモードを有効にするので、これは<code class="code">foo-mode</code>がすでに有効でもそうでなくても正しく振る舞う。モードフック内でマイナーモードを無効にする場合は少々醜くなる:
</p>
<div class="example">
<pre class="example-preformatted">(add-hook 'text-mode-hook (lambda () (foo-mode -1)))
</pre></div>

<p>しかしこれは頻繁には行われない。
</p>
<p>マイナーモードを2回連続で直接有効(や無効)にしても失敗せずに、1回だけ有効(や無効)にしたときと同じことを行うこと。言い換えるとマイナーモードコマンドはべき等であること。
</p>
</li><li>モードラインにマイナーモードを表示したければ、それぞれのマイナーモードにたいして要素を<code class="code">minor-mode-alist</code>に追加する(<a class="ref" href="Mode-Line-Variables.html#Definition-of-minor_002dmode_002dalist">Definition of minor-mode-alist</a>を参照)。この要素は以下の形式のリストであること:

<div class="example smallexample">
<pre class="example-preformatted">(<var class="var">mode-variable</var> <var class="var">string</var>)
</pre></div>

<p>ここで<var class="var">mode-variable</var>はマイナーモードの有効化を制御する変数、<var class="var">string</var>はモードラインに表示するためのスペースで始まる短い文字列である。一度に複数モードの文字列がスペースを占有するので、これらの文字列は短くなければならない。
</p>
<p><code class="code">minor-mode-alist</code>に要素を追加する際は、重複を避けるために既存要素のチェックに<code class="code">assq</code>を使用すること。たとえば:
</p>
<div class="example smallexample">
<div class="group"><pre class="example-preformatted">(unless (assq 'leif-mode minor-mode-alist)
  (push '(leif-mode &quot; Leif&quot;) minor-mode-alist))
</pre></div></div>

<p>または以下のように<code class="code">add-to-list</code>(<a class="ref" href="List-Variables.html">リスト変数の変更</a>を参照)を使用すること:
</p>
<div class="example smallexample">
<div class="group"><pre class="example-preformatted">(add-to-list 'minor-mode-alist '(leif-mode &quot; Leif&quot;))
</pre></div></div>
</li></ul>

<p>これらに加えてメジャーモードにたいする慣習(<a class="ref" href="Major-Mode-Conventions.html">メジャーモードの慣習</a>を参照)のいくつかは、マイナーモードにたいしても同様に適用されます。それらの慣習はグローバルシンボルの名前、初期化関数の最後でのフックの使用、キーマップおよびその他のテーブルの使用です。
</p>
<p>マイナーモードは、可能ならCustom(<a class="ref" href="Customization.html">カスタマイゼーション設定</a>を参照)を通じた有効化と無効化をサポートするべきです。これを行うには、モード変数は<code class="code">:type
'boolean</code>とともに<code class="code">defcustom</code>で通常は定義されるべきです。その変数をセットするだけではモードの有効化に不足なら、モードコマンドを呼び出すことによりモードを有効にする<code class="code">:set</code>メソッドも指定するべきです。そしてその変数のドキュメント文字列にCustomを通じて変数をセットしなければ効果がないことを注記してください。さらにその定義をautoload
cookie(<a class="ref" href="Autoload.html#autoload-cookie">autoload cookie</a>を参照)でマークして、その変数のカスタマイズによりモードを定義するライブラリーがロードされるように<code class="code">:require</code>を指定します。たとえば:
</p>
<div class="example smallexample">
<div class="group"><pre class="example-preformatted">;;;###autoload
(defcustom msb-mode nil
  &quot;msb-modeをトグルする
この変数を直接セットしても効果がない
\\[customize]か関数`msb-mode'を使用すること&quot;
  :set 'custom-set-minor-mode
  :initialize 'custom-initialize-default
  :version &quot;20.4&quot;
  :type    'boolean
  :group   'msb
  :require 'msb)
</pre></div></div>

</div>


This page has generated for branch:work/emacs-30_69b16e5c63840479270d32f58daea923fe725b90, commit:02402ff71daa9b70cb0d01b228003435436925c7 to check Japanese translation.
</body>
</html>
