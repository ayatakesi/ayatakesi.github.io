<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 30.0.91.

Copyright © 1990-1996, 1998-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "GNU General Public License," with the Front-Cover Texts
being "A GNU Manual," and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<title>Conditionals (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Conditionals (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Conditionals (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="date" content="December 27, 2024">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Control-Structures.html" rel="up" title="Control Structures">
<link href="Combining-Conditions.html" rel="next" title="Combining Conditions">
<link href="Sequencing.html" rel="prev" title="Sequencing">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Conditionals">
<div class="nav-panel">
<p>
Next: <a href="Combining-Conditions.html" accesskey="n" rel="next">組み合わせ条件の構築</a>, Previous: <a href="Sequencing.html" accesskey="p" rel="prev">順序</a>, Up: <a href="Control-Structures.html" accesskey="u" rel="up">制御構造</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Tiao-Jian-"><span>11.2 条件<a class="copiable-link" href="#Tiao-Jian-"> &para;</a></span></h3>
<a class="index-entry-id" id="index-conditional-evaluation"></a>
<a class="index-entry-id" id="index-forms_002c-conditional"></a>

<p>条件による制御構造は候補の中から選択を行ないます。Emacs
Lispは5つの条件フォームをもちます。<code class="code">if</code>は他の言語のものとほとんど同じです。<code class="code">when</code>と<code class="code">unless</code>は<code class="code">if</code>の変種です。<code class="code">cond</code>は一般化されたcase命令です。<code class="code">cond</code>を汎用化したものが<code class="code">pcase</code>です(<a class="ref" href="Pattern_002dMatching-Conditional.html">パターンマッチングによる条件</a>を参照)。
</p>
<dl class="first-deffn first-defspec-alias-first-deffn">
<dt class="deffn defspec-alias-deffn" id="index-if"><span class="category-def">Special Form: </span><span><strong class="def-name">if</strong> <var class="def-var-arguments">condition then-form else-forms&hellip;</var><a class="copiable-link" href="#index-if"> &para;</a></span></dt>
<dd><p><code class="code">if</code>は<var class="var">condition</var>の値にもとづき<var class="var">then-form</var>と<var class="var">else-forms</var>を選択する。評価された<var class="var">condition</var>が非<code class="code">nil</code>なら<var class="var">then-form</var>が評価されて結果がリターンされる。それ以外なら<var class="var">else-forms</var>がテキスト順に評価されて最後のフォームの値がリターンされる(<code class="code">if</code>の<var class="var">else</var>パートは暗黙の<code class="code">progn</code>の例である。<a class="ref" href="Sequencing.html">順序</a>を参照)。
</p>
<p><var class="var">condition</var>の値が<code class="code">nil</code>で<var class="var">else-forms</var>が与えられなければ、<code class="code">if</code>は<code class="code">nil</code>をリターンする。
</p>
<p>選択されなかったブランチは決して評価されない &mdash; 無視される &mdash;
ので、<code class="code">if</code>はスペシャルフォームである。したがって以下の例では<code class="code">print</code>が呼び出されることはないので<code class="code">true</code>はプリントされない。
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(if nil
    (print 'true)
  'very-false)
&rArr; very-false
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-when"><span class="category-def">Macro: </span><span><strong class="def-name">when</strong> <var class="def-var-arguments">condition then-forms&hellip;</var><a class="copiable-link" href="#index-when"> &para;</a></span></dt>
<dd><p>これは<var class="var">else-forms</var>がなく、複数の<var class="var">then-forms</var>が可能な<code class="code">if</code>の変種である。特に、
</p>
<div class="example">
<pre class="example-preformatted">(when <var class="var">condition</var> <var class="var">a</var> <var class="var">b</var> <var class="var">c</var>)
</pre></div>

<p>は以下と完全に等価である
</p>
<div class="example">
<pre class="example-preformatted">(if <var class="var">condition</var> (progn <var class="var">a</var> <var class="var">b</var> <var class="var">c</var>) nil)
</pre></div>
</dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-unless"><span class="category-def">Macro: </span><span><strong class="def-name">unless</strong> <var class="def-var-arguments">condition forms&hellip;</var><a class="copiable-link" href="#index-unless"> &para;</a></span></dt>
<dd><p>これは<var class="var">then-form</var>がない<code class="code">if</code>の変種です:
</p>
<div class="example">
<pre class="example-preformatted">(unless <var class="var">condition</var> <var class="var">a</var> <var class="var">b</var> <var class="var">c</var>)
</pre></div>

<p>は以下と完全に等価である
</p>
<div class="example">
<pre class="example-preformatted">(if <var class="var">condition</var> nil
   <var class="var">a</var> <var class="var">b</var> <var class="var">c</var>)
</pre></div>
</dd></dl>

<dl class="first-deffn first-defspec-alias-first-deffn">
<dt class="deffn defspec-alias-deffn" id="index-cond"><span class="category-def">Special Form: </span><span><strong class="def-name">cond</strong> <var class="def-var-arguments">clause&hellip;</var><a class="copiable-link" href="#index-cond"> &para;</a></span></dt>
<dd><p><code class="code">cond</code>は任意個数の選択肢から選択を行なう。<code class="code">cond</code>内の各<var class="var">clause</var>はリストでなければならない。このリストの<small class="sc">CAR</small>は<var class="var">condition</var>で、(もしあれば)残りの要素は<var class="var">body-forms</var>となる。したがってclauseは以下のようになる:
</p>
<div class="example">
<pre class="example-preformatted">(<var class="var">condition</var> <var class="var">body-forms</var>...)
</pre></div>

<p><code class="code">cond</code>は各clauseの<var class="var">condition</var>を評価することにより、テキスト順でclauseを試みる。<var class="var">condition</var>の値が非<code class="code">nil</code>ならそのclauseは成り立つ。その後に<code class="code">cond</code>はそのclauseの<var class="var">body-forms</var>を評価して、<var class="var">body-forms</var>の最後の値をリターンする。残りのclauseは無視される。
</p>
<p><var class="var">condition</var>の値が<code class="code">nil</code>ならそのclauseは失敗して、<code class="code">cond</code>は次のclauseに移動してそれの<var class="var">condition</var>を試みる。
</p>
<p>clauseは以下のようにも見えるかもしれない:
</p>
<div class="example">
<pre class="example-preformatted">(<var class="var">condition</var>)
</pre></div>

<p><var class="var">condition</var>がテストされたときに非<code class="code">nil</code>なら、<code class="code">cond</code>フォームは<var class="var">condition</var>の値をリターンする。
</p>
<p>すべての<var class="var">condition</var>が<code class="code">nil</code>に評価された場合 &mdash;
つまりすべてのclauseが不成立なら、<code class="code">cond</code>は<code class="code">nil</code>をリターンする。
</p>
<p>以下の例は<code class="code">x</code>の値が数字、文字列、バッファー、シンボルなのかをテストする4つのclauseをもつ:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(cond ((numberp x) x)
      ((stringp x) x)
      ((bufferp x)
       (setq temporary-hack x) ; <span class="r">1つのclauseに</span>
       (buffer-name x))        ; <span class="r">複数bodyフォーム</span>
      ((symbolp x) (symbol-value x)))
</pre></div></div>

<p>前のclauseが不成立のとき最後の条項を実行したいときがよくある。これを行なうには<code class="code">(t
<var class="var">body-forms</var>)</code>のように、<var class="var">condition</var>の最後のclauseに<code class="code">t</code>を使用する。フォーム<code class="code">t</code>は<code class="code">t</code>に評価され決して<code class="code">nil</code>にならないので、このclauseが不成立になることはなく最終的に<code class="code">cond</code>はこのclauseに到達する。たとえば:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(setq a 5)
(cond ((eq a 'hack) 'foo)
      (t &quot;default&quot;))
&rArr; &quot;default&quot;
</pre></div></div>

<p>この<code class="code">cond</code>式は<code class="code">a</code>の値が<code class="code">hack</code>なら<code class="code">foo</code>、それ以外は文字列<code class="code">&quot;default&quot;</code>をリターンする。
</p></dd></dl>

<p>すべての条件構文は<code class="code">cond</code>か<code class="code">if</code>のいずれかで表すことができます。したがってどちらを選択するかはスタイルの問題になります。たとえば:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(if <var class="var">a</var> <var class="var">b</var> <var class="var">c</var>)
&equiv;
(cond (<var class="var">a</var> <var class="var">b</var>) (t <var class="var">c</var>))
</pre></div></div>

<p>変数のバインドとあわせて条件を使うと便利かもしれません。変数の計算を行って、その後もし値が非<code class="code">nil</code>なら何かしたいというのはよくあることです。これを行うには、たとえば以下のように単にそのまま記述すればよいのです:
</p>
<div class="example">
<pre class="example-preformatted">(let ((result1 (do-computation)))
  (when result1
    (let ((result2 (do-more result1)))
      (when result2
        (do-something result2)))))
</pre></div>

<p>これはパターンとしては非常に一般的なのでEmacsではこれを簡単に行って、かつ可読性を向上させるためのマクロがいくつか提供されています。上記のコードは以下のように記述することができます:
</p>
<div class="example">
<pre class="example-preformatted">(when-let* ((result1 (do-computation))
            (result2 (do-more result1)))
  (do-something result2))
</pre></div>

<p>このテーマにはバリエーションがいくつかあり、以下にそれらを概略します。
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-if_002dlet_002a"><span class="category-def">Macro: </span><span><strong class="def-name">if-let*</strong> <var class="def-var-arguments">varlist then-form else-forms...</var><a class="copiable-link" href="#index-if_002dlet_002a"> &para;</a></span></dt>
<dd><p><var class="var">varlist</var>内のバインディングそれぞれ評価して、値が<code class="code">nil</code>になるバインディングがあれば停止する。すべて非<code class="code">nil</code>なら<var class="var">then-form</var>、それ以外では<var class="var">else-forms</var>の最後のフォームの値をリターンする。
</p>
<p><code class="code">varlist</code>の要素はそれぞれ<code class="code">(<var class="var">symbol</var>&nbsp;<var class="var">value-form</var>)</code><!-- /@w -->という形式をもつ。ここでは<var class="var">value-form</var>が評価されて、その結果が<var class="var">symbol</var>にローカルにバインドされる。このバインディングは<code class="code">let*</code>
(<a class="ref" href="Local-Variables.html">ローカル変数</a>を参照)の場合と同じように、シーケンシャルに処理される。特別なケースとして、<var class="var">value-form</var>をテストした結果だけが必要な場合には<var class="var">symbol</var>を省略でき、<var class="var">value-form</var>は評価されて<code class="code">nil</code>かどうかのチェックは行われるものの値はバインドされない。
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-when_002dlet_002a"><span class="category-def">Macro: </span><span><strong class="def-name">when-let*</strong> <var class="def-var-arguments">varlist then-forms...</var><a class="copiable-link" href="#index-when_002dlet_002a"> &para;</a></span></dt>
<dd><p><var class="var">varlist</var>内のバインディングをそれぞれ評価して、値が<code class="code">nil</code>になるバインディングがあれば停止する。すべて非<code class="code">nil</code>なら<var class="var">then-form</var>の最後のフォームの値をリターンする。
</p>
<p><var class="var">varlist</var>は<code class="code">if-let*</code>と同じフォームをもつ。<code class="code">varlist</code>の要素はそれぞれ<code class="code">(<var class="var">symbol</var>&nbsp;<var class="var">value-form</var>)</code><!-- /@w -->というフォームをもち、<var class="var">value-form</var>が評価された結果が<var class="var">symbol</var>にローカルにバインドされる。バインディングは<code class="code">let*</code>
(<a class="ref" href="Local-Variables.html">ローカル変数</a>を参照)のように順に行われる。<var class="var">value-form</var>の結果だけが重要な場合には、特別に<var class="var">symbol</var>を省略できる。この場合には<var class="var">value-form</var>を評価して<code class="code">nil</code>のチェックはするが、値はバインドされない。
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-and_002dlet_002a"><span class="category-def">Macro: </span><span><strong class="def-name">and-let*</strong> <var class="def-var-arguments">varlist then-forms...</var><a class="copiable-link" href="#index-and_002dlet_002a"> &para;</a></span></dt>
<dd><p><var class="var">varlist</var>内のバインディングをそれぞれ評価して、値が<code class="code">nil</code>のバインディングがあれば停止する。すべてが非<code class="code">nil</code>の場合には<var class="var">then-forms</var>の最後のフォームの値、<var class="var">then-forms</var>がなければ最後のバインディングの値をリターンする。
</p>
<p><var class="var">varlist</var>は<code class="code">if-let*</code>と同じフォームをもつ。<code class="code">varlist</code>の要素はそれぞれ<code class="code">(<var class="var">symbol</var>&nbsp;<var class="var">value-form</var>)</code><!-- /@w -->というフォームをもち、<var class="var">value-form</var>が評価された結果が<var class="var">symbol</var>にローカルにバインドされる。バインディングは<code class="code">let*</code>
(<a class="ref" href="Local-Variables.html">ローカル変数</a>を参照)のように順に行われる。<var class="var">value-form</var>の結果だけが重要な場合には、特別に<var class="var">symbol</var>を省略できる。この場合には<var class="var">value-form</var>を評価して<code class="code">nil</code>のチェックはするが、値はバインドされない。
</p></dd></dl>

<p>フォームを評価したリターン値が目的の場合には<code class="code">and</code>と<code class="code">and-let*</code>、フォーム評価による副作用が目的であってリターン値は無視する場合には<code class="code">when</code>か<code class="code">when-let*</code>という慣習にしたがうLispプログラマーもいます。
</p>
<p>いずれかのバインディングが<code class="code">nil</code>に評価されるまでループを実行する似たようなマクロもあります:
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-while_002dlet"><span class="category-def">Macro: </span><span><strong class="def-name">while-let</strong> <var class="def-var-arguments">spec then-forms...</var><a class="copiable-link" href="#index-while_002dlet"> &para;</a></span></dt>
<dd><p><var class="var">spec</var>内のバインディングをそれぞれ順番に評価して、値が<code class="code">nil</code>のバインディングがあれば停止する。すべて<code class="code">nil</code>以外であれば、<var class="var">then-forms</var>を実行した後にループを繰り返す。ループを繰り返す際には<var class="var">spec</var>内の<var class="var">value-forms</var>が再び評価されて、新たなバインディングが確立されることに注意。
</p>
<p><var class="var">varlist</var>は<code class="code">if-let*</code>と同じフォームをもつ。<code class="code">varlist</code>の要素はそれぞれ<code class="code">(<var class="var">symbol</var>&nbsp;<var class="var">value-form</var>)</code><!-- /@w -->というフォームをもち、<var class="var">value-form</var>が評価された結果が<var class="var">symbol</var>にローカルにバインドされる。バインディングは<code class="code">let*</code>
(<a class="ref" href="Local-Variables.html">ローカル変数</a>を参照)のように順に行われる。<var class="var">value-form</var>の結果だけが重要な場合には、特別に<var class="var">symbol</var>を省略できる。この場合には<var class="var">value-form</var>を評価して<code class="code">nil</code>のチェックはするが、値はバインドされない。
</p>
<p><code class="code">while-let</code>は常に値<code class="code">nil</code>をリターンする。
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Combining-Conditions.html">組み合わせ条件の構築</a>, Previous: <a href="Sequencing.html">順序</a>, Up: <a href="Control-Structures.html">制御構造</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>


This page has generated for branch:work/emacs-30_69b16e5c63840479270d32f58daea923fe725b90, commit:418e91fc5443fb56c72c3d4ccfab525d8b25fa44 to check Japanese translation.
</body>
</html>
