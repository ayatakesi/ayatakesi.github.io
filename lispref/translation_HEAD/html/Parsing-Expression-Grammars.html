<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 30.0.50.

Copyright (C) 1990-1996, 1998-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "GNU General Public License," with the Front-Cover Texts
being "A GNU Manual," and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<title>Parsing Expression Grammars (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Parsing Expression Grammars (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Parsing Expression Grammars (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="date" content="May 18, 2024">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html" rel="up" title="Top">
<link href="Parsing-Program-Source.html" rel="next" title="Parsing Program Source">
<link href="Syntax-Tables.html" rel="prev" title="Syntax Tables">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="chapter" id="Parsing-Expression-Grammars">
<div class="header">
<p>
Next: <a href="Parsing-Program-Source.html" accesskey="n" rel="next">Parsing Program Source</a>, Previous: <a href="Syntax-Tables.html" accesskey="p" rel="prev">構文テーブル</a>, Up: <a href="index.html" accesskey="u" rel="up">Emacs Lisp</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Parsing-Expression-Grammars-1"></span><h2 class="chapter">37 Parsing Expression Grammars</h2>
<span id="index-text-parsing-1"></span>
<span id="index-parsing-expression-grammar"></span>
<span id="index-PEG"></span>

<p>Emacs Lisp provides several tools for parsing and matching text, from
regular expressions (see <a href="Regular-Expressions.html">正規表現</a>) to full left-to-right
(a.k.a. <acronym>LL</acronym>) grammar parsers (see <a data-manual="bovine" href="../bovine/index.html#Top">(bovine)Bovine parser
development</a>).  <em>Parsing Expression Grammars</em> (<acronym>PEG</acronym>) are
another approach to text parsing that offer more structure and composibility
than regular expressions, but less complexity than context-free grammars.
</p>
<p>A Parsing Expression Grammar (<acronym>PEG</acronym>) describes a formal language in
terms of a set of rules for recognizing strings in the language.  In Emacs,
a <acronym>PEG</acronym> parser is defined as a list of named rules, each of which
matches text patterns and/or contains references to other rules.  Parsing is
initiated with the function <code>peg-run</code> or the macro <code>peg-parse</code>
(see below), and parses text after point in the current buffer, using a
given set of rules.
</p>
<span id="index-parsing-expression"></span>
<span id="index-root_002c-of-parsing-expression-grammar"></span>
<span id="index-entry_002dpoint_002c-of-parsing-expression-grammar"></span>
<p>Each rule in a <acronym>PEG</acronym> is referred to as a <em>parsing expression</em>
(<acronym>PEX</acronym>), and can be specified a a literal string, a regexp-like
character range or set, a peg-specific construct resembling an Emacs Lisp
function call, a reference to another rule, or a combination of any of
these.  A grammar is expressed as a tree of rules in which one rule is
typically treated as a &ldquo;root&rdquo; or &ldquo;entry-point&rdquo; rule.  For instance:
</p>
<div class="example">
<pre class="example">((number sign digit (* digit))
 (sign   (or &quot;+&quot; &quot;-&quot; &quot;&quot;))
 (digit  [0-9]))
</pre></div>

<p>Once defined, grammars can be used to parse text after point in the current
buffer, in a number of ways.  The <code>peg-parse</code> macro is the simplest:
</p>
<dl class="def">
<dt id="index-peg_002dparse"><span class="category">Macro: </span><span><strong>peg-parse</strong> <em>&amp;rest pexs</em><a href='#index-peg_002dparse' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Match <var>pexs</var> at point.
</p></dd></dl>

<div class="example">
<pre class="example">(peg-parse
  (number sign digit (* digit))
  (sign   (or &quot;+&quot; &quot;-&quot; &quot;&quot;))
  (digit  [0-9]))
</pre></div>

<p>While this macro is simple it is also inflexible, as the rules must be
written directly into the source code.  More flexibility can be gained by
using a combination of other functions and macros.
</p>
<dl class="def">
<dt id="index-with_002dpeg_002drules"><span class="category">Macro: </span><span><strong>with-peg-rules</strong> <em>rules &amp;rest body</em><a href='#index-with_002dpeg_002drules' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Execute <var>body</var> with <var>rules</var>, a list of <acronym>PEX</acronym>s, in effect.
Within <var>BODY</var>, parsing is initiated with a call to <code>peg-run</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-peg_002drun"><span class="category">Function: </span><span><strong>peg-run</strong> <em>peg-matcher &amp;optional failure-function success-function</em><a href='#index-peg_002drun' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function accepts a single <var>peg-matcher</var>, which is the result of
calling <code>peg</code> (see below) on a named rule, usually the entry-point of a
larger grammar.
</p>
<p>At the end of parsing, one of <var>failure-function</var> or
<var>success-function</var> is called, depending on whether the parsing succeeded
or not.  If <var>success-function</var> is provided, it should be a function that
receives as its only argument an anonymous function that runs all the
actions collected on the stack during parsing.  By default this anonymous
function is simply executed.  If parsing fails, a function provided as
<var>failure-function</var> will be called with a list of <acronym>PEG</acronym>
expressions that failed during parsing.  By default this list is discarded.
</p></dd></dl>

<p>The <var>peg-matcher</var> passed to <code>peg-run</code> is produced by a call to
<code>peg</code>:
</p>
<dl class="def">
<dt id="index-peg"><span class="category">Macro: </span><span><strong>peg</strong> <em>&amp;rest pexs</em><a href='#index-peg' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Convert <var>pexs</var> into a single peg-matcher suitable for passing to
<code>peg-run</code>.
</p></dd></dl>

<p>The <code>peg-parse</code> example above expands to a set of calls to these
functions, and could be written in full as:
</p>
<div class="example">
<pre class="example">(with-peg-rules
    ((number sign digit (* digit))
     (sign   (or &quot;+&quot; &quot;-&quot; &quot;&quot;))
     (digit  [0-9]))
  (peg-run (peg number)))
</pre></div>

<p>This approach allows more explicit control over the &ldquo;entry-point&rdquo; of
parsing, and allows the combination of rules from different sources.
</p>
<p>Individual rules can also be defined using a more <code>defun</code>-like syntax,
using the macro <code>define-peg-rule</code>:
</p>
<dl class="def">
<dt id="index-define_002dpeg_002drule"><span class="category">Macro: </span><span><strong>define-peg-rule</strong> <em>name args &amp;rest pexs</em><a href='#index-define_002dpeg_002drule' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Define <var>name</var> as a PEG rule that accepts <var>args</var> and matches
<var>pexs</var> at point.
</p></dd></dl>

<p>For instance:
</p>
<div class="example">
<pre class="example">(define-peg-rule digit ()
  [0-9])
</pre></div>

<p>Arguments can be supplied to rules by the <code>funcall</code> PEG rule
(see <a href="PEX-Definitions.html">PEX Definitions</a>).
</p>
<p>Another possibility is to define a named set of rules with
<code>define-peg-ruleset</code>:
</p>
<dl class="def">
<dt id="index-define_002dpeg_002druleset"><span class="category">Macro: </span><span><strong>define-peg-ruleset</strong> <em>name &amp;rest rules</em><a href='#index-define_002dpeg_002druleset' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Define <var>name</var> as an identifier for <var>rules</var>.
</p></dd></dl>

<div class="example">
<pre class="example">(define-peg-ruleset number-grammar
        '((number sign digit (* digit))
          digit  ;; A reference to the definition above.
          (sign (or &quot;+&quot; &quot;-&quot; &quot;&quot;))))
</pre></div>

<p>Rules and rulesets defined this way can be referred to by name in later
calls to <code>peg-run</code> or <code>with-peg-rules</code>:
</p>
<div class="example">
<pre class="example">(with-peg-rules number-grammar
  (peg-run (peg number)))
</pre></div>

<p>By default, calls to <code>peg-run</code> or <code>peg-parse</code> produce no output:
parsing simply moves point.  In order to return or otherwise act upon parsed
strings, rules can include <em>actions</em>, see <a href="Parsing-Actions.html">Parsing Actions</a>.
</p>

<ul class="section-toc">
<li><a href="PEX-Definitions.html" accesskey="1">PEX Definitions</a></li>
<li><a href="Parsing-Actions.html" accesskey="2">Parsing Actions</a></li>
<li><a href="Writing-PEG-Rules.html" accesskey="3">Writing PEG Rules</a></li>
</ul>
</div>
<hr>
<div class="header">
<p>
Next: <a href="Parsing-Program-Source.html">Parsing Program Source</a>, Previous: <a href="Syntax-Tables.html">構文テーブル</a>, Up: <a href="index.html">Emacs Lisp</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>


This page has generated for branch:work/master_4078d0fd3ee9e55c3da219aa6e7788ac6130697b, commit:1a48a97cde288280767e6b175310f94ffd6f295b to check Japanese translation.
</body>
</html>
