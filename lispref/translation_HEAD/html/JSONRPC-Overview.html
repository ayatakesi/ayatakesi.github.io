<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 30.0.50.

Copyright (C) 1990-1996, 1998-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "GNU General Public License," with the Front-Cover Texts
being "A GNU Manual," and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<title>JSONRPC Overview (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="JSONRPC Overview (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="JSONRPC Overview (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="date" content="May 26, 2024">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="JSONRPC.html" rel="up" title="JSONRPC">
<link href="Process_002dbased-JSONRPC-connections.html" rel="next" title="Process-based JSONRPC connections">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="subsection" id="JSONRPC-Overview">
<div class="header">
<p>
Next: <a href="Process_002dbased-JSONRPC-connections.html" accesskey="n" rel="next">プロセスベースのJSONRPC接続</a>, Up: <a href="JSONRPC.html" accesskey="u" rel="up">JSONRPCによる対話</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Gai-Guan-"></span><h4 class="subsection">33.32.1 概観</h4>

<p><a href="https://www.jsonrpc.org/">spec</a>から引用するとJSONRPCは、&quot;同一プロセス、ソケットやhttp、多くのさまざまなメッセージパッシング環境において使用可能という概念においてトランスポート非依存&quot;です。
</p>
<span id="index-jsonrpc_002dconnection"></span>
<p>この非依存性をモデル化するために、<code>jsonrpc</code>ライブラリーはリモートのJSONのエンドポイントへの接続の表現に<code>jsonrpc-connection</code>クラスのオブジェクトを使用します(Emacsのオブジェクトシステムの詳細は<a data-manual="eieio" href="https://www.gnu.org/software/emacs/manual/html_node/eieio/index.html#Top">EIEIO</a> in <cite>EIEIO</cite>を参照)。これはオブジェクト指向の現代的な用語では&ldquo;抽象的(abstract)&rdquo;なクラス、すなわち有用な接続オブジェクトの実クラスは常に<code>jsonrpc-connection</code>のサブクラスになります。それにも関わらず、<code>jsonrpc-connection</code>クラスを中心に2つのAPIを個別に定義できます。
</p>
<span id="index-JSONRPC-application-interfaces"></span>
<ol>
<li> JSONRPCアプリケーション構築用のAPI

<span id="index-_003arequest_002ddispatcher"></span>
<span id="index-_003anotification_002ddispatcher"></span>
<span id="index-jsonrpc_002dnotify"></span>
<span id="index-jsonrpc_002drequest"></span>
<span id="index-jsonrpc_002dasync_002drequest"></span>
<p>このシナリオでは野心的な新しいJSONRPCベースのアプリケーションが、エンドポイント間で取り交わされるJSONRPCメッセージのトランスポートを提供する<code>jsonrpc-connection</code>の具体的なサブクラスを選択したものとする。
</p>
<p>アプリケーションは<code>make-instance</code>を用いてそのサブクラスのオブジェクトを作成する。リモートのエンドポイントとの接続を開始するために、アプリケーションはそのオブジェクトを<code>jsonrpc-notify</code>、<code>jsonrpc-request</code>、<code>jsonrpc-async-request</code>のような関数に渡す。
</p>
<p>リモートで開始された接続(通常は非同期で到来)を処理するには、<code>make-instance</code>によるインスタンス化においてEIEIOのキーワード引数<code>:request-dispatcher</code>および<code>:notification-dispatcher</code>を用いて初期化する必要がある。これらはいずれも接続オブジェクト、リモート呼び出しされるJSONRPCメッセージを命名するシンボル、JSONRPCの<code>params</code>オブジェクトという3つの引数をもつ。
</p>
<span id="index-jsonrpc_002derror"></span>
<p><code>:request-dispatcher</code>として渡される関数はリモートのエンドポイントのリクエストを処理する役目をもち、ローカルのエンドポイント(この例では構築中のアプリケーション)からのリプライを期待する。この関数の内部ではローカルにリターン(通常のリターン)、あるいは非ローカルにリターン(エラーをthrow)できる。リクエストディスパッチャーからどちらでexitしたとしても、トランスポートを通じてリモートのエンドポイントにリプライが送信される。
</p>
<p>通常のリターンは成功レスポンスと判断される。リターン値はJSONとしてシリアライズ可能なLispオブジェクトでなければならない(<a href="Parsing-JSON.html">JSON値の解析と生成</a>を参照)。この結果はJSONRPCの<code>result</code>オブジェクトとしてサーバーにフォワードされる。非ローカルなリターンは関数<code>jsonrpc-error</code>を呼び出すことによって行われる。これによりエラーのレスポンスがサーバーに送信される。JSONRPCの<code>error</code>に付随する詳細には、<code>jsonrpc-error</code>に渡されるものすべてが含まれる。他のタイプの予期せぬエラーからトリガーされた非局所的なリターンでも、(
<code>debug-on-error</code>をセットしていなければ)エラーレスポンスを送信して、この場合にはLispデバッガが呼び出される。<a href="Error-Debugging.html">エラーによるデバッガへのエンター</a>を参照のこと。
</p>
<span id="index-jsonrpc_002dconvert_002dto_002dendpoint"></span>
<span id="index-jsonrpc_002dconvert_002dfrom_002dendpoint"></span>
<p><code>jsonrpc</code>ライブラリーを使用して、&ldquo;準JSONRPC&rdquo;として記述されたトランスポートプロトコルベースのアプリケーションを構築することは可能である。これらは似てはいるが、<a href="https://www.jsonrpc.org/">DAP (Debug Adapter
Protocol)</a>のようにJSONRPCと完全に同一ではない。これらのプロトコルはリクエスト、レスポンス、通知メッセージも定義しているがフォーマットはJSONRPCと完全に同一ではない。JSONRPCの内部表現とエンドポイントが受け入れる表現を変換するように、ジェネリック関数<code>jsonrpc-convert-to-endpoint</code>および<code>jsonrpc-convert-from-endpoint</code>をカスタマイズできる(<a href="Generic-Functions.html">ジェネリック関数</a>を参照)。
</p>
</li><li> JSONRPCトランスポート構築用のAPI

<p>このシナリオでは基盤として異なるトランスポートストラテジーを実装するために<code>jsonrpc-connection</code>をサブクラス化する(サブクラス化する方法についての詳細は<a data-manual="eieio" href="https://www.gnu.org/software/emacs/manual/html_node/eieio/Inheritance.html#Inheritance">(eieio)Inheritance</a>を参照)。その後にアプリケーション構築インターフェースのユーザーは、(
<code>make-instance</code>関数を使用して)その具象クラスのオブジェクトをインスタンス化して、そのストラテジーを使用してJSONRPCエンドポイントに接続できる。ビルトインのトランスポート実装については、<a href="Process_002dbased-JSONRPC-connections.html">プロセスベースのJSONRPC接続</a>を参照のこと。
</p>
<p>このAPIには必須部分とオプション部分がある。
</p>
<span id="index-jsonrpc_002dconnection_002dsend"></span>
<p>JSONRPC接続(通知やリクエスト)を開始したりエンドポイントのリクエストへのリプライをユーザーに許すには、その新たなトランスポート実装がジェネリック関数<code>jsonrpc-connection-send</code>を新たなサブクラス用に特化して実装しなければならない(<a href="Generic-Functions.html">ジェネリック関数</a>を参照)。このジェネリック関数は<code>jsonrpc-request</code>や<code>jsonrpc-notify</code>のようなプリミティブから自動的に呼び出される。この特化によって引数リストに記述されたメッセージが、基礎となる通信メカニズム(&ldquo;wire&rdquo;とも呼ばれる)を介して送信されて、新たなトランスポートがエンドポイントとの対話に使用することを保証する必要がある。この&ldquo;wire&rdquo;はネットワークソケット、シリアルインターフェイス、あるいはHTTP接続などかもしれない。
</p>
<span id="index-jsonrpc_002dconnection_002dreceive"></span>
<p>同様に3種類のリモートコンタクト(リクエスト、通知、ローカルリクエストへの応答)を処理するために、トランスポート実装は&ldquo;wire&rdquo;上のJSONRPC(あるいは準JSONRPC)の作成に用いられるかもしれないJSONRPCメッセージに気づいたら、Elispから関数<code>jsonrpc-connection-receive</code>が呼び出されるように計らわなければならない。
</p>
<span id="index-jsonrpc_002dshutdown"></span>
<span id="index-jsonrpc_002drunning_002dp"></span>
<p>最後にオプションとして<code>jsonrpc-connection</code>サブクラスはジェネリック関数<code>jsonrpc-shutdown</code>および<code>jsonrpc-running-p</code>にたいして、これらの概念をトランスポートに適用する場合には、これらのジェネリック関数を特化する必要がある。<code>jsonrpc-shutdown</code>の特化によって、wire上でのメッセージのlistenに用いたすべてのシステムリソース(プロセス、タイマー等)を確実にリリースすること、<code>jsonrpc-running-p</code>の特化によって、これらのリソースがまだアクティブなのか、(<code>jsonrpc-shutdown</code>やその他を通じて)すでにリリース済みかを伝えるように実装する必要がある。
</p>
</li></ol>

</div>


This page has generated for branch:work/master_4078d0fd3ee9e55c3da219aa6e7788ac6130697b, commit:cf55e2bee4e8514bdb51232a606ed2d896304d3d to check Japanese translation.
</body>
</html>
