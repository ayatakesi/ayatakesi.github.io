<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 27.1.

Copyright (C) 1990-1996, 1998-2021 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "GNU General Public License," with the Front-Cover Texts
being "A GNU Manual," and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>GNU Emacs Lisp Reference Manual: Creating Symbols</title>

<meta name="description" content="GNU Emacs Lisp Reference Manual: Creating Symbols">
<meta name="keywords" content="GNU Emacs Lisp Reference Manual: Creating Symbols">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="date" content="December 30, 2021">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Symbols.html#Symbols" rel="up" title="Symbols">
<link href="Symbol-Properties.html#Symbol-Properties" rel="next" title="Symbol Properties">
<link href="Definitions.html#Definitions" rel="prev" title="Definitions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="ja_JP" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Creating-Symbols"></a>
<div class="header">
<p>
Next: <a href="Symbol-Properties.html#Symbol-Properties" accesskey="n" rel="next">Symbol Properties</a>, Previous: <a href="Definitions.html#Definitions" accesskey="p" rel="prev">Definitions</a>, Up: <a href="Symbols.html#Symbols" accesskey="u" rel="up">Symbols</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="sinborunoZuo-Cheng-tointern"></a>
<h3 class="section">9.3 シンボルの作成とintern</h3>
<a name="index-reading-symbols"></a>

<p>To understand how symbols are created in GNU Emacs Lisp, you must know how
Lisp reads them.  Lisp must ensure that it finds the same symbol every time
it reads the same sequence of characters in the same context.  Failure to do
so would cause complete confusion.
</p>
<a name="index-symbol-name-hashing"></a>
<a name="index-hashing"></a>
<a name="index-obarray"></a>
<a name="index-bucket-_0028in-obarray_0029"></a>
<p>When the Lisp reader encounters a name that references a symbol in the
source code, it reads all the characters of that name.  Then it looks up
that name in a table called an <em>obarray</em> to find the symbol that the
programmer meant.  The technique used in this lookup is called &ldquo;hashing&rdquo;,
an efficient method of looking something up by converting a sequence of
characters to a number, known as a &ldquo;hash code&rdquo;.  For example, instead of
searching a telephone book cover to cover when looking up Jan Jones, you
start with the J&rsquo;s and go from there.  That is a simple version of hashing.
Each element of the obarray is a <em>bucket</em> which holds all the symbols
with a given hash code; to look for a given name, it is sufficient to look
through all the symbols in the bucket for that name&rsquo;s hash code.  (The same
idea is used for general Emacs hash tables, but they are a different data
type; see <a href="Hash-Tables.html#Hash-Tables">Hash Tables</a>.)
</p>
<p>When looking up names, the Lisp reader also considers &ldquo;shorthands&rdquo;.  If
the programmer supplied them, this allows the reader to find a symbol even
if its name isn&rsquo;t present in its full form in the source code.  Of course,
the reader needs to be aware of some pre-established context about such
shorthands, much as one needs context to be to able to refer uniquely to Jan
Jones by just the name &ldquo;Jan&rdquo;: it&rsquo;s probably fine when amongst the Joneses,
or when Jan has been mentioned recently, but very ambiguous in any other
situation.  See <a href="Shorthands.html#Shorthands">Shorthands</a>.
</p>
<a name="index-interning"></a>
<p>探している名前のシンボルが見つかったら、リーダーはそのシンボルを使用します。obarrayにその名前のシンボルが含まれなければ、リーダーは新しいシンボルを作成してそれをobarrayに追加します。特定の名前のシンボルを探して追加することを<em>インターン(intern)</em>と言い、これが行なわれた後はそのシンボルは<em>インターンされたシンボル(interned
symbol)</em>と呼ばれます。
</p>
<p>インターンすることによりある特定の名前のシンボルは、各obarrayに1つだけであることが保証されます。同じ名前のシンボルが他に存在するかもしれませんが、同じobarrayには存在しません。したがってリーダーは、(同じobarrayを読みつづける限り)同じ名前にたいして同じシンボルを取得します。
</p>
<p>Interning usually happens automatically in the reader, but sometimes other
programs may want to do it.  For example, after the <kbd>M-x</kbd> command
obtains the command name as a string using the minibuffer, it then interns
the string, to get the interned symbol with that name.  As another example,
a hypothetical telephone book program could intern the name of each looked
up person&rsquo;s name as a symbol, even if the obarray did not contain it, so
that it could attach information to that new symbol, such as the last time
someone looked it up.
</p>
<a name="index-symbol-equality"></a>
<a name="index-uninterned-symbol"></a>
<p>No obarray contains all symbols; in fact, some symbols are not in any
obarray.  They are called <em>uninterned symbols</em>.  An uninterned symbol
has the same four cells as other symbols; however, the only way to gain
access to it is by finding it in some other object or as the value of a
variable.  Uninterned symbols are sometimes useful in generating Lisp code,
see below.
</p>
<p>Emacs
Lispではobarrayはベクターです。ベクター内の各要素がバケットになります。要素の値は、名前がそのバケットにハッシュされるようなインターンされたシンボル、またはバケットが空のときは0です。インターンされたシンボルは、そのバケット内の次のシンボルへの内部リンク(ユーザーからは見えない)をもちます。これらのリンクは不可視なので、<code>mapatoms</code>
(以下参照)を使用する方法をのぞき、obarray内のすべてのシンボルを探す方法はありません。バケット内のシンボルの順番に意味はありません。
</p>
<p>空のobarrayではすべての要素が0なので、<code>(make-vector <var>length</var>
0)</code>でobarrayを作成することができます。<strong>obarrayを作成する有効な方法はこれだけです。</strong>長さに素数を指定するとよいハッシュ化がされる傾向があります。2の累乗から1減じた長さもよい結果を生む傾向があります。
</p>
<p><strong>自分でobarrayにシンボルを置かないでください。</strong>これはうまくいきません &mdash;
obarrayに正しくシンボルを入力できるのは<code>intern</code>だけです。
</p>
<a name="index-CL-note_002d_002d_002dsymbol-in-obarrays"></a>
<blockquote>
<p><b>Common Lisp note:</b> Unlike Common Lisp, Emacs Lisp does not provide for
interning the same name in several different &ldquo;packages&rdquo;, thus creating
multiple symbols with the same name but different packages.  Emacs Lisp
provides a different namespacing system called &ldquo;shorthands&rdquo;
(see <a href="Shorthands.html#Shorthands">Shorthands</a>).
</p></blockquote>

<p>以下の関数のほとんどは、引数に名前とobarrayをとります。名前が文字列以外、またはobarrayがベクター以外なら<code>wrong-type-argument</code>エラーがシグナルされます。
</p>
<dl>
<dt><a name="index-symbol_002dname"></a>Function: <strong>symbol-name</strong> <em>symbol</em></dt>
<dd><p>この関数は<var>symbol</var>の名前を文字列としてリターンする。たとえば:
</p>
<div class="example">
<pre class="example">(symbol-name 'foo)
     &rArr; &quot;foo&quot;
</pre></div>

<p><strong>警告:
</strong>文字の置き換えにより文字列を変更すると、それはシンボルの名前を変更しますが、obarrayの更新には失敗するので行なわないこと!
</p></dd></dl>

<a name="index-uninterned-symbol_002c-and-generating-Lisp-code"></a>
<p>インターンされていないシンボルの作成は、Lispコードを生成するとき有用です。なぜなら作成されたコード内で変数として使用されているインターンされていないシンボルは、他のLispプログラムで使用されている任意の変数と競合することはありえないからです。
</p>
<dl>
<dt><a name="index-make_002dsymbol"></a>Function: <strong>make-symbol</strong> <em>name</em></dt>
<dd><p>この関数は新たに割り当てられた、名前が<var>name</var>(文字列でなかればならない)であるような、インターンされていないシンボルをリターンする。このシンボルの値と関数はvoidで、プロパティーリストは<code>nil</code>。以下の例では<code>sym</code>の値は<code>foo</code>と<code>eq</code>ではない。なぜならこれは名前が&lsquo;<samp>foo</samp>&rsquo;という、インターンされていないシンボルだからである。
</p>
<div class="example">
<pre class="example">(setq sym (make-symbol &quot;foo&quot;))
     &rArr; foo
(eq sym 'foo)
     &rArr; nil
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-gensym"></a>Function: <strong>gensym</strong> <em>&amp;optional prefix</em></dt>
<dd><p>This function returns a symbol using <code>make-symbol</code>, whose name is made
by appending <code>gensym-counter</code> to <var>prefix</var> and incrementing that
counter, guaranteeing that no two calls to this function will generate a
symbol with the same name.  The prefix defaults to <code>&quot;g&quot;</code>.
</p></dd></dl>

<p>To avoid problems when accidentally interning printed representation of
generated code (see <a href="Printed-Representation.html#Printed-Representation">Printed Representation</a>), it is recommended to use
<code>gensym</code> instead of <code>make-symbol</code>.
</p>
<dl>
<dt><a name="index-intern"></a>Function: <strong>intern</strong> <em>name &amp;optional obarray</em></dt>
<dd><p>この関数は名前が<var>name</var>であるような、インターンされたシンボルをリターンする。オブジェクト配列<var>obarray</var>の中にそのようなシンボルが存在しなければ、<code>intern</code>は新たにシンボルを作成してobarrayに追加してそれをリターンする。<var>obarray</var>が省略されると、グローバル変数<code>obarray</code>の値が使用される。
</p>
<div class="example">
<pre class="example">(setq sym (intern &quot;foo&quot;))
     &rArr; foo
(eq sym 'foo)
     &rArr; t

(setq sym1 (intern &quot;foo&quot; other-obarray))
     &rArr; foo
(eq sym1 'foo)
     &rArr; nil
</pre></div>
</dd></dl>

<a name="index-CL-note_002d_002d_002dinterning-existing-symbol"></a>
<blockquote>
<p><b>Common Lispに関する注意: </b>Common Lispでは既存のシンボルをobarrayにインターンできる。Emacs
Lispでは<code>intern</code>の引数はシンボルではなく文字列なのでこれを行なうことはできない。
</p></blockquote>

<dl>
<dt><a name="index-intern_002dsoft"></a>Function: <strong>intern-soft</strong> <em>name &amp;optional obarray</em></dt>
<dd><p>この関数は<var>obarray</var>内の名前が<var>name</var>のシンボル、<var>obarray</var>にその名前のシンボルが存在しなければ<code>nil</code>をリターンする。したがって与えられた名前のシンボルがすでにインターンされているかテストするために、<code>intern-soft</code>を使用することができる。<var>obarray</var>が省略されるとグローバル変数<code>obarray</code>の値が使用される。
</p>
<p>引数<var>name</var>にはシンボルも使用できる。この場合、指定されたobarrayに<var>name</var>がインターンされていれば<var>name</var>、それ以外なら<code>nil</code>をリターンする。
</p>
<div class="example">
<pre class="example">(intern-soft &quot;frazzle&quot;)        ; <span class="roman">そのようなシンボルは存在しない</span>
     &rArr; nil
(make-symbol &quot;frazzle&quot;)        ; <span class="roman">インターンされていないシンボルを作成する</span>
     &rArr; frazzle
</pre><pre class="example">(intern-soft &quot;frazzle&quot;)        ; <span class="roman">そのようなシンボルは見つからない</span>
     &rArr; nil
</pre><pre class="example">(setq sym (intern &quot;frazzle&quot;))  ; <span class="roman">インターンされたシンボルを作成する</span>
     &rArr; frazzle
</pre><pre class="example">(intern-soft &quot;frazzle&quot;)        ; <span class="roman">シンボルが見つかった!</span>
     &rArr; frazzle
</pre><pre class="example">(eq sym 'frazzle)              ; <span class="roman">そしてそれは同じシンボル</span>
     &rArr; t
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-obarray-1"></a>Variable: <strong>obarray</strong></dt>
<dd><p>この変数は<code>intern</code>と<code>read</code>が使用する標準のobarrayである。
</p></dd></dl>

<dl>
<dt><a name="index-mapatoms"></a>Function: <strong>mapatoms</strong> <em>function &amp;optional obarray</em></dt>
<dd><a name="Definition-of-mapatoms"></a><p>この関数はオブジェクト配列<var>obarray</var>の中の各シンボルにたいして、<var>function</var>を一度呼び出しその後<code>nil</code>をリターンする。<var>obarray</var>が省略されると、通常のシンボルにたいする標準のオブジェクト配列<code>obarray</code>の値がデフォルトになる。
</p>
<div class="example">
<pre class="example">(setq count 0)
     &rArr; 0
(defun count-syms (s)
  (setq count (1+ count)))
     &rArr; count-syms
(mapatoms 'count-syms)
     &rArr; nil
count
     &rArr; 1871
</pre></div>

<p><code>mapatoms</code>を使用する他の例については、<a href="Accessing-Documentation.html#Accessing-Documentation">Accessing Documentation</a>の<code>documentation</code>を参照のこと。
</p></dd></dl>

<dl>
<dt><a name="index-unintern"></a>Function: <strong>unintern</strong> <em>symbol obarray</em></dt>
<dd><p>この関数はオブジェクト配列<var>obarray</var>から<var>symbol</var>を削除する。obarrayの中に<code>symbol</code>が存在ければ、<code>unintern</code>は何も行なわない。<var>obarray</var>が<code>nil</code>なら現在のobarrayが使用される。
</p>
<p><var>symbol</var>にシンボルではなく文字列を与えると、それはシンボルの名前を意味する。この場合、<code>unintern</code>は(もしあれば)obarrayからその名前のシンボルを削除する。そのようなシンボルが存在するなら<code>unintern</code>は何も行なわない。
</p>
<p><code>unintern</code>がシンボルを削除したら<code>t</code>、それ以外は<code>nil</code>をリターンする。
</p></dd></dl>

<hr>
<div class="header">
<p>
Next: <a href="Symbol-Properties.html#Symbol-Properties" accesskey="n" rel="next">Symbol Properties</a>, Previous: <a href="Definitions.html#Definitions" accesskey="p" rel="prev">Definitions</a>, Up: <a href="Symbols.html#Symbols" accesskey="u" rel="up">Symbols</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>


This page has generated for branch:work/translate_emacs-28_06545bc0cc533b1abd831dd521df5f3369675d61, commit:51daf5d8dcb453e7a044d304a838ebc50ab5478e to check Japanese translation.
</body>
</html>
