<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 27.1.

Copyright (C) 1990-1996, 1998-2022 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "GNU General Public License," with the Front-Cover Texts
being "A GNU Manual," and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<title>Retrieving Nodes (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Retrieving Nodes (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Retrieving Nodes (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="date" content="April 3, 2023">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Parsing-Program-Source.html" rel="up" title="Parsing Program Source">
<link href="Accessing-Node-Information.html" rel="next" title="Accessing Node Information">
<link href="Using-Parser.html" rel="prev" title="Using Parser">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="section" id="Retrieving-Nodes">
<div class="header">
<p>
Next: <a href="Accessing-Node-Information.html" accesskey="n" rel="next">Accessing Node Information</a>, Previous: <a href="Using-Parser.html" accesskey="p" rel="prev">Using Tree-sitter Parser</a>, Up: <a href="Parsing-Program-Source.html" accesskey="u" rel="up">Parsing Program Source</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Retrieving-Nodes-1"></span><h3 class="section">37.3 Retrieving Nodes</h3>
<span id="index-retrieve-node_002c-tree_002dsitter"></span>
<span id="index-tree_002dsitter_002c-find-node"></span>
<span id="index-get-node_002c-tree_002dsitter"></span>

<span id="index-terminology_002c-for-tree_002dsitter-functions"></span>
<p>以下はわたしたちがtree-sitter関数を文書化する際に用いる用語と慣習についてです。
</p>
<p>わたしたちがあるノードについて述べる際に、ノードが&ldquo;小さくなる(smaller)&rdquo;や&ldquo;大きくなる(larger)&rdquo;とか&ldquo;低くなる(lower)&rdquo;や&ldquo;高くなる(higher)&rdquo;と表現する場合があります。ノードが小さくとか低くと表現する場合には構文ツリー上のノードの位置が低くなり、したがってノードがバッファーのテキストを横断する範囲が小さくなるということを、ノードが大きくとか高くと表現する場合には構文ツリー上のノードの位置が高くなることで子ノードとしてもっと小さいノードを多く含むこと、それ故にノードが横断するテキスト範囲が大きくなるということを意味します。
</p>
<p>関数がノードを見つけられなかった場合には<code>nil</code>をリターンします。利便性のために、引数としてノードを受け取ってノードをリターンするすべての関数も<code>nil</code>の引数を許し、そのような場合には単に<code>nil</code>をリターンするようになっています。
</p>
<span id="index-treesit_002dnode_002doutdated"></span>
<p>関連付けられているバッファーが更新された際にノードが自動的に更新されることはなく、一度取得したノードを更新する術は存在しません。古くなってしまったノードを使用すると<code>treesit-node-outdated</code>エラーがシグナルされるでしょう。
</p>
<span id="Gou-WenturikaranonodonoQu-De-"></span><h3 class="heading">構文ツリーからのノードの取得</h3>
<span id="index-retrieving-tree_002dsitter-nodes"></span>
<span id="index-syntax-tree_002c-retrieving-nodes"></span>

<span id="index-leaf-node_002c-of-tree_002dsitter-parse-tree"></span>
<span id="index-tree_002dsitter-parse-tree_002c-leaf-node"></span>
<dl class="def">
<dt id="index-treesit_002dnode_002dat"><span class="category">Function: </span><span><strong>treesit-node-at</strong> <em>pos &amp;optional parser-or-lang named</em><a href='#index-treesit_002dnode_002dat' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数はバッファー位置<var>pos</var>にある<em>葉ノード(leaf
node)</em>をリターンする。葉ノードとは子ノードを何ももたないノードのこと。
</p>
<p>この関数は<var>pos</var>を横断して覆うようなノードのリターンを試みる。これは開始位置が<var>pos</var>以下、かつ終了位置が<var>pos</var>以上であるノードのこと。
</p>
<p><var>pos</var>を横断して覆うような葉ノードがない(たとえば<var>pos</var>が2つの葉ノードの間にある空白にある)場合には、この関数は<var>pos</var>の後にある最初の葉ノードをリターンする。
</p>
<p>最後にもし<var>pos</var>の後に葉ノードがの場合には、<var>pos</var>の前にある最初の葉ノードをリターンする。
</p>
<p><var>parser-or-lang</var>が<code>nil</code>または省略なら、この関数はカレントバッファーの<code>(treesit-parser-list)</code>にある最初のパーサーを使用する。<var>parser-or-lang</var>がパーサーオブジェクトならそのパーサー、<var>parser-or-lang</var>が言語なら<code>(treesit-parser-list)</code>内からその言語を使用する最初のパーサーを探してそれを使用する。
</p>
<p>リターンする適切なノードが見つけられなかった場合には、この関数は<code>nil</code>をリターンする。
</p>
<p><var>named</var>が非<code>nil</code>の場合には、この関数は名前つきのノードだけを探す(<a href="Language-Definitions.html#tree_002dsitter-named-node">named node</a>を参照)。
</p>
<p>例:
</p>
<div class="example">
<pre class="example">;; Cパーサーの構文ツリーでポイント位置のノードを探す
(treesit-node-at (point) 'c)
  &rArr; #&lt;treesit-node (primitive_type) in 23-27&gt;
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-treesit_002dnode_002don"><span class="category">Function: </span><span><strong>treesit-node-on</strong> <em>beg end &amp;optional parser-or-lang named</em><a href='#index-treesit_002dnode_002don' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>beg</var>と<var>end</var>の間にあるバッファーテキストのリージョンを覆うような、<em>もっとも小さい</em>ノードをリターンする。言い換えると開始が<var>beg</var>以前、かつ終了が<var>end</var>以降であるようなノードのこと。
</p>
<p><em>注意せよ:</em>
トップレベル構文(関数定義等)の内部にない空行でこの関数を呼び出すと、恐らくほとんどはルートノードが得られるだろう。その空行を覆うもっとも小さいノードがルートノードだというのがその理由だが、あなたが使いたいと望んでいる機能は、ほとんどの場合は上述の<code>treesit-node-at</code>のほうだろう。
</p>
<p><var>parser-or-lang</var>が<code>nil</code>の場合には、この関数はカレントバッファーの<code>(treesit-parser-list)</code>にある最初のパーサーを使用する。<var>parser-or-lang</var>がパーサーオブジェクトならそのパーサー、<var>parser-or-lang</var>が言語の場合には<code>(treesit-parser-list)</code>でその言語を使用するパーサーを探して、最初に見つかったパーサーを使用する。
</p>
<p><var>named</var>が非<code>nil</code>の場合には、この関数は名前つきのノードだけを探す(<a href="Language-Definitions.html#tree_002dsitter-named-node">named node</a>を参照)。
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dparser_002droot_002dnode"><span class="category">Function: </span><span><strong>treesit-parser-root-node</strong> <em>parser</em><a href='#index-treesit_002dparser_002droot_002dnode' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>parser</var>が生成した構文ツリーのルートノードをリターンする。
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dbuffer_002droot_002dnode"><span class="category">Function: </span><span><strong>treesit-buffer-root-node</strong> <em>&amp;optional language</em><a href='#index-treesit_002dbuffer_002droot_002dnode' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数はカレントバッファーの<code>(treesit-parser-list)</code>で<var>language</var>を使用する最初のパーサーを探して、そのパーサーが生成したルートノードをリターンする。適切なパーサーが見つけられなかった場合には<code>nil</code>をリターンする。
</p></dd></dl>

<p>Lispプログラムはノードが与えられれば、 そこから始まる他のノードを取得したり、そのノードに関する情報を問い合わせることができます。
</p>
<span id="nodokaranoTa-nodonoQu-De-"></span><h3 class="heading">ノードからの他ノードの取得</h3>
<span id="index-syntax-tree-nodes_002c-retrieving-from-other-nodes"></span>

<span id="Qin-Zu-Guan-Xi-kara"></span><h4 class="subheading">親族関係から</h4>
<span id="index-kinship_002c-syntax-tree-nodes"></span>
<span id="index-nodes_002c-by-kinship"></span>
<span id="index-syntax-tree-nodes_002c-by-kinship"></span>

<dl class="def">
<dt id="index-treesit_002dnode_002dparent"><span class="category">Function: </span><span><strong>treesit-node-parent</strong> <em>node</em><a href='#index-treesit_002dnode_002dparent' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>node</var>の直近の親をリターンする。
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dnode_002dchild"><span class="category">Function: </span><span><strong>treesit-node-child</strong> <em>node n &amp;optional named</em><a href='#index-treesit_002dnode_002dchild' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>node</var>の<var>n</var>番目の子をリターンする。<var>named</var>が非<code>nil</code>なら名前つきのノードだけを考慮する(<a href="Language-Definitions.html#tree_002dsitter-named-node">named node</a>を参照)。
</p>
<p>たとえば文字列<code>&quot;text&quot;</code>を表すノードの場合には開クォート<code>&quot;</code>、文字列テキストの<code>text</code>、それに閉クォート<code>&quot;</code>という3つの子ノードが存在する。これら3つのノードの中で最初の子は開クォート<code>&quot;</code>、最初の名前つきの子は文字列テキストとなる。
</p>
<p>この関数は<var>n</var>番目の子が存在しなければ<code>nil</code>をリターンする。<var>n</var>は負でも可(<code>-1</code>は最後の子を表す)。
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dnode_002dchildren"><span class="category">Function: </span><span><strong>treesit-node-children</strong> <em>node &amp;optional named</em><a href='#index-treesit_002dnode_002dchildren' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>node</var>のすべての子をリストでリターンする。<var>named</var>が非<code>nil</code>なら名前つきのノードだけを取得する。
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dnext_002dsibling"><span class="category">Function: </span><span><strong>treesit-next-sibling</strong> <em>node &amp;optional named</em><a href='#index-treesit_002dnext_002dsibling' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>node</var>の次の兄弟を探す。<var>named</var>が非<code>nil</code>なら次の名前つきの兄弟を探す。
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dprev_002dsibling"><span class="category">Function: </span><span><strong>treesit-prev-sibling</strong> <em>node &amp;optional named</em><a href='#index-treesit_002dprev_002dsibling' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数は<var>node</var>の前の兄弟を探す。<var>named</var>が非<code>nil</code>なら前の名前つきの兄弟を探す。
</p></dd></dl>

<span id="huirudoMing-kara"></span><h4 class="subheading">フィールド名から</h4>
<span id="index-nodes_002c-by-field-name"></span>
<span id="index-syntax-tree-nodes_002c-by-field-name"></span>

<p>構文ツリーの分析をより容易にするために、多くの言語では定義で子ノードに<em>フィールド名(field
names)</em>和割り当てています(<a href="Language-Definitions.html#tree_002dsitter-node-field-name">field
name</a>を参照)。たとえば<code>function_definition</code>ノードには<code>declarator</code>や<code>body</code>というノードがあるかもしれません。
</p>
<dl class="def">
<dt id="index-treesit_002dchild_002dby_002dfield_002dname"><span class="category">Function: </span><span><strong>treesit-child-by-field-name</strong> <em>node field-name</em><a href='#index-treesit_002dchild_002dby_002dfield_002dname' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数はフィールド名が<var>field-name</var>(文字列)であるような<var>node</var>の子を探す。
</p>
<div class="example">
<pre class="example">;;フィールド名が&quot;body&quot;という子を取得
(treesit-child-by-field-name node &quot;body&quot;)
  &rArr; #&lt;treesit-node (compound_statement) in 45-89&gt;
</pre></div>
</dd></dl>

<span id="Wei-Zhi-kara"></span><h4 class="subheading">位置から</h4>
<span id="index-nodes_002c-by-position"></span>
<span id="index-syntax-tree-nodes_002c-by-position"></span>

<dl class="def">
<dt id="index-treesit_002dfirst_002dchild_002dfor_002dpos"><span class="category">Function: </span><span><strong>treesit-first-child-for-pos</strong> <em>node pos &amp;optional named</em><a href='#index-treesit_002dfirst_002dchild_002dfor_002dpos' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>この関数はバッファー位置<var>pos</var>を超えて広がるような<var>node</var>の最初の子をリターンする。&ldquo;超えて広がる(extends
beyond)&rdquo;とは子ノードの終端が<var>pos</var>以降であることを意味する。この関数は<var>node</var>の直接の子だけを調べる(孫は調べない)。<var>named</var>が非<code>nil</code>の場合には最初の名前つきの子を探す(<a href="Language-Definitions.html#tree_002dsitter-named-node">named node</a>を参照)。
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dnode_002ddescendant_002dfor_002drange"><span class="category">Function: </span><span><strong>treesit-node-descendant-for-range</strong> <em>node beg end &amp;optional named</em><a href='#index-treesit_002dnode_002ddescendant_002dfor_002drange' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>これは位置<var>beg</var>と<var>end</var>の間にあるテキストリージョンを横断するような、<var>node</var>の<em>もっとも小さい</em>子孫ノードを探す、<code>treesit-node-at</code>と似た関数。<var>named</var>が非<code>nil</code>の場合には、もっとも小さい名前つきの子を探す。
</p></dd></dl>

<span id="Searching-for-node"></span><h3 class="heading">Searching for node</h3>

<dl class="def">
<dt id="index-treesit_002dsearch_002dsubtree"><span class="category">Function: </span><span><strong>treesit-search-subtree</strong> <em>node predicate &amp;optional backward all limit</em><a href='#index-treesit_002dsearch_002dsubtree' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function traverses the subtree of <var>node</var> (including <var>node</var>
itself), looking for a node for which <var>predicate</var> returns
non-<code>nil</code>.  <var>predicate</var> is a regexp that is matched against each
node&rsquo;s type, or a predicate function that takes a node and returns
non-<code>nil</code> if the node matches.  The function returns the first node
that matches, or <code>nil</code> if none does.
</p>
<p>By default, this function only traverses named nodes, but if <var>all</var> is
non-<code>nil</code>, it traverses all the nodes.  If <var>backward</var> is
non-<code>nil</code>, it traverses backwards (i.e., it visits the last child first
when traversing down the tree).  If <var>limit</var> is non-<code>nil</code>, it must
be a number that limits the tree traversal to that many levels down the
tree.  If <var>limit</var> is <code>nil</code>, it defaults to 1000.
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dsearch_002dforward"><span class="category">Function: </span><span><strong>treesit-search-forward</strong> <em>start predicate &amp;optional backward all</em><a href='#index-treesit_002dsearch_002dforward' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Like <code>treesit-search-subtree</code>, this function also traverses the parse
tree and matches each node with <var>predicate</var> (except for <var>start</var>),
where <var>predicate</var> can be a regexp or a function.  For a tree like the
below where <var>start</var> is marked S, this function traverses as numbered
from 1 to 12:
</p>
<div class="example">
<pre class="example">              12
              |
     S--------3----------11
     |        |          |
o--o-+--o  1--+--2    6--+-----10
|  |                  |        |
o  o                +-+-+   +--+--+
                    |   |   |  |  |
                    4   5   7  8  9
</pre></div>

<p>Note that this function doesn&rsquo;t traverse the subtree of <var>start</var>, and it
always traverse leaf nodes first, then upwards.
</p>
<p>Like <code>treesit-search-subtree</code>, this function only searches for named
nodes by default, but if <var>all</var> is non-<code>nil</code>, it searches for all
nodes.  If <var>backward</var> is non-<code>nil</code>, it searches backwards.
</p>
<p>While <code>treesit-search-subtree</code> traverses the subtree of a node, this
function starts with node <var>start</var> and traverses every node that comes
after it in the buffer position order, i.e., nodes with start positions
greater than the end position of <var>start</var>.
</p>
<p>In the tree shown above, <code>treesit-search-subtree</code> traverses node S
(<var>start</var>) and nodes marked with <code>o</code>, where this function traverses
the nodes marked with numbers.  This function is useful for answering
questions like &ldquo;what is the first node after <var>start</var> in the buffer that
satisfies some condition?&rdquo;
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dsearch_002dforward_002dgoto"><span class="category">Function: </span><span><strong>treesit-search-forward-goto</strong> <em>node predicate &amp;optional start backward all</em><a href='#index-treesit_002dsearch_002dforward_002dgoto' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function moves point to the start or end of the next node after
<var>node</var> in the buffer that matches <var>predicate</var>.  If <var>start</var> is
non-<code>nil</code>, stop at the beginning rather than the end of a node.
</p>
<p>This function guarantees that the matched node it returns makes progress in
terms of buffer position: the start/end position of the returned node is
always greater than that of <var>node</var>.
</p>
<p>Arguments <var>predicate</var>, <var>backward</var> and <var>all</var> are the same as in
<code>treesit-search-forward</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dinduce_002dsparse_002dtree"><span class="category">Function: </span><span><strong>treesit-induce-sparse-tree</strong> <em>root predicate &amp;optional process-fn limit</em><a href='#index-treesit_002dinduce_002dsparse_002dtree' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function creates a sparse tree from <var>root</var>&rsquo;s subtree.
</p>
<p>It takes the subtree under <var>root</var>, and combs it so only the nodes that
match <var>predicate</var> are left.  Like previous functions, the
<var>predicate</var> can be a regexp string that matches against each node&rsquo;s
type, or a function that takes a node and return non-<code>nil</code> if it
matches.
</p>
<p>For example, for a subtree on the left that consist of both numbers and
letters, if <var>predicate</var> is &ldquo;letter only&rdquo;, the returned tree is the one
on the right.
</p>
<div class="example">
<pre class="example">    a                 a              a
    |                 |              |
+---+---+         +---+---+      +---+---+
|   |   |         |   |   |      |   |   |
b   1   2         b   |   |      b   c   d
    |   |     =&gt;      |   |  =&gt;      |
    c   +--+          c   +          e
    |   |  |          |   |
 +--+   d  4       +--+   d
 |  |              |
 e  5              e
</pre></div>

<p>If <var>process-fn</var> is non-<code>nil</code>, instead of returning the matched
nodes, this function passes each node to <var>process-fn</var> and uses the
returned value instead.  If non-<code>nil</code>, <var>limit</var> is the number of
levels to go down from <var>root</var>.  If <var>limit</var> is <code>nil</code>, it
defaults to 1000.
</p>
<p>Each node in the returned tree looks like <code>(<var><span class="nolinebreak">tree-sitter-node</span></var>&nbsp;.&nbsp;(<var>child</var>&nbsp;&hellip;))</code><!-- /@w -->.  The <var>tree-sitter-node</var> of the root of this
tree will be nil if <var>root</var> doesn&rsquo;t match <var>predicate</var>.  If no node
matches <var>predicate</var>, the function returns <code>nil</code>.
</p></dd></dl>

<span id="More-convenience-functions"></span><h3 class="heading">More convenience functions</h3>

<dl class="def">
<dt id="index-treesit_002dfilter_002dchild"><span class="category">Function: </span><span><strong>treesit-filter-child</strong> <em>node predicate &amp;optional named</em><a href='#index-treesit_002dfilter_002dchild' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function finds immediate children of <var>node</var> that satisfy
<var>predicate</var>.
</p>
<p>The <var>predicate</var> function takes a node as the argument and should return
non-<code>nil</code> to indicate that the node should be kept.  If <var>named</var> is
non-<code>nil</code>, this function only examines the named nodes.
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dparent_002duntil"><span class="category">Function: </span><span><strong>treesit-parent-until</strong> <em>node predicate</em><a href='#index-treesit_002dparent_002duntil' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function repeatedly finds the parents of <var>node</var>, and returns the
parent that satisfies <var>predicate</var>, a function that takes a node as the
argument.  If no parent satisfies <var>predicate</var>, this function returns
<code>nil</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dparent_002dwhile"><span class="category">Function: </span><span><strong>treesit-parent-while</strong> <em>node predicate</em><a href='#index-treesit_002dparent_002dwhile' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function repeatedly finds the parent of <var>node</var>, and keeps doing so
as long as the nodes satisfy <var>predicate</var>, a function that takes a node
as the argument.  That is, this function returns the farthest parent that
still satisfies <var>predicate</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-treesit_002dnode_002dtop_002dlevel"><span class="category">Function: </span><span><strong>treesit-node-top-level</strong> <em>node &amp;optional type</em><a href='#index-treesit_002dnode_002dtop_002dlevel' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function returns the highest parent of <var>node</var> that has the same
type as <var>node</var>.  If no such parent exists, it returns <code>nil</code>.
Therefore this function is also useful for testing whether <var>node</var> is
top-level.
</p>
<p>If <var>type</var> is non-<code>nil</code>, this function matches each parent&rsquo;s type
with <var>type</var> as a regexp, rather than using <var>node</var>&rsquo;s type.
</p></dd></dl>

</div>
<hr>
<div class="header">
<p>
Next: <a href="Accessing-Node-Information.html">Accessing Node Information</a>, Previous: <a href="Using-Parser.html">Using Tree-sitter Parser</a>, Up: <a href="Parsing-Program-Source.html">Parsing Program Source</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>


This page has generated for branch:work/a270d41fe90516c01eb14fb2a10baf40bf59ca29, commit:7915b4b8a2f8979f24f7149971edfbad44b3fa69 to check Japanese translation.
</body>
</html>
