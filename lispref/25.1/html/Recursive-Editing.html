<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 25.1.

Copyright (C) 1990-1996, 1998-2016 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with the Invariant
Sections being "GNU General Public License," with the Front-Cover Texts
being "A GNU Manual," and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom." -->
<!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>20.13 再帰編集 (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="20.13 再帰編集 (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="20.13 再帰編集 (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Emacs Lisp">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Command-Loop.html#Command-Loop" rel="up" title="20 コマンドループ">
<link href="Disabling-Commands.html#Disabling-Commands" rel="next" title="20.14 コマンドの無効化">
<link href="Prefix-Command-Arguments.html#Prefix-Command-Arguments" rel="prev" title="20.12 プレフィクスコマンド引数">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<span id="Recursive-Editing"></span><div class="header">
<p>
Next: <a href="Disabling-Commands.html#Disabling-Commands" accesskey="n" rel="next">Disabling Commands</a>, Previous: <a href="Prefix-Command-Arguments.html#Prefix-Command-Arguments" accesskey="p" rel="prev">Prefix Command Arguments</a>, Up: <a href="Command-Loop.html#Command-Loop" accesskey="u" rel="up">Command Loop</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Zai-Gui-Bian-Ji-"></span><h3 class="section">20.13 再帰編集</h3>
<span id="index-recursive-command-loop"></span>
<span id="index-recursive-editing-level"></span>
<span id="index-command-loop_002c-recursive"></span>

<p>Emacsスタートアップ時に、自動的にEmacsコマンドループにエンターします。このトップレベルのコマンドループ呼び出しは決してexitせず、Emacs実行中は実行を続けます。Lispプログラムもコマンドループを呼び出せます。これは複数のコマンドループを活性化するため、これを<em>再帰編集(recursive
editing)</em>と呼んでいます。再帰編集レベルは、呼び出したコマンドが何であれそれをサスペンドして、そのコマンドを再開する前にユーザーが任意の編集を行うことを可能にする効果をもちます。
</p>
<p>再帰編集の間に利用可能なコマンドは、トップレベルの編集ループ内で利用できるコマンドと同じであり、キーマップ内で定義されます。数少ない特別なコマンドだけが再帰編集レベルをexitし、他のコマンドは再帰編集レベルが終了したときに再帰編集レベルからリターンします(exitするための特別なコマンドは常に利用できますが、再帰編集が行われていないときは何も行いません)。
</p>
<p>再帰コマンドループを含むすべてのコマンドループは、コマンドループから実行されたコマンド内のエラーによりそのループをexitしないように、汎用エラーハンドラーをセットアップします。
</p>
<span id="index-minibuffer-input"></span>
<p>ミニバッファー入力は、特殊な再帰編集です。これは、ミニバッファーとミニバッファーウィンドウの表示を有効にするなどの欠点をもちますが、それはあなたが思うより少ないでしょう。ミニバッファー内では特定のキーの振る舞いが異なりますが、これははミニバッファーのローカルマップによるものです。ウィンドウを切り替えれば、通常のEmacsコマンドを使用できます。
</p>
<span id="index-throw-example"></span>
<span id="index-exit"></span>
<span id="index-exit-recursive-editing"></span>
<span id="index-aborting"></span>
<p>再帰編集レベルを呼び出すには、関数を<code>recursive-edit</code>を呼び出します。この関数はコマンドループを含んでいます。さらに<code>exit</code>をthrowすることにより再帰編集レベルのexitを可能にする、タグ<code>exit</code>をともなう<code>catch</code>呼び出しも含んでいます(<a href="Catch-and-Throw.html#Catch-and-Throw">明示的な非ローカル脱出: <code>catch</code>と<code>throw</code></a>を参照)。<code>t</code>以外の値をthrowした場合、<code>recursive-edit</code>は通常それを呼び出した関数にリターンします。コマンド<kbd>C-M-c</kbd>(<code>exit-recursive-edit</code>)がこれを行います。値<code>t</code>をthrowすることにより<code>recursive-edit</code>がquitされるので、1レベル上位のコマンドループに制御がリターンされます。これは<em>abort</em>と呼ばれ、<kbd>C-]</kbd>(<code>abort-recursive-edit</code>)がこれを行います。
</p>
<p>Most applications should not use recursive editing, except as part of using
the minibuffer.  Usually it is more convenient for the user if you change
the major mode of the current buffer temporarily to a special major mode,
which should have a command to go back to the previous mode.  (The <kbd>e</kbd>
command in Rmail uses this technique.)  Or, if you wish to give the user
different text to edit recursively, create and select a new buffer in a
special mode.  In this mode, define a command to complete the processing and
go back to the previous buffer.  (The <kbd>m</kbd> command in Rmail does this.)
</p>
<p>再帰編集はデバッグに便利です。一種のブレークポイントとして関数定義内に<code>debug</code>を挿入して、関数がそこに達したときにその箇所を調べることができます。<code>debug</code>は再帰編集を呼び出しますが、デバッガのその他の機能も提供します。
</p>
<p><code>query-replace</code>内で<kbd>C-r</kbd>をタイプしたときや<kbd>C-x
q</kbd>(<code>kbd-macro-query</code>)を使用したときも、再帰編集レベルが使用されます。
</p>
<dl>
<dt id="index-recursive_002dedit">Command: <strong>recursive-edit</strong></dt>
<dd><span id="index-suspend-evaluation"></span>
<p>この関数はエディターコマンドループを呼び出す。これはユーザーに編集を開始させるために、Emacsの初期化により自動的に呼び出されるLispプログラムから呼び出されたときは、再帰編集レベルにエンターする。
</p>
<p>カレントバッファーが選択されたウィンドウのバッファーと異なる場合、<code>recursive-edit</code>はカレントバッファーの保存とリストアを行う。それ以外では、バッファーを切り替えた場合には、<code>recursive-edit</code>がリターンした後その切り替えたバッファーがカレントになる。
</p>
<p>以下の例では、関数<code>simple-rec</code>が最初にポイントを1単語分進めてからメッセージをエコーエリアにプリントして再帰編集にエンターする。その後ユーザーは望む編集を行い、<kbd>C-M-c</kbd>をタイプすれば再帰編集をexitして、<code>simple-rec</code>の実行を継続できる。
</p>
<div class="example">
<pre class="example">(defun simple-rec ()
  (forward-word 1)
  (message &quot;Recursive edit in progress&quot;)
  (recursive-edit)
  (forward-word 1))
     &rArr; simple-rec
(simple-rec)
     &rArr; nil
</pre></div>
</dd></dl>

<dl>
<dt id="index-exit_002drecursive_002dedit">Command: <strong>exit-recursive-edit</strong></dt>
<dd><p>この関数は最内の再帰編集(ミニバッファー入力を含む)からexitする。関数の実質的な定義は<code>(throw 'exit nil)</code>である。
</p></dd></dl>

<dl>
<dt id="index-abort_002drecursive_002dedit">Command: <strong>abort-recursive-edit</strong></dt>
<dd><p>この関数は、再帰編集をexitした後に<code>quit</code>をシグナルすることにより、最内の再帰編集(ミニバッファー入力を含む)を要求したコマンドをabortする。関数の実質的な定義は<code>(throw
'exit t)</code>である。<a href="Quitting.html#Quitting">quit</a>を参照のこと。
</p></dd></dl>

<dl>
<dt id="index-top_002dlevel">Command: <strong>top-level</strong></dt>
<dd><p>この関数はすべての再帰編集レベルをexitする。これはすべての計算を直接抜け出してメインのコマンドループに戻り、値をリターンしない。
</p></dd></dl>

<dl>
<dt id="index-recursion_002ddepth">Function: <strong>recursion-depth</strong></dt>
<dd><p>この関数は再帰編集のカレントの深さをリターンする。アクティブな再帰編集が存在しない場合は、0をリターンする。
</p></dd></dl>




</body>
</html>
