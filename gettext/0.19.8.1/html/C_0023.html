<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>GNU gettext utilities: C#</title>

<meta name="description" content="GNU gettext utilities: C#">
<meta name="keywords" content="GNU gettext utilities: C#">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Program-Index.html#Program-Index" rel="index" title="Program Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="List-of-Programming-Languages.html#List-of-Programming-Languages" rel="up" title="List of Programming Languages">
<link href="gawk.html#gawk" rel="next" title="gawk">
<link href="Java.html#Java" rel="prev" title="Java">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="C_0023"></a>
<div class="header">
<p>
Next: <a href="gawk.html#gawk" accesskey="n" rel="next">gawk</a>, Previous: <a href="Java.html#Java" accesskey="p" rel="prev">Java</a>, Up: <a href="List-of-Programming-Languages.html#List-of-Programming-Languages" accesskey="u" rel="up">List of Programming Languages</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Program-Index.html#Program-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="C_0023-1"></a>
<h4 class="subsection">15.5.12 C#</h4>
<a name="index-C_0023"></a>

<dl compact="compact">
<dt>RPM</dt>
<dd><p>pnet、pnetlib 0.6.2以降、またはmono 0.29以降
</p>
</dd>
<dt>ファイル拡張子</dt>
<dd><p><code>cs</code>
</p>
</dd>
<dt>文字列構文</dt>
<dd><p><code>&quot;abc&quot;</code>, <code>@&quot;abc&quot;</code>
</p>
</dd>
<dt>gettextの略記</dt>
<dd><p>_(&quot;abc&quot;)
</p>
</dd>
<dt>gettext/ngettext関数</dt>
<dd><p><code>GettextResourceManager.GetString</code>,
<code>GettextResourceManager.GetPluralString</code>
<code>GettextResourceManager.GetParticularString</code>
<code>GettextResourceManager.GetParticularPluralString</code>
</p>
</dd>
<dt>textdomain</dt>
<dd><p><code>new GettextResourceManager(domain)</code>
</p>
</dd>
<dt>bindtextdomain</dt>
<dd><p>&mdash;<br>
実行可能ファイルを含むディレクトリーのサブディレクトリーにコンパイルされたmessage catalogが配置されます
</p>
</dd>
<dt>setlocale</dt>
<dd><p>自動
</p>
</dd>
<dt>必要条件</dt>
<dd><p>&mdash;
</p>
</dd>
<dt>GNU gettextの使用またはエミュレート</dt>
<dd><p>&mdash;<br>
C# specific message catalog formatを使用してください
</p>
</dd>
<dt>抽出プログラム</dt>
<dd><p><code>xgettext -k_</code>
</p>
</dd>
<dt>位置の書式</dt>
<dd><p><code>String.Format &quot;{1} {0}&quot;</code>
</p>
</dd>
<dt>可搬性</dt>
<dd><p>完全な可搬性がある
</p>
</dd>
<dt>po-modeでのマーキング</dt>
<dd><p>&mdash;
</p></dd>
</dl>

<p>文字列をインターナショナライズ可能とマークする前に、文字列結合演算子を使って、<code>String.Format</code>呼び出しで変換が必要な文字列を結合してください。たとえば<code>&quot;file
&quot;+filename+&quot; not found&quot;</code>は、<code>String.Format(&quot;file {0} not found&quot;,
filename)</code>となります。これを行った後のみ、文字列をマークして抽出することが可能になります。
</p>
<p>GNU
gettextは、<code>ResourceManager</code>および<code>ResourceSet</code>という名前の、C#/.NET本来のインターナショナリゼーション
メカニズムを使います。アプリケーションは<code>ResourceManager</code>のメソッドを使って、母国語に翻訳された文字列を取得します。メッセージカタログファイルをインメモリーに展開したものが、<code>ResourceSet</code>のインスタンスです。<code>ResourceManager</code>は、翻訳を検索する必要が生じると、<code>ResourceSet</code>のインスタンスをロード・アクセスします。
</p>
<p>C#のランタイムが直接ロードできる<code>ResourceSet</code>には、<code>.resources</code>ファイル、および<code>.dll</code>ファイルという、2つの形式があります:
</p>
<ul>
<li> <code>.resources</code>の形式はバイナリーのファイルで、通常は<code>resgen</code>または<code>monoresgen</code>ユーティリティーにより生成され、この形式はplural
formをサポートしません。<code>.resources</code>は、.NETの<code>.exe</code>ファイルに埋め込むこともできます。これは、メッセージカタログをロードするためにファイルシステムにアクセスするかどうかに影響を及ぼすだけで、メッセージカタログの内容には影響しません。

</li><li> 一方<code>.dll</code>の形式は、ソースコードの<code>.cs</code>からコンパイルされたバイナリーファイルで、plural
formをサポートします(これは以下で記述するように、GNU gettext APIを通じてアクセスすることにより提供されます)。
</li></ul>

<p>これら
.NETの<code>.dll</code>や<code>.exe</code>ファイルは、特定のプラットフォームに限定されたものではないことに注意してください。これらのファイル形式、およびC#のためのGNU
gettextは、任意のプラットフォームで使用できます。
</p>
<p><code>msgfmt</code>プログラムに&lsquo;<samp>--csharp-resources</samp>&rsquo;オプションを指定することにより、POファイルを<code>.resources</code>ファイルに変換できます。また、<code>msgunfmt</code>プログラムに&lsquo;<samp>--csharp-resources</samp>&rsquo;オプションを指定することにより、<code>.resources</code>ファイルからPOファイルに逆変換できます。これらの処理は、<code>resgen</code>プログラム(<code>pnet</code>パッケージ)や、<code>monoresgen</code>プログラム(<code>mono</code>/<code>mcs</code>パッケージ)でできる場合もあります。これらのプログラムは、<code>.resources</code>ファイルからPOファイルへの逆変換もできます。しかし、この文書を記述している時点(2004年1月)では、<code>monoresgen</code>コンバーターにはバグが多く、<code>resgen</code>コンバーターはPOファイルのエンコーディングを無視することに注意してください。
</p>
<p><code>msgfmt</code>プログラムに<code>--csharp</code>オプションを指定することにより、POファイルを<code>.dll</code>ファイルに変換できます。<code>GettextResourceSet</code>(このクラスも<code>ResourceSet</code>のサブクラスです)のサブクラスを含んだ、<code>.dll</code>ファイルを得ることができます。また、<code>msgunfmt</code>プログラムに<code>--csharp</code>オプションを指定することにより、サブクラス<code>GettextResourceSet</code>を含む<code>.dll</code>ファイルをPOファイルに逆変換できます。
</p>
<p><code>.resources</code>形式に比べて、<code>.dll</code>形式には、以下のような利点があります:
</p>
<ol>
<li> 自由なローカライズ:
アプリケーションをビルド・配布した後でも、ユーザーは自分の翻訳を自由に追加できます。一方、システムにより提供される<code>ResourceManager</code>のコンストラクターをプログラマーが使った場合、アプリケーション用の一連の<code>.resources</code>ファイルは、アプリケーションのビルド時に指定しなければならず、後から拡張はできません。

</li><li> Plural の処理:
<code>.dll</code>形式のメッセージカタログは、pluralを処理するための関数<code>GetPluralString</code>をサポートします。一方、<code>.resources</code>ファイルは、含まれているデータと、単一の文字列にもとづく検索だけをサポートします。

</li><li> Context の処理:
<code>.dll</code>形式のメッセージカタログは、contextにもとづく問い合わせをおこなうための関数<code>GetParticularString</code>および<code>GetParticularPluralString</code>をサポートします。一方、<code>.resources</code>ファイルは、含まれているデータと、単一の文字列にもとづく検索だけをサポートします。

</li><li> <code>GettextResourceManager</code>は、<code>.dll</code>形式の中のメッセージカタログのロードと、メッセージ単位でのロードも提供します。たとえばAustrian(<code>de_AT</code>)のlocaleでは、メッセージがAustrianのメッセージカタログにないときに、German(<code>de</code>)のメッセージカタログが使用されます。つまり、Austrianの翻訳者は、Germanの翻訳とは異なるいくつかのメッセージだけを、Austrianに翻訳する必要があるということです。一方、<code>.resources</code>ファイルでは、各メッセージカタログは、それ自身に含まれるすべてのメッセージの翻訳を提供しなければなりません。

</li><li> <code>GettextResourceManager</code>は、翻訳が見つからないときはEnglishの<var>msgid</var>を戻すというフォールバック付きで、<code>.dll</code>形式のメッセージカタログをロードします。一方、<code>.resources</code>ファイルでは、その<code>.resources</code>が言語中立な場合、フォールバックを明示的に提供しなければなりません。
</li></ol>

<p>プログラム用のAPIという面では、プログラマーは標準の<code>ResourceManager</code> APIと、GNU
<code>GettextResourceManager</code> API
のどちらを使うこともできます。前者の<code>ResourceManager</code>のサブクラスが、後者の<code>GettextResourceManager</code>なので、後者の方が拡張されています。
</p>
<ol>
<li> <code>System.Resources.ResourceManager</code> API

<p>このAPIは、<code>.resources</code>形式のリソースにたいして動作します。
</p>
<p><code>ResourceManager</code>を生成するには、以下のようにします
</p><div class="smallexample">
<pre class="smallexample">  new ResourceManager(domainname, Assembly.GetExecutingAssembly())
</pre></div>

<p><code>GetString</code>関数は、文字列にたいする翻訳を戻します。翻訳がない場合はnullが戻されることに注意してください(例:
これはフォールバックのリソースファイルの場合にも適用されます)。
</p>
</li><li> <code>GNU.Gettext.GettextResourceManager</code> API

<p>このAPIは、<code>.dll</code>形式のリソースにたいして動作します。
</p>
<p>Reference documentationは、<a href="csharpdoc/index.html">csharpdoc
directory</a>にあります。
</p>
<p><code>ResourceManager</code>を生成するには、以下のようにします
</p><div class="smallexample">
<pre class="smallexample">  new GettextResourceManager(domainname)
</pre></div>

<p>このAPIの<code>GetString</code>関数は、翻訳された文字列を戻します。翻訳がない場合には、<var>msgid</var>が変更されずに戻されることに注意してください。
</p>
<p><code>GetPluralString</code>関数は、Cの<code>ngettext</code>関数のように、文字列にたいしてplural処理をした翻訳を戻します。
</p>
<p><code>GetParticularString</code>関数は、Cの<code>pgettext</code>関数のように、特定のcontextが指定された文字列の翻訳を戻します。翻訳がない場合には、<var>msgid</var>が変更されずに戻されることに注意してください。
</p>
<p><code>GetParticularPluralString</code>関数は、Cの<code>npgettext</code>関数のように、特定のcontextが指定された文字列にたいして、plural処理をした翻訳を戻します。
</p>
<a name="index-libintl-for-C_0023"></a>
<p>このAPIを使うために必要なのは、GNU
gettextパッケージの一部である<code>GNU.Gettext.dll</code>だけで、これはLGPLのもとで配布されています。
</p></li></ol>

<p>2つのアプローチをミックスすることもできます:
たとえば<code>GNU.Gettext.GettextResourceManager</code>コンストラクターは使うが、<code>ResourceManager</code>型と<code>GetString</code>メソッドだけを使うような場合です。これはPOファイル用のツールに適合させたいが、<code>ResourceManager</code>を使う既存のソースコードを変更したくなくて、(まだ)<code>GetPluralString</code>メソッドが必要ないときには適しているでしょう。
</p>
<p>2番目のAPIを使うためには、<samp>examples</samp>ディレクトリーの<code>hello-csharp</code>、<code>hello-csharp-forms</code>の2つの例が利用できます。
</p>
<p>ではAPIの使い方と、&lsquo;<samp>GetString</samp>&rsquo;の略記をしてみましょう。以下の3つの用法から選択することができましょう:
</p>
<ul>
<li> あなたのプロジェクトに&lsquo;<samp>Util</samp>&rsquo;という一意なクラスがあるとき、<code>ResourceManager</code>のインスタンスを保持するstaticな変数を定義する場合は、以下のような略記を定義します:

<div class="smallexample">
<pre class="smallexample">public static GettextResourceManager MyResourceManager =
  new GettextResourceManager(&quot;domain-name&quot;);
</pre></div>

<p>そして、インターナショナライズする文字列を含むすべてのクラスに、以下の宣言を含めます
</p>
<div class="smallexample">
<pre class="smallexample">private static GettextResourceManager Res = Util.MyResourceManager;
private static String _(String s) { return Res.GetString(s); }
</pre></div>

<p>これで以下のようにして略記を使うことができます:
</p>
<div class="smallexample">
<pre class="smallexample">Console.WriteLine(_(&quot;Operation completed.&quot;));
</pre></div>

</li><li> resource managerの定義だけを含む、とても短い名前の&lsquo;<samp>S</samp>&rsquo;というクラスを追加して、以下のような略記を定義します:

<div class="smallexample">
<pre class="smallexample">public class S {
  public static GettextResourceManager MyResourceManager =
    new GettextResourceManager(&quot;domain-name&quot;);
  public static String _(String s) {
     return MyResourceManager.GetString(s);
  }
}
</pre></div>

<p>これで以下のようにして略記を使うことができます:
</p>
<div class="smallexample">
<pre class="smallexample">Console.WriteLine(S._(&quot;Operation completed.&quot;));
</pre></div>
</li></ul>

<p>2つの用法のどちらを選ぶかは、すべてのクラスに上記の2行をコピーするのがよいか、それともすべてのクラスに1文字のクラスを追加するのがよいかによります。
</p>
<hr>
<div class="header">
<p>
Next: <a href="gawk.html#gawk" accesskey="n" rel="next">gawk</a>, Previous: <a href="Java.html#Java" accesskey="p" rel="prev">Java</a>, Up: <a href="List-of-Programming-Languages.html#List-of-Programming-Languages" accesskey="u" rel="up">List of Programming Languages</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Program-Index.html#Program-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
